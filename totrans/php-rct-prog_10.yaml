- en: Chapter 10. Using Advanced Operators and Techniques in RxPHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter dedicated to explaining new RxPHP operators. There
    are few topics that didn't fit into any of the preceding chapters, so we'll cover
    them now. A couple of times we'll revisit Observable multicasting from [Chapter
    8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d "Chapter 8. Multicasting
    in RxPHP and PHP7 pthreads Extension") , *Multicasting in RxPHP and PHP7 pthreads
    Extension*, in practical examples and also four new operators, `zip()`, `window()`,
    `materialize()`, and `dematerialize()`, which are more advanced techniques for
    modifying Observable chains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, in this chapter we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The `zip()` and `window()` operators that work with higher-order Observables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `materialize()` and `dematerialize()` operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error propagation in Observable chains and how to properly catch exceptions
    from user-defined callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theory around creating hot/cold Observables and the difference in unsubscribing
    and completing Observable chains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating anonymous operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive `DirectoryIteratorObservable` that emits all files in a
    directory and all its subdirectories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a variant of `DirectoryIteratorObservable` based on multicasting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an FTP client based on RxPHP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxPHP in blocking and synchronous applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've seen so many RxPHP operators throughout this entire book. All of them
    worked with values in some way or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: However, there are also operators that are, in principle, similar to those used
    by hot Observables or cold Observables when testing the RxPHP code that we saw
    in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code") , *Testing RxPHP Code*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The zip() operator
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `zip()` operator is similar to the `ForkJoinObservable` that we implemented
    ourselves in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code"), *Testing RxPHP Code*. The main difference is
    that it internally stores all emissions for each source Observable in a separate
    queue and then re-emits their values when all sources have a value at a specific
    index.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be understood better by looking at the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have three source Observables where each of them emits a different number
    of items. Then the `zip()` operator emits an array of values only when all the
    sources have emissions at the same index. So we know that `DebugSubject` will
    receive only two items because the `$obs2` Observable emits only two items.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the `zip()` operator can't make the third emission because it
    doesn't have a third value for the second `$obs2` Observable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that it contains only the first two values for each source Observable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have a look at another and more complicated example that simulates asynchronous
    emission from multiple source Observables:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since each source Observable emits with a different interval, the `zip()` operator
    will have to emit according to the slowest one, which emits every 1000ms. Values
    for the rest of the Observables are then stacked internally in queues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will print the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we're actually not losing values. All values that weren't re-emitted
    yet are kept inside the `zip()` operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The window() operator
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `window()` operator belongs among the more advanced higher-order Observables.
    We've seen the `switchLatest()` operator in [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, and we know that it automatically subscribes to the
    latest Observable emitted from its source Observable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The exact opposite is the `window()` operator that takes a so called "window
    boundary" Observable as an argument and splits the source emissions into separate
    Observables based on emission from the "window boundary" Observable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will definitely make this more obvious:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have a source Observable emitting 10 items in total. The `window()` operator
    splits them into chunks of three items because of the Observable in the `$windowBoundary`
    variable that we pass as an argument to `window()`. This means that we'll make
    four Observables in total where the first three emit three items (and then complete)
    and the last one just a single item (and then it completes as well).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To make this even more obvious, we added the `doOnNext()` operator to print
    a log every time we create a new Observable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The `switchLatest()` operator is then used to always subscribe only to the latest
    Observable emitted by `window()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'So in the console it''ll look like we split the source into chunks of three
    items. In other words, we split the source into windows of three times:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You're probably wondering what's this all good for. The `window()` operator,
    optionally takes a selector function. This function receives as an argument the
    current window before pushing it to its observers. For us this means that we can
    further chain operators to it before it's passed further, which can be very useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we're in a situation where we're receiving messages of many different
    types, but we want to be able to guarantee that we pass through only one message
    of each type every 100 messages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simulate such a situation by creating a source Observable with 500 items
    where we repeat only three different characters. Then split it into windows with
    100 items each and use the selector function to chain the new window Observables
    with the `distinct()` operator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every Observable emitted by the `window()` operator has its own instance of
    the `distinct()` operator, so after every 100 items we start comparing distinct
    items all over again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'This example prints the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the order of characters is always going to be different because the
    source is generated randomly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We can see that even though each window contains 100 items, these are always
    filtered by the `distinct()` operator that we chained to the window Observable
    in the selector function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `window()` operator definitely falls into the group of more advanced and
    not so common operators in practice. In RxJS 5 there're even more variants of
    this operator for more specific use cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The materialize() and dematerialize() operators
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code") , *Testing RxPHP Code*, when we talked about
    testing in RxPHP, we weren't using real values, and instead were passing some
    special recorded objects that wrapped the actual value with `OnNextNotification`
    (or its `error` or `complete` variants). We did this because of the `TestScheduler`
    class and because we had to be able to uniquely identify each value in order to
    compare object references and not just their values. Comparing just values wouldn't
    guarantee that they are identical because primitive types such as strings or integers
    aren't passed by reference by default.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: There are two operators that use a similar principle. These are `materialize()`
    and `dematerialize()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The first one takes each value, wraps it with a notification object, and re-emits
    it as a typical `onNext` signal. This includes `error` and `complete` signals
    as well. These are wrapped and re-emitted like any other value, and after that
    a complete signal is sent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can completely ignore error signals or handle them as regular
    values. Before we talk more about what we can do with all this, let''s consider
    the following example where we''ll see what the `materialize()` operator actually
    does:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is just a `RangeObservable` that emits three values and then sends complete
    signals. The `materialize()` operator converts each signal into an object, so
    this example will print the following output to the console:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that `DebugSubject` received five signals in total. The first three
    are just numbers emitted by the source `RangeObservable`. Then follows the complete
    signal from the source, wrapped as well, and after that another complete signal,
    but this time emitted by the `materialize()` operator itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s have a look at another example where we emit an error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is very similar to the previous example, but this time we're forcing one
    error signal among normal emissions. As we said, the `materialize()` operator
    wraps the error and then calls `complete`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll see that the wrapped value `4` never arrived
    to `DebugSubject` since it has already unsubscribed because of the `complete`
    signal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So what's all this actually good for when we can't, in fact, skip either the
    `error` or the `complete` signals?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: While `materialize()` wraps signals with a notification object, there's also
    the exact opposite operator called `dematerialize()`. And, of course, we can use
    these two operators independently of each other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Customizing error bubbling with dematerialize()
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that we have an Observable chain that needs to emit multiple errors,
    but it can't decide which of these are severe and need to be propagated further
    down the chain and which can be safely ignored. In a normal Observable chain,
    the first error would cause immediate unsubscription.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: With clever usage of notification objects and the `dematerialize()` operator,
    we can let the error pop up when we want.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we generate a series of nine numbers. Every third
    number is then converted into an error notification. The errors aren't important
    and can be safely ignored. But the sixth number is different, and when it appears
    we always want to signal an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example that generates multiple error signals and wraps
    them with notifications:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example uses `materialize()` at the beginning to convert all values to
    notifications. Then, inside the `map()` operator, we unwrap all notifications
    with their `accept()` method that propagates their value to the appropriate callable
    (it's like calling `subscribe()` on an Observable). This way we can see its value
    and just return it as it is or eventually return `OnErrorNotification` instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is what we wanted to get. None of the errors actually did anything, and
    they were all emitted as a normal `onNext` signal. Note that instead of number
    six we have a `LogicException`. Now the last thing is to filter out all errors
    that are unimportant for us. This means all errors except the single `LogicException`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll prepend the `filter()` and `dematerialize()` operators before the `subscribe()`
    call. We have to use `dematerialize()` to turn notifications to their respective
    signals. So the preceding example will look like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we rerun this finalized example, we''ll get the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the other errors were ignored by the `filter()` operator and the only one
    that was preserved and unwrapped with `dematerialize()` is the `LogicException`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: This method of handling errors is obviously a hack that we typically don't want
    to do, but it's good to know that even this is possible with RxPHP out of the
    box, without creating custom observers or Observables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in RxPHP operator chains
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be wondering why we can't just emit multiple errors from an Observable
    and then use `materialize()` to wrap them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example with `Observable::create` that emits two errors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It might look like this example should wrap all the values and errors into
    notifications because we put the `materialize()` operator right after the `Observable::create`.
    Let''s see what happens when we run this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So why can we only see the emissions up to the first error even though we used
    `materialize()`?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Every time we use `lift()`, we're actually creating a new instance of `AnonymousObservable`.
    This Observable creates an instance of `AutoDetachObserver` internally on subscription,
    and after that, it calls its subscription callable. This `AutoDetachObserver`
    class automatically calls `dispose()` on its internal disposable object (which
    unsubscribes from the source) when it receives the `error` or `complete` signal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Since almost all operators internally use `lift()`, they are also using `AutoDetachObserver`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: This includes `Observable::create()`, which is just a static method that creates
    a new `AnonymousObservable`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: So this is why an Observable can never emit more than one `error` or `complete`
    signal. They will always be ignored because the `AutoDetachObserver` class has
    already unsubscribed when it received the first one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The default error handler
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that each observer can take as an optional parameter an error handler
    that is called on error notification. Although the default behavior is different
    than we might expect. If we do specify the error callable, we can handle the error
    however we want to.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following example where we specify only the error
    handler:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we run this example we''ll see that the handler is called properly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now what happens if don''t set any error handler at all? We can see this situation
    in the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re using the `CallbackObserver` without any parameter, so the following
    output is what we''ll get:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The exception was simply rethrown. We didn't set any error callable, so this
    is probably something we didn't expect to happen. It's good to be aware of this
    behavior because it means that if we don't handle error notifications they might
    cause unexpected script termination.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default error handling is the same in RxJS 5; however, there's an ongoing
    discussion whether this is the correct way Rx should behave. It's likely that
    in the future versions of RxJS this behavior will change.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions inside operators
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A similar principle applies also when calling any user defined functions inside
    an Observable or an operator. For example, when using the `map()` operator the
    callable is wrapped with a try-catch block. Any exception thrown inside our callable
    is then sent as an error notification.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This means that neither Observables nor operators are supposed to throw exceptions
    unless something unexpected occurs that shouldn't happen under normal circumstances.
    Throwing an exception inside a user defined callable is a valid use case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the difference on these two examples. First we''ll throw an exception
    inside the selector function to the `zip()` operator from the same example we
    saw previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The exception will be caught and sent as an error notification:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we will see what happens when we try to use a regular object
    instead of a source Observable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that this type of error is catchable in PHP7:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The exception was left to terminate the script execution because this is a situation
    that shouldn't happen. It probably means that we have a bug in our code where
    we unintentionally wanted to use an `stdClass` instance instead of an Observable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The Observable::create() method versus the Subject class
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from creating custom Observables, we know that we can use the `Observable::create()`
    static method or an instance of the `Subject` class to emit items by ourselves,
    but so far we haven't talked about which one we should choose over the other and
    why.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb it's usually better to use `Observable::create()`. It's not
    always possible, but it has its advantages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next couple of examples, let''s consider that we want to work with
    an API that implements the following interface. This could be any Facebook/Twitter/WebSocket
    or system API:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hot/cold Observables and Observable::create()
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the most general sense an Observable is just a function that connects an
    observer with the producer of values. By producer we understand any source of
    values that is unrelated to RxPHP. For example, this can be any class implementing
    our `RemoteAPI` interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We'll see that this works well with our definitions of hot/cold Observables
    from [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*.
    A cold Observable creates its producer (in our case, connects to the remote API)
    on subscription. This means that we don't want to make any remote calls to the
    API until we have at least one observer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'So a cold Observable internally using the RemoteAPI interface could look like
    the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This fulfills our expectations from a cold Observable. The producer doesn't
    exist until we subscribe and it automatically also closes the connection when
    unsubscribing because we returned the `CallbackDisposable` instance from the callback
    to the `Observable::create()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create a hot Observable with the `Observable::create()` method
    it would be similar, but this time the Observable is not responsible for neither
    creating nor closing the producer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The producer is created independently on the hot Observable and subscribing/unsubscribing
    to it has no effect on the producer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how is this all related to comparing `Observable::create()`
    and the `Subject` class?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The point is that we can't simply do the same with Subjects. We could of course
    use a Subject in this scenario, but than we'd have to handle all subscription
    and unsubscription logic ourselves (including creating/closing the producer).
    Nonetheless, in [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we talked about the internal states in
    Subjects, which is also very relevant here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, every time you end up using a Subject think whether you
    could achieve the same with `Observable::create()` instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，每次你使用Subject时，都要考虑是否可以用`Observable::create()`来实现相同的效果。
- en: Call stack length and EventLoopScheduler
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用栈长度和EventLoopScheduler
- en: When developing PHP applications, it's handy to enable the Xdebug extension
    that we can use to debug our code. However this comes with the cost of reduced
    performance, higher memory usage, and a limited number of possible nested function
    calls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发PHP应用程序时，启用Xdebug扩展很有用，我们可以用它来调试我们的代码。然而，这会带来性能降低、内存使用增加以及可能嵌套函数调用数量的限制。
- en: 'The last issue is relevant to us in particular. For example, in RxPHP when
    we make a long operator chain and use the `ImmediateScheduler` method. Consider
    the following very long chain of operators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题与我们特别相关。例如，在RxPHP中，当我们创建一个长的操作符链并使用`ImmediateScheduler`方法时。考虑以下非常长的操作符链：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This example chains nine operators and then in the observer prints the entire
    call stack. We know that the call stack will start at the subscriber's `onNext`
    handler and traverse upwards via `onNext()` calls to the `RangeObservable` where
    it starts emitting values. Then the stack goes back to the bottom via `subscribe()`
    calls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们链式连接了九个操作符，然后在观察者中打印整个调用栈。我们知道调用栈将从订阅者的`onNext`处理程序开始，通过`onNext()`调用向上遍历到`RangeObservable`，它开始发出值。然后通过`subscribe()`调用将堆栈返回到底部。
- en: 'The shortened output looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 缩短的输出如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see that this call stack contains 103 nested function calls. This would
    be obviously hard to debug, so we can reduce its length by using `EventLoopScheduler`
    instead of `defaultImmediateScheduler`. This will make every callback to the `schedule()`
    method run as a separate event by `EventLoopScheduler`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个调用栈包含了103个嵌套函数调用。这显然很难调试，因此我们可以通过使用`EventLoopScheduler`而不是`defaultImmediateScheduler`来缩短其长度。这将使得每个回调到`schedule()`方法的调用都由`EventLoopScheduler`作为一个单独的事件来运行。
- en: 'We''ll set the Scheduler right in the `Observable::range()` call as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Observable::range()`调用中直接设置调度器，如下所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now when we run this example the call stack will contain only 65 nested calls:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行这个例子时，调用栈将只包含65个嵌套调用：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This obviously comes with a cost, so using the `EventLoopScheduler` class is
    always going to be slower than using the default `ImmediateScheduler`. Also the
    emissions that are wrapped with `schedule()` are called from the event loop and
    not from the place the `schedule()` method was invoked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然会带来一些成本，因此使用`EventLoopScheduler`类总是会比使用默认的`ImmediateScheduler`慢。此外，用`schedule()`包装的排放是从事件循环而不是从调用`schedule()`方法的地方调用的。
- en: This can make debugging even harder, but the `EventLoopScheduler` class is especially
    useful when we don't want to block the execution thread and also want to let other
    code be executed (thanks to its event loop). In [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, we talked about even loops in great detail and how
    it's important not to block the execution thread. In such cases, using `EventLoopScheduler`
    is a very good choice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使调试变得更加困难，但`EventLoopScheduler`类在我们不希望阻塞执行线程，同时还想让其他代码被执行（归功于其事件循环）时特别有用。在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级观察者")中，我们详细讨论了事件循环以及为什么不要阻塞执行线程的重要性。在这种情况下，使用`EventLoopScheduler`是一个非常不错的选择。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using an asynchronous Scheduler is also relevant to RxJS because in a JavaScript
    environment the call stack length is limited.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步调度器对RxJS也很有关系，因为在JavaScript环境中调用栈长度是有限的。
- en: Unsubscribing versus completing an Observable
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅与完成Observable
- en: We know that when we have an observer we'll stop receiving items when the source
    Observable completes or when we manually unsubscribe. However, we haven't talked
    about why we might choose one over the other.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当我们有一个观察者时，当源Observable完成或当我们手动取消订阅时，我们将停止接收项目。然而，我们还没有讨论为什么我们可能选择其中一个而不是另一个。
- en: 'There''re basically two ways to stop receiving items:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种停止接收项目的方法：
- en: Unsubscribe from the source Observable
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源Observable取消订阅
- en: Using an operator that completes the chain (such as the `takeUntil()` operator)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完成链的操作符（如`takeUntil()`操作符）
- en: By unsubscribing we usually mean that we don't want to be receiving items any
    more. This obviously doesn't mean that the source Observable stopped sending items
    or sent the complete notification. We're just no longer interested in the items
    coming from the source.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说取消订阅时，通常意味着我们不再希望接收任何项目。这显然并不意味着源可观察对象停止发送项目或发送了完整的通知。我们只是不再对来自源的项目感兴趣。
- en: 'As an important consequence to manually unsubscribing, the complete handler
    is never called. Consider the following example where we unsubscribe after receiving
    a few items:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为手动取消订阅的重要后果，完整的处理程序永远不会被调用。考虑以下示例，我们在收到几个项目后取消订阅：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we had to use the `EventLoopScheduler` class instead of the default
    one because we need to run the observer callables as separate events in the loop.
    If we used the `ImmediateScheduler` class then the `$subscription` variable would
    always be null because all the callables would be called within the `subscribe()`
    call. In other words, the `$subscription` variable would be unassigned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用 `EventLoopScheduler` 类而不是默认类，因为我们需要在循环中将观察者可调用对象作为单独的事件运行。如果我们使用 `ImmediateScheduler`
    类，那么 `$subscription` 变量将始终为 null，因为所有可调用对象都会在 `subscribe()` 调用中调用。换句话说，`$subscription`
    变量将不会被分配。
- en: 'When we run this demo we can see that it prints the first three items and then
    ends and no complete handler was called:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个演示时，我们可以看到它打印了前三个项目然后结束，并且没有调用完整的处理程序：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But what if we''re in a situation where the complete handler is important and
    we always want to call it when we unsubscribe? In such cases we can use any operator
    that sends a complete notification, for example, `takeUntil()` and an instance
    of the `Subject` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们处于一个完整的处理程序很重要且我们总是希望在取消订阅时调用它的情境中呢？在这种情况下，我们可以使用任何发送完整通知的操作符，例如 `takeUntil()`
    和 `Subject` 类的实例：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're using the `$subject` variable to notify the `takeUntil()` operator that
    we want to complete and then manually call the `onNext()` method inside a callable
    passed to the `CallbackObserver` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `$subject` 变量来通知 `takeUntil()` 操作符我们想要完成，然后在传递给 `CallbackObserver` 类的可调用对象内部手动调用
    `onNext()` 方法。
- en: 'This way we ensured that apart from just unsubscribing the observer, we''ll
    also call the complete handler, as we can see from the console output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们确保了，除了取消观察者的订阅外，我们还会调用完整的处理程序，正如我们从控制台输出中可以看到的那样：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Whether we want to simply unsubscribe or send the complete notification is up
    to us. A big advantage of using a `Subject` class and the `takeUntil()` operator
    is that we can easily complete multiple chains by using a single `onNext()` call.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是想简单地取消订阅还是发送完整的通知，这取决于我们。使用 `Subject` 类和 `takeUntil()` 操作符的一个大优点是，我们可以通过使用单个
    `onNext()` 调用来轻松完成多个链。
- en: If we wanted to just unsubscribe multiple chains, then we'd have to collect
    and keep all their disposables and then call `dispose()` on all of them manually.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想取消多个链的订阅，那么我们就必须收集并保留它们的所有可处置对象，然后手动在它们上面调用 `dispose()`。
- en: Anonymous operators
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名操作符
- en: We've been using the `lift()` method to use custom operators in Observable chains
    a lot. In RxPHP v1, it's also the only way to implement custom operators. This
    method takes as a parameter the so called **operator factory**, which is a callable
    that returns an instance of the operator we want to use. This method is called
    every time we subscribe, so it might be called just once in total.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在大量使用 `lift()` 方法在可观察对象链中使用自定义操作符。在 RxPHP v1 中，这也是实现自定义操作符的唯一方式。该方法接受所谓的
    **操作符工厂** 作为参数，这是一个返回我们想要使用的操作符实例的可调用对象。该方法在每次订阅时都会被调用，所以它总共可能只被调用一次。
- en: When using operators, we're making use of PHP's magic `__invoke()` method that
    allows us to use any object just as if it were a function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用操作符时，我们利用了 PHP 的魔法 `__invoke()` 方法，它允许我们像使用函数一样使用任何对象。
- en: 'Let''s consider this simple example that shows the `__invoke()` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的示例，它展示了 `__invoke()` 方法：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We make an instance of `MyClass` that we used as if it was a regular function
    with `$obj(3,4)`. If we run this example, we''ll get the correct result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `MyClass` 的实例，我们像使用常规函数一样使用 `$obj(3,4)`。如果我们运行这个示例，我们会得到正确的结果：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Operators in RxPHP use the same principle. In fact the `lift()` method is deep
    inside the `Observable` class, defined as the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 中的操作符使用相同的原理。实际上，`lift()` 方法深深嵌套在 `Observable` 类中，定义如下：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The callable `$operatorFactory` doesn't need to return an operator object at
    all. It can just return another callable that'll take three arguments and do whatever
    it wants to. This is useful when we want to do a one-time operation where it doesn't
    make sense to make it reusable and write a custom operator for it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can make the same operations on the source Observable and the
    observer just like in any other operator class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we have a `$prevValue` variable that is kept in this context, and
    we can use it among all invocations of the `onNext` signals.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom DirectoryIteratorObservable
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used a couple of `DirectoryIterators` to recursively
    get all files in a directory and all its subdirectories. When iterating files,
    we might want to filter not only by filenames, but also by file size or access
    restrictions. Ideally, we could have a custom Observable that just checks the
    files names to match a certain pattern and then emits `SplFileInfo` objects so
    we can implement our filtering logic ourselves.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we''ll write our own `DirectoryIteratorObservable` that does
    all this and has some extra options on top of that. We can split the implementation
    into two smaller chunks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're still using `RecursiveIteratorIterator` internally; however, we have full
    control over it and won't let other developers fiddle with it. Somebody could,
    for instance, use `rewind()` or `seek()` methods and unintentionally move the
    inner pointer, not to mention that using three different iterators to traverse
    a directory structure is a little too much and not easily reusable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: That's why our Observable hides all this from the user and has just a couple
    of input parameters. We definitely want to be able to set a pattern to filter
    files right away. Sometimes we might want to traverse several directories recursively
    and other times just a single directory, so we'll have a separate parameter for
    this. The last behavior we want to be able to modify is what this operator is
    going to emit. By default, it's the `SplFileInfo` object, but if we set a custom
    selector function we can emit, for example, just the file names.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The main logic is in the `subscribe()` method, which is built around a `scheduleRecursive()`
    method from the `Scheduler` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in RxPHP v2 the `subscribe()` method doesn't take the `Scheduler`
    as a parameter. This means that we'd access the `Scheduler` class directly with
    the `Scheduler::getImmediate()` static method instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We're looping over all values produced by the iterator and emitting them until
    we reach the end, where we emit just the complete signal. Note that we're wrapping
    the call to the selector function, so if it throws an exception we'll emit it
    as an `error` signal.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this Observable on the same directory structure from the Symfony3
    template, as we did in the previous chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will print a very long list of file names (when `SplFileInfo` objects are
    type-casted to strings they return only filenames).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Note that, internally, this Observable works similarly to, for example, `RangeObservable`.
    In fact, it doesn't keep an array of observers and instead immediately emits all
    values to the observer that subscribed (we also move the iterator's inner pointer
    to the start with `rewind()`). The consequences are obvious.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If we subscribe twice to this Observable, it'll loop the entire iterable twice
    as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: DirectoryIteratorSharedObservable
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So this looks like a good use-case for multicasting. Of course, we could append
    the `publish()` operator every time we use `DirectoryIteratorObservable`, but
    this would be error prone as we could easily forget to use it. Instead, we can
    make another Observable that wraps `DirectoryIteratorObservable`, and appends
    the `publish()` operator to it every time:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This Observable is just a wrapper around the original `DirectoryIteratorObservable`,
    which is internally instantiated and then chained with `publish()`. We're purposely
    using `publish()` and not `share()`. The `share()`operator also appends the `refCount()`
    operator, which automatically subscribes/unsubscribes based on the number of observers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This is useful with Observables that need to perform some asynchronous operation,
    such as downloading data (our `CURLObservable`) or running code in parallel (our
    `ThreadPoolOperator`). With Observables that emit all their values immediately
    on subscription, such as `RangeObservable` or our fresh `DirectoryIteratorObservable`,
    it wouldn't work as we expect. All values would be emitted to the first observer
    because of the immediate call to the `connect()` method inside the `refCount()`
    operator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test this operator by subscribing multiple observers and then calling
    the `connect()` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output for this demo will be a list of file names where each of the observers
    will receive a single item at a time from the current directory:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We avoided reemitting the same directory structure for each observer and multicasted
    items from the source with the `public()` operator and manually called the `connect()`
    method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: FTP client with RxPHP
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, let's imagine that we're running an FTP server where we want
    to perform a couple of operations. PHP has built-in support for FTP connections,
    so we don't need to install any extra libraries.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to be able to do some basic operations with an FTP connection while
    utilizing what we know from RxPHP. When working with Observables, most of the
    time we've been using them in operator chains, but Observables can be used as
    asynchronous inputs or outputs as well. When returning a value from an asynchronous
    function, we'd usually use a Promise, but the same principles work with Observables
    too, and we can also benefit from chaining them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Note that all FTP calls in PHP are blocking. Some functions have their non-blocking
    variants, such as functions to upload or download files, but others, such as functions
    that change or list a directory, are always blocking. For this reason, we'll stay
    only with their blocking variants. This way we can handle their correct and error
    states with Observables. This is also going to be a nice example where we can
    use multicasting.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: So this is going to be an example of how to use RxPHP in a synchronous and blocking
    application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll split our first `FTPClient` class into two smaller chunks and see how
    we can implement RxPHP in this use-case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the most basic methods we need. Many FTP functions in PHP return just
    true or false based on whether they succeeded or not. We used this in the constructor
    to throw exceptions if any of these cases fail.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Then there's the first method that returns an Observable. When we want to get
    a list of all the files and directories in a directory, we'll call the `listFiles()`
    method. This method returns an Observable from the array of files it received.
    As we said, FTP functions in PHP are blocking, so we're not calling `ftp_nlist()`
    asynchronously and need to wait until it finishes. The fact that we're returning
    an Observable means that we can feed this Observable into another method in this
    `FTPClient` class that takes an Observable as an argument.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We're purposely using `Observable::defer` in order to postpone the actual network
    request until we subscribe to it. We'll see why this is important when we start
    writing a test application for `FTPClient`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now have a look at three more methods that''ll get the file size, download
    files from the FTP server, or upload files to the server:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last two methods are very similar in principle. They both take an Observable as
    an argument and subscribe to it. Then they create an internal Subject that is
    used to emit successful uploads/downloads and errors. The same Subject is then
    turned into an Observable with an `asObservable()` operator and returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: What's interesting with this approach is that we don't need to know which files
    we want to download/upload in advance. In other words, we can call these methods
    with instances of Subject and just carry on executing our code. Then, sometime
    later, we can start pushing items to these Subjects, which will cause the files
    to be downloaded/uploaded. We'll see this in a moment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented the `size()` method that takes as an argument an Observable
    and subscribes to it. This method is internally implemented with `Observable::create()`
    for the same reason as `listDir()`. We want to defer emitting any values until
    there's at least one subscription.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start using this class in a simple demo application that''ll first
    just connect to an FTP server, list all files and directories, and then try to
    change the current directory to the last one in the list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We're using `listDir()` to get the content of the current directory, which is
    the root directory for this user. Then we take just the last item and try to go
    inside that directory. We used the `ftp_nlist()` function internally in `listDir()`
    where it returns all files and directories together, so how do we know that the
    last item in the list is really a directory and not a file?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'If it was a file, then the call to `chdir()` would throw an exception. A simple
    way to distinguish files from directories is by checking their size. Directories
    always have a size of `-1`, while ordinary files have a real size that is always
    greater or equal to `0`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This demonstrates very well what we talked about. We have a Subject that we
    pass as an argument to the `size()` method. This method is not going to subscribe
    to it until its own chain has an observer, which happens on the last line with
    `DebugSubject`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We're still not calling any `ftp_size()` because the `Subject` class in the
    `$getFileSizesSubject` variable hasn't emitted any items yet. This happens when
    we call `listDir()`, which itself first calls `ftp_nlist()` to get a list of all
    files and directories and then starts emitting items to the `Subject` class, which
    then simply takes the item and re-emits it to its own observer, which is the callable
    inside the `size()` method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Since `size()` is based on `Observable::create()` and `subscribe()` methods,
    it doesn't make any network calls until we start sending it items. This might
    happen any time after we called it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This all might look a little confusing, but all we're doing is just passing
    items between a couple of Observables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Another obvious use-case could be listing only files in a directory and then
    downloading all of them. We have two methods that require an Observable as a source
    of files. With `size()` they will be checked for their file size (to see whether
    they're files at all) and for `download()` to download them. Of course, we don't
    want to make two separate calls for each of these methods, so we'll use the output
    from the Observable with only files (that is, the `$fileSizes` variable) as the
    source Observable for the `download()` method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make this example a little more complicated, we''ll assume that
    we want to use the list of files once more and, for example, just print the file
    names and their sizes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `$filesToDownload` variable, we're storing a predefined chain of operators
    that emits only file names coming from `$fileSizes`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this demo application, we''ll get the following output (depending
    on the FTP server we are connected to):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see that both Observables based on emissions from `$fileSizes` are sharing
    the same connection (the `doOnNext()` operator is called just once for each item).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also create methods listing only files or only directories. This could
    look like the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These both use the same principle as postponing subscriptions, as we explained
    previously.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a couple of slightly unusual examples that are possible
    with RxPHP, and which didn't fit into any of the previous chapters. These aren't
    things that we use on a daily basis, but it's good to know that features such
    as these are possible.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we went through the operators `zip()`, `window()`, `materialize()`,
    and `dematerialize()`. We saw how to propagate and handle errors in Observable
    chains and what role `AutoDetachObserver` has. Also, we compared the `Observable::create()`
    static method and the `Subject` class and when unsubscribing and completing an
    Observable chain. Apart from this, we created anonymous operators and wrote the
    `DirectoryIteratorObservable` class that recursively iterates a directory structure.
    Finally, we used RxPHP to make a simple FTP client that uses Observables for inputs
    and outputs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we're going to talk about implementations of Reactive Extension
    in languages other than PHP. Most notably, we'll have a look at RxJS-what it is,
    how it's related to RxPHP, and what differences we can encounter in a JavaScript
    environment from PHP.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Appendix.  Reusing RxPHP Techniques in RxJS
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this entire book, we've mentioned very often that certain functionality
    (such as operators or certain Observables) work differently in RxPHP and RxJS.
    Some operators from RxJS aren't even available in RxPHP yet. There're also features
    of RxJS that aren't even possible to make in RxPHP because of the nature of PHP
    interpreter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We've referred to RxJS a lot even though Reactive Extensions were first developed
    for .NET as Rx.NET.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to focus on the differences between current RxPHP
    and RxJS. Also, the knowledge of RxJS is very useful today because its popularity
    is still rising thanks to JavaScript frameworks such as Angular 2 that heavily
    rely on RxJS.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are going to be a little unusual because these
    will combine PHP and JavaScript (ECMAScript 6 - ES6, in particular):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: We'll see what RxJS is, and we'll talk about where it stands in today's world
    of JavaScript
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll write a few very simple demos of RxJS, introducing us to synchronous and
    asynchronous code in JavaScript
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll talk about asynchronous events in JavaScript and how we can benefit from
    them in RxJS
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see how and why higher order Observables behave differently in RxJS and
    RxPHP
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll talk about operators that aren't available in RxPHP right now but are
    fully functional in RxJS
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We expect you to know at least the basics of JavaScript and ideally the new
    ES6 standard (aka ES2015) as well. This isn't required of course since RxJS can
    be used with plain old JavaScript (ES5.1 to be precise), but it's very relevant
    to RxJS and its development process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Also, ES6 is already very well supported by Node.js, so we don't have any reason
    not to use it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you can't get your head around the new ES6 syntax that we'll
    use in this chapter. If you want to know more about ES6, you can have a look at
    a quick summary of the new functionalities it provides at [https://github.com/lukehoban/es6features](https://github.com/lukehoban/es6features)
    .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We're going to run all examples in this chapter by Node.js runtime ( [https://nodejs.org](https://nodejs.org)
    ). If you're not familiar with Node.js, it's basically an environment that uses
    Chrome's V8 JavaScript engine and lets us run JavaScript code from a console.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: What is RxJS?
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very simply, RxJS is an implementation of Reactive Extensions in JavaScript.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now, get ready to get super confused.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Until December 2016, there were two major implementations of RxJS:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**RxJS 4**: This is the older implementation most people are familiar with.
    Its source code is available at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    , and it''s written in JavaScript (ES5). As we said at the beginning of this chapter,
    RxPHP refers at this moment mostly to this older RxJS 4 version that''ll become
    obsolete in the near future.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RxJS 5**: The newer and completely rewritten RxJS that will replace the older
    RxJS 4\. Its source code is available at [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)
    , and it''s completely written in TypeScript 2.0.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we''ve mentioned yet another programming language called TypeScript,
    we should quickly look at what JavaScript versions are actually out there and
    where (and also if) we can use them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**ES5.1**: The good old JavaScript that probably everybody has encountered
    at some point.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ES6** (also named **ES2015**): This is the newer standard of JavaScript.
    It''s backward compatible with ES5.1, and it brings features such as classes,
    generators, arrow functions, and the `let` keyword to create block scoped variables.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ES7** (**ES2016**): This is the even newer standard of JavaScript that brings
    in yet more features such as the `async`/`await` keyword to avoid creating callback
    hells.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: This is a superset of ES6 specification supplemented with type
    checking and is in the latest versions, also with features from ES7 such as the
    `async`/`await` keyword.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So TypeScript was the language of choice for RxJS 5 because of its compatibility
    with ES6 and type checking that helps prevent a lot of bugs in compile time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, while speaking of compiling, we should probably mention where we can
    actually run any of these new and fancy languages:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: ES5.1 is supported by every current browser including mobile browsers and Node.js.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES6 can already be used with the two major JavaScript engines: Chrome''s V8
    and SpiderMonkey (used by FireFox). Although current compatibility with ES6 is
    pretty good (as we can see at [http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    ), it''s still not possible to rely only on ES6 for browser-based applications.
    We obviously need to also support older browsers and mobile devices. For this
    reason, any code written in ES6 needs to be compiled to ES5 using a compiler such
    as babel ( [https://babeljs.io/](https://babeljs.io/) ) or traceur ( [https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)
    ). This doesn''t apply to Node.js where we can freely use ES6 since Node.js v4
    is already pretty old, and the penetration of different Node.js versions isn''t
    such a problem like those we''re used to from web browsers (there''s one important
    exception with ES6 module imports that we''ll mention later).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES7 brings some features that are already implemented natively in JavaScript
    engines (see [http://kangax.github.io/compat-table/es2016plus/](http://kangax.github.io/compat-table/es2016plus/)
    ); however, this is still music of the future. We're not going to use ES7 features
    in Node.js in this chapter, to avoid compiling our code from ES7 to ES6.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript is a relatively new language made by Microsoft and the community
    around it. It's not going to be natively supported by any JavaScript engines.
    It uses different syntax and new keywords that aren't compatible with either ES6
    or ES7\. This means that TypeScript code always needs to be compiled to ES6 or
    more commonly to ES5.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, it's important to note that TypeScript is a superset of ES6\.
    This means that any ES5 or ES6 code is also a valid TypeScript code that makes
    reusing already existing JavaScript very easy.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This is in contrast to other languages that can be compiled to ES5, such as
    Dart made by Google. Dart isn't compatible with JavaScript at all, and basically,
    all code needs to be rewritten to Dart. This might be one of the reasons why TypeScript
    is so popular today despite the fact that it came later than Dart.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: So for this chapter, we're going to use Node.js (ideally, v6.9+, but basically,
    any v4+ should be fine) and ES6.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript module systems
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add to the confusion when talking about current JavaScript standards, we
    should also mention different module systems used today to define dependencies
    between JavaScript files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Working with JavaScript was always tedious because there was never any unified
    way to split code into multiple files and load it on demand or even to bundle
    it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we have nice ES6 syntax for ES6 modules available, let''s consider the
    following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Can you tell in what environment we can run this code natively today?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This was a trick question. We can't run it anywhere because no JavaScript engine
    supports ES6 modules yet, not even Node.js.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to know more about why implementing ES6 modules into Node.js is
    so complicated, read this article by one of the Node.js developers at [https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e](https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e)
    .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Node.js at this moment supports only using the `require()` function to load
    modules in the CommonJS format (in fact, it's not exactly the CommonJS format;
    it's just very close to it). The `require()` function is natively available only
    in Node.js. If we wanted to use `require()` also in the browser, we'd need a polyfill
    or a bundler to merge multiple JavaScript files linked via `require()` calls into
    a single bundle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: If we really wanted to use ES6 module definitions right now, this would be another
    reason we'd have to compile our code. Note that we could actually compile ES6
    code into another ES6 code, only to transform ES6 imports to one of the current
    module formats, such as UMD, CommonJS, AMD, SystemJS, or globals.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: This has been resolved by various bundling tools, such as Browserify, webpack,
    SystemJS-Builder, or rollup.js. However, this just added yet another layer of
    complexity. Moreover, these tools just bundle multiple files into a single bundle.
    If we have a more complicated application where we need to load third-party libraries
    (that can be bundled in any format, which includes even the most basic Angular2
    or React applications) we need to also care about module loaders.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Module loaders are, for example, SystemJS, require.js, require1k, curl.js, and
    probably dozens more.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'This all means that when we start working on a JavaScript project today, we
    need to plan ahead the following four different things:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: What language I'm going to use? this has an effect on the features available
    and also on the compiler you have to use
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To what module format am I going to compile my source code?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What bundling tool I'm going to use?
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How I am going to require my bundled project (by just including it via the `<script>`
    tag or do I need a module loader)?
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, RxJS 4 avoided almost all of this because it's written in ES5\. The only
    necessary task is bundling it into a single file that can be loaded as easily
    as just using the `<script>` tag.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: With RxJS 5, it gets more complicated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The deployment process of RxJS 5
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire RxJS 5 project is written in TypeScript. This means that it needs
    to be compiled to ES5, so we can use it in a browser or in Node.js.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'The process goes as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The entire source code is first compiled to ES6 using the TypeScript compiler
    with the ES6 module resolution.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ES6 code is then compiled again using `closure-compiler-js` made by Google,
    which generates ES5 code.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ES5 code is bundled using rollup.js (before rollup.js, they were using
    Browserify) to create a single UMD bundle.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This bundled file together with ES5 versions of each file along with their source
    maps and `.d.ts` files (TypeScript declaration file) are then uploaded to an npm
    repository. When we use RxJS 5 in, for example, Node.js, we will usually require
    only this single UMD bundle. When using RxJS 5 in a browser, we can just include
    it via the `<script>` tag thanks to the UMD module format.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Universal Module Definition** (**UMD**) is a universal module format that
    acts as AMD, CommonJS, SystemJS, or global depending on the environment loading
    it.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, developing applications in today's JavaScript is no joke. We'll
    see that it also has some benefits. In particular, prototypical-based inheritance
    can ease extending the existing Observables, which isn't possible in PHP for instance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: But before that, let's see how we can use RxJS 5 in Node.js.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to RxJS 5 in Node.js
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're already pretty experienced reactive developers, so none of these examples
    should surprise us.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by installing RxJS 5 via `npm` (basically, a dependency management
    tool similar to Composer in PHP):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As we said earlier, we''re going to use ES6 syntax, but we want to avoid recompiling
    our code because of ES6 imports. That''s why we''ll always use the `require()`
    function to load dependencies. This example should be very simple:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We loaded RxJS 5 with `rxjs/Rx` under the Rx constant. Node.js knows where to
    find the `rxjs` package (it automatically looks for packages into the `node_modules`
    directory). The full name `rxjs/Rx` means that it'll load file from `./node_modules/rxjs/Rx.js`.
    It is like the entry point of this library. It contains a lot of `require()` calls
    and then it exports all the classes we as developers are allowed to use. All these
    classes are then accessible with the `Rx` prefix (for example, `Rx.Subject` or
    `Rx.TestScheduler`).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrow syntax `val => val % 2 == 0` we''re using is just a shortcut to declare
    an anonymous function with a return statement:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The arrow `=>` also makes the inner closure take the `this` context from its
    parent, but we're not going make use of this a lot here.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this demo, we''ll just need Node.js runtime:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Even with this very primitive example, we can already see how different it is
    from PHP. When using Composer, we don't need to worry about where our dependencies
    come from because they're always loaded by the SPL autoloader usually generated
    by Composer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous calls in RxJS
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every time we wanted to make code in PHP asynchronous, we had to stick to event
    loops: in particular, `StreamSelectLoop` and `EventLoopScheduler`, and there was
    no way around it. Every `IntervalObservable` had to take as an argument a Scheduler
    (however, in RxPHP 2 this is done automatically for us so we usually don''t need
    to worry about it).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This is in RxJS, and in general, any JavaScript environment completely different
    from PHP.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that we're using no loops and no Schedulers. In fact in RxJS 5, it's not
    that common for operators to take a Scheduler as an argument. The majority of
    operators don't because they don't need to schedule anything (such as the `map()`
    or `filter()` operators) and usually only those that need to work with timers
    do (basically, all operators containing work "time").
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: This also implies that we don't need to worry about the different parts of our
    application is using different even loops. We discussed this topic in [Chapter
    06](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables") , *PHP Streams API and Higher-Order
    Observables*, and [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, where we saw that this, left unattended,
    may cause deadlocks.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this demo and see ever-increasing counters triggering:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A good question is why is it so simple in JavaScript and yet needs to be so
    complicated in PHP?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and asynchronous events
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is in fact one large event loop based on the libuv library ( [http://docs.libuv.org/](http://docs.libuv.org/)
    ).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example that demonstrates adding a new callback
    to the event loop:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When we run an application in Node.js, it takes our code as a single callback
    and starts executing it. Somewhere in our code, we're calling the `setTimeout()`
    function that takes as argument another callback that will be executed after some
    period of time. However, we called `setTimeout()` without providing any timeout.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This in fact doesn't matter because `setTimeout()` adds the callback to the
    event loop to be run as the last one after all other callbacks are executed. Using
    callbacks, we can easily make Node.js run our code asynchronously. It's also typical
    for Node.js that all system calls are asynchronous and take callbacks as parameters
    in order to be non-blocking.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The output in the console is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can see that the callback was really called after the outer callback got
    finished. When there're no more callbacks in the event loop and no callbacks are
    pending, then Node.js terminates.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Deep inside libuv, there's actually a thread pool that runs in parallel and
    handles system calls that can be run concurrently. Nonetheless, this has no effect
    on our code because Node.js will always execute callbacks one after another. This
    is a huge difference to PHP where none of this exists and the only way to schedule
    asynchronous calls is using custom event loops just like we did with `StreamSelectLoop`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that from our point of view, Node.js is always single threaded
    and strictly sequential. This means that just like in PHP if we write code that
    is blocking, it's going to block the execution thread as well. Node.js never executes
    callbacks in parallel. This of course applies to browser JavaScript environments
    as well.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to run code in parallel, we could spawn subprocesses just like
    we did for example in [Chapter 06](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables") , *PHP Streams API
    and Higher-Order Observables*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Lossy backpressure with the debounceTime() operator
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know what backpressure is already from [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*. A typical use case in RxJS is `debounceTime()`
    that takes a value and then waits until the specified timeout expires before re-emitting
    it further. This is very useful, for example, when creating an autocomplete feature
    where we want to postpone sending AJAX requests when the user is still typing
    into an input field (as we saw in [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming") , *Introduction to Reactive
    Programming*).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at its marble diagram:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Lossy backpressure with the debounceTime() operator](img/00034.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: 'In order to illustrate a practical example of `debounceTime()`, consider the
    following example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This example emits a value every 100 ms and every fifth value is delayed by
    250 ms. That's why most of the values are ignored by `debounceTime()` because
    this operator requires an at least 200 ms long period without any emission from
    the source.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's one very nice practical example for `debounceTime()` that makes use
    of JavaScript's asynchronous callbacks.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter, when talking about reactive programming, we mentioned
    that a common application that we consider "reactive" is Excel. We have multiple
    cells with equations that define their relations and every change to any cell
    is propagated to the entire spreadsheet.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following spreadsheet with three input values `A`, `B`,
    and `C` and the following equations we made on them:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Lossy backpressure with the debounceTime() operator](img/00035.jpeg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: Now, how can we create something similar in RxJS? We can represent each cell
    as `BehaviorSubject` with a default value (we need to use Subjects in order to
    be able to change cell values later). Then, each equation (for example, `A + B`)
    will be held by `combineLatest()`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding spreadsheet could look like this in RxJS:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We're using `combineLatest()` to get notified when any of the source Observables
    for each equation change. We also have multiple `do()` operators to log what's
    going on in our Observable chains.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this demo, we''ll see the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is obviously correct. Each equation was called exactly once.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine that we change the `B` cell value to `4` after the default
    values were propagated. This means that it''ll need to recalculate `AB`, `BC`,
    and `ABBC`. The desired state after updating the `B` cell should look like the
    following screenshot:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![Lossy backpressure with the debounceTime() operator](img/00036.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: 'Append these two lines to the source file:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, rerun the example and pay attention to what equations were evaluated:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first three are alright. Then, we set `B = 4`, which triggers the recalculation
    of `A + B,` and right after that, `AB + BC` equals `10`. Well, this is not correct
    because we haven't updated also `B + C`, which comes next. Then, after updating
    `BC`, the `AB + BC` is recalculated again and the correct value is set to `ABBC`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: We could just ignore this because the result is correct at the end. However,
    if the number of cells and the number of equations grew, then each redundant update
    would still cause an update to the page's DOM. As a result, this could make the
    page laggy and the user might notice the cells blinking.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: So how can we avoid this?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: We said that when `debounceTime()` receives a value, it stores it internally
    and starts a timeout. Then it doesn't re-emit any value until the timeout's callback
    is evaluated, which re-emits only the last value `debounceTime()` received. We
    can use this to our advantage by knowing that we can set `0` timeout, which won't
    delay the callback but just puts in at the end of Node.js's event loop.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, when we use `debounceTime(0)`, we''ll ignore all values that
    `debounceTime()` receives until the end of this callback. So, we can use this
    to calculate `AB + BC`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now if we run the code again, we''ll see the output we wanted:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is definitely an advanced use case that we won't encounter on a daily basis,
    but it's nice to see that we can use JavaScript internals to our advantage.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is something very difficult to do in RxPHP without using an event
    loop and custom operators, yet relatively simple in JavaScript.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order Observables in RxJS 5 and RxPHP
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing browser applications, we very often need to make AJAX calls
    to fetch data asynchronously. For example, in Angular2, this is very common, and
    in fact, any AJAX request made using Angular2's HTTP service returns an Observable
    where we typically chain the `map()` operator to decode JSON and then use `subscribe()`
    to be notified when the response is ready.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simulate such a situation with the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Variable data contains a JSON-serialized array of objects that we decode and
    pass to the observer. The output looks like the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Well, it works, but what if we wanted to receive only objects with the `name`
    property starting with the letter `B`? Right now, we received the entire array
    of objects as a single emission.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: So, the question is how can we unpack the array and emit every single object
    separately?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'One option that can be used in RxJS and RxPHP in exactly the same way is using
    `concatMap()` (`mergeMap()` would work as well) and return a new Observable created
    from an iterable object. In RxJS, this could be as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In RxJS 5, `Observable.from()` takes as a parameter any array-like object and
    emits all its items. In RxPHP, we'd use `Observable::fromArray()` instead.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the output is a single item because the rest was skipped thanks to the
    `filter()` operator:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In RxJS 5, there's also another and quite clever way to achieve the same result.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: We've talked about operators that work with higher-order Observables, such as
    `mergeAll()` or `concatAll()`. These subscribe to an Observable that emits Observables.
    Due to RxJS 5 inner implementation, we can use a little trick and use operators
    that normally work with only higher-order Observables to work with arrays as well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `concatAll()` can be used to achieve the same result as `concatMap()`
    in the preceding example:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: So, this obviously shouldn't work. How can `concatAll()` subscribe to an array?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The answer lies in the way `concatAll()`, and basically, all operators working
    with higher-order Observables internally subscribe to items emitted by the source
    Observable. In PHP, we'd expect that all of them have to be other Observables,
    but this is not the case for RxJS 5.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Some operators in RxJS 5 subscribe to inner Observables via a function named
    `subscribeToResult()` (it's defined in `src/util/subscribeToResult.ts`). This
    function has multiple handlers for different types of items. There's of course
    a handler for Observables, but apart from that, it also knows how to work with
    Promises as well as JavaScript arrays.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: When we used `concatAll()` earlier, the `subscribeToResult()` function just
    iterated the array and re-emitted all its values. Note that it just iterated the
    array internally. It didn't create another Observable from it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: So, these were just two, but useful, differences we can encounter when switching
    from RxPHP to RxJS 5.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Operators specific for RxJS 5
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said, there are extra operators in RxJS 5 that aren't available in RxPHP
    right now. There are in fact, quite of few of them, but many are very similar
    in principle. We mentioned some of them in [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, such as `audit()` or `throttle(),` including
    all their variations that use timeouts or other Observables to create time windows.
    Also, all operators derived from `buffer()` aren't so interesting for us.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We'll have a look at the three of them that serve some other interesting purposes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The expand() operator
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interesting thing about the `expand()` operator is that it works recursively.
    It takes as a parameter a callback that needs to return another Observable. The
    callback is then applied to all values emitted by the returned Observable. This
    goes on as long as the returned Observables emit values.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where we use `expand()` to recursively multiply
    a value by two as long as the result is less than 32:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We stop the recursion by not emitting any value and returning just `Observable.empty()`
    (which emits just a complete signal).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'All intermediate values produced by all the recursive calls are re-emitted
    by `expand()`, so the output from this example will look as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The finally() operator
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, this operator executes its callback on both the `error`
    and `complete` signals. It's important to see the difference between `finally()`
    and just subscribing and using the same callbacks for error and complete signals.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'The `finally()` operator doesn''t turn cold Observables to hot. So, it''s more
    similar to the `do()` operator than to the `subscribe()` method:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The first subscription will receive only the first value and then the `error`
    signal. Note the order in which we used the `finally()` operator and the `subscribe()`
    call. Operator `finally()` comes first so it also receives the error signal first.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The second subscription is analogous. Also, this one uses `onErrorResumeNext()`
    to ignore the error signal (even though it won't receive the last value because
    it has already unsubscribed). It'll receive just the complete signal. Again, note
    where the `finally()` operator is used.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Even though both `finally()` operators are used before `subscribe()` (which
    is obvious because these are operators that need to be somewhere in the chain),
    their callbacks were executed after the error or complete callbacks from `subscribe()`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: This is the fundamental difference of the `do()` operator and also the reason
    why `finally()` might come in handy in certain situations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The withLatestFrom() operator
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, and [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension") , *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we used the `combineLatest()` operator,
    and we mentioned that in RxJS 5, there's also a slightly modified variant.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The `combineLatest()` operator takes multiple source Observables and emits their
    most recent values as an array when any of them emit a value. Then, there's the
    `withLatestFrom()` operator that takes multiple sources as well, but this operator
    emits a value only when its direct predecessor in the chain emits a value (its
    source Observable).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example with multiple timers:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Both `source1` and `source2` emit multiple values every second. However, `withLatestFrom()`
    re-emits their values only when `Observable.interval(1000)` emits a value.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this demo is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Use cases for this operator are very similar to those for `combineLatest()`.
    We just have a better control of the re-emission, which could be useful, for example,
    to implement caching mechanisms where the 1-second interval could control when
    we want to refresh the cache.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: While speaking of caching, we will have a look at the last and very nice example
    in this book.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Caching HTTP requests with publishReplay() and take()
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is my favorite. I show this demo to people who want to start with
    RxJS and they're overwhelmed by the complexity and don't see the practical advantage.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: A very common use case in frontend development is that we need to cache results
    from AJAX calls. For example, we might have a server that we want to query once
    a minute at most. All subsequent calls under one minute won't spawn another AJAX
    call but receive only the cached data.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'This can all be done by leveraging the `publishReplay()` and `take()` operators:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We're creating mock requests with the `mockDataFetch()` function that increments
    the counter every time it's called (this is to make sure that we're not making
    more calls to the server than we think). Then, we delay this Observable to pretend
    it takes some time.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Every time we want to get current data from a cache or from a fresh AJAX request,
    we use the `mockHttpCache()` function that returns an Observable.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we schedule a couple of calls and then make sure
    that this really works as we expect from the console output. After this, we can
    explain why this works:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We're making five requests in total. The first two should receive the same response.
    The next two will receive another response, and the last one will have the third
    response. For illustrational purposes, we're caching responses only for 1 second.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the console output:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: So, it really works as we want; but how?
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The `publishReplay(1, 1000)` operator multicasts responses for 1 second via
    `ReplaySubject` (see [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension") , *Multicasting
    in RxPHP and PHP7 pthreads Extension*, for more info on multicasting). After 1
    second, it discards the stored result.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `mockHttpCache()`, one of these situations occur:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: We subscribe to `ReplaySubject` that already has a cached response. In that
    case, on subscription, it immediately calls `next()` and sends this value to its
    new subscriber. Since there's `take(1)` operator, it passes the value and the
    chain completes. The `ReplaySubject` then checks whether the subscriber has stopped
    after passing it the cached value. Thanks to `take(1)` it does stop, so `ReplaySubject`
    won't subscribe to the deferred Observable.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We subscribe to `ReplaySubject`, but it doesn't have any valid response cached
    and/or it also needs to subscribe to the deferred Observable that triggers a new
    AJAX request. When the request is ready, it's passed down the chain where `take(1)`
    re-emits it and completes.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So this was a pretty short and clever way to make already sophisticated functionality
    that would normally require using at least one `setTimeout()` and at a minimum
    two state variables to keep the cached response and the time it was created.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final chapter was dedicated to RxJS 5 to show that while most principles
    are the same, there are a couple of differences that we can take advantage of.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should know the differences between RxJS 4 and
    RxJS 5, what technologies are used to develop and deploy RxJS 5, how Node.js handles
    asynchronous code, and what operators are present in RxJS 5 already but aren't
    implemented in RxPHP yet.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you'll take the best out of RxJS and RxPHP and use it to write faster
    and more readable code yourself.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
