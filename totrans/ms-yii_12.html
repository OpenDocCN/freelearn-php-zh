<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security"><div class="book" id="27GQ62-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Performance and Security</h1></div></div></div><p class="calibre9">Out of the box, Yii2 is an both a performant and efficient PHP framework. It was designed to<a id="id636" class="calibre1"/> be as fast as possible while still providing a feature-rich toolbox to work with. There are many factors that determine the performance of our application that can negatively affect the performance of our application, such as long running queries and data generation. In this chapter, we'll cover several ways in which we can optimize and fine-tune Yii2 so that our applications remain performant. We'll also cover several important aspects of securing our code.</p></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec69" class="calibre1"/>Caching</h1></div></div></div><p class="calibre9">One <a id="id637" class="calibre1"/>of the easiest ways to improve the performance of our applications is to implement caching. By implementing caching within our application, we can reduce the amount of time it takes to generate and deliver data to our end users. With Yii2, we can cache everything from generated data, database queries, and even entire pages and page fragments. We can also instruct our browsers to cache pages for us. In this section, we'll cover several different caching techniques that we can implement within Yii2 in order to improve the performance of our application.</p></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching">
<div class="book" title="Caching data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec137" class="calibre1"/>Caching data</h2></div></div></div><p class="calibre9">Data caching is<a id="id638" class="calibre1"/> all about storing commonly generated data so that we can generate it once for a given period of time rather than on every request, and in Yii2, it is implemented through the cache component of our application. Yii2 provides a variety of different classes that we can use to cache data, all of which follow and use a consistent API by implementing the <code class="email">yii\caching\Cache</code> abstract class. </p><p class="calibre9">This consistent API enables us to swap out our caching component with any of the caches listed in<a id="id639" class="calibre1"/> the following table without having to make any change to the code within our application:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Cache Name</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Description</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Class reference</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\ApcCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A <a id="id640" class="indexterm"/>cache that uses APC PHP extensions. On a single server configuration, an APC cache is very performant but suffers from compatibility issues if PHP Opcache is enabled.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html">http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\DbCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A <a id="id641" class="indexterm"/>cache that uses a database table to store information.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html">http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\DummyCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A placeholder cache that doesn't do any caching but serves as a standing for a real cache that can be used during development in order to ensure that our applications will work with a real cache.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html">http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\FileCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A<a id="id642" class="indexterm"/> cache that stores data in a file store and is recommended for the storing of pages or page fragments.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html">http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\MemCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">An in-memory cache that uses the PHP memcache or memcached extensions to store data.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html">http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\WinCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A cache that uses the WinCache PHP extension.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html">http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\redis\Cache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A cache that implements the Redis key value store.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-redis-cache.html">http://www.yiiframework.com/doc-2.0/yii-redis-cache.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\XCache</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A cache that uses the XCache PHP extension.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html">http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html</a>
</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip189" class="calibre1"/>Tip</h3><p class="calibre9">While<a id="id643" class="calibre1"/> each cache that's listed implements the <code class="email">yii\caching\Cache</code> API, some caches, such as <code class="email">yii\redis\Cache</code> and <code class="email">yii\caching\MemCache</code>, require some additional configuration. Ensure that you refer to the class reference for the cache you decide to use in your application.</p></div><p class="calibre9">Using <code class="email">yii\caching\FileCache</code> as an example, we can implement caching within our application by adding the following to our application configuration file:</p><div class="note"><pre class="programlisting">&lt;?php return [
    // [...],
    'components' =&gt; [
        // [...]
        <span class="strong"><strong class="calibre2">'cache' =&gt; [</strong></span>
<span class="strong"><strong class="calibre2">            'class' =&gt; 'yii\caching\FileCache',</strong></span>
<span class="strong"><strong class="calibre2">        ]</strong></span>
    ]
];</pre></div><p class="calibre9">After<a id="id644" class="calibre1"/> implementing a specific caching system, we can then use our cache by referencing <code class="email">Yii::$app-&gt;cache</code> within our application code.</p><p class="calibre9">As mentioned previously, each cache implements a consistent API, as defined by the <code class="email">yii\caching\Cache</code> abstract class. Consequently, each cache provides the following methods<a id="id645" class="calibre1"/> that we can use to manipulate the data in our cache.</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Method</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Explanation</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::add()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Stores the value with a given key in the cache if it does not exist. If the cached item exists, no operation will occur.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::get()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Retrieves an item with a given key from the cache.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::set()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Sets an item with a given key into the cache with the option to specify an expiration date. The cached items set with an expiration date will automatically be expunged by either the underlying cache mechanism or by Yii2 itself.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::madd()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Stores multiple items in the cache as a key value array. If a given cache key already exists, nothing will occur.</p>
<p class="calibre22">In Yii 2.1, this method will be marked as deprecated and will be superseded by <code class="literal">yii\caching\Cache::multiAdd()</code>.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::mget()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Retrieves multiple data keys from the cache simultaneously.</p>
<p class="calibre22">In Yii 2.1, this method will be marked as deprecated and will be superseded by <code class="literal">yii\caching\Cache::multiGet()</code>.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::mset()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Sets multiple cached items represented as a key value simultaneously into the cache. The cached items set with an expiration date will automatically be expunged by either the underlying cache mechanism or by Yii2 itself.</p>
<p class="calibre22">In Yii 2.1, this method will be marked as deprecated and will be superseded by <code class="literal">yii\caching\Cache::multiSet()</code>.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::exists()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Returns<a id="id646" class="indexterm"/> <code class="literal">true</code> or <code class="literal">false</code> if a given cache key exists within the cache.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::delete()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Deletes a given cache key from the cache.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\Cache::flush()</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Flushes all the data from the cache.</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip190" class="calibre1"/>Tip</h3><p class="calibre9">For<a id="id647" class="calibre1"/> more information on each method and its use, refer to the noninherited public methods described by the <code class="email">yii\caching\Cache</code> abstract class at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-caching-cache.html">http://www.yiiframework.com/doc-2.0/yii-caching-cache.html</a>.</p></div><p class="calibre9">In<a id="id648" class="calibre1"/> general, our cache can be used by calling any of these methods against our <code class="email">Yii::$app-&gt;cache</code> component, as shown in the following example:</p><div class="note"><pre class="programlisting">$cache = Yii::$app-&gt;cache;
if ($cache-&gt;exists('example'))
    $data = $cache-&gt;get('example');
else
{
    // Generate data here...
    $data = [];
    // Cache the $data for 100 seconds
    $cache-&gt;set('example', $data, 100);
}
return $data;</pre></div><div class="book" title="Caching dependencies"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec51" class="calibre1"/>Caching dependencies</h3></div></div></div><p class="calibre9">In <a id="id649" class="calibre1"/>addition to setting a cache with a given expiration time, we can also cache data with certain dependencies, such as the last modification time of a file of an expression of some kind, and automatically expire our data should that dependency change. Yii2 provides several dependencies that we can use.</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Method</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Explanation</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Class Reference</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\ChainedDependency</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A<a id="id650" class="indexterm"/> dependency that allows us to chain multiple dependencies together and expire a cache item if any of the dependencies fail.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html">http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\DbDependency</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A dependency upon a given SQL query. Should the result of the query change, the cache will be invalidated.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html">http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\FileDependency</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A dependency upon a file based upon the last modification time of the file.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html">http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\ExpressionDependency</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A dependency represented by a Boolean expression.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html">http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\caching\TagDependency</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">A dependency upon an array of tags that can be managed.</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html">http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html</a>
</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip191" class="calibre1"/>Tip</h3><p class="calibre9">Check out the class reference for each dependency for more information on its available properties and methods.</p></div><p class="calibre9">Expanding upon our previous example, we can add a cache dependency, as shown in the following example. In the following code, we create a dependency upon a file called <code class="email">data.csv</code>, which can contain a report or some other data that we wish to generate or import into our application:</p><div class="note"><pre class="programlisting">$cache = Yii::$app-&gt;cache;
if ($cache-&gt;exists('example'))
    $data = $cache-&gt;get('example');
else
{
    // Generate data here...
    $data = [];

    $dependency = new \yii\caching\FileDependency(['fileName' =&gt; 'data.csv']);
    // Cache $data for 100 seconds using the key "example" with a FileDependency
   $cache-&gt;set('example', $data, 100, $dependency);
}
return $data;</pre></div></div><div class="book" title="Database query caching"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch12lvl3sec52" class="calibre1"/>Database query caching</h3></div></div></div><p class="calibre9">With Yii2, we<a id="id651" class="calibre1"/> can also cache the result of a database query. To enable query caching, we need to set three properties within our database component: <code class="email">$enableQueryCache</code>, which toggles the query cache on and off; <code class="email">$queryCacheDuration</code>, which sets the duration queries should be cached for; and <code class="email">$queryCache</code>, which specifies the cache component that should be used.</p><p class="calibre9">The following connection example illustrates how to enable the query cache:</p><div class="note"><pre class="programlisting">&lt;?php return [
    // [...],
    'components' =&gt; [
        // [...]
        'db' =&gt; [
            'class'        =&gt; 'yii\db\Connection',
            'dsn'          =&gt; 'mysql:host='127.0.0.1;dbname=masteringyii',
            'username'     =&gt; '&lt;username&gt;,
            'password'	=&gt; '&lt;password&gt;',
            'charset' 	=&gt; 'utf8',

            <code class="email">'queryCacheEnabled'  =&gt; true,</code>
<code class="email">            // 0 = Never expires</code>
<code class="email">            'queryCacheDuration' =&gt; 0,</code>
<code class="email">            'queryCache'      =&gt; 'cache'</code>
        ],

    'cache' =&gt; [
            'class' =&gt; 'yii\caching\FileCache',
        ]
    ]
];</pre></div><p class="calibre9">After configuring database query caching, we can then cache the results of a single DAO query by <a id="id652" class="calibre1"/>adding or chaining the cache method to our query, as shown in the following example:</p><div class="note"><pre class="programlisting">$duration = 100; // 100 seconds
$results = $db-&gt;createCommand('SELECT * FROM users WHERE id=1;')<span class="strong"><strong class="calibre2">-&gt;cache($duration)-&gt;</strong></span>queryOne();</pre></div><p class="calibre9">Alternatively, if we have multiple queries we'd like to cache, we can call the <code class="email">yii\db\Connection::cache()</code> function directly:</p><div class="note"><pre class="programlisting">$result = $db-&gt;cache(function ($db) {
    $result = $db-&gt;createCommand('SELECT * FROM users WHERE id=1;')-&gt;queryOne();
    return $result;
}, $duration, $dependency);</pre></div><p class="calibre9">
<code class="email">ActiveRecord</code> can also take advantage of query caching by fetching the database component from the <code class="email">ActiveRecord</code> model, as shown in the next example:</p><div class="note"><pre class="programlisting">$result = User::getDb()-&gt;cache(function ($db) {
    return User::find()-&gt;where(['id' =&gt; 5])-&gt;one();
}, $duration, $dependency);</pre></div><p class="calibre9">Moreover, within a query cache, we can exclude certain queries from being cached by chaining the <code class="email">noCache()</code> method to our query, as illustrated by the following examples:</p><div class="note"><pre class="programlisting">$result = $db-&gt;cache(function ($db) {
     // Cache queries in this block

    <span class="strong"><strong class="calibre2">$db-&gt;noCache(function ($db) {</strong></span>
<span class="strong"><strong class="calibre2">        // Do not cache queries in this block</strong></span>
<span class="strong"><strong class="calibre2">    });</strong></span>

    // Don't cache this query either
    $customer = $db-&gt;createCommand('SELECT * FROM users WHERE id=1'<span class="strong"><strong class="calibre2">)-&gt;noCache()</strong></span>-&gt;queryOne();
    return $result;
});</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip192" class="calibre1"/>Tip</h3><p class="calibre9">Some databases such as MySQL have their own built-in caching implemented in the software layer. Implementing both MySQL's native query cache and Yii2's query cache can cause problems in ensuring that the right data is presented. Additionally, any data that is returned as a resource handler cannot be cached by Yii2. Furthermore, some caches, such as <code class="email">Memcache</code>, limit how much data can be associated <a id="id653" class="calibre1"/>with a specific key. Be cognizant of these limitations when using query caching.</p></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching">
<div class="book" title="Fragment caching"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec138" class="calibre1"/>Fragment caching</h2></div></div></div><p class="calibre9">Fragment <a id="id654" class="calibre1"/>caching is built on top of data caching. Fragment caching in Yii2 allows us to cache a fragment of a page and present that cached fragment rather than regenerating the entire contents of the page on every request. In general, we can use fragment caching by wrapping our code in the following block:</p><div class="note"><pre class="programlisting">// $id = ...a unique key...
// $this = ...instance of yii\web\View...;
// Begin our cache and check to see if the data is already cached.
// If content is found, beginCache will output data, otherwise
// the conditional will execute.
if ($this-&gt;beginCache($id))
{
    // Our cached content goes here
    $this-&gt;endCache();
}</pre></div><p class="calibre9">Like data caching, fragment caching has support for several conditions, such as duration, dependencies, variation, and toggling the fragment cache on and off. These conditions can be added as key value arrays to the second parameter of the <code class="email">beginCache()</code> method, as shown in the following example:</p><div class="note"><pre class="programlisting">if ($this-&gt;beginCache($id, [
    // Time we want the fragment cache valid for
    <span class="strong"><strong class="calibre2">'duration'</strong></span> =&gt; 100,

    // Any dependencies we want to add
    <span class="strong"><strong class="calibre2">'dependency'</strong></span> =&gt; [
        'class' =&gt; 'yii\caching\DbDependency',
        'sql' =&gt; 'SELECT MAX(updated_at) FROM user',
    ],

    // Conditionally enable the cache for any boolean value
    <span class="strong"><strong class="calibre2">'enabled'</strong></span> =&gt; Yii::$app-&gt;request-&gt;isGet,

    // Have a variation of this page for every language
    <span class="strong"><strong class="calibre2">'variations'</strong></span> =&gt; Yii::$app-&gt;language	

]))
{
    // Our cached content goes here
    $this-&gt;endCache();
}</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching">
<div class="book" title="Page caching"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec139" class="calibre1"/>Page caching</h2></div></div></div><p class="calibre9">As an<a id="id655" class="calibre1"/> alternative to caching just a fragment of a web page, with Yii2, we can also cache an entire page and serve the cached copy instead of generating the page on every page load. This is exceptionally useful when we have a read-heavy application, such as a blog. Page caching in Yii2 is implemented by adding the <code class="email">yii\filters\PageCache</code> filter to the <code class="email">behaviors()</code> method of our controller, as shown in the following example. Like fragment caching, we can specify variations for our page, dependencies upon which our content should be invalidated, and the duration it should be cached for. Like other filters, we can also specify the actions we want our cache to apply to using the <code class="email">only</code> and <code class="email">except</code> parameters. The following example illustrates the use of page caching:</p><div class="note"><pre class="programlisting">public function behaviors()
{
    return [
        [
            'class' =&gt; 'yii\filters\PageCache',
            'only' =&gt; ['article'],
            'duration' =&gt; 60,
            'variations' =&gt; [
                Yii::$app-&gt;language,
                Yii::$app-&gt;user-&gt;isGuest
            ],
            'dependency' =&gt; [
                'class' =&gt; 'yii\caching\DbDependency',
                'sql' =&gt; 'SELECT MAX(updated_at) FROM articles',
            ],
        ],
    ];
}</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching">
<div class="book" title="HTTP caching"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch12lvl2sec140" class="calibre1"/>HTTP caching</h2></div></div></div><p class="calibre9">Data, fragment, and <a id="id656" class="calibre1"/>page caching are all strategies that we can use to optimize the server-side performance of our application. To further improve the performance of our application, we can also send across headers with our application in order to indicate that we want the client's browser to cache the output of our page. These three headers are <code class="email">Last-Modified</code>, <code class="email">ETag</code>, and <code class="email">Cache-Control</code>. By sending these headers along with our application, we can significantly reduce the number of HTTP requests sent to our application from our clients for pages that don't change often. HTTP caching in Yii2 is implemented by the <code class="email">yii\filtersHttpCache</code> filter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first header, <code class="email">Last-Modified</code>, informs the client about the last time the page was changed. If a client makes a HEAD request to the server and sees that the <code class="email">Last-Modified</code> header differs from what it currently has, it will re-request the page and cache it instead. Otherwise, it will load the page from the client's cache.</li><li class="listitem">The <code class="email">ETag</code> header is used to represent a hash of the tag. Like the <code class="email">Last-Modified</code> header, if the <code class="email">ETag</code> hash changes, the browser knows that it had to re-download the page.</li><li class="listitem">Finally, the <code class="email">Cache-Control</code> header indicates what type of cache the page should be stored in and for how long. By default, Yii2 will send <code class="email">public; max-age: 3600</code> for this header, which will indicate that the client should cache the content for 3600 seconds or 1 hour.<div class="note1" title="Note"><h3 class="title2"><a id="tip193" class="calibre1"/>Tip</h3><p class="calibre9">More<a id="id657" class="calibre1"/> information on the Cache-Control header can be found on the w3c specification reference guide at <a class="calibre1" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p></div></li></ul></div><p class="calibre9">An example illustrating the use of all three of these headers combined is illustrated as follows:</p><div class="note"><pre class="programlisting">public function behaviors()
{
    return [
        [
            'class' =&gt; 'yii\filters\HttpCache',
            'only' =&gt; ['index'],
            'lastModified' =&gt; function ($action, $params) {
                $q = new \yii\db\Query();
                return $q-&gt;from('articles')-&gt;max('updated_at');
            },
            'etag' =&gt; function($action, $params) {
                $article = Article::find()-&gt;where(['id' =&gt; \Yii::$app-&gt;request-&gt;get('id')])-&gt;one();
                return serialize([$article-&gt;title, $article-&gt;content]);
            },
            'cacheControlHeader' =&gt; 'public; max-age:3600'
        ],
    ];
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip194" class="calibre1"/>Tip</h3><p class="calibre9">Note<a id="id658" class="calibre1"/> that for HTTP caching, you only need to specify the headers you want to send. Specifying multiple headers can give you more fine grain control over when caches should be expired.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Performance and Security">
<div class="book" title="Caching">
<div class="book" title="Caching database schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch12lvl2sec141" class="calibre1"/>Caching database schema</h2></div></div></div><p class="calibre9">In <a id="id659" class="calibre1"/>order to make <code class="email">ActiveRecord</code> models work automagically, Yii2 will automatically query the database to determine the schema of our application at the beginning of each query. While useful in a development environment, this operation is unnecessary in production environments where our schema rarely changes. We can tell Yii2 to cache our database schema to improve the performance of our database operations by enabling three properties of database component: <code class="email">$schemeCache</code>, which represents the cache component we want to use; <code class="email">$schemaCacheDuration</code>, which defines how long we want Yii2 to cache our schema; and <code class="email">$enableSchemaCache</code>, which enables or disables the schema cache.</p><p class="calibre9">The following MySQL database component illustrates the use of the schema cache properties:</p><div class="note"><pre class="programlisting">&lt;?php return [
    // [...],
    'components' =&gt; [
        // [...]
        'db' =&gt; [
            'class'        =&gt; 'yii\db\Connection',
            'dsn'         =&gt; 'mysql:host='127.0.0.1;dbname=masteringyii',
            'username'     =&gt; '&lt;username&gt;,
            'password'	=&gt; '&lt;password&gt;',
            'charset' 	=&gt; 'utf8',

            <span class="strong"><strong class="calibre2">'enableSchemaCache'   =&gt; true,</strong></span>
<span class="strong"><strong class="calibre2">            'schemaCacheDuration' =&gt; 0,</strong></span>
<span class="strong"><strong class="calibre2">            'schemaCache' 	      =&gt; 'cache'</strong></span>
        ],

        'cache' =&gt; [
            'class' =&gt; 'yii\caching\FileCache',
        ]
    ]
];</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip195" class="calibre1"/>Tip</h3><p class="calibre9">When<a id="id660" class="calibre1"/> schema cache is enabled, run the <code class="email">cache/flush</code> command after applying new migrations so that Yii2 can pick up your new database structure.</p></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="General performance enhancements" id="28FAO1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec70" class="calibre1"/>General performance enhancements</h1></div></div></div><p class="calibre9">For<a id="id661" class="calibre1"/> considerable performance gains, there are several changes that you can make to your application as well as your web server environment that can significantly increase the performance of your application.</p></div>

<div class="book" title="General performance enhancements" id="28FAO1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Enabling OPCache"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec142" class="calibre1"/>Enabling OPCache</h2></div></div></div><p class="calibre9">Unlike <a id="id662" class="calibre1"/>compiled languages such as C and C++, PHP is an interpreted scripting language. Consequently, every time our web server requests a new page or every time we run a command from our command line, PHP needs to interpret our code into machine code that our servers can actually run. Even if our source code doesn't change, PHP will automatically perform this step on every request. In our development environments, this allows us to simply make a change to our source code, save the file, and then reload it in the page to see our changes. In a production environment, however, this step is unnecessary since our code will only change if we perform a deployment.</p><p class="calibre9">Starting in PHP 5.5, a new tool called OPCache was released by Zend Framework Technologies Ltd and built into the PHP core. Once enabled, OPCache will cache the compiled and optimized opcode that our PHP code is generated from and store it in a shared memory store. If our code is ever run again, OPCache will look inside that shared memory store for our code and execute it rather than re-interpreting our raw source code file. Depending upon the size of our application, enabling OPCache can have significant performance implications for our app. Moreover, since OPCache is now built into PHP, enabling it is fairly simple.</p><div class="note" title="Note"><h3 class="title2"><a id="tip196" class="calibre1"/>Tip</h3><p class="calibre9">Note that Zend OPCache and APCCache both can be configured to cache PHP's opcode. It's highly recommended that you do not run both Zend OPCache and APCCache at the same time as it can cause instability within PHP. As Zend OPCache is maintained by PHP maintainers, it's recommended that you use it instead of APC.</p></div><p class="calibre9">Depending <a id="id663" class="calibre1"/>upon your package managed, OPCache may either be built into your PHP instance or provided as an external extension. A simply way to check whether OPCache is installed or not is to run the following command from your command line:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ php –m</strong></span>
</pre></div><p class="calibre9">If OPCache is installed, you should see <span class="strong"><strong class="calibre2">Zend OPcache</strong></span> appear in the output. If you don't see this output, you'll need to install OPCache from your package manager. Once OPCache is installed, you can enable it by adding the following to your <code class="email">php.ini</code> file or to a file in your PHP INI includes folder and restarting your web server:</p><div class="note"><pre class="programlisting">zend_extension=opcache.so
opcache.enable = true
opcache.enable_cli = true
opcache.save_comments = false
opcache.enable_file_override = true</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip197" class="calibre1"/>Tip</h3><p class="calibre9">When you perform a deployment, you'll need to clear OPCache for your new code to take effect. Typically, this is done by restarting your web server or your PHP<a id="id664" class="calibre1"/> process. Alternatively, you can use a tool such as <code class="email">cachetool</code> (available at <a class="calibre1" href="https://github.com/gordalina/cachetool">https://github.com/gordalina/cachetool</a>) to clear the cache tool. Using a tool like <code class="email">cachetool</code> is beneficial because it allows you to clear your OPCache without restarting your web server and facing potential downtime.</p></div></div></div>

<div class="book" title="General performance enhancements" id="28FAO1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Optimizing Composer dependencies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec143" class="calibre1"/>Optimizing Composer dependencies</h2></div></div></div><p class="calibre9">Another performance change<a id="id665" class="calibre1"/> you can make as part of your deployment is to exclude your development dependencies from your production deployments:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer install --no-dev</strong></span>
</pre></div><p class="calibre9">Since our development dependencies are used in development, loading and registering that code with our application only adds extra overhead to our application.</p><p class="calibre9">Additionally, we can instruct Composer to optimize the autoloader that it generates by running the following command when we install our composer dependencies:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer install –o</strong></span>
</pre></div><p class="calibre9">Alternatively, we can generate an optimized autoloader file after installing our dependencies by running the following command:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer dumpautoload -o</strong></span>
</pre></div><p class="calibre9">By optimizing Composer's autoloader file, we can reduce the number of file and disk lookups with which we need to load our classes in our source code, which in turn will make our application faster.</p></div></div>

<div class="book" title="General performance enhancements" id="28FAO1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Upgrading to PHP 7"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec144" class="calibre1"/>Upgrading to PHP 7</h2></div></div></div><p class="calibre9">At the <a id="id666" class="calibre1"/>time of publication, PHP 7 has been released, and it contains a refactored PHP engine that is able to interpret, compile, and execute the same PHP code with significantly less instructions. By reducing the number of CPU instructions and memory usage, PHP 7 is significantly faster than PHP 5.6. For significant performance gains, consider upgrading your PHP instance from 5.6 to 7.</p></div></div>

<div class="book" title="General performance enhancements" id="28FAO1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Switch to Facebook's HHVM"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec145" class="calibre1"/>Switch to Facebook's HHVM</h2></div></div></div><p class="calibre9">As <a id="id667" class="calibre1"/>an alternative to upgrading to PHP 7, you can consider leaving the PHP engine and switching to HHVM, a reengineered engine for PHP created by Facebook. Like PHP 7, HHVM is significantly faster than PHP 5.6, and for high traffic applications, it can significantly reduce the costs associated with hosting a high traffic application. Unlike PHP 7, however, HHVM doesn't have support for all the PHP modules you may be accustomed to. Moreover, while Yii2 is fully compatible with HHVM, third-party Composer packages may not be, which may cause problems if thorough testing is not performed. For more information on HHVM, check<a id="id668" class="calibre1"/> out the HHVM documentation at <a class="calibre1" href="http://docs.hhvm.com/manual/en/index.php">http://docs.hhvm.com/manual/en/index.php</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Security considerations"><div class="book" id="29DRA2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec71" class="calibre1"/>Security considerations</h1></div></div></div><p class="calibre9">When <a id="id669" class="calibre1"/>using Yii2, it's important to remember to follow security best practices in order to ensure the security of your application, the servers they run on, the data we collect, and our end users who entrust us with this information. In previous chapters, we explored how we can use the <code class="email">yii\base\Security</code> class to safely encrypt and hash data and how to use hazing algorithms such as Bcrypt to secure passwords. In this section, we'll cover some additional security best practices that we can apply when building our applications.</p></div>

<div class="book" title="Security considerations">
<div class="book" title="Certificates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec146" class="calibre1"/>Certificates</h2></div></div></div><p class="calibre9">In almost <a id="id670" class="calibre1"/>every application that Yii2 will be providing the backend for, our clients (browsers or native clients) will communicate with our application over HTTP (Hypertext Transfer Protocol). An easy way to ensure that the information our client submits from their clients reaches our servers in the same state it left in is to encrypt the traffic between our clients and the server with a certificate signed by a trusted certificate authority transmitted over the TLS (Transport Layer Security) protocol.</p><div class="note" title="Note"><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre9">TLS is <a id="id671" class="calibre1"/>the successor to SSL (Secure Sockets Layer), and both are often referred to as SSL certificates. As of 2014, all versions of SSL (1.0, 2.0, and 3.0) have been deprecated due to known security issues with the SSL protocol itself. Its successor, TLS versions 1.1 and 1.2, are not vulnerable and are the recommended protocol to use when encrypting data between clients and servers over HTTP.</p></div><p class="calibre9">Adding a <a id="id672" class="calibre1"/>signed and trusted certificate to our server has several major advantages:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Encrypting data in transit prevents data from being viewed and manipulated by third parties. Health information, credit card information, usernames, and passwords can all be protected by encrypting data while in transit</li><li class="listitem">Clients can pin certificates that we publish so that they know to communicate with us only if our certificate matches the one they have pinned. This prevents Man-in-the-Middle attacks (MITM) and prevents others from learning about our data. Additionally, when using pinned certificates, our clients will know not to communicate with servers masquerading as ours. Again, this protects us and our users</li><li class="listitem">Search engines such as Google and Bing give higher rankings to sites that use TLS</li><li class="listitem">Implementing TLS in our web server is a simple task, and on modern computers, it incurs almost no overhead</li></ul></div><p class="calibre9">When implementing TLS, there are several resources you can use to determine the most secure cipher<a id="id673" class="calibre1"/> suites and to verify that your configuration is secure. For instance, the <a class="calibre1" href="https://cipherli.st">https://cipherli.st</a> site provides a list of modern cipher suites for a variety of web servers and configurations. Qualys' SSL Labs site (<a class="calibre1" href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a>) can also give you a complete report of your TLS <a id="id674" class="calibre1"/>configuration and can validate your web server<a id="id675" class="calibre1"/> configuration. Combined, these tools can help better secure your application and infrastructure.</p></div></div>

<div class="book" title="Security considerations">
<div class="book" title="Cookies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec147" class="calibre1"/>Cookies</h2></div></div></div><p class="calibre9">When<a id="id676" class="calibre1"/> retrieving data from cookies using <code class="email">yii\web\Request</code> and <code class="email">yii\web\Response</code>, Yii2 will automatically encrypt your cookie information using your cookie validation key:</p><div class="note"><pre class="programlisting">return [
    // [...],
    'components' =&gt; [
        // [...]
        'request' =&gt; [
            'cookieValidationKey' =&gt; '&lt;your secret key here&gt;',
        ],
    ],
];</pre></div><p class="calibre9">When working with cookies and session cookies, we can take additional protections by adding additional attributes to our cookies, such as <code class="email">yii\web\Cookie::$secure</code> and <code class="email">yii\web\Cookie::$httpOnly</code>. By marking our cookies as <code class="email">secure</code>, we can ensure that our cookies will only be sent over a secure connection, as described in the previous section. Moreover, by setting our cookies to be <code class="email">httpOnly</code>, we can ensure that JavaScript and other web scripting languages cannot read our cookies. By configuring our cookies with these two flags, we can significantly improve the security of our application.</p></div></div>

<div class="book" title="Security considerations">
<div class="book" title="Protecting against cross-site scripting"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec148" class="calibre1"/>Protecting against cross-site scripting</h2></div></div></div><p class="calibre9">As a<a id="id677" class="calibre1"/> general rule of web development, any time we display information submitted by an end user, we should encode it so that we can protect our site and users against XSS or cross-site scripting. XSS occurs when a user submits data that, when displayed on our page, can be interpreted by our browser. This could be something innocuous, such as adding <code class="email">&lt;em&gt;</code> or <code class="email">&lt;b&gt;</code> tags to our markup, or it could be something more sinister, such as injecting a <code class="email">&lt;script&gt;</code> tag that tracks information about the user or redirects them to another site all together. Fortunately, Yii2 provides two ways of working with data submitted by end users that we can display.</p><p class="calibre9">The first method we can use to protect our site from XSS is to encode end user data using the <code class="email">yii\helpers\Html::encode()</code> method, as illustrated in the following example:</p><div class="note"><pre class="programlisting">&lt;?php echo \yii\helpers\Html::encode($data); ?&gt;</pre></div><p class="calibre9">When encoding our data using this method, Yii2 will convert tags such as <code class="email">&lt;</code> and <code class="email">&gt;</code> into HTML-encoded entities that modern browsers know how to display and interpret.</p><p class="calibre9">In the instance where we do want end user data to be displayed as HTML, we can use <code class="email">yii\web\HtmlPurifier::purify()</code> to correctly parse our data with the rich HTML we want without allowing JavaScript code to be injected:</p><div class="note"><pre class="programlisting">&lt;?php \yii\helpers\HtmlPurifier::process($longData);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre9">HtmlPurifier <a id="id678" class="calibre1"/>can be extremely slow even when configured properly. Be sure you understand and configure HtmlPurifier properly before deploying your code as it can significantly hurt the performance of your application. More information on how to configure HtmlPurifier within Yii2 can<a id="id679" class="calibre1"/> be found at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html">http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html</a>, and<a id="id680" class="calibre1"/> HtmlPurifier's complete documentation can be found at <a class="calibre1" href="http://htmlpurifier.org/">http://htmlpurifier.org/</a>.</p></div></div></div>

<div class="book" title="Security considerations">
<div class="book" title="Enabling cross-site request forgery protection"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec149" class="calibre1"/>Enabling cross-site request forgery protection</h2></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">CSRF</strong></span> (<span class="strong"><strong class="calibre2">cross-site request forgery</strong></span>) is another<a id="id681" class="calibre1"/> common <a id="id682" class="calibre1"/>vulnerability that many sites deal with, which Yii2 can help protect us against. When dealing with client requests, we generally assume that the request came from the user himself. With JavaScript, however, we can send false requests in the background without the user's knowledge. These requests can be as simple as logging a user out of a given service without their knowledge or scraping a specific page for information about the user then transmitting it to a malicious server. Yii2 automatically protects<a id="id683" class="calibre1"/> us from CSRF attacks. The only additional protection you can perform is to follow the HTTP specification (such as not allowing state changes on GET requests).</p><div class="note" title="Note"><h3 class="title2"><a id="tip198" class="calibre1"/>Tip</h3><p class="calibre9">Note that there may be many times when CSRF needs to be disabled for one reason or another. Within our controller, we can disable CSRF for specific actions by adding this code within our action by setting <code class="email">Yii::$app-&gt;controller-&gt;enableCsrfValidation</code> to <code class="email">false</code>.</p></div></div></div>
<div class="book" title="Summary" id="2ACBS1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec72" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we covered several different ways in which we can improve and explore the performance of our application and learned how to improve the security of our application. We explored how we can use data, page, fragment, HTTP, database, and schema caching to improve the performance of our application. We also discovered general improvements we can make to Yii2 and PHP in order to make our application run faster. Finally, we discovered several ways in which we can improve the security of our application through the use of certificates, enabling certain cookie attributes, and protecting our site against XSS and CSRF attacks.</p><p class="calibre9">In our final chapter, we'll cover how we can speed up our already fast development time with Yii2, learn how to explore our application through logging, and discover fast and secure ways to deploy our application with almost no downtime or interruption of service.</p></div></body></html>