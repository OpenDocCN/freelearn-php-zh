<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Isolated Component Testing with PHPUnit"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Isolated Component Testing with PHPUnit</h1></div></div></div><p>In this chapter, we will take a closer look at <a id="id202" class="indexterm"/>
<span class="strong"><strong>PHPUnit</strong></span> and how it is handled by Codeception.</p><p>We will start with a brief introduction of the changes that we need to perform before getting into the actual tests, and from there, go through the red, green, and refactor phases to implement the tests and our code and refactor where needed.</p><p>We will introduce basic topics such as testing in isolation, integration tests of the components, and more advanced topics such as <a id="id203" class="indexterm"/>
<span class="strong"><strong>data providers</strong></span>.</p><p>The following topics are covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the work to be done</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">User</code> model</li><li class="listitem" style="list-style-type: disc">Implementing the first unit test</li><li class="listitem" style="list-style-type: disc">Component testing of the model</li><li class="listitem" style="list-style-type: disc">Implementing the <code class="literal">ActiveRecord</code> class and its methods</li><li class="listitem" style="list-style-type: disc">Seeing test passing</li></ul></div><div class="section" title="Understanding the work to be done"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Understanding the work to be done</h1></div></div></div><p>In the scope of our work, we're going to introduce <a id="id204" class="indexterm"/>PHPUnit by first discussing the <code class="literal">User</code> model, how the authentication method works in Yii, and how it's going to be used in our specific case.</p><p>After that, we will sketch our tests to cover all possible uses of the <code class="literal">User</code> class, refactor the model, and then aim to get the test passed.</p><p>The current state of the framework that we have installed is not good enough for the features we want to implement.</p><p>As underlined in the previous chapters, we're going to follow a TDD approach for this first part.</p></div></div>
<div class="section" title="Using the User model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Using the User model</h1></div></div></div><p>Let's<a id="id205" class="indexterm"/> start by having a look at how the <code class="literal">User</code> model is used in Yii.</p><p>You can open the file located at <code class="literal">/models/User.php</code>.</p><p>The first thing to notice is that the <code class="literal">User</code> class extends from a generic Yii <code class="literal">Object</code> class and implements <code class="literal">IdentityInterface</code>:</p><div class="informalexample"><pre class="programlisting">// User.php

namespace app\models;

use yii\base\Object;
use yii\web\IdentityInterface;

class User extends Object implements IdentityInterface
{
    // ...</pre></div><p>The <code class="literal">yii\base\Object</code> class is the parent class of all classes, which implements the concept of virtual attributes, with the use of dynamically invoked getters and setters, while <code class="literal">yii\web\IdentityInterface</code> provides the signature for methods we need to implement in our class to provide the authentication mechanism.</p><p>You will also notice by the private property <code class="literal">$users</code> that the model does not connect to a database; instead, it holds all the authentication data within the class itself. This has been done on purpose by the Yii developers, in order to have everything working without additional effort. This not only alleviates the problem of massive refactors in case you're not using any authentication in your app, but it's also a good starting point if you need to learn how the authentication works.</p><p>Authentication in Yii is not particularly straightforward, and a lot of the mechanism for authenticating a user is kept hidden from us; so, unless you need to implement some level of robustness in your application, you don't normally have to worry too much.</p><p>Instead, what  is important to notice is that the authentication information is kept in an object, separate<a id="id206" class="indexterm"/> from the <code class="literal">User</code> model. This mechanism provides a separate and clean layer of security. From here, the authentication status is kept into a dynamically loaded class of the <code class="literal">\yii\web\User</code> type, which is accessible throughout the whole life of the application via <code class="literal">Yii::$app-&gt;user</code>. For instance, to check whether the user is logged in, we can do the following:</p><div class="informalexample"><pre class="programlisting">use Yii;

// check the user is logged in
if (!Yii::$app-&gt;user-&gt;isGuest) {
    // do something
}</pre></div><p>This is actually used in several views, and it's clearly similar to what was happening before in Yii 1.</p><p>Having both static and private properties, as is the case with the <code class="literal">$users</code> variable in the <code class="literal">User</code> class, could make the job of testing our class quite hard, if not impossible, at times.</p><p>This is another reason why we need to modify the way it's defined entirely, and instead, the <code class="literal">User</code> class is extended from the <code class="literal">ActiveRecord</code> class and deals directly with the database. With this, we can make use of the fixtures that we can control without having to hardcode configuration settings or parameters in our tests, which could lead to unmaintainable tests, if not pointless ones.</p></div>
<div class="section" title="Implementing the first unit test"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Implementing the first unit test</h1></div></div></div><p>Yii provides an <a id="id207" class="indexterm"/>empty <code class="literal">UserTest</code> class for us, so we're going to start working from there. Head over to <code class="literal">tests/codeception/unit/models/</code> and open the <code class="literal">UserTest.php</code> file.</p><p>So now our question is: what are we going to implement at this point? Well, the answer will be quite simple, once we've understood what the aim of the unit tests is.</p><p>Unit tests, as well as functional and acceptance tests, are a black box testing system: The tests will simply use the interface provided by the object and will make sure that the outputs are as expected. Since the implementation doesn't count if this changes slightly, or even radically, the tests should still pass assuming the interface remained the same.</p><p>White box testing, which is provided by code coverage, will instead ensure that we have covered all the possible branches of our code. We will discuss this further in <a class="link" href="ch08.html" title="Chapter 8. Analyzing Testing Information">Chapter 8</a>, <span class="emphasis"><em>Analyzing Testing Information</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Unit tests also provide support for use cases that will document effectively the use of your interfaces to anyone in or outside your team.</p></div></div><p>So, whether we're starting from scratch, adding new tests, or refactoring some existing ones, we have a few rules to help us achieve as much coverage as possible:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fix the existing broken tests (and raise relevant tickets if not related to our code or if the work ends up being <span class="emphasis"><em>out of scope</em></span>).</li><li class="listitem" style="list-style-type: disc">Implement tests for the new smallest possible unit of code.</li><li class="listitem" style="list-style-type: disc">Make tests independent from each other.</li><li class="listitem" style="list-style-type: disc">Name tests properly. I've started using long names to understand with accuracy what could be wrong depending on which tests were failing, for example, <code class="literal">testMyMethodThrowsAnExceptionWhenInvokedWithNoParameters()</code>; you can clearly use any other naming standards, for instance, using <code class="literal">_</code> as a word separator instead of the camel case; the idea is to keep things readable and maintainable.</li></ul></div><p>We also want to have a few basic rules that could guarantee a 360 degree usage overview so that we can see how to use our component and spot immediately if any of its uses are forbidden, useless, or anything else. These rules are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cover normal usage of the class/method/whatever (positive test).</li><li class="listitem" style="list-style-type: disc">Cover the extraordinary functionality of whatever you're testing, for example, when it returns the exception (in other words, when it should fail) (negative test).</li></ul></div><p>This might be a bit off-putting, and this first step is possibly the most difficult that I've witnessed, on myself and on my colleagues. Countless times I've seen negative tests missing, creating a huge gap of potential vulnerabilities and fragility in the test.</p><p>Don't let yourself down; the reward, as we've seen in <a class="link" href="ch01.html" title="Chapter 1. The Testing Mindset">Chapter 1</a>, <span class="emphasis"><em>The Testing Mindset</em></span>, is priceless.</p><p>As soon as you start, consider yourself a tester, which is the first and most important step for ensuring the quality of the code that you ship, you can see what you've achieved with an improved sense of confidence in your code.</p><div class="section" title="How much to care for other people's code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>How much to care for other people's code</h2></div></div></div><p>Not all the <a id="id208" class="indexterm"/>code you're going to test will be the product of your effort.</p><p>When working with Yii, we will start testing code or integrations with code that comes from Yii itself, or most likely as in a real-world project, from someone else internally or externally from your team.</p><p>Sometimes, it's safe to say that you don't need to test anything that is outside your scope, for many reasons. But, it's also important to understand what the implied risk of not testing these features is.</p><p>Think, for instance, about the password verification of the <code class="literal">User</code> model, which we will be addressing a few pages further on: the possibility of being unable to verify a saved password is something we need to avoid, as its risk could compromise the overall functionality of our application and have as a consequence the inability of the user to log into our application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>As explained in <a class="link" href="ch01.html" title="Chapter 1. The Testing Mindset">Chapter 1</a>, <span class="emphasis"><em>The Testing Mindset</em></span>, and in <a class="link" href="ch02.html" title="Chapter 2. Tooling up for Testing">Chapter 2</a>, <span class="emphasis"><em>Tooling up for Testing</em></span>, <span class="strong"><strong>Attributes-Components-Capabilities</strong></span> (<span class="strong"><strong>ACC</strong></span>) might<a id="id209" class="indexterm"/> be something you should be starting to look into if you need this understanding of the risks related to the piece of functionality that you're building.</p></div></div><p>In our specific case, our tests will be concentrating on bits of functionality provided by the parent class and the interface, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Validating the <code class="literal">User</code> model (this is clearly needed as it's a functionality that is also triggered immediately by the <code class="literal">save()</code> method).</li><li class="listitem" style="list-style-type: disc">Saving the <code class="literal">User</code> model in the database.</li><li class="listitem" style="list-style-type: disc">Covering the basic usage for the functions we will have to implement from the interface.</li></ul></div><p>It should suffice to say that in some cases, this might fall out of scope. If we were taking into consideration the higher level of abstraction from a BDD point of view, the kind of tests we would be interested in would be the interaction with the <code class="literal">User</code> class, as in reading it from the database and how it will be used by other components.</p></div></div>
<div class="section" title="Component testing of the model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Component testing of the model</h1></div></div></div><p>Testing the<a id="id210" class="indexterm"/> validation of a model and any further data manipulation, until it reaches the database and comes back, is the basic step in Yii to ensure that the model has clear and well-defined validation rules implemented. This is effectively useful when it comes down to preventing clients from being able to pass additional or wrong data, when interacting with the system.</p><p>If you care about security, this is something you might need to investigate a bit further, if you haven't done it already.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>I'd like to stress the position we've taken in the previous statement: We're taking the consumer/client perspective. At this particular moment, we don't know how things are going to be implemented, so it's better to focus on the usage of the model.</p></div></div><p>So, let's get back to <code class="literal">/tests/codeception/unit/ models/UserTest.php</code>: The file should already be there, and it's more or less what you would get by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../vendor/bin/codecept generate:phpunit unit models/UserTest</strong></span>
<span class="strong"><strong>Test was created in /var/www/vhosts//htdocs/tests/unit/UserTest.php</strong></span>
</pre></div><p>Right now, if you were to run this command, you would end up with a test that you would need to slightly change, so that we could use the Yii infrastructure. In particular, you would need to change the class your test was extending from with the following:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/UserTest.php
namespace tests\codeception\unit\models;

use yii\codeception\TestCase;

class UserTest extends TestCase
{
}</pre></div><p>In other words, we need to use the provided <code class="literal">\yii\codeception\TestCase</code> class, instead of the PHPUnit default <code class="literal">\PHPUnit_Framework_TestCase</code> class.</p><p>So, let's first sketch down a few tests within our <code class="literal">tests\codeception\unit\models\UserTest</code> class:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/UserTest.php

public function testValidateReturnsFalseIfParametersAreNotSet() {
    $user = new User;
    $this-&gt;assertFalse($user-&gt;validate(), "New User should not validate");
}

public function testValidateReturnsTrueIfParametersAreSet() {
    $configurationParams = [
        'username' =&gt; 'a valid username',
        'password' =&gt; 'a valid password',
        'authkey' =&gt; 'a valid authkey'
    ];
    $user = new User($configurationParams);
    $this-&gt;assertTrue($user-&gt;validate(), "User with set parameters should validate");
}</pre></div><p>As you can see, knowing<a id="id211" class="indexterm"/> what to test requires insight on how Yii works. So, it might be completely fine to actually get the first test sketches completely wrong, if you don't know how things are intended to work.</p><p>In the preceding code snippet, we've defined two tests; the first is what we've called the <span class="emphasis"><em>negative</em></span> and the second is the <span class="emphasis"><em>positive</em></span> one.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Please note that passing the second parameter to the various assert commands will help you debug the tests in case they're failing. Writing a descriptive and meaningful message could save time.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>In the code snippets of this book, the second parameter of the various assert methods will not be passed, in order to keep the code snippets more compact.</p></div></div><div class="section" title="What's testing for PHPUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>What's testing for PHPUnit</h2></div></div></div><p>Before<a id="id212" class="indexterm"/> we continue with the rest of our tests, let's review what we've got up until here: The test file is a class with a name in the <code class="literal">&lt;Component&gt;Test</code> format, which collects all tests relating to the component we want to test; each method of the class is a test of a specific feature, either positive or negative.</p><p>Each method/test in the class should have at least one assertion, and PHPUnit provides a long list of assertion statements that you can trigger to assert that an actual value matches an expected value, together with methods to expect for a specific exception.</p><p>These methods are provided by the parent class <code class="literal">TestCase</code>. You can get the full list at <a class="ulink" href="https://phpunit.de/manual/current/en/appendixes.assertions.html">https://phpunit.de/manual/current/en/appendixes.assertions.html</a>.</p><p>Some basic assertions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertTrue(actualValue)</code> and its opposite <code class="literal">assertFalse(...)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertEquals(expectedValue, actualValue)</code> and its opposite <code class="literal">assertNotEquals(...)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertNull(actualValue)</code></li></ul></div><p>The result<a id="id213" class="indexterm"/> of your test is based on the output of these methods. You should also try to avoid wrapping some assertions within one or more conditions. Think carefully about what you're trying to achieve and what you're actually testing.</p><p>As for exceptions, you need to use some documentation annotation:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>PHPUnit uses documentation annotations extensively to cover what's not normally doable with in-test assertions.</p><p>On top of what we will see, there's plenty of other functionalities, such as testing dependencies with <code class="literal">@depends</code>, <code class="literal">@before</code>, and <code class="literal">@after</code> or grouping with <code class="literal">@group</code>.</p><p>For a full list of annotations <a id="id214" class="indexterm"/>you can use, head over to <a class="ulink" href="https://phpunit.de/manual/current/en/appendixes.annotations.html">https://phpunit.de/manual/current/en/appendixes.annotations.html</a>.</p></div></div><p>Consider the following example:</p><div class="informalexample"><pre class="programlisting">/**
 * <span class="strong"><strong>@expectedException</strong></span> yii\base\InvalidParamException
 */
public function 
testValidatePasswordThrowsInvalidParamExceptionIfPasswordIsIncorrect() {
    $user = new User;
    $user-&gt;password = 'some password';

    $user-&gt;validatePassword('some other password');
}</pre></div><p>On top of <code class="literal">@expectedException</code>, you can also use <code class="literal">@expectedExceptionCode</code> and <code class="literal">@expectedExceptionMessage</code>, in case you need to ensure that the content of the exception is what you are expecting it to be.</p><p>Another way to do this is to use the <code class="literal">setExpectedException()</code> method, which might provide a higher level of flexibility when you have more complex exception cases to deal with.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Although very generic, we can also expect language-specific errors when passing a different type to a method with a typed formal parameter, or when trying to include a non-existing file by using <code class="literal">@expectedException PHPUnit_Framework_Error</code>.</p></div></div><p>Assertion <a id="id215" class="indexterm"/>testing in PHPUnit is quite straightforward once you've got a grip on how your class, model, and method are going to be used.</p><p>On top of this, PHPUnit provides some clever functionality to help us speed up testing and solve some intricacies. Data providers, fixtures, stubs, and mocks will be covered later on and in <a class="link" href="ch05.html" title="Chapter 5. Summoning the Test Doubles">Chapter 5</a>, <span class="emphasis"><em>Summoning the Test Doubles</em></span>.</p></div><div class="section" title="Testing the methods inherited by IdentityInterface"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Testing the methods inherited by IdentityInterface</h2></div></div></div><p>Now that we know<a id="id216" class="indexterm"/> everything we need to in order to start, we would normally decide to implement the rules to make the <code class="literal">testValidateReturnsTrueIfParametersAreSet()</code> and <code class="literal">testValidateReturnsTrueIfParametersAreNotSet()</code>tests pass, although at this occasion, it seems much easier to just continue sketching the remaining methods that we would need to implement later on, such as <code class="literal">getId()</code>, <code class="literal">getAuthKey()</code>, <code class="literal">validateAuthKey()</code>, <code class="literal">findIdentity()</code>, and <code class="literal">findIdentityByAccessToken()</code>, plus two more methods that have been implemented and used already, namely <code class="literal">validatePassword()</code> and <code class="literal">findByUsername()</code>, both used by the <code class="literal">LoginForm</code> model.</p><p>We can immediately decide to get rid of the simplest methods to cover. We're not going to make any use of the access token, and normally, if we weren't forced to implement the method by the interface, we could have just avoided this bit. In this case, instead, we need to get it sorted and the best way to document this missing functionality is to raise <code class="literal">NotSupportedException</code> from the method and expect such an exception:</p><div class="informalexample"><pre class="programlisting">/**
 * @expectedException yii\base\NotSupportedException
 */
public function testFindIdentityByAccessTokenReturnsTheExpectedObject()
{
    User::findIdentityByAccessToken('anyAccessToken');
}</pre></div><p>Following this<a id="id217" class="indexterm"/> method, we test <code class="literal">getId()</code>:</p><div class="informalexample"><pre class="programlisting">public function testGetIdReturnsTheExpectedId() {
    $user = new User();
    $user-&gt;id = 2;

    $this-&gt;assertEquals($expectedId, $user-&gt;getId());
}</pre></div><p>We can use the exact same logic to test <code class="literal">$user-&gt;getAuthkey()</code>.</p><p>While for <code class="literal">findIdentity()</code>, we can do the following:</p><div class="informalexample"><pre class="programlisting">public function testFindIdentityReturnsTheExpectedObject() {
    $expectedAttrs = [
        'username' =&gt; 'someone',
        'password' =&gt; 'else',
        'authkey' =&gt; 'random string'
    ];
    $user = new User($expectedAttrs);

    $this-&gt;assertTrue($user-&gt;save());

    $expectedAttrs['id'] = $user-&gt;id;
    $user = User::findIdentity($expectedAttrs['id']);

    $this-&gt;assertNotNull($user);
    $this-&gt;assertInstanceOf('yii\web\IdentityInterface', $user);
    $this-&gt;assertEquals($expectedAttrs['username'], $user-&gt;username);
    $this-&gt;assertEquals($expectedAttrs['password'], $user-&gt;password);
    $this-&gt;assertEquals($expectedAttrs['authkey'], $user-&gt;authkey);
}</pre></div><p>With <code class="literal">findIdentity()</code>, we<a id="id218" class="indexterm"/> want to make sure the object returned is the one we were expecting, so our assertions ensure that:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">there's a record retrieved</li><li class="listitem">it's of the right class (<code class="literal">IdentityInterface</code> is what most of the methods interacting with the user at authentication time will expect it to be)</li><li class="listitem">it contains what we've passed when creating it</li></ol></div></div><div class="section" title="Using data providers for more flexibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Using data providers for more flexibility</h2></div></div></div><p>The negative<a id="id219" class="indexterm"/> test for <code class="literal">findIdentity()</code> is quite straightforward:</p><div class="informalexample"><pre class="programlisting">public function testFindIdentityReturnsNullIfUserIsNotFound() {
    $this-&gt;assertNull(User::findIdentity(-1));
}</pre></div><p>Implementing a test like this might raise some eyebrows, as we've hardcoded a value, <code class="literal">-1</code>, which might not be representative of any actual real-world case.</p><p>The best way would be to use a <a id="id220" class="indexterm"/>
<span class="strong"><strong>data provider</strong></span>, which can feed our test with a list of values that should make the test pass. This is quite convenient as we can tailor edge cases when it comes down to doing some regression testing on the existing features:</p><div class="informalexample"><pre class="programlisting">/**
 * <span class="strong"><strong>@dataProvider</strong></span> nonExistingIdsDataProvider
 */
public function testFindIdentityReturnsNullIfUserIsNotFound(
    $invalidId
) {
    $this-&gt;assertNull(User::findIdentity($invalidId));
}

public function nonExistingIdsDataProvider() {
    return [[-1], [null], [30]];
}</pre></div><p>In a data provider, each second-level array is a call to the function requesting it and the content of these arrays is the ordered list of the actual parameters of the method.</p><p>So, in our <a id="id221" class="indexterm"/>preceding case, the test will receive <code class="literal">-1</code>, <code class="literal">null</code>, and <code class="literal">30</code> in consecutive invocations.</p><p>If we were to use a data provider for our initial test <code class="literal">testFindIdentityReturnsTheExpectedObject()</code>, we could test whether the username contains UTF-8 or invalid characters, for instance.</p><p>So, using <a id="id222" class="indexterm"/>data providers is a good thing! It gives us the ability to use a single test to check more complex situations that require a certain level of flexibility.</p><p>But here comes the problem: The database that is used during all tests (with <code class="literal">$user-&gt;save()</code>) will continue to grow, as there is no instruction to tell it to do otherwise.</p><p>As a result, we can add the following to the <code class="literal">setUp()</code> function:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/UserTest.php

protected function setUp()
{
    parent::setUp();
    // cleanup the User db
    <span class="strong"><strong>User::deleteAll();</strong></span>
}</pre></div><p>Remember to clean up after yourself: You might be impacting someone else's test. For now, with this call to <code class="literal">deleteAll()</code> in place, we are fine.</p><p>The <code class="literal">setUp()</code> function is called at the beginning before every single test contained in the class. PHPUnit provides several layers of methods for setting things up before one or more tests, and unsetting them after. The sequence of calls can be summed up with the following:</p><div class="informalexample"><pre class="programlisting">tests\codeception\unit\models\UserTest::setUpBeforeClass();
   tests\codeception\unit\models\UserTest::_before();
      tests\codeception\unit\models\UserTest::setUp();
         tests\codeception\unit\models\UserTest::testSomething();
      tests\codeception\unit\models\UserTest::tearDown();
   tests\codeception\unit\models\UserTest::_after();
tests\codeception\unit\models\UserTest::tearDownAfterClass();</pre></div><p>Here, <code class="literal">setUpBeforeClass()</code> is the most external call possible that is run before the class is instantiated. Please also note that <code class="literal">_before</code> and <code class="literal">_after</code> are Codeception <code class="literal">TestCase</code> methods, while the rest are standard PHPUnit methods.</p><p>Since we are here, we<a id="id223" class="indexterm"/> could also add a test-wide <code class="literal">User</code> class that will be instantiated before each test; it can be used by any of our tests. For this to happen, we need to add a private variable and add the related statement, where needed:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/UserTest
/** @var User */
<span class="strong"><strong>private $_user = null;</strong></span>

protected function setUp()
{
    parent::setUp();
    // setup global User
    <span class="strong"><strong>$this-&gt;_user = new User;</strong></span>
    // cleanup the User db
    User::deleteAll();
}</pre></div><p>Now, we just <a id="id224" class="indexterm"/>need to amend the relevant tests to use <code class="literal">$this-&gt;_user</code> when needed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Try to keep private variables and methods clearly visible; this could also help you avoid naming conflicts, as we will see when introducing fixtures.</p></div></div></div><div class="section" title="Using fixtures to prepare the database"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Using fixtures to prepare the database</h2></div></div></div><p>As we've seen, the <a id="id225" class="indexterm"/>data provider solution helps you run the same test with a different dataset each time, which ends up being extremely useful. Another and possibly complimentary solution is to use fixtures that let you preload some well-defined data and keep tests even more simple. This would mean being able to test methods such as <code class="literal">User::findIdentity()</code> without having to rely on <code class="literal">$user-&gt;save()</code>, which is not a part of the test itself.</p><p>Fixtures are used to set the database at a fixed/known state so that your tests can run in a controlled environment. In doing this, we will also eliminate the need to delete all users in the <code class="literal">setUp</code> function or rely on static values that might be influenced by other previously run tests.</p><p>The fixture is just a class that is dynamically loaded in the <code class="literal">setUp()</code> method, and you're left with only the task of creating the fixture class and the actual content for the database.</p><p>Let's start by creating the fixture class:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/fixtures/UserFixture.php
namespace app\codeception\tests\unit\fixtures;

use yii\test\ActiveFixture;
class UserFixture extends ActiveFixture
{
    public $modelClass = 'app\models\User';
}</pre></div><p>In this case, we're <a id="id226" class="indexterm"/>extending from <code class="literal">ActiveFixture</code> as it will provide some additional functionality that might be useful, so the only thing we need to do is to define the model it will mimic. The alternative, as for login forms or other custom-made models, is to extend from <code class="literal">yii\test\Fixture</code>, where you have to define the table name by using the public property <code class="literal">$tableName</code>. With <code class="literal">ActiveFixture</code>, by just defining <code class="literal">$className</code>, the fixture will figure out the table name by itself.</p><p>The next step is to define the actual fixture that will define the content we want to fill into our database. By default, Yii will try to look for a file named <code class="literal">&lt;table_name&gt;.php</code> within the <code class="literal">fixtures/data/</code> folder. The fixture is just a return statement of an array, such as the following:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/fixtures/data/user.php

return [
    'admin' =&gt; [
        'id' =&gt; 1,
        'username' =&gt; 'admin',
        'password' =&gt; Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash('admin'),
        'authkey' =&gt; 'valid authkey'
    ]
];</pre></div><p>Each entry of the fixture can be key-indexed to quickly reference it in our tests. You don't also normally need to specify the primary key as they will be automatically created, as in the case of <code class="literal">ActiveRecord</code>.</p><p>As a last step, we need to implement the <code class="literal">fixtures()</code> method to define which fixtures we want to use in our tests. To do so, we can use the following code:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/UserTest.php

public function fixtures() {
    return [
        'user' =&gt; UserFixture::className(),
    ];
}</pre></div><p>By doing this, our <code class="literal">setUp()</code> method <a id="id227" class="indexterm"/>will initialize the database with the content of the fixture we've just defined. If we were in need to use more than one fixture for the same fixture class, then we could have specified which fixture to load in the current test by also returning a <code class="literal">dataFile</code> key that specified the path of the fixture, as in the following example:</p><div class="informalexample"><pre class="programlisting">public function fixtures()
{
    return [
        'user' =&gt; [
            'class' =&gt; UserFixture::className(),
            'dataFile' =&gt; '@app/tests/codeception/unit/fixtures/data/userModels.php'
        ]
    ];
}</pre></div><p>Now that we have the fixture defined and ready to be used, we can access its content via the <code class="literal">$this-&gt;user</code> variable (and now you can see why it's better to keep private and public variables well defined and separate). You can normally use it as an array and access the index or key you need, or let it return an <code class="literal">ActiveRecord</code> object as with <code class="literal">$this-&gt;user('admin')</code>.</p><p>Now, we can see it in action by refactoring our previously implemented test:</p><div class="informalexample"><pre class="programlisting">public function testFindIdentityReturnsTheExpectedObject() {
    $expectedAttrs = <span class="strong"><strong>$this-&gt;user['admin'];</strong></span>

    /** @var User $user */
    $user = User::findIdentity($expectedAttrs['id']);

    $this-&gt;assertNotNull($user);
    $this-&gt;assertInstanceOf('yii\web\IdentityInterface', $user);
    $this-&gt;assertEquals($expectedAttrs['id'], $user-&gt;id);
    $this-&gt;assertEquals($expectedAttrs['username'], $user-&gt;username);
    $this-&gt;assertEquals($expectedAttrs['password'], $user-&gt;password);
    $this-&gt;assertEquals($expectedAttrs['authkey'], $user-&gt;authkey);
}</pre></div><p>This way, we can <a id="id228" class="indexterm"/>carry on with our tests without worrying about calling <code class="literal">save()</code> every time we need to ensure that a record is in the database.</p><p>This also means that we won't need to clean up the database, as the fixture will do so for us:</p><div class="informalexample"><pre class="programlisting">protected function setUp()
{
    parent::setUp();
    $this-&gt;_user = new User;
}</pre></div><p>Following what we just said, it should be quite straightforward to implement tests for <code class="literal">findByUsername()</code> in the same way as we did for <code class="literal">findIdentity()</code>. So, I'll leave this for you as an exercise.</p></div><div class="section" title="Adding the remaining tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Adding the remaining tests</h2></div></div></div><p>By now, we should <a id="id229" class="indexterm"/>have almost all the tests created, apart from the ones covering <code class="literal">validateAuthKey()</code>, which you should be able to implement without any particular problem, and <code class="literal">validatePassword()</code>, which we will take a closer look at in <a class="link" href="ch05.html" title="Chapter 5. Summoning the Test Doubles">Chapter 5</a>, <span class="emphasis"><em>Summoning the Test Doubles</em></span>.</p></div></div>
<div class="section" title="Implementing the ActiveRecord class and its methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Implementing the ActiveRecord class and its methods</h1></div></div></div><p>Now, we can try <a id="id230" class="indexterm"/>the tests and see them not passing before we go through the implementation of the class. So, just run the following command, as we learned in the previous chapter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tests</strong></span>
<span class="strong"><strong>$ ../vendor/bin/codecept run unit</strong></span>
</pre></div><p>It's very probable that the preceding command will fail with the following error:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PHP Fatal error:  Call to undefined method app\models\User::tableName()</strong></span>
</pre></div><p>This is because <a id="id231" class="indexterm"/>our class has not yet been regenerated as <code class="literal">ActiveRecord</code>.</p><p>In the next section, we will start the work of making our tests pass by starting with the migrations to move some information into the database and progress from there.</p><div class="section" title="Dealing with migrations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Dealing with migrations</h2></div></div></div><p>So, the <a id="id232" class="indexterm"/>best step forward is to define a user table in the database, fill it with the data we would need, and then implement the user model on top of it with the required methods from the interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>There is more to be said about <a id="id233" class="indexterm"/>migrations and the documentation about it is being improved and expanded every day. Be sure to head over and have a read for yourself at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-db-migrations.html">http://www.yiiframework.com/doc-2.0/guide-db-migrations.html</a>.</p></div></div><p>Let's start by creating the migration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./yii migrate/create table_create_user</strong></span>
<span class="strong"><strong>Yii Migration Tool (based on Yii v2.0.0-dev)</strong></span>

<span class="strong"><strong>Create new migration '/var/www/vhosts/htdocs/migrations/m140906_172836_table_create_user.php'? (yes|no) [no]:yes</strong></span>
<span class="strong"><strong>New migration created successfully.</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>Now that we have the migration, let's implement the <code class="literal">up()</code> and <code class="literal">down()</code> methods as needed:</p><div class="informalexample"><pre class="programlisting">// migrations/m140906_172836_table_create_user.php

class m140906_172836_table_create_user extends Migration
{
    public function up()
    {
        $this-&gt;createTable('user', [
            'id' =&gt; 'pk',
            'username' =&gt; 'varchar(24) NOT NULL',
            'password' =&gt; 'varchar(128) NOT NULL',
            'authkey' =&gt; 'varchar(255) NOT NULL',
            'accessToken' =&gt; 'varchar(255)'
        ]);

        $this-&gt;insert('user', [
            'username' =&gt; 'admin',
            'password' =&gt; Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash('admin'),
            'authkey' =&gt; uniqid()
        ]);
    }

    public function down()
    {
        $this-&gt;dropTable('user');
    }
}</pre></div><p>We use the <a id="id234" class="indexterm"/>Security component provided by Yii to create the password. There are many other functions that are quite handy and avoid the need to reinvent the wheel.</p><p>Please note that it's important to implement the <code class="literal">down()</code> method correctly and test it before pushing your changes, as it will be fundamental if you need to revert to a previous state of the application, also called a <a id="id235" class="indexterm"/>
<span class="strong"><strong>roll back</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>In addition to <code class="literal">up()</code> and <code class="literal">down()</code>, you can use <code class="literal">safeUp()</code> and <code class="literal">safeDown()</code>, which will allow you to run the migration up or down using transactions, which in turn means that in the case of an error, all prior operations will be rolled back automatically.</p></div></div><p>The migrations are implemented and used in the same way as in the case of Yii 1, and if you've never used them before, they're a great tool as they give you the ability to define specific steps that can be easily missed when deploying your application. The syntax used should also be quite straightforward to understand and the methods self-explanatory: <code class="literal">createTable()</code>, <code class="literal">renameColumn()</code>, <code class="literal">addForeignKey()</code>, and so on.</p><p>Now that we have our migration in place, it's time to apply it by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./yii migrate/up</strong></span>
<span class="strong"><strong>Yii Migration Tool (based on Yii v2.0.0-dev)</strong></span>

<span class="strong"><strong>Creating migration history table "migration"...done.</strong></span>
<span class="strong"><strong>Total 1 new migration to be applied:</strong></span>
<span class="strong"><strong>    m140906_172836_table_create_user</strong></span>
<span class="strong"><strong>Apply the above migration? (yes|no) [no]:yes</strong></span>
<span class="strong"><strong>*** applying m140906_172836_table_create_user</strong></span>
<span class="strong"><strong>    &gt; create table user ... done (time: 0.022s)</strong></span>
<span class="strong"><strong>    &gt; insert into user ... done (time: 0.008s)</strong></span>
<span class="strong"><strong>*** applied m140906_172836_table_create_user (time: 0.585s)</strong></span>
<span class="strong"><strong>Migrated up successfully.</strong></span>
</pre></div><p>Now that we have <a id="id236" class="indexterm"/>the structure and the data in the database, we can start refactoring the model accordingly.</p></div><div class="section" title="The Gii code generation tool"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>The Gii code generation tool</h2></div></div></div><p>Yii <a id="id237" class="indexterm"/>continues to provide and improve its system of code generation tools, particularly <span class="strong"><strong>Gii</strong></span>. Gii <a id="id238" class="indexterm"/>is a code generator<a id="id239" class="indexterm"/> that helps you create the basic code structure for models, controllers, CRUD, modules, and so forth, so that you don't have to think too much about what needs to be done and instead, get to the implementation part as quickly as possible.</p><p>The basic application that we're using comes with Gii (and it's defined as a <code class="literal">require-dev</code> package). And, since in our case we're running the tests in a (virtual) hosted environment, we need to adjust the configuration a little bit; we need to allow our client IP to access the tool:</p><div class="informalexample"><pre class="programlisting">// config/web.php

if (YII_ENV_DEV) {
    // ...
    $config['bootstrap'][] = 'gii';
    $config['modules']['gii'] = [
        'class' =&gt; 'yii\gii\Module',
        'allowedIPs' =&gt; ['127.0.0.1', '::1', '192.168.56.*'],
    ];
}</pre></div><p>
<code class="literal">192.168.56.*</code> should be the default case if you're using VirtualBox.</p><p>Now that we<a id="id240" class="indexterm"/> have made this change, we can <a id="id241" class="indexterm"/>head our browsers to <code class="literal">http://basic.yii2.sandbox/gii</code>. From there, we can click on the <span class="strong"><strong>Model Generator</strong></span> section, where we can create the new model, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B03646_04_01.jpg" alt="The Gii code generation tool"/><div class="caption"><p>The model generator interface</p></div></div><p>When clicking <a id="id242" class="indexterm"/>on the <span class="strong"><strong>Preview</strong></span> button, Gii will <a id="id243" class="indexterm"/>first check whether the file(s) to be generated already exist and give us the opportunity to see the difference and decide whether we want to override the file(s) before we actually hit the <span class="strong"><strong>Generate</strong></span> button.</p><p>Since our <code class="literal">User</code> model is so thin at the moment, we won't have any problems in overwriting it and re-implementing the needed methods ourselves. Just remember to tick the <span class="strong"><strong>Overwrite</strong></span> check box and click on <span class="strong"><strong>Generate</strong></span>. Otherwise, you can just adjust it accordingly with the hints given in the following paragraphs.</p><p>After clicking on<a id="id244" class="indexterm"/> <span class="strong"><strong>Generate</strong></span>, you should be able to see the <span class="strong"><strong>The code has been generated successfully</strong></span> notice at the end of the page.</p><p>Now let's head back to our <code class="literal">User.php</code> class and see what's been changed, and refine the implementation.</p><p>First of all, we will <a id="id245" class="indexterm"/>notice that the class now extends from the <code class="literal">ActiveRecord</code> class; this is the default class for database-facing models. There is a series of default methods already implemented, which we won't need to change. What we would need instead is to make the class implement <code class="literal">IdentityInterface</code>, as follows:</p><div class="informalexample"><pre class="programlisting">// models/User.php

use Yii;
use yii\db\ActiveRecord;
use yii\web\IdentityInterface;

class User extends ActiveRecord implements IdentityInterface
{</pre></div><p>Now, implement the five required methods from <code class="literal">IdentityInterface</code> at the end of the class:</p><div class="informalexample"><pre class="programlisting">// models/User.php

/**
 * @inheritdoc
 */
public static function findIdentity($id) {
    return self::findOne($id);
}</pre></div><p>As we can see, the way to find a record in the database is quite straightforward, as <code class="literal">ActiveRecord</code> exposes some very nifty and easy-to-understand methods to interact with the database. We will be seeing plenty of these use cases across the upcoming pages.</p><p>It's probably worth noticing that <code class="literal">findIdentity()</code> returns an <code class="literal">IdentityInterface</code> object. The previous implementation that we overwrote invoked <code class="literal">new static()</code>, which, in turn, triggered the magic method <code class="literal">__construct()</code> from the <code class="literal">yii\base\Object</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The <code class="literal">new static()</code> method has been available since PHP 5.3 and provides a way to instantiate a child class statically from a parent, which wasn't possible earlier. This methodology is called <a id="id246" class="indexterm"/>
<span class="strong"><strong>Late Static Binding</strong></span>.</p><p>More information can be found in <a id="id247" class="indexterm"/>the PHP manual at <a class="ulink" href="http://php.net/manual/en/language.oop5.late-static-bindings.php">http://php.net/manual/en/language.oop5.late-static-bindings.php</a>.</p></div></div><p>As mentioned <a id="id248" class="indexterm"/>earlier, <code class="literal">findIdentityByAccessToken</code> is not needed as <code class="literal">accessToken</code> will not be used anywhere in our code, so let's implement it:</p><div class="informalexample"><pre class="programlisting">public static function findIdentityByAccessToken($token, $type = null) {
    throw new NotSupportedException('Login by access token not supported.');
}</pre></div><p>The remaining <a id="id249" class="indexterm"/>three methods from the interface should be straightforward to implement and understand, and to do so, we can use the following code:</p><div class="informalexample"><pre class="programlisting">public function getId() {
    return $this-&gt;id;
}

public function getAuthKey() {
    return $this-&gt;authkey;
}

public function validateAuthKey($authKey) {
    return $this-&gt;authkey === $authKey;
}</pre></div><p>Left out from the obvious methods from the interface are a couple of methods that are used in <code class="literal">LoginForm.php</code>; one of them is <code class="literal">findByUsername</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Finds user by username
 *
 * @param  string      $username
 * @return static|null
 */
public static function findByUsername($username)
{
    return self::findOne(['username' =&gt; $username]);
}</pre></div><p>Another is <code class="literal">validatePassword</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Validates password
 *
 * @param  string  $password password to validate
 * @return boolean if password provided is valid for current user
 */
public function validatePassword($password)
{
    return Yii::$app-&gt;getSecurity()-&gt;validatePassword($password, $this-&gt;password);
}</pre></div><p>Here, we again <a id="id250" class="indexterm"/>use the <code class="literal">validatePassword()</code> method <a id="id251" class="indexterm"/>from the Security component, which makes the use of cryptography and any additional level of security that we want to add transparent to the user.</p></div></div>
<div class="section" title="Seeing tests pass"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Seeing tests pass</h1></div></div></div><p>As you<a id="id252" class="indexterm"/> might have guessed, it's again time to run Codeception against our <code class="literal">UserTest</code> class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../vendor/bin/codecept run unit models/UserTest.php</strong></span>
<span class="strong"><strong>Codeception PHP Testing Framework v2.0.6</strong></span>
<span class="strong"><strong>Powered by PHPUnit 4.4-dev by Sebastian Bergmann.</strong></span>

<span class="strong"><strong>Unit Tests (14) -----------------------------</strong></span>
<span class="strong"><strong>Trying to test validate returns false if parameters are not set (tests\codeception\unit\models\UserTest::testValidateReturnsFalseIfParametersAreNotSet)                              Ok</strong></span>
<span class="strong"><strong>[snip]</strong></span>


<span class="strong"><strong>Time: 3.61 seconds, Memory: 28.75Mb</strong></span>

<span class="strong"><strong>OK (27 tests, 53 assertions)</strong></span>
</pre></div><p>You should have all tests passing without problems, and you should also be able to fix them in case an error is raised.</p><p>If we decide to<a id="id253" class="indexterm"/> run all the tests, including those that were already there, we might see that some tests are not passing anymore. Don't worry, this is quite normal as we've changed the way the <code class="literal">User</code> model works and behaves internally. In particular, the error I'm getting is the following regarding <code class="literal">LoginFormTest</code>, but Codeception/PHPUnit is quite prompt in informing us what's wrong:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>There was 1 error:</strong></span>

<span class="strong"><strong>---------</strong></span>
<span class="strong"><strong>1) tests\unit\models\LoginFormTest::testLoginCorrect | user should be able to login with correct credentials</strong></span>
<span class="strong"><strong>yii\base\InvalidParamException: Hash is invalid.</strong></span>

<span class="strong"><strong>                                     </strong></span>
<span class="strong"><strong>FAILURES!                            </strong></span>
<span class="strong"><strong>Tests: 31, Assertions: 64, Errors: 1.</strong></span>
</pre></div><p>As I've underlined previously, it's quite important to fix any tests that do not work well. This will make us understand if we've touched anything that wasn't meant to break or that can potentially break when committing our changes.</p><div class="section" title="Using global fixtures"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Using global fixtures</h2></div></div></div><p>In this case, it's <a id="id254" class="indexterm"/>quite clear that our tests have impacted the<a id="id255" class="indexterm"/> state of the database: The solution will be able to create a new fixture with the expected data for the admin user, which replicates what the migration is doing, and to update <code class="literal">LoginFormTest</code> and <code class="literal">UserTest</code>.</p><p>We will now use the default fixture <code class="literal">user.php</code> as the global fixture with the admin user, as follows:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/fixtures/data/user.php

return [
    'admin' =&gt; [
        'id' =&gt; 1,
        'username' =&gt; 'admin',
        'password' =&gt; Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash('admin'),
        'authkey' =&gt; 'valid authkey'
    ]
];</pre></div><p>The previous<a id="id256" class="indexterm"/> fixture will be renamed as <code class="literal">userModels.php</code>; it contains<a id="id257" class="indexterm"/> additional users that we might end up adding to our application in the future. The code for doing so is as follows:</p><div class="informalexample"><pre class="programlisting">return [
    'user_basic' =&gt; [
        'username' =&gt; '-=[ valid username ]=-',
        'password' =&gt; 'This is a valid password!!!',
        'authkey' =&gt; '00%am|%lk;@P .'
    ],
    'user_accessToken' =&gt; [
        'username' =&gt; '-=[ valid username ]=-',
        'password' =&gt; 'This is another valid password!!! :) &lt;script&gt;&lt;/script&gt;',
        'authkey' =&gt; uniqid()
    ],
    'user_id' =&gt; [
        'id' =&gt; 4,
        'username' =&gt; '-=[ valid username ]=-',
        'password' =&gt; 'This is another valid password!!! :)',
        'authkey' =&gt; uniqid()
    ],
];</pre></div><p>We could have fallen into the trap of just amending the initial fixture to contain the admin user, which would have solved the problem but would have made multiple tests rely on fixtures that were designed for specific tests. So, let's try to keep things as separate and independent as possible.</p><p>Now, we can load the previously mentioned fixture in <code class="literal">LoginFormTest</code> as a global fixture, as follows:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/LoginFormTest.php

public function globalFixtures()
{
    return [
        'user' =&gt; UserFixture::className(),
    ];
}</pre></div><p>Furthermore, we<a id="id258" class="indexterm"/> can amend the previously implemented methods to load<a id="id259" class="indexterm"/> the fixtures in the <code class="literal">UserTest</code>, as follows:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/unit/models/UserTest.php

public function globalFixtures()
{
    return [
        'user' =&gt; UserFixture::className(),
    ];
}

public function fixtures()
{
    return [
        'user' =&gt; [
            'class' =&gt; UserFixture::className(),
            'dataFile' =&gt; '@app/tests/codeception/unit/fixtures/data/userModels.php'
        ]
    ];
}</pre></div><p>Our new <code class="literal">fixtures()</code> implementation will need to expand on the parameters passed and define both <code class="literal">class</code> and <code class="literal">dataFile</code>; otherwise, it won't load it properly.</p><p>The <code class="literal">globalFixtures()</code> method is run before the <code class="literal">fixtures()</code> method, which means that the <code class="literal">$this-&gt;user</code> variable will only contain the latest fixtures and not the admin.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>We've discussed a wide variety of things concerning PHPUnit such as assertions, data providers, and fixtures. We've seen how to make tests pass and how to preventively catch errors that might cause bigger problems.</p><p>There are many more things you can discover on both Codeception unit tests and PHPUnit, but what we've seen up until now should be enough to give you the confidence required to start creating tests with clarity.</p><p>In the next chapter, we'll see how to test components that rely on external code and classes, in order to get the best controlled environment needed by using stubs and mocks.</p></div></body></html>