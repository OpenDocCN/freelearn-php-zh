<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Eloquent ORM"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Eloquent ORM</h1></div></div></div><p>In the previous chapter, we touched on Eloquent, the <span class="strong"><strong>object-relational mapper</strong></span> (<span class="strong"><strong>ORM</strong></span>) that ships with Laravel. Eloquent acts as the model layer (the M in MVC) in our applications. As it is such a big part of most applications built in Laravel, we are going to take a look at Eloquent in more detail.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading and writing data to our database</li><li class="listitem" style="list-style-type: disc">Relationships between models</li><li class="listitem" style="list-style-type: disc">Query scopes</li><li class="listitem" style="list-style-type: disc">Model events and observers</li><li class="listitem" style="list-style-type: disc">Collections</li></ul></div><div class="section" title="Eloquent conventions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Eloquent conventions</h1></div></div></div><p>Eloquent has some <a id="id135" class="indexterm"/>conventions, which, if followed, will make your life easier. This approach is known as <span class="strong"><strong>convention over configuration</strong></span>, which means, if you <a id="id136" class="indexterm"/>follow these conventions, you will have to do very little configuration for things to "just work".</p><p>An Eloquent model is contained in a single class and is the "studly-cased", singular version of your database table's name. Studly-case is similar to camel-casing, but the first letter is uppercase as well. So if you have a database table called <code class="literal">cats</code>, then your model class will be called <code class="literal">Cat</code>.</p><p>There is no set place in the filesystem to place your Eloquent models; you are free to organize them as you see fit. You can use an Artisan command to create a model <span class="strong"><strong>stub</strong></span> (a simple class with the basic structure of an Eloquent model). The command is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan app:model Cat</strong></span>
</pre></div><p>By default, Artisan places new model classes in the <code class="literal">app</code> directory. You are free to move your model classes and store them in whatever directory you wish, just be sure to update the namespace declaration at the top of the file to reflect its new location.</p><p>Our model stub class will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;
use Illuminate\Database\Eloquent\Model;
class Cat extends Model {
  //
}</pre></div><p>This will attempt to use a table called <code class="literal">cats</code> by default.</p><p>Our model class extends the base Eloquent <code class="literal">Model</code> class, which contains all of the goodness we're going to use <a id="id137" class="indexterm"/>over the course of this chapter. The first thing you should do after creating a model is define the database table it maps to. In our case, the database table will be called <code class="literal">cats</code>:</p><div class="informalexample"><pre class="programlisting">class Cat extends Model {
  <span class="strong"><strong>protected $table = 'cats';</strong></span>
}</pre></div><p>This is a working Eloquent model at its simplest and you can now use it to fetch records from your database table.</p></div></div>
<div class="section" title="Retrieving data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Retrieving data</h1></div></div></div><p>Eloquent provides you with <a id="id138" class="indexterm"/>numerous ways to fetch records from your database, each with their own appropriate use case. You can simply fetch all records in one go; a single record based on its primary key; records based on conditions; or a paginated list of either all or filtered records.</p><p>To fetch all records, we can use the aptly-named <code class="literal">all</code> method:</p><div class="informalexample"><pre class="programlisting">use App\Cat;
$cats = Cat::all();</pre></div><p>To fetch a record by its primary key, you can use the <code class="literal">find</code> method:</p><div class="informalexample"><pre class="programlisting">$cat = Cat::find(1);</pre></div><p>Along with the <code class="literal">first</code> and <code class="literal">all</code> methods, there are <span class="strong"><strong>aggregate</strong></span> methods. These allow you to retrieve aggregate values (rather than a record set) from your database tables:</p><div class="informalexample"><pre class="programlisting">use App\Order;

$orderCount    = Order::count();
$maximumTotal  = Order::max('amount');
$minimumTotal  = Order::min('amount');
$averageTotal  = Order::avg('amount');
$lifetimeSales = Order::sum('amount');</pre></div><div class="section" title="Filtering records"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Filtering records</h2></div></div></div><p>Eloquent also ships with a feature-rich query builder that allows you to build queries in code, without having to write a single line of SQL. This abstraction layer makes it easier to swap database platforms, should you ever need to. With Laravel, the only thing you need to do is update your database configuration and your application will continue to function as before.</p><p>Laravel's query builder has <a id="id139" class="indexterm"/>methods for common SQL-like directives such as <code class="literal">WHERE</code>, <code class="literal">ORDER</code>, and <code class="literal">LIMIT</code>; and more advanced concepts such as joins. For example, the previous <code class="literal">find</code> illustration can be expressed—albeit in longhand—as:</p><div class="informalexample"><pre class="programlisting">$cat = Cat::where('id', '=', 1)-&gt;first();</pre></div><p>This will retrieve the first record <code class="literal">WHERE 'id' = 1</code>. We will only expect one record when querying based on the primary key, so use the <code class="literal">first</code> method. If we have a more open <code class="literal">WHERE</code> clause, where we were expecting potentially more than one record, we can use the <code class="literal">get</code> method, as we did in the first code example, and it will only return records that matched that clause.</p><p>Clauses can also be <span class="strong"><strong>chained</strong></span>. This <a id="id140" class="indexterm"/>allows you to build up complex query conditions by adding clauses together. Consider the following example code:</p><div class="informalexample"><pre class="programlisting">use App\User;

$users = User::where('gender', '=', 'Male')
  -&gt;where('birth_date', '&gt;', '1989-02-12')
  -&gt;all();</pre></div><p>This will find all male users who were born after February 12, 1989. Instead of specifying dates manually, we can also use <span class="strong"><strong>Carbon</strong></span>, a date and time library. Here is an example of using Carbon to <a id="id141" class="indexterm"/>find all users who are older than 21 years of age:</p><div class="informalexample"><pre class="programlisting">use App\User;
use Carbon\Carbon;

$users = User::where('birth_date', '&lt;', Carbon::now()- &gt;subYears(21))
  -&gt;all();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>You can <a id="id142" class="indexterm"/>find more information on Carbon and its available functions at its official GitHub repository <a class="ulink" href="https://github.com/briannesbitt/Carbon">https://github.com/briannesbitt/Carbon</a>. Common Carbon methods are also covered in <a class="link" href="apa.html" title="Appendix A. An Arsenal of Tools">Appendix</a>, <span class="emphasis"><em>An Arsenal of Tools</em></span>.</p></div></div><p>Along with filtering records by <code class="literal">WHERE</code> conditions, you can also limit the number of records by using ranges using the <code class="literal">take</code> method:</p><div class="informalexample"><pre class="programlisting">$women = User::where('gender', '=', 'Female')-&gt;take(5)-&gt;get();</pre></div><p>This will get the first five female users. You can also specify offsets by using the skip method:</p><div class="informalexample"><pre class="programlisting">$women = User::where('gender', '=', 'Female')-&gt;take(5)-&gt;skip(10)-&gt;get();</pre></div><p>In SQL, this will look similar to the following:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE gender = 'Female' OFFSET 10 LIMIT 5</pre></div><p>Queries can also be ordered <a id="id143" class="indexterm"/>by using the <code class="literal">orderBy</code> method:</p><div class="informalexample"><pre class="programlisting">$rankings = Team::orderBy('rating', 'asc')-&gt;get();</pre></div><p>This will correspond to a SQL statement that looks like this:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM teams ORDER BY rating ASC</pre></div></div></div>
<div class="section" title="Saving data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Saving data</h1></div></div></div><p>Applications that display <a id="id144" class="indexterm"/>data are great, but they're not very interactive. The fun comes when you allow users to submit data, whether these users are trusted contributors adding content via a content management system or contributions from general users on a site like Wikipedia.</p><p>When you retrieve a record via Eloquent, you can access its properties as follows:</p><div class="informalexample"><pre class="programlisting">$cat = Cat::find(1);
print $cat-&gt;name;</pre></div><p>We can update attribute values in the same manner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$cat-&gt;name = 'Garfield';</strong></span>
</pre></div><p>This will set the value in the model instance, but we need to persist the change to the database. We do this by calling the <code class="literal">save</code> method afterwards:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$cat-&gt;name = 'Garfield';</strong></span>
<span class="strong"><strong>$cat-&gt;save();</strong></span>
</pre></div><p>If you have a table with lots of columns, then it will become tiresome to assign each property manually like this. To this end, Eloquent allows you to fill models by passing an associative array with values, and the keys representing the column names. You can fill a model while either creating or updating it:</p><div class="informalexample"><pre class="programlisting">$data = [
  'name' =&gt; 'Garfield',
  'birth_date' =&gt; '1978-06-19',
  'breed_id' =&gt; 1,
];

$cat-&gt;create($data);</pre></div><p>However, this will <a id="id145" class="indexterm"/>throw a <code class="literal">MassAssignmentException</code> error.</p><div class="section" title="Mass assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Mass assignment</h2></div></div></div><p>The preceding example is an <a id="id146" class="indexterm"/>example of <span class="strong"><strong>mass assignment</strong></span>. That is where a model's attributes are blindly updated with values <span class="emphasis"><em>en masse</em></span>. If the <code class="literal">$data</code> array in the previous example came from say, a user's form submission, then they can update any and all values in the same database.</p><p>Consider that you have a <code class="literal">users</code> table with a column called <code class="literal">is_admin</code>, which determines whether or not that user can view your website's administration area. Also consider that users on the public side of your website can update their profile. If, during form submission, the user also included a field with the name of <code class="literal">is_admin</code> and a value of <code class="literal">1</code>, that would update the column value in the database table and grant them access to your super secret admin area—this is a huge security concern and is exactly what mass-assignment protection prevents.</p><p>To mark columns whose values are safe to set via mass-assignment (such as <code class="literal">name</code>, <code class="literal">birth_date</code>, and so on.), we need to update our Eloquent models by providing a new property called <code class="literal">$fillable</code>. This is simply an array containing the names of the attributes that are safe to set via mass assignment:</p><div class="informalexample"><pre class="programlisting">class Cat extends Model {

  protected $table = 'cats';
  <span class="strong"><strong>protected $fillable = [</strong></span>
<span class="strong"><strong>    'name',</strong></span>
<span class="strong"><strong>    'birth_date',</strong></span>
<span class="strong"><strong>    'breed_id',</strong></span>
<span class="strong"><strong>  ];</strong></span>
}</pre></div><p>Now, we can create and update models by passing an array of data as before, without facing a <code class="literal">MassAssignmentException</code> being thrown.</p><p>Along with creating a new record, there are a couple of sibling methods that you can use. There is <code class="literal">firstOrCreate</code>, where you can pass an array of data—Eloquent will first try and find a model with the matching values. If it can't find a match, it will instead create the record.</p><p>There's also the similarly named <code class="literal">firstOrNew</code> method. However, instead of immediately saving the record to the database, it will instead just return a new Eloquent instance with the attribute values set, allowing you to set any other values first before manually saving it yourself.</p><p>A good time to use these methods is when allowing users to log in by using a third-party service such as Facebook or Twitter. These services will usually return information identifying the user, such as an <a id="id147" class="indexterm"/>e-mail address, allowing you to check your database for a matching user. If one exists, you can simply log them in, otherwise you can create a new user account for them.</p></div></div>
<div class="section" title="Deleting data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Deleting data</h1></div></div></div><p>There are two ways of deleting <a id="id148" class="indexterm"/>records. If you have a model instance that you have fetched from the database, then you can call the <code class="literal">delete</code> method on it:</p><div class="informalexample"><pre class="programlisting">$cat = Cat::find(1);
$cat-&gt;delete();</pre></div><p>Alternatively, you can call the <code class="literal">destroy</code> method, specifying the IDs of the records you want to delete, without having to fetch those records first:</p><div class="informalexample"><pre class="programlisting">Cat::destroy(1);
Cat::destroy(1, 2, 3, 4, 5);</pre></div><div class="section" title="Soft deletion"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Soft deletion</h2></div></div></div><p>By default, Eloquent will <a id="id149" class="indexterm"/>
<span class="strong"><strong>hard-delete</strong></span> records from your database. This means, once it's deleted, it's gone forever. If you need to retain deleted data (that is, for auditing), then you can use <span class="strong"><strong>soft deletes</strong></span>. When deleting a model, the record is kept in the <a id="id150" class="indexterm"/>database but instead a <code class="literal">deleted_at</code> timestamp is set, and any records with this timestamp set will not be included when querying your database.</p><p>Soft deletes can be easily added to your Eloquent model. All you need to do is include the trait:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>use Illuminate\Database\Eloquent\SoftDeletes;</strong></span>
class Cat extends Model {
  <span class="strong"><strong>use SoftDeletes;</strong></span>
<span class="strong"><strong>  protected $dates = ['deleted_at'];</strong></span>
}</pre></div><p>We've also designated that the <code class="literal">deleted_at</code> column should be treated as a date column. This will yield the value as a Carbon instance and allow us to perform operations on it or display it in a variety of formats, should we need to.</p><p>You'll also need to <a id="id151" class="indexterm"/>make sure the <code class="literal">deleted_at</code> column is added to your table <a id="id152" class="indexterm"/>migration. An example of such a migration is as follows:</p><div class="informalexample"><pre class="programlisting">public function up() {
  $table-&gt;softDeletes();
}</pre></div><div class="section" title="Including deleted models in results"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Including deleted models in results</h3></div></div></div><p>If you find you <a id="id153" class="indexterm"/>need to include deleted records when querying your database (for example, in an administration area), then you can use the <code class="literal">withTrashed</code> query scope. Query scopes are just methods you can use in chaining:</p><div class="informalexample"><pre class="programlisting">$cats = Cat::withTrashed()-&gt;get();</pre></div><p>This will mix deleted records with non-deleted records. If you find you need to retrieve <span class="emphasis"><em>only</em></span> deleted records, then you can use the <code class="literal">onlyTrashed</code> query scope:</p><div class="informalexample"><pre class="programlisting">$cats = Cat::onlyTrashed()-&gt;get();</pre></div><p>If you find you need to "un-delete" a record, then the <code class="literal">SoftDeletes</code> trait provides you with a new <code class="literal">restore</code> method to undo this:</p><div class="informalexample"><pre class="programlisting">$cat-&gt;restore();</pre></div><p>Finally, if you find you <span class="emphasis"><em>really</em></span> need to delete a record from your database, you can use the <code class="literal">forceDelete</code> method. As the name implies, once you delete a record with this method, it's truly gone.</p><div class="informalexample"><pre class="programlisting">$cat-&gt;forceDelete();</pre></div></div></div></div>
<div class="section" title="Query scopes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Query scopes</h1></div></div></div><p>The previous <a id="id154" class="indexterm"/>section introduced you to the concept of query scopes. This builds on from the query builder that allows you to build conditions on an ad hoc basis. However, what if you need certain conditions to apply to every request? Or a single condition that is actually the combination of multiple <code class="literal">WHERE</code> clauses? This is where query scopes come in.</p><p>Query scopes allow you to define these conditions once in your model, and then re-use them without having to manually define the clauses that make up that condition. For example, imagine we need to find users above the age of 21 in multiple places in our application. We can express this as a query scope:</p><div class="informalexample"><pre class="programlisting">class User extends Model {

<span class="strong"><strong>  public function scopeOver21($query)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    $date = Carbon::now()-&gt;subYears(21);</strong></span>
<span class="strong"><strong>    return $query-&gt;where('birth_date', '&lt;', $date);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Thanks to the fluent query builder, we can now use this as follows:</p><div class="informalexample"><pre class="programlisting">$usersOver21 = User::over21()-&gt;get();</pre></div><p>As you can see, query scopes are methods that begin with the word "scope", take the current query as a parameter, modify it in some way, and then return the modified query, ready to be used in another clause. This means you can chain query scopes just as you would any other query expression:</p><div class="informalexample"><pre class="programlisting">$malesOver21 = User::male()-&gt;over21()-&gt;get();</pre></div><p>Along with simple scopes like these, we can create more "dynamic" scopes that accept parameters and can be <a id="id155" class="indexterm"/>passed to the scope's conditions. Consider the following example code:</p><div class="informalexample"><pre class="programlisting">class Cat extends Model {
  <span class="strong"><strong>public function scopeOfBreed($query, $breedId)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $query-&gt;where('breed_id', '=', $breedId);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>We can then find cats of a specific breed as follows:</p><div class="informalexample"><pre class="programlisting">$tabbyCats = Cat::ofBreed(1)-&gt;get();</pre></div></div>
<div class="section" title="Relationships"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Relationships</h1></div></div></div><p>When we built our <a id="id156" class="indexterm"/>application in <a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>, we made use of relationships. Each cat in our application was of a particular breed. However, instead of storing the name of the breed next to every individual cat and potentially having the breed repeating numerous times, we created a separate <code class="literal">breeds</code> table and each cat's breed was a value that referred to the ID of a record in that table. This gave us an example of two types of relationships: a cat <span class="emphasis"><em>belongs to</em></span> a breed, but a breed can <span class="emphasis"><em>have many</em></span> cats. This is <a id="id157" class="indexterm"/>defined as a <span class="strong"><strong>one-to-many</strong></span> relationship.</p><p>There are other types of relationships, for each of which Eloquent provides good support:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One-to-one</li><li class="listitem" style="list-style-type: disc">Many-to-many</li><li class="listitem" style="list-style-type: disc">Has-many-through</li><li class="listitem" style="list-style-type: disc">Polymorphic relations</li><li class="listitem" style="list-style-type: disc">Many-to-many polymorphic relations</li></ul></div><p>Here, we will look through them with an example of each.</p><div class="section" title="One-to-one"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>One-to-one</h2></div></div></div><p>Sometimes, you may <a id="id158" class="indexterm"/>want to split data across multiple tables for ease of management, or because they represent two different parts of one entity. A <a id="id159" class="indexterm"/>common example is a user, and a user's profile. You may have a <code class="literal">users</code> table that contains core information about that user such as their name, account e-mail address, and password hash; however, if it's a social networking website, then they may also have a profile with more information, such as their favorite color. This information can then be stored in a separate <code class="literal">profiles</code> table, with a foreign key representing the user that the profile belongs to.</p><p>In your models, this relation will look like this:</p><div class="informalexample"><pre class="programlisting">class User extends Model {

  <span class="strong"><strong>public function profile()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;hasOne('App\Profile');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>And in the <code class="literal">Profile</code> model, the relation will look like this:</p><div class="informalexample"><pre class="programlisting">class Profile extends Model {

  <span class="strong"><strong>public function user()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;belongsTo('App\User');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>When querying <code class="literal">Users</code>, we can also access their profile separately:</p><div class="informalexample"><pre class="programlisting">$profile = User::find(1)-&gt;profile;</pre></div><p>Relations are accessed using the name of the method used to define it in the model. Since in the <code class="literal">User</code> model we defined the relation in a method called <code class="literal">profile</code>, this is the name of the property we use to access the data of that related model.</p></div><div class="section" title="Many-to-many"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Many-to-many</h2></div></div></div><p>A many-to-many <a id="id160" class="indexterm"/>relationship is more complicated than a <a id="id161" class="indexterm"/>one-to-one (where one model belongs to exactly one other model) or a one-to-many relationship (where many models can belong to one other model). As the name suggests, many models can belong to many other models. To accomplish this, instead of just two tables being involved, a third is introduced. This can be quite difficult to comprehend, so let's look at an example.</p><p>Imagine you're building a permissions system to limit what actions each user can perform. Instead of assigning permissions on a per-user basis, you instead have roles, where each user is given a subset of permissions, depending on which role they've been assigned. In this description, we've identified two entities: a <code class="literal">User</code> and a <code class="literal">Role</code>. Also in this scenario, a user can have many roles, and a role can belong to many users. To map roles to users, we create a third table, called a join table. Laravel refers to these tables as <span class="strong"><strong>pivot</strong></span> tables, a term you may have heard of if you have worked with spreadsheets before.</p><p>By default, Eloquent expects join tables to contain the singular names of the two target tables, listed alphabetically and separated by an underscore. So in our scenario, this would be <code class="literal">role_user</code>. The <a id="id162" class="indexterm"/>table itself contains only two columns (other than the primary key). These columns represent the foreign key of the <code class="literal">Role</code> <a id="id163" class="indexterm"/>model and the <code class="literal">User</code> model it is creating a relation between. Again in convention over configuration, these should be lowercase, singular, with <code class="literal">_id</code> appended, that is, <code class="literal">role_id</code> and <code class="literal">user_id</code>.</p><p>The relationship is defined in both our <code class="literal">User</code> and <code class="literal">Role</code> models using the <code class="literal">belongsToMany</code> method:</p><div class="informalexample"><pre class="programlisting">class User extends Model {
  <span class="strong"><strong>public function roles()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;belongsToMany('App\Role');</strong></span>
<span class="strong"><strong>  }</strong></span>
}

class Role extends Model {
  <span class="strong"><strong>public function users()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;belongsToMany('App\User');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>We can now find out what roles a user has been assigned:</p><div class="informalexample"><pre class="programlisting">$roles = User::find(1)-&gt;roles;</pre></div><p>We can also find out all users with a particular role:</p><div class="informalexample"><pre class="programlisting">$admins = Role::find(1)-&gt;users;</pre></div><p>If you need to add a new role to a user, you can do so by using the <code class="literal">attach</code> method:</p><div class="informalexample"><pre class="programlisting">$user = User::find(1);
$user-&gt;roles()-&gt;attach($roleId);</pre></div><p>And, of course, the opposite of <code class="literal">attach</code> is <code class="literal">detach</code>:</p><div class="informalexample"><pre class="programlisting">$user-&gt;roles()-&gt;detach($roleId);</pre></div><p>Both the <code class="literal">attach</code> and <code class="literal">detach</code> methods also accept arrays, allowing you to add/remove multiple relations in one operation.</p><p>Alternatively, you can use the <code class="literal">sync</code> method. The difference with <code class="literal">sync</code> is, only after the operation is complete are the <a id="id164" class="indexterm"/>IDs that are passed present in the <a id="id165" class="indexterm"/>join table, rather than adding/removing them from the existing relations.</p><div class="informalexample"><pre class="programlisting">$user-&gt;roles()-&gt;sync(1, 2, 3, 4, 5);</pre></div><div class="section" title="Storing data in the pivot table"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Storing data in the pivot table</h3></div></div></div><p>Along with <a id="id166" class="indexterm"/>storing the primary keys of both the related models in the pivot table, you can also store additional data. Imagine we have users and groups in an application. Many users can belong to many groups, but users can also be moderators of groups. To indicate which users are moderators of a group, we can add a <code class="literal">is_moderator</code> column on the pivot table. To specify the additional data that should be stored in the pivot table, we can specify a second parameter when calling the <code class="literal">attach</code> method:</p><div class="informalexample"><pre class="programlisting">$user-&gt;groups()-&gt;attach(1, ['is_moderator' =&gt; true]);</pre></div><p>We can use the same approach when using the <code class="literal">sync</code> method too:</p><div class="informalexample"><pre class="programlisting">$user-&gt;groups()-&gt;sync([1 =&gt; ['is_moderator' =&gt; true]]);</pre></div></div></div><div class="section" title="Has-many-through"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Has-many-through</h2></div></div></div><p>With related <a id="id167" class="indexterm"/>data, things are simple when you want data from a <a id="id168" class="indexterm"/>model that is directly related to the current one you're working with; but what happens if you want data that is two <span class="strong"><strong>hops</strong></span> away from your current model?</p><p>Consider a simple e-commerce website. You may have a <code class="literal">Product</code> model, an <code class="literal">Order</code> model, and an <code class="literal">OrderItem</code> model that belongs to both a product and an order. You have been tasked with finding all orders that contain a particular product. How do you do this if <code class="literal">Product</code> isn't directly associated with <code class="literal">Order</code>? Thankfully, in our scenario, they have a common relation—the <code class="literal">OrderItem</code> model.</p><p>We can use a "has-many-through" relationship to reach orders a product is part of via the intermediate <code class="literal">OrderItem</code> model. We set the relationship up in our <code class="literal">Product</code> model, as follows:</p><div class="informalexample"><pre class="programlisting">class Product extends Model {

  <span class="strong"><strong>public function orders()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;hasManyThrough('App\Order', 'App\OrderItem');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The first parameter <a id="id169" class="indexterm"/>in the <code class="literal">hasManyThrough</code> method is the target <a id="id170" class="indexterm"/>model, and the second parameter is the intermediate model we go through to get to it. We can now easily list the orders a product is part of:</p><div class="informalexample"><pre class="programlisting">$product = Product::find(1);
$orders = $product-&gt;orders;</pre></div></div><div class="section" title="Polymorphic relations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Polymorphic relations</h2></div></div></div><p>Polymorphic <a id="id171" class="indexterm"/>relations are difficult to grasp at first; however, once you have an understanding of them, they are really powerful. They allow a model <a id="id172" class="indexterm"/>to belong to more than one other model on a single association.</p><p>A common use case for a polymorphic relationship is to create an image library and then allow your other models to contain images by linking to the relevant records in the image library table. A base <code class="literal">Image</code> model will look like this:</p><div class="informalexample"><pre class="programlisting">class Image extends Model {

  <span class="strong"><strong>public function imageable()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;morphTo();</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The <code class="literal">morphTo</code> method is what makes this model polymorphic. Now, in our other models, we can create a relation to the <code class="literal">Image</code> model, as follows:</p><div class="informalexample"><pre class="programlisting">class Article extends Model {
  <span class="strong"><strong>public function images()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    $this-&gt;morphMany('App\Image', 'imageable');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>You can now fetch any related <code class="literal">Image</code> models through your <code class="literal">Article</code> model:</p><div class="informalexample"><pre class="programlisting">$article = Article::find(1);

foreach ($article-&gt;images as $image) {
  // Do something with image
}</pre></div><p>You may think that this is no different to a one-to-many relationship, but the difference becomes apparent when you look at the relation from the other side. When retrieving an <code class="literal">Image</code> instance, if you access the <code class="literal">imageable</code> relation, you'll receive an instance of whatever model "owns" the image. This may be an <code class="literal">Article</code>, a <code class="literal">Product</code>, or another model type in your application. Eloquent achieves this by not only storing a foreign key value, but also the name <a id="id173" class="indexterm"/>of the model class. In the case of our <code class="literal">Image</code> model, the <a id="id174" class="indexterm"/>columns would be <code class="literal">imageable_id</code> and <code class="literal">imageable_type</code>. When creating your migration, there is a method to create these two columns:</p><div class="informalexample"><pre class="programlisting">$table-&gt;morphs('imageable');</pre></div></div><div class="section" title="Many-to-many polymorphic relations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Many-to-many polymorphic relations</h2></div></div></div><p>The final relation type we will look at is the <span class="strong"><strong>many-to-many polymorphic relation</strong></span>, by far the most complex. Staying with our image library example, we can see that it has one drawback, an <code class="literal">Image</code> can only belong to one other model at a time. So, while we can see all images that have <a id="id175" class="indexterm"/>been uploaded by <a id="id176" class="indexterm"/>models in our application, we can't re-use an uploaded image like we would in a true image library. This is where a many-to-many polymorphic relation would come in.</p><p>Keeping our <code class="literal">images</code> and <code class="literal">articles</code> tables, we need to introduce a third table, <code class="literal">imageables</code>. The relation data is removed from the <code class="literal">images</code> table, and instead placed in this new table, which also has another column that is a foreign key pointing to the <code class="literal">Image</code> primary key. The three columns are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">image_id</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">imageable_id</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">imageable_type</code></li></ul></div><p>With this schema, a single <code class="literal">Image</code> can have multiple relations. That is, the image can be re-used in multiple models, whether that is multiple <code class="literal">Article</code> records, or models of different types. Our updated model classes then take this form:</p><div class="informalexample"><pre class="programlisting">class Article extends Model {
  <span class="strong"><strong>public function images()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;morphedByMany('App\Image', 'imageable');</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The <code class="literal">Image</code> model is also updated, containing methods for each of its relationships:</p><div class="informalexample"><pre class="programlisting">class Image extends Model {
  <span class="strong"><strong>public function articles()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;morphToMany('App\Article', 'imageable');</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  public function products()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;morphToMany('App\Product', 'imageable');</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  // And any other relations</strong></span>
}</pre></div><p>You can still <a id="id177" class="indexterm"/>access the <code class="literal">images</code> relation as with a normal <a id="id178" class="indexterm"/>polymorphic relationship.</p></div></div>
<div class="section" title="Model events"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Model events</h1></div></div></div><p>Eloquent fires <a id="id179" class="indexterm"/>numerous events at different points, such as when a model is being saved or deleted. The following is a list of methods Eloquent models can fire:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">creating</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">created</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">updating</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">updated</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">saving</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">saved</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">deleting</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">deleted</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">restoring</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">restored</code></li></ul></div><p>The names are self-explanatory. The difference in the past and present participles is that events such as <code class="literal">creating</code> are fired <span class="emphasis"><em>before</em></span> the model is created, whereas <code class="literal">created</code> is fired <span class="emphasis"><em>after</em></span> the model has been created. Therefore, if you were to halt execution within a handler for the <code class="literal">creating</code> event, the record will not be saved; whereas, if you halted execution within a handler for the <code class="literal">created</code> event, the record would still be persisted to the database.</p><div class="section" title="Registering event listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Registering event listeners</h2></div></div></div><p>It's quite open-ended <a id="id180" class="indexterm"/>as to where to register listeners for model events. One place is in the <code class="literal">boot</code> method within the <code class="literal">EventServiceProvider</code> class:</p><div class="informalexample"><pre class="programlisting">public function boot(DispatcherContract $events)
{
  parent::boot($events);

  <span class="strong"><strong>User::creating(function($user)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // Do something</strong></span>
<span class="strong"><strong>  });</strong></span>
}</pre></div><p>Be sure to import the namespace for the <code class="literal">DispatcherContract</code> at the top of the file:</p><div class="informalexample"><pre class="programlisting">use Illuminate\Contracts\Bus\Dispatcher as DispatcherContract;</pre></div><p>Eloquent models provide <a id="id181" class="indexterm"/>a method for each event that you can pass an anonymous function to. This anonymous function receives an instance of the model that you can then act upon. So if you wanted to create a URL-friendly representation of an article headline each time your <code class="literal">Article</code> model was saved, you can do this by listening on the saving event:</p><div class="informalexample"><pre class="programlisting">Article::saving(function($article)
{
  $article-&gt;slug = Str::slug($article-&gt;headline);
});</pre></div></div><div class="section" title="Model observers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Model observers</h2></div></div></div><p>As you add more and <a id="id182" class="indexterm"/>more model event handlers to your <code class="literal">EventServiceProvider</code> class, you may find it becoming overcrowded and difficult to maintain. This is where an alternative to handling model events comes into play—model observers.</p><p>Model observers are standalone classes that you attach to a model, and implement methods for as many events as you need to listen out for. So our slug-creating function can be re-factored into a model observer as follows:</p><div class="informalexample"><pre class="programlisting">use Illuminate\Support\Str;

class ArticleObserver {
  public function saving($article)
  {
    $article-&gt;slug = Str::slug($article-&gt;headline);
  }
}</pre></div><p>We can then register our observer in our <code class="literal">EventServiceProvider</code> class:</p><div class="informalexample"><pre class="programlisting">public function boot(DispatcherContract $events)
{
  parent::boot($events);
  <span class="strong"><strong>Article::observe(new ArticleObserver);</strong></span>
}</pre></div></div></div>
<div class="section" title="Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Collections</h1></div></div></div><p>Historically, other <a id="id183" class="indexterm"/>frameworks that have shipped with their own ORMs and query builders have returned result sets as either multidimensional arrays or <span class="strong"><strong>Plain Old PHP </strong></span><a id="id184" class="indexterm"/>
<span class="strong"><strong>Objects</strong></span> (<span class="strong"><strong>POPOs</strong></span>). Eloquent has taken its cue from other, more mature ORMs and instead returns result sets as an instance of a collection object.</p><p>The collection object is powerful as it not only contains the data returned from the database, but also many helper methods, allowing you to manipulate that data before displaying it to the user.</p><div class="section" title="Checking whether a key exists in a collection"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Checking whether a key exists in a collection</h2></div></div></div><p>If you need to find <a id="id185" class="indexterm"/>out whether a particular key exists in a collection, you can use the <code class="literal">contains</code> method:</p><div class="informalexample"><pre class="programlisting">$users = User::all();
if ($users-&gt;contains($userId))
{
  // Do something
}</pre></div><p>When querying models, any relations are also returned as subcollections, allowing you to use the exact same methods on relations too:</p><div class="informalexample"><pre class="programlisting">$user = User::find(1);
if ($user-&gt;roles-&gt;contains($roleId))
{
  // Do something
}</pre></div><p>By default, models return an instance of <code class="literal">Illuminate\Database\Eloquent\Collection</code>. However, this can be overridden to instead use a different class. This is handy if we wanted to add additional methods to collections.</p><p>Say for a collection of roles and we want to determine if administrator is one of those roles. If we imagine the administrator role to have a primary key value of <code class="literal">1</code>, we can create a new method, like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;
use Illuminate\Database\Eloquent\Collection as EloquentCollection;
class RoleCollection extends EloquentCollection {
  <span class="strong"><strong>public function containsAdmin()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return $this-&gt;contains(1);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The second part is to then tell the <code class="literal">Role</code> model to use our new collection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>use App\RoleCollection;</strong></span>

class Role extends Model {
  <span class="strong"><strong>public function newCollection(array $models = array())</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return new RoleCollection($models);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Instead of instantiating <a id="id186" class="indexterm"/>the default Eloquent collection, it will instead create a new instance of our <code class="literal">RoleCollection</code> class, filling it with the results from our query. This means that every time we request roles, we can use our new <code class="literal">containsAdmin</code> method:</p><div class="informalexample"><pre class="programlisting">$user = User::find(1);

if ($user-&gt;roles-&gt;containsAdmin())
{
  // Let user administrate something
}
else
{
 // User does not have administrator role
}</pre></div><p>Eloquent <a id="id187" class="indexterm"/>collections also have a plethora of other helpful functions for allowing you to manipulate, filter, and iterate over items. You can view more information on these methods at <a class="ulink" href="http://laravel.com/docs/master/eloquent#collections">http://laravel.com/docs/master/eloquent#collections</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>Although we have covered a lot in this chapter, Eloquent is so feature-rich that unfortunately, there isn't room to cover each and every one of its features. We have covered the most important aspects of Eloquent, though, and that will set you well on your way to saving and retrieving data, creating relations of varying complexity between your models, and handling various events raised during your models' lifecycle.</p><p>The next chapter sees us move on to learn all about testing our application so it remains as bulletproof as possible.</p></div></body></html>