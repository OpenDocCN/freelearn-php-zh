- en: Chapter 1. Zend Framework 2 Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Zend Framework 2 project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling routines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using configurations to your benefit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EventManager and Bootstrap classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will go through a basic Zend Framework 2 application, from
    download, to setup, to running it. If you are unfamiliar with how Zend Framework
    2 works, and the best way to install it, you can use this chapter as a reference.
    Further on in the chapter, we will get somewhat deeper in the framework by looking
    at the **dependency injection** (**DI**) and how it can help us code more efficiently.
    Lastly we will go more into the details of the configuration options, the `EventManager`
    and `ModuleManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Zend Framework 2 project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is more exciting than setting up a new project in our favourite framework.
    Every time we start a new project we begin with a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can set up a new Zend Framework 2 application you need to make sure
    you have the following items ready:'
  prefs: []
  type: TYPE_NORMAL
- en: A web server such as Apache running PHP Version 5.3.3 or higher that you can
    reach from a web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't have everything ready as mentioned, you are best off reading the
    topics mentioned in the *See also* section of this recipe (every topic we explain
    in this chapter is called a recipe) before you continue reading here.
  prefs: []
  type: TYPE_NORMAL
- en: We are assuming that Zend Framework 2 will be used on a Linux-based platform
    running an Apache 2 web server; this means that commands might not directly work
    on a Windows platform. Windows users, however, can set up a virtual machine with
    Linux on it to make full use of the book.
  prefs: []
  type: TYPE_NORMAL
- en: To install a virtual machine on Windows, we can use an application called Oracle
    VM VirtualBox, which is freely available. We can go to [www.virtualbox.org](http://www.virtualbox.org)
    and download plus install the latest version of VirtualBox, we can go to VirtualBoxes
    ([http://virtualboxes.org/images/ubuntu](http://virtualboxes.org/images/ubuntu))
    and download a preconfigured virtual machine from there.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do on the VirtualBoxes website is click on the latest Ubuntu
    (which is a distribution of Linux) link in the list, please take note of the username
    and password displayed there as we will need it later to login. Once the image
    is downloaded, it can be made ready by following the instructions in the documentation
    that can be found on the VirtualBoxes site ([http://virtualboxes.org/doc/register-and-load-a-downloaded-image](http://virtualboxes.org/doc/register-and-load-a-downloaded-image)).
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the image is imported we can easily start up the virtual machine and
    put in our username and password that has been supplied with the downloaded virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in to the virtual machine we need to make sure Git is installed,
    which can be done easily by typing in the following command (mind that the dollar
    sign is the command prompt, and not the command we actually need to type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If Git wasn't installed, the system will ask you to install Git, which can be
    done by pressing the *Y* key, followed by the *Enter* key, on the other hand if
    Git was already installed, than it will not do anything and tell you it already
    is installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need the Zend Framework 2 skeleton so we can easily create
    a new project. A skeleton is a template structure that can be used to start developing
    with an application, and in this case it creates a template for us to develop
    within Zend Framework. Fortunately doing this is relatively easy, and almost never
    causes any problems, and when it does, it is usually related to Git not being
    able to retrieve the code. When Git isn't able to retrieve the skeleton, please
    make sure there are no spelling mistakes in the command, and that Git has outside
    access (we can test this by typing `ping Github.com` and see whether we get a
    response back).
  prefs: []
  type: TYPE_NORMAL
- en: The method we are going to use to retrieve the skeleton is called **cloning**,
    through a version control system called Git. Cloning the source code will make
    sure we always get the latest version that the developer (in this case Zend itself)
    has put online.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can clone the skeleton—and almost everything else on Github for that matter
    — through use of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Moving the skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once finished we can go into the newly created folder called `ZendSkeletonApplication`,
    and copy and paste everything in there over to our web server document root. On
    a Linux system this is usually `/var/www` (this is also the case when we use Zend
    Server, as described in the [Appendix](apa.html "Appendix A. Setting up the Essentials"),
    *Setting up the Essentials*). We can do this, for example, by typing the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the Composer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When everything is copied over, we are going to initialize the project by typing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now the **Command Line Interface** (**CLI**) of PHP executes `composer.phar`,
    which will in this instance, download and install the Zend Framework 2 library
    and set up a simple project for us to be able to work in.
  prefs: []
  type: TYPE_NORMAL
- en: This command can take a long time before it is successfully executed, as Composer
    needs to do a lot of things before it tells you that Zend Framework 2 is ready
    for use, we won't go into the details of the workings of Composer here, as it
    is already discussed in the [Appendix](apa.html "Appendix A. Setting up the Essentials"),
    *Setting up the Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Once this command has been completed we need to make sure our web server document
    root is changed to match the layout of the skeleton. It is common practice that
    Zend Framework 2 uses the `public` folder as a main landing point for the application.
    The structure of the Zend Framework 2 skeleton allows us to bind the user to the
    `public` folder, while all our logic is safely outside the public area.
  prefs: []
  type: TYPE_NORMAL
- en: In essence this means we need to `root` or `jail` the web server in using the
    `public` folder first before we can actually see anything that we just installed.
    We want to `root` or `jail` the web server because we don't want the outside world
    to be able to abuse our web server more than necessary, and rooting or jailing
    makes sure that the web server itself has no access to any other folders than
    what it is jailed to, thus making our server a bit more secure.
  prefs: []
  type: TYPE_NORMAL
- en: In my personal case this means changing the Apache 2 configuration. In most
    Linux-based systems it will be the Apache web server that is serving our web requests.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest thing that you can do is find your web server configuration (usually
    located in `/etc/apache2` and append the DocumentRoot with `/public`. For me this
    would change the document root from `/var/www' to '/var/www/public`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using Apache, you need to check if the `AllowOverride` setting is
    set correctly, this can be found in the same section as your document root and
    should reflect the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally we need to restart the Apache web server, which can be done by the following
    command if you are logged in as a root user or invoke it by prepending the command
    with `sudo`, which tells the server that we want to execute it as a super user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are able to check our browser and see what we have actually done. We
    now simply go with a web browser to the project created by typing in the URL,
    in my case this would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the Composer](img/4841OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, you have now set up a basic Zend Framework 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After getting the basic Zend Framework 2 skeleton working, it is the perfect
    time to install the ZFTool. The ZFTool is a utility module that comes in handy
    when we want to list the current modules in our project, or add a new module,
    or even set up a new project. It also contains an extremely useful class-map generator
    that we can use in the somewhat more advanced areas of Zend Framework 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install this utility by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although we already set up our Zend Framework 2 skeleton through the composer,
    it might be a fun thing to show you how you can easily set up a new project through
    the ZFTool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a new Zend Framework 2 skeleton project in
    the folder `/var/www/new-project`. In turn this means that the document root for
    our new project should be set to `/var/www/new-project/public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the Zend Framework 2 application in our new-project, we can simply
    go to the new-project directory and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy command of the ZFTool is the creation and display of modules
    in our project. The ZFTool can easily display a list of modules that we currently
    use (with larger applications we tend to lose sight of the modules) and the ability
    to create a new skeleton module for our application. To see a list of the current
    modules used in our application we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new module named `wow-module` in our project based in the directory
    `/var/www/new-project` we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Giving the path to the application is optional, but if we are using it with
    multiple projects on the same machine, it is best to make sure that we have the
    right path for our project.
  prefs: []
  type: TYPE_NORMAL
- en: And now for the last and probably the most useful command in the ZFTool box,
    the class-map generator. A class-map file is a file that has all the classes of
    a project with their respective paths declared, which makes it easier for the
    PHP auto loaders to load the class file. Normally class files are found in paths
    that we know of, creating a small lag because the auto loader actually needs to
    search for the file. With a class-map file, however, this is not the case as the
    auto load can immediately find the file required.
  prefs: []
  type: TYPE_NORMAL
- en: Class-mapping is a big issue in Zend Framework 2 because a bad class mapping
    can make a good application terribly slow, and to be completely fair Zend Framework
    2 can use all the speed it can get.
  prefs: []
  type: TYPE_NORMAL
- en: What the class-map generator does is create a file that contains all the classes
    and paths that can be autoloaded. That way we don't have to worry about where
    the classes are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a new class-map file, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command requires us to give in two different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<directory`>: The directory that needs to have the classes indexed. For example,
    this can be a new library you added to the `vendor` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<file>`: This is the class-map file the ZFTool needs to generate. Our auto
    loader in Zend Framework 2 needs to pick this file up, so we need to make sure
    that the ZFTool can find the file. If you don''t specify a file, it will create
    a file called `autoload_classmap.php` in the current working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time it is necessary to append a class-map file instead of overwriting
    it, if you want to append it you can simply change `-w` with `-a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a class-map file is the `autoload_namespaces.php` file in the
    `vendor/composer` directory, and it looks a little bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also other ways of installing the ZFTool, some are just as easy as
    using the composer, so we'll cover two other methods of installing the ZFTool.
    That way we give ourselves the broadest options available to use.
  prefs: []
  type: TYPE_NORMAL
- en: Another method of installing ZFTool is by utilizing git, and thus cloning the
    source code from the repository itself. This however gets the current master version,
    which can be a bit buggy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `zftool.phar` we have now got the `zf.php` file at our disposal,
    which can be used in exactly the same way. Now we have covered all the different
    options on installing ZFTool.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making sure you have all that you need* recipe in the [Appendix](apa.html
    "Appendix A. Setting up the Essentials"), *Setting up the Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading Zend Framework 2 and finding its documentation* recipe in the
    [Appendix](apa.html "Appendix A. Setting up the Essentials"), *Setting up the
    Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composer and its uses within Zend Framework 2* recipe in the [Appendix](apa.html
    "Appendix A. Setting up the Essentials"), *Setting up the Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache web server [http://apache.org/](http://apache.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP website [http://php.net](http://php.net)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect (if not the most important one) is the routing within Zend
    Framework 2\. In its most basic form routing tells the framework how the user
    should get from page A to page B, and what needs to be done to arrive at that
    destination. That is why we generally think this is the most important part to
    understand if you are just starting out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define a route we can simply go into one of the configuration files and add
    the router configuration to there.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at our simple (`Segment`) configuration as follows (file: `/module/Application/config/module.config.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this basic configuration we can easily define routes in our application,
    and in this instance we have configured a route that responds to the `/website`
    URL. When we would go to the `/website` URL, we would be routed to the `Website\Controller\Index::indexAction`
    by default. If we however use the route `/website/another/route`, we would be
    routed to the `Website\Controller\Another::routeAction`, as we have defined that
    the controller and action can be parsed behind that. If we omit the route path
    and put in `/website/another`, we would be redirected to the `Website\Controller\Another::indexAction`,
    as that is used by default by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example has only one really major drawback, which is, when we
    decide to use anonymous function in the configuration to create more dynamic routes,
    we would not be able to cache the route as closures are not serializeable by the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another method of declaring the route, and that is in the
    code. The need to create the route functionality in the code could (obviously
    everyone has their own reasons and requirements) arise because we want to cache
    the configuration in a later stage (as we cannot cache anonymous function, for
    example) or when we want to load up a route dynamically from a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `/module/Application/Module.php` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Naturally there are more ways of adding a route, but the method mentioned in
    the preceding code for adding a route displays a canny way of dynamically adding
    a route. What we created there is that whenever Gdog goes to his profile, he can
    simply type in `http://example.ext/gdog` and end up on his profile.
  prefs: []
  type: TYPE_NORMAL
- en: Even more wonderful is that if our friend Gdog wants to see his friends, he
    is able to do that by just typing in for example, `http://example.ext/gdog/my/friends`,
    which will resolve to the `Member` module and then go to the `My` controller,
    lastly executing the `Friends` action.
  prefs: []
  type: TYPE_NORMAL
- en: Using SimpleRouteStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This route stack is—as the name implies—the simplest router around and is basically
    a list with routes that is being parsed to see which route matches, by default
    this type of router is not used in Zend Framework 2\. The general rule of thumb
    is that if we want to add a route with a high priority, we give it a high index
    number for example, 100, or 200\. If we want to give the route a very low priority,
    we would give it an index number of, for example, 5 or 10.
  prefs: []
  type: TYPE_NORMAL
- en: Giving priorities to routes comes in handy when we have very specific routes
    (which usually have a high priority) and less specific routes (low priority).
    If we, for example, want to make `/website/url` redirect to a completely different
    module, controller, and action, but not affect the other website routes, we need
    to give the `/website/url` route a higher priority so that when it is found, it
    will not search for the lower priority routes.
  prefs: []
  type: TYPE_NORMAL
- en: If we, by accident, turn the priorities around, we would find our `/website/url`
    always redirect to the route that contains all the `/website` routes.
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleRouteStack` uses a `Zend\Mvc\Router\PriorityList` class to manage its
    routes priorities.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider routing before we want to start creating our application,
    as when the application grows we might get into trouble with our routing if we
    haven't considered 'how to route' beforehand. It would therefore be wise for us
    to 'sitemap' the application before coding the routes to make sure we have a correct
    route list and are not creating any conflicting routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimpleRouteStack` class has a number of methods defined that are very
    useful for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getRoute($name)` / `getRoutes($name)`: This will retrieve the current route—if
    a name is provided—or routes that are defined in our `SimpleRouteStack`. If we
    are unsure about the routes we have defined, this would be a good place to check
    first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addRoute($name, $route, $priority)` / `addRoutes($routes)`: We can use this
    to add a new route or an array of routes to our route type by simply adding it
    through this method. A route requires a `name`, `route` (which can be a string
    or an instance of `RouteInterface`) and if we fancy a priority, we can give that
    as the third parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasRoute($name)`: If we would want to check whether a specific route already
    exists, we can search using its `name` and find out if it does or doesn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: '`removeRoute($name)`: When we are tired of a route we can simply give its name
    and remove it from the list. This can be particularly handy if we want for example
    to have a module override a certain /login when the user has logged in to route
    to/user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleRouteStack`: Does not have a functionality to have multiple routes with
    the same priority. If there is a route with a priority already defined, it will
    prioritize the last route added as the route with the highest priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TreeRouteStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Routers are not restricted to using the URI path to find out how to route a
    request. They can also use other information such as the query parameters, headers,
    methods, or hostnames to find a match.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Zend Framework 2, we will generally use routing that is based on a request
    URI, which contains path segments that should be queried. Routes are matched by
    a router, which utilizes `RouteStack` to find the match to the query made by the
    router. We use `RouteStack` because we want a decent way of managing our different
    routes. With Zend Framework 2 there are loads of route types provided, but only
    two flavorless routers namely `SimpleRouteStack` and `TreeRouteStack`.
  prefs: []
  type: TYPE_NORMAL
- en: When we are defining a router, we need to make sure we understand how it works.
    Although creating lists with different paths is simple enough, it is wise to remember
    that the Zend Framework 2 router generally works with the **Last In First Out**
    (**LIFO**) concept, which means that a route that would be used often would be
    registered last, and a route that is less common would be registered earlier in
    the router stack.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the two standard route types, Zend Framework 2 comes with a whole scale
    of route types that are more specialized to the Internet navigation or even through
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace – Zend\Mvc\Router\Http
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A wonderful set of HTTP routers can be found in the `Zend\Mvc\Router\Http` namespace
    and we will take a quick look at the different classes that reside within this
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The Hostname class explained
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Zend\Mvc\Router\Http\Hostname` namespace will try to match its routing
    against the hostname defined in the configuration. For example, if we define the
    route to be `something.example.ext`, our router will make its routing decision
    based on the full URL. But, if we add a single colon at the beginning of that
    same route, for example: `:something.example.ext`, the router would base its route
    on the `something` variable, which could be anything from `aardvark.example.ext`
    to `zyxt.example.ext`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Literal class explained
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Literal` class will literally match the path we give
    in. For example, if we put a route in there, which is `/grouphug`, the route will
    only resolve to that URL, and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Methods explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Method` class is used when we want to match against
    an HTTP method instead of a segment or path. This could be, for example, a `POST`,
    `DELETE` and so on. The method is also called `verb` by Zend Framework 2, which
    means that instead of a `route` parameter, it requests a `verb` parameter when
    adding the route, which is an excellent way to create RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Part class explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Part` class is used to describe `child_routes` in
    our routing configuration. This means that—although never used directly—we can
    define that `/user/profile` is being redirected to use the `UserController`, with
    the `profile` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Regex explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Regex` class would be used when we have a complex
    routing structure that requires us to dynamically create the route. This would,
    for example, come in handy when we look at News sites, where posts are built up
    like `/archive/some-subject-2013.html`. This fairly complex route (as `some-subject-2013.html`
    is dynamic in our case) would require a `Regex` router that can resolve the Controller,
    Action, and in our case also the output format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, it is important to note that `/archive/%id%.%format%`
    tells us that we will receive two parameters in our method called `indexAction`
    that is, `id` and `format`.
  prefs: []
  type: TYPE_NORMAL
- en: The Scheme class explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Scheme` class is always using the `defaults` parameter
    and will accept only one other parameter, which is called `scheme` and can only
    contain one of the following options, that is, `http`, `https`, and `mailto`.
  prefs: []
  type: TYPE_NORMAL
- en: The Segment class explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Zend\Mvc\Router\Http\Segment` class is probably one of the most-used routers
    that we would use, as you can dynamically define the route and controller for
    any module by using, for example, `/:controller/:action`, which is easily recognizable
    by the colon separation. We can define any `constraints` to the segment by configuring
    only the use of alphanumeric characters or another definition that we would like
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: An example of `Segment` is given in the first example in the *How to do it...*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about the dependency injection, or in short DI, we talk about the
    simple task of, for example, injecting data in object or methods at initialization
    when needed by one or other higher up classes, which either modify or dispose
    off the object after use. The DI is probably the most complex feature in Zend
    Framework 2 to understand. Unfortunately because DI's over complexity in debugging
    and performance and the Service Locator (explained in [Chapter 6](ch06.html "Chapter 6. Modules,
    Models, and Services"), *Modules, Models and Services*). However, although it
    is not the best tool in the shed, we must try to learn it, because when mastered
    it could prove to be a very powerful tool to create a very maintainable piece
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: If we come across a situation where it is necessary for us to input a lot of
    parameters in classes because of objects deeper in the code are dependent on them
    is probably the most annoying and un-maintainable piece of code that we can find
    in even the most professional environment. We need to think mainly about objects
    that are used more than once in an application, and always required to instantiate
    again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us take a look at the following example and assume that `FirstClass` is
    the only class that we will actually need further in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both the preceding examples give either variables that are only used to instantiate
    another class and/or add complexity in reading the code. Although they both are
    correct, the use of DI can, in this case, make the configuration of both the classes
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the DI at call-time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at this DI example, considering that we have the same classes
    as the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we simply say to the DI that `AnotherNamespace\ThirdClass`
    has two parameters in its `__construct` method. The DI will then utilize `Reflection`
    to find out what parameters are present there, and will then give any class that
    has a `first_name`, `vehicle`, or `last_name` parameter in its constructor that
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course we will see a potential flaw here, as you might need to utilize multiple
    instantiations, one can presume that at some point the same parameter name will
    be used. In our example, it would cause a problem if another class also has a
    `$first_name` parameter but requires a different input, as the DI will simply
    give the one that is in its list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we use DI to instantiate our classes and all we need the constructor for
    is to set our variables, we can easily remove the constructor altogether as the
    DI doesn't use the constructor to initialize the variables. Instead the DI will
    just set the properties of the values.
  prefs: []
  type: TYPE_NORMAL
- en: One good thing about this is that this can flaw only happens when we use the
    DI at a call-time level, and not in a global configuration level as we will see
    now. That is why it isn't recommended to use the DI at call-time level at all.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the DI through a Configuration object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we also can do to create a more specific (or accurate) initialization of
    our object – and to make sure classes with the same property names don't conflict
    – is initializing the DI with a configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this is that we first create a configuration object (or array)
    that defines which classes need which properties set, and then use that to initialize
    the DI, which in its turn finds out when it needs to initiate what.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example, which shows you the exact thing we just
    explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To make everything even nicer, we would just put the `Zend\Di\Configuration`
    of the DI in the bootstrap of our module, so that we can use it easily throughout
    the namespace. This way we can simply put the configuration of the DI in our `module.config.php`
    and let the framework take care of it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DI or dependency injector is an important, and most of the time overlooked
    feature of Zend Framework 2\. The DI makes our lives a lot easier by automatically
    finding the classes we need in our application.
  prefs: []
  type: TYPE_NORMAL
- en: With all its complexity however, comes a couple of features we should be wary
    of.
  prefs: []
  type: TYPE_NORMAL
- en: The DI only gives out one instance of an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that every `get()` call will result in the same instantiation over
    and over again. If we would like a new instance, we would need to call `newInstance()`
    as the DI implements the singleton pattern, which means that all the data persists
    every time we call the `get()` method unless we force a new instance of the DI.
  prefs: []
  type: TYPE_NORMAL
- en: Defining either all properties, or using a Fully Qualified (FQ) setter parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our class has more properties than we define, we will find out that the
    DI will use the last value for every other property in the class. Of course this
    is unwanted, and if we wrote the class ourselves we should consider refactoring
    the configuration and/or class.
  prefs: []
  type: TYPE_NORMAL
- en: However, when there is no other way we can define the right properties only
    by using a **Fully Qualified** (**FQ**) setter parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In our configuration we would then define a very specific property name, for
    example, `class::method:paramPos`. If we take our `ThirdClass` example from earlier
    on, this would then be `ThirdClass::setFirstName:0` and `ThirdClass::setLastName:0`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is loads more we can learn about the DI in Zend Framework 2\. The following
    list provides a very short and compact description of other interesting DI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RuntimeDefinition` (default), `CompilerDefinition` and `ClassDefinition`:
    These definitions are used to determine how to configure our objects. Although
    the default one usually does the job, it can''t hurt to see what the other two
    Definitions do, because they all have their pros and cons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstanceManager`: Used to define the configuration, specifically the `Aliases`,
    `Parameters` and `Preferences`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using configurations to your benefit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configurations play a crucial role in the workings of Zend Framework 2, therefore
    it is essential to know how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go through the following sections to use configurations to your benefit:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a global configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When beginning to code in Zend Framework 2 there is some misunderstanding as
    to what the different configuration files do. By default we have multiple configuration
    files, and it might not always be simple to understand where things need to go.
    That is why we like to apply a simple rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is the configuration necessary throughout all our modules? If yes, place your
    configuration in the `config/application.config.php` file. If not, place your
    configuration in the `config/global.php` file at the module where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration that we usually place in the `global.php` file can be, for
    example, the caching method and configuration, the database configuration. Normally
    we would like to place items in there that are environment related, but nothing
    that is security sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a bad example of `global.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is terrible practice to put the username and password in the `global.php`
    file. The `global.php` file is to be put in our version control, and therefore
    should contain only configuration items that are required to globally run the
    application, not specific information that is relevant per environment, such as
    database usernames and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Creating configuration that only works for a local machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the benefits of the ultra-many configuration files in Zend Framework
    2, is that you are able to override your global configuration with your local
    configuration. This certainly comes in handy when developing and you find yourself
    in a position where your details are slightly different in configuration than
    your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following `/config/autoload/global.php` configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding example, we create a nice and simple MySQL database
    connection to our `somename` database which resides on the localhost. But as good
    developers we have not defined our username and password in here. That is where
    the /`config/autoload/local.php` file comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how our `local.php` might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we are using a version control system (please say yes), we should not commit
    this file, not only for security reasons but also because this is a local configuration
    file and wouldn't be necessary on a live system, as we would create a new one
    with the right details for that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Editing your application.config.php file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we look at our default `config/application.config.php` file we have only
    a few properties set, but loads of inline comments, which really come in handy
    when we can't remember the exact name or description of a property any more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main configuration that we will be changing the most in our application
    as we develop is the `modules` property. This specific property is a simple array
    with the different module namespaces that we have (and want to use) in our application.
    At default this looks somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we add or remove a module, this line needs to be modified as well and one
    can even suggest modifying this before starting a new module or removing one.
    The reason for this is simple, when we forget to modify this file when removing
    a module it will generate a `500 – Application Error` when visiting the application
    in our browser. And because this configuration file is read quite early in the
    instantiation, it can sometimes be hard for the developer to pinpoint why the
    application fails to load all of a sudden.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look at the `index.php` file in the `public` folder, we can see that we
    parse our initial configuration file to the Zend Framework MVC Application with
    the line `require 'config/application.config.php'`. This then loads up the main
    configuration file, which in its turn defines all our properties.
  prefs: []
  type: TYPE_NORMAL
- en: A nifty property in the `application.config.php` file is the `config_glob_paths`
    property. Any additional configuration files are by default read by finding files
    in the `config/autoload` folder as well, using a very specific file pattern namely;
    `*global.php` and `*local.php`. The order in which this is defined is also very
    important.
  prefs: []
  type: TYPE_NORMAL
- en: When we say `*global.php`, we can define anything from `somemodule.global.php`
    to `menu.global.php` to just `global.php`, as the file pattern (also named `GLOB_BRACE`)
    searches for anything that matches that. The same happens for `*local.php`.
  prefs: []
  type: TYPE_NORMAL
- en: The order this is defined is very important as said before because we want our
    global configuration to be loaded before our local configuration, otherwise there
    would be no point in overriding our global configuration, would there?
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize the configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config/application.config.php`: Modules can be added and removed here, and
    very low level configuration happens here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config/autoload/some-module.global.php`: Used to override your default values
    of your module configuration. Make sure not to put sensitive information in here,
    but hostnames and database names should go in here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config/autoload/some-module.local.php`: You can put your usernames and passwords
    and other configuration items that are very specific to your local environment
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module/SomeModule/config/module.config.php`: Module specific configuration
    happens here, use only default values and make sure nothing too specific will
    be entered here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EventManager and Bootstrap classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be showing off one of the most beautiful features of Zend Framework
    2: The EventManager.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `EventManager` and `Bootstrap` classes are an essential part of our application,
    this recipe is all about how to use those two tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the bootstrap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bootstrap is in our case the start of a module, whenever a module is requested
    it will use the `onBootstrap()` method located in the `Module.php` file. Although
    the method is not required, we usually want this method in our module as it is
    an easy method of making sure that some instances already exist or are configured
    before venturing further in our client request.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sessions are a wonderful way of saving information about a user on a temporary
    basis. Think about saving the information of a logged-in user, or history on the
    pages they have been. Once we begin creating an application we find ourselves
    saving a lot of things in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is modify the `/module/Application/config/module.config.php`
    file, and add another section called `session` to it. Let''s assume that we have
    a completely empty module configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is it. Sessions are now useable in our controllers and models. We
    have now created two session containers that we can use to store our information
    in. We can access these containers in any Controller or Model that has a service
    locator available by doing the following (file: `/module/Application/src/Application/Controller/IndexController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using the EventManager class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `EventManager` class is possibly one of the nicest features in the framework.
    When used properly, it can make our code a lot more dynamic and maintainable without
    creating spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: What it does is relatively simple, for example; a class might have a method
    called `MethodA`. This `MethodA` has a list of listeners, which are interested
    in the outcome of that class. When `MethodA` executes, it just runs through its
    normal procedures, and when finished it just notifies the `EventManager` a specific
    event has occurred. Now the `EventManager` will trigger all of the interested
    parties that this event has taken place, and the parties in their turn will execute
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Got it? Don''t worry if you don''t, because this example code might clear things
    up (file: `/module/Application/src/Application/Model/SwagMachine.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see we created a little class with two event triggers, `findSwag.begin`
    and `findSwag.end`, respectively on the beginning of the method, and one on the
    end of the method. The `findSwag.begin` event will potentially modify the `$id`,
    and the `findSwag.end` event only parses the `returnValue` object, with no modification
    possible to the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the code that implements the triggers (file: `/module/Application/src/Application/Controller/IndexController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see attaching triggers to events is pretty straightforward. And –
    if the events are properly documented – can come in handy when we want to, say,
    modify parameters going into a method (like we did with the `findSwag.begin`),
    or just outputting the results to a log (like `findSwag.end`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at what is on our screen, it should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The result consists of the top line being the output from the `findSwag.end`
    trigger, while the value `60` comes from the highest priority trigger, the one
    with priority `100` (as that is considered a higher priority than `200`).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the View output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it is necessary that we have different View outputs, for example when
    we need to build ourselves a REST service or a SOAP service. Although this can
    be arranged much simpler by a controller plugin, it is an example on how to hook
    into the `dispatch` event, and see what is going on there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let us take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see it is relatively simple to attach a callback function to the `EventManager`
    object. In this example we are using `McvEvent::EVENT_DISPATCH` as the event we
    want to hook in to. So what basically happens is that whenever a controller executes
    the `onDispatch()` method, this event will be triggered as well. This means that
    through events we can modify the outcome of a method without actually needing
    to modify the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EventManager class works through a couple of different methods, namely the
    Observer pattern, the Aspect-Oriented Programming technique (or AOP) and the Event-Driven
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply said the Observer pattern means that there are several interested parties,
    called listeners that want to know when the application triggers a certain event.
    When a specific event is triggered, the listeners will be notified so that they
    can take their necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-Oriented Programming (AOP) explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to explain what AOP is, we could say that in short it stands for
    writing clean code that have only function and are as isolated from the rest of
    the code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture explained
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The benefit of an Event-driven architecture is that instead of creating bulks
    of code that need to check every condition, we can easily hook ourselves to different
    events, which in essence will create a more responsive application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EventManager` object is queried through a `PriorityQueue`, which tells
    us that an important event will generally get a lower value, while an unimportant
    event a higher value. For example, the highest priority might get priority `-1000`
    while a quite low priority might get 40\. The `EventManager` class then gets the
    queue through a **FIFO** (**First In, First Out**) concept, meaning the higher
    the priority, the lower the number.
  prefs: []
  type: TYPE_NORMAL
