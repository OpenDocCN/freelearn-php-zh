- en: Chapter 3. Understanding PHP Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning a new language is not easy. You need to understand not only the syntax
    of the language, but also its grammatical rules, that is, when and why to use
    each element of the language. Luckily for you, some languages come from the same
    root. For example, Spanish and French are Romance languages, as they both evolved
    from spoken Latin; that means that these two languages share a lot of rules, and
    if you already know French, learning Spanish becomes much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages are quite the same. If you already know another programming
    language, it will be very easy for you to go through this chapter. If this is
    your first time though, you will need to understand all those grammatical rules
    from scratch, and so, it might take some more time. But fear not! We are here
    to help you in this endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables, strings, arrays, and operators in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PHP filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From now on, we will work on your `index.php` file, so you can just start the
    web server, and go to `http://localhost:8080` to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: You might have already noticed that in order to write PHP code, you have to
    start the file with `<?php`. There are other options, and you can also finish
    the file with `?>`, but none of them are needed. What is important to know is
    that you can mix PHP code with other content, like HTML, CSS, or JavaScript, in
    your PHP file as soon as you enclose the PHP bits with the `<?php ?>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will learn in [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, why it is usually a bad idea
    to mix PHP and HTML. For now, assuming that it is bad, let''s try to avoid it.
    For that, you can include one file from another PHP file using any one of these
    four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include`: This will try to find and include the specified file each time it
    is invoked. If the file is not found, PHP will throw a warning, but will continue
    with the execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`: This will do the same as `include`, but PHP will throw an error
    instead of a warning if the file is not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_once`: This function will do what `include` does, but it will include
    the file only the first time that it is invoked. Subsequent calls will be ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require_once`: This works the same as `require`, but it will include the file
    only the first time that it is invoked. Subsequent calls will be ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each function has its own usage, so it is not right to say that one is better
    than the other. Just think carefully what your scenario is, and then decide. For
    example, let''s try to include our `index.html` file from our `index.php` file
    such that we do not mix PHP with HTML, but have the best of both worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We chose `require` as we know the file is there—and if it is not, we are not
    interested in continuing the execution. Moreover, as it is some HTML code, we
    might want to include it multiple times, so we did not choose the `require_once`
    option. You can try to require a file that does not exist, and see what the browser
    says.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP does not consider empty lines; you can add as many as you want to make
    your code easier to read, and it will not have any repercussion on your application.
    Another element that helps in writing understandable code, and which is ignored
    by PHP, is comments. Let''s see both in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code does the same job as the previous one, but now everyone will easily
    understand what we are trying to do. We can see two types of comments: single-line
    comments and multiple-line comments. The first type consists of a single line
    starting with `//`, and the second type encloses multiple lines within `/*` and
    `*/`. We start each commented line with an asterisk, but that is completely optional.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables keep a value for future reference. This value can change if we want
    it to; that is why they are called variables. Let''s take a look at them in an
    example. Save this code in your `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this preceding piece of code, we have three variables: `$a` has value `1`,
    `$b` has `2`, and `$c` contains the sum of `$a` and `$b`, hence, `$c` equals 3\.
    Your browser should print the value of the variable `$c`, which is 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value to a variable means to give it a value, and it is done with
    the equals sign as shown in the previous example. If you did not assign a value
    to a variable, we will get a notice from PHP when it checks its contents. A notice
    is just a message telling us that something is not exactly right, but it is a
    minor problem and you can continue with the execution. The value of an unassigned
    variable will be null, that is, nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP variables start with the `$` sign followed by the variable name. A valid
    variable name starts with a letter or an underscore followed by any combination
    of letters, numbers, and/or underscores. It is case sensitive. Let''s see some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember that everything after `//` is a comment, and is thus ignored by PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In this piece of code, we can see that variable names like `$_some_value` and
    `$go_2_home` are valid. `$1number` and `$some$signs%` are not valid as they start
    with a number, or they contain invalid symbols. As names are case sensitive, `$go_2_home`
    and `$go_2_Home` are two different variables. Finally, we show the CamelCase convention,
    which is the preferred option among most developers.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can assign more than just numbers to variables. PHP has eight primitive
    types, but for now, we will focus on its four scalar types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Booleans**: These take just true or false values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integers**: These are numeric values without a decimal point, for example,
    2 or 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point numbers or floats**: These are numbers with a decimal point,
    for example, 2.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings**: These are concatenations of characters which are surrounded by
    either single or double quotes, like ''this'' or "that"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though PHP defines these types, it allows the user to assign different
    types of data to the same variable. Check the following code to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the result on your browser, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code first assigns the value `123` to the variable `$number`. As `123` is
    an integer, the type of the variable will be integer `int`. That is what we see
    when printing the content of the variable with `var_dump`. After that, we assign
    another value to the same variable, this time a string. When printing the new
    content, we see that the type of the variable changed from integer to string,
    yet PHP did not complain at any time. This is called **type juggling**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check another piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You already know that the `+` operator returns the sum of two numeric values.
    You will see later that the `.` operator concatenates two strings. Thus, the preceding
    code assigns a string and an integer to two variables, and then tries to add and
    concatenate them.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to add them, PHP knows that it needs two numeric values, and so
    it tries to adapt the string to an integer. In this case, it is easy as the string
    represents a valid number. That is the reason why we see the first result as an
    integer 3 (*1 + 2*).
  prefs: []
  type: TYPE_NORMAL
- en: In the last line, we are performing a string concatenation. We have an integer
    in `$b`, so PHP will first try to convert it to a string—which is "2"—and then
    concatenate it with the other string, "1". The result is the string "12".
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Type juggling**'
  prefs: []
  type: TYPE_NORMAL
- en: PHP tries to convert the data type of a variable only when there is a context
    where the type of variable needed is different. But PHP does not change the value
    and type of the variable itself. Instead, it will take the value and try to transform
    it, leaving the variable intact.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using variables is nice, but if we cannot make them interact with each other,
    there is nothing much we can do. **Operators** are elements that take some expressions—operands—and
    perform actions on them to get a result. The most common examples of operators
    are arithmetic operators, which you already saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: An **expression** is almost anything that has a value. Variables, numbers, or
    text are examples of expressions, but you will see that they can get way more
    complicated. Operators expect expressions of a specific type, for example, arithmetic
    operators expect either integers or floats. But as you already know, PHP takes
    care of transforming the types of the expressions given whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the most important groups of operators.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic operators are very intuitive, as you already know. Addition, subtraction,
    multiplication, and division (`+`, `-`, `*`, and `/`) do as their names say. Modulus
    (`%`) gives the remainder of the division of two operands. Exponentiation (`**`)
    raises the first operand to the power of the second. Finally, negation (`-`) negates
    the operand. This last one is the only arithmetic operator that takes just one
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, they are quite easy to understand!
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know this one too, as we have been using it in our examples. The
    assignment operator assigns the result of an expression to a variable. Now you
    know that an expression can be as simple as a number, or, for example, the result
    of a series of arithmetic operations. The following example assigns the result
    of an expression to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a series of assignment operators that work as shortcuts. You can
    build them combining an arithmetic operator and the assignment operator. Let''s
    see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comparison operators are one of the most used groups of operators. They take
    two operands and compare them, returning the result of the comparison usually
    as a Boolean, that is, `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four comparisons that are very intuitive: `<` (less than), `<=` (less
    or equal to), `>` (greater than), and `>=` (greater than or equal to). There is
    also the special operator `<=>` (spaceship) that compares both the operands and
    returns an integer instead of a Boolean. When comparing *a* with *b*, the result
    will be less than 0 if *a* is less than *b*, 0 if *a* equals *b*, and greater
    than 0 if *a* is greater than *b*. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are comparison operators to evaluate if two expressions are equal or
    not, but you need to be careful with type juggling. The `==` (equals) operator
    evaluates two expressions *after* type juggling, that is, it will try to transform
    both expressions to the same type, and then compare them. Instead, the `===` (identical)
    operator evaluates two expressions *without* type juggling, so even if they look
    the same, if they are not of the same type, the comparison will return `false`.
    The same applies to `!=` or `<>` (not equal to) and `!==` (not identical):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see that when asking if a string and an integer that represent the same
    number are equal, it replies affirmatively; PHP first transforms both to the same
    type. On the other hand, when asked if they are identical, it replies they are
    not as they are of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators apply a logic operation—also known as a binary operation—to
    its operands, returning a Boolean response. The most used ones are `!` (not),
    `&&` (and), and `||` (or). `&&` will return `true` only if both operands evaluate
    to `true`. `||` will return `true` if any or both of the operands are `true`.
    `!` will return the negated value of the operand, that is, `true` if the operand
    is `false` or `false` if the operand is `true`. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Incrementing and decrementing operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incrementing/decrementing operators are also shortcuts like `+=` or `-=`, and
    they only work on variables. There are four of them, and they need special attention.
    We''ve already seen the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: '`++`: This operator on the left of the variable will increase the variable
    by 1, and then return the result. On the right, it will return the content of
    the variable, and after that increase it by 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--`: This operator works the same as `++` but decreases the value by 1 instead
    of increasing by 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, on the first assignment to `$b`, we use `$a++`. The operator
    on the right will return first the value of `$a`, which is `3`, assign it to `$b`,
    and only then increase `$a` by 1\. In the second assignment, the operator on the
    left first increases `$a` by 1, changes the value of `$a` to `5`, and then assigns
    that value to `$b`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add multiple operators to an expression to make it as long as it needs
    to be, but you need to be careful as some operators have higher precedence than
    others, and thus, the order of execution might not be the one you expect. The
    following table shows the order of precedence of the operators that we''ve studied
    until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `++`, `--` | Increasing/decreasing |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `*`, `/`, `%` | Arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `+`, `-` | Arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `<`, `<=`, `>`, `>=` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `==`, `!=`, `===`, `!==` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=` | Assignment |'
  prefs: []
  type: TYPE_TB
- en: The preceding table shows us that the expression *3+2*3* will first evaluate
    the product *2*3* and then the sum, so the result is 9 rather than 15\. If you
    want to perform operations in a specific order, different from the natural order
    of precedence, you can force it by enclosing the operation within parentheses.
    Hence, *(3+2)*3* will first perform the sum and then the product, giving the result
    15 this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples to clarify this quite tricky subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding example could be endless, and still not be able to cover all
    the scenarios you can imagine, so let''s keep it simple. In the first highlighted
    line, we have a combination of arithmetic, comparison, and logical operators,
    plus the assignment operator. As there are no parentheses, the order is the one
    detailed in the previous table. The operator with the highest preference is the
    sum, so we perform it first: `$a` + `$b` equals 4\. The next one is the comparison
    operator, so *4 > 5*, which is `false`. Finally, the logical operator, `false`
    || `$c` (`$c` is `true`) results in `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second example might need a bit more explanation. The first operator we
    see in the table is the negation, so we resolve it. `!$d` is `!false`, so it is
    `true`. The expression is now, `$e` == `true` && `true`. First we need to solve
    the comparison `$e` == `true.` Knowing that `$e` is `true`, the comparison results
    in `true`. The final operation then is the logical end, and it results in `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Try to work out the last example by yourself to get some practice. Do not be
    afraid if you think we are not covering operators enough. During the next few
    sections, we will see a lot of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with strings in real life is really easy. Actions like *Check if this
    string contains this* or *Tell me how many times this character appears* are very
    easy to perform. But when programming, strings are concatenations of characters
    that you cannot see at once when searching for something. Instead, you have to
    look one by one and keep track of what the content is. In this scenario, those
    really easy actions are not that easy any more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for you, PHP brings a whole set of predefined functions that help you
    in interacting with strings. You can find the entire list of functions at [http://php.net/manual/en/ref.strings.php](http://php.net/manual/en/ref.strings.php),
    but we will only cover the ones that are used the most. Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding long piece of code, we are playing with a string with different
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strlen`: This function returns the number of characters that the string contains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim`: This function returns the string, removing all the blank spaces to
    the left and to the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strtoupper` and `strtolower`: These functions return the string with all the
    characters in upper or lower case respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str_replace`: This function replaces all occurrences of a given string by
    the replacement string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substr`: This function extracts the string contained between the positions
    specified by parameters, with the first character being at position 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strpos`: This function shows the position of the first occurrence of the given
    string. It returns `false` if the string cannot be found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there is an operator for strings (`.`) which concatenates two
    strings (or two variables transformed to a string when possible). Using it is
    really simple: in the following example, the last statement will concatenate all
    the strings and variables forming the sentence, *I am Hiro Nakamura!*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing to note about strings is the way they are represented. So far,
    we have been enclosing the strings within single quotes, but you can also enclose
    them within double quotes. The difference is that within single quotes, a string
    is exactly as it is represented, but within double quotes, some rules are applied
    before showing the final result. There are two elements that double quotes treat
    differently than single quotes: escape characters and variable expansions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Escape characters**: These are special characters than cannot be represented
    easily. Examples of escape characters are new lines or tabs. To represent them,
    we use escape sequences, which are the concatenation of a backslash (`\`) followed
    by some other character. For example, `\n` represents a new line, and `\t` represents
    a tabulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable expanding**: This allows you to include variable references inside
    the string, and PHP replaces them by their current value. You have to include
    the `$` sign too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code will print the following in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `\n` inserted a new line. `\"` added the double quotes (you need to escape
    them too, as PHP would understand that you want to end your string), and the variables
    `$firstname` and `$surname` were replaced by their values.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have some experience with other programming languages or data structures
    in general, you might be aware of two data structures that are very common and
    useful: **lists** and **maps**. A list is an ordered set of elements, whereas
    a map is a set of elements identified by keys. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element is a list of names that contains three values: `Harry`, `Ron`,
    and `Hermione`. The second one is a map, and it defines two values: `James Potter`
    and `dead`. Each of these two values is identified with a key: `name` and `status`
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, we do not have lists and maps; we have arrays. An array is a data structure
    that implements both, a list and a map.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have different options for initializing an array. You can initialize an
    empty array, or you can initialize an array with data. There are different ways
    of writing the same data with arrays too. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define the list and map from the previous section.
    `$names1` and `$names2` are exactly the same array, just using a different notation.
    The same happens with `$status1` and `$status2`. Finally, `$empty1` and `$empty2`
    are two ways of creating an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later you will see that lists are handled like maps. Internally, the array
    `$names1` is a map, and its keys are ordered numbers. In this case, another initialization
    for `$names1` that leads to the same array could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Keys of an array can be any alphanumeric value, like strings or numbers. Values
    of an array can be anything: strings, numbers, Booleans, other arrays, and so
    on. You could have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This array is a list that contains two arrays—maps. Each map contains different
    values like strings, doubles, and Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Populating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays are not immutable, that is, they can change after being initialized.
    You can change the content of an array either by treating it as a map or as a
    list. Treating it as a map means that you specify the key that you want to override,
    whereas treating it as a list means appending another element to the end of the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first highlighted line appends the name `Neville`
    to the list of names, hence the list will look like *['Harry', 'Ron', 'Hermione',
    'Neville']*. The second change actually adds a new key-value to the array. You
    can check the result from your browser by using the function `print_r`. It does
    something similar to `var_dump`, just without the type and size of each value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**print_r and var_dump in a browser**'
  prefs: []
  type: TYPE_NORMAL
- en: When printing the content of an array, it is useful to see one key-value per
    line, but if you check your browser, you will see that it displays the whole array
    in one line. That happens because what the browser tries to display is HTML, and
    it ignores new lines or whitespaces. To check the content of the array as PHP
    wants you to see it, check the source code of the page—you will see the option
    by right-clicking on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to remove an element from the array, instead of adding or updating
    one, you can use the `unset` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new `$status` array contains the key name only.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing an array is as easy as specifying the key as when you were updating
    it. For that, you need to understand how lists work. You already know that lists
    are treated internally as a map with numeric keys in order. The first key is always
    0; so, an array with *n* elements will have keys from 0 to *n-1*.
  prefs: []
  type: TYPE_NORMAL
- en: You can add any key to a given array, even if it previously consisted of numeric
    entries. The problem arises when adding numeric keys, and later, you try to append
    an element to the array. What do you think will happen?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of that last piece of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When trying to append a value, PHP inserts it after the last numeric key, in
    this case `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might''ve already figured it out by yourself, but you can always print
    any part of the array by specifying its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, trying to access a key that does not exist in an array will return
    you a null and throw a notice, as PHP identifies that you are doing something
    wrong in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The empty and isset functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two useful functions for enquiring about the content of an array.
    If you want to know if an array contains any element at all, you can ask if it
    is empty with the `empty` function. That function actually works with strings
    too, an empty string being a string with no characters ('' ''). The `isset` function
    takes an array position, and returns `true` or `false` depending on whether that
    position exists or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see that an array with no elements or a string
    with no characters will return `true` when asked if it is empty, and `false` otherwise.
    When we use `isset($names[2])` to check if the position 2 of the array exists,
    we get `true`, as there is a value for that key: `Hermione`. Finally, `isset($names[3])`
    evaluates to `false` as the key 3 does not exist in that array.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably, one of the most used functions with arrays is `in_array`. This function
    takes two values, the value that you want to search for and the array. The function
    returns `true` if the value is in the array and `false` otherwise. This is very
    useful, because a lot of times what you want to know from a list or a map is if
    it contains an element, rather than knowing that it does or its location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more useful sometimes is `array_search`. This function works in the same
    way except that instead of returning a Boolean, it returns the key where the value
    is found, or `false` otherwise. Let''s see both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Ordering arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array can be sorted in different ways, so there are a lot of chances that
    the order that you need is different from the current one. By default, the array
    is sorted by the order in which the elements were added to it, but you can sort
    an array by its key or by its value, both ascending and descending. Furthermore,
    when sorting an array by its values, you can choose to preserve their keys or
    to generate new ones as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a complete list of these functions on the official documentation website
    at [http://php.net/manual/en/array.sorting.php](http://php.net/manual/en/array.sorting.php),
    but here we will display the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Sorts by | Maintains key association | Order of sort |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Value | No | Low to high |'
  prefs: []
  type: TYPE_TB
- en: '| `rsort` | Value | No | High to low |'
  prefs: []
  type: TYPE_TB
- en: '| `asort` | Value | Yes | Low to high |'
  prefs: []
  type: TYPE_TB
- en: '| `arsort` | Value | Yes | High to low |'
  prefs: []
  type: TYPE_TB
- en: '| `ksort` | Key | Yes | Low to high |'
  prefs: []
  type: TYPE_TB
- en: '| `krsort` | Key | Yes | High to low |'
  prefs: []
  type: TYPE_TB
- en: 'These functions always take one argument, the array, and they do not return
    anything. Instead, they directly sort the array we pass to them. Let''s see some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, there is a lot going on in the last example. First of all, we initialize
    an array with some key values and assign it to `$properties`. Then we create three
    variables that are copies of the original array—the syntax should be intuitive.
    Why do we do that? Because if we sort the original array, we will not have the
    original content any more. This is not what we want in this specific example,
    as we want to see how the different sort functions affect the same array. Finally,
    we perform three different sorts, and print each of the results. The browser should
    show you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `sort`, orders the values alphabetically. Also, if you check
    the keys, now they are numeric as in a list, instead of the original keys. Instead,
    `asort` orders the values in the same way, but keeps the association of key-values.
    Finally, `ksort` orders the elements by their keys, alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How to remember so many function names**'
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP has a lot of function helpers that will save you from writing customized
    functions by yourself, for example, it provides you with up to 13 different sorting
    functions. And you can always rely on the official documentation. But, of course,
    you would like to write code without going back and forth from the docs. So, here
    are some tips to remember what each sorting function does:'
  prefs: []
  type: TYPE_NORMAL
- en: An `a` in the name means **associative**, and thus, will preserve the key-value
    association.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `r` in the name means **reverse**, so the order will be from high to low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `k` means **key**, so the sorting will be based on the keys instead of the
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are around 80 different functions related to arrays. As you can imagine,
    you will never even hear about some of them, as they have very specific purposes.
    The complete list can be found at [http://php.net/manual/en/book.array.php](http://php.net/manual/en/book.array.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a list of the keys of the array with `array_keys`, and a list of
    its values with `array_values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the number of elements in an array with the `count` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can merge two or more arrays into one with `array_merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example will print the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the keys of the second array are now different, as originally,
    both the arrays had the same numeric keys, and an array cannot have two values
    for the same key.
  prefs: []
  type: TYPE_NORMAL
- en: PHP in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the main purpose of this chapter is to show you the basics of PHP,
    doing it in a reference-manual kind of a way is not interesting enough, and if
    we were to copy-paste what the official documentation says, you might as well
    go there and read it by yourself. Keeping in mind the main purpose of this book
    and your main goal is to write web applications with PHP, let us show you how
    to apply everything you are learning as soon as possible, before you get too bored.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do that, we will now start on a journey towards building an online
    bookstore. At the very beginning, you might not see the usefulness of it, but
    that is just because we've still not shown all that PHP can do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by building a home page. In this page, we are going to figure out
    if the user is looking for a book or just walking by. How do we find that out?
    The easiest way right now is to inspect the URL that the user used to access our
    application, and extract some information from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this content as your `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now access the link, `http://localhost:8000/?author=HarperLee&title=To Kill
    a Mockingbird`. You will see that the page prints some of the information that
    you passed on to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each request, PHP stores all the parameters that come from the query string
    in an array called `$_GET`. Each key of the array is the name of the parameter,
    and its associated value is the value of the parameter. So `$_GET` contains two
    entries: `$_GET[''author'']` contains `Harper Lee` and `$_GET[''title'']` has
    the value `To Kill a Mockingbird`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first highlighted line, we assign a Boolean value to the variable `$looking`.
    If either `$_GET['title']` or `$_GET['author']` exists, that variable will be
    `true`, otherwise `false`. Just after that, we close the PHP tag and then we print
    some HTML, but as you can see, we are actually mixing the HTML with some PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting line here is the second highlighted one. Before printing
    the content of `$looking`, we cast the value. **Casting** means forcing PHP to
    transform a type of value to another one. Casting a Boolean to an integer means
    that the resultant value will be `1` if the Boolean is `true` or `0` if the Boolean
    is `false`. As `$looking` is `true` since `$_GET` contains valid keys, the page
    shows a "1".
  prefs: []
  type: TYPE_NORMAL
- en: If we try to access the same page without sending any information, as in `http://localhost:8000`,
    the browser will say **Are you looking for a book? 0**. Depending on the settings
    of your PHP configuration, you will see two notice messages complaining that you
    are trying to access keys of the array that do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Casting versus type juggling**'
  prefs: []
  type: TYPE_NORMAL
- en: We already know that when PHP needs a specific type of variable, it will try
    to transform it, which is called type juggling. But PHP is quite flexible, so
    sometimes, you have to be the one specifying the type that you need. When printing
    something with `echo`, PHP tries to transform everything it gets into strings.
    Since the string version of the Boolean `false` is an empty string, that would
    not be useful for our application. Casting the Boolean to an integer first assures
    that we will see a value, even if it is just a 0.
  prefs: []
  type: TYPE_NORMAL
- en: HTML forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTML forms are one of the most popular ways of collecting information from
    the user. They consist of a series of fields—called `input` in the HTML world—and
    a final `submit` button. In HTML, the `form` tag contains two attributes: `action`
    points where the form will be submitted, and `method`, which specifies the HTTP
    method that the form will use (GET or POST). Let''s see how it works. Save the
    following content as `login.html` and go to `http://localhost:8000/login.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The form defined in the preceding code contains two fields, one for the username
    and one for the password. You can see that they are identified by the attribute
    name. If you try to submit this form, the browser will show you a **Page Not Found**
    message, as it is trying to access `http://localhost:8000/authenticate.php` and
    the web server cannot find it. Let''s create it then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with `$_GET`, `$_POST` is an array that contains the parameters received
    by POST. In this preceding piece of code, we first ask if that array is not empty—note
    the `!` operator. Afterwards, we just display the information received, just as
    in `index.php`. Notice that the keys of the `$_POST` array are the values for
    the argument name of each input field.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want the browser to remember some data like whether you are logged in
    or not on your web application, your basic info, and so on, we use **cookies**.
    Cookies are stored on the client side and are sent to the server when making a
    request as headers. As PHP is oriented towards web applications, it allows you
    to manage cookies in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few things you need to know about cookies and PHP. You can write
    cookies with the `setcookie` function that accepts several arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid name for the cookie as a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the cookie—only strings or values that can be casted to a string.
    This parameter is optional, and if not set, PHP will actually remove the cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expiration time as a timestamp. If not set, the cookie will be removed once
    the browser is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Timestamps**'
  prefs: []
  type: TYPE_NORMAL
- en: Computers use different ways for describing dates and times, and a very common
    one, especially on Unix systems, is the use of timestamps. They represent the
    number of seconds passed since January 1, 1970\. For example, the timestamp that
    represents October 4, 2015 at 6:30 p.m. would be 1,443,954,637, which is the number
    of seconds since that date.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the current timestamp with PHP using the `time` function.
  prefs: []
  type: TYPE_NORMAL
- en: There are other arguments related to security, but they are out of the scope
    of this section. Also note that you can only set cookies if there is no previous
    output from your application, that is, before HTML, `echo` calls, and any other
    similar functions that send some output.
  prefs: []
  type: TYPE_NORMAL
- en: To read the cookies that the client sends to us, we just need to access the
    array, `$_COOKIE`. It works as the other two arrays, so the keys of the array
    will be the name of the cookies and the value of the array will be their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common usage for cookies is authenticating the user. There are several
    different ways of doing so, depending on the level of security you need for your
    application. Let''s try to implement one very simple—albeit insecure one (do not
    use it for live web applications). Leaving the HTML intact, update the PHP part
    of your `authenticate.php` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same with the `body` tag in your `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you access `http://localhost:8000/login.html` again, try to log in, open
    a new tab (in the same browser), and go to the home page at `http://localhost:8000`,
    you will see how the browser still remembers your username.
  prefs: []
  type: TYPE_NORMAL
- en: Other superglobals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$_GET`, `$_POST`, and `$_COOKIE` are special variables called **superglobals**.
    There are other superglobals too, like `$_SERVER` or `$_ENV`, which will give
    you extra information. The first one shows you information about headers, paths
    accessed, and other information related to the request. The second one contains
    the environment variables of the machine where your application is running. You
    can see the full list of these arrays and their elements at [http://php.net/manual/es/language.variables.superglobals.php](http://php.net/manual/es/language.variables.superglobals.php).'
  prefs: []
  type: TYPE_NORMAL
- en: In general, using superglobals is useful, since it allows you to get information
    from the user, the browser, the request, and so on. This is of immeasurable value
    when writing web applications that need to interact with the user. But with great
    power comes great responsibility, and you should be very careful when using these
    arrays. Most of those values come from the users themselves, which could lead
    to security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our files have been executed line by line. Due to that, we have been
    getting notices on some scenarios, such as when the array does not contain what
    we are looking for. Would it not be nice if we could choose which lines to execute?
    Control structures to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: A **control structure** is like a traffic diversion sign. It directs the execution
    flow depending on some predefined conditions. There are different control structures,
    but we can categorize them in **conditionals** and **loops**. A conditional allows
    us to choose whether to execute a statement or not. A loop executes a statement
    as many times as you need. Let's take a look at each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A conditional evaluates a Boolean expression, that is, something that returns
    a value. If the expression is `true`, it will execute everything inside its block
    of code. A block of code is a group of statements enclosed by `{}`. Let''s see
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, we use two conditionals. A conditional is defined
    by the keyword `if` followed by a Boolean expression in parentheses and by a block
    of code. If the expression is `true`, it will execute the block, otherwise it
    will skip it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can increase the power of conditionals by adding the keyword `else`. This
    tells PHP to execute some block of code if the previous conditions were not satisfied.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will execute the code inside the `else` as the condition
    of the `if` was not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can also add an `elseif` keyword followed by another condition
    and a block of code to continue asking PHP for more conditions. You can add as
    many `elseif` as you need after an `if`. If you add an `else`, it has to be the
    last one of the chain of conditions. Also keep in mind that as soon as PHP finds
    a condition that resolves to `true`, it will stop evaluating the rest of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, the first condition that evaluates to `true` is the highlighted
    one. After that, PHP does not evaluate any more conditions until a new `if` starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, let''s try to clean up our application a bit, executing
    statements only when needed. Copy this code to your `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this new code, we have mixed conditionals and HTML code in two different
    ways. The first one opens a PHP tag, and adds an `if…else` clause that will print
    whether we are authenticated or not with an `echo`. No HTML is merged within the
    conditionals, which makes it clear.
  prefs: []
  type: TYPE_NORMAL
- en: The second option—the second highlighted block—shows an uglier solution, but
    sometimes necessary. When you have to print a lot of HTML code, `echo` is not
    that handy, and it is better to close the PHP tag, print all HTML you need, and
    then open the tag again. You can do that even inside the code block of an `if`
    clause as you can see in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mixing PHP and HTML**'
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that the last file we edited looks rather ugly, you are right. Mixing
    PHP and HTML is confusing, and you should avoid it. In [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, we will see how to do things
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit our `authenticate.php` file too, as it is trying to access the
    `$_POST` entries that might not be there. The new content of the file would be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This code also contains conditionals, which we already know. We are setting
    a variable to know if we submitted a login or not, and set the cookies if so.
    But the highlighted lines show you a new way of including conditionals with HTML.
    This makes the code more readable when working with HTML code, avoiding the use
    of `{}`, and instead using `:` and `endif`. Both syntaxes are correct, and you
    should use the one that you consider more readable in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Switch…case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another control structure similar to `if…else` is `switch…case`. This structure
    evaluates only one expression, and executes the block depending on its value.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` clause takes an expression, in this case a variable, and then defines
    a series of cases. When the case matches the current value of the expression,
    PHP executes the code inside it. As soon as PHP finds a `break` statement, it
    exits the `switch…case`. In case none of the cases are suitable for the expression,
    PHP executes the default, if there is one, but that is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to know that breaks are mandatory if you want to exit the `switch…case`.
    If you do not specify any, PHP will keep on executing statements, even if it encounters
    a new case. Let''s see a similar example, but without the breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you test this code in your browser, you will see that it prints **Uh...A
    classic! Dunno that one**. PHP found that the second case is valid, so it executes
    its content. But as there are no breaks, it keeps on executing until the end.
    This might be the desired behavior sometimes but not usually, so be careful when
    using it!
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Loops** are control structures that allow you to execute certain statements
    several times, as many times as you need. You might use them in several different
    scenarios, but the most common one is when interacting with arrays. For example,
    imagine you have an array with elements, but you do not know what is in it. You
    want to print all its elements, so you loop through all of them.'
  prefs: []
  type: TYPE_NORMAL
- en: There are four types of loops. Each of them has its own use cases, but in general,
    you can transform one type of loop into another. Let's look at them closely.
  prefs: []
  type: TYPE_NORMAL
- en: While
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop is the simplest of the loops. It executes a block of code
    until the expression to evaluate returns `false`. Let''s see one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define a variable with value `1`. Then we have
    a `while` clause in which the expression to evaluate is `$i < 4`. This loop executes
    the content of the block of code until that expression is `false`. As you can
    see, inside the loop we are incrementing the value of `$i` by 1 each time, so
    the loop ends after 4 iterations. Check the output of that script and you will
    see "0 1 2 3". The last value printed is 3, so at that time the value of `$i`
    was 3\. After that, we increased its value to 4, so when the `while` clause evaluates
    if `$i < 4`, the result is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Whiles and infinite loops**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common problems with the `while` loops is creating an infinite
    loop. If you do not add any code inside the `while` loop that updates any of the
    variables considered in the `while` expression such that it can be `false` at
    some point, PHP will never exit the loop!
  prefs: []
  type: TYPE_NORMAL
- en: Do…while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `do…while` loop is very similar to `while` in the sense that it evaluates
    an expression each time, and will execute the block of code until that expression
    is `false`. The only difference is that when this expression is evaluated, the
    `while` clause evaluates the expression before executing the code, so sometimes,
    we might not even enter the loop if the expression evaluates to `false` the very
    first time. On the other hand, `do…while` evaluates the expression after it executes
    its block of code, so even if the expression is `false` from the very beginning,
    the loop will be executed at least once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code defines two loops with the same expression and block
    of code, but if you execute them, you will see that only the code inside the `do…while`
    is executed. In both cases, the expression is `false` since the beginning, so
    `while` does not even enter the loop, whereas the `do…while` enters the loop once.
  prefs: []
  type: TYPE_NORMAL
- en: For
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop is the most complex of the four loops. It defines an initialization
    expression, an exit condition, and the end of an iteration expression. When PHP
    first encounters the loop, it executes what is defined as the initialization expression.
    Then, it evaluates the exit condition and if it resolves to `true`, it enters
    the loop. After executing everything inside the loop, it executes the end of the
    iteration expression. Once done, it evaluates the end condition again, going through
    the loop code and the end of the iteration expression, until it evaluates to `false`.
    As always, an example will clarify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization expression is `$i = 1`, and is executed only the first time.
    The exit condition is `$i < 10`, and it is evaluated at the beginning of each
    iteration. The end of the iteration expression is `$i++`, which is executed at
    the end of each iteration. This example prints the numbers from 1 to 9\. Another
    more common usage of the `for` loop is with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have an array of names. Since it is defined as a list, its
    keys will be 0, 1, and 2\. The loop initializes the variable `$i` to 0, and it
    iterates until the value of `$i` is not less than the number of elements in the
    array, that is, 3\. In the first iteration, `$i` is 0, in the second, it is 1,
    and in the third one it is equal to 2\. When `$i` is 3, it will not enter the
    loop, as the exit condition evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration, we print the content of the position `$i` of the array, hence
    the result of this code will be all three names in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Be careful with exit conditions**'
  prefs: []
  type: TYPE_NORMAL
- en: It is very common to set an exit condition that is not exactly what we need,
    especially with arrays. Remember that arrays start with 0 if they are a list,
    so an array of three elements will have entries of 0, 1, and 2\. Defining the
    exit condition as `$i <= count($array)` will cause an error in your code, as when
    `$i` is 3, it also satisfies the exit condition and will try to access the key
    3, which does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Foreach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last, but not least, type of loop is `foreach`. This loop is exclusive
    for arrays, and it allows you to iterate an array entirely, even if you do not
    know its keys. There are two options for the syntax, as you can see in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `foreach` loop accepts an array—in this case `$names`—and it specifies a
    variable which will contain the value of the entry of the array. You can see that
    we do not need to specify any end condition, as PHP will know when the array has
    been iterated. Optionally, you can specify a variable that contains the key of
    each iteration, as in the second loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `foreach` loops are also useful with maps, where the keys are not necessarily
    numeric. The order in which PHP iterates the array will be the same order that
    you used to insert the contents in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use some loops in our application. We want to show the available books
    in our home page. We have the list of books in an array, so we will have to iterate
    all of them with a `foreach` loop, printing some information from each one. Append
    the following code to the `body` tag in `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows a `foreach` loop using the `:` notation as well,
    which is better when mixing it with HTML. It iterates all of the `$books` array,
    and for each book, it prints some information as an HTML list. Notice also that
    we have a conditional inside a loop, which is perfectly fine. Of course, this
    conditional will be executed for each entry in the array, so you should keep the
    block of code of your loops as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a reusable block of code that, given an input, performs some actions
    and, optionally, returns some result. You already know several predefined functions
    like `empty`, `in_array`, or `var_dump`. Those functions come with PHP so you
    do not have to reinvent the wheel, but you can create your own very easily. You
    can define functions when you identify portions of your application that have
    to be executed several times, or just to encapsulate some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Function declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring a function means writing it down so it can be used later. A function
    has a name, takes some arguments, and has a block of code. Optionally, it can
    define what kind of value is to be returned. The name of the function has to follow
    the same rules as variable names, that is, it has to start with a letter or an
    underscore, and can contain any letters, numbers, or underscore. It cannot be
    a reserved word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function''s name is `addNumbers`, and it takes two arguments:
    `$a` and `$b`. The block of code defines a new variable `$sum`, which is the sum
    of both arguments, and then returns its content with `return`. In order to use
    this function, you just need to call it by its name while sending all the required
    arguments, as shown in the highlighted line.'
  prefs: []
  type: TYPE_NORMAL
- en: PHP does not support **overloaded functions**. Overloading refers to the ability
    of declaring two or more functions with the same name but different arguments.
    As you can see, you can declare the arguments without knowing what their types
    are, so PHP would not be able to decide which function to use.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to note is the **variable scope**. We are declaring
    a variable `$sum` inside the block of code, so once the function ends, the variable
    will not be accessible any more. That means that the scope of variables declared
    inside the function is just the function itself. Furthermore, if you had a variable
    `$sum` declared outside the function, it would not be affected at all since the
    function cannot access that variable unless we send it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function gets information from outside via arguments. You can define any number
    of arguments—including 0 (none). These arguments need at least a name so they
    can be used inside the function; there cannot be two arguments with the same name.
    When invoking the function, you need to send the arguments in the same order as
    declared.
  prefs: []
  type: TYPE_NORMAL
- en: A function may contain **optional arguments**, that is, you are not forced to
    provide a value for those arguments. When declaring the function, you need to
    provide a default value for those arguments. So, in case the user does not provide
    a value, the function will use the default one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This new function in the last example takes two mandatory arguments and an optional
    one. The default value of the optional argument is `false`, and it is then used
    normally inside the function. The function will print the result of the sum if
    the user provides `true` as the third argument, which happens only the third time
    that the function is invoked. For the first two, `$printResult` is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments that the function receives are just copies of the values that
    the user provided. That means that if you modify these arguments inside the function,
    it will not affect the original values. This feature is known as sending arguments
    by value. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring a variable `$a` with value `2`, and then calling the `modify`
    method sending that `$a`. The `modify` method modifies the argument `$a`, setting
    its value to `3`, but this does not affect the original value of `$a`, which remains
    `2` as you can see from `var_dump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If what you want is to actually change the value of the original variable used
    in the invocation, you need to pass the argument by reference. To do that, you
    add an ampersand (`&`) before the argument when declaring the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, on invoking the function `modify`, `$a` will always be `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Arguments by value versus by reference**'
  prefs: []
  type: TYPE_NORMAL
- en: PHP allows you to do it, and in fact, some native functions of PHP use arguments
    by reference. Remember the array sorting functions? They did not return the sorted
    array, but sorted the array provided instead. But using arguments by reference
    is a way of confusing developers. Usually, when someone uses a function, they
    expect a result, and they do not want the arguments provided by them to be modified.
    So try to avoid it; people will be grateful!
  prefs: []
  type: TYPE_NORMAL
- en: The return statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have as many `return` statements as you want inside your function,
    but PHP will exit the function as soon as it finds one. That means that if you
    have two consecutive `return` statements, the second one will never be executed.
    Still, having multiple `return` statements can be useful if they are inside conditionals.
    Add this function inside your `functions.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s use the last example in your `index.php` file by replacing the highlighted
    content (note that to save some trees, I replaced most of the code that was not
    changed at all with `//…`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can omit the `return` statement if you do not want the function
    to return anything. In this case, the function will end once it reaches the end
    of the block of code.
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting and return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the release of PHP 7, the language allows the developer to be more specific
    about what functions are getting and returning. You can—always optionally—specify
    the type of argument that the function needs (**type hinting**), and the type
    of result the function will return (**return type**). Let''s first see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This preceding function states that the arguments need to be integer, integer,
    and Boolean, and that the result will be an integer. Now, you know that PHP has
    type juggling, so it can usually transform a value of one type to its equivalent
    value of another type, for example, the string "2" can be used as integer 2\.
    To stop PHP from using type juggling with the arguments and results of functions,
    you can declare the directive `strict_types` as shown in the first highlighted
    line. This directive has to be declared at the top of each file where you want
    to enforce this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three invocations work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first invocation sends two integers and a Boolean, which is what the function
    expects, so regardless of the value of `strict_types`, it will always work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second invocation sends an integer, a string, and a Boolean. The string
    has a valid integer value, so if PHP was allowed to use type juggling, the invocation
    would resolve just normally. But in this example, it will fail because of the
    declaration at the top of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third invocation will always fail as the string "something" cannot be transformed
    into a valid integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to use a function within our project. In our `index.php`, we have
    a `foreach` loop that iterates the books and prints them. The code inside the
    loop is kind of hard to understand as it is a mix of HTML with PHP, and there
    is a conditional too. Let''s try to abstract the logic inside the loop into a
    function. First, create the new `functions.php` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This file will contain our functions. The first one, `printableTitle`, takes
    an array representing a book, and builds a string with a nice representation of
    the book in HTML. The code is the same as before, just encapsulated in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `index.php` will have to include the `functions.php` file, and then use
    the function inside the loop. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Well, now our loop looks way cleaner, right? Also, if we need to print the title
    of the book somewhere else, we can reuse the function instead of duplicating code!
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have already noticed, PHP comes with a lot of native functions
    that help you to manage arrays and strings in an easier way as compared to other
    languages. The filesystem is another of those areas where PHP tried to make it
    as easy as possible. The list of functions extends to over 80 different ones,
    so we will cover here just the ones that you are more likely to use.
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our code, we define a list of books. So far, we have only three books, but
    you can guess that if we want to make this application useful, the list will grow
    way more. Storing the information inside your code is not practical at all, so
    we have to start thinking about externalizing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think in terms of separating the code from the data, there is no need
    to keep using PHP arrays to define the books. Using a less language-restrictive
    system will allow people who do not know PHP to edit the content of the file.
    There are many solutions for this, like CSV or XML files, but nowadays, one of
    the most used systems to represent data in web applications is JSON. PHP allows
    you to convert arrays to JSON and vice versa using just a couple of functions:
    `json_encode` and `json_decode`. Easy, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following into `books.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: With just one function, we are able to store all the content from the JSON file
    in a variable as a string. With the function, we transform this JSON string into
    an array. The second argument in `json_decode` tells PHP to transform it to an
    array, otherwise it would use objects, which we have not covered as yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'When referencing files within PHP functions, you need to know whether to use
    absolute or relative paths. When using relative paths, PHP will try to find the
    file inside the same directory where the PHP script is. If not found, PHP will
    try to find it in other directories defined in the `include_path` directive, but
    that is something you would like to avoid. Instead, you could use absolute paths,
    which is a way to make sure the reference will not be misunderstood. Let''s see
    two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The constant `__DIR__` contains the directory name of the current PHP file,
    and if we prefix it to the name of our file, we will have an absolute path. In
    fact, even though you might think that writing down the whole path by yourself
    is better, using `__DIR__` allows you to move your application anywhere else without
    needing to change anything in the code, as its content will always match the directory
    of the script, whereas the hardcoded path from the first example will not be valid
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's add some functionality to our application. Imagine that we want to allow
    the user to take the book that he or she is looking for, but only if it is available.
    If you remember, we identify the book by the query string. That is not very practical,
    so let's help the user by adding links to the list of books, so when you click
    on a link, the query string will contain that book's information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try the preceding code in your browser, you will see that the list contains
    links, and by clicking on them, the page refreshes with the new title as part
    of the query string. Let''s now check if the book is available or not, and if
    it is, let''s update its available field to `false`. Add the following function
    in your `functions.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We have to pay attention as the code starts getting complex. This function takes
    an array of books and a title, and returns a Boolean, being `true` if it could
    book it or `false` if not. Moreover, the array of books is passed by reference,
    which means that all changes to that array will affect the original array too.
    Even though we discouraged this previously, in this case, it is a reasonable approach.
  prefs: []
  type: TYPE_NORMAL
- en: We iterate the whole array of books, asking each time if the title of the current
    book matches the one we are looking for. Only if that is `true`, we will check
    if the book is available or not. If it is, we will update the availability to
    `false` and return `true`, meaning that we booked the book. If the book is not
    available, we will just return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that `foreach` defines `$key` and `$book`. We do so because the
    `$book` variable is a copy of the `$books` array, and if we edit it, the original
    one will not be affected. Instead, we ask for the key of that book too, so when
    editing the array, we use `$books[$key]` instead of `$book`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function from the `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it out in your browser. By clicking on an available book, you will get
    the **Booked!** message. We are almost done! We are just missing the last part:
    persist this information back to the filesystem. In order to do that, we have
    to construct the new JSON content and then to write it back to the `books.json`
    file. Of course, let''s do that only if the book was available.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json_encode` function does the opposite of `json_decode`: it takes an
    array—or any other variable—and transforms it to JSON. The `file_put_contents`
    function is used to write to the file referenced as the first argument, the content
    sent as the second argument. Would you know how to use this function?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Files versus databases**'
  prefs: []
  type: TYPE_NORMAL
- en: Storing information in JSON files is better than having it in your code, but
    it is still not the best option. In [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, you will learn how to store
    data of the application in a database, which is a way better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Other filesystem functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to make your application more robust, you could check that the
    `books.json` file exists, that you have read and write permission, and/or that
    the previous content was a valid JSON. You can use some PHP functions for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_exists`: This function takes the path of the file, and returns a Boolean:
    `true` when the file exists and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_writable`: This function works the same as `file_exists`, but checks whether
    the file is writable or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full list of functions at [http://uk1.php.net/manual/en/book.filesystem.php](http://uk1.php.net/manual/en/book.filesystem.php).
    You can find functions to move, copy, or remove files, create directories, give
    permissions and ownership, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through all the basics of procedural PHP while writing
    simple examples in order to practice them. You now know how to use variables and
    arrays with control structures and functions, how to get information from HTTP
    requests, and how to interact with the filesystem among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will study the other and most used paradigm: OOP. That
    is one step closer to writing clean and well-structured applications.'
  prefs: []
  type: TYPE_NORMAL
