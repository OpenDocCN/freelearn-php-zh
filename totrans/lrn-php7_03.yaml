- en: Chapter 3. Understanding PHP Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 理解PHP基础知识
- en: Learning a new language is not easy. You need to understand not only the syntax
    of the language, but also its grammatical rules, that is, when and why to use
    each element of the language. Luckily for you, some languages come from the same
    root. For example, Spanish and French are Romance languages, as they both evolved
    from spoken Latin; that means that these two languages share a lot of rules, and
    if you already know French, learning Spanish becomes much easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新语言并不容易。你需要理解语言的语法，以及其语法规则，即何时以及为什么使用语言中的每个元素。幸运的是，一些语言来自同一个根源。例如，西班牙语和法语是罗曼语族，因为它们都源自拉丁语口语；这意味着这两种语言有很多规则是共享的，如果你已经知道法语，学习西班牙语就会容易得多。
- en: Programming languages are quite the same. If you already know another programming
    language, it will be very easy for you to go through this chapter. If this is
    your first time though, you will need to understand all those grammatical rules
    from scratch, and so, it might take some more time. But fear not! We are here
    to help you in this endeavor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言相当相似。如果你已经知道另一种编程语言，那么通过这一章会非常容易。但如果这是你第一次，那么你需要从头开始理解所有那些语法规则，所以可能需要更多的时间。但别担心！我们在这里帮助你完成这项任务。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: PHP files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP文件
- en: Variables, strings, arrays, and operators in PHP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP中的变量、字符串、数组运算符
- en: PHP in web applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 在网络应用中
- en: Control structures in PHP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP中的控制结构
- en: Functions in PHP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP中的函数
- en: The PHP filesystem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP文件系统
- en: PHP files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP文件
- en: From now on, we will work on your `index.php` file, so you can just start the
    web server, and go to `http://localhost:8080` to see the results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将专注于你的 `index.php` 文件，所以你可以直接启动Web服务器，然后访问 `http://localhost:8080` 来查看结果。
- en: You might have already noticed that in order to write PHP code, you have to
    start the file with `<?php`. There are other options, and you can also finish
    the file with `?>`, but none of them are needed. What is important to know is
    that you can mix PHP code with other content, like HTML, CSS, or JavaScript, in
    your PHP file as soon as you enclose the PHP bits with the `<?php ?>` tags.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了编写PHP代码，你必须以 `<?php` 开始文件。还有其他选项，你还可以用 `?>` 结束文件，但这些都是不必要的。重要的是要知道，一旦你用
    `<?php ?>` 标签包围了PHP代码块，你就可以在你的PHP文件中混合PHP代码和其他内容，如HTML、CSS或JavaScript。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will learn in [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, why it is usually a bad idea
    to mix PHP and HTML. For now, assuming that it is bad, let''s try to avoid it.
    For that, you can include one file from another PHP file using any one of these
    four functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第6章](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851 "第6章.
    适应MVC")中学习，*适应MVC*，为什么通常将PHP和HTML混合使用不是一个好主意。现在，假设这是不好的，让我们尽量避免。为此，你可以使用以下四个函数之一从另一个PHP文件中包含一个文件：
- en: '`include`: This will try to find and include the specified file each time it
    is invoked. If the file is not found, PHP will throw a warning, but will continue
    with the execution.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`: 每次调用时都会尝试查找并包含指定的文件。如果找不到文件，PHP将抛出警告，但会继续执行。'
- en: '`require`: This will do the same as `include`, but PHP will throw an error
    instead of a warning if the file is not found.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`: 这将执行与 `include` 相同的操作，但如果找不到文件，PHP 将抛出错误而不是警告。'
- en: '`include_once`: This function will do what `include` does, but it will include
    the file only the first time that it is invoked. Subsequent calls will be ignored.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_once`: 这个函数将执行 `include` 的功能，但只有在第一次调用时才会包含文件。后续的调用将被忽略。'
- en: '`require_once`: This works the same as `require`, but it will include the file
    only the first time that it is invoked. Subsequent calls will be ignored.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require_once`: 这与 `require` 的功能相同，但只有在第一次调用时才会包含文件。后续的调用将被忽略。'
- en: 'Each function has its own usage, so it is not right to say that one is better
    than the other. Just think carefully what your scenario is, and then decide. For
    example, let''s try to include our `index.html` file from our `index.php` file
    such that we do not mix PHP with HTML, but have the best of both worlds:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有自己的用途，所以说一个比另一个好是不正确的。只需仔细思考你的场景，然后做出决定。例如，让我们尝试从我们的 `index.php` 文件中包含我们的
    `index.html` 文件，这样我们就不混合PHP和HTML，而是两者兼得：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We chose `require` as we know the file is there—and if it is not, we are not
    interested in continuing the execution. Moreover, as it is some HTML code, we
    might want to include it multiple times, so we did not choose the `require_once`
    option. You can try to require a file that does not exist, and see what the browser
    says.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用`require`，因为我们知道文件在那里——如果它不存在，我们就不想继续执行。此外，由于它是某些HTML代码，我们可能希望多次包含它，所以我们没有选择`require_once`选项。你可以尝试引入一个不存在的文件，看看浏览器会说什么。
- en: 'PHP does not consider empty lines; you can add as many as you want to make
    your code easier to read, and it will not have any repercussion on your application.
    Another element that helps in writing understandable code, and which is ignored
    by PHP, is comments. Let''s see both in action:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PHP不会考虑空行；你可以添加尽可能多的空行来使你的代码更容易阅读，而且它不会对你的应用程序产生任何影响。另一个有助于编写可读代码的元素，但PHP会忽略它，是注释。让我们看看它们在实际中的应用：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code does the same job as the previous one, but now everyone will easily
    understand what we are trying to do. We can see two types of comments: single-line
    comments and multiple-line comments. The first type consists of a single line
    starting with `//`, and the second type encloses multiple lines within `/*` and
    `*/`. We start each commented line with an asterisk, but that is completely optional.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一个代码做的是同样的工作，但现在每个人都会很容易理解我们试图做什么。我们可以看到两种类型的注释：单行注释和多行注释。第一种类型由以`//`开头的一行组成，第二种类型在`/*`和`*/`之间包含多行。我们以星号开始每个注释行，但这完全是可选的。
- en: Variables
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables keep a value for future reference. This value can change if we want
    it to; that is why they are called variables. Let''s take a look at them in an
    example. Save this code in your `index.php` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 变量保存一个值以供将来引用。如果我们想改变它，这个值可以改变；这就是为什么它们被称为变量。让我们通过一个例子来看看它们。将此代码保存到你的`index.php`文件中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this preceding piece of code, we have three variables: `$a` has value `1`,
    `$b` has `2`, and `$c` contains the sum of `$a` and `$b`, hence, `$c` equals 3\.
    Your browser should print the value of the variable `$c`, which is 3.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有三个变量：`$a`的值为`1`，`$b`的值为`2`，`$c`包含`$a`和`$b`的和，因此`$c`等于3。你的浏览器应该打印变量`$c`的值，即3。
- en: Assigning a value to a variable means to give it a value, and it is done with
    the equals sign as shown in the previous example. If you did not assign a value
    to a variable, we will get a notice from PHP when it checks its contents. A notice
    is just a message telling us that something is not exactly right, but it is a
    minor problem and you can continue with the execution. The value of an unassigned
    variable will be null, that is, nothing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给变量意味着给它一个值，这就像上一个例子中所示的那样，使用等号。如果你没有给变量赋值，当PHP检查其内容时，我们会收到一个PHP的通知。通知只是一个消息，告诉我们某些事情并不完全正确，但这只是一个小问题，你可以继续执行。未分配变量的值将是null，即没有内容。
- en: 'PHP variables start with the `$` sign followed by the variable name. A valid
    variable name starts with a letter or an underscore followed by any combination
    of letters, numbers, and/or underscores. It is case sensitive. Let''s see some
    examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PHP变量以`$`符号开头，后跟变量名。一个有效的变量名以字母或下划线开头，后跟任何组合的字母、数字和/或下划线。它是区分大小写的。让我们看看一些例子：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember that everything after `//` is a comment, and is thus ignored by PHP.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`//`之后的所有内容都是注释，因此会被PHP忽略。
- en: In this piece of code, we can see that variable names like `$_some_value` and
    `$go_2_home` are valid. `$1number` and `$some$signs%` are not valid as they start
    with a number, or they contain invalid symbols. As names are case sensitive, `$go_2_home`
    and `$go_2_Home` are two different variables. Finally, we show the CamelCase convention,
    which is the preferred option among most developers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以看到像`$_some_value`和`$go_2_home`这样的变量名是有效的。`$1number`和`$some$signs%`不是有效的，因为它们以数字开头，或者它们包含无效的符号。由于名称是区分大小写的，`$go_2_home`和`$go_2_Home`是两个不同的变量。最后，我们展示了驼峰命名法，这是大多数开发者首选的选项。
- en: Data types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'We can assign more than just numbers to variables. PHP has eight primitive
    types, but for now, we will focus on its four scalar types:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不仅仅是数字赋值给变量。PHP有八个原始类型，但到目前为止，我们将关注它的四种标量类型：
- en: '**Booleans**: These take just true or false values'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：它们只取true或false值'
- en: '**Integers**: These are numeric values without a decimal point, for example,
    2 or 5'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：这些是没有小数点的数值，例如，2或5'
- en: '**Floating point numbers or floats**: These are numbers with a decimal point,
    for example, 2.3'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数或浮点数**：这些是带有小数点的数字，例如，2.3'
- en: '**Strings**: These are concatenations of characters which are surrounded by
    either single or double quotes, like ''this'' or "that"'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这些是由单引号或双引号包围的字符的连接，例如 ''this'' 或 "that"'
- en: 'Even though PHP defines these types, it allows the user to assign different
    types of data to the same variable. Check the following code to see how it works:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP定义了这些类型，但它允许用户将不同类型的数据分配给同一个变量。查看以下代码以了解它是如何工作的：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you check the result on your browser, you will see the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器上查看结果，你会看到以下内容：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code first assigns the value `123` to the variable `$number`. As `123` is
    an integer, the type of the variable will be integer `int`. That is what we see
    when printing the content of the variable with `var_dump`. After that, we assign
    another value to the same variable, this time a string. When printing the new
    content, we see that the type of the variable changed from integer to string,
    yet PHP did not complain at any time. This is called **type juggling**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先将值`123`分配给变量`$number`。由于`123`是整数，变量的类型将是整数`int`。这就是我们在使用`var_dump`打印变量内容时看到的内容。之后，我们将另一个值分配给同一个变量，这次是一个字符串。在打印新内容时，我们看到变量的类型从整数变为字符串，但PHP在任何时候都没有抱怨。这被称为**类型转换**。
- en: 'Let''s check another piece of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查另一段代码：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You already know that the `+` operator returns the sum of two numeric values.
    You will see later that the `.` operator concatenates two strings. Thus, the preceding
    code assigns a string and an integer to two variables, and then tries to add and
    concatenate them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道`+`运算符返回两个数值的和。您稍后将会看到`.`运算符连接两个字符串。因此，前面的代码将一个字符串和一个整数分配给两个变量，然后尝试将它们相加和连接。
- en: When trying to add them, PHP knows that it needs two numeric values, and so
    it tries to adapt the string to an integer. In this case, it is easy as the string
    represents a valid number. That is the reason why we see the first result as an
    integer 3 (*1 + 2*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将它们相加时，PHP知道它需要两个数值，因此它会尝试将字符串转换为整数。在这种情况下，由于字符串代表一个有效的数字，所以很容易。这就是为什么我们看到第一个结果是一个整数3（*1
    + 2*）。
- en: In the last line, we are performing a string concatenation. We have an integer
    in `$b`, so PHP will first try to convert it to a string—which is "2"—and then
    concatenate it with the other string, "1". The result is the string "12".
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们正在进行字符串连接。在 `$b` 中有一个整数，所以PHP会首先尝试将其转换为字符串——即 "2"，然后将其与另一个字符串 "1" 连接。结果是字符串
    "12"。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Type juggling**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换**'
- en: PHP tries to convert the data type of a variable only when there is a context
    where the type of variable needed is different. But PHP does not change the value
    and type of the variable itself. Instead, it will take the value and try to transform
    it, leaving the variable intact.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PHP仅在存在需要不同变量类型的上下文时才会尝试转换变量的数据类型。但PHP不会改变变量本身的价值和类型。相反，它会取值并尝试转换，同时保持变量不变。
- en: Operators
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: Using variables is nice, but if we cannot make them interact with each other,
    there is nothing much we can do. **Operators** are elements that take some expressions—operands—and
    perform actions on them to get a result. The most common examples of operators
    are arithmetic operators, which you already saw previously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量很方便，但如果我们不能使它们相互交互，我们就无法做太多。**运算符**是接受一些表达式（操作数）并对其执行操作以获得结果的元素。最常见的运算符例子是算术运算符，您之前已经看到了。
- en: An **expression** is almost anything that has a value. Variables, numbers, or
    text are examples of expressions, but you will see that they can get way more
    complicated. Operators expect expressions of a specific type, for example, arithmetic
    operators expect either integers or floats. But as you already know, PHP takes
    care of transforming the types of the expressions given whenever possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**几乎可以是任何具有值的元素。变量、数字或文本是表达式的例子，但你会看到它们可以变得非常复杂。运算符期望特定类型的表达式，例如，算术运算符期望整数或浮点数。但如您所知，PHP会在可能的情况下处理给定表达式的类型转换。'
- en: Let's take a look at the most important groups of operators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最重要的运算符组。
- en: Arithmetic operators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators are very intuitive, as you already know. Addition, subtraction,
    multiplication, and division (`+`, `-`, `*`, and `/`) do as their names say. Modulus
    (`%`) gives the remainder of the division of two operands. Exponentiation (`**`)
    raises the first operand to the power of the second. Finally, negation (`-`) negates
    the operand. This last one is the only arithmetic operator that takes just one
    operand.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符非常直观，正如你所知。加法（`+`）、减法（`-`）、乘法（`*`）和除法（`/`）都按照它们的名称执行。取模运算符（`%`）给出两个操作数除法的余数。指数运算符（`**`）将第一个操作数提升为第二个操作数的幂。最后，取反运算符（`-`）对操作数取反。这是唯一只需要一个操作数的算术运算符。
- en: 'Let''s see some examples:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, they are quite easy to understand!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它们很容易理解！
- en: Assignment operators
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'You already know this one too, as we have been using it in our examples. The
    assignment operator assigns the result of an expression to a variable. Now you
    know that an expression can be as simple as a number, or, for example, the result
    of a series of arithmetic operations. The following example assigns the result
    of an expression to a variable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也熟悉这个，因为我们已经在我们的例子中使用过它了。赋值运算符将表达式的结果赋给一个变量。现在你知道一个表达式可以像数字一样简单，或者，例如，一系列算术运算的结果。以下示例将表达式的结果赋给一个变量：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a series of assignment operators that work as shortcuts. You can
    build them combining an arithmetic operator and the assignment operator. Let''s
    see some examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一系列的赋值运算符，它们作为快捷方式工作。你可以通过组合一个算术运算符和一个赋值运算符来构建它们。让我们看看一些例子：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Comparison operators
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Comparison operators are one of the most used groups of operators. They take
    two operands and compare them, returning the result of the comparison usually
    as a Boolean, that is, `true` or `false`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符是使用最频繁的运算符组之一。它们接受两个操作数并比较它们，通常将比较的结果作为布尔值返回，即`true`或`false`。
- en: 'There are four comparisons that are very intuitive: `<` (less than), `<=` (less
    or equal to), `>` (greater than), and `>=` (greater than or equal to). There is
    also the special operator `<=>` (spaceship) that compares both the operands and
    returns an integer instead of a Boolean. When comparing *a* with *b*, the result
    will be less than 0 if *a* is less than *b*, 0 if *a* equals *b*, and greater
    than 0 if *a* is greater than *b*. Let''s see some examples:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种非常直观的比较运算符：`<`（小于）、`<=`（小于等于）、`>`（大于）和`>=`（大于等于）。还有一个特殊的运算符`<=>`（飞船），它比较两个操作数并返回一个整数而不是布尔值。当比较*a*和*b*时，如果*a*小于*b*，结果将小于0；如果*a*等于*b*，结果为0；如果*a*大于*b*，结果大于0。让我们看看一些例子：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are comparison operators to evaluate if two expressions are equal or
    not, but you need to be careful with type juggling. The `==` (equals) operator
    evaluates two expressions *after* type juggling, that is, it will try to transform
    both expressions to the same type, and then compare them. Instead, the `===` (identical)
    operator evaluates two expressions *without* type juggling, so even if they look
    the same, if they are not of the same type, the comparison will return `false`.
    The same applies to `!=` or `<>` (not equal to) and `!==` (not identical):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存在比较运算符来评估两个表达式是否相等，但你需要小心类型转换。`==`（等于）运算符在类型转换后评估两个表达式，也就是说，它会尝试将两个表达式转换为相同的类型，然后再进行比较。相反，`===`（严格等于）运算符在无类型转换的情况下评估两个表达式，所以即使它们看起来相同，如果它们的类型不同，比较结果将返回`false`。同样的规则适用于`!=`或`<>`（不等于）和`!==`（严格不等于）：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see that when asking if a string and an integer that represent the same
    number are equal, it replies affirmatively; PHP first transforms both to the same
    type. On the other hand, when asked if they are identical, it replies they are
    not as they are of different types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当询问一个字符串和一个表示相同数字的整数是否相等时，它回答肯定；PHP首先将它们都转换为相同的类型。另一方面，当询问它们是否相同类型时，它回答它们不是，因为它们的类型不同。
- en: Logical operators
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators apply a logic operation—also known as a binary operation—to
    its operands, returning a Boolean response. The most used ones are `!` (not),
    `&&` (and), and `||` (or). `&&` will return `true` only if both operands evaluate
    to `true`. `||` will return `true` if any or both of the operands are `true`.
    `!` will return the negated value of the operand, that is, `true` if the operand
    is `false` or `false` if the operand is `true`. Let''s see some examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑操作符对其操作数应用逻辑运算（也称为二元运算），返回布尔响应。最常用的有`!`（非），`&&`（与）和`||`（或）。`&&`只有在两个操作数都评估为`true`时才会返回`true`。`||`如果任何或两个操作数都是`true`，则返回`true`。`!`将返回操作数的否定值，即如果操作数是`false`则返回`true`，如果操作数是`true`则返回`false`。让我们看一些例子：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Incrementing and decrementing operators
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量和减量操作符
- en: 'Incrementing/decrementing operators are also shortcuts like `+=` or `-=`, and
    they only work on variables. There are four of them, and they need special attention.
    We''ve already seen the first two:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量操作符也是像`+=`或`-=`这样的快捷方式，并且它们只作用于变量。这里有四个，需要特别注意。我们已经看到了前两个：
- en: '`++`: This operator on the left of the variable will increase the variable
    by 1, and then return the result. On the right, it will return the content of
    the variable, and after that increase it by 1.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++`：这个操作符在变量的左侧会将变量增加1，然后返回结果。在右侧，它会返回变量的内容，然后增加1。'
- en: '`--`: This operator works the same as `++` but decreases the value by 1 instead
    of increasing by 1.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`：这个操作符的作用与`++`相同，但它是减少值而不是增加值。'
- en: 'Let''s see an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, on the first assignment to `$b`, we use `$a++`. The operator
    on the right will return first the value of `$a`, which is `3`, assign it to `$b`,
    and only then increase `$a` by 1\. In the second assignment, the operator on the
    left first increases `$a` by 1, changes the value of `$a` to `5`, and then assigns
    that value to `$b`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在第一次赋值给`$b`时，我们使用了`$a++`。右侧的操作符首先会返回`$a`的值，即`3`，然后将它赋值给`$b`，然后才将`$a`增加1。在第二次赋值中，左侧的操作符首先将`$a`增加1，将`$a`的值变为`5`，然后将这个值赋给`$b`。
- en: Operator precedence
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符优先级
- en: 'You can add multiple operators to an expression to make it as long as it needs
    to be, but you need to be careful as some operators have higher precedence than
    others, and thus, the order of execution might not be the one you expect. The
    following table shows the order of precedence of the operators that we''ve studied
    until now:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个表达式中添加多个操作符，使其长度满足需要，但你需要小心，因为一些操作符的优先级高于其他操作符，因此执行顺序可能不是你所期望的。以下表格显示了我们至今为止所学的操作符的优先级顺序：
- en: '| Operator | Type |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 类型 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**` | Arithmetic |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 算术 |'
- en: '| `++`, `--` | Increasing/decreasing |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `++`, `--` | 增量/减少 |'
- en: '| `!` | Logical |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑 |'
- en: '| `*`, `/`, `%` | Arithmetic |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `*`, `/`, `%` | 算术 |'
- en: '| `+`, `-` | Arithmetic |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `+`, `-` | 算术 |'
- en: '| `<`, `<=`, `>`, `>=` | Comparison |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `<=`, `>`, `>=` | 比较 |'
- en: '| `==`, `!=`, `===`, `!==` | Comparison |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `==`, `!=`, `===`, `!==` | 比较 |'
- en: '| `&&` | Logical |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑 |'
- en: '| `&#124;&#124;` | Logical |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 逻辑 |'
- en: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=` | Assignment |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=` | 赋值 |'
- en: The preceding table shows us that the expression *3+2*3* will first evaluate
    the product *2*3* and then the sum, so the result is 9 rather than 15\. If you
    want to perform operations in a specific order, different from the natural order
    of precedence, you can force it by enclosing the operation within parentheses.
    Hence, *(3+2)*3* will first perform the sum and then the product, giving the result
    15 this time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格显示，表达式`3+2*3`将首先计算乘积`2*3`，然后是求和，所以结果是9而不是15。如果你想以不同于自然优先级顺序的特定顺序执行操作，可以通过将操作放在括号内来强制执行。因此，`(3+2)*3`将首先执行求和，然后是乘法，这次结果是15。
- en: 'Let''s see some examples to clarify this quite tricky subject:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些例子来澄清这个相当棘手的问题：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This preceding example could be endless, and still not be able to cover all
    the scenarios you can imagine, so let''s keep it simple. In the first highlighted
    line, we have a combination of arithmetic, comparison, and logical operators,
    plus the assignment operator. As there are no parentheses, the order is the one
    detailed in the previous table. The operator with the highest preference is the
    sum, so we perform it first: `$a` + `$b` equals 4\. The next one is the comparison
    operator, so *4 > 5*, which is `false`. Finally, the logical operator, `false`
    || `$c` (`$c` is `true`) results in `true`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的例子可能是无穷无尽的，而且仍然不能涵盖你所能想象的所有场景，所以让我们保持简单。在第一行高亮的代码中，我们有算术、比较和逻辑操作符的组合，以及赋值操作符。因为没有括号，所以顺序是前面表格中详细说明的。优先级最高的操作符是加法，所以我们首先执行它：`$a`
    + `$b` 等于 4。下一个是比较操作符，所以 *4 > 5*，结果是 `false`。最后，逻辑操作符，`false` || `$c` (`$c` 是
    `true`) 结果为 `true`。
- en: The second example might need a bit more explanation. The first operator we
    see in the table is the negation, so we resolve it. `!$d` is `!false`, so it is
    `true`. The expression is now, `$e` == `true` && `true`. First we need to solve
    the comparison `$e` == `true.` Knowing that `$e` is `true`, the comparison results
    in `true`. The final operation then is the logical end, and it results in `true`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子可能需要更多的解释。表中我们看到的第一种操作符是取反，所以我们解决它。`!$d` 是 `!false`，所以它是 `true`。现在表达式是
    `$e` == `true` && `true`。首先我们需要解决比较 `$e` == `true`。知道 `$e` 是 `true`，比较结果为 `true`。最后的操作是逻辑结束，结果为
    `true`。
- en: Try to work out the last example by yourself to get some practice. Do not be
    afraid if you think we are not covering operators enough. During the next few
    sections, we will see a lot of examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己解决最后一个例子以获得一些练习。如果你认为我们没有充分覆盖操作符，不要害怕。在接下来的几节中，我们将看到很多例子。
- en: Working with strings
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Working with strings in real life is really easy. Actions like *Check if this
    string contains this* or *Tell me how many times this character appears* are very
    easy to perform. But when programming, strings are concatenations of characters
    that you cannot see at once when searching for something. Instead, you have to
    look one by one and keep track of what the content is. In this scenario, those
    really easy actions are not that easy any more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中处理字符串真的很简单。像 *检查这个字符串是否包含这个* 或 *告诉我这个字符出现多少次* 这样的动作很容易执行。但在编程时，字符串是字符的连接，你在搜索时不能一次看到所有的内容。相反，你必须一个一个地查看并跟踪内容。在这种情况下，那些很容易的动作不再那么容易了。
- en: 'Luckily for you, PHP brings a whole set of predefined functions that help you
    in interacting with strings. You can find the entire list of functions at [http://php.net/manual/en/ref.strings.php](http://php.net/manual/en/ref.strings.php),
    but we will only cover the ones that are used the most. Let''s look at some examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PHP 带有一整套预定义的函数，可以帮助你与字符串交互。你可以在 [http://php.net/manual/en/ref.strings.php](http://php.net/manual/en/ref.strings.php)
    找到函数的完整列表，但我们只会介绍最常用的那些。让我们看看一些例子：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding long piece of code, we are playing with a string with different
    functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面长段代码中，我们正在使用不同的函数玩字符串：
- en: '`strlen`: This function returns the number of characters that the string contains.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strlen`: 这个函数返回字符串包含的字符数。'
- en: '`trim`: This function returns the string, removing all the blank spaces to
    the left and to the right.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim`: 这个函数返回字符串，移除所有左边的空白和右边的空白。'
- en: '`strtoupper` and `strtolower`: These functions return the string with all the
    characters in upper or lower case respectively.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strtoupper` 和 `strtolower`: 这些函数分别返回所有字符都为大写或小写的字符串。'
- en: '`str_replace`: This function replaces all occurrences of a given string by
    the replacement string.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str_replace`: 这个函数将给定的字符串的所有出现替换为替换字符串。'
- en: '`substr`: This function extracts the string contained between the positions
    specified by parameters, with the first character being at position 0.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr`: 这个函数提取由参数指定的位置之间的字符串，第一个字符位于位置 0。'
- en: '`strpos`: This function shows the position of the first occurrence of the given
    string. It returns `false` if the string cannot be found.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strpos`: 这个函数显示给定字符串第一次出现的位置。如果字符串找不到，则返回 `false`。'
- en: 'Additionally, there is an operator for strings (`.`) which concatenates two
    strings (or two variables transformed to a string when possible). Using it is
    really simple: in the following example, the last statement will concatenate all
    the strings and variables forming the sentence, *I am Hiro Nakamura!*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于字符串的运算符（`.`），它可以连接两个字符串（或者当可能时将两个变量转换为字符串）。使用它非常简单：在下面的例子中，最后的语句将连接所有字符串和变量，形成句子*I
    am Hiro Nakamura!*。
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another thing to note about strings is the way they are represented. So far,
    we have been enclosing the strings within single quotes, but you can also enclose
    them within double quotes. The difference is that within single quotes, a string
    is exactly as it is represented, but within double quotes, some rules are applied
    before showing the final result. There are two elements that double quotes treat
    differently than single quotes: escape characters and variable expansions.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串，还有一点需要注意，那就是它们的表示方式。到目前为止，我们一直用单引号括起来字符串，但你也可以用双引号括起来。区别在于，在单引号内，字符串的表示方式就是它本身，但在双引号内，在显示最终结果之前会应用一些规则。双引号与单引号处理不同的两个元素是：转义字符和变量扩展。
- en: '**Escape characters**: These are special characters than cannot be represented
    easily. Examples of escape characters are new lines or tabs. To represent them,
    we use escape sequences, which are the concatenation of a backslash (`\`) followed
    by some other character. For example, `\n` represents a new line, and `\t` represents
    a tabulation.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转义字符**：这些是无法轻易表示的特殊字符。转义字符的例子包括换行符或制表符。为了表示它们，我们使用转义序列，它是反斜杠（`\`）后跟其他字符的连接。例如，`\n`代表换行符，`\t`代表制表符。'
- en: '**Variable expanding**: This allows you to include variable references inside
    the string, and PHP replaces them by their current value. You have to include
    the `$` sign too.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量扩展**：这允许你在字符串中包含变量引用，PHP会用它们的当前值来替换它们。你还需要包括`$`符号。'
- en: 'Have a look at the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding piece of code will print the following in the browser:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在浏览器中打印以下内容：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `\n` inserted a new line. `\"` added the double quotes (you need to escape
    them too, as PHP would understand that you want to end your string), and the variables
    `$firstname` and `$surname` were replaced by their values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`\n`插入了一个新行。`\"`添加了双引号（你也需要转义它们，因为PHP会理解你想要结束字符串），变量`$firstname`和`$surname`被它们的值所替换。
- en: Arrays
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'If you have some experience with other programming languages or data structures
    in general, you might be aware of two data structures that are very common and
    useful: **lists** and **maps**. A list is an ordered set of elements, whereas
    a map is a set of elements identified by keys. Let''s see an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些其他编程语言或数据结构的一般经验，你可能已经知道两种非常常见且有用的数据结构：**列表**和**映射**。列表是有序元素集合，而映射是带有键的元素集合。让我们看看一个例子：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first element is a list of names that contains three values: `Harry`, `Ron`,
    and `Hermione`. The second one is a map, and it defines two values: `James Potter`
    and `dead`. Each of these two values is identified with a key: `name` and `status`
    respectively.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素是一个包含三个值的名字列表：`Harry`、`Ron`和`Hermione`。第二个是一个映射，它定义了两个值：`James Potter`和`dead`。这两个值中的每一个都通过一个键来标识：`name`和`status`。
- en: In PHP, we do not have lists and maps; we have arrays. An array is a data structure
    that implements both, a list and a map.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，我们没有列表和映射；我们有数组。数组是一种数据结构，它实现了列表和映射。
- en: Initializing arrays
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数组
- en: 'You have different options for initializing an array. You can initialize an
    empty array, or you can initialize an array with data. There are different ways
    of writing the same data with arrays too. Let''s see some examples:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组有多种选择。你可以初始化一个空数组，或者初始化一个包含数据的数组。数组中用相同的方式写相同的数据也有不同的方法。让我们看看一些例子：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we define the list and map from the previous section.
    `$names1` and `$names2` are exactly the same array, just using a different notation.
    The same happens with `$status1` and `$status2`. Finally, `$empty1` and `$empty2`
    are two ways of creating an empty array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了上一节中的列表和映射。`$names1`和`$names2`是完全相同的数组，只是使用了不同的表示法。同样，`$status1`和`$status2`也是这样。最后，`$empty1`和`$empty2`是创建空数组的两种方式。
- en: 'Later you will see that lists are handled like maps. Internally, the array
    `$names1` is a map, and its keys are ordered numbers. In this case, another initialization
    for `$names1` that leads to the same array could be as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以后你会看到列表被像映射一样处理。内部，数组`$names1`是一个映射，其键是有序的数字。在这种情况下，对`$names1`的另一种初始化，可以导致相同的数组，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Keys of an array can be any alphanumeric value, like strings or numbers. Values
    of an array can be anything: strings, numbers, Booleans, other arrays, and so
    on. You could have something like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的键可以是任何字母数字值，如字符串或数字。数组的值可以是任何东西：字符串、数字、布尔值、其他数组等等。你可能会有以下这样的东西：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This array is a list that contains two arrays—maps. Each map contains different
    values like strings, doubles, and Booleans.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组是一个包含两个数组——映射的列表。每个映射包含不同的值，如字符串、双精度浮点数和布尔值。
- en: Populating arrays
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充数组
- en: 'Arrays are not immutable, that is, they can change after being initialized.
    You can change the content of an array either by treating it as a map or as a
    list. Treating it as a map means that you specify the key that you want to override,
    whereas treating it as a list means appending another element to the end of the
    array:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不是不可变的，也就是说，初始化后它们可以改变。你可以通过将其视为映射或列表来更改数组的内容。将其视为映射意味着你指定要覆盖的键，而将其视为列表意味着将另一个元素追加到数组的末尾：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the first highlighted line appends the name `Neville`
    to the list of names, hence the list will look like *['Harry', 'Ron', 'Hermione',
    'Neville']*. The second change actually adds a new key-value to the array. You
    can check the result from your browser by using the function `print_r`. It does
    something similar to `var_dump`, just without the type and size of each value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，第一行高亮显示的行将名称`Neville`追加到名称列表中，因此列表将看起来像*['Harry', 'Ron', 'Hermione',
    'Neville']*。第二个更改实际上向数组添加了一个新的键值对。你可以通过使用函数`print_r`来检查结果。它做的是类似`var_dump`的事情，只是没有每个值的类型和大小。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**print_r and var_dump in a browser**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器中的print_r和var_dump**'
- en: When printing the content of an array, it is useful to see one key-value per
    line, but if you check your browser, you will see that it displays the whole array
    in one line. That happens because what the browser tries to display is HTML, and
    it ignores new lines or whitespaces. To check the content of the array as PHP
    wants you to see it, check the source code of the page—you will see the option
    by right-clicking on the page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印数组的内容时，看到每个键值一行很有用，但如果你检查浏览器，你会看到它在一行中显示整个数组。这是因为浏览器试图显示的是HTML，它忽略了换行符或空白。为了检查数组的内容，就像PHP希望你看的那样，请检查页面的源代码——你可以在页面上右键单击来看到选项。
- en: 'If you need to remove an element from the array, instead of adding or updating
    one, you can use the `unset` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从数组中删除一个元素，而不是添加或更新一个，你可以使用`unset`函数：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new `$status` array contains the key name only.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`$status`数组只包含键名。
- en: Accessing arrays
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组
- en: Accessing an array is as easy as specifying the key as when you were updating
    it. For that, you need to understand how lists work. You already know that lists
    are treated internally as a map with numeric keys in order. The first key is always
    0; so, an array with *n* elements will have keys from 0 to *n-1*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组就像指定键时更新它一样简单。为此，你需要了解列表是如何工作的。你已经知道列表在内部被视为一个具有顺序数字键的映射。第一个键总是0；因此，具有*n*个元素的数组将具有从0到*n-1*的键。
- en: You can add any key to a given array, even if it previously consisted of numeric
    entries. The problem arises when adding numeric keys, and later, you try to append
    an element to the array. What do you think will happen?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向给定的数组添加任何键，即使它之前只包含数字条目。问题出现在添加数字键时，后来你尝试向数组追加一个元素。你认为会发生什么？
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result of that last piece of code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一小段代码的结果如下：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When trying to append a value, PHP inserts it after the last numeric key, in
    this case `8`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试追加一个值时，PHP将其插入到最后一个数字键之后，在这种情况下是`8`。
- en: 'You might''ve already figured it out by yourself, but you can always print
    any part of the array by specifying its key:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经自己想出来了，但你总是可以通过指定其键来打印数组的任何部分：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, trying to access a key that does not exist in an array will return
    you a null and throw a notice, as PHP identifies that you are doing something
    wrong in your code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试访问数组中不存在的键将返回null并抛出一个警告，因为PHP识别出你在代码中做了错误的事情。
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The empty and isset functions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空和isset函数
- en: 'There are two useful functions for enquiring about the content of an array.
    If you want to know if an array contains any element at all, you can ask if it
    is empty with the `empty` function. That function actually works with strings
    too, an empty string being a string with no characters ('' ''). The `isset` function
    takes an array position, and returns `true` or `false` depending on whether that
    position exists or not:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个有用的函数可以用来查询数组的内容。如果你想检查数组是否包含任何元素，你可以使用 `empty` 函数来检查它是否为空。实际上，这个函数也可以用于字符串，一个空字符串就是一个没有字符的字符串（'
    '）。`isset` 函数接受一个数组位置，并返回 `true` 或 `false`，取决于该位置是否存在：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, we can see that an array with no elements or a string
    with no characters will return `true` when asked if it is empty, and `false` otherwise.
    When we use `isset($names[2])` to check if the position 2 of the array exists,
    we get `true`, as there is a value for that key: `Hermione`. Finally, `isset($names[3])`
    evaluates to `false` as the key 3 does not exist in that array.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到，一个没有元素的数组或一个没有字符的字符串，当被询问是否为空时，会返回 `true`，否则返回 `false`。当我们使用
    `isset($names[2])` 来检查数组位置 2 是否存在时，我们得到 `true`，因为该键有一个值：`Hermione`。最后，`isset($names[3])`
    评估为 `false`，因为该数组中不存在键 3。
- en: Searching for elements in an array
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中搜索元素
- en: Probably, one of the most used functions with arrays is `in_array`. This function
    takes two values, the value that you want to search for and the array. The function
    returns `true` if the value is in the array and `false` otherwise. This is very
    useful, because a lot of times what you want to know from a list or a map is if
    it contains an element, rather than knowing that it does or its location.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，与数组一起使用最频繁的函数之一是 `in_array`。这个函数接受两个值，你想要搜索的值和数组。如果值在数组中，函数返回 `true`，否则返回
    `false`。这非常有用，因为很多时候你从列表或映射中想要知道的是它是否包含一个元素，而不是知道它是否存在或其位置。
- en: 'Even more useful sometimes is `array_search`. This function works in the same
    way except that instead of returning a Boolean, it returns the key where the value
    is found, or `false` otherwise. Let''s see both functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`array_search` 函数更加有用。这个函数的工作方式与之前相同，只不过它返回的是一个布尔值，而不是找到的值对应的键，如果没有找到则返回
    `false`。让我们看看这两个函数：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ordering arrays
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序数组
- en: An array can be sorted in different ways, so there are a lot of chances that
    the order that you need is different from the current one. By default, the array
    is sorted by the order in which the elements were added to it, but you can sort
    an array by its key or by its value, both ascending and descending. Furthermore,
    when sorting an array by its values, you can choose to preserve their keys or
    to generate new ones as a list.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以以不同的方式排序，所以很可能你需要的是与当前顺序不同的顺序。默认情况下，数组是按照元素被添加到数组的顺序排序的，但你也可以按键或值对其进行排序，包括升序和降序。此外，当按值排序数组时，你可以选择保留它们的键或者生成一个新的列表。
- en: 'There is a complete list of these functions on the official documentation website
    at [http://php.net/manual/en/array.sorting.php](http://php.net/manual/en/array.sorting.php),
    but here we will display the most important ones:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的完整列表可以在官方文档网站上找到，网址为 [http://php.net/manual/en/array.sorting.php](http://php.net/manual/en/array.sorting.php)，但在这里我们将展示其中最重要的几个：
- en: '| Name | Sorts by | Maintains key association | Order of sort |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 排序方式 | 维护键关联 | 排序顺序 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `sort` | Value | No | Low to high |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 值 | 否 | 从低到高 |'
- en: '| `rsort` | Value | No | High to low |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `rsort` | 值 | 否 | 从高到低 |'
- en: '| `asort` | Value | Yes | Low to high |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `asort` | 值 | 是 | 从低到高 |'
- en: '| `arsort` | Value | Yes | High to low |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `arsort` | 值 | 是 | 从高到低 |'
- en: '| `ksort` | Key | Yes | Low to high |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `ksort` | 键 | 是 | 从低到高 |'
- en: '| `krsort` | Key | Yes | High to low |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `krsort` | 键 | 是 | 从高到低 |'
- en: 'These functions always take one argument, the array, and they do not return
    anything. Instead, they directly sort the array we pass to them. Let''s see some
    of them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数始终接受一个参数，即数组，并且它们不返回任何内容。相反，它们直接对传递给它们的数组进行排序。让我们看看其中的一些函数：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Okay, there is a lot going on in the last example. First of all, we initialize
    an array with some key values and assign it to `$properties`. Then we create three
    variables that are copies of the original array—the syntax should be intuitive.
    Why do we do that? Because if we sort the original array, we will not have the
    original content any more. This is not what we want in this specific example,
    as we want to see how the different sort functions affect the same array. Finally,
    we perform three different sorts, and print each of the results. The browser should
    show you something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，最后一个示例中有很多内容。首先，我们使用一些键值初始化一个数组，并将其分配给`$properties`。然后我们创建三个变量，它们是原始数组的副本——语法应该是直观的。我们为什么要这样做？因为我们如果对原始数组进行排序，我们就不会再有原始内容了。在这个特定的例子中，我们不想这样做，因为我们想看到不同的排序函数如何影响同一个数组。最后，我们执行了三种不同的排序，并打印出每个结果。浏览器应该显示如下：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first function, `sort`, orders the values alphabetically. Also, if you check
    the keys, now they are numeric as in a list, instead of the original keys. Instead,
    `asort` orders the values in the same way, but keeps the association of key-values.
    Finally, `ksort` orders the elements by their keys, alphabetically.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`sort`按字母顺序排序值。此外，如果您检查键，现在它们是列表中的数字，而不是原始键。相反，`asort`以相同的方式排序值，但保持键值关联。最后，`ksort`按键的字母顺序排序元素。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How to remember so many function names**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何记住这么多函数名**'
- en: 'PHP has a lot of function helpers that will save you from writing customized
    functions by yourself, for example, it provides you with up to 13 different sorting
    functions. And you can always rely on the official documentation. But, of course,
    you would like to write code without going back and forth from the docs. So, here
    are some tips to remember what each sorting function does:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有很多函数助手，可以帮助您避免自己编写自定义函数，例如，它提供了多达13种不同的排序函数。您始终可以依赖官方文档。但当然，您可能希望编写不返回文档的代码。因此，这里有一些提示来记住每个排序函数的作用：
- en: An `a` in the name means **associative**, and thus, will preserve the key-value
    association.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中的`a`表示**关联的**，因此将保留键值关联。
- en: An `r` in the name means **reverse**, so the order will be from high to low.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中的`r`表示**反向的**，所以顺序将是从高到低。
- en: A `k` means **key**, so the sorting will be based on the keys instead of the
    values.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k`表示**键**，因此排序将基于键而不是值。'
- en: Other array functions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数组函数
- en: There are around 80 different functions related to arrays. As you can imagine,
    you will never even hear about some of them, as they have very specific purposes.
    The complete list can be found at [http://php.net/manual/en/book.array.php](http://php.net/manual/en/book.array.php).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大约有80个与数组相关的不同函数。正如您所想象的那样，您甚至可能从未听说过其中的一些，因为它们具有非常特定的用途。完整的列表可以在[http://php.net/manual/en/book.array.php](http://php.net/manual/en/book.array.php)找到。
- en: 'We can get a list of the keys of the array with `array_keys`, and a list of
    its values with `array_values`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`array_keys`获取数组的键列表，以及使用`array_values`获取其值列表：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can get the number of elements in an array with the `count` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`count`函数来获取数组中的元素数量：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we can merge two or more arrays into one with `array_merge`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`array_merge`将两个或多个数组合并为一个：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last example will print the following array:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例将打印以下数组：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the keys of the second array are now different, as originally,
    both the arrays had the same numeric keys, and an array cannot have two values
    for the same key.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第二个数组的键现在不同了，因为最初，这两个数组都有相同的数字键，而一个数组不能有两个相同的键的值。
- en: PHP in web applications
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP在Web应用程序中
- en: Even though the main purpose of this chapter is to show you the basics of PHP,
    doing it in a reference-manual kind of a way is not interesting enough, and if
    we were to copy-paste what the official documentation says, you might as well
    go there and read it by yourself. Keeping in mind the main purpose of this book
    and your main goal is to write web applications with PHP, let us show you how
    to apply everything you are learning as soon as possible, before you get too bored.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的主要目的是向您展示PHP的基础知识，但以参考手册的方式来做并不足够有趣，如果我们只是复制粘贴官方文档中的内容，您还不如自己去那里阅读。考虑到本书的主要目的和您的目标是用PHP编写网络应用程序，让我们尽快向您展示如何应用您所学的所有内容，以免您感到过于无聊。
- en: In order to do that, we will now start on a journey towards building an online
    bookstore. At the very beginning, you might not see the usefulness of it, but
    that is just because we've still not shown all that PHP can do.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们现在将开始一段旅程，目标是构建一个在线书店。在最开始的时候，你可能看不到它的实用性，但这仅仅是因为我们还没有展示PHP能做的一切。
- en: Getting information from the user
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户获取信息
- en: Let's start by building a home page. In this page, we are going to figure out
    if the user is looking for a book or just walking by. How do we find that out?
    The easiest way right now is to inspect the URL that the user used to access our
    application, and extract some information from there.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从构建一个主页开始。在这个页面上，我们要确定用户是在找书还是在路过。我们如何找到这个信息呢？目前最简单的方法是检查用户用来访问我们应用程序的URL，并从中提取一些信息。
- en: 'Save this content as your `index.php`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容保存为你的`index.php`：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now access the link, `http://localhost:8000/?author=HarperLee&title=To Kill
    a Mockingbird`. You will see that the page prints some of the information that
    you passed on to the URL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问链接，`http://localhost:8000/?author=HarperLee&title=To Kill a Mockingbird`。你会看到页面打印了你传递给URL的一些信息。
- en: 'For each request, PHP stores all the parameters that come from the query string
    in an array called `$_GET`. Each key of the array is the name of the parameter,
    and its associated value is the value of the parameter. So `$_GET` contains two
    entries: `$_GET[''author'']` contains `Harper Lee` and `$_GET[''title'']` has
    the value `To Kill a Mockingbird`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，PHP会将来自查询字符串的所有参数存储在一个名为`$_GET`的数组中。数组的每个键都是参数的名称，其关联的值是参数的值。因此`$_GET`包含两个条目：`$_GET['author']`包含`Harper
    Lee`，而`$_GET['title']`的值是`To Kill a Mockingbird`。
- en: In the first highlighted line, we assign a Boolean value to the variable `$looking`.
    If either `$_GET['title']` or `$_GET['author']` exists, that variable will be
    `true`, otherwise `false`. Just after that, we close the PHP tag and then we print
    some HTML, but as you can see, we are actually mixing the HTML with some PHP code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行高亮显示的代码中，我们给变量`$looking`赋了一个布尔值。如果`$_GET['title']`或`$_GET['author']`存在，该变量将为`true`，否则为`false`。紧接着，我们关闭了PHP标签，然后打印了一些HTML，但正如你所看到的，我们实际上是在混合HTML和一些PHP代码。
- en: Another interesting line here is the second highlighted one. Before printing
    the content of `$looking`, we cast the value. **Casting** means forcing PHP to
    transform a type of value to another one. Casting a Boolean to an integer means
    that the resultant value will be `1` if the Boolean is `true` or `0` if the Boolean
    is `false`. As `$looking` is `true` since `$_GET` contains valid keys, the page
    shows a "1".
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一条有趣的代码行，即第二行高亮显示的代码。在打印`$looking`的内容之前，我们进行了类型转换。**类型转换**意味着强制PHP将一种类型的值转换为另一种类型。将布尔值转换为整数意味着如果布尔值为`true`，则结果值为`1`，如果布尔值为`false`，则结果值为`0`。由于`$_GET`包含有效的键，`$looking`为`true`，因此页面显示了一个“1”。
- en: If we try to access the same page without sending any information, as in `http://localhost:8000`,
    the browser will say **Are you looking for a book? 0**. Depending on the settings
    of your PHP configuration, you will see two notice messages complaining that you
    are trying to access keys of the array that do not exist.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在不发送任何信息的情况下访问相同的页面，如`http://localhost:8000`，浏览器将显示**你在找一本书吗？0**。根据你的PHP配置设置，你会看到两条通知消息，抱怨你正在尝试访问不存在的数组键。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Casting versus type juggling**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换与类型转换**'
- en: We already know that when PHP needs a specific type of variable, it will try
    to transform it, which is called type juggling. But PHP is quite flexible, so
    sometimes, you have to be the one specifying the type that you need. When printing
    something with `echo`, PHP tries to transform everything it gets into strings.
    Since the string version of the Boolean `false` is an empty string, that would
    not be useful for our application. Casting the Boolean to an integer first assures
    that we will see a value, even if it is just a 0.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，当PHP需要特定类型的变量时，它会尝试将其转换，这被称为类型转换。但PHP非常灵活，所以有时你必须指定你需要的类型。当使用`echo`打印内容时，PHP会尝试将得到的所有内容转换为字符串。由于布尔值`false`的字符串形式是一个空字符串，这对我们的应用程序来说可能没有用。首先将布尔值转换为整数可以确保我们能看到一个值，即使它只是一个0。
- en: HTML forms
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML表单
- en: 'HTML forms are one of the most popular ways of collecting information from
    the user. They consist of a series of fields—called `input` in the HTML world—and
    a final `submit` button. In HTML, the `form` tag contains two attributes: `action`
    points where the form will be submitted, and `method`, which specifies the HTTP
    method that the form will use (GET or POST). Let''s see how it works. Save the
    following content as `login.html` and go to `http://localhost:8000/login.html`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 表单是收集用户信息最受欢迎的方式之一。它们由一系列字段组成——在 HTML 世界中称为 `input` 字段——以及一个最终的 `submit`
    按钮。在 HTML 中，`form` 标签包含两个属性：`action` 指定了表单将被提交的位置，而 `method` 指定了表单将使用的 HTTP 方法（GET
    或 POST）。让我们看看它是如何工作的。将以下内容保存为 `login.html` 并访问 `http://localhost:8000/login.html`。
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The form defined in the preceding code contains two fields, one for the username
    and one for the password. You can see that they are identified by the attribute
    name. If you try to submit this form, the browser will show you a **Page Not Found**
    message, as it is trying to access `http://localhost:8000/authenticate.php` and
    the web server cannot find it. Let''s create it then:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中定义的表单包含两个字段，一个用于用户名，一个用于密码。你可以看到它们通过属性 `name` 来标识。如果你尝试提交这个表单，浏览器将显示一个
    **页面未找到** 消息，因为它正在尝试访问 `http://localhost:8000/authenticate.php`，而 web 服务器找不到它。那么让我们创建它：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As with `$_GET`, `$_POST` is an array that contains the parameters received
    by POST. In this preceding piece of code, we first ask if that array is not empty—note
    the `!` operator. Afterwards, we just display the information received, just as
    in `index.php`. Notice that the keys of the `$_POST` array are the values for
    the argument name of each input field.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `$_GET` 类似，`$_POST` 是一个包含通过 POST 接收的参数的数组。在这段代码的前一部分，我们首先检查该数组是否为空——注意 `!`
    操作符。之后，我们只需显示接收到的信息，就像在 `index.php` 中一样。请注意，`$_POST` 数组的键是每个输入字段的参数名称的值。
- en: Persisting data with cookies
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cookies 持久化数据
- en: When we want the browser to remember some data like whether you are logged in
    or not on your web application, your basic info, and so on, we use **cookies**.
    Cookies are stored on the client side and are sent to the server when making a
    request as headers. As PHP is oriented towards web applications, it allows you
    to manage cookies in a very easy way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望浏览器记住一些数据，比如在你的 web 应用程序中你是否已登录，你的基本信息等等，我们使用 **cookies**。Cookies 存储在客户端，并在请求时作为头部信息发送到服务器。由于
    PHP 面向 web 应用程序，它允许你以非常简单的方式管理 cookies。
- en: 'There are few things you need to know about cookies and PHP. You can write
    cookies with the `setcookie` function that accepts several arguments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 cookies 和 PHP，你需要了解一些事情。你可以使用 `setcookie` 函数来写入 cookies，该函数接受多个参数：
- en: A valid name for the cookie as a string.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 cookie 名称作为字符串。
- en: The value of the cookie—only strings or values that can be casted to a string.
    This parameter is optional, and if not set, PHP will actually remove the cookie.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cookie 的值——只能是字符串或可以转换为字符串的值。此参数是可选的，如果没有设置，PHP 实际上会删除 cookie。
- en: Expiration time as a timestamp. If not set, the cookie will be removed once
    the browser is closed.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过期时间作为时间戳。如果没有设置，cookie 将在浏览器关闭时被删除。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Timestamps**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间戳**'
- en: Computers use different ways for describing dates and times, and a very common
    one, especially on Unix systems, is the use of timestamps. They represent the
    number of seconds passed since January 1, 1970\. For example, the timestamp that
    represents October 4, 2015 at 6:30 p.m. would be 1,443,954,637, which is the number
    of seconds since that date.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用不同的方式来描述日期和时间，其中最常见的一种，尤其是在 Unix 系统上，就是使用时间戳。它们表示自 1970 年 1 月 1 日以来经过的秒数。例如，表示
    2015 年 10 月 4 日下午 6:30 的时间戳将是 1,443,954,637，这是自该日期以来的秒数。
- en: You can get the current timestamp with PHP using the `time` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 PHP 的 `time` 函数获取当前的时间戳。
- en: There are other arguments related to security, but they are out of the scope
    of this section. Also note that you can only set cookies if there is no previous
    output from your application, that is, before HTML, `echo` calls, and any other
    similar functions that send some output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与安全相关的其他参数也存在，但它们超出了本节的范围。此外，请注意，你只能在应用程序没有之前的输出之前设置 cookies，也就是说，在 HTML、`echo`
    调用以及任何其他发送输出的类似函数之前。
- en: To read the cookies that the client sends to us, we just need to access the
    array, `$_COOKIE`. It works as the other two arrays, so the keys of the array
    will be the name of the cookies and the value of the array will be their values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取客户端发送给我们的 cookies，我们只需访问数组 `$_COOKIE`。它像其他两个数组一样工作，因此数组的键将是 cookies 的名称，数组的值将是它们的值。
- en: 'A very common usage for cookies is authenticating the user. There are several
    different ways of doing so, depending on the level of security you need for your
    application. Let''s try to implement one very simple—albeit insecure one (do not
    use it for live web applications). Leaving the HTML intact, update the PHP part
    of your `authenticate.php` file with the following content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的cookies用法是验证用户身份。根据您应用程序所需的 安全级别，有几种不同的方法可以实现。让我们尝试实现一个非常简单——尽管不安全的例子（不要用于实际Web应用程序）。保持HTML不变，更新你的`authenticate.php`文件的PHP部分，内容如下：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do the same with the `body` tag in your `index.php`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对`index.php`中的`body`标签做同样的处理：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you access `http://localhost:8000/login.html` again, try to log in, open
    a new tab (in the same browser), and go to the home page at `http://localhost:8000`,
    you will see how the browser still remembers your username.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次访问`http://localhost:8000/login.html`，尝试登录，打开一个新的标签页（在同一浏览器中），并转到主页`http://localhost:8000`，你会看到浏览器仍然记得你的用户名。
- en: Other superglobals
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他超全局变量
- en: '`$_GET`, `$_POST`, and `$_COOKIE` are special variables called **superglobals**.
    There are other superglobals too, like `$_SERVER` or `$_ENV`, which will give
    you extra information. The first one shows you information about headers, paths
    accessed, and other information related to the request. The second one contains
    the environment variables of the machine where your application is running. You
    can see the full list of these arrays and their elements at [http://php.net/manual/es/language.variables.superglobals.php](http://php.net/manual/es/language.variables.superglobals.php).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_GET`、`$_POST`和`$_COOKIE`是称为**超全局变量**的特殊变量。还有其他超全局变量，如`$_SERVER`或`$_ENV`，它们会给你提供额外的信息。第一个显示了关于标题、访问的路径和其他与请求相关的信息。第二个包含了运行应用程序的机器的环境变量。你可以在[http://php.net/manual/es/language.variables.superglobals.php](http://php.net/manual/es/language.variables.superglobals.php)上看到这些数组的完整列表及其元素。'
- en: In general, using superglobals is useful, since it allows you to get information
    from the user, the browser, the request, and so on. This is of immeasurable value
    when writing web applications that need to interact with the user. But with great
    power comes great responsibility, and you should be very careful when using these
    arrays. Most of those values come from the users themselves, which could lead
    to security issues.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用超全局变量是有用的，因为它允许你从用户、浏览器、请求等获取信息。这对于编写需要与用户交互的Web应用程序来说具有无法估量的价值。但是，权力越大，责任越大，使用这些数组时你应该非常小心。这些值中的大多数都来自用户本身，这可能导致安全问题。
- en: Control structures
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: So far, our files have been executed line by line. Due to that, we have been
    getting notices on some scenarios, such as when the array does not contain what
    we are looking for. Would it not be nice if we could choose which lines to execute?
    Control structures to the rescue!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的文件是逐行执行的。正因为如此，我们在某些场景下收到了通知，例如当数组不包含我们正在寻找的内容时。如果我们能选择执行哪些行会不是很好？控制结构来拯救我们！
- en: A **control structure** is like a traffic diversion sign. It directs the execution
    flow depending on some predefined conditions. There are different control structures,
    but we can categorize them in **conditionals** and **loops**. A conditional allows
    us to choose whether to execute a statement or not. A loop executes a statement
    as many times as you need. Let's take a look at each one of them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制结构**就像一个交通分流标志。它根据一些预定义的条件来指导执行流程。有不同种类的控制结构，但我们可以将它们分为**条件**和**循环**。条件允许我们选择是否执行一个语句。循环会根据需要多次执行一个语句。让我们来看看每一个。'
- en: Conditionals
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件
- en: 'A conditional evaluates a Boolean expression, that is, something that returns
    a value. If the expression is `true`, it will execute everything inside its block
    of code. A block of code is a group of statements enclosed by `{}`. Let''s see
    how it works:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 条件评估一个布尔表达式，即返回值的某种东西。如果表达式为`true`，它将执行其代码块内的所有内容。代码块是一组由`{}`包围的语句。让我们看看它是如何工作的：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding piece of code, we use two conditionals. A conditional is defined
    by the keyword `if` followed by a Boolean expression in parentheses and by a block
    of code. If the expression is `true`, it will execute the block, otherwise it
    will skip it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了两个条件。条件是通过关键字`if`后跟括号中的布尔表达式和代码块来定义的。如果表达式为`true`，它将执行该块，否则将跳过它。
- en: 'You can increase the power of conditionals by adding the keyword `else`. This
    tells PHP to execute some block of code if the previous conditions were not satisfied.
    Let''s see an example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加关键字`else`来增强条件语句的威力。这告诉PHP，如果前面的条件没有得到满足，则执行一些代码块。让我们看看一个例子：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding example will execute the code inside the `else` as the condition
    of the `if` was not satisfied.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将在`if`的条件没有得到满足时执行`else`中的代码。
- en: Finally, you can also add an `elseif` keyword followed by another condition
    and a block of code to continue asking PHP for more conditions. You can add as
    many `elseif` as you need after an `if`. If you add an `else`, it has to be the
    last one of the chain of conditions. Also keep in mind that as soon as PHP finds
    a condition that resolves to `true`, it will stop evaluating the rest of conditions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以添加一个`elseif`关键字，后面跟着另一个条件和一段代码，以继续向PHP请求更多条件。你可以在`if`之后添加任意数量的`elseif`。如果你添加了`else`，它必须是条件链中的最后一个。同时，请注意，一旦PHP找到一个解析为`true`的条件，它将停止评估剩余的条件。
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the last example, the first condition that evaluates to `true` is the highlighted
    one. After that, PHP does not evaluate any more conditions until a new `if` starts.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，第一个评估为`true`的条件是突出显示的那个。在那之后，PHP不会评估更多的条件，直到一个新的`if`开始。
- en: 'With this knowledge, let''s try to clean up our application a bit, executing
    statements only when needed. Copy this code to your `index.php` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们尝试清理我们的应用程序，只在需要时执行语句。将此代码复制到你的`index.php`文件中：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this new code, we have mixed conditionals and HTML code in two different
    ways. The first one opens a PHP tag, and adds an `if…else` clause that will print
    whether we are authenticated or not with an `echo`. No HTML is merged within the
    conditionals, which makes it clear.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段新代码中，我们以两种不同的方式混合了条件和HTML代码。第一种是打开一个PHP标签，并添加一个`if…else`子句，该子句将使用`echo`打印我们是否已认证。条件内没有合并HTML，这使得它很清晰。
- en: The second option—the second highlighted block—shows an uglier solution, but
    sometimes necessary. When you have to print a lot of HTML code, `echo` is not
    that handy, and it is better to close the PHP tag, print all HTML you need, and
    then open the tag again. You can do that even inside the code block of an `if`
    clause as you can see in the code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项——第二个突出显示的块——展示了一个更丑陋但有时必要的解决方案。当你需要打印大量的HTML代码时，`echo`并不那么方便，最好是关闭PHP标签，打印所有需要的HTML，然后再打开标签。你甚至可以在`if`子句的代码块内这样做，就像你可以在代码中看到的那样。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Mixing PHP and HTML**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合PHP和HTML**'
- en: If you feel that the last file we edited looks rather ugly, you are right. Mixing
    PHP and HTML is confusing, and you should avoid it. In [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, we will see how to do things
    properly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得我们最后编辑的文件看起来相当丑陋，你是对的。混合PHP和HTML会让人困惑，你应该避免这样做。在[第6章](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "第6章。适应MVC")，*适应MVC*中，我们将看到如何正确地做事。
- en: 'Let''s edit our `authenticate.php` file too, as it is trying to access the
    `$_POST` entries that might not be there. The new content of the file would be
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再编辑一下`authenticate.php`文件，因为它正在尝试访问可能不存在的`$_POST`条目。文件的新内容如下：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code also contains conditionals, which we already know. We are setting
    a variable to know if we submitted a login or not, and set the cookies if so.
    But the highlighted lines show you a new way of including conditionals with HTML.
    This makes the code more readable when working with HTML code, avoiding the use
    of `{}`, and instead using `:` and `endif`. Both syntaxes are correct, and you
    should use the one that you consider more readable in each case.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也包含条件语句，这是我们已知的。我们正在设置一个变量来知道是否提交了登录，如果是的话，则设置cookies。但突出显示的行展示了使用HTML包含条件语句的新方法。这使得在处理HTML代码时代码更易读，避免了使用`{}`，而是使用`:`和`endif`。两种语法都是正确的，你应该在每个情况下使用你认为更易读的一种。
- en: Switch…case
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Switch…case
- en: 'Another control structure similar to `if…else` is `switch…case`. This structure
    evaluates only one expression, and executes the block depending on its value.
    Let''s see an example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if…else`类似的另一个控制结构是`switch…case`。这个结构只评估一个表达式，并根据其值执行相应的代码块。让我们看看一个例子：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `switch` clause takes an expression, in this case a variable, and then defines
    a series of cases. When the case matches the current value of the expression,
    PHP executes the code inside it. As soon as PHP finds a `break` statement, it
    exits the `switch…case`. In case none of the cases are suitable for the expression,
    PHP executes the default, if there is one, but that is optional.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`子句接受一个表达式，在这个例子中是一个变量，然后定义了一系列的情况。当某个情况与表达式的当前值匹配时，PHP会执行其内部的代码。一旦PHP找到一个`break`语句，它就会退出`switch…case`。如果没有适合表达式的任何情况，PHP会执行默认情况（如果有的话），但这不是必须的。'
- en: 'You also need to know that breaks are mandatory if you want to exit the `switch…case`.
    If you do not specify any, PHP will keep on executing statements, even if it encounters
    a new case. Let''s see a similar example, but without the breaks:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道，如果你想退出`switch…case`，break是强制性的。如果你没有指定任何，PHP会继续执行语句，即使它遇到了新的情况。让我们看一个类似的例子，但没有break语句：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you test this code in your browser, you will see that it prints **Uh...A
    classic! Dunno that one**. PHP found that the second case is valid, so it executes
    its content. But as there are no breaks, it keeps on executing until the end.
    This might be the desired behavior sometimes but not usually, so be careful when
    using it!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个浏览器中测试这段代码，你会看到它打印出**嗯...经典！不知道这个**。PHP发现第二个情况是有效的，因此执行了其内容。但是因为没有break语句，它会一直执行到末尾。这可能在某些情况下是期望的行为，但通常不是，所以使用时要小心！
- en: Loops
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: '**Loops** are control structures that allow you to execute certain statements
    several times, as many times as you need. You might use them in several different
    scenarios, but the most common one is when interacting with arrays. For example,
    imagine you have an array with elements, but you do not know what is in it. You
    want to print all its elements, so you loop through all of them.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**是允许你多次执行某些语句的控制结构，你可以根据需要多次执行。你可能会在多种不同的场景中使用它们，但最常见的一个是在与数组交互时。例如，想象你有一个包含元素的数组，但你不知道里面有什么。你想要打印出所有的元素，所以你会遍历它们。'
- en: There are four types of loops. Each of them has its own use cases, but in general,
    you can transform one type of loop into another. Let's look at them closely.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的循环。每种类型都有自己的使用场景，但一般来说，你可以将一种类型的循环转换为另一种类型。让我们仔细看看它们。
- en: While
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: While
- en: 'The `while` loop is the simplest of the loops. It executes a block of code
    until the expression to evaluate returns `false`. Let''s see one example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是最简单的循环。它会在要评估的表达式返回`false`之前执行代码块。让我们看一个例子：'
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, we define a variable with value `1`. Then we have
    a `while` clause in which the expression to evaluate is `$i < 4`. This loop executes
    the content of the block of code until that expression is `false`. As you can
    see, inside the loop we are incrementing the value of `$i` by 1 each time, so
    the loop ends after 4 iterations. Check the output of that script and you will
    see "0 1 2 3". The last value printed is 3, so at that time the value of `$i`
    was 3\. After that, we increased its value to 4, so when the `while` clause evaluates
    if `$i < 4`, the result is `false`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个值为`1`的变量。然后我们有一个`while`子句，其中要评估的表达式是`$i < 4`。这个循环会执行代码块的内容，直到该表达式为`false`。正如你所看到的，在循环内部，我们每次都会将`$i`的值增加1，所以循环会在4次迭代后结束。检查那个脚本的输出，你会看到"0
    1 2 3"。最后打印的值是3，所以在那时`$i`的值是3。之后，我们将其值增加到4，所以当`while`子句评估`$i < 4`时，结果是`false`。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Whiles and infinite loops**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环和无限循环**'
- en: One of the most common problems with the `while` loops is creating an infinite
    loop. If you do not add any code inside the `while` loop that updates any of the
    variables considered in the `while` expression such that it can be `false` at
    some point, PHP will never exit the loop!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环最常见的一个问题就是创建无限循环。如果你没有在`while`循环内添加任何代码来更新`while`表达式中考虑的任何变量，使得它在某个时刻可以返回`false`，PHP将永远不会退出循环！'
- en: Do…while
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Do…while
- en: The `do…while` loop is very similar to `while` in the sense that it evaluates
    an expression each time, and will execute the block of code until that expression
    is `false`. The only difference is that when this expression is evaluated, the
    `while` clause evaluates the expression before executing the code, so sometimes,
    we might not even enter the loop if the expression evaluates to `false` the very
    first time. On the other hand, `do…while` evaluates the expression after it executes
    its block of code, so even if the expression is `false` from the very beginning,
    the loop will be executed at least once.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`do…while`循环在某种程度上与`while`循环非常相似，因为它每次都会评估一个表达式，并且会执行代码块直到该表达式为`false`。唯一的区别在于，当这个表达式被评估时，`while`子句会在执行代码之前评估这个表达式，所以有时候，如果表达式第一次评估就为`false`，我们甚至可能不会进入循环。另一方面，`do…while`在执行其代码块之后评估这个表达式，所以即使表达式一开始就是`false`，循环至少也会执行一次。'
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding piece of code defines two loops with the same expression and block
    of code, but if you execute them, you will see that only the code inside the `do…while`
    is executed. In both cases, the expression is `false` since the beginning, so
    `while` does not even enter the loop, whereas the `do…while` enters the loop once.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了两个具有相同表达式和代码块的循环，但如果你执行它们，你会看到只有`do…while`中的代码被执行。在这两种情况下，表达式从一开始就是`false`，所以`while`甚至没有进入循环，而`do…while`进入循环一次。
- en: For
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: For
- en: 'The `for` loop is the most complex of the four loops. It defines an initialization
    expression, an exit condition, and the end of an iteration expression. When PHP
    first encounters the loop, it executes what is defined as the initialization expression.
    Then, it evaluates the exit condition and if it resolves to `true`, it enters
    the loop. After executing everything inside the loop, it executes the end of the
    iteration expression. Once done, it evaluates the end condition again, going through
    the loop code and the end of the iteration expression, until it evaluates to `false`.
    As always, an example will clarify it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是四种循环中最复杂的。它定义了一个初始化表达式、一个退出条件和迭代结束表达式。当PHP第一次遇到循环时，它会执行初始化表达式所定义的内容。然后，它会评估退出条件，如果它解析为`true`，它会进入循环。在执行循环内的所有内容之后，它会执行迭代结束表达式。一旦完成，它会再次评估结束条件，通过循环代码和迭代结束表达式，直到它评估为`false`。就像往常一样，一个例子会澄清它：'
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The initialization expression is `$i = 1`, and is executed only the first time.
    The exit condition is `$i < 10`, and it is evaluated at the beginning of each
    iteration. The end of the iteration expression is `$i++`, which is executed at
    the end of each iteration. This example prints the numbers from 1 to 9\. Another
    more common usage of the `for` loop is with arrays:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化表达式是`$i = 1`，并且只执行第一次。退出条件是`$i < 10`，它在每次迭代的开始时被评估。迭代结束表达式是`$i++`，它在每次迭代的结束时执行。这个例子会打印从1到9的数字。`for`循环的另一种更常见的用法是与数组一起使用：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, we have an array of names. Since it is defined as a list, its
    keys will be 0, 1, and 2\. The loop initializes the variable `$i` to 0, and it
    iterates until the value of `$i` is not less than the number of elements in the
    array, that is, 3\. In the first iteration, `$i` is 0, in the second, it is 1,
    and in the third one it is equal to 2\. When `$i` is 3, it will not enter the
    loop, as the exit condition evaluates to `false`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名字数组。由于它被定义为列表，它的键将是0、1和2。循环将变量`$i`初始化为0，并且它迭代直到`$i`的值不小于数组中的元素数量，即3。在第一次迭代中，`$i`是0，在第二次迭代中是1，在第三次迭代中是2。当`$i`是3时，它将不会进入循环，因为退出条件评估为`false`。
- en: On each iteration, we print the content of the position `$i` of the array, hence
    the result of this code will be all three names in the array.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们打印数组中位置`$i`的内容，因此这段代码的结果将是数组中的所有三个名字。
- en: Tip
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: '**Be careful with exit conditions**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意退出条件**'
- en: It is very common to set an exit condition that is not exactly what we need,
    especially with arrays. Remember that arrays start with 0 if they are a list,
    so an array of three elements will have entries of 0, 1, and 2\. Defining the
    exit condition as `$i <= count($array)` will cause an error in your code, as when
    `$i` is 3, it also satisfies the exit condition and will try to access the key
    3, which does not exist.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是设置一个不是我们真正需要的退出条件，尤其是在处理数组时。记住，如果数组是一个列表，它从0开始，所以一个有三个元素的数组将有条目0、1和2。将退出条件定义为`$i
    <= count($array)`会在你的代码中引起错误，因为当`$i`是3时，它也满足退出条件，并尝试访问不存在的键3。
- en: Foreach
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Foreach
- en: 'The last, but not least, type of loop is `foreach`. This loop is exclusive
    for arrays, and it allows you to iterate an array entirely, even if you do not
    know its keys. There are two options for the syntax, as you can see in the following
    examples:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `foreach` loop accepts an array—in this case `$names`—and it specifies a
    variable which will contain the value of the entry of the array. You can see that
    we do not need to specify any end condition, as PHP will know when the array has
    been iterated. Optionally, you can specify a variable that contains the key of
    each iteration, as in the second loop.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The `foreach` loops are also useful with maps, where the keys are not necessarily
    numeric. The order in which PHP iterates the array will be the same order that
    you used to insert the contents in the array.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use some loops in our application. We want to show the available books
    in our home page. We have the list of books in an array, so we will have to iterate
    all of them with a `foreach` loop, printing some information from each one. Append
    the following code to the `body` tag in `index.php`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The highlighted code shows a `foreach` loop using the `:` notation as well,
    which is better when mixing it with HTML. It iterates all of the `$books` array,
    and for each book, it prints some information as an HTML list. Notice also that
    we have a conditional inside a loop, which is perfectly fine. Of course, this
    conditional will be executed for each entry in the array, so you should keep the
    block of code of your loops as simple as possible.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a reusable block of code that, given an input, performs some actions
    and, optionally, returns some result. You already know several predefined functions
    like `empty`, `in_array`, or `var_dump`. Those functions come with PHP so you
    do not have to reinvent the wheel, but you can create your own very easily. You
    can define functions when you identify portions of your application that have
    to be executed several times, or just to encapsulate some functionality.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Function declaration
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring a function means writing it down so it can be used later. A function
    has a name, takes some arguments, and has a block of code. Optionally, it can
    define what kind of value is to be returned. The name of the function has to follow
    the same rules as variable names, that is, it has to start with a letter or an
    underscore, and can contain any letters, numbers, or underscore. It cannot be
    a reserved word.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding function''s name is `addNumbers`, and it takes two arguments:
    `$a` and `$b`. The block of code defines a new variable `$sum`, which is the sum
    of both arguments, and then returns its content with `return`. In order to use
    this function, you just need to call it by its name while sending all the required
    arguments, as shown in the highlighted line.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: PHP does not support **overloaded functions**. Overloading refers to the ability
    of declaring two or more functions with the same name but different arguments.
    As you can see, you can declare the arguments without knowing what their types
    are, so PHP would not be able to decide which function to use.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to note is the **variable scope**. We are declaring
    a variable `$sum` inside the block of code, so once the function ends, the variable
    will not be accessible any more. That means that the scope of variables declared
    inside the function is just the function itself. Furthermore, if you had a variable
    `$sum` declared outside the function, it would not be affected at all since the
    function cannot access that variable unless we send it as an argument.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function gets information from outside via arguments. You can define any number
    of arguments—including 0 (none). These arguments need at least a name so they
    can be used inside the function; there cannot be two arguments with the same name.
    When invoking the function, you need to send the arguments in the same order as
    declared.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: A function may contain **optional arguments**, that is, you are not forced to
    provide a value for those arguments. When declaring the function, you need to
    provide a default value for those arguments. So, in case the user does not provide
    a value, the function will use the default one.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This new function in the last example takes two mandatory arguments and an optional
    one. The default value of the optional argument is `false`, and it is then used
    normally inside the function. The function will print the result of the sum if
    the user provides `true` as the third argument, which happens only the third time
    that the function is invoked. For the first two, `$printResult` is set to `false`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments that the function receives are just copies of the values that
    the user provided. That means that if you modify these arguments inside the function,
    it will not affect the original values. This feature is known as sending arguments
    by value. Let''s see an example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are declaring a variable `$a` with value `2`, and then calling the `modify`
    method sending that `$a`. The `modify` method modifies the argument `$a`, setting
    its value to `3`, but this does not affect the original value of `$a`, which remains
    `2` as you can see from `var_dump`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'If what you want is to actually change the value of the original variable used
    in the invocation, you need to pass the argument by reference. To do that, you
    add an ampersand (`&`) before the argument when declaring the function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, on invoking the function `modify`, `$a` will always be `3`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Arguments by value versus by reference**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: PHP allows you to do it, and in fact, some native functions of PHP use arguments
    by reference. Remember the array sorting functions? They did not return the sorted
    array, but sorted the array provided instead. But using arguments by reference
    is a way of confusing developers. Usually, when someone uses a function, they
    expect a result, and they do not want the arguments provided by them to be modified.
    So try to avoid it; people will be grateful!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The return statement
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have as many `return` statements as you want inside your function,
    but PHP will exit the function as soon as it finds one. That means that if you
    have two consecutive `return` statements, the second one will never be executed.
    Still, having multiple `return` statements can be useful if they are inside conditionals.
    Add this function inside your `functions.php` file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And let''s use the last example in your `index.php` file by replacing the highlighted
    content (note that to save some trees, I replaced most of the code that was not
    changed at all with `//…`):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Additionally, you can omit the `return` statement if you do not want the function
    to return anything. In this case, the function will end once it reaches the end
    of the block of code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting and return types
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the release of PHP 7, the language allows the developer to be more specific
    about what functions are getting and returning. You can—always optionally—specify
    the type of argument that the function needs (**type hinting**), and the type
    of result the function will return (**return type**). Let''s first see an example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This preceding function states that the arguments need to be integer, integer,
    and Boolean, and that the result will be an integer. Now, you know that PHP has
    type juggling, so it can usually transform a value of one type to its equivalent
    value of another type, for example, the string "2" can be used as integer 2\.
    To stop PHP from using type juggling with the arguments and results of functions,
    you can declare the directive `strict_types` as shown in the first highlighted
    line. This directive has to be declared at the top of each file where you want
    to enforce this behavior.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'The three invocations work as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The first invocation sends two integers and a Boolean, which is what the function
    expects, so regardless of the value of `strict_types`, it will always work.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second invocation sends an integer, a string, and a Boolean. The string
    has a valid integer value, so if PHP was allowed to use type juggling, the invocation
    would resolve just normally. But in this example, it will fail because of the
    declaration at the top of the file.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third invocation will always fail as the string "something" cannot be transformed
    into a valid integer.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to use a function within our project. In our `index.php`, we have
    a `foreach` loop that iterates the books and prints them. The code inside the
    loop is kind of hard to understand as it is a mix of HTML with PHP, and there
    is a conditional too. Let''s try to abstract the logic inside the loop into a
    function. First, create the new `functions.php` file with the following content:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This file will contain our functions. The first one, `printableTitle`, takes
    an array representing a book, and builds a string with a nice representation of
    the book in HTML. The code is the same as before, just encapsulated in a function.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `index.php` will have to include the `functions.php` file, and then use
    the function inside the loop. Let''s see how:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Well, now our loop looks way cleaner, right? Also, if we need to print the title
    of the book somewhere else, we can reuse the function instead of duplicating code!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have already noticed, PHP comes with a lot of native functions
    that help you to manage arrays and strings in an easier way as compared to other
    languages. The filesystem is another of those areas where PHP tried to make it
    as easy as possible. The list of functions extends to over 80 different ones,
    so we will cover here just the ones that you are more likely to use.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our code, we define a list of books. So far, we have only three books, but
    you can guess that if we want to make this application useful, the list will grow
    way more. Storing the information inside your code is not practical at all, so
    we have to start thinking about externalizing it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think in terms of separating the code from the data, there is no need
    to keep using PHP arrays to define the books. Using a less language-restrictive
    system will allow people who do not know PHP to edit the content of the file.
    There are many solutions for this, like CSV or XML files, but nowadays, one of
    the most used systems to represent data in web applications is JSON. PHP allows
    you to convert arrays to JSON and vice versa using just a couple of functions:
    `json_encode` and `json_decode`. Easy, right?'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following into `books.json`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With just one function, we are able to store all the content from the JSON file
    in a variable as a string. With the function, we transform this JSON string into
    an array. The second argument in `json_decode` tells PHP to transform it to an
    array, otherwise it would use objects, which we have not covered as yet.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'When referencing files within PHP functions, you need to know whether to use
    absolute or relative paths. When using relative paths, PHP will try to find the
    file inside the same directory where the PHP script is. If not found, PHP will
    try to find it in other directories defined in the `include_path` directive, but
    that is something you would like to avoid. Instead, you could use absolute paths,
    which is a way to make sure the reference will not be misunderstood. Let''s see
    two examples:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The constant `__DIR__` contains the directory name of the current PHP file,
    and if we prefix it to the name of our file, we will have an absolute path. In
    fact, even though you might think that writing down the whole path by yourself
    is better, using `__DIR__` allows you to move your application anywhere else without
    needing to change anything in the code, as its content will always match the directory
    of the script, whereas the hardcoded path from the first example will not be valid
    anymore.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Writing files
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's add some functionality to our application. Imagine that we want to allow
    the user to take the book that he or she is looking for, but only if it is available.
    If you remember, we identify the book by the query string. That is not very practical,
    so let's help the user by adding links to the list of books, so when you click
    on a link, the query string will contain that book's information.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If you try the preceding code in your browser, you will see that the list contains
    links, and by clicking on them, the page refreshes with the new title as part
    of the query string. Let''s now check if the book is available or not, and if
    it is, let''s update its available field to `false`. Add the following function
    in your `functions.php`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We have to pay attention as the code starts getting complex. This function takes
    an array of books and a title, and returns a Boolean, being `true` if it could
    book it or `false` if not. Moreover, the array of books is passed by reference,
    which means that all changes to that array will affect the original array too.
    Even though we discouraged this previously, in this case, it is a reasonable approach.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We iterate the whole array of books, asking each time if the title of the current
    book matches the one we are looking for. Only if that is `true`, we will check
    if the book is available or not. If it is, we will update the availability to
    `false` and return `true`, meaning that we booked the book. If the book is not
    available, we will just return `false`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that `foreach` defines `$key` and `$book`. We do so because the
    `$book` variable is a copy of the `$books` array, and if we edit it, the original
    one will not be affected. Instead, we ask for the key of that book too, so when
    editing the array, we use `$books[$key]` instead of `$book`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function from the `index.php` file:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Try it out in your browser. By clicking on an available book, you will get
    the **Booked!** message. We are almost done! We are just missing the last part:
    persist this information back to the filesystem. In order to do that, we have
    to construct the new JSON content and then to write it back to the `books.json`
    file. Of course, let''s do that only if the book was available.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `json_encode` function does the opposite of `json_decode`: it takes an
    array—or any other variable—and transforms it to JSON. The `file_put_contents`
    function is used to write to the file referenced as the first argument, the content
    sent as the second argument. Would you know how to use this function?'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Files versus databases**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Storing information in JSON files is better than having it in your code, but
    it is still not the best option. In [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, you will learn how to store
    data of the application in a database, which is a way better solution.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Other filesystem functions
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to make your application more robust, you could check that the
    `books.json` file exists, that you have read and write permission, and/or that
    the previous content was a valid JSON. You can use some PHP functions for that:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`file_exists`: This function takes the path of the file, and returns a Boolean:
    `true` when the file exists and `false` otherwise.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_writable`: This function works the same as `file_exists`, but checks whether
    the file is writable or not.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full list of functions at [http://uk1.php.net/manual/en/book.filesystem.php](http://uk1.php.net/manual/en/book.filesystem.php).
    You can find functions to move, copy, or remove files, create directories, give
    permissions and ownership, and so on.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through all the basics of procedural PHP while writing
    simple examples in order to practice them. You now know how to use variables and
    arrays with control structures and functions, how to get information from HTTP
    requests, and how to interact with the filesystem among other things.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will study the other and most used paradigm: OOP. That
    is one step closer to writing clean and well-structured applications.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
