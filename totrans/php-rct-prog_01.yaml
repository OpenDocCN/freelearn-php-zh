- en: Chapter 1. Introduction to Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 反应式编程简介
- en: Reactive programming has become a very popular and in demand topic over the
    last few years, and even though the ideas behind it aren't new, it takes the good
    parts from multiple different programming paradigms. This book's purpose is to
    teach you how to start writing PHP applications with principles of reactive programming
    in mind and in combination with pre-existing libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程在过去的几年中已经成为一个非常受欢迎和需求旺盛的主题，尽管其背后的理念并不新颖，但它从多个不同的编程范式中学到了优点。本书的目的是教会你如何带着反应式编程的原则，结合现有的库来编写PHP应用程序。
- en: 'In this chapter, we''ll learn the most important principles that will guide
    us throughout this entire book:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习将指导我们贯穿整本书的最重要的原则：
- en: Recap well-known programming paradigms and quickly explain their meaning for
    humans.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾众所周知的编程范式，并简要解释它们对人类的意义。
- en: We'll see how we can use functional PHP programming, even today, using practical
    examples. We pay special attention to how we can use anonymous functions.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用实用的例子，即使在今天，我们也可以使用函数式PHP编程。我们特别关注我们如何使用匿名函数。
- en: Explain what reactive programing is and what good parts it takes from other
    programming paradigms.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释什么是反应式编程，以及它从其他编程范式中学到了哪些优点。
- en: We'll have a look at some examples of widely spread JavaScript and PHP libraries
    that already use very similar principles to reactive programming.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨一些广泛使用的JavaScript和PHP库的例子，这些库已经使用了与反应式编程非常相似的原则。
- en: Introduce Reactive Extensions and see how these fit into the world of reactive
    programming.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍反应式扩展，并了解这些如何融入反应式编程的世界。
- en: Show what using Reactive Extensions looks like using RxJS and how it fits into
    the grand scheme of things.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS展示使用反应式扩展的样子，以及它是如何融入整个方案的。
- en: Create a first simple demo with RxPHP library.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxPHP库创建一个简单的第一个演示。
- en: Since reactive programming is a programming paradigm, we'll take a quick look
    at other common paradigms that all of us have probably already heard of and that
    you'll see mentioned every time you read or hear about reactive programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反应式编程是一种编程范式，因此我们将快速浏览其他所有我们可能已经听说过的常见范式，你会在阅读或听到反应式编程时经常看到它们。
- en: Imperative programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式编程
- en: Imperative programming is a programming paradigm around executing statements
    that change the program's state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程是一种围绕执行改变程序状态的语句的编程范式。
- en: 'What this means in human language:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这在人类语言中的含义是：
- en: '**Programming paradigm**: This is a set of concepts defining a style of building
    and structuring programs. Most programming languages, such as PHP, support multiple
    paradigms. We can also think of it as a mindset and a way we approach problems
    when using such paradigms.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程范式**：这是一组定义构建和结构化程序风格的概念。大多数编程语言，如PHP，支持多种范式。我们也可以将其视为一种心态和一种当我们使用这些范式时解决问题的方法。'
- en: '**Statements**: Units of action with side effects in imperative programming
    evaluated in sequences usually containing expressions. Statements are executed
    for their side effects and expressions for their return value. Consider this example:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**：在命令式编程中，具有副作用的行为单元，通常包含表达式，按顺序评估。语句执行是为了它们的副作用，表达式是为了它们的返回值。考虑以下示例：'
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line of code is a statement where `2 + 5` is an expression. The expected
    side effect is assigning the value `7` to the `$a` variable. This leads to changing
    the program''s current state. Another statement could be, for instance:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码是一个语句，其中`2 + 5`是一个表达式。预期的副作用是将值`7`赋给`$a`变量。这会导致改变程序的当前状态。另一个例子可以是：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This statement has one expression and no return value.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个语句有一个表达式，但没有返回值。
- en: '**State**: Values of program variables in memory at any given time. In imperative
    programming, we define a series of statements that control the program''s flow
    and, therefore, change its state.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：在任何给定时间内存中程序变量的值。在命令式编程中，我们定义一系列控制程序流程的语句，因此改变其状态。'
- en: Declarative programming
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程
- en: Declarative programming is a paradigm focused on describing a program's logic
    instead of particular executional steps. In other words, in declarative programming,
    we define what we want instead of how we want it. In contrast to imperative programming,
    programs in declarative programming are defined with expressions instead of statements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Very common examples could be SQL and HTML languages. Consider the following
    database query:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In SQL, we define what data from what table we want to query, but the implementation
    details are completely hidden for us. We don't even want to worry about how the
    database engine stores or indexes the data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In HTML, we define the structure of elements; what's behind the browser's rendering
    process isn't important for us. We just want to see the page on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Sequential and parallel programming
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of sequential and parallel programming as counterparts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In sequential programming, we''re executing processes in order. This means
    that a process is started when the preceding process has finished. In other words,
    there is always only one process being executed. The following figure illustrates
    this principle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Sequential and parallel programming](img/00002.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'In parallel programming, multiple processes can be executed concurrently:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Sequential and parallel programming](img/00003.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: To make this easier to understand and more relevant to PHP, we can, instead
    of processes, think of lines of code. PHP interpreter is always sequential and
    it never executes code in parallel.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d
    "Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman"),
    *Multithreaded and Distributed Computing with pthreads and Gearman*, we'll use
    PHP module pthreads that makes it possible to run PHP code in multiple threads,
    but we'll see that it's not as simple as it seems. Module pthreads, in fact, creates
    multiple independent PHP interpreters, each running in a separate thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term asynchronous programming is very common in languages such as JavaScript.
    A very general definition is that, in asynchronous programming, we're executing
    code in a different order than it was defined. This is typical for any event based
    application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: For example, in JavaScript, we first define an event listener with its handler,
    which is executed some time later, when an appropriate event occurs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, this could be, for example, a web application that needs to send an
    e-mail when we create a new blog article. Just, instead of lines of code, we''re
    considering tasks. The following figure demonstrates an asynchronously triggered
    event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous programming](img/00004.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: While the web application was saving an article (processing a task), it triggered
    an event that sent an e-mail and then carried on with the original task. The event
    handler had to be defined somewhere before we started this task.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus parallel programming
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common misconception is that asynchronous and parallel programming are
    the same, or that one is an implication of the other. This is very common in JavaScript
    where, from the user's perspective, it looks like things are running in parallel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: This isn't true, but many programming languages (in fact, just their interpreters),
    create the illusion of running in parallel while they're still sequential. They
    appear to be parallel due to it's event-based nature (JavaScript), or because of
    their interpreter internals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For example, Python simulates threads by switching the execution context between
    different parts of the application. The Python interpreter is still single threaded
    and executes instructions sequentially, but creates the illusion of running code
    in parallel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional programming paradigm treats program flow as an evaluation of
    functions. It utilizes several concepts, where the most important for us are eliminating
    side effects, avoiding mutable data, functions as first-class citizens and higher-order
    functions. The output of each function is dependent only on its input argument
    values, therefore, calling the same function twice has to always return the same
    value. It's based on declarative programming, in the sense of using expressions
    instead of statements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a deeper look what this means:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Eliminating side effects**: While in imperative programming side-effects
    were desired during program execution, in functional programming it''s the exact
    opposite. Each function is supposed to be an individual building block whose return
    value is based only on its input values. Note that, in functional programming,
    it almost never makes sense to define a function that takes no arguments and returns
    no value. Assuming that functions have no side effects, this means that this function
    can''t do anything (or at least anything observable from the outside). This is
    in contrast to imperative programming, where using such functions makes sense
    because they can modify some internal state (of an object for instance). Eliminating
    side effects leads to more independent and better testable code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding mutable data**: The concept of not modifying any input values and
    working with their copies works well with not creating any side effects. Executing
    the same function with the same input parameters will always return the same value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First-class citizens and higher-order functions**: In programming languages,
    stating that type/object/function is a first-class citizen (or first-class element)
    means that this entity supports operations generally available to all other entities.
    Usually, this includes:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be passed as a parameter to functions
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be returned from a function
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be assigned to a variable
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Higher-order functions have a very similar meaning and have to do at least
    one of these:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a function as an argument
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a function as a result
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In functional programming, this concept of higher-order function is often used
    in connection with methods on collections such as `map()`, `filter()`, `reduce()`, `concat()`,
    and `zip()`
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functional programming in PHP
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's step aside for a moment and see how the three concepts mentioned above
    are related to PHP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating side effects
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is mostly a matter of a good programming style and self-discipline. Of
    course, PHP doesn''t restrict us from violating this rule. Note that, by side
    effects, we also mean use cases like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though we have not defined the function `saveToDatabase()` ourselves (for
    example, it comes from a framework we are using), it's still a side effect. If
    we execute the same function again, it will return the same value, but the end
    state is different. For example, it will create the record in the database twice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding mutable data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This concept is simple with primitive data types, for example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, when working with collections, this principle requires the creation
    of a new collection and copying values from the old collection to the new one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example shows this principle in practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, arrays are passed by reference for performance reasons until the first
    attempt to modify them. Then the interpreter will create a copy of the original
    array behind the scene (so called copy-on-write). However, objects are always
    passed as references, so we'll have to be very careful when working with them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: This concept of immutable collections (or objects in general) became very popular
    in JavaScript with libraries such as `Immutable.js`, made by Facebook ( [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)
    ), or the so-called `onPush` change detection mechanism in Angular2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Apart from making our code more predictable, when it's used appropriately, it
    will simplify checking for changes in large collections because, if any of its
    items have changed, then the entire collection is replaced by a new instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In order to check if two collections contain the same data, we can use the identity
    operator (`===` three equal signs) instead of comparing the collections' items
    one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, there are already libraries that make this task easier, for instance,
    `Immutable.php` ( [https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php)
    ). Also, for example, PHP 5.5+ comes with an immutable version of `DateTime` class
    called `DateTimeImmutable` by default.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: First-class citizens and higher-order functions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it starts to get interesting. Functions in PHP have been first-class citizens
    for a very long time already. Moreover, since PHP 5.3+, we can use anonymous functions,
    which greatly simplifies the usage of higher-order functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a very trivial example that applies a function on every item in a
    collection with the built-in `array_map()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have used PHP''s `array_map()` function to iterate the array and return
    the length of each string. If we consider just this function call, it uses many
    of the concepts from multiple paradigms that we have explained above:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What this means in particular:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Single expression `strlen($item)` and no assignments (declarative programming).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation details on how the array is actually iterated are hidden from
    us (declarative programming).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class citizens and higher-order functions (functional programming).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data - this function call doesn't change the original, but creates
    a new array (functional programming).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No side effects - everything happens inside the inner closure. If we used any
    variables, they would exist only inside this closure (functional programming).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just for comparison, if we wanted to write the same example in imperative programming,
    it would be just one line longer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s take this a little further, and say we want to get the sum of all lengths
    greater than `5`. First, we''ll start with the most obvious imperative approach:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can write the same thing using functional programming, utilizing three
    methods we mentioned earlier: map, filter and reduce. In PHP, these are called
    `array_map()`, `array_filter()`, and `array_reduce()` respectively:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We got rid of all statements and used only expressions. The resulting code
    isn''t short, and we had to also create three variables to hold partially processed
    arrays. So let''s transform this into one large nested call:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a little shorter; we can see the sequence of functions applied and
    their respective expressions in the same order. We''ve already encountered inconsistency
    in function declarations in PHP, as shown in the following code, which has been
    highly criticized:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are shortened function definitions from PHP documentation. We can see
    that, sometimes the first argument is the iterated collection; sometimes it's
    the callback function. The same problem exists with string functions and their
    haystack-needle arguments. We can try to improve the readability a little with
    functional-PHP library ( [https://github.com/lstrojny/functional-php](https://github.com/lstrojny/functional-php)
    ) - a collection of functions for functional programming in PHP.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code represents the same example as above, but uses `lstrojny/functional-php`
    library:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It definitely looks better, but this is probably the best we can get when using
    standard PHP arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how the same problem could be solved in a language where
    arrays are objects and map, filter and reduce are its methods. Javascript, for
    example, is such a language, so we can rewrite the same example from above one
    more time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll use the new ES6 standard whenever we show any JavaScript code throughout
    this entire book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Well, this was quite easy and it meets all our expectations from functional
    programming much better than PHP. This might be the reason why we almost never
    use higher-order functions in PHP. They are just too hard to write, read and maintain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, we should look at another topic related to functional programming
    in PHP that is worth mentioning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions in PHP
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every anonymous function is internally represented as an instance of a Closure
    class, shown as follows (we''ll also refer to anonymous functions as closures
    or callables):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What's unusual is that we can bind custom `$this` object when calling a closure,
    a concept that is very common in JavaScript but very rarely used in PHP.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple class that we''ll use for demonstration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, test the function stored in `$count` variable on two objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example prints to console the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In PHP, we can specify what variables we want to pass from the parent scope
    to the closure with the `use` keyword. Variables can be also passed by reference,
    similar to passing variables by reference on function calls. Consider the following
    example that demonstrates both principles:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have two closures `$func` and `$func2`. The first one works with a copy
    of `$str` so, when we print it outside of the function, it''s unmodified. However,
    the second closure, `$func2` works with a reference to the original variable.
    The output for this demo is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We'll be passing objects to closures a lot in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: There's also a `bindTo($newThis)` method with a similar purpose. Instead of
    evaluating the closure, it returns a new Closure object with `$this` binded to `$newThis`, which
    can be later called with for example, `call_user_func()` method. When using closures
    inside objects, the context `$this` is bind automatically, so we don't need to
    worry about it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Anonymous functions and the Closure class are very well explained in the official
    documentation, so head over there if you have any hesitations: [http://php.net/manual/en/functions.anonymous.php](http://php.net/manual/en/functions.anonymous.php)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: PHP magic methods
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP defines a set of names that can be used as class methods with a special
    effect. These are all prefixed with two underscores `__`. For our purposes, we'll
    be particularly interested in two of them, called `__invoke()` and `__call()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The `__invoke()` method is used when we try to use an object as if it were a
    regular function. This is useful when we use higher-order functions because we
    can treat objects and functions exactly the same way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The second `__call()` method is used when we attempt to call an object method
    that doesn't exist (to be precise, a method that is inaccessible). It receives
    as arguments the original method name and an array of its arguments that was used
    when trying to call it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We'll use both of these magic methods in [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The principles shown here aren't very common in PHP, but we'll meet them on
    several occasions when using functional programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this entire book, we'll try to follow PSR-1 and PSR-2 coding standards
    ([http://www.php-fig.org/psr/](http://www.php-fig.org/psr/)). However, we'll often
    violate them on purpose to keep the source codes as short as possible.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll finally grasp reactive programming.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is yet another programming paradigm. It is based around
    the ability to easily express data flows and the automatic propagation of changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore this in more depth:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Data flows** (or data streams): In reactive programming, we want to think
    about variables as "values that change over time". For example, this could be
    a mouse position, user click or data coming via WebSockets. Basically, any event-based
    system can be considered a data stream.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Propagation of change**: A very nice example is a spreadsheet editor. If
    we set the value of a single cell to `A1 = A2 + A3`, this means that every change
    to cells `A2` and `A3` will be propagated to `A1`. In programmers'' speech, this
    corresponds to the observer design pattern where `A2` and `A3` are observables
    and `A1` is an observer. We''ll talk about the observer pattern again later in
    this chapter.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easily express data flows**: This is related mostly to libraries we use rather
    than to the language itself. It means that, if we want to use reactive programming
    effectively, we need to be able to manipulate data streams easily. This principle
    also suggests that reactive programming falls under the category of declarative
    paradigms.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the definition is very broad.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The first part about data flows and propagation of change looks like the observer
    design pattern with iterables. Expressing data flows with ease could be done with
    functional programming. This all basically describes what we've already seen in
    this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The main differences to the observer pattern are how we think and manipulate
    with data streams. In previous examples, we always worked with arrays as inputs,
    which are synchronous, while data streams can be both synchronous and asynchronous.
    From our point of view, it doesn't matter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what a typical implementation of the observer pattern might look
    like in PHP:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to be notified about any changes made by the Observable, we need another
    class called `Observer` that subscribes to an Observable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, a typical usage might look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This example will print two messages to the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This almost follows how we defined the reactive programming paradigm. A data
    stream is a sequence of events coming from an Observable, and changes are propagated
    to all listening observers. The last point we mentioned above - being able to
    easily express data flows - isn't really there. What if we wanted to filter out
    all events that don't match a particular condition, just like we did in the examples
    with `array_filter()` and functional programming? This logic would have to go
    into each `Observer` class implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The principles of reactive programming are actually very common in some libraries.
    We'll have a look at three of them and see how these relate to what we've just
    learned about reactive and functional programming.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: jQuery Promises
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably every web developer has used jQuery at some point. A very handy way
    of avoiding so-called **callback hell** is using Promises when dealing with asynchronous
    calls. For example, calling `jQuery.ajax()` returns a `Promise` object that is
    resolved or rejected when the AJAX call has finished:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `Promise` object represents a value in the future. It's non-blocking (asynchronous),
    but lets us handle it in a declarative approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful use case is chaining callbacks, forming a chain, where each
    callback can modify the value before propagating it further:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we have a single source which is the `functionReturningAPromise()`
    call, and three callbacks where only the last one prints the value that resolved
    the Promise. We can see that the number `42` was modified twice when going through
    the chain of callbacks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reactive programming, we'll use a very similar approach to Promises, but
    while a `Promise` object is always resolved only once (it carries just one value);
    data streams can generate multiple or even an infinite number of values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Gulp streaming build system
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gulp build system has become the most popular build system in JavaScript.
    It''s completely based on streams and manipulating them. Consider the following
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a stream of files that match the predicate `src/*.js`, concats
    all of them together and finally writes one single file to `build/all.min.js`.
    Does this remind you of anything?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This is the same declarative and functional approach we used above, when talking
    about functional programming in PHP. In particular, this `concat()` function could
    be replaced with PHP's `array_reduce()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams in gulp (aka vinyl-source-stream) can be modified in any way we want.
    We can, for example, split a stream into two new streams:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, we can merge two streams and uglify (minify and obfuscate the source code)
    into one stream:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This stream manipulation corresponds very well to the last concept we used to
    define the reactive programming paradigm - express data flows with ease - while
    it's both functional and declarative.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: EventDispatcher component in PHP
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably every PHP framework comes with some type of event-driven component
    to notify various different parts of an application using events.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: One such component comes with the Symfony framework out-of-the-box ( [https://github.com/symfony/event-dispatcher](https://github.com/symfony/event-dispatcher)
    ). It's an independent component that allows subscribing and listening to events
    (the observer pattern).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Event listeners can be later grouped by the events they subscribe to and can
    also be assigned custom tags, as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This principle is very similar to Zend\EventManager used in Zend Framework.
    It is just another variation of the Observable - observer combination.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: We'll come back to Symfony `EventDispatcher` component in  [Chapter 4](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 4. Reactive versus a Typical Event-Driven Approach") , *Reactive vs a
    Typical Event-Driven approach*, where we'll explore how to apply the reactive
    programming approach to event-based systems, which should lead to simplification
    and better-organized code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Extensions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen that the principles in the reactive programming paradigm
    aren't completely new for us, we can start thinking about how to put all this
    together. In other words, what libraries or frameworks do we really need in order
    to start writing reactive code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive Extensions (ReactiveX or just Rx in short) are a set of libraries
    in various languages that make reactive programming easy even in languages where
    concepts of asynchronous and functional programming are clumsy, such as PHP. However,
    there''s a very important distinction:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming doesn't equal Reactive Extensions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: A Reactive Extension is a library that introduces certain principles as one
    of the possible ways to approach reactive programming. Very often, when somebody
    tells you they're using reactive programming to do something in their applications,
    they're in fact talking about a particular Reactive Extension library in their
    favorite language.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Extensions were originally made by Microsoft for .NET and called **Rx.NET**.
    Later, it was ported by Netflix to Java as **RxJava**. Now, there are over a dozen
    supported languages, the most popular probably being **RxJS** - the JavaScript
    implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: All ports follow a very similar API design, however, differences occur and we'll
    talk about them a couple of times. We'll be mostly interested in differences between
    RxPHP and RxJS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: RxPHP is mostly uncharted territory. A more typical environment where we encounter
    asynchronous events is JavaScript, so we'll first demonstrate examples in JavaScript
    (and RxJS 5), and afterwards we will have a look at RxPHP.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Autocomplete with RxJS
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine we want to implement an autocomplete feature that downloads suggestions
    from Wikipedia (this example comes from the official collection of demos on RxJS''s
    GitHub page):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s take a closer look at how this works:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We create an Observable from the form input's `keyup` event. This function is
    built into RxJS to simplify creating Observables. We can, of course, create our
    own Observables as well.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the `map()` function. This is exactly what we have already seen above.
    Note that this `map()` function, is in fact, not `Array.map()`, but `Observable.map()`
    instead, because we're not working with arrays here.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chain with `filter()` method. Exactly the same case as with `map()`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method `debounceTime()` is used to limit propagating an event down the stream
    only once after a period of time. In this case, we're using 750ms, which means
    that, when the user starts typing, it won't download data from Wikipedia on every
    `keyup` event, but only after at least a 750ms delay between two events.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `distinctUntilChanged()` method makes sure we're calling the AJAX request
    only when the value has really changed from the last time, because it makes no
    sense to download the same suggestions twice.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last statement with `keyup.switchMap()` guarantees that when making multiple
    asynchronous calls, only the last one in the stream gets processed. All the others
    are dismissed. This is important because, when dealing with AJAX calls, we have
    absolutely no control over which Promise resolves first.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we didn't use RxJS, this feature would require multiple state variables.
    At least to keep the last value from the input, the last time the event occurred,
    and the last request value for the AJAX call. With RxJS, we can focus on what
    we want to do and not worry about its implementation details (declarative approach).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: With Reactive Extensions, this approach fulfills all we described above about
    reactive programming, functional programming and also, mostly, declarative programming.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Mouse position on drag and drop
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a look at a slightly more complicated example in RxJS. We want to
    track the relative mouse position from where we start dragging an HTML element,
    until we release it (`mouseup` event).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to how this example combines multiple Observables (this example
    also comes from the official collection of demos on RxJS''s GitHub page):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that `mousedrag` is an Observable created by calling `return mousemove(...)`
    and that it emits events only until a `mouseup` event is emitted thanks to `takeUntil(mouseup)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Normally, without RxJS and with a typical imperative approach, this would be
    even more complicated than the previous example, with more state variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this requires some basic knowledge of what functions are available
    for Observables, but even without any previous experience, the code should be
    reasonably easy to understand. Yet again, the implementation details are completely
    hidden for us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RxPHP
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxPHP ( [https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP)
    ) is a port of RxJS. We're going to be using Composer to handle all dependencies
    in our PHP projects. It has become a state of the art tool, so if you haven't
    used it before, download it first and check out some basic usage at  [https://getcomposer.org/](https://getcomposer.org/)
    .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a new directory and initialize a composer project:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Fill in the required fields by the interactive wizard and then add RxPHP as
    a dependency:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the library successfully downloads, composer will also create `autoload.php`
    file to handle all class auto-loading on demand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, our code will print string lengths of different types of fruit:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all future examples, we won't include the `autoload.php` file, to keep the
    examples as short as possible. However, it's obviously required in order to run
    the examples. If you're unsure, have a look at the source codes provided for each
    chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We first created an observer - `CallbackObserver` to be precise - which takes
    three functions as arguments. These are called on the next item in the stream,
    on error and when the input stream is complete and won't emit any more items.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the `CallbackObserver` class is that we don't need to write
    a custom observer class every time we want to handle incoming items in some special
    and not very reusable way. With `CallbackObserver`, we can just write the callables
    for signals we want to handle.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll see:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example was very easy, but compared to the JavaScript environment, it's
    not very common to use asynchronous operations in PHP and, in case we do have
    to work asynchronously, it's probably something non-trivial. In [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit reader with
    RxPHP*, we'll use **Symfony Console component** to handle all user input from
    the command line and, where we can, use similar principles to handling mouse events
    as we saw in the two RxJS examples above.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript examples work very well as examples of what reactive programming
    using Reactive Extensions looks like and what its benefits are.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to know more about Reactive Extensions, head over to [http://reactivex.io/](http://reactivex.io/).
    Also, before continuing to the next chapter, you can have a look at how many different
    operators Rx supports [http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)
    and how these can be used in different languages.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: RxPHP 1.x and RxPHP 2
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of April 2017, there're two versions of RxPHP.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The RxPHP 1.x is stable and requires PHP 5.5+. All examples in this book are
    made for RxPHP 1.x, more specifically, RxPHP 1.5+. It's API is based mostly on
    RxJS 4, but it takes some features from RxJS 5 as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: There's also RxPHP 2 in development, which requires PHP 7.0+. RxPHP 2 API from
    the user's perspective is almost the same as 1.x, it just makes some things easier
    (for example working with even loops, as we'll see in [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*). When we encounter any differences worth mentioning,
    we'll give them extra space.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The newer RxPHP 2 was meant to be based to the PHP loop interoperability specification
    ([https://github.com/async-interop/event-loop](https://github.com/async-interop/event-loop)).
    However, the specification is still in pre-release stage and it won't be stable
    in the nearest future. For this reason, the RxPHP team decided to leave the async-interop
    support for future releases. For more information visit [https://github.com/ReactiveX/RxPHP/pull/150](https://github.com/ReactiveX/RxPHP/pull/150).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we tried to explain the common programming paradigms used
    in most programming languages. These were: imperative, declarative and functional
    programming. We also compared the meanings of asynchronous and parallel code.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We spent some time on practical examples of functional programming in PHP and
    its downsides, and we went through examples of some not very common features,
    such as the Closure class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the definition of reactive programming and how it's related
    to all we saw previously in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We introduced Reactive Extensions (Rx) as a library for one of the possible
    approaches to reactive programming.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In two examples of RxJS, we saw what working with Reactive Extensions looks
    like in practice and how this matches our definition of reactive programming.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced RxPHP, which we'll use throughout this entire book. We
    also quickly talked about differences between RxPHP 1.x and RxPHP 2.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll have a closer look at various parts of the RxPHP
    library and talk more about the principles used in Reactive Extensions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
