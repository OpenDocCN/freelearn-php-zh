<html><head></head><body>
<div class="book" title="The foundations of REST APIs">
<div class="book" title="Status codes in responses"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec146" class="calibre1"/>Status codes in responses</h2></div></div></div><p class="calibre8">If HTTP methods <a id="id752" class="calibre1"/>are very important for requests, status<a id="id753" class="calibre1"/> codes are almost indispensable for responses. With just one number, the client will know what happened with the request. This is especially useful when you know that status codes are a standard, and they are extensively documented on the Internet.</p><p class="calibre8">We've already described the most important ones in <a class="calibre1" title="Chapter 2. Web Applications with PHP" href="part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851">Chapter 2</a>, <span class="strong"><em class="calibre12">Web Applications with PHP</em></span>, but let's list them again, adding a few more that are important for REST APIs. For the full list of <a id="id754" class="calibre1"/>status codes, you can visit <a class="calibre1" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.</p><div class="book" title="2xx – success"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec26" class="calibre1"/>2xx – success</h3></div></div></div><p class="calibre8">All the status codes that<a id="id755" class="calibre1"/> start with 2 are used for responses where the request was processed successfully, regardless of whether it was a GET or POST. Some of the most commonly used ones in this category are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">200 OK</strong></span>: It is the <a id="id756" class="calibre1"/>generic "everything was OK" response. If you were asking for a resource, you will get it in the body of the response, and if you were updating a resource, this will mean that the new data has been successfully saved.</li><li class="listitem"><span class="strong"><strong class="calibre2">201 created</strong></span>: It is the<a id="id757" class="calibre1"/> response used when resources are created successfully with POST or PUT.</li><li class="listitem"><span class="strong"><strong class="calibre2">202 accepted</strong></span>: This<a id="id758" class="calibre1"/> response means that the request has been accepted, but it has not been processed yet. This might be useful when the client needs a straightforward response for a very heavy operation: the server sends the accepted response, and then starts processing it.</li></ul></div></div><div class="book" title="3xx – redirection"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec27" class="calibre1"/>3xx – redirection</h3></div></div></div><p class="calibre8">Even though you might<a id="id759" class="calibre1"/> think there is only one type of redirection, there are a few refinements:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">301 moved permanently</strong></span>: This<a id="id760" class="calibre1"/> means that the resource has been moved to a different URL, so from then on, you should try to access it through the URL provided in the body of the response.</li><li class="listitem"><span class="strong"><strong class="calibre2">303 see other</strong></span>: This<a id="id761" class="calibre1"/> means that the request has been processed but, in order to see the response, you need to access the URL provided in the body of the response.</li></ul></div></div><div class="book" title="4xx – client error"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec28" class="calibre1"/>4xx – client error</h3></div></div></div><p class="calibre8">This category has status codes <a id="id762" class="calibre1"/>describing what went wrong due to the client's request:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">400 bad request</strong></span>: This is a<a id="id763" class="calibre1"/> generic response to a malformed request, that is, there is a syntax error in the endpoint, or some of the expected parameters were not provided.</li><li class="listitem"><span class="strong"><strong class="calibre2">401 unauthorized</strong></span>: This<a id="id764" class="calibre1"/> means the client has not been authenticated successfully yet, and the resource that it is trying to access needs this authentication.</li><li class="listitem"><span class="strong"><strong class="calibre2">403 forbidden</strong></span>: This <a id="id765" class="calibre1"/>error message means that even though the client has been authenticated, it does not have enough permissions to access that resource.</li><li class="listitem"><span class="strong"><strong class="calibre2">404 not found</strong></span>: The<a id="id766" class="calibre1"/> specific resource <a id="id767" class="calibre1"/>has not been found.</li><li class="listitem"><span class="strong"><strong class="calibre2">405 method not allowed</strong></span>: This <a id="id768" class="calibre1"/>means that the endpoint exists, but it does not accept the HTTP method used on the request, for example, we were trying to use PUT, but the endpoint only accepts POST requests.</li></ul></div></div><div class="book" title="5xx – server error"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec29" class="calibre1"/>5xx – server error</h3></div></div></div><p class="calibre8">There are up to 11<a id="id769" class="calibre1"/> different <a id="id770" class="calibre1"/>errors on the server side, but we are only interested in one: the <a id="id771" class="calibre1"/>
<span class="strong"><strong class="calibre2">500 internal server</strong></span> error. You could use this status code when something unexpected, like a database error, happens while processing the request.</p></div></div></div>

<div class="book" title="The foundations of REST APIs">
<div class="book" title="REST API security"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec147" class="calibre1"/>REST API security</h2></div></div></div><p class="calibre8">REST APIs <a id="id772" class="calibre1"/>are a powerful tool since they allow developers to<a id="id773" class="calibre1"/> retrieve and/or update data from the server. But with great power comes great responsibility, and when designing a REST API, you should think about making your data as secure as possible. Imagine— anyone could post tweets on your behalf with a simple HTTP request!</p><p class="calibre8">Similar to using web applications, there are two concepts here: <span class="strong"><strong class="calibre2">authentication</strong></span>
<a id="id774" class="calibre1"/> and <a id="id775" class="calibre1"/>
<span class="strong"><strong class="calibre2">authorization</strong></span>. Authenticating someone is identifying who he or she is, that is, linking his or her request to a user in the database. On the other hand, authorizing someone is to allow that specific user to perform certain actions. You could think of authentication as the login of the user, and authorization as giving permissions.</p><p class="calibre8">REST APIs need to manage these two concepts very carefully. Just because a developer has been authenticated does not mean he can access all the data on the server. Sometimes, users can access only their own data, whereas sometimes you would like to implement a roles system where each role has different access levels. It always depends on the type of application you are building.</p><p class="calibre8">Although authorization happens on the server side, that is, it's the server's database that will decide whether a given user can access a certain resource or not, authentications have to be triggered by the client. This means that the client has to know what authentication system the REST API is using in order to proceed with the authentication. Each REST API will implement its own authentication system, but there are some well known implementations.</p><div class="book" title="Basic access authentication"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec30" class="calibre1"/>Basic access authentication</h3></div></div></div><p class="calibre8">Basic access authentication—BA for short—is, as its name suggests, basic. The client adds the information about<a id="id776" class="calibre1"/> the user in the headers of each request, that is, username and password. The problem is that this information is only encoded using BASE64 but not encrypted, making it extremely easy for an intruder to decode the header and obtain the password in plain text. If you ever have to use it, since, to be honest, it is a very easy way of implementing some sort of authentication, we would recommend you to use it with HTTPS.</p><p class="calibre8">In order to use this method, you need to concatenate the username and password like <code class="email">username:password</code>, encode the resultant string using Base64, and add the authorization header as:</p><div class="informalexample"><pre class="programlisting">Authorization: Basic &lt;encoded-string&gt;</pre></div></div><div class="book" title="OAuth 2.0"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec31" class="calibre1"/>OAuth 2.0</h3></div></div></div><p class="calibre8">If basic<a id="id777" class="calibre1"/> authentication was very simple, and insecure, OAuth 2.0 is the most secure system that <a id="id778" class="calibre1"/>REST APIs use in order to authenticate, and so was the previous OAuth 1.0. There are actually different versions of this standard, but all of them work on the same foundation:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">There are no usernames and passwords. Instead, the provider of the REST API assigns a pair of credentials—a token and the secret—to the developer.</li><li class="listitem" value="2">In order to authenticate, the developer needs to send a POST request to the "token" endpoint, which is different in each REST API but has the same concept. This request has to include the encoded developer credentials.</li><li class="listitem" value="3">The server replies to the previous request with a session token. This (and not the credentials mentioned in the first step) is to be included in each request that you make to the REST API. The session token expires for security reasons, so you will have to repeat the second step again when that happens.</li></ol><div class="calibre13"/></div><p class="calibre8">Even though this standard is kind of recent (2012 onwards), several big companies like Google or Facebook have already implemented it for their REST APIs. It might look a bit overcomplicated, but you will soon get to use it, and even implement it.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using third-party APIs"><div class="book" id="2E6E42-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec76" class="calibre1"/>Using third-party APIs</h1></div></div></div><p class="calibre8">That was enough theory about <a id="id779" class="calibre1"/>REST APIs; it is time to dive into a real world example. In this section, we will write a small PHP application that interacts with Twitter's REST API; that includes requesting developer credentials, authenticating, and sending requests. The goal is to give you your first experience in working with REST APIs, and showing you that it is easier than you could expect. It will also help you to understand better how they work, so it will be easier to build your own later.</p></div>

<div class="book" title="Using third-party APIs">
<div class="book" title="Getting the application's credentials"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec148" class="calibre1"/>Getting the application's credentials</h2></div></div></div><p class="calibre8">REST APIs usually<a id="id780" class="calibre1"/> have the concept of application. An application is like an account on their development site that identifies who uses the API. The credentials that you will use to access the API will be linked to this application, which means that you can have multiple applications linked to the same account.</p><p class="calibre8">Assuming that you have a Twitter<a id="id781" class="calibre1"/> account, go to <a class="calibre1" href="https://apps.twitter.com">https://apps.twitter.com</a> in order to create a new application. Click on the <span class="strong"><strong class="calibre2">Create New App</strong></span> button in order to access the form for application details. The fields are very self-explanatory—just a name for the application, the description, and the website URL. The callback URL is not necessary here, since that will be used only for applications that require access to someone else's account. Agree with the terms and conditions in order to proceed.</p><p class="calibre8">Once you have been redirected to your application's page, you will see all sort of information that you can edit. Since this is just an example, let's go straight to what matters: the credentials. Click on the <span class="strong"><strong class="calibre2">Keys and Access Tokens</strong></span> tab to see the values of <span class="strong"><strong class="calibre2">Consumer key (API key)</strong></span> and <span class="strong"><strong class="calibre2">Consumer Secret (API secret)</strong></span>. There is nothing else that we need from here. You can save them on your filesystem, as <code class="email">~/.twitter_php7.json</code>, for example:</p><div class="informalexample"><pre class="programlisting">{
    "key": "iTh4Mzl0EAPn9HAm98hEhAmVEXS",
    "secret": "PfoWM9yq4Bh6rGbzzJhr893j4r4sMIAeVRaPMYbkDer5N6F"
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Securing your credentials</strong></span>
</p><p class="calibre8">Securing your REST API credentials should be taken seriously. In fact, you should take care of all kinds of credentials, like the database ones. But the difference is that you will usually host your database in your server, which makes things slightly more difficult to whoever wants to attack. On the other hand, the third-party REST API is not part of your system, and someone with your credentials can use your account freely on your behalf.</p><p class="calibre8">Never include<a id="id782" class="calibre1"/> your credentials in your code base, especially if you have your code in GitHub or some other repository. One solution would be to have a file in your server, outside your code, with the credentials; if that file is encrypted, that is even better. And try to refresh your credentials regularly, which you can probably do on the provider's website.</p></div></div></div>

<div class="book" title="Using third-party APIs">
<div class="book" title="Setting up the application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec149" class="calibre1"/>Setting up the application</h2></div></div></div><p class="calibre8">Our application will<a id="id783" class="calibre1"/> be extremely simple. It will consist of one class that will allow us to fetch tweets. This will be managed by our <code class="email">app.php</code> script.</p><p class="calibre8">As we have to make HTTP requests, we can either write our own functions that use <a id="id784" class="calibre1"/>
<span class="strong"><strong class="calibre2">cURL</strong></span> (a set of PHP native functions), or make use of the famous PHP <a id="id785" class="calibre1"/>library, <span class="strong"><strong class="calibre2">Guzzle</strong></span>. This library can be found in <a id="id786" class="calibre1"/>
<span class="strong"><strong class="calibre2">Packagist</strong></span>, so we will use Composer to include it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require guzzlehttp/guzzle</strong></span>
</pre></div><p class="calibre8">We will have a <code class="email">Twitter</code> class, which will get the credentials from the constructor, and one public method: <code class="email">fetchTwits</code>. For now, just create the skeleton so that we can work with it; we will implement such methods in later sections. Add the following code to <code class="email">src/Twitter.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace TwitterApp;

class Twitter {

    private $key;
    private $secret;

    public function __construct(String $key, String $secret) {
        $this-&gt;key = $key;
        $this-&gt;secret = $secret;
    }

    public function fetchTwits(string name, int $count): array {
        return [];
    }
}</pre></div><p class="calibre8">Since we set the namespace <code class="email">TwitterApp</code>, we need to update our <code class="email">composer.json</code> file with the following addition. Remember to run <code class="email">composer update</code> to update the autoloader.</p><div class="informalexample"><pre class="programlisting">"autoload": {
    "psr-4": {"TwitterApp\\": "src"}
}</pre></div><p class="calibre8">Finally, we will create a<a id="id787" class="calibre1"/> basic <code class="email">app.php</code> file, which includes the Composer autoloader, reads the credentials file, and creates a Twitter instance:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use TwitterApp\Twitter;

require __DIR__ . '/vendor/autoload.php';

$path = $_SERVER['HOME'] . '/.twitter_php7.json';
$jsonCredentials = file_get_contents($path);
$credentials = json_decode($jsonCredentials, true);

$twitter = new Twitter($credentials['key'], $credentials['secret']);</pre></div></div></div>

<div class="book" title="Using third-party APIs">
<div class="book" title="Requesting an access token"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec150" class="calibre1"/>Requesting an access token</h2></div></div></div><p class="calibre8">In a real world <a id="id788" class="calibre1"/>application, you would probably want to separate the code related to authentication from the one that deals with operations like fetching or posting data. To keep things simple here, we will let the <code class="email">Twitter</code> class know how to authenticate by itself.</p><p class="calibre8">Let's start by adding a <code class="email">$client</code> property to the class which will contain an instance of Guzzle's <code class="email">Client</code> class. This instance will contain the base URI of the Twitter API, which we can have as the constant <code class="email">TWITTER_API_BASE_URI</code>. Instantiate this property in the constructor so that the rest of the methods can make use of it. You can also add an <code class="email">$accessToken</code> property which will contain the access token returned by the Twitter API when authenticating. All these changes are highlighted here:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace TwitterApp;

use Exception;
<span class="strong"><strong class="calibre2">use GuzzleHttp\Client;</strong></span>

class Twitter {

<span class="strong"><strong class="calibre2">    const TWITTER_API_BASE_URI = 'https://api.twitter.com';</strong></span>

    private $key;
    private $secret;
<span class="strong"><strong class="calibre2">    private $accessToken;</strong></span>
<span class="strong"><strong class="calibre2">    private $client;</strong></span>

    public function __construct(String $key, String $secret) {
        $this-&gt;key = $key;
        $this-&gt;secret = $secret;

<span class="strong"><strong class="calibre2">        $this-&gt;client = new Client(</strong></span>
<span class="strong"><strong class="calibre2">            ['base_uri' =&gt; self::TWITTER_API_BASE_URI]</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
    }

    //...
}</pre></div><p class="calibre8">The next step would be to<a id="id789" class="calibre1"/> write a method that, given the key and secret are provided, requests an access token to the provider. More specifically:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Concatenate the key and the secret with a <code class="email">:</code>. Encode the result using Base64.</li><li class="listitem">Send a POST request to <code class="email">/oauth2/token</code> with the encoded credentials as the <code class="email">Authorization</code> header. Also include a <code class="email">Content-Type</code> header and a body (check the code for more information).</li></ul></div><p class="calibre8">We now invoke the <code class="email">post</code> method of Guzzle's <code class="email">client</code> instance sending two arguments: the endpoint string (<code class="email">/oauth2/token</code>) and an array with options. These options include the headers and the body of the request, as you will see shortly. The response of this invocation is an object that identifies the HTTP response. You can extract the content (body) of the response with <code class="email">getBody</code>. Twitter's API response is a JSON with some arguments. The one that you care about the most is the <code class="email">access_token</code>, the token that you will need to include in each subsequent request to the API. Extract it and save it. The full method looks as follows:</p><div class="informalexample"><pre class="programlisting">private function requestAccessToken() {
    $encodedString = base64_encode(
        $this-&gt;key . ':' . $this-&gt;secret
    );
    $headers = [
        'Authorization' =&gt; 'Basic ' . $encodedString,
        'Content-Type' =&gt; 'application/x-www-form-urlencoded;charset=UTF-8'
    ];
    $options = [
        'headers' =&gt; $headers,
        'body' =&gt; 'grant_type=client_credentials'
    ];

    $response = $this-&gt;client-&gt;post(self:: OAUTH_ENDPOINT, $options);
    $body = json_decode($response-&gt;getBody(), true);

    $this-&gt;accessToken = $body['access_token'];
}</pre></div><p class="calibre8">You can already try this code by adding these two lines at the end of the constructor:</p><div class="informalexample"><pre class="programlisting">$this-&gt;requestAccessToken();
var_dump($this-&gt;accessToken);</pre></div><p class="calibre8">Run the application in order to see the access token given by the provider using the following command. Remember to remove the preceding two lines in order to proceed with the section.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php app.php</strong></span>
</pre></div><p class="calibre8">Keep in mind that, even<a id="id790" class="calibre1"/> though having a key and secret and getting an access token is the same across all OAuth authentications, the specific way of encoding, the endpoint used, and the response received from the provider are exclusive from Twitter's API. It could be that several others are exactly the same, but always check the documentation for each one.</p></div></div>

<div class="book" title="Using third-party APIs">
<div class="book" title="Fetching tweets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec151" class="calibre1"/>Fetching tweets</h2></div></div></div><p class="calibre8">We finally arrive <a id="id791" class="calibre1"/>to the section where we actually make use of the API. We will implement the <code class="email">fetchTwits</code> method in order to get a list of the last <span class="strong"><em class="calibre12">N</em></span> number of tweets for a given user. In order to perform requests, we need to add the <code class="email">Authorization</code> header to each one, this time with the access token. Since we want to make this class as reusable as possible, let's extract this to a private method:</p><div class="informalexample"><pre class="programlisting">private function getAccessTokenHeaders(): array {
    if (empty($this-&gt;accessToken)) {
        $this-&gt;requestAccessToken();
    }

    return ['Authorization' =&gt; 'Bearer ' . $this-&gt;accessToken];
}</pre></div><p class="calibre8">As you can see, the preceding method also allows us to fetch the access token from the provider. This is useful, since if we make more than one request, we will just request the access token once, and we have one unique place to do so. Add now the following method implementation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">const GET_TWITS = '/1.1/statuses/user_timeline.json';</strong></span>
//...
public function fetchTwits(string $name, int $count): array {
    $options = [
        'headers' =&gt; $this-&gt;getAccessTokenHeaders(),
        'query' =&gt; [
            'count' =&gt; $count,
            'screen_name' =&gt; $name
        ]
    ];

    $response = $this-&gt;client-&gt;get(self::GET_TWITS, $options);
    $responseTwits = json_decode($response-&gt;getBody(), true);

    $twits = [];
    foreach ($responseTwits as $twit) {
        $twits[] = [
            'created_at' =&gt; $twit['created_at'],
            'text' =&gt; $twit['text'],
            'user' =&gt; $twit['user']['name']
        ];
    }

    return $twits;
}</pre></div><p class="calibre8">The first part of the<a id="id792" class="calibre1"/> preceding method builds the <code class="email">options</code> array with the access token headers and the query string arguments—in this case, with the number of tweets to retrieve and the user. We perform the GET request and decode the JSON response into an array. This array contains a lot of information that we might not need, so we iterate it in order to extract those fields that we really want—in this example, the date, the text, and the user.</p><p class="calibre8">In order to test the application, just invoke the <code class="email">fetchTwits</code> method at the end of the <code class="email">app.php</code> file, specifying the Twitter ID of one of the people you are following, or yourself.</p><div class="informalexample"><pre class="programlisting">$twits = $twitter-&gt;fetchTwits('neiltyson', 10);
var_dump($twits);</pre></div><p class="calibre8">You should get a response similar to ours, shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="Fetching tweets" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">One thing to keep in<a id="id793" class="calibre1"/> mind is that access tokens expire after some time, returning an HTTP response with a 4xx status code (usually, 401 unauthorized). Guzzle throws an exception when the status code is either 4xx or 5xx, so it is easy manage these scenarios. You could add this code when performing the GET request:</p><div class="informalexample"><pre class="programlisting">try {
    $response = $this-&gt;client-&gt;get(self::GET_TWITS, $options);
} catch (ClientException $e) {
<span class="strong"><strong class="calibre2">    if ($e-&gt;getCode() == 401) {</strong></span>
        $this-&gt;requestAccessToken();
        $response = $this-&gt;client-&gt;get(self::GET_TWITS, $options);
    } else {
        throw $e;
    }
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The toolkit of the REST API developer" id="2F4UM1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec77" class="calibre1"/>The toolkit of the REST API developer</h1></div></div></div><p class="calibre8">While you are developing<a id="id794" class="calibre1"/> your own REST API, or writing an integration for a third-party one, you might want to test it before you start writing your code. There are a handful of tools that will help you with this task, whether you want to use your browser, or you are a fan of the command line.</p></div>

<div class="book" title="The toolkit of the REST API developer" id="2F4UM1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Testing APIs with browsers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec152" class="calibre1"/>Testing APIs with browsers</h2></div></div></div><p class="calibre8">There are actually <a id="id795" class="calibre1"/>several add-ons that allow you to perform HTTP <a id="id796" class="calibre1"/>requests from browsers, depending on which one you use. Some famous names are <span class="strong"><em class="calibre12">Advanced Rest Client</em></span> for Chrome and <span class="strong"><em class="calibre12">RESTClient</em></span> for Firefox. At the end of the day, all those clients allow you to perform the same HTTP requests, where you can specify the URL, the method, the headers, the body, and so on. These clients will also show you all the details you can imagine from the response, including the status code, the time spent, and the body. The following screenshot displays an example of a request using Chrome's <span class="strong"><em class="calibre12">Advanced Rest Client</em></span>:</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Testing APIs with browsers" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If you want to test GET<a id="id797" class="calibre1"/> requests with your own API, and all that you need is the<a id="id798" class="calibre1"/> URL, that is, you do not need to send any headers, you can just use your browser as if you were trying to access any other website. If you do so, and if you are working with JSON responses, you can install another add-on to your browser that will help you in viewing your JSON in a more "beautiful" way. Look for <span class="strong"><em class="calibre12">JSONView</em></span> on any browser for a really handy one.</p></div></div>

<div class="book" title="The toolkit of the REST API developer" id="2F4UM1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Testing APIs using the command line"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec153" class="calibre1"/>Testing APIs using the command line</h2></div></div></div><p class="calibre8">Some people feel <a id="id799" class="calibre1"/>more comfortable using the command line; so luckily, for<a id="id800" class="calibre1"/> them there are tools that allow them to perform any HTTP request from their consoles. We will give a brief introduction to one of the most famous ones: cURL. This tool has quite a lot of features, but we will focus only on the ones that you will be using more often: the HTTP method, post parameters, and headers:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">-X &lt;method&gt;</code>: This specifies the HTTP method to use</li><li class="listitem"><code class="email">--data</code>: This adds the parameters specified, which can be added as key-value pairs, JSON, plain text, and so on</li><li class="listitem"><code class="email">--header</code>: This adds a header to the request</li></ul></div><p class="calibre8">The following is an example of the way to send a POST request with cURL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">curl -X POST --data "text=This is sparta!" \</strong></span>
<span class="strong"><strong class="calibre2">&gt; --header "Authorization: Bearer 8s8d7bf8asdbf8sbdf8bsa" \</strong></span>
<span class="strong"><strong class="calibre2">&gt;  https://api.twitter.com/1.1/statuses/update.json</strong></span>
<span class="strong"><strong class="calibre2">{"errors":[{"code":89,"message":"Invalid or expired token."}]}</strong></span>
</pre></div><p class="calibre8">If you are using a Unix <a id="id801" class="calibre1"/>system, you will probably be able to format<a id="id802" class="calibre1"/> the resulting JSON by appending <code class="email">| python -m json.tool</code> so that it gets easier to read:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ curl -X POST --data "text=This is sparta!" \</strong></span>
<span class="strong"><strong class="calibre2">&gt; --header "Authorization: Bearer 8s8d7bf8asdbf8sbdf8bsa" \</strong></span>
<span class="strong"><strong class="calibre2">&gt;  https://api.twitter.com/1.1/statuses/update.json \</strong></span>
<span class="strong"><strong class="calibre2">&gt; | python -m json.tool</strong></span>
<span class="strong"><strong class="calibre2">{</strong></span>
<span class="strong"><strong class="calibre2">    "errors": [</strong></span>
<span class="strong"><strong class="calibre2">        {</strong></span>
<span class="strong"><strong class="calibre2">            "code": 89,</strong></span>
<span class="strong"><strong class="calibre2">            "message": "Invalid or expired token."</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">    ]</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
</pre></div><p class="calibre8">cURL is quite a powerful tool that lets you do quite a few tricks. If you are interested, go ahead and check the documentation or some tutorial on how to use all its features.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec78" class="calibre1"/>Best practices with REST APIs</h1></div></div></div><p class="calibre8">We've already gone through <a id="id803" class="calibre1"/>some of the best practices when writing REST APIs, like<a id="id804" class="calibre1"/> using HTTP methods properly, or choosing the correct status code for your responses. We also described two of the most used authentication systems. But there is still a lot to learn about creating proper REST APIs. Remember that they are meant to be used by developers like yourself, so they will always be grateful if you do things properly, and make their lives easier. Ready?</p></div>

<div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Consistency in your endpoints"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec154" class="calibre1"/>Consistency in your endpoints</h2></div></div></div><p class="calibre8">When deciding how to name your <a id="id805" class="calibre1"/>endpoints, try keeping them consistent. Even though you are free to choose, there is a set of spoken rules that will make your endpoints more intuitive and easy to understand. Let's list some of them:</p><div class="book"><ul class="itemizedlist"><li class="listitem">For starters, an endpoint should point to a specific resource (for example, books or tweets), and you should make that clear in your endpoint. If you have an endpoint that returns the list of all books, do not name it <code class="email">/library</code>, as it is not obvious what it will be returning. Instead, name it <code class="email">/books</code> or <code class="email">/books/all</code>.</li><li class="listitem">The name of the resource can be either plural or singular, but make it consistent. If sometimes you use <code class="email">/books</code> and sometimes <code class="email">/user</code>, it might be confusing, and people will probably make mistakes. We personally prefer to use the plural form, but that is totally up to you.</li><li class="listitem">When you want to retrieve a specific resource, do it by specifying the ID whenever possible. IDs must be unique in your system, and any other parameter might point to two different entities. Specify the ID next to the name of the resource, such as <code class="email">/books/249234-234-23-42</code>.</li><li class="listitem">If you can understand what an endpoint does by just the HTTP method, there is no need to add this information as part of the endpoint. For example, if you want to get a book, or you want to delete it, <code class="email">/books/249234-234-23-42</code> along with the HTTP methods GET and DELETE are more than enough. If it is not obvious, state it as a verb at the end of the endpoint, like <code class="email">/employee/9218379182/promote</code>.</li></ul></div></div></div>

<div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Document as much as you can"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec155" class="calibre1"/>Document as much as you can</h2></div></div></div><p class="calibre8">The title says everything. You <a id="id806" class="calibre1"/>are probably not going to be the one using the REST API, others will. Obviously, even if you design a very intuitive set of endpoints, developers will still need to know the whole set of available endpoints, what each of them does, what optional parameters are available, and so on.</p><p class="calibre8">Write as much documentation as possible, and keep it up to date. Take a look at other documented APIs to gather ideas on how to display the information. There are plenty of templates and tools that will help you deliver a well-presented documentation, but you are the one that has to be consistent and methodical. Developers have a special hate towards documenting anything, but we also like to find clear and beautifully presented documentation when <a id="id807" class="calibre1"/>we need to use someone else's APIs.</p></div></div>

<div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Filters and pagination"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec156" class="calibre1"/>Filters and pagination</h2></div></div></div><p class="calibre8">One of the common<a id="id808" class="calibre1"/> usages of an API is to list resources and filter them <a id="id809" class="calibre1"/>by some criteria. We already saw an example when we were building our own bookstore; we wanted to get the list of books that contained a certain string in their titles or authors.</p><p class="calibre8">Some developers try to have beautiful endpoints, which a priori is a good thing to do. Imagine that you want to filter just by title, you might end up having an endpoint like <code class="email">/books/title/&lt;string&gt;</code>. We add also the ability to filter by author, and we now get two more endpoints: <code class="email">/books/title/&lt;string&gt;/author/&lt;string&gt;</code> and <code class="email">/books/author/&lt;string&gt;</code>. Now let's add the description too—do you see where we are going?</p><p class="calibre8">Even though some developers do not like to use query strings as arguments, there is nothing wrong with it. In fact, if you use them properly, you will end up with cleaner endpoints. You want to get books? Fine, just use <code class="email">/books</code>, and add whichever filter you need using the query string.</p><p class="calibre8">Pagination occurs when you have way too many resources of the same type to retrieve all at once. You should think of pagination as another optional filter to be specified as a GET parameter. You should have pages with a default size, let's say 10 books, but it is a good idea to give the developers the ability to define their own size. In this case, developers can specify the length and the number of pages to retrieve.</p></div></div>

<div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="API versioning"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec157" class="calibre1"/>API versioning</h2></div></div></div><p class="calibre8">Your API is a reflection <a id="id810" class="calibre1"/>of what your application can do. Chances are that your code will evolve, improving the already existing features or adding new ones. Your API should be updated too, exposing those new features, updating existing endpoints, or even removing some of them.</p><p class="calibre8">Imagine now that someone else is using your REST API, and their whole website relies on it. If you change your existing endpoints, their website will stop working! They will not be happy at all, and will try to find someone else that can do what you were doing. Not a good scenario, but then, how do you improve your API?</p><p class="calibre8">The solution is to use versioning. When you release a new version of the API, do not nuke down the existing one; you should give some time to the users to upgrade their integrations. And how can two different versions of the API coexist? You already saw one of the options—the one that we recommend you: by specifying the version of the API to use as part of the endpoint. Do you remember the endpoint of the Twitter API <code class="email">/1.1/statuses/user_timeline.json</code>? The <code class="email">1.1</code> refers to the version that we want to use.</p></div></div>

<div class="book" title="Best practices with REST APIs" id="2G3F81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Using HTTP cache"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec158" class="calibre1"/>Using HTTP cache</h2></div></div></div><p class="calibre8">If the main feature of<a id="id811" class="calibre1"/> REST APIs is that they make heavy use of HTTP, why not take advantage of HTTP cache? Well, there are actual reasons for not using it, but most of them are due to a lack of knowledge about using it properly. It is out of the scope of this book to explain every single detail of its implementation, but let's try to give a short introduction to the topic. Plenty of resources on the Internet can help you to understand the parts that you are more interested in.</p><p class="calibre8">HTTP responses can be divided as public and private. Public responses are shared between all users of the API, whereas the private ones are meant to be unique for each user. You can specify which type of response is yours using the <code class="email">Cache-Control</code> header, allowing the response to be cached if the method of the request was a GET. This header can also expose the expiration of the cache, that is, you can specify the duration for which your response will remain the same, and thus, can be cached.</p><p class="calibre8">Other systems rely on generating a hash of the representation of a resource, and add it as the <code class="email">ETag</code> (Entity tag) header in order to know if the resource has changed or not. In a similar way, you can set the <code class="email">Last-Modified</code> header to let the client know when was the last time that the given resource changed. The idea behind those systems is to identify when the client already contains valid data. If so, the provider does not process the request, but returns an empty response with the status code 304 (not modified) instead. When the client gets that response, it uses its cached content.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a REST API with Laravel"><div class="book" id="2H1VQ2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec79" class="calibre1"/>Creating a REST API with Laravel</h1></div></div></div><p class="calibre8">In this section, we <a id="id812" class="calibre1"/>will build a REST API with Laravel from scratch. This REST API will allow you to manage different clients at your bookstore, not only via the browser, but via the UI as well. You will be able to perform pretty much the same actions as before, that is, listing books, buying them, borrowing for free, and so on.</p><p class="calibre8">Once the REST API is done, you should remove all the business logic from the bookstore that you built during the previous chapters. The reason is that you should have one unique place where you can actually manipulate your databases and the REST API, and the rest of the applications, like the web one, should able to communicate with the REST API for managing data. In doing so, you will be able to create other applications for different platforms, like mobile apps, that will use the REST API too, and both the website and the mobile app will always be synchronized, since they will be using the same sources.</p><p class="calibre8">As with our previous Laravel example, in order to create a new project, you just need to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ laravel new bookstore_api</strong></span>
</pre></div></div>

<div class="book" title="Creating a REST API with Laravel">
<div class="book" title="Setting OAuth2 authentication"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec159" class="calibre1"/>Setting OAuth2 authentication</h2></div></div></div><p class="calibre8">The first thing<a id="id813" class="calibre1"/> that we are going to implement is the authentication layer. We will use OAuth2 in order to make our application more secure than basic authentication. Laravel does not provide support for OAuth2 out of the box, but there is a service provider which does that for us.</p><div class="book" title="Installing OAuth2Server"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec32" class="calibre1"/>Installing OAuth2Server</h3></div></div></div><p class="calibre8">To install <a id="id814" class="calibre1"/>OAuth2, add it as a dependency to your project using Composer:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require "lucadegasperi/oauth2-server-laravel:5.1.*"</strong></span>
</pre></div><p class="calibre8">This service provider needs quite a few changes. We will go through them without going into too much detail on how things work exactly. If you are more interested in the topic, or if you want to create your own service providers for Laravel, we recommend you to go though the extensive official documentation.</p><p class="calibre8">To start with, we need to add the new OAuth2Server service provider to the array of providers in the <code class="email">config/app.php</code> file. Add the following lines at the end of the <code class="email">providers</code> array:</p><div class="informalexample"><pre class="programlisting">/*
 * OAuth2 Server Service Providers...
 */
        LucaDegasperi\OAuth2Server\Storage\FluentStorageServiceProvider::class,       LucaDegasperi\OAuth2Server\OAuth2ServerServiceProvider::class,</pre></div><p class="calibre8">In the same way, you need to add a new alias to the <code class="email">aliases</code> array in the same file:</p><div class="informalexample"><pre class="programlisting">'Authorizer' =&gt; LucaDegasperi\OAuth2Server\Facades\Authorizer::class,</pre></div><p class="calibre8">Let's move to the <code class="email">app/Http/Kernel.php</code> file, where we need to make some changes too. Add the following entry to the <code class="email">$middleware</code> array property of the <code class="email">Kernel</code> class:</p><div class="informalexample"><pre class="programlisting">\LucaDegasperi\OAuth2Server\Middleware\OAuthExceptionHandlerMiddleware::class,</pre></div><p class="calibre8">Add the following key-value pairs to the <code class="email">$routeMiddleware</code> array property of the same class:</p><div class="informalexample"><pre class="programlisting">'oauth' =&gt; \LucaDegasperi\OAuth2Server\Middleware\OAuthMiddleware::class,
'oauth-user' =&gt; \LucaDegasperi\OAuth2Server\Middleware\OAuthUserOwnerMiddleware::class,
'oauth-client' =&gt; \LucaDegasperi\OAuth2Server\Middleware\OAuthClientOwnerMiddleware::class,
'check-authorization-params' =&gt; \LucaDegasperi\OAuth2Server\Middleware\CheckAuthCodeRequestMiddleware::class,
'csrf' =&gt; \App\Http\Middleware\VerifyCsrfToken::class,</pre></div><p class="calibre8">We added a <a id="id815" class="calibre1"/>CSRF token verifier to the <code class="email">$routeMiddleware</code>, so we need to remove the one already defined in <code class="email">$middlewareGroups</code>, since they are incompatible. Use the following line to do so:</p><div class="informalexample"><pre class="programlisting">\App\Http\Middleware\VerifyCsrfToken::class,</pre></div></div><div class="book" title="Setting up the database"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec33" class="calibre1"/>Setting up the database</h3></div></div></div><p class="calibre8">Let's set up the<a id="id816" class="calibre1"/> database now. In this section, we will assume that you already have the bookstore database in your environment. If you do not have it, go back to <a class="calibre1" title="Chapter 5. Using Databases" href="part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851">Chapter 5</a>, <span class="strong"><em class="calibre12">Using Databases</em></span>, to create it in order to proceed with this setup.</p><p class="calibre8">The first thing to do is to update the database credentials in the <code class="email">.env</code> file. They should look something similar to the following lines, but with your username and password:</p><div class="informalexample"><pre class="programlisting">DB_HOST=localhost
DB_DATABASE=bookstore
DB_USERNAME=root
DB_PASSWORD=</pre></div><p class="calibre8">In order to prepare the configuration and database migration files from the OAuth2Server service provider, we need to publish it. In Laravel, you do it by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan vendor:publish</strong></span>
</pre></div><p class="calibre8">Now the <code class="email">database/migrations</code> directory contains all the necessary migration files that will create the necessary tables related to OAuth2 in our database. To execute them, we run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan migrate</strong></span>
</pre></div><p class="calibre8">We need to add at least one client to the <code class="email">oauth_clients</code> table, which is the table that stores the key and secrets for all clients that want to connect to our REST API. This new client will be the one that you will use during the development process in order to test what you have done. We can set a random ID—the key—and the secret as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mysql&gt; INSERT INTO oauth_clients(id, secret, name)</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; VALUES('iTh4Mzl0EAPn90sK4EhAmVEXS',</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; 'PfoWM9yq4Bh6rGbzzJhr8oDDsNZwGlsMIAeVRaPM',</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; 'Toni');</strong></span>
<span class="strong"><strong class="calibre2">Query OK, 1 row affected, 1 warning (0.00 sec)</strong></span>
</pre></div></div><div class="book" title="Enabling client-credentials authentication"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec34" class="calibre1"/>Enabling client-credentials authentication</h3></div></div></div><p class="calibre8">Since we <a id="id817" class="calibre1"/>published the plugins in <code class="email">vendor</code> in the previous step, now we have the configuration files for the OAuth2Server. This plugin allows us different authentication systems (all of them with OAuth2), depending on our necessities. The one that we are interested in for our project is the <code class="email">client_credentials</code> type. To let Laravel know, add the following lines at the end of the array in the <code class="email">config/oauth2.php</code> file:</p><div class="informalexample"><pre class="programlisting">'grant_types' =&gt; [
     'client_credentials' =&gt; [
        'class' =&gt; 
            '\League\OAuth2\Server\Grant\ClientCredentialsGrant',
        'access_token_ttl' =&gt; 3600
    ]
]</pre></div><p class="calibre8">These preceding lines grant access to the <code class="email">client_credentials</code> type, which are managed by the <code class="email">ClientCredentialsGrant</code> class. The <code class="email">access_token_ttl</code> value refers to the time period of the access token, that is, for how long someone can use it. In this case, it is set to 1 hour, that is, 3,600 seconds.</p><p class="calibre8">Finally, we need to enable a route so we can post our credentials in exchange for an access token. Add the following route to the routes file in <code class="email">app/Http/routes.php</code>:</p><div class="informalexample"><pre class="programlisting">Route::post('oauth/access_token', function() {
    return Response::json(Authorizer::issueAccessToken());
});</pre></div></div><div class="book" title="Requesting an access token"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec35" class="calibre1"/>Requesting an access token</h3></div></div></div><p class="calibre8">It is time to test what<a id="id818" class="calibre1"/> we have done so far. To do so, we need to send a POST request to the <code class="email">/oauth/access_token</code> endpoint that we enabled just now. This request needs the following POST parameters:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">client_id</code> with the key from the database</li><li class="listitem"><code class="email">client_secret</code> with the secret from the database</li><li class="listitem"><code class="email">grant_type</code> to specify the type of authentication that we are trying to perform, in this case <code class="email">client_credentials</code></li></ul></div><p class="calibre8">The request issued using the <span class="strong"><em class="calibre12">Advanced REST Client</em></span> add-on from Chrome looks as follows:</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Requesting an access token" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The response that you <a id="id819" class="calibre1"/>should get should have the same format as this one:</p><div class="informalexample"><pre class="programlisting">{
    "access_token": "MPCovQda354d10zzUXpZVOFzqe491E7ZHQAhSAax"
    "token_type": "Bearer"
    "expires_in": 3600
}</pre></div><p class="calibre8">Note that this is a different way of requesting for an access token than what the Twitter API does, but the idea is still the same: given a key and a secret, the provider gives us an access token that will allow us to use the API for some time.</p></div></div></div>

<div class="book" title="Creating a REST API with Laravel">
<div class="book" title="Preparing the database"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec160" class="calibre1"/>Preparing the database</h2></div></div></div><p class="calibre8">Even though<a id="id820" class="calibre1"/> we've already done the same in the previous chapter, you might think: "Why do we start by preparing the database?". We could argue that you first need to know the kind of endpoints you want to expose in your REST API, and only then you can start thinking about what your database should look like. But you could also think that, since we are working with an API, each endpoint should manage one resource, so first you need to define the resources you are dealing with. This <span class="strong"><em class="calibre12">code first versus database/model first</em></span> is an ongoing war on the Internet. But whichever way you think is better, the fact is that we already know what the users will need to do with our REST API, since we already built the UI previously; so it does not really matter.</p><p class="calibre8">We need to create four tables: <code class="email">books</code>, <code class="email">sales</code>, <code class="email">sales_books</code>, and <code class="email">borrowed_books</code>. Remember that Laravel already provides a <code class="email">users</code> table, which we can use as our customers. Run the following four commands to create the migrations files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan make:migration create_books_table --create=books</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:migration create_sales_table --create=sales</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:migration create_borrowed_books_table \</strong></span>
<span class="strong"><strong class="calibre2">--create=borrowed_books</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:migration create_sales_books_table \</strong></span>
<span class="strong"><strong class="calibre2">--create=sales_books</strong></span>
</pre></div><p class="calibre8">Now we have to go file by file to define what each table should look like. We will try to replicate the data structure from <a class="calibre1" title="Chapter 5. Using Databases" href="part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851">Chapter 5</a>, <span class="strong"><em class="calibre12">Using Databases</em></span>, as much as possible. Remember that the migration files can be found inside the <code class="email">database/migrations</code> directory. The first file that we can edit is the <code class="email">create_books_table.php</code>. Replace the existing empty <code class="email">up</code> method by the following one:</p><div class="informalexample"><pre class="programlisting">public function up()
{
    Schema::create('books', function (Blueprint $table) {
        $table-&gt;increments('id');
        $table-&gt;string('isbn')-&gt;unique();
        $table-&gt;string('title');
        $table-&gt;string('author');
        $table-&gt;smallInteger('stock')-&gt;unsigned();
        $table-&gt;float('price')-&gt;unsigned();
    });
}</pre></div><p class="calibre8">The next one in the <a id="id821" class="calibre1"/>list is <code class="email">create_sales_table.php</code>. Remember that this one has a foreign key pointing to the <code class="email">users</code> table. You can use <code class="email">references(field)-&gt;on(tablename)</code> to define this constraint.</p><div class="informalexample"><pre class="programlisting">public function up()
{
    Schema::create('sales', function (Blueprint $table) {
        $table-&gt;increments('id');
        $table-&gt;string('user_id')-&gt;references('id')-&gt;on('users');
        $table-&gt;timestamps();
    });
}</pre></div><p class="calibre8">The <code class="email">create_sales_books_table.php</code> file contains two foreign keys: one pointing to the ID of the sale, and one to the ID of the book. Replace the existing <code class="email">up</code> method by the following one:</p><div class="informalexample"><pre class="programlisting">public function up()
{
    Schema::create('sales_books', function (Blueprint $table) {
        $table-&gt;increments('id');
        $table-&gt;integer('sale_id')-&gt;references('id')-&gt;on('sales');
        $table-&gt;integer('book_id')-&gt;references('id')-&gt;on('books');
        $table-&gt;smallInteger('amount')-&gt;unsigned();
    });
}</pre></div><p class="calibre8">Finally, edit the <code class="email">create_borrowed_books_table.php</code> file, which has the <code class="email">book_id</code> foreign key and the <code class="email">start</code> and <code class="email">end</code> timestamps:</p><div class="informalexample"><pre class="programlisting">public function up()
{
    Schema::create('borrowed_books', function (Blueprint $table) {
        $table-&gt;increments('id');
        $table-&gt;integer('book_id')-&gt;references('id')-&gt;on('books');
        $table-&gt;string('user_id')-&gt;references('id')-&gt;on('users');
        $table-&gt;timestamp('start');
        $table-&gt;timestamp('end');
    });
}</pre></div><p class="calibre8">The migration files<a id="id822" class="calibre1"/> are ready so we just need to migrate them in order to create the database tables. Run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan migrate</strong></span>
</pre></div><p class="calibre8">Also, add some books to the database manually so that you can test later. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mysql&gt; INSERT INTO books (isbn,title,author,stock,price) VALUES</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ("9780882339726","1984","George Orwell",12,7.50),</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ("9789724621081","1Q84","Haruki Murakami",9,9.75),</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ("9780736692427","Animal Farm","George Orwell",8,3.50),</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ("9780307350169","Dracula","Bram Stoker",30,10.15),</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ("9780753179246","19 minutes","Jodi Picoult",0,10);</strong></span>
<span class="strong"><strong class="calibre2">Query OK, 5 rows affected (0.01 sec)</strong></span>
<span class="strong"><strong class="calibre2">Records: 5  Duplicates: 0  Warnings: 0</strong></span>
</pre></div></div></div>

<div class="book" title="Creating a REST API with Laravel">
<div class="book" title="Setting up the models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec161" class="calibre1"/>Setting up the models</h2></div></div></div><p class="calibre8">The next thing to<a id="id823" class="calibre1"/> do on the list is to add the relationships that our data has, that is, to translate the foreign keys from the database to the models. First of all, we need to create those models, and for that we just run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan make:model Book</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:model Sale</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:model BorrowedBook</strong></span>
<span class="strong"><strong class="calibre2">$ php artisan make:model SalesBook</strong></span>
</pre></div><p class="calibre8">Now we have to go model by model, and add the one to one and one to many relationships as we did in the previous chapter. For <code class="email">BookModel</code>, we will only specify that the model does not have timestamps, since they come by default. To do so, add the following highlighted line to your <code class="email">app/Book.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Book extends Model
{
<span class="strong"><strong class="calibre2">    public $timestamps = false;</strong></span>
}</pre></div><p class="calibre8">For the <code class="email">BorrowedBook</code> model, we need to specify that it has one book, and it belongs to a user. We also need to specify the fields we will fill once we need to create the object—in this case, <code class="email">book_id</code> and <code class="email">start</code>. Add the following two methods in <code class="email">app/BorrowedBook.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class BorrowedBook extends Model
{
<span class="strong"><strong class="calibre2">    protected $fillable = ['user_id', 'book_id', 'start'];</strong></span>
<span class="strong"><strong class="calibre2">    public $timestamps = false;</strong></span>

<span class="strong"><strong class="calibre2">    public function user() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;belongsTo('App\User');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

<span class="strong"><strong class="calibre2">    public function book() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;hasOne('App\Book');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">Sales can have<a id="id824" class="calibre1"/> many "sale books" (we know it might sound a little awkward), and they also belong to just one user. Add the following to your <code class="email">app/Sale.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Sale extends Model
{
<span class="strong"><strong class="calibre2">    protected $fillable = ['user_id'];</strong></span>

<span class="strong"><strong class="calibre2">    public function books() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;hasMany('App\SalesBook');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

<span class="strong"><strong class="calibre2">    public function user() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;belongsTo('App\User');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">Like borrowed books, sale books can have one book and belong to one sale instead of to one user. The following lines should be added to <code class="email">app/SalesBook.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class SaleBook extends Model
{
<span class="strong"><strong class="calibre2">    public $timestamps = false;</strong></span>
<span class="strong"><strong class="calibre2">    protected $fillable = ['book_id', 'sale_id', 'amount'];</strong></span>

<span class="strong"><strong class="calibre2">    public function sale() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;belongsTo('App\Sale');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

<span class="strong"><strong class="calibre2">    public function books() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;hasOne('App\Book');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">Finally, the last model that we need to update is the <code class="email">User</code> model. We need to add the opposite relationship to the <code class="email">belongs</code> we used earlier in <code class="email">Sale</code> and <code class="email">BorrowedBook</code>. Add these two functions, and<a id="id825" class="calibre1"/> leave the rest of the class intact:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App;

use Illuminate\Foundation\Auth\User as Authenticatable;

class User extends Authenticatable
{
    //...

<span class="strong"><strong class="calibre2">    public function sales() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;hasMany('App\Sale');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

<span class="strong"><strong class="calibre2">    public function borrowedBooks() {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;hasMany('App\BorrowedBook');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div></div></div>

<div class="book" title="Creating a REST API with Laravel">
<div class="book" title="Designing endpoints"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec162" class="calibre1"/>Designing endpoints</h2></div></div></div><p class="calibre8">In this section, we <a id="id826" class="calibre1"/>need to come up with the list of endpoints that we want to expose to the REST API clients. Keep in mind the "rules" explained in the <span class="strong"><em class="calibre12">Best practices with REST APIs</em></span> section. In short, keep the following rules in mind:</p><div class="book"><ul class="itemizedlist"><li class="listitem">One endpoint interacts with one resource</li><li class="listitem">A possible schema could be <code class="email">&lt;API version&gt;/&lt;resource name&gt;/&lt;optional id&gt;/&lt;optional action&gt;</code></li><li class="listitem">Use GET parameters for filtering and pagination</li></ul></div><p class="calibre8">So what will the user need to do? We already have a good idea about that, since we created the UI. A brief summary would be as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">List all the available books with some filtering (by title and author), and paginated when necessary. Also retrieve the information on a specific book, given the ID.</li><li class="listitem">Allow the user to borrow a specific book if available. In the same way, the user should be able to return books, and list the history of borrowed books too (filtered by date and paginated).</li><li class="listitem">Allow the user to buy a list of books. This could be improved, but for now let's force the user to buy books with just one request, including the full list of books in the body. Also, list the sales of the user following the same rules as that with borrowed books.</li></ul></div><p class="calibre8">We will start straightaway with our list of endpoints, specifying the path, the HTTP method, and the optional<a id="id827" class="calibre1"/> parameters. It will also give you an idea on how to document your REST APIs.</p><div class="book"><ul class="itemizedlist"><li class="listitem">GET <code class="email">/books</code><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">title</code>: Optional and filters by title</li><li class="listitem"><code class="email">author</code>: Optional and filters by author</li><li class="listitem"><code class="email">page</code>: Optional, default is 1, and specifies the page to return</li><li class="listitem"><code class="email">page-size</code>: Optional, default is 50, and specifies the page size to return</li></ul></div></li><li class="listitem">GET <code class="email">/books/&lt;book id&gt;</code></li><li class="listitem">POST <code class="email">/borrowed-books</code><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">book-id</code>: Mandatory and specifies the ID of the book to borrow</li></ul></div></li><li class="listitem">GET <code class="email">/borrowed-books</code><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">from</code>: Optional and returns borrowed books from the specified date</li><li class="listitem"><code class="email">page</code>: Optional, default is 1, and specifies the page to return</li><li class="listitem"><code class="email">page-size</code>: Optional, default is 50, and specifies the number of borrowed books per page</li></ul></div></li><li class="listitem">PUT <code class="email">/borrowed-books/&lt;borrowed book id&gt;/return</code></li><li class="listitem">POST <code class="email">/sales</code><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">books</code>: Mandatory and it is an array listing the book IDs to buy and their amounts, that is, <span class="strong"><em class="calibre12">{"book-id-1": amount, "book-id-2": amount, ...}</em></span></li></ul></div></li><li class="listitem">GET <code class="email">/sales</code><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">from</code>: Optional and returns borrowed books from the specified date</li><li class="listitem"><code class="email">page</code>: Optional, default is 1, and specifies the page to return</li><li class="listitem"><code class="email">page-size</code>: Optional, default is 50, and specifies the number of sales per page</li></ul></div></li><li class="listitem">GET <code class="email">/sales/&lt;sales id&gt;</code></li></ul></div><p class="calibre8">We use POST requests <a id="id828" class="calibre1"/>when creating sales and borrowed books, since we do not know the ID of the resource that we want to create a priori, and posting the same request will create multiple resources. On the other hand, when returning a book, we do know the ID of the borrowed book, and sending the same request multiple times will leave the database in the same state. Let's translate these endpoints to routes in <code class="email">app/Http/routes.php</code>:</p><div class="informalexample"><pre class="programlisting">/*
 * Books endpoints.
 */
Route::get('books', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'BookController@getAll']);
Route::get('books/{id}', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'BookController@get']);
/*
 * Borrowed books endpoints.
 */
Route::post('borrowed-books', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'BorrowedBookController@borrow']);
Route::get('borrowed-books', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'BorrowedBookController@get']);
Route::put('borrowed-books/{id}/return', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'BorrowedBookController@returnBook']);
/*
 * Sales endpoints.
 */
Route::post('sales', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'SalesController@buy]);
Route::get('sales', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'SalesController@getAll']);
Route::get('sales/{id}', ['middleware' =&gt; 'oauth',
    'uses' =&gt; 'SalesController@get']);</pre></div><p class="calibre8">In the preceding code, note how we added the middleware <code class="email">oauth</code> to all the endpoints. This will require the user to provide a valid access token in order to access them.</p></div></div>

<div class="book" title="Creating a REST API with Laravel">
<div class="book" title="Adding the controllers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec163" class="calibre1"/>Adding the controllers</h2></div></div></div><p class="calibre8">From the previous <a id="id829" class="calibre1"/>section, you can imagine that we need to create three controllers: <code class="email">BookController</code>, <code class="email">BorrowedBookController</code>, and <code class="email">SalesController</code>. Let's start with the easiest one: returning the information of a book given the ID. Create the file <code class="email">app/Http/Controllers/BookController.php</code>, and add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Http\Controllers;

use App\Book;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Response;

class BookController extends Controller {

    public function get(string $id): JsonResponse {
        $book = Book::find($id);
    
        if (empty($book)) {
            return new JsonResponse (
                null,
                JsonResponse::HTTP_NOT_FOUND
            );
        }
    
        return response()-&gt;json(['book' =&gt; $book]);
    }
}</pre></div><p class="calibre8">Even though this preceding example is quite easy, it contains most of what we will need for the rest of the endpoints. We try to fetch a book given the ID from the URL, and when not found, we reply with a 404 (not found) empty response—the constant <code class="email">Response::HTTP_NOT_FOUND</code> is 404. In case we have the book, we return it as JSON with <code class="email">response-&gt;json()</code>. Note how we add the seemingly unnecessary key <code class="email">book</code>; it is true that we do not return anything else and, since we ask for the book, the user will know what we are talking about, but as it does not really hurt, it is good to be as explicit as possible.</p><p class="calibre8">Let's test it! You already know how to get an access token—check the <span class="strong"><em class="calibre12">Requesting an access token</em></span> section. So get one, and try to access the following URLs:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">http://localhost/books/0?access_token=12345</code></li><li class="listitem"><code class="email">http://localhost/books/1?access_token=12345</code></li></ul></div><p class="calibre8">Assuming that <code class="email">12345</code> is your access token, that you have a book in the database with ID <code class="email">1</code>, and you do not have a book with ID <code class="email">0</code>, the first URL should return a 404 response, and the second one, a response something similar to the following:</p><div class="informalexample"><pre class="programlisting">{
    "book": {
        "id": 1
        "isbn": "9780882339726"
        "title": "1984"
        "author": "George Orwell"
        "stock": 12
        "price": 7.5
    }
}</pre></div><p class="calibre8">Let's now add the <a id="id830" class="calibre1"/>method to get all the books with filters and pagination. It looks quite verbose, but the logic that we use is quite simple:</p><div class="informalexample"><pre class="programlisting">public function getAll(Request $request): JsonResponse {
    $title = $request-&gt;get('title', '');
    $author = $request-&gt;get('author', '');
    $page = $request-&gt;get('page', 1);
    $pageSize = $request-&gt;get('page-size', 50);

    $books = Book::where('title', 'like', "%$title%")
        -&gt;where('author', 'like', "%$author%")
        -&gt;take($pageSize)
        -&gt;skip(($page - 1) * $pageSize)
        -&gt;get();

    return response()-&gt;json(['books' =&gt; $books]);
}</pre></div><p class="calibre8">We get all the parameters that can come from the request, and set the default values of each one in case the user does not include them (since they are optional). Then, we use the Eloquent ORM to filter by title and author using <code class="email">where()</code>, and limiting the results with <code class="email">take()-&gt;skip()</code>. We return the JSON in the same way we did with the previous method. In this one though, we do not need any extra check; if the query does not return any book, it is not really a problem.</p><p class="calibre8">You can now play with your REST API, sending different requests with different filters. The following are some examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">http://localhost/books?access_token=12345</code></li><li class="listitem"><code class="email">http://localhost/books?access_token=12345&amp;title=19&amp;page-size=1</code></li><li class="listitem"><code class="email">http://localhost/books?access_token=12345&amp;page=2</code></li></ul></div><p class="calibre8">The next controller in the list is <code class="email">BorrowedBookController</code>. We need to add three methods: <code class="email">borrow</code>, <code class="email">get</code>, and <code class="email">returnBook</code>. As you already know how to work with requests, responses, <a id="id831" class="calibre1"/>status codes, and the Eloquent ORM, we will write the entire class straightaway:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Http\Controllers;

use App\Book;
use App\BorrowedBook;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use LucaDegasperi\OAuth2Server\Facades\Authorizer;

class BorrowedBookController extends Controller {

    public function get(): JsonResponse {
        $borrowedBooks = BorrowedBook::where(
            'user_id', '=', Authorizer::getResourceOwnerId()
        )-&gt;get();

        return response()-&gt;json(
            ['borrowed-books' =&gt; $borrowedBooks]
        );
    }

    public function borrow(Request $request): JsonResponse {
        $id = $request-&gt;get('book-id');

        if (empty($id)) {
            return new JsonResponse(
                ['error' =&gt; 'Expecting book-id parameter.'],
                JsonResponse::HTTP_BAD_REQUEST
            );
        }

        $book = Book::find($id);

        if (empty($book)) {
            return new JsonResponse(
                ['error' =&gt; 'Book not found.'],
                JsonResponse::HTTP_BAD_REQUEST
            );
        } else if ($book-&gt;stock &lt; 1) {
            return new JsonResponse(
                ['error' =&gt; 'Not enough stock.'],
                JsonResponse::HTTP_BAD_REQUEST
            );
        }

<span class="strong"><strong class="calibre2">        $book-&gt;stock--;</strong></span>
<span class="strong"><strong class="calibre2">        $book-&gt;save();</strong></span>

<span class="strong"><strong class="calibre2">        $borrowedBook = BorrowedBook::create(</strong></span>
<span class="strong"><strong class="calibre2">            [</strong></span>
<span class="strong"><strong class="calibre2">                'book_id' =&gt; $book-&gt;id,</strong></span>
<span class="strong"><strong class="calibre2">                'start' =&gt; date('Y-m-d H:i:s'),</strong></span>
<span class="strong"><strong class="calibre2">                'user_id' =&gt; Authorizer::getResourceOwnerId()</strong></span>
<span class="strong"><strong class="calibre2">            ]</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>

        return response()-&gt;json(['borrowed-book' =&gt; $borrowedBook]);
    }

    public function returnBook(string $id): JsonResponse {
        $borrowedBook = BorrowedBook::find($id);

        if (empty($borrowedBook)) {
            return new JsonResponse(
                ['error' =&gt; 'Borrowed book not found.'],
                JsonResponse::HTTP_BAD_REQUEST
            );
        }

        $book = Book::find($borrowedBook-&gt;book_id);
        $book-&gt;stock++;
        $book-&gt;save();

        $borrowedBook-&gt;end = date('Y-m-d H:m:s');
        $borrowedBook-&gt;save();

        return response()-&gt;json(['borrowed-book' =&gt; $borrowedBook]);
    }
}</pre></div><p class="calibre8">The only thing to note in the preceding code is how we also update the stock of the book by increasing or decreasing the stock, and invoke the <code class="email">save</code> method to save the changes in the database. We also return the borrowed book object as the response when borrowing a book so that the user can know the borrowed book ID, and use it when querying or returning the book.</p><p class="calibre8">You can test how this set of endpoints works with the following use cases:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Borrow a book. Check that you get a valid response.</li><li class="listitem">Get the list of borrowed books. The one that you just created should be there with a valid starting date and an empty end date.</li><li class="listitem">Get the information of the book you borrowed. The stock should be one less.</li><li class="listitem">Return the book. Fetch the list of borrowed books to check the end date and the returned book to check the stock.</li></ul></div><p class="calibre8">Of course, you can always try to trick the API and ask for books without stock, non-existing borrowed books, and the like. All these edge cases should respond with the correct status codes and error messages.</p><p class="calibre8">We finish this <a id="id832" class="calibre1"/>section, and the REST API, by creating the <code class="email">SalesController</code>. This controller is the one that contains more logic, since creating a sale implies adding entries to the sales books table, prior to checking for enough stock for each one. Add the following code to <code class="email">app/Html/SalesController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Http\Controllers;

use App\Book;
use App\Sale;
use App\SalesBook;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use LucaDegasperi\OAuth2Server\Facades\Authorizer;

class SalesController extends Controller {

    public function get(string $id): JsonResponse {
        $sale = Sale::find($id);

        if (empty($sale)) {
            return new JsonResponse(
                null,
                JsonResponse::HTTP_NOT_FOUND
            );
        }

        $sale-&gt;books = $sale-&gt;books()-&gt;getResults();
        return response()-&gt;json(['sale' =&gt; $sale]);
    }

    public function buy(Request $request): JsonResponse {
        $books = json_decode($request-&gt;get('books'), true);

        if (empty($books) || !is_array($books)) {
            return new JsonResponse(
                ['error' =&gt; 'Books array is malformed.'],
                JsonResponse::HTTP_BAD_REQUEST
            );
        }

        $saleBooks = [];
        $bookObjects = [];
        foreach ($books as $bookId =&gt; $amount) {
            $book = Book::find($bookId);
            if (empty($book) || $book-&gt;stock &lt; $amount) {
                return new JsonResponse(
                    ['error' =&gt; "Book $bookId not valid."],
                    JsonResponse::HTTP_BAD_REQUEST
                );
            }

            $bookObjects[] = $book;
            $saleBooks[] = [
                'book_id' =&gt; $bookId,
                'amount' =&gt; $amount
            ];
        }

        $sale = Sale::create(
            ['user_id' =&gt; Authorizer::getResourceOwnerId()]
        );
        foreach ($bookObjects as $key =&gt; $book) {
            $book-&gt;stock -= $saleBooks[$key]['amount'];

            $saleBooks[$key]['sale_id'] = $sale-&gt;id;
            SalesBook::create($saleBooks[$key]);
        }

        $sale-&gt;books = $sale-&gt;books()-&gt;getResults();
        return response()-&gt;json(['sale' =&gt; $sale]);
    }

    public function getAll(Request $request): JsonResponse {
        $page = $request-&gt;get('page', 1);
        $pageSize = $request-&gt;get('page-size', 50);

        $sales = Sale::where(
                'user_id', '=', Authorizer::getResourceOwnerId()
             )
            -&gt;take($pageSize)
            -&gt;skip(($page - 1) * $pageSize)
            -&gt;get();

        foreach ($sales as $sale) {
            $sale-&gt;books = $sale-&gt;books()-&gt;getResults();
        }

        return response()-&gt;json(['sales' =&gt; $sales]);
    }
}</pre></div><p class="calibre8">In the preceding<a id="id833" class="calibre1"/> code, note how we first check the availability of all the books before creating the sales entry. This way, we make sure that we do not leave any unfinished sale in the database when returning an error to the user. You could change this, and use transactions instead, and if a book is not valid, just roll back the transaction.</p><p class="calibre8">In order to test this, we can follow similar steps as we did with borrowed books. Just remember that the <code class="email">books</code> parameter, when posting a sale, is a JSON map; for example, <code class="email">{"1": 2, "4": 1}</code> means that I am trying to buy two books with ID <code class="email">1</code> and one book with ID <code class="email">4</code>.</p></div></div>
<div class="book" title="Testing your REST APIs"><div class="book" id="2I0GC2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec80" class="calibre1"/>Testing your REST APIs</h1></div></div></div><p class="calibre8">You<a id="id834" class="calibre1"/> have already been testing your REST API after finishing each controller by making some request and expecting a response. As you might imagine, this can be handy sometimes, but it is for sure not the way to go. Testing should be automatic, and should cover as much as possible. We will have to think of a solution similar to unit testing.</p><p class="calibre8">In <a class="calibre1" title="Chapter 10. Behavioral Testing" href="part0088_split_000.html#2JTHG2-edcc22b134104d5db0bf3aa086c86851">Chapter 10</a>, <span class="strong"><em class="calibre12">Behavioral Testing</em></span>, you will learn more methodologies and tools for testing an application end to end, and that will include REST APIs. However, due to the simplicity of our REST API, we can add some pretty good tests with what Laravel provides us as well. Actually, the idea is very similar to the tests that we wrote in <a class="calibre1" title="Chapter 8. Using Existing PHP Frameworks" href="part0071_split_000.html#23MNU1-edcc22b134104d5db0bf3aa086c86851">Chapter 8</a>, <span class="strong"><em class="calibre12">Using Existing PHP Frameworks</em></span>, where we made a request to some endpoint, and expected a response. The only difference will be in the kind of assertions that we use (which can check if a JSON response is OK), and the way we perform requests.</p><p class="calibre8">Let's add some<a id="id835" class="calibre1"/> tests to the set of endpoints related to books. We need some books in the database in order to query them, so we will have to populate the database before each test, that is, use the <code class="email">setUp</code> method. Remember that in order to leave the database clean of test data, we need to use the trait <code class="email">DatabaseTransactions</code>. Add the following code to <code class="email">tests/BooksTest.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Illuminate\Foundation\Testing\DatabaseTransactions;
use App\Book;

class BooksTest extends TestCase {

    use DatabaseTransactions;

<span class="strong"><strong class="calibre2">    private $books = [];</strong></span>

    public function setUp() {
        parent::setUp();

<span class="strong"><strong class="calibre2">        $this-&gt;addBooks();</strong></span>
    }

    private function addBooks() {
        $this-&gt;books[0] = Book::create(
            [
                'isbn' =&gt; '293842983648273',
                'title' =&gt; 'Iliad',
                'author' =&gt; 'Homer',
                'stock' =&gt; 12,
                'price' =&gt; 7.40
            ]
        );
        $this-&gt;books[0]-&gt;save();
        $this-&gt;books[0] = $this-&gt;books[0]-&gt;fresh();

        $this-&gt;books[1] = Book::create(
            [
                'isbn' =&gt; '9879287342342',
                'title' =&gt; 'Odyssey',
                'author' =&gt; 'Homer',
                'stock' =&gt; 8,
                'price' =&gt; 10.60
            ]
        );
        $this-&gt;books[1]-&gt;save();
        $this-&gt;books[1] = $this-&gt;books[1]-&gt;fresh();

        $this-&gt;books[2] = Book::create(
            [
                'isbn' =&gt; '312312314235324',
                'title' =&gt; 'The Illuminati',
                'author' =&gt; 'Larry Burkett',
                'stock' =&gt; 22,
                'price' =&gt; 5.10
            ]
        );
        $this-&gt;books[2]-&gt;save();
        $this-&gt;books[2] = $this-&gt;books[2]-&gt;fresh();
    }
}</pre></div><p class="calibre8">As you can <a id="id836" class="calibre1"/>see in the preceding code, we add three books to the database, and to the class property <code class="email">$books</code> too. We will need them when we want to assert that a response is valid. Also note the use of the <code class="email">fresh</code> method; this method synchronizes the model that we have with the content in the database. We need to do this in order to get the ID inserted in the database, since we do not know it a priori.</p><p class="calibre8">There is another thing we need to do before we run each test: authenticating our client. We will need to make a POST request to the access token generation endpoint sending valid credentials, and storing the access token that we receive so that it can be used in the remaining requests. You are free to choose how to provide the credentials, since there are different ways to do it. In our case, we just provide the credentials of a client test that we know exists in the database, but you might prefer to insert that client into the database each time. Update the test with the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Illuminate\Foundation\Testing\DatabaseTransactions;
use App\Book;

class BooksTest extends TestCase {

    use DatabaseTransactions;

    private $books = [];
<span class="strong"><strong class="calibre2">    private $accessToken;</strong></span>

    public function setUp() {
        parent::setUp();

        $this-&gt;addBooks();
<span class="strong"><strong class="calibre2">        $this-&gt;authenticate();</strong></span>
    }

    //...

<span class="strong"><strong class="calibre2">    private function authenticate() {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;post(</strong></span>
<span class="strong"><strong class="calibre2">            'oauth/access_token',</strong></span>
<span class="strong"><strong class="calibre2">            [</strong></span>
<span class="strong"><strong class="calibre2">                'client_id' =&gt; 'iTh4Mzl0EAPn90sK4EhAmVEXS',</strong></span>
<span class="strong"><strong class="calibre2">                'client_secret' =&gt; 'PfoWM9yq4Bh6rhr8oDDsNZM',</strong></span>
<span class="strong"><strong class="calibre2">                'grant_type' =&gt; 'client_credentials'</strong></span>
<span class="strong"><strong class="calibre2">            ]</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
<span class="strong"><strong class="calibre2">        $response = json_decode(</strong></span>
<span class="strong"><strong class="calibre2">            $this-&gt;response-&gt;getContent(), true</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;accessToken = $response['access_token'];</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">In the preceding code, we use the <code class="email">post</code> method in order to send a POST request. This method accepts a <a id="id837" class="calibre1"/>string with the endpoint, and an array with the parameters to be included. After making a request, Laravel saves the response object into the <code class="email">$response</code> property. We can JSON-decode it, and extract the access token that we need.</p><p class="calibre8">It is time to add some tests. Let's start with an easy one: requesting a book given an ID. The ID is used to make the GET requests with the ID of the book (do not forget the access token), and check if the response matches the expected one. Remember that we have the <code class="email">$books</code> array already, so it will be pretty easy to perform these checks.</p><p class="calibre8">We will be using two assertions: <code class="email">seeJson</code>, which compares the received JSON response with the one that we provide, and <code class="email">assertResponseOk</code>, which you already know from previous tests—it just checks that the response has a 200 status code. Add this test to the class:</p><div class="informalexample"><pre class="programlisting">public function testGetBook() {
    $expectedResponse = [
        'book' =&gt; json_decode($this-&gt;books[1], true)
    ];
    $url = 'books/' . $this-&gt;books[1]-&gt;id
        . '?' . $this-&gt;getCredentials();

    $this-&gt;get($url)
        -&gt;seeJson($expectedResponse)
        -&gt;assertResponseOk();
}

private function getCredentials(): string {
    return 'grant_access=client_credentials&amp;access_token='
        . $this-&gt;accessToken;
}</pre></div><p class="calibre8">We use the <code class="email">get</code> method instead of <code class="email">post</code>, since this is a GET request. Also note that we use the <code class="email">getCredentials</code> helper, since we will have to use it in each test. To see another example, let's add a test that checks the response when requesting the books that contain the given title:</p><div class="informalexample"><pre class="programlisting">public function testGetBooksByTitle() {
    $expectedResponse = [
        'books' =&gt; [
            json_decode($this-&gt;books[0], true),
            json_decode($this-&gt;books[2], true)
        ]
    ];

    $url = 'books/?title=Il&amp;' . $this-&gt;getCredentials();
    $this-&gt;get($url)
        -&gt;seeJson($expectedResponse)
        -&gt;assertResponseOk();
}</pre></div><p class="calibre8">The preceding test is <a id="id838" class="calibre1"/>pretty much the same as the previous one, isn't it? The only changes are the endpoint and the expected response. Well, the remaining tests will all follow the same pattern, since so far, we can only fetch books and filter them.</p><p class="calibre8">To see something different, let's check how to test an endpoint that creates resources. There are different options, one of them being to first make the request, and then going to the database to check that the resource has been created. Another option, the one that we prefer, is to first send the request that creates the resource, and then, with the information in the response, send a request to fetch the newly created resource. This is preferable, since we are testing only the REST API, and we do not need to know the specific schema that the database is using. Also, if the REST API changes its database, the tests will keep passing—and they should—since we test through the interface only.</p><p class="calibre8">One good example could be borrowing a book. The test should first send a POST in order to borrow the book, specifying the book ID, then extract the borrowed book ID from the response, and finally send <a id="id839" class="calibre1"/>a GET request asking for that borrowed book. To save time, you can add the following test to the already existing <code class="email">tests/BooksTest.php</code>:</p><div class="informalexample"><pre class="programlisting">public function testBorrowBook() {
    $params = ['book-id' =&gt; $this-&gt;books[1]-&gt;id];
    $params = array_merge($params, $this-&gt;postCredentials());

    $this-&gt;post('borrowed-books', $params)
        -&gt;seeJsonContains(['book_id' =&gt; $this-&gt;books[1]-&gt;id])
        -&gt;assertResponseOk();

    $response = json_decode($this-&gt;response-&gt;getContent(), true);

    $url = 'borrowed-books' . '?' . $this-&gt;getCredentials();
    $this-&gt;get($url)
        -&gt;seeJsonContains(['id' =&gt; $response['borrowed-book']['id']])
        -&gt;assertResponseOk();
}

private function postCredentials(): array {
    return [
        'grant_access' =&gt; 'client_credentials',
        'access_token' =&gt; $this-&gt;accessToken
    ];
}</pre></div></div>
<div class="book" title="Summary" id="2IV0U1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec81" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned the importance of REST APIs in the web world. Now you are able not only to use them, but also write your own REST APIs, which has turned you into a more resourceful developer. You can also integrate your applications with third-party APIs to give more features to your users, and for making your websites more interesting and useful.</p><p class="calibre8">In the next and last chapter, we will end this book discovering a type of testing other than unit testing: behavioral testing, which improves the quality and reliability of your web applications.</p></div></body></html>