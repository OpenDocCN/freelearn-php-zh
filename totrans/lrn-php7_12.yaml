- en: Chapter 10. Behavioral Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 行为测试
- en: In [Chapter 7](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851
    "Chapter 7. Testing Web Applications"), *Testing Web Applications*, you learned
    how to write unit tests in order to test small pieces of code in an isolated way.
    Even though this is a must, it is not enough alone to make sure your application
    works as it should. The scope of your test could be so small that even though
    the algorithm that you test makes sense, it would not be what the business asked
    you to create.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851 "第7章.
    测试网络应用")中，*测试网络应用*，你学习了如何编写单元测试以独立方式测试代码的小片段。尽管这是必须的，但仅靠它并不能确保你的应用按预期工作。你的测试范围可能非常小，即使你测试的算法是有意义的，它也可能不是业务要求你创建的内容。
- en: Acceptance tests were born in order to add this level of security to the business
    side, complementing the already existing unit tests. In the same way, BDD originated
    from TDD in order to write code based on these acceptance tests in an attempt
    to involve business and managers in the development process. As PHP is one of
    the favorite languages of web developers, it is just natural to find powerful
    tools to implement BDD in your projects. You will be positively surprised by what
    you can do with **Behat** and **Mink**, the two most popular BDD frameworks at
    the moment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给业务方面增加这一级别的安全性，接受测试应运而生，以补充已经存在的单元测试。同样，BDD（行为驱动开发）起源于TDD（测试驱动开发），目的是基于这些接受测试编写代码，试图让业务和经理们参与到开发过程中。由于PHP是网络开发者的最爱之一，因此找到强大的工具来实现BDD项目是顺理成章的。你将会对**Behat**和**Mink**这两个目前最受欢迎的BDD框架所能做到的事情感到惊喜。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解：
- en: Acceptance tests and BDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试和BDD
- en: Writing features with Gherkin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gherkin编写特性
- en: Implementing and running tests with Behat
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Behat实现和运行测试
- en: Writing tests against browsers with Mink
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mink针对浏览器编写测试
- en: Behavior-driven development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: We already exposed in [Chapter 7](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851
    "Chapter 7. Testing Web Applications"), *Testing Web Applications*, the different
    tools we can use in order to make our applications bug-free, such as automated
    tests. We described what unit tests are and how they can help us achieve our goals,
    but this is far from enough. In this section, we will describe the process of
    creating a real-world application, how unit tests are not enough, and what other
    techniques we can include in this life cycle in order to succeed in our task—in
    this case, behavioral tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第7章](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851 "第7章.
    测试网络应用")中，*测试网络应用*，介绍了我们可以用来使我们的应用无bug的工具，例如自动化测试。我们描述了单元测试是什么以及它们如何帮助我们实现目标，但这远远不够。在本节中，我们将描述创建真实世界应用的过程，单元测试为何不足，以及我们可以在这一生命周期中包含哪些其他技术来成功完成任务——在这种情况下，行为测试。
- en: Introducing continuous integration
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍持续集成
- en: 'There is a huge difference between developing a small web application by yourself
    and being part of a big team of developers, managers, marketing people, and so
    on, that works around the same big web application. Working on an application
    used by thousands or millions of users has a clear risk: if you mess it up, there
    will be a huge number of unhappy affected users, which may translate into sales
    going down, partnerships terminated, and so on.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自己开发一个小型网络应用和成为由开发者、经理、市场营销人员等组成的大团队的一员，共同围绕同一个大型网络应用工作，这两者之间存在着巨大的差异。为成千上万的或数百万用户使用的应用工作具有明显的风险：如果你搞砸了，会有大量的不满意的受影响用户，这可能导致销售额下降、合作伙伴关系终止等。
- en: From this scenario, you can imagine that people would be scared when they have
    to change anything in production. Before doing so, they will make sure that everything
    works perfectly fine. For this reason, there is always a heavy process around
    all the changes affecting a web application in production, including loads of
    tests of all kinds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个场景中，你可以想象，当人们不得不在生产环境中进行任何更改时，他们会感到害怕。在这样做之前，他们会确保一切运行得非常完美。因此，所有影响生产中网络应用的变化都伴随着一个繁重的过程，包括大量的各种测试。
- en: Some think that by reducing the number of times they deploy to production, they
    can reduce the risk of failure, which ends up with them having releases every
    several months with an uncountable number of changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，通过减少他们部署到生产环境的次数，可以降低失败的风险，最终导致他们每隔几个月发布一次，其中包含无数的变化。
- en: 'Now, imagine releasing the result of two or three months of code changes at
    once and something mysteriously fails in production: do you know where to even
    start looking for the cause of the problem? What if your team is good enough to
    make perfect releases, but the end result is not what the market needs? You might
    end up wasting months of work!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下一次性发布两三个月的代码更改结果，但在生产中神秘地失败了：你知道从哪里开始寻找问题的原因吗？如果你的团队能够做出完美的发布，但最终结果并不是市场需要的，你可能会浪费几个月的工作！
- en: 'Even though there are different approaches and not all companies use them,
    let''s try to describe one of the most famous ones from the last few years: **continuous
    integration** (**CI**). The idea is to integrate small pieces of work often rather
    than big ones every once in a while. Of course, releasing is still a constraint
    in your system, which means that it takes a lot of time and resources. CI tries
    to automatize this process as much as possible, reducing the amount of time and
    resources that you need to invest. There are huge benefits with this approach,
    which are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有不同方法，并不是所有公司都使用它们，但让我们尝试描述过去几年中最著名的一种：**持续集成**（**CI**）。这个想法是经常集成小块工作，而不是偶尔集成大块工作。当然，发布仍然是系统中的约束，这意味着它需要大量的时间和资源。CI试图尽可能自动化这个过程，减少你需要投入的时间和资源。这种方法有很多好处，如下所述：
- en: Releases do not take forever to be done, and there isn't an entire team focused
    on releasing as this is done automatically.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布并不需要很长时间，而且没有整个团队专注于发布，因为这是自动完成的。
- en: You can release changes one by one as they come. If something fails, you know
    exactly what the change was and where to start looking for the error. You can
    even revert the changes easily if you need to.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以逐个发布更改。如果有什么失败，你知道确切的变化是什么以及从哪里开始查找错误。如果你需要，甚至可以轻松地撤销更改。
- en: As you release so often, you can get quick feedback from everyone. You will
    be able to change your plans in time if you need to instead of waiting for months
    to get any feedback and wasting all the effort you put on this release.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你发布得如此频繁，你可以从每个人那里快速获得反馈。如果你需要，你可以及时更改你的计划，而不是等待几个月才能获得任何反馈，浪费你在这个发布上所付出的所有努力。
- en: 'The idea seems perfect, but how do we implement it? First, let''s focus on
    the manual part of the process: developing the features using a **version control
    system** (**VCS**). The following diagram shows a very common approach:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法看起来很完美，但我们如何实施它呢？首先，让我们关注这个过程的手动部分：使用**版本控制系统**（**VCS**）开发功能。以下图表展示了一种非常常见的方法：
- en: '![Introducing continuous integration](img/00047.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍持续集成](img/00047.jpeg)'
- en: 'As we already mentioned, a VCS allows developers to work on the same codebase,
    tracking all the changes that everyone makes and helping on the resolution of
    conflicts. A VCS usually allows you to have different branches; that is, you can
    diverge from the main line of development and continue to do work without messing
    with it. The previous graph shows you how to use branches to write new features
    and can be explained as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，版本控制系统（VCS）允许开发者对同一代码库进行工作，跟踪每个人所做的所有更改，并帮助解决冲突。VCS通常允许你拥有不同的分支；也就是说，你可以从主开发线分叉出来，继续工作而不会干扰它。之前的图表展示了如何使用分支来编写新功能，可以解释如下：
- en: '**A**: A team needs to start working on feature A. They create a new branch
    from the master, in which they will add all the changes for this feature.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：一个团队需要开始工作在功能A上。他们从master创建一个新的分支，在这个分支中，他们将添加这个功能的全部更改。'
- en: '**B**: A different team also needs to start working on a feature. They create
    a new branch from master, same as before. At this point, they are not aware of
    what the first team is doing as they do it on their own branch.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**：另一个团队也需要开始工作在一个功能上。他们从master创建一个新的分支，就像之前一样。此时，他们并没有意识到第一个团队正在做什么，因为他们是在自己的分支上做的。'
- en: '**C**: The second team finishes their job. No one else changed master, so they
    can merge their changes straight away. At this point, the CI process will start
    the release process.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：第二个团队完成了他们的工作。没有其他人更改master，所以他们可以立即合并他们的更改。此时，CI过程将启动发布过程。'
- en: '**D**: The first team finishes the feature. In order to merge it to master,
    they need to first rebase their branch with the new changes of master and solve
    any conflicts that might take place. The older the branch is the more chances
    of getting conflicts you will have, so you can imagine that smaller and faster
    features are preferred.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 第一个团队完成了功能。为了将其合并到主分支，他们需要首先将他们的分支与主分支的新更改进行rebase，并解决可能出现的任何冲突。分支越老，你遇到冲突的机会就越大，所以你可以想象，更小、更快的功能更受欢迎。'
- en: 'Now, let''s take a look at how the automated side of the process looks. The
    following graph shows you all the steps from the merging into master to production
    deployment:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个过程自动化的部分是如何的。以下图表显示了从合并到主分支到生产部署的所有步骤：
- en: '![Introducing continuous integration](img/00048.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![介绍持续集成](img/00048.jpeg)'
- en: Until you merge your code into master, you are in the development environment.
    The CI tool will listen to all the changes on the master branch of your project,
    and for each of them, it will trigger a job. This job will take care of building
    the project if necessary and then run all the tests. If there is any error or
    test failure, it will let everyone now, and the team that triggered this job should
    take care of fixing it. The master branch is considered unstable at this point.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将代码合并到主分支之前，你处于开发环境。CI工具将监听你项目主分支上的所有更改，并对每个更改触发一个作业。这个作业将负责在必要时构建项目，然后运行所有测试。如果有任何错误或测试失败，它将通知每个人，触发此作业的团队应该负责修复它。此时，主分支被认为是不可靠的。
- en: If all tests pass, the CI tool will deploy your code into staging. Staging is
    an environment that emulates production as much as possible; that is, it has the
    same server configuration, database structure, and so on. Once the application
    is here, you can run all the tests that you need until you are confident to continue
    the deployment to production. As you make small changes, you do not need to manually
    test absolutely everything. Instead, you can test your changes and the main use
    cases of your application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有测试都通过，CI工具将部署你的代码到预发布环境。预发布环境尽可能地模拟生产环境；也就是说，它有相同的服务器配置、数据库结构等等。一旦应用程序在这里，你就可以运行所有需要的测试，直到你确信可以继续部署到生产环境。随着你进行小的更改，你不需要手动测试所有内容。相反，你可以测试你的更改和应用程序的主要用例。
- en: Unit tests versus acceptance tests
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试与验收测试
- en: We said that the goal of CI is to have a process as automatized as possible.
    However, we still need to manually test the application in staging, right? Acceptance
    tests to the rescue!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，CI的目标是尽可能自动化流程。然而，我们仍然需要在预发布环境中手动测试应用程序，对吧？验收测试来拯救！
- en: Writing unit tests is nice and a must, but they test only small pieces of code
    in an isolated way. Even if your entire unit tests suite passes, you cannot be
    sure that your application works at all as you might not integrate all the parts
    properly because you are missing functionalities or the functionalities that you
    built were not what the business needed. Acceptance tests test the entire flow
    of a specific use case.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试很好，也是必须的，但它们只是以隔离的方式测试代码的小部分。即使你的整个单元测试套件都通过了，你也不能确定你的应用程序是否真的工作，因为你可能没有正确地整合所有部分，因为你缺少功能，或者你构建的功能并不是业务需要的。验收测试测试特定用例的整个流程。
- en: If your application is a website, acceptance tests will probably launch a browser
    and emulate user actions, such as clicking and typing, in order to assert that
    the page returns what is expected. Yes, from a few lines of code, you can execute
    all the tests that were previously manual in an automated way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是一个网站，验收测试可能会启动一个浏览器并模拟用户操作，例如点击和输入，以断言页面返回预期的结果。是的，从几行代码中，你可以以自动化的方式执行之前手动进行的所有测试。
- en: Now, imagine that you wrote acceptance tests for all the features of your application.
    Once the code is in staging, the CI tool can automatically run all of these tests
    and make sure that the new code does not break any existing functionality. You
    can even run them using as many different browsers as you need to make sure that
    your application works fine in all of them. If a test fails, the CI tool will
    notify the team responsible, and they will have to fix it. If all the tests pass,
    the CI tool can automatically deploy your code into production.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你为应用程序的所有功能编写了验收测试。一旦代码进入预发布环境，CI工具可以自动运行所有这些测试，并确保新代码不会破坏任何现有功能。你甚至可以使用你需要的任何数量的不同浏览器来运行它们，以确保你的应用程序在所有浏览器中都能正常工作。如果测试失败，CI工具将通知负责的团队，他们必须修复它。如果所有测试都通过，CI工具可以自动将你的代码部署到生产环境。
- en: Why do we need to write unit tests then, if acceptance tests test what the business
    really cares about? There are several reasons to keep both acceptance and unit
    tests; in fact, you should have way more unit tests than acceptance tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验收测试测试的是业务真正关心的内容，那么我们为什么还需要编写单元测试呢？保持验收测试和单元测试都有几个原因；实际上，你应该有比验收测试多得多的单元测试。
- en: Unit tests check small pieces of code, which make them orders-of-magnitude faster
    than acceptance tests, which test the whole flow against a browser. That means
    that you can run all your unit tests in a few seconds or minutes, but it will
    take much longer to run all your acceptance tests.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试检查代码的小片段，这使得它们比验收测试快几个数量级，验收测试是对浏览器进行整个流程的测试。这意味着你可以用几秒钟或几分钟的时间运行所有的单元测试，但运行所有的验收测试将需要更长的时间。
- en: Writing acceptance tests that cover absolutely all the possible combinations
    of use cases is virtually impossible. Writing unit tests that cover a high percentage
    of use cases for a given method or piece of code is rather easy. You should have
    loads of unit tests testing as many edge cases as possible but only some acceptance
    tests testing the main use cases.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写覆盖所有可能用例组合的验收测试几乎是不可能的。编写覆盖特定方法或代码片段的高比例用例的单元测试相对容易。你应该有大量的单元测试，尽可能多地测试边缘情况，但只有一些验收测试测试主要用例。
- en: When should you run each type of test then? As unit tests are faster, they should
    be executed during the first stages of deployment. Only once we know that they
    all have passed do we want to spend time deploying to staging and running acceptance
    tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么何时应该运行每种类型的测试呢？由于单元测试运行速度更快，它们应该在部署的第一阶段执行。只有当我们知道它们都通过后，我们才愿意花费时间部署到预发布环境并运行验收测试。
- en: TDD versus BDD
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD与BDD
- en: In [Chapter 7](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851
    "Chapter 7. Testing Web Applications"), *Testing Web Applications*, you learned
    that TDD or test-driven development is the practice of writing first the unit
    tests and then the code in an attempt to write testable and cleaner code and to
    make sure that your test suite is always up to date. With the appearance of acceptance
    tests, TDD evolved to BDD or behavior-driven development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851 "第7章。测试Web应用程序")《测试Web应用程序》中，你学习了TDD或测试驱动开发是首先编写单元测试然后编写代码的实践，目的是编写可测试和更干净的代码，并确保你的测试套件始终保持最新。随着验收测试的出现，TDD演变为BDD或行为驱动开发。
- en: BDD is quite similar to TDD, in that you should write the tests first and then
    the code that makes these tests pass. The only difference is that with BDD, we
    write tests that specify the desired behavior of the code, which can be translated
    to acceptance tests. Even though it will always depend on the situation, you should
    write acceptance tests that test a very specific part of the application rather
    than long use cases that contain several steps. With BDD, as with TDD, you want
    to get quick feedback, and if you write a broad test, you will have to write a
    lot of code in order to make it pass, which is not the goal that BDD wants to
    achieve.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: BDD与TDD非常相似，因为你应该先编写测试，然后编写使这些测试通过的代码。唯一的区别是，在BDD中，我们编写指定代码期望行为的测试，这些测试可以转化为验收测试。尽管这始终取决于具体情况，但你应该编写测试验收测试，测试应用程序的非常具体的一部分，而不是包含多个步骤的长用例。与TDD一样，使用BDD，你希望得到快速的反馈，如果你编写了一个广泛的测试，你将不得不编写大量的代码才能使其通过，这不是BDD想要实现的目标。
- en: Business writing tests
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写业务测试
- en: 'The whole point of acceptance tests and BDD is to make sure that your application
    works as expected, not only your code. Acceptance tests, then, should not be written
    by developers but by the business itself. Of course, you cannot expect that managers
    and executives will learn how to code in order to create acceptance tests, but
    there is a bunch of tools that allow you to translate plain English instructions
    or **behavioral specifications** into acceptance tests'' code. Of course, these
    instructions have to follow some patterns. Behavioral specifications have the
    following parts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试和BDD的整个目的是确保您的应用程序按预期工作，而不仅仅是您的代码。因此，验收测试不应由开发者编写，而应由业务本身编写。当然，您不能期望经理和主管学习如何编码以创建验收测试，但有一系列工具允许您将简单的英语指令或**行为规范**转换为验收测试的代码。当然，这些指令必须遵循某些模式。行为规范有以下部分：
- en: A title, which describes briefly, but in a very clear way, what use case the
    behavioral specification covers.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，简要但非常清晰地描述了行为规范覆盖的用例。
- en: 'A narrative, which specifies who performs the test, what the business value
    is, and what the expected outcome is. Usually the format of the narrative is the
    following:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个叙事，它具体说明了谁执行测试，业务价值是什么，以及预期的结果是什么。通常叙事的格式如下：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A set of scenarios, which is a description and a set of steps of each specific
    use case that we want to cover. Each scenario has a description and a list of
    instructions in the `Given`-`When`-`Then` format; we will discuss more on this
    in the next section. A common patterns is:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组场景，它描述了我们想要覆盖的每个特定用例的描述和步骤。每个场景都有一个描述和一系列在 `Given`-`When`-`Then` 格式下的指令；我们将在下一节中对此进行更多讨论。一个常见的模式是：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next two sections, we will discover two tools in PHP that you can use
    in order to understand behavioral scenarios and run them as acceptance tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将发现两个 PHP 工具，您可以使用它们来理解行为场景并将它们作为验收测试运行。
- en: BDD with Behat
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Behat 进行 BDD
- en: The first of the tools we will introduce is Behat. Behat is a PHP framework
    that can transform behavioral scenarios into acceptance tests and then run them,
    providing feedback similar to PHPUnit. The idea is to match each of the steps
    in English with the scenarios in a PHP function that performs some action or asserts
    some results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一款工具是 Behat。Behat 是一个 PHP 框架，可以将行为场景转换为验收测试，然后运行它们，提供类似于 PHPUnit 的反馈。其理念是将每个步骤在英语中与执行某些操作或断言某些结果的
    PHP 函数中的场景相匹配。
- en: In this section, we will try to add some acceptance tests to our application.
    The application will be a simple database migration script that will allow us
    to keep track of the changes that we will add to our schema. The idea is that
    each time that you want to change your database, you will write the changes on
    a migration file and then execute the script. The application will check what
    was the last migration executed and will perform new ones. We will first write
    the acceptance tests and then introduce the code progressively as BDD suggests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试为我们应用程序添加一些验收测试。该应用程序将是一个简单的数据库迁移脚本，它将允许我们跟踪我们将添加到我们的模式中的更改。想法是每次您想要更改数据库时，您都会在迁移文件上编写更改，然后执行脚本。应用程序将检查最后一次执行的迁移是什么，并将执行新的迁移。我们将首先编写验收测试，然后按照
    BDD 的建议逐步引入代码。
- en: 'In order to install Behat on your development environment, you can use Composer.
    The command is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的开发环境中安装 Behat，您可以使用 Composer。命令如下：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Behat actually does not come with any set of assertion functions, so you will
    have to either implement your own by writing conditionals and throwing exceptions
    or you could integrate any library that provides them. Developers usually choose
    PHPUnit for this as they are already used to its assertions. Add it, then, to
    your project via the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Behat 实际上并不附带任何一组断言函数，因此您必须通过编写条件语句和抛出异常来实现自己的函数，或者您可以集成任何提供这些函数的库。开发者通常选择 PHPUnit
    来完成这项工作，因为他们已经习惯了它的断言。然后，您可以通过以下方式将其添加到项目中：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As with PHPUnit, Behat needs to know where your test suite is located. You
    can either have a configuration file stating this and other configuration options,
    which is similar to the `phpunit.xml` configuration file for PHPUnit, or you could
    follow the conventions that Behat sets and skip the configuration step. If you
    choose the second option, you can let Behat create the folder structure and PHP
    `test` class for you with the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PHPUnit 类似，Behat 需要知道你的测试套件位于何处。你可以有一个配置文件来声明这一点和其他配置选项，这与 PHPUnit 的 `phpunit.xml`
    配置文件类似，或者你可以遵循 Behat 设置的约定并跳过配置步骤。如果你选择第二个选项，你可以使用以下命令让 Behat 为你创建文件夹结构和 PHP `test`
    类：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After running this command, you should have a `features/bootstrap/FeatureContext.php`
    file, which is where you need to add the steps of the PHP functions' matching
    scenarios. More on this shortly, but first, let's find out how to write behavioral
    specifications so that Behat can understand them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该有一个 `features/bootstrap/FeatureContext.php` 文件，这是你需要添加 PHP 函数匹配场景步骤的地方。关于这一点，我们稍后会详细说明，但首先，让我们了解一下如何编写行为规范，以便
    Behat 能够理解它们。
- en: Introducing the Gherkin language
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Gherkin 语言
- en: Gherkin is the language, or rather the format, that behavioral specifications
    have to follow. Using Gherkin naming, each behavioral specification is a **feature**.
    Each feature is added to the `features` directory and should have the `.feature`
    extension. Feature files should start with the `Feature` keyword followed by the
    title and the narrative in the same format that we already mentioned before—that
    is, the *In order to–As a–I need to* structure. In fact, Gherkin will only print
    these lines, but keeping it consistent will help your developers and business
    know what they are trying to achieve.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 是行为规范必须遵循的语言，或者更准确地说，是格式。使用 Gherkin 命名，每个行为规范都是一个 **特性**。每个特性都添加到 `features`
    目录中，并且应该有 `.feature` 扩展名。特性文件应该以 `Feature` 关键字开头，后面跟着标题和叙述，格式与我们之前提到的相同——即 *为了（In
    order to）–作为（As a）–我需要（I need to）* 结构。实际上，Gherkin 只会打印这些行，但保持一致性将有助于你的开发者和业务人员了解他们试图实现的目标。
- en: 'Our application will have two features: one for the setup of our database to
    allow the migrations tool to work, and the other one for the correct behavior
    when adding migrations to the database. Add the following content to the `features/setup.feature`
    file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有两个特性：一个用于设置我们的数据库，以便迁移工具能够工作；另一个用于向数据库添加迁移时的正确行为。将以下内容添加到 `features/setup.feature`
    文件中：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add the following feature definition to the `features/migrations.feature`
    file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下特性定义添加到 `features/migrations.feature` 文件中：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Defining scenarios
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义场景
- en: 'The title and narrative of features does not really do anything more than give
    information to the person who runs the tests. The real work is done in scenarios,
    which are specific use cases with a set of steps to take and some assertions.
    You can add as many scenarios as you need to each feature file as long as they
    represent different use cases of the same feature. For example, for `setup.feature`,
    we can add a couple of scenarios: one where it is the first time that the user
    runs the script, so the application will have to set up the database, and one
    where the user already executed the script previously, so the application does
    not need to go through the setup process.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特性的标题和叙述实际上并没有做更多的事情，只是向运行测试的人提供信息。真正的工作是在场景中完成的，场景是一组特定的用例，包含一系列要执行的步骤和一些断言。只要它们代表同一特性的不同用例，你就可以在每个特性文件中添加任意多的场景。例如，对于
    `setup.feature`，我们可以添加几个场景：一个场景是用户第一次运行脚本，因此应用程序需要设置数据库；另一个场景是用户之前已经执行过脚本，因此应用程序不需要经过设置过程。
- en: As Behat needs to be able to translate the scenarios written in plain English
    to PHP functions, you will have to follow some conventions. In fact, you will
    see that they are very similar to the ones that we already mentioned in the behavioral
    specifications section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Behat 需要将用纯英语编写的场景转换为 PHP 函数，你将不得不遵循一些约定。实际上，你会发现它们与我们已经在行为规范部分提到的是非常相似的。
- en: Writing Given-When-Then test cases
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Given-When-Then 测试用例
- en: 'A scenario must start with the `Scenario` keyword followed by a short description
    of what use case the scenario covers. Then, you need to add the list of steps
    and assertions. Gherkin allows you to use four keywords for this: `Given`, `When`,
    `Then`, and `And`. In fact, they all have the same meaning when it comes to code,
    but they add a lot of semantic value to your scenarios. Let''s consider an example;
    add the following scenario at the end of your `setup.feature` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个场景必须以 `Scenario` 关键词开始，后面跟着对该场景覆盖的用例的简要描述。然后，你需要添加步骤和断言的列表。Gherkin 允许你使用四个关键词来完成这个任务：`Given`、`When`、`Then`
    和 `And`。实际上，当涉及到代码时，它们都有相同的意义，但它们为你的场景添加了很多语义价值。让我们考虑一个例子；在你的 `setup.feature`
    文件末尾添加以下场景：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This scenario tests what happens when we do not have any schema information
    and run the migrations script. First, it describes the state of the scenario:
    *Given I do not have the bdd_db_test schema And I do not have migration files*.
    These two lines will be translated to one method each, which will remove the schema
    and all migration files. Then, the scenario describes what the user will do: *When
    I run the migrations script*. Finally, we set the expectations for this scenario:
    *Then I should have an empty migrations table And I should get Latest version
    applied is 0.*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景测试当我们没有任何模式信息并运行迁移脚本时会发生什么。首先，它描述了场景的状态：*Given 我没有 bdd_db_test 模式 And 我没有迁移文件*。这两行将翻译成每个方法，将删除模式和所有迁移文件。然后，场景描述了用户将执行的操作：*When
    我运行迁移脚本*。最后，我们为这个场景设定期望：*Then 我应该有一个空的迁移表 And 我应该得到已应用最新版本是 0.*。
- en: In general, the same step will always start by the same keyword—that is, *I
    run the migrations script* will always be preceded by `When`. The `And` keyword
    is a special one as it matches all the three keywords; its only purpose is to
    have steps as English-friendly as possible; although if you prefer, you could
    write *Given I do not have migration files*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，相同的步骤总是以相同的关键词开始——也就是说，*我运行迁移脚本* 总是以 `When` 为前缀。`And` 关键词是一个特殊的词，因为它匹配所有三个关键词；它的唯一目的是使步骤尽可能英语友好；尽管如此，如果你愿意，你也可以写
    *Given 我没有迁移文件*。
- en: Another thing to note in this example is the use of arguments as part of the
    step. The line *And I should get* is followed by a string enclosed by `"""`. The
    PHP function will get this string as an argument, so you can have one unique step
    definition—that is, the function—for a wide variety of situations just using different
    strings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，还有一个需要注意的事项是使用参数作为步骤的一部分。*And 我应该得到* 这一行后面跟着一个由 `"""` 包围的字符串。PHP 函数将获取这个字符串作为参数，因此你可以使用一个独特的步骤定义——即函数——来应对各种情况，只需使用不同的字符串即可。
- en: Reusing parts of scenarios
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复使用场景的部分
- en: 'It is quite common that for a given feature, you always start from the same
    scenario. For example, `setup.feature` has a scenario in which we can run the
    migrations for the first time without any migration file, but we will also add
    another scenario in which we want to run the migrations script for the first time
    with some migration files to make sure that it will apply all of them. Both scenarios
    have in common one thing: they do not have the database set up.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个特定的特性，你通常总是从同一个场景开始的情况很常见。例如，`setup.feature` 有一个场景，我们可以运行迁移脚本而没有任何迁移文件，但我们还会添加另一个场景，我们想要运行迁移脚本并带有一些迁移文件，以确保它会应用所有这些文件。这两个场景有一个共同点：它们都没有设置数据库。
- en: 'Gherkin allows you to define some steps that will be applied to all the scenarios
    of the feature. You can use the `Background` keyword and a list of steps, usually
    `Given`. Add these two lines between the `feature` narrative and `scenario` definition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 允许你定义一些步骤，这些步骤将应用于该特性的所有场景。你可以使用 `Background` 关键词和一系列步骤，通常是 `Given`。在
    `feature` 叙述和 `scenario` 定义之间添加这两行：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can remove the first step from the existing scenario as `Background`
    will take care of it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从现有的场景中移除第一个步骤，因为 `Background` 会处理它。
- en: Writing step definitions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写步骤定义
- en: 'So far, we have written features using the Gherkin language, but we still have
    not considered how any of the steps in each scenario is translated to actual code.
    The easiest way to note this is by asking Behat to run the acceptance tests; as
    the steps are not defined anywhere, Behat will print out all the functions that
    you need to add to your `FeatureContext` class. To run the tests, just execute
    the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Gherkin语言编写了特性，但我们还没有考虑每个场景中的任何步骤是如何翻译成实际代码的。最容易的方法是让Behat运行验收测试；由于步骤尚未定义，Behat会打印出你需要添加到`FeatureContext`类中的所有函数。要运行测试，只需执行以下命令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the output that you should get if you have no
    step definitions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如果你没有步骤定义应该得到的输出：
- en: '![Writing step definitions](img/00049.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![编写步骤定义](img/00049.jpeg)'
- en: 'As you can note, Behat complained about some missing steps and then printed
    in yellow the methods that you could use in order to implement them. Copy and
    paste them into your autogenerated `features/bootstrap/FeatureContext.php` file.
    The following `FeatureContext` class has already implemented all of them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，Behat 抱怨了一些缺失的步骤，然后以黄色打印出你可以用来实现它们的方法。将它们复制并粘贴到你的自动生成的`features/bootstrap/FeatureContext.php`文件中。以下`FeatureContext`类已经实现了所有这些：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can note, we read the configuration from the `config/app.json` file.
    This is the same configuration file that the application will use, and it contains
    the database's credentials. We also instantiated a `PDO` object to access the
    database so that we could add or remove tables or take a look at what the script
    did.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们从`config/app.json`文件中读取了配置。这是应用程序将使用的相同配置文件，它包含数据库的凭据。我们还实例化了一个`PDO`对象来访问数据库，以便我们可以添加或删除表，或者查看脚本做了什么。
- en: 'Step definitions are a set of methods with a comment on each of them. This
    comment is an annotation as it starts with `@` and is basically a regular expression
    matching the plain English step defined in the feature. Each of them has its implementation:
    either removing a database or migration files, executing the migrations script,
    or checking what the migrations table contains.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤定义是一组带有注释的方法。这个注释是一个注解，因为它以`@`开头，基本上是一个与在特性中定义的纯英文步骤匹配的正则表达式。每个步骤都有自己的实现：要么删除数据库或迁移文件，要么执行迁移脚本，或者检查迁移表的内容。
- en: The parameterization of steps
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤参数化
- en: 'In the previous `FeatureContext` class, we intentionally missed the `iShouldGet`
    method. As you might recall, this step has a string argument identified by a string
    enclosed between `"""`. The implementation for this method looks as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`FeatureContext`类中，我们故意遗漏了`iShouldGet`方法。正如你可能记得的，这个步骤有一个以`"""`包围的字符串参数。这个方法的实现如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how the regular expression does not contain the string. This happens when
    using long strings with `"""`. Also, the argument is an instance of `PyStringNode`,
    which is a bit more complex than a normal string. However, fear not; when you
    compare it with a string, PHP will look for the `__toString` method, which just
    prints the content of the string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意正则表达式不包含字符串。这发生在使用`"""`的长字符串时。此外，参数是一个`PyStringNode`实例，它比普通字符串复杂一些。然而，不用担心；当你与字符串比较时，PHP会寻找`__toString`方法，它只是打印字符串的内容。
- en: Running feature tests
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行特性测试
- en: 'In the previous sections, we wrote acceptance tests using Behat, but we have
    not written a single line of code yet. Before running them, though, add the `config/app.json`
    configuration file with the credentials of your database user so that the `FeatureContext`
    constructor can find it, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用Behat编写了验收测试，但我们还没有写一行代码。在运行它们之前，请添加`config/app.json`配置文件，包含你的数据库用户的凭据，以便`FeatureContext`构造函数可以找到它，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s run the acceptance tests, expecting them to fail; otherwise, our
    tests will not be valid at all. The output should be something similar to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行验收测试，预期它们会失败；否则，我们的测试将完全无效。输出应该类似于以下内容：
- en: '![Running feature tests](img/00050.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![运行特性测试](img/00050.jpeg)'
- en: 'As expected, the `Then` steps failed. Let''s implement the minimum code necessary
    in order to make the tests pass. For starters, add the autoloader into your `composer.json`
    file and run `composer update`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Then`步骤失败了。让我们实现必要的最小代码，以便使测试通过。首先，将自动加载器添加到你的`composer.json`文件中，并运行`composer
    update`：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We would like to implement a `Schema` class that contains the helpers necessary
    to set up a database, run migrations, and so on. Right now, the feature is only
    concerned about the setup of the database—that is, creating the database, adding
    the empty migrations table to keep track of all the migrations added, and the
    ability to get the latest migration registered as successful. Add the following
    code as `src/Schema.php`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现一个包含设置数据库、运行迁移等必要辅助函数的`Schema`类。目前，这个特性只关注数据库的设置——也就是说，创建数据库、添加空的迁移表以跟踪所有添加的迁移，以及获取最新已注册为成功的迁移的能力。将以下代码添加为`src/Schema.php`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Even though the focus of this chapter is to write acceptance tests, let''s
    go through the different implemented methods:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的重点是编写验收测试，但让我们回顾一下实现的不同方法：
- en: The constructor and `getConnection` just read the configuration file in `config/app.json`
    and instantiated the `PDO` object.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和`getConnection`只是读取`config/app.json`中的配置文件，并实例化了`PDO`对象。
- en: The `createSchema` executed `CREATE SCHEMA IF NOT EXISTS`, so if the schema
    already exists, it will do nothing. We executed the command with `exec` instead
    of `PDO` as `PDO` always needs to use an existing database.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSchema`执行了`CREATE SCHEMA IF NOT EXISTS`，所以如果模式已经存在，它将不会做任何事情。我们使用`exec`而不是`PDO`来执行命令，因为`PDO`总是需要使用现有的数据库。'
- en: The `getLatestMigration` will first check whether the migrations table exists;
    if not, we will create it using `setup.sql` and then fetch the last successful
    migration.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLatestMigration`将首先检查迁移表是否存在；如果不存在，我们将使用`setup.sql`创建它，然后获取最后一个成功的迁移。'
- en: 'We also need to add the `migrations/setup.sql` file with the query to create
    the migrations table, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加`migrations/setup.sql`文件，其中包含创建迁移表的查询，如下所示：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to add the `migrate.php` file, which is the one that the user
    will execute. This file will get the configuration, instantiate the `Schema` class,
    set up the database, and retrieve the last migration applied. Run the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`migrate.php`文件，这是用户将执行的那个文件。这个文件将获取配置，实例化`Schema`类，设置数据库，并检索最后一个应用的迁移。运行以下代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You are now good to run the tests again. This time, the output should be similar
    to this screenshot, where all the steps are in green:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以再次运行测试了。这次，输出应该类似于这个截图，其中所有步骤都是绿色的：
- en: '![Running feature tests](img/00051.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![运行特性测试](img/00051.jpeg)'
- en: 'Now that our acceptance test is passing, we need to add the rest of the tests.
    To make things quicker, we will add all the scenarios, and then we will implement
    the necessary code to make them pass, but it would be better if you add one scenario
    at a time. The second scenario of `setup.feature` could look as follows (remember
    that the feature contains a `Background` section, in which we clean the database):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的验收测试已经通过，我们需要添加剩余的测试。为了加快速度，我们将添加所有场景，然后我们将实现必要的代码使它们通过，但最好是一次添加一个场景。`setup.feature`的第二个场景可能看起来如下（记住，特性包含一个`Background`部分，其中我们清理数据库）：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This scenario is important as it used parameters inside the step definitions.
    For example, the *I have migration file* step is presented twice, each time with
    a different migration file number. The implementation of this step is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景很重要，因为它在步骤定义中使用了参数。例如，`我有迁移文件`步骤被呈现了两次，每次都使用不同的迁移文件编号。这个步骤的实现如下：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The annotation of this method, which is a regular expression, used `:version`
    as a wildcard. Any step that starts with *Given I have migration file* followed
    by something else will match this step definition, and the "something else" bit
    will be received as the `$version` argument as a string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的注释，它是一个正则表达式，使用了`:version`作为通配符。任何以`Given I have migration file`开头，后面跟其他内容的步骤都将匹配这个步骤定义，而“其他内容”部分将作为字符串接收为`$version`参数。
- en: 'Here, we introduced yet another type of argument: tables. The *Then I should
    only have the following tables* step defined a table of two rows of one column
    each, and the *Then I should have the following migrations* bit sent a table of
    two rows of two columns each. The implementation for the new steps is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了另一种类型的参数：表。`然后我应该只有以下表`步骤定义了一个两行一列的表，而`然后我应该有以下迁移`部分发送了一个两行两列的表。新步骤的实现如下：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The tables are received as `TableNode` arguments. This class contains a `getRows`
    method that returns an array with the rows defined in the feature file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表格作为 `TableNode` 参数接收。此类包含一个 `getRows` 方法，该方法返回在功能文件中定义的行数组。
- en: 'The other feature that we would like to add is `features/migrations.feature`.
    This feature will assume that the user already has the database set up, so we
    will add a `Background` section with this step. We will add one scenario in which
    the migration file numbers are not consecutive, in which case the application
    should stop at the last consecutive migration file. The other scenario will make
    sure that when there is an error, the application does not continue the migration
    process. The feature should look similar to the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加的另一个功能是 `features/migrations.feature`。此功能将假设用户已经设置了数据库，因此我们将添加一个包含此步骤的
    `Background` 部分。我们将添加一个场景，其中迁移文件编号不连续，在这种情况下，应用程序应停止在最后一个连续的迁移文件处。另一个场景将确保当出现错误时，应用程序不会继续迁移过程。该功能应类似于以下内容：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There aren''t any new Gherkin features. The two new step implementations look
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何新的 Gherkin 功能。两个新的步骤实现如下：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, it is time to add the needed implementation to make the tests pass. There
    are only two changes needed. The first one is an `applyMigrationsFrom` method
    in the `Schema` class that, given a version number, will try to apply the migration
    file for this number. If the migration is successful, it will add a row in the
    migrations table, with the new version added successfully. If the migration failed,
    we would add the record in the migrations table as a failure and then throw an
    exception so that the script is aware of it. Finally, if the migration file does
    not exist, the returning value will be `false`. Add this code to the `Schema`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加必要的实现来使测试通过。只需要两个更改。第一个是在 `Schema` 类中的 `applyMigrationsFrom` 方法，它将尝试应用给定版本号的迁移文件。如果迁移成功，它将在迁移表中添加一行，其中包含成功添加的新版本。如果迁移失败，我们将在迁移表中添加一条失败记录，然后抛出异常，以便脚本知道这一点。最后，如果迁移文件不存在，返回值将是
    `false`。将以下代码添加到 `Schema` 类中：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The other bit missing is in the `migrate.php` script. We need to call the newly
    created `applyMigrationsFrom` method with consecutive versions starting from the
    latest one, until we get either a `false` value or an exception. We also want
    to print out information about what is going on so that the user is aware of what
    migrations were added. Add the following code at the end of the `migrate.php`
    script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺失的部分在 `migrate.php` 脚本中。我们需要从最新版本开始调用新创建的 `applyMigrationsFrom` 方法，直到我们得到一个
    `false` 值或异常。我们还想打印出有关正在发生的事情的信息，以便用户了解添加了哪些迁移。在 `migrate.php` 脚本的末尾添加以下代码：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, run the tests and voilà! They all pass. You now have a library that manages
    database migrations, and you are 100% sure that it works thanks to your acceptance
    tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试，voilà！它们都通过了。您现在有一个管理数据库迁移的库，您有 100% 的把握它工作正常，多亏了您的验收测试。
- en: Testing with a browser using Mink
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mink 在浏览器中进行测试
- en: 'So far, we have been able to write acceptance tests for a script, but most
    of you are reading this book in order to write nice and shiny web applications.
    How can you take advantage of acceptance tests then? It is time to introduce the
    second PHP tool of this chapter: Mink.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够为脚本编写验收测试，但你们大多数人阅读这本书是为了编写漂亮且闪亮的网络应用程序。那么，如何利用验收测试呢？现在是时候介绍本章的第二个
    PHP 工具：Mink。
- en: Mink is actually an extension of Behat, which adds implementations of several
    steps related to web browser testing. For example, if you add Mink to your application,
    you will be able to add scenarios where Mink will launch a browser and click or
    type as requested, saving you a lot of time and effort in manual testing. However,
    first, let's take a look at how Mink can achieve this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Mink 实际上是 Behat 的一个扩展，它添加了与网络浏览器测试相关的几个步骤的实现。例如，如果您将 Mink 添加到您的应用程序中，您将能够添加
    Mink 将启动浏览器并按请求进行点击或输入的场景，这将为您节省大量手动测试的时间和精力。然而，首先，让我们看看 Mink 如何实现这一点。
- en: Types of web drivers
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络驱动程序类型
- en: Mink makes use of web drivers—that is, libraries that have an API that allows
    you to interact with a browser. You can send commands, such as *go to this page*,
    *click on this link*, *fill this input field with this text*, and so on, and the
    web driver will translate this into the correct instruction for your browser.
    There are several web drivers, each of them implemented following a different
    approach. It is for this reason that depending on the web driver, you will have
    some features or others.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Mink 使用网络驱动程序——即具有 API 的库，允许你与浏览器交互。你可以发送命令，例如 *转到这个页面*，*点击这个链接*，*用这个文本填充这个输入字段*，等等，网络驱动程序会将这些转换为针对你的浏览器的正确指令。有几个网络驱动程序，每个都采用不同的方法实现。这就是为什么根据网络驱动程序，你将有一些功能或另一些功能。
- en: 'Web drivers can be divided into two groups depending on how they work:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的工作方式，网络驱动程序可以分为两组：
- en: '**Headless browsers**: These drivers do not really launch a browser; they only
    try to emulate one. They actually request for the web page and render the HTML
    and JavaScript code, so they are aware of how the page looks, but they do not
    display it. They have a huge benefit: they are easy to install and manage, and
    as they do not have to build the graphical representation, they are extremely
    fast. The disadvantage is that they have severe restrictions in terms of CSS and
    some JavaScript functionalities, especially AJAX.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无头浏览器**：这些驱动程序实际上并没有启动浏览器；它们只是尝试模拟一个。它们实际上请求网页并渲染 HTML 和 JavaScript 代码，因此它们知道页面看起来如何，但它们不会显示它。它们有一个巨大的好处：它们易于安装和管理，并且由于它们不需要构建图形表示，它们非常快。缺点是它们在
    CSS 和一些 JavaScript 功能方面有严重的限制，尤其是 AJAX。'
- en: '**Web drivers that launch real browsers like a user would do**: These web drivers
    can do almost anything and are way more powerful than headless browsers. The problem
    is that they can be a bit tricky to install and are very, very slow—as slow as
    a real user trying to go through the scenarios.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动真实浏览器的网络驱动程序**：这些网络驱动程序可以做到几乎任何事情，比无头浏览器强大得多。问题是它们可能有点难以安装，并且非常、非常慢——就像一个真实用户试图通过场景一样慢。'
- en: So, which one should you choose? As always, it will depend on what your application
    is. If you have an application that does not make heavy use of CSS and JavaScript
    and it is not critical for your business, you could use headless browsers. Instead,
    if the application is the cornerstone of your business and you need to be absolutely
    certain that all the UI features work as expected, you might want to go for web
    drivers that launch browsers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该选择哪一个呢？像往常一样，这取决于你的应用程序。如果你有一个不大量使用 CSS 和 JavaScript 的应用程序，并且它对你的业务不是至关重要的，你可以使用无头浏览器。相反，如果该应用程序是你的业务基石，你需要绝对确信所有
    UI 功能都能按预期工作，你可能想要选择启动浏览器的网络驱动程序。
- en: Installing Mink with Goutte
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Goutte 安装 Mink
- en: 'In this chapter, we will use **Goutte**, a headless web driver written by the
    same guys that worked on **Symfony**, to add some acceptance tests to the repositories
    page of GitHub. The required components of your project will be Behat, Mink, and
    the Goutte driver. Add them with Composer via the following commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 **Goutte**，这是一个由参与开发 **Symfony** 的同一批人编写的无头网络驱动程序，为 GitHub 的仓库页面添加一些验收测试。你的项目所需的组件将是
    Behat、Mink 和 Goutte 驱动程序。使用以下命令通过 Composer 添加它们：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, execute the following line to ask Behat to create the basic directory
    structure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令以让 Behat 创建基本目录结构：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The only change we will add to the `FeatureContext` class is where it extends
    from. This time, we will use `MinkContext` in order to get all the step definitions
    related to web testing. The `FeatureContext` class should look similar to this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 `FeatureContext` 类所做的唯一更改是它扩展的地方。这次，我们将使用 `MinkContext` 以获取所有与网络测试相关的步骤定义。`FeatureContext`
    类应该看起来像这样：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Mink also needs some configuration in order to let Behat know which web driver
    we want to use or what the base URL for our tests is. Add the following information
    to `behat.yml`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Mink 还需要一些配置，以便让 Behat 知道我们想要使用哪个网络驱动程序或我们的测试的基础 URL 是什么。将以下信息添加到 `behat.yml`
    文件中：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this configuration, we let Behat know that we are using the Mink extension,
    that Mink will use Goutte in all the sessions (you could actually define different
    sessions with different web drivers if necessary), and that the base URL for these
    tests is the GitHub one. Behat is already instructed to look for the `behat.yml`
    file in the same directory that we executed it in, so there is nothing else that
    we need to do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配置，我们让 Behat 知道我们正在使用 Mink 扩展，Mink 将在所有会话中使用 Goutte（如果需要，实际上可以定义具有不同 Web
    驱动的不同会话），并且这些测试的基础 URL 是 GitHub 的。Behat 已经被指示在执行它的同一目录中查找 `behat.yml` 文件，所以我们不需要做任何事情。
- en: Interaction with the browser
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与浏览器的交互
- en: 'Now, let''s look at the magic. If you know the steps to use, writing acceptance
    tests with Mink will be like a game. First, add the following feature in `feature/search.feature`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看魔法。如果你知道如何使用步骤，用 Mink 编写验收测试就像玩游戏一样。首先，在 `feature/search.feature` 中添加以下功能：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first thing to note is that we have a `Background` section. This section
    assumes that the user visited the [https://github.com/picahielos](https://github.com/picahielos)
    page and clicked on the **Repositories** link. Using *I follow* with some string
    is the equivalent of trying to find a link with this string and clicking on it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们有一个 `Background` 部分。这个部分假设用户访问了 [https://github.com/picahielos](https://github.com/picahielos)
    页面并点击了 **Repositories** 链接。使用 *我跟随* 加上一些字符串相当于尝试找到这个字符串的链接并点击它。
- en: The first scenario used the *When I fill <field> with <value>* step, which basically
    tries to find the input field on the page (you can either specify the ID or name),
    and types the value for you. In this case, the `q` field was the search bar, and
    we typed `zap`. Then, similar to when clicking on the links, the *I press <button>*
    line will try to find the button by name, ID, or value, and will click on it.
    Finally, *Then I should see* followed by a string will assert that the given string
    could be found on the page. In short, the test launched a browser, going to the
    specified URL, clicking on the **Repositories** link, searching for the `zap`
    repository, and asserting that it could find it. In a similar way, the second
    scenario tried to find a repository that does not exist.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景使用了 *当我用 <value> 填充 <field>* 步骤，这基本上是尝试在页面上找到输入字段（你可以指定 ID 或名称），并为你输入值。在这种情况下，`q`
    字段是搜索栏，我们输入了 `zap`。然后，类似于点击链接，*我按下 <button>* 行将尝试通过名称、ID 或值找到按钮，并点击它。最后，*然后我应该看到*
    后跟一个字符串将断言可以在页面上找到给定的字符串。简而言之，测试启动了一个浏览器，访问指定的 URL，点击 **Repositories** 链接，搜索 `zap`
    仓库，并断言可以找到它。以类似的方式，第二个场景尝试找到一个不存在的仓库。
- en: If you run the tests, they should pass, but you will not see any browser. Remember
    that Goutte is a headless browser web driver. However, check how fast these tests
    are executed; in my laptop, it took less than 3 seconds! Can you imagine anyone
    performing these two tests manually in less than this time?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试，它们应该通过，但你不会看到任何浏览器。记住，Goutte 是一个无头浏览器 Web 驱动。然而，检查这些测试的执行速度；在我的笔记本电脑上，它不到
    3 秒钟！你能想象有人在这么短的时间内手动执行这两个测试吗？
- en: 'One last thing: having a cheat sheet of predefined Mink steps is one of the
    handiest things to have near your desk; you can find one at [http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf](http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf).
    As you can see, we did not write a single line of code, and we still have two
    tests making sure that the website works as expected. Also, if you need to add
    a fancier step, do not worry; you can still implement your step definitions as
    we did in Behat previously while taking advantage of the web driver''s interface
    that Mink provides. We recommend you to go through the official documentation
    in order to take a look at the complete list of things that you can do with Mink.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：在办公桌附近放一张预定义的 Mink 步骤表是非常方便的事情；你可以在[http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf](http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf)找到一张。正如你所见，我们没有写一行代码，但仍然有两个测试确保网站按预期工作。此外，如果你需要添加更复杂的步骤，不用担心；你仍然可以像
    Behat 之前那样实现你的步骤定义，同时利用 Mink 提供的 Web 驱动接口。我们建议你查阅官方文档，以查看你可以用 Mink 做的所有事情的完整列表。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this concluding chapter, you learned how important it is to coordinate the
    business with the application. For this, you saw what BDD is and how to implement
    it with your PHP web applications using Behat and Mink. This also gives you the
    ability to test the UI with web drivers, which you could not do it with unit tests
    and PHPUnit. Now, you can make sure that not only is your application bug-free
    and secure, but also that it does what the business needs it to do.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的结尾，你学习了协调业务与应用程序的重要性。为此，你了解了BDD是什么以及如何使用Behat和Mink在你的PHP Web应用程序中实现它。这也让你能够使用Web驱动程序测试UI，而这之前你无法使用单元测试和PHPUnit做到。现在，你可以确保你的应用程序不仅没有错误和漏洞，而且能够满足业务需求。
- en: Congratulations on reaching the end of the book! You started as an inexperienced
    developer, but now you are able to write simple and complex websites and REST
    APIs with PHP and have an extensive knowledge of good test practices. You have
    even worked with a couple of famous PHP frameworks, so you are ready to either
    start a new project with them or join a team that uses one of them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这本书的阅读！你开始时是一个没有经验的开发者，但现在你能够用PHP编写简单和复杂的网站以及REST API，并且对良好的测试实践有广泛的知识。你甚至与几个著名的PHP框架合作过，所以你准备好要么用它们开始一个新项目，要么加入使用其中之一的公司。
- en: 'Now, you might be wondering: what do I do next? You already know the theory—well,
    some of it—so we would recommend that you practice a lot. There are several ways
    you can do this: by creating your own application, joining a team working on open
    source projects, or working for a company. Try to keep up to date with new releases
    of the language or the tools and frameworks, discover a new framework from time
    to time, and never stop reading. Expanding your set of skills is always a great
    idea!'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道：接下来我该做什么？你已经了解了理论——好吧，至少是其中的一部分——所以我们建议你大量练习。你可以通过多种方式来做这件事：创建自己的应用程序，加入一个正在从事开源项目的团队，或者为一家公司工作。尽量跟上语言或工具和框架的新版本，时不时地发现一个新的框架，并且永远不要停止阅读。扩展你的技能集总是一个好主意！
- en: 'If you run out of ideas on what to read next, here are some hints. We did not
    go through the frontend part too much, so you might be interested in reading about
    CSS and specially JavaScript. JavaScript has become the main character in these
    last few years, so do not miss it out. If you are rather interested in the backend
    side and how to manage applications properly, try discovering new technologies,
    such as continuous integration tools similar to Jenkins. Finally, if you prefer
    to focus on the theory and "science" side, you can read about how to write quality
    code with *Code Complete*, *Steve McConnell*, or how to make good use of design
    patterns with *Design Patterns: Elements of Reusable Object-Oriented Software*,
    *Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm*, a gang of four.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你对于接下来阅读什么感到没有主意，这里有一些提示。我们没有过多地涉及前端部分，所以你可能对阅读关于CSS和JavaScript的内容感兴趣。在过去的几年中，JavaScript已经成为主角，所以不要错过它。如果你对后端方面以及如何正确管理应用程序更感兴趣，尝试发现新技术，例如类似于Jenkins的持续集成工具。最后，如果你更倾向于关注理论“科学”方面，你可以阅读关于如何用《代码大全》*Code
    Complete*，*Steve McConnell*编写高质量代码，或者如何使用《设计模式：可复用面向对象软件元素》*Design Patterns: Elements
    of Reusable Object-Oriented Software*，*Erich Gamma, John Vlissides, Ralph Johnson,
    and Richard Helm*，四人帮的书籍来有效地利用设计模式。'
- en: Always enjoy and have fun when developing. Always!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，始终享受乐趣并保持愉快。永远都要这样！
