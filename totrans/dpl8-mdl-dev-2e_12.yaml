- en: JavaScript and the Ajax API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we've only talked about topics that can be considered to
    relate to backend development. This means heavy PHP working with the APIs and
    the database, and so on. This is because this book is oriented toward module developers
    rather than "themers". Also, the author of this book is admittedly not a JavaScript,
    or any kind of frontend, developer.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in this chapter we'll switch gears and talk a bit about *frontend
    development*, namely, how to work with JavaScript in a Drupal 8 application. This
    is because there are many things developers can and should be doing in their modules
    that require frontend technologies. There are a few approaches and techniques
    specific to Drupal when it comes to adding and using JavaScript files and we will
    talk about those here. Moreover, we will also prove how powerful Drupal 8 is in
    allowing us to do quite a bit of JavaScript work without actually writing a single
    line of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: So, there are a few things we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will talk about the approach of writing JavaScript in Drupal. You
    already learned in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*,
    how you can create libraries and attach them to render arrays, elements, or pages.
    Basically, using libraries, we can get our JavaScript files loaded when we need.
    I recommend you check out the *Assets and libraries* section from [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, if you don't remember exactly how libraries work. Because in this chapter,
    we will continue from there and talk a bit about what actually goes inside those
    JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: A good resource to keep handy is the documentation page ([https://www.drupal.org/node/172169](https://www.drupal.org/node/172169))
    which lists the coding standards for JavaScript in Drupal 8 that we should abide
    by.
  prefs: []
  type: TYPE_NORMAL
- en: We won't actually write a lot of JavaScript code in the first part—just enough
    to get you started though. In the second part, we will not write any at all. Instead,
    we will talk about the robust Ajax API that comes with Drupal and that allows
    us to build some very dynamic functionalities that rely on JavaScript. To demonstrate
    how things work, we will revisit our importer functionality that we started in
    [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own Custom Entity
    and Plugin Types*, and improve it using Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will also talk about the States system of the Form API, which allows
    us to make our form elements dynamic and dependent on others in a declarative
    way. Again, we won't even have to know any JavaScript to do what is actually quite
    complex client-side behavior.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript in Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal 8 relies on a number of JavaScript libraries and plugins to perform some
    of its frontend tasks. For example, the use of *Backbone.js* is another example
    of advancement from previous versions of Drupal when it comes to adopting established
    libraries rather than reinventing new ones. Of course, as we've already seen,
    the ubiquitous *jQuery* library continues to be used in Drupal 8 as well. But
    of course, there are others.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing I have already mentioned, but which is helpful to bring up again,
    is the fact that Drupal no longer loads things such as jQuery or its Ajax framework
    on all pages needlessly. For example, many pages serving anonymous users that do
    not require jQuery won't even load it. This can greatly improve performance. But
    it also means that when we define our libraries to include our own JavaScript
    files, we must always declare these as dependencies (if we need them). For example,
    jQuery is something you'll often depend on.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things you need to know when writing JavaScript files
    in Drupal is the concept of behaviors. But in order to understand that, let's
    get a bit of context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing JavaScript code using jQuery, it''s often standard to wrap our
    code inside a `ready()` method statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that your code runs only after the entire **Document Object Model**
    (**DOM**) has been loaded by the browser. Moreover, the use of jQuery for this
    helps a great deal with cross-browser compatibility and also allows us to place
    this code wherever we want on the page (header or footer).
  prefs: []
  type: TYPE_NORMAL
- en: In Drupal, however, we have a different solution which is better in the context
    of writing JavaScript that works with Drupal as well (not just with the DOM).
    That comes in the form of Drupal behaviors. In a nutshell, behaviors are methods
    we declare that get called when the DOM loads fully, that is, when the document
    is ready. However, on top of that, they also get called by the Ajax framework
    when new data is loaded onto the page. Even when using BigPipe and placeholder
    replacements are streamed.
  prefs: []
  type: TYPE_NORMAL
- en: Any Drupal site has a global `Drupal` object that is used for many things we
    won't go into right now. However, the `Drupal.behaviours` object is where we declare
    behaviors, and typically any JavaScript code that we want to run should go inside
    a behavior. So, let's see an example, as it will be much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is to show a little dynamic JavaScript clock next to the Hello
    World salutation, if the message is not coming from the configuration but is dependent
    on the time of day. While writing the code for our functionality, we'll talk about
    Drupal behaviors and how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Our library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get our JavaScript file loaded, it needs to be in a library and
    attached to *something*. As you learned in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, the libraries file has the name `hello_world.libraries.yml` and is
    located in the root folder of our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We only have a single JavaScript file that is needed for our purpose, located
    in the `js` directory of our module. But we do have some dependencies. First,
    we want jQuery loaded because we will use it. Second, we want to have the general
    Drupal JavaScript library which handles a bunch of things, including behaviors.
    The last dependency we will talk about soon and it will make a bit more sense
    then.
  prefs: []
  type: TYPE_NORMAL
- en: Without these dependencies declared, in some cases (especially for anonymous
    users), Drupal would not have them loaded on the page and our JavaScript functionality
    would not work.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's attach this library to our salutation component found inside the
    `HelloWorldSalutation` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is nothing new for us but the point is that we are only attaching the library
    if the component is showing the dynamic salutation message that depends on the
    time of day. If this message has been overridden, we don't even want to load these
    libraries, and that is pretty much it. We can dive in and create our `hello_world_clock.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do inside the JavaScript file is to wrap the entire
    code we write in the file into an **Immediately Invoked Function Expression**
    (**IIFE**). In doing this, we protect the scope of what we write from the global
    one and even use global variables with more commonly associated variable names
    inside our own scope. This is how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most important thing here is that inside this function we can now use the
    dollar sign (`$`) as a reference to the global jQuery object without interfering
    with other libraries that might use the same variable name. Also, we added the
    `use strict` declaration to ensure we write semantically correct code (and it's
    also part of the JavaScript coding standards for Drupal 8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the meat of our functionality and explain how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we are defining a new behavior, which is an object on the `Drupal.behaviours`
    object and needs to have a unique name. You can look at a single behavior as one
    piece of functionality. We only need one function on this object called `attach`,
    which receives two parameters: `context` (the page or part of the page that is
    being loaded) and `settings` (the variable containing data passed from PHP).'
  prefs: []
  type: TYPE_NORMAL
- en: This function gets invoked by Drupal whenever behaviors need to be attached—`Drupal.attachBehaviors()`.
    This happens when the page gets loaded for the first time (in which case `context`
    is the entire DOM) or after an Ajax request or BigPipe replacement (in which case
    `context` contains only the newly loaded parts of the page). Therefore, using
    the `context` instead of the entire document for looking up elements is sometimes
    more performant (especially after an Ajax request) and prevents other side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `attach` function, we have our logic for creating a clock. First,
    we define a simple function that looks for the element with the `.clock` class
    and puts the current time into it. You'll notice that we used `context` to look
    for the element. Next, we create this element ourselves and append it to our salutation
    message element. Lastly, we set an interval every second to keep calling our `ticker()`
    function, essentially updating the time every second, giving the illusion of a
    clock. This is all pretty standard.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the strings we are printing to the user via JavaScript are not
    run through the translation system and that is not good practice (even if the
    site is not multilingual). In a later chapter, we will see how we need to handle
    it instead.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the cache and navigating to our `/hello` page, we can already see the
    new clock appearing (if we don't have the salutation message overridden). So we're
    done, right? Well, not really.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up the browser''s developer tools, namely the console, and try to
    attach the behaviors again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We notice that our clock element gets appended again (it has been duplicated).
    Well, that's not right because if we have an Ajax request we run the risk of having
    this happen. This is where `jQuery.once` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jQuery.once` library is a plugin for jQuery that allows us to track and
    make sure we are performing something only once. It''s actually very simple to
    use. All we have to do is replace this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So basically, before doing the actual thing, we call the `.once()` method with
    an ID to use for tracking. This will ensure that whatever comes next in the chain
    is only applied to the elements to which it has not been already applied. And
    now you also see why we wanted our library to depend on `core/jquery.once`.
  prefs: []
  type: TYPE_NORMAL
- en: And with this, our clock is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another powerful thing we can do (and something we often need to do) is pass
    values from our PHP code to the JavaScript layer. In custom PHP applications,
    this can get messy, but Drupal has a robust API that transforms PHP arrays into
    JavaScript objects. These can be found inside the `settings` object passed to
    the behavior's `attach()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the easiest way to understand this is through an example. So let''s
    say we want to print an extra message after the salutation if it is the afternoon.
    Of course, we can use JavaScript to determine that as well, but so far it has
    been the responsibility of our PHP code, so let''s keep it that way. So then we
    need a way to tell our JavaScript that it is afternoon, and we can do this by
    setting a flag if that is the case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'New here is the second line from within the *if conditional*, namely the one
    where we attach something to the render array. In this case, though, it''s not
    a library but `drupalSettings` in a big multidimensional array. The best practice
    is to *namespace* our settings hierarchically like so: our module name -> the
    functionality the setting belongs to -> the setting name. In JavaScript, this
    array will be transformed into an object.'
  prefs: []
  type: TYPE_NORMAL
- en: To get the `drupalSettings` to work, we need to make sure the `core/drupalSettings`
    library is loaded. In our case, this happens because the `core/drupal` library
    lists it as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we pass this flag (which could be much more complex if needed), we
    can make use of it in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That is pretty much it. We managed to easily pass values from PHP into JavaScript
    and use them in client-side logic.
  prefs: []
  type: TYPE_NORMAL
- en: The Ajax API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are on your way and ready to write whatever JavaScript you need
    for your application, and you are able to integrate this with the Drupal backend
    APIs, let's take a look at the Ajax framework. There's a lot we can do on the
    client side without having to write a single line of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: The Drupal Ajax API is a robust system that allows us to define client-side
    interactions via PHP. We most commonly use Ajax when we interact with forms—triggering
    certain actions that change the DOM without having to reload the page. We will
    demonstrate how all this works by expanding a bit more on the importer functionality
    we built in [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types*. Before, though, let's take a quick look at the
    simpler use case of Ajax in Drupal 8.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to interact with Drupal's Ajax API is to add the `use-ajax`
    class to any link. This will cause the link to make an Ajax request to the path
    of the link rather than moving the browser to it. A similar thing can be done
    with the submit button of a form using the `use-ajax-submit` class. This makes
    the form submit via Ajax to the path defined in the form's action.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing, however, is what we do on the other end of the process.
    Clicking a link that triggers an Ajax request won't do anything if we don't handle
    that request accordingly. What we have to do is return an `AjaxResponse` object
    with some jQuery *commands* that instruct the browser on the changes it needs
    to make to the DOM. So, let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, when we created our first block which simply rendered the
    salutation message from the service? It didn't use the theme hook we created in
    [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*, but simply
    delegated to the `getSalutation()` method of the `HelloWorldSalutation` service.
    Let's say we want to add a link after the message that we can click on, and that
    hides the block entirely. There are a few easy steps we need to take to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to alter the `build()` method of the block to get something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the new *use* statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is wrap our original simple `#markup`-based array into
    a Drupal core `container` theme hook, just so it wraps it with some divs and we
    don't have to create our own theme hook. After all, we are doing proof-of-concept
    work here. Next, below the message, we print a link to a new route we have to
    define. And as we talked about, to that link we add the `use-ajax` class. You'll
    notice that we can add attributes (refer back to [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, for more info on those) straight to the `Url` object, and they will
    be added to the rendered link element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we need to define this new route. Nothing could be simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We map it to a new method on the same Controller class we've been using and
    allow all users access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third (and last), we need to define the Controller method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And the new *use* statements at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you'll notice is the `$request` parameter of this method, and
    you may be wondering where it's coming from. Drupal passes the current request
    object to any Controller method which simply type hints a parameter with that
    class. So, we don't have to inject it into our Controller. The reason we need
    it is so that we can check whether the request to this route was made via Ajax.
    Because if not, we don't want to handle it. That is, we throw a `NotFoundHttpException`
    which results in a regular 404.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the fun stuff relating to the Ajax API, namely, the building of an
    `AjaxResponse` full of commands back to the browser. In our example, there is
    only one command which instructs it to run the jQuery `remove()` method on the
    elements that match the selector that is passed to it. In our case, this is the
    class of the block wrapper. And with this, our functionality is in place. We can
    clear our cache and the block should now print a link that removes the block via
    Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be thinking: why do we need a trip back to the server for a job that
    can be done on the client-side alone? And the answer is—we actually don''t. However,
    it serves as a good example of how Ajax responses work. And I encourage you to
    check out the documentation page ([https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x](https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x)
    ) for the Ajax API, where you can find a list of all the available commands. For
    example, we could have used the `ReplaceCommand` to replace the block with something
    else that comes back from the server, or the `HtmlCommand` to insert some data
    into an element on the page, or even an `AlertCommand` to trigger a JavaScript
    alert with some data coming from the server. The cool thing is that the response
    can process multiple commands so we are not restricted to only using one.'
  prefs: []
  type: TYPE_NORMAL
- en: Ajax in forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common use of Ajax in Drupal is through the Form API, where we can
    create dynamic interactions between the server and client with ease. To demonstrate
    how this works, we will go through an example. This will be a rework of the Importer
    configuration entity form we created in [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, we said that tying certain configuration values to the generic
    entity does not make sense, as importer plugins might be different. The first
    Importer we wrote loads a JSON file from a remote URL. So, it stands to reason
    that the configuration value for the URL is tied to the plugin and not the configuration
    entity (even if the latter actually stores it). Because if we want to create a
    CSV importer, for example, we don't need the URL. So, let's refactor our work
    to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an outline of the steps we need to take for this refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Importer plugins need to provide their own configuration form elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Importer configuration form needs to read these elements depending on which
    plugin is selected (this is where the Ajax API comes into play).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to alter the storage and configuration schema of the values that are
    specific to plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by giving the `ImporterInterface` plugin type a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is responsible for getting the form elements needed for this plugin. As
    an argument, it receives the Importer configuration entity, which can be inspected
    for default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on the `ImporterInterface` of the configuration entity, we need to remove
    the `getUrl()` method (since that is specific to the `JsonImporter` plugin) and
    replace it with a generic method for retrieving all the configuration values pertaining
    to the plugin selected for the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, in the importer entity class, we reflect this change as well
    (by replacing the `$url` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And the actual getter method, in line with the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good, nothing complicated going on. We are replacing the plugin-specific
    configuration values with a generic one in which values specific to the selected
    plugin will be stored. However, since our entity type no longer has the `$url`
    field but a `$plugin_configuration` one instead, we need to also adjust the `config_export`
    key in the annotation to reflect this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s turn to the `ImporterForm` and make all the adjustments there.
    But before we do that, let''s move the form element for the `url` field into the
    `JsonImporter`, where we have to implement the new `getConfigurationForm()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice some differences in getting the default value. Instead of calling
    the now-removed `getUrl()` method on the configuration entity, we use the new
    `getPluginConfiguration()` method and check inside the resulting array. Also,
    since we use the `$this->t()` method to ensure the translation of the strings,
    we should use the `StringTranslationTrait` as well (which can go inside the parent
    base class as it is a trait):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s not forget that we are actually using the URL in the import, so we need
    to make some adjustments to the `getData()` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can go ahead and adjust our `ImporterForm` (where we
    no longer have the form element for the URL field).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main things we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose the plugin selection element to Ajax, that is, trigger an Ajax request
    when the user makes a selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the extra elements to the form depending on the chosen plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what the new `plugin` element looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two noticeable changes: we''ve added an `#empty_option` key (to be
    used as the option shown if the user has not made a choice) and the `#ajax` key
    (which we will discuss in a bit more detail).'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we did is pretty simple. We declared a callback method to be triggered
    when a user makes a change to this form element, and we declared the HTML ID of
    the element that should be replaced with the result of the Ajax callback. And
    in the latter (which is a simple method on the same class), all we have to do
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We return a form element (which we still have to define). An important lesson
    here is that Ajax responses in forms can return content as well (in the form of
    render arrays or even strings), which will be used to replace the HTML found by
    the ID specified in the `wrapper` key of the Ajax declaration. Alternatively,
    an `AjaxResponse` full of commands can also be returned to do more complex things,
    as we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at this new `plugin_configuration` form element, let''s look
    at some of the other options that can be used inside the `#ajax` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: This indicates the jQuery method to use when interacting with the
    `wrapper` element (if specified). The default is `replaceWith()`, but you can
    also use `append()`, `html()`, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: This shows which event should be used to trigger the Ajax call. By
    default, the form element in question decides that. For example, when selecting
    an option in a select element or when typing something into a textfield.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`progress`: This defines the indicator to be used while the Ajax request is
    taking place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: A URL to trigger the Ajax request in case the `callback` was not specified.
    Typically, using the latter is more powerful as the entire `$form` and `$form_state`
    are passed as parameters and can be used in processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend you check out the documentation page ([https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x](https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x))
    for the Ajax API for more information about these options and the other ones that
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, we can go back to our form definition and add our
    missing parts, right after the `plugin` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the `plugin_configuration` form element as a `hidden` type.
    This means it will not be visible to users when the page loads for the first time.
    However, we do use the `#prefix` and `#suffix` options (common practice with the
    Drupal Form API) to wrap this element with a div that has the ID we indicated
    as the `wrapper` of our Ajax declaration. So, the goal is to have this element
    replaced each time an Ajax request is made, that is, each time a plugin is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try to get the ID of the chosen plugin. First, we load it from the
    configuration entity in case we are looking at an edit form. However, we also
    check in the form state to see if one has been selected (and is different from
    the one in the entity). And if you are wondering how we can have the plugin in
    the form state, the answer is that after an Ajax call is made (triggered by the
    user selecting a plugin), the form gets rebuilt. Now, we can see what's in the
    form state and retrieve the plugin ID that was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more than that, if we get our hands on a plugin ID, we can completely
    change the `plugin_configuration` element, which in turn then gets returned by
    the Ajax callback to be used to replace our wrapper. So to sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: The page loads for the first time (on a new form). The element is hidden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user selects a plugin and an Ajax request is triggered, which rebuilds the
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the form is rebuilt, we check for the selected plugin and alter the `plugin_configuration`
    element to reflect the selected plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ajax response replaces the old element with the new, potentially changed,
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `plugin_configuration` element becomes a `details` one (a collapsible
    container for multiple elements), open by default, and which has one key, called
    `plugin`, onto which we add all the elements coming from the plugin. Moreover,
    we use the `#tree` property to indicate that when the form is submitted, the values
    of the elements are sent and stored in a tree that reflects the form element (a
    multidimensional array, basically). Otherwise, the form state values that are
    submitted get flattened and we lose their connection to the `plugin_configuration`
    element (which is also the Importer configuration entity field name we want to
    store the data under).
  prefs: []
  type: TYPE_NORMAL
- en: We are almost there. We can already go and create an importer entity, and when
    we select the JSON Importer, the new fieldset containing the URL field should
    show up below. But we still have one problem. If we save the form, the URL value
    will be stored inside an array keyed by `plugin`, inside the `plugin_configuration`
    field. So we need to clean things up a bit and we can do so inside the `save()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right before saving the entity, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, we basically move the values one array up, removing the superfluous `plugin`
    level in the array (which was only needed to neatly organize the form tree).
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done. Well, not really, as we still need to handle the configuration
    schema aspect. Yes, remember those from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*? We are now going to see how we can
    work with our own dynamic configuration schema, similar to how we did with the
    ones needed for the field plugins in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*. But why do we need a dynamic configuration schema?
  prefs: []
  type: TYPE_NORMAL
- en: Before this refactoring, we knew the exact fields of the importer configuration
    entity and we could declare the schema for each easily (as we did). However, now
    plugins can come with their own individual fields, so we need to make sure they
    can provide their own schema definitions for the respective data. So how can we
    do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, inside our `importer.schema.yml` file, we need to remove the `url` field
    schema definition as it no longer exists. We replace it, however, with one for
    the new field we created, namely the `plugin_configuration` array of values that
    came from the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here is where things become interesting. We don't know what fields there will
    be inside, so we instead reference another type (our own). Moreover, the name
    of the type is dynamic. We have a prefix (`products.importer.plugin.`) followed
    by a variable name given by the value of the plugin field of the parent *(*the
    main configuration entity*)*. So basically, if a given configuration entity uses
    the `json` plugin, the type of schema definition will be `products.importer.plugin.json`.
    So now, it's the responsibility of whoever creates new plugins to also provide
    their own schema definitions for their own fields (like we did in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields,* when we defined field plugins).
  prefs: []
  type: TYPE_NORMAL
- en: 'But before that can happen, we need to define this new type we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So essentially our new type extends from `mapping` and has a simple label. Of
    course, it applies to all that start with that name (hence the wildcard we encountered
    before).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the schema definition for our single `json` Importer plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now have our first instance of the `products.importer.plugin`
    type, which contains the `url` field and which is inside the `plugin_configuration`
    field of the configuration entity—reflecting a simple array hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: But the point of this dynamic declaration is that other modules that define
    new plugins can now also define their own instances of the `products.importer.plugin.*`
    schema definitions to map their own fields. It is no longer the responsibility
    of the configuration entity (schema) to "guess" what field types are being used
    on each plugin.
  prefs: []
  type: TYPE_NORMAL
- en: With this, our refactoring is complete. Drupal is well aware of the type of
    data the configuration entity is saving, even if it is in part relating to external
    input (the selected plugin). So that means we can create (if we want) another
    importer plugin that uses a CSV file for the product data. But we'll see how to
    do that in a later chapter when we talk about file handling.
  prefs: []
  type: TYPE_NORMAL
- en: States (Form) system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we are going to look at in this chapter is the States system
    of the Form API (not to be confused with the State API we covered in [Chapter
    6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and Storage*).
    This allows us to define our form elements to behave somewhat dynamically based
    on the user interaction with the form. It doesn't use Ajax but relies on JavaScript
    to handle the manipulations. This is another great example of client-side behavior
    where we don't have to write a single line of JavaScript. So, let's see what this
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#states` are simple properties we can add to form elements, which have
    the role of changing them depending on the *state* of other elements. The best
    way to understand this is through some examples. Imagine these two form elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first, we ask the user if they have kids (using a simple checkbox),
    while in the second ,we ask them how many kids they have. But why should the user
    actually see the second element if they don''t have kids? This is where the `#states`
    property comes into play, and its role is to manipulate an element depending on
    the *state* of another. So instead, we can have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, the element for specifying the number of kids is only going to be visible
    if the *state* of the `kid` element is checked.
  prefs: []
  type: TYPE_NORMAL
- en: The `#states` property is an array whose key is the actual *state* that needs
    to be applied to the current element if the conditions inside are met. And the
    conditions can vary, but they all depend on a CSS selector (in our case `input[name="kids"]`
    matching another element).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example can also be written with this reverse logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from `visible` and `invisible`, the following *states* can be also applied
    to form elements: `enabled`, `disabled`, `required`, `optional`, `checked`, `unchecked`,
    `expanded` and `collapsed`. As for the conditions that can "trigger" these *states*,
    we can have the following (apart from `checked`, which we already saw): `empty`,
    `filled`, `unchecked`, `expanded`, `collapsed` and `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, we can even control the *state* of an element depending on
    the value the user selected on another. Combining these possibilities can greatly
    improve our forms when it comes to user experience, decluttering, and even building
    logical form trees.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took on the client-side and talked about JavaScript and
    client-side capabilities in Drupal 8\. We started with the approach we need to
    take when writing JavaScript in a Drupal context. We learned about behaviors,
    why they are important, and how to use them. We also saw how we can pass around
    data from the server (Drupal) to the client-side and make use of it in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Funnily enough, we then switched to a no-JavaScript-allowed policy for the rest
    of the chapter. We did this to prove how powerful the Drupal Ajax API is, with
    which we can perform complex server-to-client interactions even if we are not
    frontend developers that can write JavaScript code. And to demonstrate the API,
    we first looked at how simple links can be turned into Ajax requests. We followed
    that up with an important refactor of our earlier product importer functionality
    which relied on Ajax to make the Importer configuration entity form dynamic (dependent
    on the selected plugin). Let's not forget another nugget of information—dynamic
    configuration schema—which allows us to decouple the configuration entity data
    definitions from that of their selected plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished by looking at the States system of the Form API which allows
    us to declaratively code client-side manipulations onto our form elements, essentially
    making them dependent on the user's interaction with the form.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about internationalization and translations
    to make sure our applications can be used anywhere around the globe.
  prefs: []
  type: TYPE_NORMAL
