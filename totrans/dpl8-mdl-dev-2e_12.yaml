- en: JavaScript and the Ajax API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 和 Ajax API
- en: So far in this book, we've only talked about topics that can be considered to
    relate to backend development. This means heavy PHP working with the APIs and
    the database, and so on. This is because this book is oriented toward module developers
    rather than "themers". Also, the author of this book is admittedly not a JavaScript,
    or any kind of frontend, developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们只讨论了可以被认为是与后端开发相关的话题。这意味着大量的 PHP 与 API 和数据库一起工作，等等。这是因为这本书面向的是模块开发者，而不是“主题开发者”。此外，这本书的作者承认自己不是
    JavaScript 或任何前端开发者。
- en: Nevertheless, in this chapter we'll switch gears and talk a bit about *frontend
    development*, namely, how to work with JavaScript in a Drupal 8 application. This
    is because there are many things developers can and should be doing in their modules
    that require frontend technologies. There are a few approaches and techniques
    specific to Drupal when it comes to adding and using JavaScript files and we will
    talk about those here. Moreover, we will also prove how powerful Drupal 8 is in
    allowing us to do quite a bit of JavaScript work without actually writing a single
    line of JavaScript code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在本章中，我们将转换方向，简要讨论一下 *前端开发*，即如何在 Drupal 8 应用程序中与 JavaScript 一起工作。这是因为开发者可以在他们的模块中做很多事情，这些事情需要前端技术。在添加和使用
    JavaScript 文件方面，Drupal 有一些特定的方法和技巧，我们将在本章中讨论这些内容。此外，我们还将证明 Drupal 8 在允许我们进行大量的
    JavaScript 工作方面是多么强大，而实际上我们甚至不需要编写一行 JavaScript 代码。
- en: So, there are a few things we will cover in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中我们将介绍一些内容。
- en: First, we will talk about the approach of writing JavaScript in Drupal. You
    already learned in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*,
    how you can create libraries and attach them to render arrays, elements, or pages.
    Basically, using libraries, we can get our JavaScript files loaded when we need.
    I recommend you check out the *Assets and libraries* section from [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, if you don't remember exactly how libraries work. Because in this chapter,
    we will continue from there and talk a bit about what actually goes inside those
    JavaScript files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论在 Drupal 中编写 JavaScript 的方法。你已经在[第 4 章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，“主题”中学习了如何创建库并将它们附加到渲染数组、元素或页面上。基本上，通过使用库，我们可以在需要的时候加载我们的
    JavaScript 文件。如果你不记得库是如何工作的，我建议你查看[第 4 章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，“主题”中的“资源和库”部分。因为在本章中，我们将从这里继续，并简要讨论那些
    JavaScript 文件中实际包含的内容。
- en: A good resource to keep handy is the documentation page ([https://www.drupal.org/node/172169](https://www.drupal.org/node/172169))
    which lists the coding standards for JavaScript in Drupal 8 that we should abide
    by.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的资源是文档页面([https://www.drupal.org/node/172169](https://www.drupal.org/node/172169))，它列出了
    Drupal 8 中 JavaScript 的编码标准，我们应该遵守这些标准。
- en: We won't actually write a lot of JavaScript code in the first part—just enough
    to get you started though. In the second part, we will not write any at all. Instead,
    we will talk about the robust Ajax API that comes with Drupal and that allows
    us to build some very dynamic functionalities that rely on JavaScript. To demonstrate
    how things work, we will revisit our importer functionality that we started in
    [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own Custom Entity
    and Plugin Types*, and improve it using Ajax.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们实际上不会编写很多 JavaScript 代码——只是足够让你开始。在第二部分，我们则一个字也不会写。相反，我们将讨论与 Drupal
    一起提供的强大 Ajax API，它允许我们构建一些非常动态的功能，这些功能依赖于 JavaScript。为了展示事物是如何工作的，我们将回顾我们在[第 7
    章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，“你的自定义实体和插件类型”中开始的功能导入，并使用 Ajax
    来改进它。
- en: Finally, we will also talk about the States system of the Form API, which allows
    us to make our form elements dynamic and dependent on others in a declarative
    way. Again, we won't even have to know any JavaScript to do what is actually quite
    complex client-side behavior.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将讨论表单 API 的状态系统，它允许我们以声明的方式使我们的表单元素动态化并依赖于其他元素。同样，我们甚至不需要了解任何 JavaScript
    就可以完成相当复杂的客户端行为。
- en: JavaScript in Drupal
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal 中的 JavaScript
- en: Drupal 8 relies on a number of JavaScript libraries and plugins to perform some
    of its frontend tasks. For example, the use of *Backbone.js* is another example
    of advancement from previous versions of Drupal when it comes to adopting established
    libraries rather than reinventing new ones. Of course, as we've already seen,
    the ubiquitous *jQuery* library continues to be used in Drupal 8 as well. But
    of course, there are others.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 依赖于许多 JavaScript 库和插件来执行一些前端任务。例如，使用 *Backbone.js* 是 Drupal 相较于之前版本在采用现有库而不是重新发明轮子方面的进步。当然，正如我们已经看到的，无处不在的
    *jQuery* 库在 Drupal 8 中仍然被使用。但当然，还有其他库。
- en: Another thing I have already mentioned, but which is helpful to bring up again,
    is the fact that Drupal no longer loads things such as jQuery or its Ajax framework
    on all pages needlessly. For example, many pages serving anonymous users that do
    not require jQuery won't even load it. This can greatly improve performance. But
    it also means that when we define our libraries to include our own JavaScript
    files, we must always declare these as dependencies (if we need them). For example,
    jQuery is something you'll often depend on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我已经提到过，但再次提及是有帮助的，那就是 Drupal 现在不再在所有页面上无谓地加载诸如 jQuery 或其 Ajax 框架之类的东西。例如，许多为匿名用户提供服务且不需要
    jQuery 的页面甚至不会加载它。这可以大大提高性能。但这也意味着，当我们定义库以包含我们自己的 JavaScript 文件时，我们必须始终将这些声明为依赖项（如果我们需要它们）。例如，jQuery
    是你经常依赖的东西。
- en: Drupal behaviors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal 行为
- en: One of the most important things you need to know when writing JavaScript files
    in Drupal is the concept of behaviors. But in order to understand that, let's
    get a bit of context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Drupal 中编写 JavaScript 文件时，你需要知道的一个重要概念是行为。但为了理解这一点，让我们先了解一下背景。
- en: 'When writing JavaScript code using jQuery, it''s often standard to wrap our
    code inside a `ready()` method statement as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 jQuery 编写 JavaScript 代码时，通常的标准是将我们的代码包裹在一个 `ready()` 方法语句中，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This ensures that your code runs only after the entire **Document Object Model**
    (**DOM**) has been loaded by the browser. Moreover, the use of jQuery for this
    helps a great deal with cross-browser compatibility and also allows us to place
    this code wherever we want on the page (header or footer).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了您的代码只有在浏览器加载了整个 **文档对象模型**（**DOM**）之后才会运行。此外，使用 jQuery 来实现这一点在很大程度上有助于跨浏览器兼容性，并允许我们在页面上任何我们想要的位置放置此代码（例如头部或尾部）。
- en: In Drupal, however, we have a different solution which is better in the context
    of writing JavaScript that works with Drupal as well (not just with the DOM).
    That comes in the form of Drupal behaviors. In a nutshell, behaviors are methods
    we declare that get called when the DOM loads fully, that is, when the document
    is ready. However, on top of that, they also get called by the Ajax framework
    when new data is loaded onto the page. Even when using BigPipe and placeholder
    replacements are streamed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Drupal 中，我们有一个不同的解决方案，这个方案在编写与 Drupal 一起工作的 JavaScript（而不仅仅是与 DOM 一起工作）的上下文中更好。这个解决方案就是
    Drupal 行为。简而言之，行为是我们声明的、在 DOM 完全加载时被调用的方法，也就是说，当文档准备就绪时。然而，除此之外，它们还会在 Ajax 框架将新数据加载到页面上时被调用。即使在使用
    BigPipe 和占位符替换时也是如此。
- en: Any Drupal site has a global `Drupal` object that is used for many things we
    won't go into right now. However, the `Drupal.behaviours` object is where we declare
    behaviors, and typically any JavaScript code that we want to run should go inside
    a behavior. So, let's see an example, as it will be much easier to understand.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Drupal 网站都有一个全局的 `Drupal` 对象，用于许多我们现在不会深入讨论的事情。然而，`Drupal.behaviours` 对象是我们声明行为的地方，通常我们想要运行的任何
    JavaScript 代码都应该放在行为内部。所以，让我们看看一个例子，这样会更容易理解。
- en: What we want is to show a little dynamic JavaScript clock next to the Hello
    World salutation, if the message is not coming from the configuration but is dependent
    on the time of day. While writing the code for our functionality, we'll talk about
    Drupal behaviors and how they are used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示一个动态的 JavaScript 时钟，位于“Hello World”问候语旁边，如果消息不是来自配置而是依赖于一天中的时间。在编写我们功能性的代码时，我们将讨论
    Drupal 行为以及它们是如何被使用的。
- en: Our library
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的库
- en: 'In order to get our JavaScript file loaded, it needs to be in a library and
    attached to *something*. As you learned in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, the libraries file has the name `hello_world.libraries.yml` and is
    located in the root folder of our module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 JavaScript 文件能够加载，它需要位于一个库中，并附加到*某个东西*上。正如你在[第 4 章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)中学习的*主题化*，库文件名为
    `hello_world.libraries.yml`，位于我们模块的根目录中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We only have a single JavaScript file that is needed for our purpose, located
    in the `js` directory of our module. But we do have some dependencies. First,
    we want jQuery loaded because we will use it. Second, we want to have the general
    Drupal JavaScript library which handles a bunch of things, including behaviors.
    The last dependency we will talk about soon and it will make a bit more sense
    then.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个 JavaScript 文件，它位于我们模块的 `js` 目录中，用于我们的目的。但我们确实有一些依赖项。首先，我们希望加载 jQuery，因为我们将会使用它。其次，我们希望有通用的
    Drupal JavaScript 库，它处理许多事情，包括行为。我们将很快讨论最后一个依赖项，那时它会有更多的意义。
- en: Without these dependencies declared, in some cases (especially for anonymous
    users), Drupal would not have them loaded on the page and our JavaScript functionality
    would not work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有声明这些依赖项，在某些情况下（尤其是对于匿名用户），Drupal 不会在页面上加载它们，我们的 JavaScript 功能将无法工作。
- en: Now, let's attach this library to our salutation component found inside the
    `HelloWorldSalutation` service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个库附加到位于 `HelloWorldSalutation` 服务内部的 salutation 组件上。
- en: 'Right after these two lines:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两行之后：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can add the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is nothing new for us but the point is that we are only attaching the library
    if the component is showing the dynamic salutation message that depends on the
    time of day. If this message has been overridden, we don't even want to load these
    libraries, and that is pretty much it. We can dive in and create our `hello_world_clock.js`
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说并不新鲜，但关键是我们只在我们需要显示的组件上附加库，这个动态问候消息依赖于一天中的时间。如果这个消息已被覆盖，我们甚至不想加载这些库，这就是全部。我们可以深入进去创建我们的
    `hello_world_clock.js` 文件。
- en: The JavaScript
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'The first thing we need to do inside the JavaScript file is to wrap the entire
    code we write in the file into an **Immediately Invoked Function Expression**
    (**IIFE**). In doing this, we protect the scope of what we write from the global
    one and even use global variables with more commonly associated variable names
    inside our own scope. This is how this looks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件中，我们首先需要做的是将我们在这个文件中编写的整个代码包裹在一个**立即调用的函数表达式**（**IIFE**）中。通过这样做，我们保护了我们编写的代码的作用域，使其不会与全局作用域冲突，甚至可以在我们自己的作用域中使用与变量名更常见的全局变量。这就是它的样子：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most important thing here is that inside this function we can now use the
    dollar sign (`$`) as a reference to the global jQuery object without interfering
    with other libraries that might use the same variable name. Also, we added the
    `use strict` declaration to ensure we write semantically correct code (and it's
    also part of the JavaScript coding standards for Drupal 8).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的事情是，现在我们可以在函数内部使用美元符号（`$`）作为对全局 jQuery 对象的引用，而不会干扰可能使用相同变量名的其他库。此外，我们还添加了
    `use strict` 声明，以确保我们编写的代码语义正确（这也是 Drupal 8 的 JavaScript 编码标准的一部分）。
- en: 'Let''s now add the meat of our functionality and explain how it works:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在添加我们功能的核心部分，并解释它是如何工作的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First of all, we are defining a new behavior, which is an object on the `Drupal.behaviours`
    object and needs to have a unique name. You can look at a single behavior as one
    piece of functionality. We only need one function on this object called `attach`,
    which receives two parameters: `context` (the page or part of the page that is
    being loaded) and `settings` (the variable containing data passed from PHP).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在定义一个新的行为，这是一个位于 `Drupal.behaviours` 对象上的对象，并且需要有一个唯一的名字。你可以把一个行为看作是一块功能。我们只需要在这个对象上有一个名为
    `attach` 的函数，它接收两个参数：`context`（正在加载的页面或页面的一部分）和 `settings`（包含从 PHP 传递的数据的变量）。
- en: This function gets invoked by Drupal whenever behaviors need to be attached—`Drupal.attachBehaviors()`.
    This happens when the page gets loaded for the first time (in which case `context`
    is the entire DOM) or after an Ajax request or BigPipe replacement (in which case
    `context` contains only the newly loaded parts of the page). Therefore, using
    the `context` instead of the entire document for looking up elements is sometimes
    more performant (especially after an Ajax request) and prevents other side effects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会在 Drupal 需要附加行为时被调用——`Drupal.attachBehaviors()`。这发生在页面首次加载时（在这种情况下，`context`
    是整个 DOM），或者在 Ajax 请求或 BigPipe 替换之后（在这种情况下，`context` 只包含页面新加载的部分）。因此，使用 `context`
    而不是整个文档来查找元素有时会更高效（尤其是在 Ajax 请求之后），并且可以防止其他副作用。
- en: Inside the `attach` function, we have our logic for creating a clock. First,
    we define a simple function that looks for the element with the `.clock` class
    and puts the current time into it. You'll notice that we used `context` to look
    for the element. Next, we create this element ourselves and append it to our salutation
    message element. Lastly, we set an interval every second to keep calling our `ticker()`
    function, essentially updating the time every second, giving the illusion of a
    clock. This is all pretty standard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `attach` 函数内部，我们有创建时钟的逻辑。首先，我们定义一个简单的函数，用于查找具有 `.clock` 类的元素并将当前时间放入其中。你会注意到我们使用了
    `context` 来查找元素。接下来，我们自行创建这个元素并将其附加到我们的问候信息元素上。最后，我们每秒设置一个间隔来持续调用我们的 `ticker()`
    函数，本质上每秒更新一次时间，从而产生时钟的错觉。这一切都很标准。
- en: Be aware that the strings we are printing to the user via JavaScript are not
    run through the translation system and that is not good practice (even if the
    site is not multilingual). In a later chapter, we will see how we need to handle
    it instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过 JavaScript 打印给用户的字符串没有经过翻译系统，这不是一个好的做法（即使网站不是多语言的）。在后面的章节中，我们将看到我们如何需要处理它。
- en: Clearing the cache and navigating to our `/hello` page, we can already see the
    new clock appearing (if we don't have the salutation message overridden). So we're
    done, right? Well, not really.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存并导航到我们的 `/hello` 页面，我们就可以看到新的时钟已经出现（如果我们没有覆盖问候信息）。所以，我们完成了，对吧？嗯，其实并没有。
- en: 'If we open up the browser''s developer tools, namely the console, and try to
    attach the behaviors again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开浏览器的开发者工具，即控制台，并尝试再次附加行为：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We notice that our clock element gets appended again (it has been duplicated).
    Well, that's not right because if we have an Ajax request we run the risk of having
    this happen. This is where `jQuery.once` comes in.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到我们的时钟元素被再次附加（它已经被复制了）。这显然是不对的，因为如果我们有 Ajax 请求，我们就有风险发生这种情况。这就是 `jQuery.once`
    发挥作用的地方。
- en: 'The `jQuery.once` library is a plugin for jQuery that allows us to track and
    make sure we are performing something only once. It''s actually very simple to
    use. All we have to do is replace this line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.once` 库是 jQuery 的一个插件，它允许我们跟踪并确保我们只执行一次某个操作。实际上，它非常简单易用。我们只需替换这一行：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So basically, before doing the actual thing, we call the `.once()` method with
    an ID to use for tracking. This will ensure that whatever comes next in the chain
    is only applied to the elements to which it has not been already applied. And
    now you also see why we wanted our library to depend on `core/jquery.once`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，在执行实际操作之前，我们使用一个 ID 调用 `.once()` 方法来跟踪。这将确保链中接下来的任何操作只应用于尚未应用过该操作的元素。现在你也看到了为什么我们希望我们的库依赖于
    `core/jquery.once`。
- en: And with this, our clock is ready.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的时钟就准备好了。
- en: Drupal settings
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal 设置
- en: Another powerful thing we can do (and something we often need to do) is pass
    values from our PHP code to the JavaScript layer. In custom PHP applications,
    this can get messy, but Drupal has a robust API that transforms PHP arrays into
    JavaScript objects. These can be found inside the `settings` object passed to
    the behavior's `attach()` function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做另一件强大而常见的事情（我们经常需要做），那就是将值从 PHP 代码传递到 JavaScript 层。在自定义 PHP 应用程序中，这可能会变得很复杂，但
    Drupal 有一个强大的 API，可以将 PHP 数组转换为 JavaScript 对象。这些对象可以在传递给行为 `attach()` 函数的 `settings`
    对象中找到。
- en: 'Again, the easiest way to understand this is through an example. So let''s
    say we want to print an extra message after the salutation if it is the afternoon.
    Of course, we can use JavaScript to determine that as well, but so far it has
    been the responsibility of our PHP code, so let''s keep it that way. So then we
    need a way to tell our JavaScript that it is afternoon, and we can do this by
    setting a flag if that is the case, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，理解这一点最简单的方法是通过一个例子。所以，假设我们想在问候语之后打印一条额外的消息，如果它是下午的话。当然，我们也可以使用 JavaScript
    来确定这一点，但到目前为止，这一直是我们的 PHP 代码的责任，所以让我们保持这种方式。因此，我们需要一种方法来告诉我们的 JavaScript 它是下午，如果那样的话，我们可以通过设置一个标志来实现，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'New here is the second line from within the *if conditional*, namely the one
    where we attach something to the render array. In this case, though, it''s not
    a library but `drupalSettings` in a big multidimensional array. The best practice
    is to *namespace* our settings hierarchically like so: our module name -> the
    functionality the setting belongs to -> the setting name. In JavaScript, this
    array will be transformed into an object.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是 *if 条件* 中的第二行，即我们将其附加到渲染数组中的那一行。然而，在这种情况下，它不是一个库，而是一个大型的多维数组中的 `drupalSettings`。最佳实践是按照以下方式分层命名我们的设置：我们的模块名称
    -> 设置所属的功能 -> 设置名称。在 JavaScript 中，这个数组将被转换成一个对象。
- en: To get the `drupalSettings` to work, we need to make sure the `core/drupalSettings`
    library is loaded. In our case, this happens because the `core/drupal` library
    lists it as a dependency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `drupalSettings` 生效，我们需要确保已加载 `core/drupalSettings` 库。在我们的例子中，这是因为 `core/drupal`
    库将其列为依赖项。
- en: 'Now that we pass this flag (which could be much more complex if needed), we
    can make use of it in JavaScript:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们传递了这个标志（如果需要，它可能更加复杂），我们就可以在 JavaScript 中使用它：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That is pretty much it. We managed to easily pass values from PHP into JavaScript
    and use them in client-side logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。我们成功地轻松地将值从 PHP 传递到 JavaScript 并在客户端逻辑中使用它们。
- en: The Ajax API
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax API
- en: Now that you are on your way and ready to write whatever JavaScript you need
    for your application, and you are able to integrate this with the Drupal backend
    APIs, let's take a look at the Ajax framework. There's a lot we can do on the
    client side without having to write a single line of JavaScript code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好编写您应用程序所需的任何 JavaScript 代码，并且能够将其与 Drupal 后端 API 集成，让我们来看看 Ajax 框架。在不编写任何
    JavaScript 代码的情况下，我们可以在客户端做很多事情。
- en: The Drupal Ajax API is a robust system that allows us to define client-side
    interactions via PHP. We most commonly use Ajax when we interact with forms—triggering
    certain actions that change the DOM without having to reload the page. We will
    demonstrate how all this works by expanding a bit more on the importer functionality
    we built in [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types*. Before, though, let's take a quick look at the
    simpler use case of Ajax in Drupal 8.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal Ajax API 是一个强大的系统，它允许我们通过 PHP 定义客户端交互。我们最常使用 Ajax 与表单交互——触发某些动作，改变 DOM
    而无需重新加载页面。我们将通过扩展我们在 [第 7 章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，*您的自定义实体和插件类型*
    中构建的导入功能来演示这一切是如何工作的。在深入探讨之前，让我们快速看一下 Drupal 8 中 Ajax 的简单用法。
- en: Ajax links
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax 链接
- en: The simplest way to interact with Drupal's Ajax API is to add the `use-ajax`
    class to any link. This will cause the link to make an Ajax request to the path
    of the link rather than moving the browser to it. A similar thing can be done
    with the submit button of a form using the `use-ajax-submit` class. This makes
    the form submit via Ajax to the path defined in the form's action.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Drupal 的 Ajax API 交互的最简单方法是向任何链接添加 `use-ajax` 类。这将导致链接向链接的路径发送 Ajax 请求，而不是将浏览器移动到那里。类似的事情可以使用表单的提交按钮通过
    `use-ajax-submit` 类来完成。这使得表单通过 Ajax 提交到表单的 action 中定义的路径。
- en: The most important thing, however, is what we do on the other end of the process.
    Clicking a link that triggers an Ajax request won't do anything if we don't handle
    that request accordingly. What we have to do is return an `AjaxResponse` object
    with some jQuery *commands* that instruct the browser on the changes it needs
    to make to the DOM. So, let's see an example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是我们在流程的另一端所做的工作。点击一个触发 Ajax 请求的链接，如果我们没有相应地处理该请求，那么什么也不会发生。我们必须做的是返回一个包含一些
    jQuery *命令* 的 `AjaxResponse` 对象，这些命令指导浏览器对 DOM 所需进行的更改。所以，让我们看看一个例子。
- en: Remember in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, when we created our first block which simply rendered the
    salutation message from the service? It didn't use the theme hook we created in
    [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*, but simply
    delegated to the `getSalutation()` method of the `HelloWorldSalutation` service.
    Let's say we want to add a link after the message that we can click on, and that
    hides the block entirely. There are a few easy steps we need to take to achieve
    this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建你的第一个模块*中，当我们创建第一个仅渲染服务中的问候消息的块时？它没有使用我们在[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*中创建的主题钩子，而是简单地委托给`HelloWorldSalutation`服务的`getSalutation()`方法。假设我们想在消息后添加一个可以点击的链接，并且可以完全隐藏块。我们需要采取几个简单的步骤来实现这一点。
- en: 'First, we need to alter the `build()` method of the block to get something
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改块中的`build()`方法，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And the new *use* statement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以及新的`use`声明：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing we do is wrap our original simple `#markup`-based array into
    a Drupal core `container` theme hook, just so it wraps it with some divs and we
    don't have to create our own theme hook. After all, we are doing proof-of-concept
    work here. Next, below the message, we print a link to a new route we have to
    define. And as we talked about, to that link we add the `use-ajax` class. You'll
    notice that we can add attributes (refer back to [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, for more info on those) straight to the `Url` object, and they will
    be added to the rendered link element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是将我们的原始基于`#markup`的简单数组包装到Drupal核心的`container`主题钩子中，这样它就会用一些div将其包裹起来，我们就不必创建自己的主题钩子。毕竟，我们在这里做的是概念验证工作。接下来，在消息下方，我们打印出一个指向我们必须要定义的新路由的链接。正如我们之前讨论的，我们给这个链接添加了`use-ajax`类。你会注意到，我们可以直接将属性（参考[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*，了解更多关于这些属性的信息）添加到`Url`对象中，它们将被添加到渲染的链接元素中。
- en: 'Second, we need to define this new route. Nothing could be simpler:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要定义这个新路由。这再简单不过了：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We map it to a new method on the same Controller class we've been using and
    allow all users access to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其映射到我们一直在使用的相同控制器类的新方法上，并允许所有用户访问它。
- en: 'Third (and last), we need to define the Controller method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第三（也是最后），我们需要定义控制器方法：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the new *use* statements at the top:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新`use`声明：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing you'll notice is the `$request` parameter of this method, and
    you may be wondering where it's coming from. Drupal passes the current request
    object to any Controller method which simply type hints a parameter with that
    class. So, we don't have to inject it into our Controller. The reason we need
    it is so that we can check whether the request to this route was made via Ajax.
    Because if not, we don't want to handle it. That is, we throw a `NotFoundHttpException`
    which results in a regular 404.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到这个方法的`$request`参数，你可能想知道它从哪里来。Drupal将当前请求对象传递给任何仅通过该类类型提示参数的控制器方法。因此，我们不需要将其注入到我们的控制器中。我们需要它的原因是我们可以检查对这条路由的请求是否是通过Ajax发起的。因为如果不是，我们不想处理它。也就是说，我们抛出一个`NotFoundHttpException`，这会导致常规的404错误。
- en: Then comes the fun stuff relating to the Ajax API, namely, the building of an
    `AjaxResponse` full of commands back to the browser. In our example, there is
    only one command which instructs it to run the jQuery `remove()` method on the
    elements that match the selector that is passed to it. In our case, this is the
    class of the block wrapper. And with this, our functionality is in place. We can
    clear our cache and the block should now print a link that removes the block via
    Ajax.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是关于Ajax API的有趣内容，即构建一个充满命令的`AjaxResponse`，这些命令将返回到浏览器。在我们的例子中，只有一个命令，它指示浏览器在匹配传递给它的选择器的元素上运行jQuery的`remove()`方法。在我们的情况下，这是块包装器的类。有了这个，我们的功能就到位了。我们可以清除缓存，现在块应该会打印出一个通过Ajax删除块的链接。
- en: 'You may be thinking: why do we need a trip back to the server for a job that
    can be done on the client-side alone? And the answer is—we actually don''t. However,
    it serves as a good example of how Ajax responses work. And I encourage you to
    check out the documentation page ([https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x](https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x)
    ) for the Ajax API, where you can find a list of all the available commands. For
    example, we could have used the `ReplaceCommand` to replace the block with something
    else that comes back from the server, or the `HtmlCommand` to insert some data
    into an element on the page, or even an `AlertCommand` to trigger a JavaScript
    alert with some data coming from the server. The cool thing is that the response
    can process multiple commands so we are not restricted to only using one.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：为什么我们需要回到服务器去完成本可以在客户端独立完成的工作？答案是——实际上我们不需要。然而，这作为一个很好的例子，说明了Ajax响应是如何工作的。我鼓励你查看Ajax
    API的文档页面([https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x](https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x)
    )，在那里你可以找到所有可用命令的列表。例如，我们可以使用`ReplaceCommand`来用从服务器返回的另一个块替换块，或者使用`HtmlCommand`在页面上插入一些数据，甚至使用`AlertCommand`触发一个带有来自服务器的数据的JavaScript警告。酷的地方在于响应可以处理多个命令，所以我们不受仅使用一个的限制。
- en: Ajax in forms
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单中的Ajax
- en: The most common use of Ajax in Drupal is through the Form API, where we can
    create dynamic interactions between the server and client with ease. To demonstrate
    how this works, we will go through an example. This will be a rework of the Importer
    configuration entity form we created in [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal中，Ajax最常用的用途是通过表单API，我们可以轻松地在服务器和客户端之间创建动态交互。为了演示这是如何工作的，我们将通过一个示例来展示。这将是对我们在[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，“你自己的自定义实体和插件类型”中创建的导入器配置实体表单的重构。
- en: If you remember, we said that tying certain configuration values to the generic
    entity does not make sense, as importer plugins might be different. The first
    Importer we wrote loads a JSON file from a remote URL. So, it stands to reason
    that the configuration value for the URL is tied to the plugin and not the configuration
    entity (even if the latter actually stores it). Because if we want to create a
    CSV importer, for example, we don't need the URL. So, let's refactor our work
    to make this happen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们说过将某些配置值绑定到通用实体是没有意义的，因为导入插件可能不同。我们编写的第一个导入器从远程URL加载JSON文件。因此，可以合理地认为URL的配置值绑定到插件而不是配置实体（即使后者实际上存储它）。因为如果我们想创建一个CSV导入器，例如，我们不需要URL。所以，让我们重构我们的工作来实现这一点。
- en: 'Here is an outline of the steps we need to take for this refactoring:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要采取的步骤的概述，以进行此重构：
- en: Importer plugins need to provide their own configuration form elements.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入器插件需要提供它们自己的配置表单元素。
- en: The Importer configuration form needs to read these elements depending on which
    plugin is selected (this is where the Ajax API comes into play).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入器配置表单需要根据所选的插件读取这些元素（这就是Ajax API发挥作用的地方）。
- en: We need to alter the storage and configuration schema of the values that are
    specific to plugins.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更改特定于插件的值的数据存储和配置架构。
- en: 'Let''s start by giving the `ImporterInterface` plugin type a new method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为`ImporterInterface`插件类型提供一个新方法开始：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is responsible for getting the form elements needed for this plugin. As
    an argument, it receives the Importer configuration entity, which can be inspected
    for default values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这负责获取此插件所需的表单元素。作为一个参数，它接收导入器配置实体，可以检查默认值。
- en: 'Next, on the `ImporterInterface` of the configuration entity, we need to remove
    the `getUrl()` method (since that is specific to the `JsonImporter` plugin) and
    replace it with a generic method for retrieving all the configuration values pertaining
    to the plugin selected for the entity:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在配置实体的`ImporterInterface`上，我们需要移除`getUrl()`方法（因为这是针对`JsonImporter`插件的特定方法）并替换为用于检索与实体选择的插件相关的所有配置值的通用方法：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And of course, in the importer entity class, we reflect this change as well
    (by replacing the `$url` property):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在导入器实体类中，我们也反映了这一变化（通过替换`$url`属性）：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And the actual getter method, in line with the interface:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的getter方法，与接口保持一致：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So far so good, nothing complicated going on. We are replacing the plugin-specific
    configuration values with a generic one in which values specific to the selected
    plugin will be stored. However, since our entity type no longer has the `$url`
    field but a `$plugin_configuration` one instead, we need to also adjust the `config_export`
    key in the annotation to reflect this change:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，没有复杂的事情发生。我们正在用通用配置值替换特定于插件的配置值，其中将存储特定于所选插件的值。然而，由于我们的实体类型不再有`$url`字段，而是有一个`$plugin_configuration`字段，因此我们还需要调整注解中的`config_export`键以反映这一变化：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s turn to the `ImporterForm` and make all the adjustments there.
    But before we do that, let''s move the form element for the `url` field into the
    `JsonImporter`, where we have to implement the new `getConfigurationForm()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向`ImporterForm`并对其进行所有调整。但在我们这样做之前，让我们将`url`字段的表单元素移动到`JsonImporter`中，在那里我们必须实现新的`getConfigurationForm()`方法：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You''ll notice some differences in getting the default value. Instead of calling
    the now-removed `getUrl()` method on the configuration entity, we use the new
    `getPluginConfiguration()` method and check inside the resulting array. Also,
    since we use the `$this->t()` method to ensure the translation of the strings,
    we should use the `StringTranslationTrait` as well (which can go inside the parent
    base class as it is a trait):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在获取默认值时有一些差异。我们不再在配置实体上调用已删除的`getUrl()`方法，而是使用新的`getPluginConfiguration()`方法并在结果数组内部进行检查。另外，由于我们使用`$this->t()`方法来确保字符串的翻译，我们还应该使用`StringTranslationTrait`（它可以放在父基类中，因为它是一个特质）：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s not forget that we are actually using the URL in the import, so we need
    to make some adjustments to the `getData()` method as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记，我们实际上在导入时使用了URL，因此我们还需要对`getData()`方法做一些调整：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this in place, we can go ahead and adjust our `ImporterForm` (where we
    no longer have the form element for the URL field).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以继续调整我们的`ImporterForm`（其中我们不再有URL字段的表单元素）。
- en: 'There are two main things we need to do:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的主要有两件事：
- en: Expose the plugin selection element to Ajax, that is, trigger an Ajax request
    when the user makes a selection
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将插件选择元素暴露给Ajax，即当用户做出选择时触发Ajax请求
- en: Add the extra elements to the form depending on the chosen plugin
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据选择的插件添加额外的元素到表单中
- en: 'This is what the new `plugin` element looks like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`plugin`元素看起来是这样的：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two noticeable changes: we''ve added an `#empty_option` key (to be
    used as the option shown if the user has not made a choice) and the `#ajax` key
    (which we will discuss in a bit more detail).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个显著的变化：我们添加了一个`#empty_option`键（用于在用户未做出选择时显示的选项）和一个`#ajax`键（我们将在下面更详细地讨论）。
- en: 'What we did is pretty simple. We declared a callback method to be triggered
    when a user makes a change to this form element, and we declared the HTML ID of
    the element that should be replaced with the result of the Ajax callback. And
    in the latter (which is a simple method on the same class), all we have to do
    is this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是相当简单的。我们声明了一个回调方法，当用户更改此表单元素时将被触发，并声明了应该用Ajax回调的结果替换的元素的HTML ID。在后者（这是同一类的一个简单方法）中，我们只需做以下操作：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We return a form element (which we still have to define). An important lesson
    here is that Ajax responses in forms can return content as well (in the form of
    render arrays or even strings), which will be used to replace the HTML found by
    the ID specified in the `wrapper` key of the Ajax declaration. Alternatively,
    an `AjaxResponse` full of commands can also be returned to do more complex things,
    as we saw in the previous section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个表单元素（我们仍然需要定义）。在这里的一个重要教训是，表单中的Ajax响应可以返回内容（以渲染数组或字符串的形式），这将用于替换Ajax声明中`wrapper`键指定的ID找到的HTML。或者，也可以返回一个充满命令的`AjaxResponse`以执行更复杂的事情，就像我们在上一节中看到的那样。
- en: 'Before we look at this new `plugin_configuration` form element, let''s look
    at some of the other options that can be used inside the `#ajax` array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这个新的`plugin_configuration`表单元素之前，让我们看看可以在`#ajax`数组内部使用的其他一些选项：
- en: '`method`: This indicates the jQuery method to use when interacting with the
    `wrapper` element (if specified). The default is `replaceWith()`, but you can
    also use `append()`, `html()`, and others.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：这表示与`wrapper`元素交互时要使用的jQuery方法（如果指定）。默认是`replaceWith()`，但您也可以使用`append()`、`html()`等。'
- en: '`event`: This shows which event should be used to trigger the Ajax call. By
    default, the form element in question decides that. For example, when selecting
    an option in a select element or when typing something into a textfield.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`: 这表示应该使用哪个事件来触发Ajax调用。默认情况下，相关的表单元素会做出这个决定。例如，当在选择元素中选择一个选项或向文本字段中输入内容时。'
- en: '`progress`: This defines the indicator to be used while the Ajax request is
    taking place.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progress`: 这定义了在Ajax请求进行时使用的指示器。'
- en: '`url`: A URL to trigger the Ajax request in case the `callback` was not specified.
    Typically, using the latter is more powerful as the entire `$form` and `$form_state`
    are passed as parameters and can be used in processing.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 如果未指定`callback`，则触发Ajax请求的URL。通常，使用后者更强大，因为整个`$form`和`$form_state`作为参数传递，并可用于处理。'
- en: I recommend you check out the documentation page ([https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x](https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x))
    for the Ajax API for more information about these options and the other ones that
    are available.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你查看文档页面([https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x](https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x))，以获取有关这些选项和其他可用选项的更多信息。
- en: 'With that out of the way, we can go back to our form definition and add our
    missing parts, right after the `plugin` element:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，我们可以回到我们的表单定义，并在`plugin`元素之后添加我们缺失的部分：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we define the `plugin_configuration` form element as a `hidden` type.
    This means it will not be visible to users when the page loads for the first time.
    However, we do use the `#prefix` and `#suffix` options (common practice with the
    Drupal Form API) to wrap this element with a div that has the ID we indicated
    as the `wrapper` of our Ajax declaration. So, the goal is to have this element
    replaced each time an Ajax request is made, that is, each time a plugin is selected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`plugin_configuration`表单元素定义为`hidden`类型。这意味着当页面首次加载时，用户将看不到它。然而，我们确实使用了`#prefix`和`#suffix`选项（与Drupal表单API的常见做法）来用具有我们指示的ID的div包装这个元素，作为我们的Ajax声明的包装器。所以，目标是每次进行Ajax请求时（即每次选择插件时）替换这个元素。
- en: Next, we try to get the ID of the chosen plugin. First, we load it from the
    configuration entity in case we are looking at an edit form. However, we also
    check in the form state to see if one has been selected (and is different from
    the one in the entity). And if you are wondering how we can have the plugin in
    the form state, the answer is that after an Ajax call is made (triggered by the
    user selecting a plugin), the form gets rebuilt. Now, we can see what's in the
    form state and retrieve the plugin ID that was chosen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试获取所选插件的ID。首先，如果我们在查看编辑表单，我们会从配置实体中加载它。然而，我们也会检查表单状态，看看是否已经选择了一个（并且与实体中的不同）。如果你想知道我们如何在表单状态中拥有插件，答案是：在用户选择插件后触发Ajax调用后，表单会被重建。现在，我们可以看到表单状态中的内容，并检索所选的插件ID。
- en: 'Even more than that, if we get our hands on a plugin ID, we can completely
    change the `plugin_configuration` element, which in turn then gets returned by
    the Ajax callback to be used to replace our wrapper. So to sum up:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果我们获得了插件ID，我们可以完全更改`plugin_configuration`元素，这反过来又会被Ajax回调返回，用于替换我们的包装器。所以总结一下：
- en: The page loads for the first time (on a new form). The element is hidden.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面首次加载（在新的表单中）。元素被隐藏。
- en: The user selects a plugin and an Ajax request is triggered, which rebuilds the
    form.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择一个插件并触发Ajax请求，这会重建表单。
- en: As the form is rebuilt, we check for the selected plugin and alter the `plugin_configuration`
    element to reflect the selected plugin.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当表单重建时，我们会检查所选插件，并修改`plugin_configuration`元素以反映所选插件。
- en: The Ajax response replaces the old element with the new, potentially changed,
    one.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ajax响应会用新的、可能已更改的元素替换旧的元素。
- en: The new `plugin_configuration` element becomes a `details` one (a collapsible
    container for multiple elements), open by default, and which has one key, called
    `plugin`, onto which we add all the elements coming from the plugin. Moreover,
    we use the `#tree` property to indicate that when the form is submitted, the values
    of the elements are sent and stored in a tree that reflects the form element (a
    multidimensional array, basically). Otherwise, the form state values that are
    submitted get flattened and we lose their connection to the `plugin_configuration`
    element (which is also the Importer configuration entity field name we want to
    store the data under).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`plugin_configuration`元素变成了一个`details`元素（一个可折叠的容器，用于多个元素），默认打开，并且有一个名为`plugin`的键，我们将所有来自插件的元素添加到这个键上。此外，我们使用`#tree`属性来指示，当表单提交时，元素的值会被发送并存储在一个反映表单元素的树中（基本上是一个多维数组）。否则，提交的表单状态值会被扁平化，我们就会失去它们与`plugin_configuration`元素（这也是我们想要存储数据的导入器配置实体字段名称）的关联。
- en: We are almost there. We can already go and create an importer entity, and when
    we select the JSON Importer, the new fieldset containing the URL field should
    show up below. But we still have one problem. If we save the form, the URL value
    will be stored inside an array keyed by `plugin`, inside the `plugin_configuration`
    field. So we need to clean things up a bit and we can do so inside the `save()`
    method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。我们可以创建一个导入器实体，并且当我们选择JSON导入器时，包含URL字段的新的字段集应该会显示在下面。但我们仍然有一个问题。如果我们保存表单，URL值将存储在`plugin_configuration`字段中，以`plugin`为键的数组内。因此，我们需要稍微整理一下，我们可以在`save()`方法中这样做。
- en: 'Right before saving the entity, we can do this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存实体之前，我们可以这样做：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, we basically move the values one array up, removing the superfluous `plugin`
    level in the array (which was only needed to neatly organize the form tree).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上将值向上移动一个数组，从数组中移除多余的`plugin`级别（这只是为了整齐地组织表单树）。
- en: With this, we are done. Well, not really, as we still need to handle the configuration
    schema aspect. Yes, remember those from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*? We are now going to see how we can
    work with our own dynamic configuration schema, similar to how we did with the
    ones needed for the field plugins in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*. But why do we need a dynamic configuration schema?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了。嗯，实际上还没有，因为我们仍然需要处理配置模式方面。是的，还记得第6章[数据建模和存储](77cab458-5612-468c-8010-12385708eb81.xhtml)和第7章[自定义实体和插件类型](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)中的那些吗？我们现在将看到我们如何处理自己的动态配置模式，类似于我们在第9章[自定义字段](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml)中处理字段插件所需的方式。但为什么我们需要一个动态配置模式呢？
- en: Before this refactoring, we knew the exact fields of the importer configuration
    entity and we could declare the schema for each easily (as we did). However, now
    plugins can come with their own individual fields, so we need to make sure they
    can provide their own schema definitions for the respective data. So how can we
    do this?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构之前，我们知道导入器配置实体的确切字段，并且可以轻松地为每个字段声明模式（就像我们做的那样）。然而，现在插件可以带有它们自己的单个字段，因此我们需要确保它们可以为相应数据提供自己的模式定义。那么我们如何做到这一点呢？
- en: 'First, inside our `importer.schema.yml` file, we need to remove the `url` field
    schema definition as it no longer exists. We replace it, however, with one for
    the new field we created, namely the `plugin_configuration` array of values that
    came from the plugin:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的`importer.schema.yml`文件中，我们需要移除`url`字段模式定义，因为它已经不存在了。然而，我们用我们创建的新字段替换它，即来自插件的`plugin_configuration`值数组：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here is where things become interesting. We don't know what fields there will
    be inside, so we instead reference another type (our own). Moreover, the name
    of the type is dynamic. We have a prefix (`products.importer.plugin.`) followed
    by a variable name given by the value of the plugin field of the parent *(*the
    main configuration entity*)*. So basically, if a given configuration entity uses
    the `json` plugin, the type of schema definition will be `products.importer.plugin.json`.
    So now, it's the responsibility of whoever creates new plugins to also provide
    their own schema definitions for their own fields (like we did in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields,* when we defined field plugins).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得有趣。我们不知道里面会有哪些字段，所以我们引用了另一个类型（我们自己的）。此外，类型的名称是动态的。我们有一个前缀（`products.importer.plugin.`）后面跟着由父插件字段（*主要配置实体*）的值给出的变量名。所以基本上，如果一个给定的配置实体使用了`json`插件，模式定义的类型将是`products.importer.plugin.json`。因此，现在，创建新插件的人也有责任为其自己的字段提供自己的模式定义（就像我们在[第9章](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml)，*自定义字段*）中定义字段插件时做的那样）。
- en: 'But before that can happen, we need to define this new type we created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那之前，我们需要定义我们创建的新类型：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So essentially our new type extends from `mapping` and has a simple label. Of
    course, it applies to all that start with that name (hence the wildcard we encountered
    before).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，本质上，我们的新类型扩展自`mapping`并有一个简单的标签。当然，它适用于所有以该名称开头的东西（这就是我们之前遇到的通配符的原因）。
- en: 'Now, we can add the schema definition for our single `json` Importer plugin:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的单个`json`导入插件添加模式定义：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we now have our first instance of the `products.importer.plugin`
    type, which contains the `url` field and which is inside the `plugin_configuration`
    field of the configuration entity—reflecting a simple array hierarchy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有了`products.importer.plugin`类型的第一个实例，它包含`url`字段，位于配置实体的`plugin_configuration`字段中——反映了一个简单的数组层次结构。
- en: But the point of this dynamic declaration is that other modules that define
    new plugins can now also define their own instances of the `products.importer.plugin.*`
    schema definitions to map their own fields. It is no longer the responsibility
    of the configuration entity (schema) to "guess" what field types are being used
    on each plugin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个动态声明的目的是，其他定义新插件的模块现在也可以定义自己的`products.importer.plugin.*`模式定义的实例来映射它们自己的字段。不再是由配置实体（模式）来“猜测”每个插件正在使用哪些字段类型。
- en: With this, our refactoring is complete. Drupal is well aware of the type of
    data the configuration entity is saving, even if it is in part relating to external
    input (the selected plugin). So that means we can create (if we want) another
    importer plugin that uses a CSV file for the product data. But we'll see how to
    do that in a later chapter when we talk about file handling.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的重构就完成了。Drupal清楚地知道配置实体正在保存的数据类型，即使它部分与外部输入（选定的插件）相关。这意味着我们可以创建（如果我们想的话）另一个使用CSV文件的产品数据的导入插件。但我们将如何在后面的章节中讨论文件处理时看到如何做。
- en: States (Form) system
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态（表单）系统
- en: The last thing we are going to look at in this chapter is the States system
    of the Form API (not to be confused with the State API we covered in [Chapter
    6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and Storage*).
    This allows us to define our form elements to behave somewhat dynamically based
    on the user interaction with the form. It doesn't use Ajax but relies on JavaScript
    to handle the manipulations. This is another great example of client-side behavior
    where we don't have to write a single line of JavaScript. So, let's see what this
    is.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将最后探讨Form API的状态系统（不要与我们在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)，*数据建模和存储*）混淆）。这允许我们根据用户与表单的交互动态地定义我们的表单元素。它不使用Ajax，而是依赖于JavaScript来处理操作。这是另一个客户端行为的绝佳例子，我们不需要写一行JavaScript。所以，让我们看看这是什么。
- en: 'The `#states` are simple properties we can add to form elements, which have
    the role of changing them depending on the *state* of other elements. The best
    way to understand this is through some examples. Imagine these two form elements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`#states`是我们可以添加到表单元素中的简单属性，它们根据其他元素的*状态*来改变它们。理解这个概念最好的方式是通过一些例子。想象这两个表单元素：'
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the first, we ask the user if they have kids (using a simple checkbox),
    while in the second ,we ask them how many kids they have. But why should the user
    actually see the second element if they don''t have kids? This is where the `#states`
    property comes into play, and its role is to manipulate an element depending on
    the *state* of another. So instead, we can have this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们询问用户是否有孩子（使用简单的复选框），而在第二种情况下，我们询问他们有多少孩子。但为什么如果用户没有孩子，他们实际上应该看到第二个元素呢？这就是`#states`属性发挥作用的地方，它的作用是根据另一个元素的*状态*来操纵一个元素。所以，我们可以这样：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the element for specifying the number of kids is only going to be visible
    if the *state* of the `kid` element is checked.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，指定孩子数量的元素只有在`kid`元素的*状态*被选中时才会可见。
- en: The `#states` property is an array whose key is the actual *state* that needs
    to be applied to the current element if the conditions inside are met. And the
    conditions can vary, but they all depend on a CSS selector (in our case `input[name="kids"]`
    matching another element).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`#states`属性是一个数组，其键是如果条件内部满足，需要应用到当前元素的实际情况。条件可以变化，但它们都依赖于一个CSS选择器（在我们的例子中是`input[name="kids"]`匹配另一个元素）。'
- en: 'Our example can also be written with this reverse logic:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子也可以用这种逆向逻辑来写：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Apart from `visible` and `invisible`, the following *states* can be also applied
    to form elements: `enabled`, `disabled`, `required`, `optional`, `checked`, `unchecked`,
    `expanded` and `collapsed`. As for the conditions that can "trigger" these *states*,
    we can have the following (apart from `checked`, which we already saw): `empty`,
    `filled`, `unchecked`, `expanded`, `collapsed` and `value`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`visible`和`invisible`之外，以下*状态*也可以应用到表单元素上：`enabled`、`disabled`、`required`、`optional`、`checked`、`unchecked`、`expanded`和`collapsed`。至于可以“触发”这些*状态*的条件，我们可以有以下几种（除了我们之前看到的`checked`）：`empty`、`filled`、`unchecked`、`expanded`、`collapsed`和`value`。
- en: So, for example, we can even control the *state* of an element depending on
    the value the user selected on another. Combining these possibilities can greatly
    improve our forms when it comes to user experience, decluttering, and even building
    logical form trees.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们甚至可以根据用户在另一个元素上选择的值来控制一个元素的*状态*。结合这些可能性可以极大地改善我们的表单，在用户体验、整理甚至构建逻辑表单树方面。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took on the client-side and talked about JavaScript and
    client-side capabilities in Drupal 8\. We started with the approach we need to
    take when writing JavaScript in a Drupal context. We learned about behaviors,
    why they are important, and how to use them. We also saw how we can pass around
    data from the server (Drupal) to the client-side and make use of it in JavaScript.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注了客户端，并讨论了Drupal 8中的JavaScript和客户端功能。我们首先讨论了在Drupal环境中编写JavaScript时需要采取的方法。我们学习了行为、为什么它们很重要以及如何使用它们。我们还看到了如何从服务器（Drupal）传递数据到客户端，并在JavaScript中使用它。
- en: Funnily enough, we then switched to a no-JavaScript-allowed policy for the rest
    of the chapter. We did this to prove how powerful the Drupal Ajax API is, with
    which we can perform complex server-to-client interactions even if we are not
    frontend developers that can write JavaScript code. And to demonstrate the API,
    we first looked at how simple links can be turned into Ajax requests. We followed
    that up with an important refactor of our earlier product importer functionality
    which relied on Ajax to make the Importer configuration entity form dynamic (dependent
    on the selected plugin). Let's not forget another nugget of information—dynamic
    configuration schema—which allows us to decouple the configuration entity data
    definitions from that of their selected plugins.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，我们随后将本章的其余部分改为不允许使用JavaScript的策略。我们这样做是为了证明Drupal Ajax API的强大功能，即使我们不是能够编写JavaScript代码的前端开发者，我们也能使用它来执行复杂的客户端到服务器的交互。为了展示这个API，我们首先看了如何将简单的链接转换为Ajax请求。接着，我们对之前的产品导入功能进行了重要的重构，该功能依赖于Ajax来使导入配置实体表单动态化（依赖于所选的插件）。别忘了另一个信息亮点——动态配置模式，它允许我们将配置实体数据定义与其所选插件的数据定义解耦。
- en: Finally, we finished by looking at the States system of the Form API which allows
    us to declaratively code client-side manipulations onto our form elements, essentially
    making them dependent on the user's interaction with the form.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看表单API的States系统来结束讨论，该系统允许我们将客户端操作声明性地编码到我们的表单元素上，本质上使它们依赖于用户的表单交互。
- en: In the next chapter, we are going to talk about internationalization and translations
    to make sure our applications can be used anywhere around the globe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论国际化与翻译，以确保我们的应用程序可以在全球任何地方使用。
