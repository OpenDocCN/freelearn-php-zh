<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Clever Website Coordination Using the PEAR Installer"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Clever Website Coordination Using the PEAR Installer</h1></div></div></div><p>In the last two chapters, we learned how to use the PEAR installer's features to manage libraries and applications for public distribution. In this chapter, we'll learn how the PEAR installer can be used to make managing the contents of a complex and rapidly evolving website easy. In fact, the PEAR installer can be used to provide an extra level of insurance that a website will function as expected, and even make diagnosing problems easier.<a id="id200" class="indexterm"/>
</p><p>In this chapter, we'll begin by understanding the details of our problem at a high level, and seeing how PEAR installer can help us to solve it. Then we'll look at the first step of the solution, setting up the source control system, and we will finally finish off with managing the complexity of a multi-segment website using a live site as an example.</p><div class="section" title="Overview of the Problem"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Overview of the Problem</h1></div></div></div><p>One of the most important tasks is keeping the structure of a complex and dynamic website coherent and up to date as the information represented evolves. In many cases, re-organization may result in files that are no longer in use cluttering the directory layout. Worse, when deleting unused files, there is a risk of accidentally removing an essential file without realizing it. In addition, coordinating a multi-developer modular website presents an obvious challenge: how does one prevent conflicts in updates and additions?<a id="id201" class="indexterm"/>
</p><p>In conjunction with a revision control system such as CVS (Concurrent Versions System), the PEAR installer provides a unique and battle-tested solution to manage all of these problems effectively. Revision control systems provide a combination of redundancy and flexibility that cannot be matched by simple file systems. The ability to check out a personal<span class="strong"><strong> sandbox</strong></span> in which to do development without the fear of disrupting the primary code base is an essential part of any serious code development.<a id="id202" class="indexterm"/>
</p><p>Traditionally, branches (CVS and Subversion) and tags (CVS only) are used to document "release points", where a program is ready for usage. For instance, PEAR version 1.4.5 can be retrieved directly from<code class="literal"> cvs.php.net</code> via these commands:<a id="id203" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :pserver:anoncvs@cvs.php.net:/respository login
Password:&lt;enter your email address&gt;
$ cvs -d :pserver:anoncvs@cvs.php.net:/respository co r RELEASE_1_4_5 pear-core
</strong></span>
</pre></div><p>This sequence checks out the source of the PEAR installer, which is located at<code class="literal"> cvs.php.net</code> in<code class="literal"> /repository/pear-core</code>, and then retrieves the tag<code class="literal"> RELEASE_1_4_5</code>, which was set at the release time of PEAR version 1.4.5 via the convenient<code class="literal"> cvstag</code> command (covered in depth later in the chapter):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear cvstag package2.xml package-PEAR.xml tests</strong></span>
</pre></div><p>The above example is the most complex possible command. In most cases, a developer can tag a package simply with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear cvstag package.xml
</strong></span>
</pre></div><p>Of course, the PEAR installer and a revision control system is only as effective as the coordinating plan behind them, and so devising a good strategy for developing the website in conjunction with the two tools is an essential part of the equation, and is covered in the last segment of this chapter.<a id="id204" class="indexterm"/>
</p><p>Using a<span class="strong"><strong> roadmap</strong></span> or a development timeline describing approximately when new features will be added and old ones removed is a good first step. Defining ways in which developers should coordinate and synchronize their efforts is another. Using design tools and strategies such as UML and extreme programming (test-driven development and its friends) may also be of use, but ultimately the clarity of thought present in the website architects' design goals is usually far more significant, and will lead to the best solution, regardless of the tools chosen to get there.<a id="id205" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"/>Tip</h3><p>The primary problem we will address is how to coordinate a complex website, specifically, how to safely and systematically update the live website from a development machine.</p></div></div></div>
<div class="section" title="Understanding the Problem"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Understanding the Problem</h1></div></div></div><p>To understand the solution to a problem, it makes sense that we should understand the problem at a high level. In our case, it is important to understand the main issues that surround coordinating the development of a major website. A good website will draw users back to view it as often as possible, developing a community. This will only happen if there is both exciting content and pleasing visual and logical layout. Often, content can be updated without changing any code (think of blogs or content management systems), but changing the visual layout and logical structure of a site requires more extensive internal changes to a site.<a id="id206" class="indexterm"/>
</p><p>Even if you design the perfect site on the first attempt (congratulations!) and have a simple method for adjusting the content and even the logical structure of a site, this may lead to the largest challenge of transitioning from a small website to a hugely successful website with thousands of hits per minute:<span class="strong"><strong> scalability</strong></span>. Often at this stage, a comprehensive redesign may be necessary to accommodate unexpected needs. Success inevitably leads to the need for bringing on new developers who may be unfamiliar with the website structure or design goals. The constant threat of re-factoring to improve things also threatens to bring unexpected chaos to even the best-intentioned web team.</p><p>All of this uncertainty will lead to greater potential for breakage of code, confusing and cluttered directory structure, and other problems.</p><p>We'll look at four typical problem areas, and get a better picture of how PEAR Installer will help us:<a id="id208" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing code breakage and reverting to a previous version</li><li class="listitem" style="list-style-type: disc">Managing missing or extraneous files</li><li class="listitem" style="list-style-type: disc">Coordinating development with a team of developers</li><li class="listitem" style="list-style-type: disc">Backing up code: redundancy as a necessary precaution</li></ul></div><div class="section" title="Managing Code Breakage and Reverting to Previous Versions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>Managing Code Breakage and Reverting to Previous Versions</h2></div></div></div><p>Occasionally, it becomes apparent that in spite of careful design and even more careful testing, something in a recent update has broken a critical portion of a website. Even worse, a security breach may have resulted in a rogue hacker destroying a carefully worked out web structure.<a id="id209" class="indexterm"/>
</p><p>In the past, this could mean hoping that a restore from backup would do the trick. In some cases, a hack was not noticed for a long time, requiring restoration from an early backup. This can result in tremendous difficulty determining the correct files to transfer and delete.</p><p>The PEAR installer manages these problems in a tremendously efficient manner. Instead of spending feverish hours going over each directory by hand, two commands are sufficient to completely remove and restore the most current website structure:<a id="id210" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ rm -rf /path/to/htdocs
$ pear upgrade --force WebSite-1.2.3.tgz
</strong></span>
</pre></div><p>The difference in complexity between this and a frantic "<span class="emphasis"><em>is-everything-all-right-oops-I-need-to-restore-that-file-and-delete-this-one</em></span>" is staggering.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"/>Tip</h3><p><span class="strong"><strong>PEAR Installer or rsync?</strong></span></p><p>Experienced web developers should also know about the<code class="literal"> rsync</code> command, which facilitates remote synchronization of directories on machines separated by a great distance. In many cases, this is a very efficient way of ensuring that local and remote repositories are in sync. However, if you are coordinating between several developers, or developing some portions of a site while others are stable, it may cause more difficulty than ease. In this case, you will benefit more from the strengths of the versioning and simple reversion provided by the PEAR installer.</p></div></div><div class="section" title="Managing Missing or Extraneous Files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Managing Missing or Extraneous Files</h2></div></div></div><p>Theoretically, problems of missing or extra files should never happen if you fully test a website on a development machine prior to upload, but there are times when a mistake in a<code class="literal"> rsync</code> transfer occurs and files are removed that should not be. In the best-case scenario, this will result in the immediate breakage of the site, and will be easily tracked down and fixed. In the worst case, however, the breakage may be subtle, and in fact not apparent until a rare but crucial task is performed by one of your website's end users or a hacker discovers a security vulnerability in an unused file. This can lead to scaring off users, lost profits for commercial websites, or even legal problems if your site was used by a hacker to commit a crime and negligence on your part can be proven.<a id="id211" class="indexterm"/>
</p><p>How are these problems any different when managing a website using the PEAR installer? There are two features of the PEAR installer that set it apart from traditional solutions:<a id="id212" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Versioning</li><li class="listitem" style="list-style-type: disc">File Transactions</li></ul></div><p>Through the concept of versioning, it is possible to determine precisely which files are present by either examining the contents of<code class="literal"> package.xml</code> or by running the<code class="literal"> list-files</code> command like so:<a id="id213" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear list-files mychannel/PackageName
</strong></span>
</pre></div><p>Missing or extraneous files are easily detectable with this system without the need to resort to a slow recursive check of actual directories. In addition, the ability to quickly revert to an earlier version, even temporarily, and then restore a newer fixed version is also incredibly simple, as evidenced by this sample command sequence:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force mychannel/PackageName-1.0.2
&lt;after fixing things&gt;
$ pear upgrade mychannel/PackageName
</strong></span>
</pre></div><p>The PEAR installer takes advantage of a concept from relational databases and implements transaction-based file installation and removal. This means that no changes to the directory structure occur until all have been successfully completed. In addition, atomic file operations are performed whenever possible. The life cycle of a file is rather simple, and consists of these steps:<a id="id214" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">File<code class="literal"> path/to/foo.php</code> is installed as<code class="literal"> /path/to/pear/path/to/.tmpfoo.php</code></li><li class="listitem" style="list-style-type: disc">File<code class="literal"> /path/to/pear/path/to/foo.php</code> if present, is renamed to<code class="literal"> /path/to/pear/path/to/foo.php.bak</code>.</li><li class="listitem" style="list-style-type: disc">File<code class="literal"> /path/to/pear/path/to/.tmpfoo.php</code> is renamed to<code class="literal"> /path/to/pear/path/to/foo.php</code>.</li></ul></div><p>After installation, all of the<code class="literal"> .bak</code> files created are removed.</p><p>However, if there is a problem at any step along the way, the installed files are removed, and the<code class="literal"> .bak</code> files are renamed to the original filename. In this way, it is possible to very safely manage file upgrades. Additional checks are performed to ensure that the installer is capable of writing to the directory of the installation, and that the files are actually installed as expected. All of this extra work helps to guarantee the success of an installation.</p></div><div class="section" title="Coordinating Development with a Team of Developers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>Coordinating Development with a Team of Developers</h2></div></div></div><p>The PEAR installer also helps coordinate a team of web developers in two ways:<a id="id215" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discrete packaging</li><li class="listitem" style="list-style-type: disc">File conflict resolution</li></ul></div><p>
<span class="strong"><strong>Discrete packaging</strong></span> simply means that each developer or sub-team's set of files can occupy its own package and be installed/upgraded independently of the others. In addition, they can all be managed from a central package using dependencies.<a id="id216" class="indexterm"/>
</p><p>
<span class="strong"><strong>File conflict resolution</strong></span> solves the potential for accidentally overwriting files from another team and makes it possible to share directory space safely. The PEAR installer does not allow different packages to conflict with any files from other packages. This simple technical fact will augment your team's file naming conventions with an additional layer of error-checking.<a id="id217" class="indexterm"/>
</p><p>Even when the<code class="literal"> --force</code> option is specified, file conflict resolution is used. Only the dangerous<code class="literal"> --ignore-errors</code> option overrides file conflict checking.</p></div><div class="section" title="Backing Up Code: Redundancy as a Necessary Precaution"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>Backing Up Code: Redundancy as a Necessary Precaution</h2></div></div></div><p>Managing a website using the PEAR installer provides what is perhaps a less obvious benefit by duplicating the code. The need to back up code from a website is often thought of only in terms of keeping a duplicate of the entire site. This is important, but may not be enough. The ability to quickly restore corrupted segments of a website, if only a few files are corrupted, is again quite simple with the PEAR installer; one only needs to run:<a id="id218" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force mychannel/MyPackage
</strong></span>
</pre></div><p>In addition, the storage of website code as packaged archives at the channel server provides an additional level of redundancy above and beyond the redundancy provided by source control and traditional full back-up methods.</p><p>Now that we know the problem areas and how PEAR installer can help us deal with them, let's get into the solution in detail.</p></div></div>
<div class="section" title="The Solution, Part I: All-Important Source Control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>The Solution, Part I: All-Important Source Control</h1></div></div></div><p>Before taking advantage of the PEAR installer, it is important to set up a source control system. There are many fine commercial software programs that can be used to perform source control, including<span class="strong"><strong> Perforce</strong></span> and<span class="strong"><strong> Visual SourceSafe</strong></span>, but we will focus on the tried and true, free open-source revision control systems:<span class="emphasis"><em> CVS</em></span> and <span class="strong"><strong> Subversion</strong></span>.<a id="id219" class="indexterm"/>
</p><p>
<span class="strong"><strong>CVS</strong></span> (<span class="strong"><strong>Concurrent Versioning System</strong></span>) is one of the oldest source-control products, and is based on the even older<span class="strong"><strong> RCS</strong></span> (<span class="strong"><strong>Revision Control System</strong></span>) source control program. CVS implements its source control by using a client-server model. The server contains the final code, organized into directories and files. However, on the server, each file actually contains a full revision history of that file. On the client end, users check out a local <span class="strong"><strong> sandbox</strong></span> — a copy of the server code, which can then be developed independently of other developers. When the code is ready to be committed to the server, the user sends a special command to the server. At that time, the server checks to see if there have been any changes to the repository by other users, and if so, prevents the conflict that may occur. Conflict resolution between users' commits is fully supported, as well as merging compatible changes.<a id="id220" class="indexterm"/>
</p><p>Although CVS does a very good job, there are a few limitations that prompted the Subversion development team to begin work on a new model. Like CVS, Subversion provides the same collaborative tools. The difference is in how Subversion stores its information. Using a Berkeley database file to document changes and revisions (or in the latest releases, the FSFS file-based database), Subversion has the capability to track changes to groups of files and directories as well as to individual files, something that is far more difficult to do with CVS. In addition, Subversion stores a complete copy of the server code in the client sandbox, allowing for very efficient use of bandwidth when performing actions such as checking changes and making patches.<a id="id222" class="indexterm"/>
</p><div class="section" title="Providing Redundancy and Revision History"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Providing Redundancy and Revision History</h2></div></div></div><p>The primary benefit of a source control system is the combination of redundancy and revision history. Source control systems are designed around the principle of human fallibility: we just make mistakes sometimes, and it is important to be able to recover from those mistakes as easily as possible. Through the redundancy provided by separating a developer sandbox from the server repository, it becomes possible to quickly recover from a mistake on the developer's machine. The existence of revision history, and CVS/Subversion's sophisticated ability to check out code from a particular point in time, or a particular tag or branch, mean that it is also a simple matter to revert a faulty commit, or change to the server repository.<a id="id223" class="indexterm"/>
</p></div><div class="section" title="Installing CVS or Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Installing CVS or Subversion</h2></div></div></div><p>In most cases, setting up a revision control system is easy. This text is not the best resource for installation, but does cover the basics. For extended support, it is best to consult the support resources of CVS or Subversion directly.<a id="id224" class="indexterm"/>
</p><p>In the next few sections, you will learn how to initialize a repository in CVS or Subversion and to create new projects within the repository, and how to create a local sandbox for development. There are a few prerequisites for setting up a revision control system. It is important that you have access to a shell on the host for which you wish to set up the revision control system. If you do not have access to the file system, it will be exceedingly difficult to fix any problems with the repository.<a id="id225" class="indexterm"/>
</p><p>If you do not have shell access to your remote host, and do not have the resources to switch to an internet provider that does provide shell access, all is not lost.</p><p>On Windows-based systems, it is very easy to set up a local repository using the freeware TortoiseCVS or TortoiseSVN programs, and on unix-based systems like Mac OS X or Linux, you can compile and use the CVS and Subversion tools directly to initialize a repository. The only drawback to this approach is that you lose some of the fail-safe advantages of having a remote repository.<a id="id226" class="indexterm"/>
</p><p>In either case, remote or local repository, you will need to make regular backups of the system to avoid trouble in case of catastrophic hardware failure or other unpleasant truths of Murphy's Law.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"/>Tip</h3><p><span class="strong"><strong>Here is Murphy's Law:</strong></span></p><p>"If anything can go wrong, it will."</p><p>Always plan for problems — Hardware failure, data corruption, and security breaches just begin the list of issues plaguing our work.</p></div><div class="section" title="Concurrent Versions System"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Concurrent Versions System</h3></div></div></div><p>Concurrent Versions System (CVS) is hosted at  <a class="ulink" href="http://www.nongnu.org/cvs/">http://www.nongnu.org/cvs/</a> and is the oldest form of revision control. CVS is very stable, and has been stable for years. As such, it is the old warhorse of revision control, having stood the test of time. CVS is based on a very simple file-based revision control. In the repository, each file contains content and metadata containing differences between revisions. The repository should never be used for direct access or work. Instead, a complete copy of a directory is checked out for development. No changes are saved to the main repository until you check in or commit the code.<a id="id227" class="indexterm"/>
</p><p>CVS is designed to coordinate the work of multiple developers, and as such has the capability to refuse a commit if there may be a conflict between the work of two different developers. Let's look at an example.<a id="id228" class="indexterm"/>
</p><p>The PHP repository has several modules hosted by<code class="literal"> cvs.php.net</code>, which are organized like a file system. To check out a module, you must first log into the CVS server. Users with accounts will use their account name, but PHP also provides anonymous read-only CVS access. To log into the CVS server, one types:<a id="id229" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :pserver:cvsread@cvs.php.net:/repository login
</strong></span>
</pre></div><p>At this point, the<code class="literal"> cvs</code> command will prompt for a password. For anonymous CVS access, enter your email address. Once you are logged in, check out a module. For instance, to view the source of the PEAR_PackageFileManager package, you would type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :pserver:cvsread@cvs.php.net:/repository checkout pear/ PEAR_PackageFileManager
</strong></span>
</pre></div><p>This command creates the directory<code class="literal"> pear</code> and subdirectory<code class="literal"> PEAR_PackageFileManager</code>, and populates them with all the files and directories contained within the project. In addition, it creates special directories named<code class="literal"> CVS</code> that contain information about the state of the local copy of the repository. Each directory must contain files named<code class="literal"> Entries, Root</code>, and<code class="literal"> Repository</code>. Depending on the state of the repository, there may be other files as well. These files should<span class="emphasis"><em> never</em></span> be hand-altered except in extreme circumstances, but it is important to know what controls your CVS checkout.<a id="id230" class="indexterm"/>
</p><p>For more information and help on using CVS, it is probably good to start by reading the<span class="emphasis"><em> manpage on unix</em></span> via<code class="literal"> man cvs</code>, and to read the CVS book published by O'Reilly and distributed online under the GNU General Public Licence at <a class="ulink" href="http://cvsbook.red-bean.com/"> http://cvsbook.red-bean.com/</a>.</p><p>On Windows, it is probably easiest to use a tool like<span class="strong"><strong> TortoiseCVS</strong></span>, which is available from <a class="ulink" href="http://www.tortoisecvs.org"> http://www.tortoisecvs.org</a>. This free tool adds an extension to Windows Explorer that allows direct manipulation of CVS checkouts and repository simply by right-clicking on files or directories with the mouse. It is very intuitive and powerful.<a id="id231" class="indexterm"/>
</p><div class="section" title="Setting Up a CVS Repository"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec01"/>Setting Up a CVS Repository</h4></div></div></div><p>The first step in setting up a CVS repository is to determine where you are going to put the repository. CVS has several methods of connecting to the repository remotely. In most cases, it is best to require access through secure shell (<span class="strong"><strong>SSH</strong></span>), via the<code class="literal"> ext</code> method, as in:<a id="id232" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :ext:cellog@cvs.phpdoc.org:/opt/cvsroot
</strong></span>
</pre></div><p>Parsing this command line further, the<code class="literal"> -d</code> option tells CVS where to locate the root of CVS, or<code class="literal"> CVSROOT</code>. In this case, it tells CVS to connect to the remote CVSROOT at<code class="literal"> cvs.phpdoc.org</code> via the<code class="literal"> pserver</code> protocol, using the<code class="literal"> cellog</code> username. In addition, it informs the remote CVS daemon that the CVSROOT is located at<code class="literal"> /opt/cvsroot</code>. On<code class="literal"> cvs.php.net</code>, the CVSROOT is located at<code class="literal"> /repository</code>.<a id="id233" class="indexterm"/>
</p><p>If you're on a shared host, assuming your remote username is<code class="literal"> youruser</code>, it is probably best to put the<code class="literal"> cvsroot</code> in<code class="literal"> /home/youruser/cvs</code> or something of that nature. Otherwise, you are not likely to have write access to the directory in which you initialize your CVS repository. Obviously, write access is very important; otherwise there is no way to commit code from a development sandbox.</p><p>Once you have decided where to put the CVS repository, the next step is to initialize it. This is straightforward:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d /home/youruser/cvs init
</strong></span>
</pre></div><p>This creates the<code class="literal"> /home/youruser/cvs/CVSROOT</code> directory.</p><p>The next step is to create the module you will use for the website. Before importing the website, first create the module for the website.<a id="id234" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ mkdir /home/youruser/website
$ cd /home/youruser/website
$ echo "hi" &gt;&gt; README
$ cvs -d /home/youruser/cvs imoort website tcvs-vendor tcvs-release
</strong></span>
</pre></div><p>This will create a module named<code class="literal"> website</code> that can be checked out. To ensure success, check out a copy of the<code class="literal"> website</code> module:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd
$ cvs -d /home/youruser/cvs checkout website
</strong></span>
</pre></div><p>If all goes well, this will result in the creation of directory<code class="literal"> /home/youruser/website</code> and the file<code class="literal"> /home/youruser/website/README</code>. To test that CVS is accessible remotely, check out a copy of the<code class="literal"> website</code> module via something like:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :ext:youruser@example.com:/home/youruser/cvs checkout website
</strong></span>
</pre></div><p>The next step is adding the contents of the website into the CVS repository. Simply copy all of the website files with the directory hierarchy you desire into your local checkout of the<code class="literal"> website</code> module. The next step is the most complicated.</p><p>Most websites contain both text files (like our PHP scripts) and binary files, like images or sound clips. CVS treats binary and text files differently. Text files are processed, and special CVS in-file tags like<code class="literal"> $Id$</code> or<code class="literal"> $Revision$</code> are replaced with special values based on the state of the file in the repository. Tags like "$Id$" must be manually added to the files by the developer, CVS does not create them automatically. Binary files are treated as a single entity, and their contents are not touched.</p><p>When adding files to a CVS module, they must first be added via the<code class="literal"> cvs add</code> command, and then committed via the<code class="literal"> cvs commit</code> command. Text files and directories are simply added like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs add file
</strong></span>
</pre></div><p>Binary files are added with the<code class="literal"> -kb</code> switch:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs add -kb file</strong></span>
</pre></div><p>Files can be added with wildcards, but be very careful to ensure that you do not add image files as text files or text files as binary! In the worst case, you can remove files prior to committing with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs remove file
</strong></span>
</pre></div><p>Note that files that have been committed to the repository must be deleted prior to removal:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ rm file
$ cvs remove file</strong></span>
</pre></div><p>If you are using Windows, TortoiseCVS makes adding files far easier, as it does so recursively and hides the implementation details.<a id="id235" class="indexterm"/>
</p></div></div><div class="section" title="Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Subversion</h3></div></div></div><p>Subversion was developed a few years ago to address some of the shortcomings of CVS. Specifically, Subversion stores the repository information using a database, and so supports grouping changes together by commit rather than by file. Subversion is newer and as such has not been battle-tested as long as CVS, but both have been used in production for years.<a id="id236" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"/>Tip</h3><p>
 <a class="ulink" href="http://svnbook.red-bean.com">http://svnbook.red-bean.com</a> contains several different formats of the same book as published by O'Reilly. The Subversion book contains everything needed to set up, configure, and administer a Subversion repository.</p></div><p>Subversion differs from CVS in a few important ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A complete copy of the remote repository is stored locally, simplifying diffs and making it possible to do this offline.</li><li class="listitem" style="list-style-type: disc">Tags are stored as branches, unlike CVS. In CVS, tags are read-only and it is difficult to accidentally modify a tag. Modifying a branch is quite simple, and because tags are branches in Subversion, this makes it more difficult to implement a read-only tag.</li><li class="listitem" style="list-style-type: disc">Large files are easier to manage. Because the sandbox contains a complete copy of the current state of the repository module, this means that committing large text files only requires sending a diff. Ultimately, this saves both bandwidth and processor cycles on the server, which can be very important. (I once locked up the entire live server requiring a reboot just by committing a minor change to a 133MB database dump in a CVS repository. This was bad.)</li><li class="listitem" style="list-style-type: disc">Keywords (<code class="literal">$Id$, $Revision$</code>, and so on) are not substituted by default; all files in subversion are treated as binary files. To set a keyword substitution for a file, you need to set a property with something like:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn propset svn:keywords "Id" blah.php
</strong></span>
</pre></div></li></ul></div><p>More information is available at <a class="ulink" href="http://svnbook.red-bean.com/nightly/en/svn.advanced.props.html#svn.advanced.props.special.keywords">http://svnbook.red-bean.com/nightly/en/svn.advanced.props.html#svn.advanced.props.special.keywords</a>
</p><div class="section" title="Setting Up a Subversion Repository"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec02"/>Setting Up a Subversion Repository</h4></div></div></div><p>Like CVS, setting up a repository is relatively painless. Simply run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svnadmin create /path/to/subversion
</strong></span>
</pre></div><p>This will create a Subversion repository as a subdirectory of the current directory. To import your website code into the repository, first set up the standard Subversion directories:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ mkdir ~/tmp
$ cd ~/tmp
$ mkdir website
$ cd website
$ mkdir trunk
$ mkdir tags
$ mkdir branches
</strong></span>
</pre></div><p>Next, copy the complete contents of your current website into the<code class="literal"> website/trunk</code> directory. Finally execute:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd ~/tmp
$ svn import . file:///path/to/subversion -m "initial import"
</strong></span>
</pre></div><p>Once you have successfully imported, test by checking out the module:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout file:///path/to/subversion/website/trunk website
</strong></span>
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"/>Tip</h3><p><span class="strong"><strong>WARNING: check out website/trunk, not website.</strong></span></p><p>If you check out the entire module, you will get all branches and tags as well. This will eventually eat up all available disk space.</p></div><p>Accessing the<code class="literal"> website</code> module remotely requires that either the<code class="literal"> svnserve</code> daemon is running or that<code class="literal"> mod_svn</code> is running as an Apache web-server module. Consult the Subversion book at <a class="ulink" href="http://svnbook.red-bean.com"> http://svnbook.red-bean.com</a> for extended details on setting this up if one is not set up for you.</p><p>If you are running<code class="literal"> svnserve</code>, either check out via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout svn://yourwebsite.example.com/path/to/subversion/website/trunk website
</strong></span>
</pre></div><p>Or, if you support the highly recommended secure shell (SSH) tunneling:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout
svn+ssh://yourwebsite.example.com/path/to/subversion/website/ trunk website</strong></span>
</pre></div><p>Instead, if you have<code class="literal"> mod_svn</code> running, checking out is far simpler:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout http://yourwebsite.example.com/subversion/website/ trunk website
</strong></span>
</pre></div><p>Or, if you have a secure server:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout https://yourwebsite.example.com/subversion/website/ trunk website
</strong></span>
</pre></div><p>These commands will create a directory named<code class="literal"> website</code> that contains the code for your website.</p><p>Adding and removing files in a Subversion repository is very straightforward, and similar to CVS. Simply use this format to add a file or directory from within the<code class="literal"> website</code> directory:<a id="id237" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn add file.php
</strong></span>
</pre></div><p>Use this format to remove a file or directory:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn delete file.php
</strong></span>
</pre></div><p>Unlike with CVS, it is possible to move files around or copy them, retaining their revision history, with the<code class="literal"> move</code> and<code class="literal"> copy</code> commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn copy file.php newfile.php
$ svn move oldfile.php anotherfile.php
</strong></span>
</pre></div><p>If you wish to have keywords like<code class="literal"> $Id$</code> or<code class="literal"> $Revision$</code> replaced, you need to manually tell Subversion to perform this substitution:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn propset svn:keywords "Id Revision" file.php
</strong></span>
</pre></div><p>This should be enough information to get started with using the repository that you choose to use.</p></div></div></div><div class="section" title="Intelligent Source Control"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>Intelligent Source Control</h2></div></div></div><p>OK, now you have a version control repository set up and configured. Great! What next? Using a version control system intelligently is a very important step. Basic principles should be followed to ensure this is happening. Although many are common sense, it is not easy to remain vigilant and adhere to them.<a id="id238" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make regular backups of your repository and store them on independent media from the machine hosting the repository. If you remember nothing else, remember this!</li><li class="listitem" style="list-style-type: disc">Only commit working code to the repository — test before committing to avoid obvious errors like syntax errors.</li><li class="listitem" style="list-style-type: disc">Use tags to mark point releases of working code that will be deployed to a live server.</li><li class="listitem" style="list-style-type: disc">Use branches to support innovation and stable code bases simultaneously.</li><li class="listitem" style="list-style-type: disc">If you have multiple developers, define some basic coding standards (like PEAR's coding standards) so that diffs between revisions do not contain spurious changes to whitespace and other noise.<a id="id239" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">If you have multiple developers, set up a mailing list that is explicitly for commits to the repository. There are many excellent programs available for use in post-commit scripts that will mail diffs to a mailing list. Ensure that every developer is subscribed to the mailing list.</li></ul></div><div class="section" title="Maintaining Branches for Complex Versioning Support"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Maintaining Branches for Complex Versioning Support</h3></div></div></div><p>
<span class="strong"><strong>Branches</strong></span> allow development of more than one version of the same software at the same time. For instance, when software has reached stability, and major new features will be added, branch off a copy of the software so that small bugs can be fixed in the stable version at the same time as development continues. Best practice has the stable version branched off and development continuing on HEAD.<a id="id240" class="indexterm"/>
</p><p>To develop the stable version 1.2.X in a branch using CVS:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs tag -b VERSION_1_2
$ cvs update -b DEVEL_1_2
</strong></span>
</pre></div><p>The<code class="literal"> update</code> command is an unintuitive requirement, but is very important; without updating your sources, you will not be editing the branch code, and any changes will end up on HEAD.</p><p>It is a good idea to have two separate directories. For instance, when developing PEAR version 1.5.0 I have two directories that I use, which are created like so:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs -d :pserver:cellog@cvs.php.net:/repository co -r PEAR_1_4 d pear1.4 pear-core
$ cvs -d :pserver:cellog@cvs.php.net:/repository co pear-core
</strong></span>
</pre></div><p>Because I specified the<code class="literal"> -d pear1.4</code> option to the<code class="literal"> checkout</code> command (abbreviated as<code class="literal"> co</code>), the files will be checked out to the<code class="literal"> pear1.4</code> directory. The<code class="literal"> -r PEAR_1_4</code> option retrieves the PEAR_1_4 branch for fixing bugs in PEAR version 1.4.X. In the second case, files from the default HEAD branch are checked out to the<code class="literal"> pear-core</code> directory.</p><p>The same task using Subversion is performed by something like:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn checkout http://yourwebsite.example.com/subversion/website/ trunk website
</strong></span>
</pre></div></div><div class="section" title="Using Tags to Mark Point Releases"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Using Tags to Mark Point Releases</h3></div></div></div><p>Tags are important for several reasons, not the least of which is the ability to reconstruct older releases in the event of a disastrous loss of data. There are two ways to create a tag using CVS. The recommended way is very simple:<a id="id241" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear cvstag package.xml
</strong></span>
</pre></div><p>This command parses<code class="literal"> package.xml</code>, and for each file found, that file is tagged with<code class="literal"> RELEASE_X_Y_Z</code> where X_Y_Z is the version number. Version 1.2.3 will be tagged with<code class="literal"> RELEASE_1_2_3</code>.</p><p>Tagging manually from within the module checkout can be accomplished with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs tag -r RELEASE_1_2_3
</strong></span>
</pre></div><p>Subversion does not differentiate between tags and branches, so the only difference between creating a tag and a branch is where you copy it with the<code class="literal"> svn</code> copy command. By default, tags should be copied to the trunk/tags branch using<code class="literal"> svn</code> copy:<a id="id242" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn copy trunk tags/RELEASE_1_2_3
$ svn commit -m "tag release version 1.2.3"
</strong></span>
</pre></div></div></div></div>
<div class="section" title="The Solution, Part II: Using the PEAR Installer to Update the Website"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec04"/>The Solution, Part II: Using the PEAR Installer to Update the Website</h1></div></div></div><p>At this point, you should be familiar with the basic usage of both the PEAR installer and a source control system. Now we will take that knowledge to the next level and discover how to use the strengths of both tools to manage the complexity of a multi-segment website with inter-dependencies. First, it is important to think of the website code in terms of discrete packages and dependencies. To do this, it is often helpful to use a diagram. For complex systems, it makes a great deal of sense to use the <span class="strong"><strong> Uniform Modelling Language</strong></span> (<span class="strong"><strong>UML</strong></span>) to describe the system, as this is the universal standard of description.<a id="id243" class="indexterm"/>
</p><p>Let's examine a real-world example: the Chiara String Quartet website, <a class="ulink" href="http://www.chiaraquartet.net"> http://www.chiaraquartet.net</a>. As of early 2006, this is a mid-size website designed by a single developer, but the principles would scale well to a multi-developer situation. The website consists of a number of sub-sites as well as the main site.<a id="id244" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip33"/>Tip</h3><p>As of a few days prior to publication, the Chiara Quartet's website is now managed by an independent developer, and is no longer maintained directly by the author as described. For an example of a website that is being manged using<code class="literal"> package.xml</code>, at the time of publication,<code class="literal"> pear.php.net</code> was migrating to this approach. Check out the pearweb module from<code class="literal"> cvs.php.net</code>, and the<code class="literal"> package.php</code> script and corresponding<code class="literal"> package.xml</code> and post-installation script which can be used to set up a MySQL database and configure<code class="literal"> http.conf</code> file for a development copy of<code class="literal"> pear.php.net's</code> code.</p></div><p>The public sites are:<a id="id245" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <a class="ulink" href="http://www.chiaraquartet.net">http://www.chiaraquartet.net</a> (main site)</li><li class="listitem" style="list-style-type: disc"> <a class="ulink" href="http://music.chiaraquartet.net">http://music.chiaraquartet.net</a> (MP3s/audio samples)</li><li class="listitem" style="list-style-type: disc"> <a class="ulink" href="http://calendar.chiaraquartet.net">http://calendar.chiaraquartet.net</a> (schedule information)</li></ul></div><p>The private back-end sites include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"> <a class="ulink" href="http://addressbook.chiaraquartet.net">http://addressbook.chiaraquartet.net</a> (data entry for contact database)</li><li class="listitem" style="list-style-type: disc"> <a class="ulink" href="http://database.chiaraquartet.net">http://database.chiaraquartet.net</a> (management of general back end data)</li></ul></div><p>Each of these sites has an independent code base, but there are interlinked dependencies on elements such as images and templates used to unify the look of different sites. In addition, as the quartet's career grows, the needs of the website change dramatically, and the ability to add new sub-sites and remove obsolete ones is very important.<a id="id246" class="indexterm"/>
</p><p>Also important is to note that very large files are needed, such as high resolution press pictures and MP3 audio clips that will not change as regularly as the PHP code.</p><p>As such, the website can be grouped into several simple packages:<a id="id247" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">website</li><li class="listitem" style="list-style-type: disc">website database back end</li><li class="listitem" style="list-style-type: disc">website contact data entry back end</li><li class="listitem" style="list-style-type: disc">website images</li><li class="listitem" style="list-style-type: disc">website MP3s</li><li class="listitem" style="list-style-type: disc">website photos</li><li class="listitem" style="list-style-type: disc">website press PDFs</li></ul></div><p>The primary website package itself can be broken up at a later date into separate packages such as a primary website and a website blog package without penalty through a couple of methods that we will examine later on in the chapter.</p><p>Once we have determined the logical partitioning of the website into packages, all that is needed is to create a private channel, generate proper<code class="literal"> package.xml</code> files for each package, and install the website. Each component can be upgraded — and downgraded — independently, making maintenance and tracking changes far less of a magical ritual.</p><p>A wonderful technique for backing up a database is not only to save full dumps, but to commit these to a Subversion repository. This way, you are storing smaller versions and have the capability to check out the database dump on a remote machine for development and testing purposes.</p><p>Subversion is greatly preferred to CVS because it handles extremely large files far more gracefully. CVS can easily bring down an entire machine when calculating the difference between two 150 MB database dumps. I learned this the hard way. Subversion is far superior in this regard simply because it calculates differences using the local copy, and so only differences are sent back and forth, reducing net traffic exponentially.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"/>Tip</h3><p>It is important to note that if there is any private data in the database, access should be restricted to<code class="literal"> svn+ssh</code> in order to reduce the possibility of accidentally giving the sensitive data to the wrong people.</p><p>Needless to say, if there are any crucially sensitive data such as credit-card numbers or data that identity thieves would love to get their hands on, do not allow any remote access to the data whatsoever; instead resort to a tool like rdiff-backup ( <a class="ulink" href="http://www.nongnu.org/rdiff-backup/">http://www.nongnu.org/rdiff-backup/</a>).</p></div><p>When porting an existing website, it is best to add it to CVS/Subversion in exactly the source layout of the existing website.</p><p>One difficulty in developing a remote website is the need for code that understands it will run on a different IP and possibly a different hostname. There are three ways of handling this problem:<a id="id248" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add the live host name to the<code class="literal"> /etc/hosts</code> file as an alias to localhost, so all requests go to localhost.</li><li class="listitem" style="list-style-type: disc">Use host-neutral code, for example depending on the<code class="literal"> $_SERVER['HTTP_HOST']</code> variable used by the Apache web server, or<code class="literal"> $_SERVER['PHP_SELF']</code>.</li><li class="listitem" style="list-style-type: disc">Use PEAR's replacements facility and custom file roles to define per-machine host information.</li></ul></div><p>Adding the live host name to the<code class="literal"> /etc/hosts</code> file (usually<code class="literal"> C:\WINDOWS\system32\drivers\etc\hosts</code> on Microsoft Windows systems) will make it impossible to actually access the live web server  —  or FTP server  —  from the development machine, and so is no solution at all.<a id="id249" class="indexterm"/>
</p><p>Using host-neutral code appears to be a good idea at first, but as recent security concerns have shown, cross-site scripting (XSS) attacks thrive on vulnerabilities created through the use of these tools. Although it is not difficult to avoid the security issues, it does add considerable complexity, and makes the chance of introducing another bug or security issue higher than is comfortable.</p><p>The third option involves creating custom PEAR installer file roles that define special configuration variables, and then coupling these with PEAR's replacement task to customize files automatically per-machine.<a id="id250" class="indexterm"/>
</p><p>Specifically, our example website, <a class="ulink" href="http://www.chiaraquartet.net"> http://www.chiaraquartet.net</a>, would require setting up virtual hosts<code class="literal"> www.chiaraquartet.net, database.chiaraquartet.net, music.chiaraquartet.net</code>, and<code class="literal"> calendar.chiaraquartet.net</code> on the development machine. What a pain! Instead, I created two custom packages that define five configuration variables:<a id="id251" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">root_url:</code> This defines the base URL of the website.</li><li class="listitem" style="list-style-type: disc"><code class="literal">music_url</code> :This defines the base URL of the music-audio portion of the website.</li><li class="listitem" style="list-style-type: disc"><code class="literal">calendar_url:</code> This defines the base URL of the concert and event schedule.</li><li class="listitem" style="list-style-type: disc"><code class="literal">addressbook_url:</code> This defines the base URL of the back-end contact list.</li><li class="listitem" style="list-style-type: disc"><code class="literal">database_url:</code> This defines the base URL of the back-end database.</li></ul></div><p>On the<span class="emphasis"><em> development</em></span> server, I set these configuration variables to their needed values with:<a id="id252" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear config-set root_url http://localhost
$ pear config-set music_url http://localhost/music
$ pear config-set calendar_url http://localhost/calendar
$ pear config-set addressbook_url http://localhost/addressbook
$ pear config-set database_url http://localhost/database
</strong></span>
</pre></div><p>On the<span class="emphasis"><em> live</em></span> server, I set the configuration variables to their needed values with:<a id="id253" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear config-set root_url http://www.chiaraquartet.net
$ pear config-set music_url http://music.chiaraquartet.net
$ pear config-set calendar_url http://calendar.chiaraquartet.net
$ pear config-set addressbook_url http://addressbook.chiaraquartet.net
$ pear config-set database_url http://database.chiaraquartet.net
</strong></span>
</pre></div><p>Then, to set this information directly in the source, I use something like this:</p><div class="informalexample"><pre class="programlisting">$ajaxHelper-&gt;serverUrl = '@DATABASE-URL@/rest/rest_server.php';
</pre></div><p>The<code class="literal"> @DATABASE-URL@</code> value will be replaced with the value of the<code class="literal"> database_url</code> configuration variable if this tag is specified in<code class="literal"> package.xml:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;file name="blah.php" role="php"&gt;
&lt;tasks:replace from="@DATABASE-URL@" to="database_url"
type="pear-config" /&gt;
&lt;/file&gt;
</pre></div><p>After this work, when installed on the local<span class="emphasis"><em> development</em></span> machine, the code will be:</p><div class="informalexample"><pre class="programlisting">$ajaxHelper-&gt;serverUrl =
'http://localhost/database/rest/rest_server.php';
</pre></div><p>And on the<span class="emphasis"><em> live</em></span> server, the code will be:</p><div class="informalexample"><pre class="programlisting">$ajaxHelper-&gt;serverUrl = 'http://database.chiaraquartet.net/rest/ rest_server.php';
</pre></div><p>The best thing about this is that the URL is guaranteed to be correct on both machines without any extra work. This basic principle can also be applied for any important difference between development and live servers.</p><p>Another specific difference between standard library packages and websites is that websites should be installed into publicly accessible directories, but standard library package files should be installed into non-accessible locations. For this purpose, we have default configuration variables like<code class="literal"> php_dir, data_dir</code>, and<code class="literal"> test_dir</code>. There is no default role for web files. Fortunately, a custom file role package does exist on the<code class="literal"> pearified.com</code> channel. To acquire this package, follow these steps:<a id="id254" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pearified.com
$ pear install pearified/Role_Web
$ pear run-scripts pearified/Role_Web
</strong></span>
</pre></div><p>Then, to use it in<code class="literal"> package.xml</code>, simply write:</p><div class="informalexample"><pre class="programlisting">&lt;file name="foo.html" role="web" /&gt;
</pre></div><p>In addition, you should specify a required dependency on<code class="literal"> pearified.com/Role_Web</code> and a<code class="literal">&lt;usesrole&gt;</code> tag as described in <a class="link" href="ch02.html" title="Chapter 2. Mastering PHP Software Management with the PEAR Installer">Chapter 2</a>.</p><p>After these details are worked out, it is time to generate the<code class="literal"> package.xml</code> files that are needed by the PEAR installer in order to manage installation of the website.</p><div class="section" title="Generating package.xml from the Source Control Checkout"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Generating package.xml from the Source Control Checkout</h2></div></div></div><p>To generate<code class="literal"> package.xml</code>, there are a number of options available. The oldest and simplest for a complex website is to use the PEAR_PackageFileManager package to create a<code class="literal"> package.xml</code> generation script. The script should generate each<code class="literal"> package.xml</code> file that is needed, making it simple to update. In addition, it should correctly ignore irrelevant files and sub-packages.<a id="id255" class="indexterm"/>
</p><p>The generation script for our real website, <a class="ulink" href="http://www.chiaraquartet.net"> http://www.chiaraquartet.net</a>, was maintained using this method:<a id="id256" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
require_once 'PEAR/PackageFileManager2.php';
PEAR::setErrorHAndling(PEAR_ERROR_DIE);
</pre></div><p>The next section simply sets release notes and versions for each sub-package's<code class="literal"> package.xml</code> in a centralized location near the top of the file, making it easier to edit the file.</p><div class="informalexample"><pre class="programlisting">$imageversion = '0.1.0';
$imagenotes = &lt;&lt;&lt;EOT
initial release
EOT;
$mp3version = '0.1.0';
$mp3notes = &lt;&lt;&lt;EOT
initial release
EOT;
$photoversion = '0.1.0';
$photonotes = &lt;&lt;&lt;EOT
initial release
EOT;
$pressversion = '0.1.0';
$pressnotes = &lt;&lt;&lt;EOT
initial release
EOT;
$dataversion = '0.10.3';
$datanotes = &lt;&lt;&lt;EOT
fix saving multiple program items
EOT;
$version = '0.10.0';
$apiversion = '0.1.0';
$notes = &lt;&lt;&lt;EOT
split off database from main package
EOT;
</pre></div><p>Next, we create each of the<code class="literal"> package.xml</code> files by importing from the existing<code class="literal"> package.xml</code> for each sub-package. We'll cut out a few of the sub-packages, just for brevity. Here is a typical one (website images):<a id="id257" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$package_images =
PEAR_PackageFileManager2::importOptions(dirname(__FILE__) .
DIRECTORY_SEPARATOR . 'images' . DIRECTORY_SEPARATOR .
'package.xml',
$options = array(
'ignore' =&gt; array('package.xml'),
'filelistgenerator' =&gt; 'cvs', // other option is 'file'
'changelogoldtonew' =&gt; false,
'baseinstalldir' =&gt; 'images',
'packagedirectory' =&gt; dirname(__FILE__) . DIRECTORY_SEPARATOR .
'images',
'simpleoutput' =&gt; true,
'roles' =&gt; array('*' =&gt; 'web'),
));
$package_images-&gt;setPackageType('php');
$package_images-&gt;setReleaseVersion($imageversion);
$package_images-&gt;setAPIVersion($imageversion);
$package_images-&gt;setReleaseStability('alpha');
$package_images-&gt;setAPIStability('alpha');
$package_images-&gt;setNotes($imagenotes);
$package_images-&gt;clearDeps();
$package_images-&gt;resetUsesRole();
$package_images-&gt;addUsesRole('web_dir', 'Role_Web', 'pearified.com');
$package_images-&gt;addPackageDepWithChannel('required', 'Role_Web',
'pearified.com');
$package_images-&gt;setPhpDep('5.1.0');
$package_images-&gt;setPearinstallerDep('1.4.3');
$package_images-&gt;generateContents();
$package_images-&gt;addRelease();
<span class="strong"><strong>// snip
</strong></span>
$package_data =
PEAR_PackageFileManager2::importOptions(dirname(__FILE__) .
DIRECTORY_SEPARATOR . 'database' . DIRECTORY_SEPARATOR .
'package.xml',
$options = array(
'ignore' =&gt; array('package.xml'),
'filelistgenerator' =&gt; 'cvs', // other option is 'file'
'changelogoldtonew' =&gt; false,
'baseinstalldir' =&gt; 'database',
'packagedirectory' =&gt; dirname(__FILE__) . DIRECTORY_SEPARATOR .
'database',
'simpleoutput' =&gt; true,
'roles' =&gt; array('*' =&gt; 'web'),
));
$package_data-&gt;setPackageType('php');
$package_data-&gt;setReleaseVersion($dataversion);
$package_data-&gt;setAPIVersion($dataversion);
$package_data-&gt;setReleaseStability('alpha');
$package_data-&gt;setAPIStability('alpha');
$package_data-&gt;setNotes($datanotes);
$package_data-&gt;clearDeps();
$package_data-&gt;resetUsesRole();
$package_data-&gt;addPackageDepWithChannel('required', 'HTML_AJAX',
'pear.php.net');
$package_data-&gt;addPackageDepWithChannel('required',
'HTML_Javascript', 'pear.php.net');
$package_data-&gt;addPackageDepWithChannel('required', 'XML_RPC2',
'pear.php.net');
$package_data-&gt;addUsesRole('web_dir', 'Role_Web', 'pearified.com');
$package_data-&gt;addUsesRole('root_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_data-&gt;addUsesRole('music_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_data-&gt;addUsesRole('calendar_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_data-&gt;addUsesRole('database_url', 'Role_Chiara2',
'pear.chiaraquartet.net/private');
$package_data-&gt;addPackageDepWithChannel('required', 'Role_Web',
'pearified.com');
$package_data-&gt;setPhpDep('5.1.0');
$package_data-&gt;setPearinstallerDep('1.4.3');
</pre></div><p>Here, we will add replacement tasks to all files, demonstrating the customization we need for development versus production machine:<a id="id258" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$package_data-&gt;addGlobalReplacement('pear-config', '@ROOT-URL@',
'root_url');
$package_data-&gt;addGlobalReplacement('pear-config', '@MUSIC-URL@',
'music_url');
$package_data-&gt;addGlobalReplacement('pear-config', '@CALENDAR-URL@',
'calendar_url');
$package_data-&gt;addGlobalReplacement('pear-config', '@DATABASE-URL@',
'database_url');
$package_data-&gt;addGlobalReplacement('pear-config', '@WEB-DIR@',
'web_dir');
$package_data-&gt;generateContents();
$package_data-&gt;addRelease();
$package_website =
PEAR_PackageFileManager2::importOptions(dirname(__FILE__) .
DIRECTORY_SEPARATOR . 'package.xml',
</pre></div><p>This next line is crucial; we need to ignore the contents of all the sub-packages, or they will be duplicated and will conflict with the parent package!<a id="id259" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$options = array(
'ignore' =&gt; array('package.php', 'package.xml', '*.bak',
'chiaraqu_Chiara', '*.tgz', 'README', 'Chiara_Role/',
'images/', 'photos/', 'music/mp3/', 'press/', 'database/'),
'filelistgenerator' =&gt; 'cvs', // other option is 'file'
'changelogoldtonew' =&gt; false,
'baseinstalldir' =&gt; '/',
'packagedirectory' =&gt; dirname(__FILE__),
'simpleoutput' =&gt; true,
'roles' =&gt; array('*' =&gt; 'web'),
));
$package_website-&gt;setPackageType('php');
$package_website-&gt;setReleaseVersion($version);
$package_website-&gt;setAPIVersion($apiversion);
$package_website-&gt;setReleaseStability('alpha');
$package_website-&gt;setAPIStability('alpha');
$package_website-&gt;setNotes($notes);
$package_website-&gt;clearDeps();
$package_website-&gt;resetUsesRole();
$package_website-&gt;addUsesRole('web_dir', 'Role_Web',
'pearified.com');
$package_website-&gt;addUsesRole('root_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_website-&gt;addUsesRole('music_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_website-&gt;addUsesRole('calendar_url', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_website-&gt;addUsesRole('database_url', 'Role_Chiara2',
'pear.chiaraquartet.net/private');
$package_website-&gt;addPackageDepWithChannel('required', 'PEAR',
'pear.php.net', '1.4.3');
$package_website-&gt;addPackageDepWithChannel('required', 'Role_Web',
'pearified.com');
$package_website-&gt;addPackageDepWithChannel('required', 'Role_Chiara',
'pear.chiaraquartet.net/private');
$package_website-&gt;addPackageDepWithChannel('required',
'Role_Chiara2', 'pear.chiaraquartet.net/private');
</pre></div><p>Here, we add dependencies on each of the sub-packages:<a id="id260" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$package_website-&gt;addPackageDepWithChannel('required',
'website_photos', 'pear.chiaraquartet.net/private');
$package_website-&gt;addPackageDepWithChannel('required',
'website_mp3s', 'pear.chiaraquartet.net/private');
$package_website-&gt;addPackageDepWithChannel('required',
'website_press', 'pear.chiaraquartet.net/private');
$package_website-&gt;addPackageDepWithChannel('required',
'website_images', 'pear.chiaraquartet.net/private');
$package_website-&gt;setPhpDep('5.1.0');
$package_website-&gt;setPearinstallerDep('1.4.3');
$package_website-&gt;addGlobalReplacement('pear-config', '@ROOT-URL@',
'root_url');
$package_website-&gt;addGlobalReplacement('pear-config', '@MUSIC-URL@',
'music_url');
$package_website-&gt;addGlobalReplacement('pear-config',
'@CALENDAR-URL@', 'calendar_url');
$package_website-&gt;addGlobalReplacement('pear-config',
'@DATABASE-URL@', 'database_url');
$package_website-&gt;addGlobalReplacement('pear-config', '@WEB-DIR@',
'web_dir');
$package_website-&gt;generateContents();
$package_website-&gt;addRelease();
</pre></div><p>Finally, we create each of the<code class="literal"> package.xml</code> files or display them for error-checking:<a id="id261" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">if (isset($_SERVER['argv'][1]) &amp;&amp; $_SERVER['argv'][1] == 'commit') {
$package_press-&gt;writePackageFile();
$package_images-&gt;writePackageFile();
$package_mp3s-&gt;writePackageFile();
$package_photos-&gt;writePackageFile();
$package_website-&gt;writePackageFile();
$package_data-&gt;writePackageFile();
} else {
$package_press-&gt;debugPackageFile();
$package_mp3s-&gt;debugPackageFile();
$package_images-&gt;debugPackageFile();
$package_photos-&gt;debugPackageFile();
$package_website-&gt;debugPackageFile();
$package_data-&gt;debugPackageFile();
}
?&gt;
</pre></div><p>Each sub-package has its own PEAR_PackageFileManager2 object, and imports options from an existing<code class="literal"> package.xml</code>, only modifying what is necessary. To create the<code class="literal"> package.xml</code>, I copied an existing one from a PEAR package (in this case, PEAR's own<code class="literal"> package2.xml</code>), and modified the sections<code class="literal">&lt;summary&gt;, &lt;description&gt;, &lt;license&gt;</code>, and the list of maintainers to suit the website package.</p><p>To use the script, I saved it as<code class="literal"> package.php</code> and now run it with PHP 5.1.0 or newer, like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ php package.php
</strong></span>
</pre></div><p>This allows me to view the<code class="literal"> package.xml</code> files and check them for errors. To save changes to<code class="literal"> package.xml</code>, I run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ php package.php commit
</strong></span>
</pre></div><p>Voilà!<code class="literal"> package.xml</code> is created in<code class="literal"> website/, website/database, website/calendar, website/press</code>, and<code class="literal"> website/music</code>.</p><p>At this stage, we are ready to start making releases of the code and deploying it to a test server.</p></div><div class="section" title="Packaging: Coordinating Release Versions with Tags and Branches"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Packaging: Coordinating Release Versions with Tags and Branches</h2></div></div></div><p>Arriving at this stage means we are ready to start packaging our website up into PEAR packages for installation. At this point, the process begins to merge with the packaging we learned to do in the previous chapter. Ultimately, this is the reason that packaging a website using the PEAR installer is a good idea. The process of installing, upgrading, and even reverting the website is no different from installing, upgrading, and reverting any PEAR package. This process makes it incredibly simple to manage.<a id="id262" class="indexterm"/>
</p><p>When converting from the old way of managing a website to the PEAR way, there are several important steps that must be undertaken:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Test the release on a local development server.</li><li class="listitem">Back up the live server immediately prior to deployment if possible.</li><li class="listitem">Deploy the PEAR package on the remote server.</li></ol></div><p>Once the website has been successfully deployed, then it is a simple process of upgrading the respective package on the remote server.<a id="id263" class="indexterm"/>
</p><p>When a release is made, it is very important to mark that release in the source control system using a tag. If you chose to use CVS, tagging is straightforward:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear cvstag package.xml
</strong></span>
</pre></div><p>This will automatically scan<code class="literal"> package.xml</code> for the files contained within the release, and using the release version will create a tag named<code class="literal"> RELEASE_X_Y_Z</code> and apply it to all of the files. If the release version is 0.10.0, the tag will be<code class="literal"> RELEASE_0_10_0</code>, if the release version is 1.2.3, the tag will be<code class="literal"> RELEASE_1_2_3</code>, and so on.<a id="id264" class="indexterm"/>
</p><p>Tagging with Subversion is not quite as automatic, but is accomplished simply via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ svn copy trunk tags/RELEASE_X_Y_Z
$ svn commit -m "tag release X.Y.Z"
</strong></span>
</pre></div><p>With these steps, release version X.Y.Z is tagged.</p></div><div class="section" title="Testing the Release before Uploading"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Testing the Release before Uploading</h2></div></div></div><p>When you are ready to deploy the website, it is important to create a test package and install it locally to ensure that all is OK. Output from packaging will be something along these lines:<a id="id265" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
Analyzing addressbook/data.php
Analyzing addressbook/form.php
Analyzing addressbook/index.php
Analyzing addressbook/list.php
Analyzing addressbook/login.php
Analyzing addressbook/nameparser.php
Analyzing addressbook/usps.php
Analyzing calendar/chiaraSchedule.php
Analyzing calendar/HTMLController.php
Analyzing calendar/HTMLView.php
Analyzing calendar/index.php
Analyzing calendar/schedulelogin.php
Analyzing css/default.css
Analyzing css/history.css
Analyzing css/jonah.css
Analyzing css/music.css
Analyzing css/newindex.css
Analyzing css/news.css
Analyzing css/schedule.css
Analyzing domLib/Changelog
Analyzing domLib/domLib.js
Analyzing domLib/LICENSE
Analyzing domTT/alphaAPI.js
Analyzing domTT/domLib.js
Analyzing domTT/domTT.js
Analyzing domTT/domTT_drag.js
Analyzing music/index.php
Analyzing rest_/list/composers.php
Analyzing rest_/list/concerts.php
Analyzing rest_/list/halls.php
Analyzing rest_/list/pieces.php
Analyzing templates/bio.tpl
Analyzing templates/genericheader.tpl
Analyzing templates/header.tpl
Analyzing templates/history.tpl
Analyzing templates/index.tpl
Analyzing templates/jonahheader.tpl
Analyzing templates/jonahindex.tpl
Analyzing templates/musicbody.tpl
Analyzing templates/news.tpl
Analyzing templates/schedulebody.tpl
Analyzing bio.php
Analyzing editconcerts.html
Analyzing history.php
Analyzing index.php
Analyzing news.php
Warning: in pieces.php: class "getPieces" not prefixed with package name "website"
Warning: in halls.php: class "getHalls" not prefixed with package name "website"
Warning: in concerts.php: class "getConcerts" not prefixed with package name "website"
Warning: in composers.php: class "getComposers" not prefixed with package name "website"
Warning: in index.php: function "err" not prefixed with package name "website"
Warning: in index.php: class "schedulebody" not prefixed with package name "website"
Warning: in news.php: class "test" not prefixed with package name "website"
Warning: in HTMLView.php: class "HTMLView" not prefixed with package name "website"
Warning: in HTMLController.php: class "HTMLController" not prefixed with package name "website"
Warning: in chiaraSchedule.php: class "chiaraSchedule" not prefixed with package name "website"
Warning: in usps.php: class "Services_USPS" not prefixed with package name "website"
Warning: in nameparser.php: class "Spouses" not prefixed with package name "website"
Warning: in nameparser.php: class "CareOf" not prefixed with package name "website"
Warning: in nameparser.php: class "Name" not prefixed with package name "website"
Warning: in nameparser.php: class "NameParser" not prefixed with package name "website"
Warning: in schedulelogin.php: class "Login" not prefixed with package name "website"
Warning: in index.php: class "Page3Display" not prefixed with package name "website"
Warning: in index.php: class "Page1Display" not prefixed with package name "website"
Warning: in index.php: class "MyDisplay" not prefixed with package name "website"
Warning: in index.php: class "Recycle" not prefixed with package name "website"
Warning: in index.php: class "Cancel" not prefixed with package name "website"
Warning: in index.php: class "FinalPage" not prefixed with package name "website"
Warning: in index.php: class "VerifyPage" not prefixed with package name "website"
Warning: in index.php: class "FirstPage" not prefixed with package name "website"
Warning: in form.php: class "HTML_QuickForm_Action_Next" not prefixed with package name "website"
Warning: in data.php: class "ContactAddress" not prefixed with package name "website"
Warning: in data.php: class "Address" not prefixed with package name "website"
Warning: in data.php: class "Data" not prefixed with package name "website"
Warning: Channel validator warning: field "date" - Release Date "2006-04-08" is not today
Package website-0.10.0.tgz done
Tag the released code with `pear cvstag package.xml'
(or set the CVS tag RELEASE_0_10_0 by hand)
$ pear upgrade website-0.10.0.tgz
upgrade ok: channel://pear.chiaraquartet.net/private/website-0.10.0
</strong></span>
<a id="id267" class="indexterm"/>
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"/>Tip</h3><p><span class="strong"><strong>What about all those "Warning: in index.php..." Things?</strong></span></p><p>This warning is intended for those folks who are actively developing for the official PEAR repository at <a class="ulink" href="http://pear.php.net"> http://pear.php.net</a> to help catch cases where classes are misnamed. We could easily eliminate these warnings by creating a custom channel validator as discussed in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>, but this is unnecessary since we know that they are superfluous warnings (one of the advantages of having written the software or of having read this book!)</p></div><p>Next, browse to every page and click links (or run your test suite if you have one) to be sure that it is working properly. Once you are convinced it is ready and working, it is time to upgrade the live server.</p></div><div class="section" title="Upgrading the Live Server"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Upgrading the Live Server</h2></div></div></div><p>Although it is actually possible to upgrade the live server without taking steps to shut it down, this is generally a bad idea. It is in fact best to create a test directory with an<code class="literal"> index.html</code> and a<code class="literal"> 404.html</code> file; something like the following:<a id="id268" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Upgrading site check back later&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
We are currently upgrading our server, please check back later.
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>Then, save an<code class="literal"> .htaccess</code> file (assuming you are using Apache) that looks something like this:</p><div class="informalexample"><pre class="programlisting">RewriteEngine On
RewriteRule .+ test/index.html
</pre></div><p>This is assuming your web host has<code class="literal"> mod_rewrite</code> enabled in Apache (not all hosts do). Better yet, if you have access to<code class="literal"> httpd.conf</code>, simply change the directory for<code class="literal"> DocumentRoot</code> to the test directory, and add the<code class="literal"> ErrorDocument</code> reference.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"/>Tip</h3><p>Because the PEAR installer uses atomic file transactions, there is very little chance of ending up with a half-done install. The purpose of the temporary site is to avoid users having to see the site should there be any major problems. You can test the site by adding a RewriteCond rule that specifies your computer's IP will ignore the rule, which allows you to see the full site and detect any problems that need to be fixed.</p></div><p>Once you have the site properly hidden behind a RewriteRule, it is time to actually upgrade the site. First, check out a copy of the website from source control using<code class="literal"> cvs checkout</code> or<code class="literal"> svn checkout</code> as we learned at the beginning of this chapter. Next, we need to create the package and install it. Before we can do this, we need to install all of the necessary custom file roles we created:<a id="id269" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pearified.com
$ pear install pearified/Role_Web
$ pear channel-discover pear.chiaraquartet.net/private
$ pear install priv/Role_Chiara
$ pear install priv/Role_Chiara2
</strong></span>
</pre></div><p>Next, we need to initialize the custom file roles:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear run-scripts pearified/Role_Web
$ pear config-set root_url http://www.chiaraquartet.net/
$ pear config-set calendar_url http://calendar.chiaraquartet.net/
$ pear config-set database_url http://database.chiaraquartet.net/
$ pear config-set music_url http://music.chiaraquartet.net/
$ pear config-set addressbook_url http://addressbook.chiaraquartet.net/
</strong></span>
</pre></div><p>Once this is complete, we are ready to begin installation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs checkout...etc.
$ cd website
$ pear package
$ pear install website-0.10.0.tgz
</strong></span>
</pre></div><p>That's it! Now that we have finished the initial installation, upgrading to the next version when it is time is as easy as it gets.</p><div class="section" title="Using the pear upgrade Command"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Using the pear upgrade Command</h3></div></div></div><p>For this section, we will use CVS as our source-control example, but substitute what we've learned about Subversion if you are using a Subversion repository.<a id="id270" class="indexterm"/>
</p><p>When you need to fix a bug or add a new feature, simply modify the release notes from the<code class="literal"> package.php package.xml</code> generation file:</p><div class="informalexample"><pre class="programlisting">$version = '0.11.0';
$apiversion = '0.1.0';
$notes = &lt;&lt;&lt;EOT
Add a doohickey to the main page
EOT;
</pre></div><p>Then, create the<code class="literal"> package.xml</code> files:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ php package.php commit
</strong></span>
</pre></div><p>Finally, commit your work:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cvs commit -m "add a doohickey to the main page, and prepare for 0.11.0 release"
</strong></span>
</pre></div><p>Again, test on the local server via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade package.xml
</strong></span>
</pre></div><p>And when you are certain it works on the remote server, simply run these commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd website
$ cvs upd -P -d
$ pear package
$ pear cvstag package.xml
$ pear upgrade website-0.11.0.tgz
</strong></span>
</pre></div><p>At this stage, you have successfully upgraded to version 0.11.0.</p><p>What happens if you discover a critical error in version 0.11.0 that didn't exist in version 0.10.0? Fortunately, the sequence to fix the problem is straightforward and elegant:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd website
$ pear upgrade -f website-0.10.0.tgz</strong></span>
</pre></div><p>Two lines of typing is all that you need. This is assuming you kept the 0.10.0 release tarball sitting around. Even if you didn't, the process is still very simple:<a id="id271" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd website
$ cvs upd -r RELEASE_0_10_0 -P -d
$ pear upgrade -f package.xml
$ cvs upd -r HEAD -P -d</strong></span>
</pre></div><p>Technically, the last line returning to<code class="literal"> HEAD</code> of CVS is not really necessary for the recovery of the website, but it will save later headaches when you have forgotten that you have checked out the<code class="literal"> RELEASE_0_10_0</code> tag. The same process is also simple in Subversion:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd website
$ svn switch http://yourwebsite.example.com/subversion/website/tags/RELEASE_0_10_0
$ pear upgrade -f package.xml
$ svn switch http://yourwebsite.example.com/subversion/website/trunk</strong></span>
</pre></div><p>Now for the $10 million question: how can you perform these tasks if you have no shell access on the remote server, as many folks on shared hosts have experienced? (Hint: read the section on<span class="emphasis"><em> PEAR_RemoteInstaller</em></span> in <a class="link" href="ch01.html" title="Chapter 1. Acquiring PEAR: What is it and How do I Get It?">Chapter 1</a>, and you'll have the answer).</p></div><div class="section" title="The Real Beauty of Using Pear to Fix Problems"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>The Real Beauty of Using Pear to Fix Problems</h3></div></div></div><p>The worst moment in a web developer's life is when a serious flaw is discovered in a website. It is often difficult to quickly revert to an older version. The PEAR installer makes this process simple. If testing determines that the problem was introduced in version 1.2.3 and does not exist in version 1.2.2, reverting to version 1.2.2 is as simple as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force website-1.2.2.tgz
</strong></span>
<a id="id272" class="indexterm"/>
</pre></div><p>Or if you have set up a channel (we'll assume you have aliased it as<code class="literal"> private):</code>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force private/website-1.2.2
</strong></span>
</pre></div><p>Abbreviated:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear up f private/website-1.2.2
</strong></span>
</pre></div><p>In addition, any required dependencies will also be downgraded if you pass in the<code class="literal"> -o</code> command-line option.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Summary</h1></div></div></div><p>In this chapter we have seen how to use PEAR installer to manage a complicated and rapidly evolving website. We saw a number of issues involved in the development of a website, such as code breakage, missing or extra files, and how the PEAR Installer can help us with them.</p><p>We also saw how to set up a revision control system, either CVS or Subversion. Finally, we saw how to use PEAR installer and source control systems to update a website.</p><p>In the next chapter you will learn about ways of publicly distributing your libraries and applications over the Internet.</p></div></body></html>