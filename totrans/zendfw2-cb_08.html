<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Optimizing Performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Optimizing Performance</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caching, and when to cache</li><li class="listitem" style="list-style-type: disc">Understanding and using storage plugins</li><li class="listitem" style="list-style-type: disc">Setting up a caching system</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Introduction</h1></div></div></div><p>In a society where we want our data now, it is important to make sure that our websites and applications also deliver it as soon as possible. When we rule out any obvious cause of slow downs, such as network infrastructure or server configuration, we can start looking at caching. This chapter is all about what to cache and how to cache, making our lives a lot faster.</p></div></div>
<div class="section" title="Caching and when to Cache"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Caching and when to Cache</h1></div></div></div><p>Caching, <a id="id606" class="indexterm"/>everyone knows about it, everybody talks about it, but what is it? In its purest essence caching is <a id="id607" class="indexterm"/>all about serving your application as quickly as possible to the user. That's what we will talk in this recipe when and how to cache.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Getting ready</h2></div></div></div><p>We will be working with the Zend Framework skeleton application again, so it would be wise to have that set up.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>How to do it…</h2></div></div></div><p>When developing an application, caching might not be something that immediately comes up in the design, <a id="id608" class="indexterm"/>and most probably this will come up when the application goes live and after a while you find your application responding slower than when you first put it live.</p><p>That is the perfect (well not perfect, as that would be during the design phase, obviously) time to consider implementing a cache.</p><p>When we talk <a id="id609" class="indexterm"/>about caching, a common misunderstanding is that we are solely talking about caching an HTML output. Nothing could be further from the truth, as we have several powerful methods of caching in PHP.</p><p>The following list is a collection of some methods available to us to cache different sections of our application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caching the ZF2 configuration</li><li class="listitem" style="list-style-type: disc">Caching the rendered output</li><li class="listitem" style="list-style-type: disc">Caching the class map</li></ul></div><p>We will now go in further detail of the methods named in the preceding list.</p><div class="section" title="Caching configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec222"/>Caching configuration</h3></div></div></div><p>Probably the<a id="id610" class="indexterm"/> most static bit of code in your application will be the configuration. Oh but how we need configuration to properly load our application, but in the meantime we might hate it for all the merging it needs to do before we end up with the final version of the configuration.</p><p>But fear not, as we can simply cache the merged configuration so that your application doesn't have to parse through the lot anymore! This is actually such a simple process, that it is almost hilarious to give the example for it (<code class="literal">/config/application.config.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // Look for this ke y in the configuration array.
  'module_listener_options' =&gt; array(

    // Enable the config cache.
    'config_cache_enabled' =&gt; true,

    // If we want to give the cache a special filename
    // we can just type a name here.
    'config_cache_key' =&gt; 'configuration'
 
    // The directory where we want to write the cache 
    // to. Don't forget that we need read/write access 
    // to this directory by the process running the app, which in 
    // most cases is the web server process!
    'cache_dir' =&gt; 'data/cache/',
  ),
);</pre></div><p>And that's it. Nothing fancy is needed to make this work as everything that is required to make this work is already built in Zend Framework 2.</p><p>This is a <a id="id611" class="indexterm"/>very effective way to start caching everything that is static, and although it probably doesn't give the application an enormous speed boost (unless we have literally dozens of modules) it will be a method that shouldn't be forgotten.</p></div><div class="section" title="Caching output"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec223"/>Caching output</h3></div></div></div><p>Caching output<a id="id612" class="indexterm"/> is useful when we have a lot of static files that normally don't or rarely change. When we talk about content that doesn't change a lot we can think of blog posts or news items as those usually get generated once and put live indefinitely. There are obviously more output types that are useful to cache, but we will just give an example to show how easy it is to cache output that we deem static.</p><p>First we need to create the configuration in our module to make sure the caching is enabled in our <code class="literal">ServiceManager</code> (<code class="literal">/module/SomeModule/config/module.config.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // We need to define the ServiceManager
  'service_manager' =&gt; array(
    // We will call it cache-service
    'cache-service' =&gt; function () {
      // Return a new cache adapter
      return \Zend\Cache\StorageFactory::factory(array(
        'adapter' =&gt; array(
          // We want to use the cache that is being 
          // stored on the filesystem
          'name' =&gt; 'filesystem',
          'options' =&gt; array(
            'cache_dir' =&gt; 'data/cache/',

            // This is the amount in minutes the cache is valid
            'ttl' =&gt; 100
          ),
        ),
      ));
    },
  },
);</pre></div><p>Now that we <a id="id613" class="indexterm"/>created the configuration, let's continue to control the caching in our <code class="literal">/module/SomeModule/Module.php</code> file's <code class="literal">onBootstrap</code> method:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Don't forget the namespace (obviously)
namespace SomeModule;

// We need this event for the onBootstrap event
use Zend\Mvc\MvcEvent;

// Begin our module class
class Module
{
  // This is going to be run at bootstrap, and will thus 
  // create our events that will create our cached 
  // output
  public function onBootstrap(MvcEvent $e)
  {
    // We will need a list of routes that we deem 
    // cacheable
    $routes = array('blog/pages', 'blog/archives');

    $eventManager = $e-&gt;getApplication()-&gt;getEventManager();
    $serviceManager = $e-&gt;getApplication()-&gt;getServiceManager();

    $eventManager-&gt;attach(
         MvcEvent::EVENT_ROUTE, 
         function($e) use ($serviceManager)
    {
      $route = $e-&gt;getRouteMatch()
                 -&gt;getMatchedRouteName();

      // Check if this is a page that we want to cache, 
      // if not then just exit this method
      if (!in_array($route, $routes)) {
        return;
      }

      // Get the cache-service from the configuration
      $cache = $serviceManager-&gt;get('cache-service');

      // Define a unique key that we use for the route
      $key = 'route-'. $route;

      // Check if our cache has the key with our route 
      // content 
      if ($cache-&gt;hasItem($key)) {
        // Handle response
        $response = $e-&gt;getResponse();

        // Set the content to our cached content
        $response-&gt;setContent($cache-&gt;getItem($key));

        // Return the response, because when we return 
        // the response from a route event, the 
        // application will output that response.
        return $response;
      }
    }, 
    // Make this priority super low to make sure this 
    // route has already happened
    -1000); 

    // Now we create an trigger for the render event 
    // which will come after the route event. This means 
    // that we didn't have a valid cache, and we will 
    // now use this opportunity to create a cache of our 
    // rendered content.
    $eventManager-&gt;attach(
      MvcEvent::EVENT_RENDER, 
      function($e) use ($serviceManager, $routes) 
    {
      // Get the current route name 
      $route = $e-&gt;getRouteMatch()
                 -&gt;getMatchedRouteName();

      // Check if this is a page that we want to cache, 
      // if not then just exit this method
      if (!in_array($route, $routes))
        return;
      
      // Apparently we want to cache the content, so 
      // here we go!
      $response = $e-&gt;getResponse(); 

      // Get the cache service from the ServiceManager
      $cache = $serviceManager-&gt;get('cache-service');
      
      // Build up our unique cache key
      $key = 'route-'. $route;

      // And now set the cache item
      $cache-&gt;setItem($key, $response-&gt;getContent());
    }, 
    // Again the lowest priority to make sure rendering 
    // already has happened.
    -1000);
  }
}</pre></div><p>Now every<a id="id614" class="indexterm"/> time we go to our application the route event will check if we might have a cache of the specific route, and if we do, it will return the cache (if not expired, of course). If the route hasn't been cached yet it will do so if necessary once the rendered event is triggered.</p><p>Credit for this example goes to <span class="emphasis"><em>Jurian Sluiman</em></span> (<span class="emphasis"><em>jurian-sluiman</em></span>) who is a user on the <a class="ulink" href="http://stackoverflow.com">stackoverflow.com</a> website and a significant contributor to Zend Framework 2.</p></div><div class="section" title="Caching the class map"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec224"/>Caching the class map</h3></div></div></div><p>The class map file <a id="id615" class="indexterm"/>is one of those files that are just big, and basically static after the application has done merging it. That it is static and is obviously a great opportunity for us so we can cache it and take a bit of the load from the applications merging away. As for the first method of our caching, this one also only requires us to add a couple of properties in the configuration file.</p><p>Let's get this example started (<code class="literal">/config/application.config.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // Look for this key in the configuration array.
  'module_listener_options' =&gt; array(

    // Enable the module map cache.
    'module_map_cache_enabled' =&gt; true,

    // If we want to give the cache a special filename
    // we can just type a name here.
    'module_map_cache_key' =&gt; 'classmap
 
    // The directory where we want to write the cache 
    // to. Don't forget that we need read/write access  
    // to this directory!
    'cache_dir' =&gt; 'data/cache/',
  ),
);</pre></div><p>Again, although this<a id="id616" class="indexterm"/> might not be a significant improvement on the overall performance, we can be sure that every little bit helps, and it will certainly help lighten the load for the autoloader process.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>How it works…</h2></div></div></div><p>All that caching does is speeding up the application by keeping everything ready for when it is needed within a certain time (the <code class="literal">ttl</code> or also called time-to-live) period. It speeds up the application because it gives the application the data it requires without the application needing to make the connection to the database, or recompiling templates for example.</p><p>Caching is usually done on the filesystem, as it is considered to be a very fast option instead of going through a database for example. However, technically the fastest option for caching would be in-memory (this is because the memory or RAM is the closest data storage for the CPU and therefore the fastest). Although memory caching is a great method of caching, it can also become the worst kind if there is just too much to cache.</p><p>It is therefore wise to think about different caching methods (filesystem cache, for example, only with blog posts and application configuration, for example, in memory cache) before just generally using a method.</p></div></div>
<div class="section" title="Understanding and using storage plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Understanding and using storage plugins</h1></div></div></div><p>Instead of customizing <a id="id617" class="indexterm"/>everything, Zend Framework 2 provides an excellent interface that can manipulate the storing, removing, and retrieving of cache data by using storage plugins.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>How to do it…</h2></div></div></div><p>Storage plugins are <a id="id618" class="indexterm"/>used to compliment the storage adapters whenever a developer feels that they need more functionality added to the adapter without necessarily making a custom adapter. Therefore, plugins are the handiest tool to use when we want to modify the way our storage adapters handle the cache.</p><p>There are a couple of storage plugins readily available in Zend Framework 2, so let's get cracking on and explain them a bit further.</p><div class="section" title="Using the ClearExpiredByFactor plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec225"/>Using the ClearExpiredByFactor plugin</h3></div></div></div><p>The <a id="id619" class="indexterm"/>
<code class="literal">ClearExpiredByFactor</code> plugin <a id="id620" class="indexterm"/>clears the expired cache items once in a while, which are <a id="id621" class="indexterm"/>determined by a set factor. The higher the factor integer is, the less likely it will be that the cache will clear its expired items. But don't forget; this being a (pseudo) random process and all chances could be that it will be called every single time. We understand that this is incredibly counterintuitive, so maybe this code snippet taken from the plugin will clear things up.</p><div class="informalexample"><pre class="programlisting">if ($factor &amp;&amp; mt_rand(1, $factor) == 1) {
     $storage-&gt;clearExpired();
}</pre></div><p>We should also note that this plugin is only fired when there is cache to be written, it does not fire when cache is read.</p><p>
<code class="literal">PluginOptions</code> that can be set is <code class="literal">setClearingFactor</code>, which sets the clearing factor.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>This plugin requires the storage adapter to be an instance of <code class="literal">ClearExpiredInterface</code>, otherwise it will not do anything (and we would never know as it doesn't log this error). Only the Filesystem and Memory Storage adapters support this interface.</p></div></div></div><div class="section" title="Using the ExceptionHandler plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec226"/>Using the ExceptionHandler plugin</h3></div></div></div><p>The <a id="id622" class="indexterm"/>
<code class="literal">ExceptionHandler</code> plugin <a id="id623" class="indexterm"/>catches any <a id="id624" class="indexterm"/>exceptions that are thrown when getting/setting the cache and forwards it to a developer defined callback.</p><p>
<code class="literal">PluginOptions</code> that can be set are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setExceptionCallback</code>: This is a callback function to call when an exception occurs</li><li class="listitem" style="list-style-type: disc"><code class="literal">setThrowExceptions</code>: This is a Boolean (default <code class="literal">true</code>) value that tells the plugin to re-throw exceptions that it caught</li></ul></div></div><div class="section" title="Using the IgnoreUserAbort plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec227"/>Using the IgnoreUserAbort plugin</h3></div></div></div><p>The <a id="id625" class="indexterm"/>
<code class="literal">IgnoreUserAbort</code> plugin makes sure<a id="id626" class="indexterm"/> that the <a id="id627" class="indexterm"/>script isn't aborted before the writing has finished to the cache. This way we can be sure we won't get any corrupted data in our cache.</p><p>
<code class="literal">PluginOptions</code> that can be set is <code class="literal">setExitOnAbort</code>, which is a Boolean (default <code class="literal">true</code>) value that tells us if we can abort the script whenever we want, or if we need to wait until we are done writing.</p></div><div class="section" title="Using the OptimizeByFactor plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec228"/>Using the OptimizeByFactor plugin</h3></div></div></div><p>You wanted<a id="id628" class="indexterm"/> to<a id="id629" class="indexterm"/> clear by factor? I am sure you also <a id="id630" class="indexterm"/>want to optimize by factor then! This plugin (pseudo) randomly optimizes the cache. The factor determines the chance it has of actually optimizing, the lower the number (between 1 and a high number) the greater chance, the higher the number the lower the chance. We understand that this is incredibly counterintuitive, so maybe this code snippet taken from the plugin will clear things up:</p><div class="informalexample"><pre class="programlisting">if ($factor &amp;&amp; mt_rand(1, $factor) == 1) {
     $storage-&gt;clearExpired();
}</pre></div><p>We should also note that this plugin is only fired when there is cache to be removed, it does not fire when the cache is read or written.</p><p>
<code class="literal">PluginOptions</code> that can be set is <code class="literal">setOptimizingFactor</code>, which sets the optimizing factor.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>This plugin only works on storage adapters with an instance of <code class="literal">OptimizableInterface</code>. If this is not available it will not throw an error, so we will never know. The adapters currently supporting this interface are Dba and Filesystem.</p></div></div></div><div class="section" title="Using the Serializer plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec229"/>Using the Serializer plugin</h3></div></div></div><p>The <a id="id631" class="indexterm"/>
<code class="literal">Serializer</code> plugin <a id="id632" class="indexterm"/>will serialize<a id="id633" class="indexterm"/> and unserialize the data when setting and getting it from the cache.</p><p>
<code class="literal">PluginOptions</code> that can be set:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setSerializer</code>: This sets the serializer we want to use, it needs to be an class that implements the <code class="literal">Zend\Serializer\Adapter\AdapterInterface</code> class</li><li class="listitem" style="list-style-type: disc"><code class="literal">setSerializerOptions</code>: If a string is given at the <code class="literal">setSerializer</code> option (the full class name as a string) then the instantiation options need to be set in this option</li></ul></div></div><div class="section" title="Using any plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec230"/>Using any plugin</h3></div></div></div><p>Fortunately<a id="id634" class="indexterm"/> plugins are easy to use, and all we have to do is add them to the storage adapter to make it work.</p><p>We know that there are several ways of instantiating plugins, but we will just display one method to show off how it basically works:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Use the following libraries for our example
use Zend\Cache\Storage\Plugin\Serializer;
use Zend\Cache\Storage\Adapter\FileSystem;

// Initialize our Serializer plugin
$plugin = new Serializer();

// Initialize our FileSystem adapter
$adapter = new FileSystem();

// Now bind the two together
$adapter-&gt;addPlugin($plugin);</pre></div><p>That's all that needs configuring to make it all work together nicely. In a MVC application (which we probably will use Zend Framework 2 for) plugin can be on very different locations.<a id="id635" class="indexterm"/> Normally though we want to configure this in the configuration or in the bootstrap event if we will use it constantly throughout the application, as that will save time compared to instantiating it more than once.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>How it works…</h2></div></div></div><p>Plugins are attached to storage adapters and work because they attach themselves to events of the storage adapters. When these events get triggered, the functionality gets triggered as well. It is really as simple as that, and there is no real further explanation needed for this.</p></div></div>
<div class="section" title="Setting up a caching system"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Setting up a caching system</h1></div></div></div><p>A good <a id="id636" class="indexterm"/>example on how to do it is always the best way to learn a new technique quickly. That is why we will show you how to implement a caching system on different parts of our application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Getting ready</h2></div></div></div><p>In this recipe we will show off a simple system that makes use of caching. We will also show off some benchmarks so that we can clearly see the differences between a system without caching and a system with caching. The code for this project can also be found with the book, which contain a couple of sample classes so that we can measure the performance a bit better. We will not discuss any of the sample classes (which all can be found in the <code class="literal">/module/Application/src/Application</code> directory), but we will refer to them in some of the examples.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>How to do it…</h2></div></div></div><p>Setting up a simple caching system is easy enough, but the question most of the time is, where to begin.</p><div class="section" title="Benchmarking our application before cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec231"/>Benchmarking our application before cache</h3></div></div></div><p>For the benchmark <a id="id637" class="indexterm"/>we will use an application called <code class="literal">ab</code>, which is short for ApacheBench. This is a tool which comes standard with the Apache web server on both the Microsoft Windows as the Linux version; for our recipe we will be using the Linux version of the benchmarking tool, don't worry though as both versions do exactly the same.</p><p>For our benchmark, <a id="id638" class="indexterm"/>we will use no caching at all and we will use the following code in <code class="literal">Application\Controller\IndexController</code> (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>) to generate our ridiculously long output:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Don't forget to set our namespace
namespace Application\Controller;

// Use the following classes 
use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

// Define our class name and extend
class IndexController extends AbstractActionController
{
  // We will just use the index for this
  public function indexAction()
  {
    // Initialize our LongOutput class
    $output = new \Application\Model\LongOutput();

    // echo our stupidly long output 
    echo '&lt;!-- '. $output-&gt;run(1500). ' --&gt;';

    // Just return a view model, it doesn't affect us
    return new ViewModel();
  }
}</pre></div><p>This action will output a very long string, which is overly complicated, but we don't really care about that as we just want to measure how long it takes to create such a string. We can now commence with the first benchmark.</p><p>The following command will be used to do the benchmarking:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ab -c 4 -n 10 http://localhost/</strong></span>
</pre></div><p>The command stands for a concurrency of four (<code class="literal">-c 4</code>) and we want to run the test ten times (<code class="literal">-n 10</code>) on the <code class="literal">localhost</code> as our website. This means that a total of 40 times our page will be visited, which will give us quite a clear view on the average in response times.</p><p>The following is a<a id="id639" class="indexterm"/> review of the most important result of the benchmark. Obviously the rest of the result is also somewhat interesting, but we are just interested in the response time at the moment.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time taken for tests:   18.111 seconds</strong></span>
</pre></div><p>We will use the 18.111 seconds as the base to compare all the other results with.</p></div><div class="section" title="Implementing configuration/class map cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec232"/>Implementing configuration/class map cache</h3></div></div></div><p>First we are<a id="id640" class="indexterm"/> going to implement the configuration cache as that is the basis of all caching (at least I like to think so).</p><p>We can do that by adding the following configuration to the <code class="literal">/config/application.config.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Lets add our options to the configuration array, 
// please be aware that we don't show any other options 
// here that could very well be in the configuration 
// already.
return array(
  // We should add our options inside this array key
  'module_listener_options' =&gt; array(
    // Enable the config cache
    'config_cache_enabled' =&gt; true,

    // Give the config cache a file name like module-
    // config-cache.config.php
    'config_cache_key' =&gt; 'config',

    // Enable the class map caching
    'module_map_cache_enabled' =&gt; true,

    // Give the class map cache a file name like module-
    // classmap-cache.classmap.php
    'module_map_cache_key' =&gt; 'classmap',

    // Use our data/cache as the cache directory 
    // (remember this directory need to be writeable for 
    // the web server).
    'cache_dir' =&gt; 'data/cache',
    // We don't want to check the module dependencies as 
    // that is the job of the developer, it just takes 
    // time to do this and is pretty much useless.
    'check_dependencies' =&gt; false,
  ),
);</pre></div><p>We now enabled the<a id="id641" class="indexterm"/> configuration/class map caching, which should get us a very (very) small increase in response time. Naturally, this will be a bigger difference when we have a larger application with more modules.</p><p>Let's do our benchmark again to see what the difference is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time taken for tests:   15.428 seconds</strong></span>
</pre></div><p>As we can see our result has been significantly different, a staggering 14.2 percent faster actually. We should not forget, however, that our application is incredibly small and this percentage may actually be a lot smaller if our application grows larger in the future. Still, this is a clear sign that caching our configuration and class mapping is a good practice.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>A little bug in the configuration caching system we should wary about is that we cannot use closures (also called anonymous functions). If we do we get a PHP fatal error saying something like the following:</p><div class="informalexample"><pre class="programlisting">Call to undefined method Closure::__set_state() in your_configuration_cache.php on line XX</pre></div></div></div></div><div class="section" title="Implementing the class caching"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec233"/>Implementing the class caching</h3></div></div></div><p>Because we have <a id="id642" class="indexterm"/>this incredibly long output, it is interesting to use the <code class="literal">ClassCache</code> adapter to cache the output of the single method that generates this output. And we also know our <code class="literal">LongOutput</code> model has no output that changes, we can safely cache the output.</p><p>For this caching method to work we need to make sure that the configuration cache has been turned off, otherwise it will end up in a PHP error.</p><p>We are going to change <code class="literal">module.config.php</code> in the <code class="literal">Application</code> module first to initialize our cache storage adapter first. After that we will change the <code class="literal">Application\Controller\IndexController</code> so that we can use our pattern. We can just add the<a id="id643" class="indexterm"/> following code to <code class="literal">/module/Application/config/module.config.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // We are configuring the service manager
  'service_manager' =&gt; array(
    'factories' =&gt; array(
      // Initialize our file system storage
      'Zend\Cache\StorageFactory' =&gt; function() {
        return Zend\Cache\StorageFactory::factory(
          array(
            'adapter' =&gt; array(
              'name' =&gt; 'filesystem',
              'options' =&gt; array(
                // Define the directory to store the 
                // cache in 
                'cacheDir' =&gt; 'data/cache',
              ),
            ),
            // For the file system storage we need to 
            // have the serializer plugin enabled, 
            // otherwise thing just go wrong when we  
            // want to storage a class or so
            'plugins' =&gt; array('serializer'),
          ),
        );
      }
    ),
    // We want to call our cache with the 'cache' key
    'aliases' =&gt; array(
      'cache' =&gt; 'Zend\Cache\StorageFactory',
    ),
  ),
);</pre></div><p>Now we have initialized our cache, we need to make sure our output is cached as well. This will be done in <code class="literal">IndexController</code> (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>) of our <code class="literal">Application</code> module:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Set the namespace
namespace Application\Controller;

// Define the imports
use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

// Define the class name and extend
class IndexController extends AbstractActionController
{

  // Begin our index action again
  public function indexAction()
  {
    // This time we want to make sure our class is 
    // loaded in to the ClassCache pattern so that we 
    // can eventually cache the output of our class 
    // method    
    $pattern = \Zend\Cache\PatternFactory::factory(
           'class', array(
      'storage' =&gt; $this-&gt;getServiceLocator()-&gt;get('cache'),
      'class' =&gt; '\Application\Model\LongOutput'
    ));
  
    // Now call our method through the ClassCache 
    // pattern with the same arguments as the previous 
    // test
    echo '&lt;!-- '. $pattern-&gt;call('run', array(1500)). '--&gt;';
  
    // Return the view model again because we don't 
    // actually do anything with it
    return new ViewModel();
  }
}</pre></div><p>If we now take a look at the benchmarking, we can see that the following caching has resulted in the following performance improvement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time taken for tests:   14.956 seconds</strong></span>
</pre></div><p>As we can see this is almost a 17.4 percent improvement on the original benchmark, which obviously is a fantastic improvement. It is also a 3.2 percent response increase in comparison to the configuration/class map caching. We know that this doesn't sound too impressive, and we understand your disappointment. However, do understand that in real life a database call or a service call can take a lot longer than this, and the percentage of improvement therefore would be much more!</p><p>There is only <a id="id644" class="indexterm"/>one slight issue with this method; and that is we won't be able to cache the configuration/class map this way. Because we want to optimize our application the best we can, this is obviously not good practice. Don't panic, however, there is a solution to this issue, and it comes in the form of <code class="literal">StorageCacheFactory</code>!</p><p>We didn't immediately discuss this because it is always best to see more than one way of coding, at least that is my personal choice.</p><p>What we'll do is strip the configuration we just added in <code class="literal">/module/Application/config/module.config.php</code> and add the following configuration:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// We need to assume that we have stripped the previous 
// configuration out of here and it is back to the 
// default configuration file
return array(
  'service_manager' =&gt; array(
    // Instantiate the cache through our storage cache 
    // factory. It will look for the 'cache' key to 
    // initialize the cache
    'factories' =&gt; array(
        'cache' =&gt; '\Zend\Cache\Service\StorageCacheFactory',
    ),
  ),

  // And here we go, initializing the cache
  'cache' =&gt; array(
    // We want to use the filesystem adapter
    'adapter' =&gt; 'Filesystem',
    'options' =&gt; array(
      // Of course we need to set the directory to cache 
      // in
      'cache_dir' =&gt; 'data/cache'
    ),

    // We also want the serializer otherwise it will 
    // throw an exception
    'plugins' =&gt; array('Serializer'),
  ),
);</pre></div><p>If we now turn <a id="id645" class="indexterm"/>back on the configuration and class map caching and do a benchmark, we get the following result.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time taken for tests:   14.303 seconds</strong></span>
</pre></div><p>As we can see this time with both caching systems enabled, we get a 21 percent speed increase in comparison to the original.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>How it works…</h2></div></div></div><p>It is always good to cache the things we use regularly and are sure about their persistence. If we know a class's output doesn't change, but for example merely does some calculations we know that it will be a strong candidate to use for caching. Don't forget that caching methods which rely on third party input, such as databases, are harder to cache as they require a certain time-to-live in which the cache knows the data they have cached is out-of-date.</p><p>Another thing to look out for is to cache too much, that way your application actually slows down instead of speeding up as the cache is too busy refreshing/getting and setting the cache instead of actually outputting it. A good way of auto-cleaning and auto-optimizing however, is by setting up a periodic <code class="literal">cron</code> (much like scheduled tasks for Windows users) process that runs periodically.</p></div></div></body></html>