- en: Factories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: Factories are a powerful abstraction. They help decouple the client from the
    details of how to interact with the Domain. The client doesn't need to know how
    to build complex objects and Aggregates, so you can use Factories to create whole
    Aggregates, thereby enforcing their invariants.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是一个强大的抽象。它们帮助客户端与领域交互的细节解耦。客户端不需要知道如何构建复杂对象和聚合，因此可以使用工厂创建整个聚合，从而强制执行其不变性。
- en: Factory Method on Aggregate Root
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合根上的工厂方法
- en: 'The [Factory Method](https://en.wikipedia.org/wiki/Factory_method_pattern) pattern,
    as defined in the classic, [Gang of Four](http://wiki.c2.com/?GangOfFour), is
    a creational pattern that:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 经典著作中定义的[工厂方法模式](https://en.wikipedia.org/wiki/Factory_method_pattern)，在《设计模式：可复用面向对象软件的基础》一书中，是一个创建型模式，它：
- en: Defines an interface for creating an object, but leaves the choice of its type
    to the subclasses, creation being deferred at run-time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个创建对象的接口，但将其实例化类型的选择留给子类，创建在运行时延迟。
- en: Adding a Factory Method in the Aggregate Root hides the internal implementation
    details of creating Aggregates from any external client. This also moves the responsibility
    for the integrity of the Aggregate back to the root.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合根中添加工厂方法隐藏了创建聚合的内部实现细节，这对于任何外部客户端都是不可见的。这也将聚合完整性的责任移回根。
- en: In a Domain Model where we have a `User` Entity and a `Wish` Entity, the `User`
    acts as the Aggregate root. There's no `Wish` without `User`. The `User` Entity
    should manage its Aggregates.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含`User`实体和`Wish`实体的领域模型中，`User`充当聚合根。没有`User`就没有`Wish`。`User`实体应该管理其聚合。
- en: 'The way to move the control of `Wish` back to the `User` Entity is by placing
    a Factory method in the Aggregate root:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Wish`的控制权移回`User`实体，是通过在聚合根中放置一个工厂方法来实现的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The client doesn''t need to know the internal details of how the Aggregate
    Root handles the creation logic:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不需要知道聚合根如何处理创建逻辑的内部细节：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Forcing Invariants
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制不变性
- en: Factory Methods in the Aggregate Root are also a good place for invariants.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根中的工厂方法也是处理不变性的好地方。
- en: 'In a Domain Model with `Forum` and `Post` Entities, where `Post` is an aggregated
    part of the Aggregate Root `Forum`, publishing a `Post` could look something like
    this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含`Forum`和`Post`实体的领域模型中，其中`Post`是聚合根`Forum`的聚合部分，发布`Post`可能看起来像这样：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After talking with a Domain Expert, we came to the conclusion that a `Post`
    shouldn''t be published when the `Forum` is closed. This is an invariant, and
    we could force it directly on `Post` creation, thereby preventing an inconsistent
    Domain state:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与领域专家交谈后，我们得出结论，当`Forum`关闭时，不应发布`Post`。这是一个不变性，我们可以在创建`Post`时直接强制执行，从而防止领域状态不一致：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Factory on Service
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务上的工厂
- en: Decoupling creation logic also comes in handy in our Services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦创建逻辑也对我们服务的实现很有帮助。
- en: Building Specifications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建规范
- en: Using Specifications in our Services might be the best example to illustrate
    how to use Factories within our Services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务中使用规范可能是说明如何在服务中使用工厂的最佳例子。
- en: 'Consider the following Service example. Given a request from the outside world,
    we want to build a feed based on the latest `Posts` added to the system:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下服务示例。给定来自外部世界的请求，我们希望根据系统中最新添加的`Posts`构建一个feed：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finder methods in Repositories like `latestPosts` have some limitations, as
    they keep adding complexity to our Repositories indefinitely. As we discuss in
    the [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories* Specifications
    are a better approach.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的查找方法，如`latestPosts`，有一些限制，因为它们会无限期地向我们的仓库添加复杂性。正如我们在第[10章](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)中讨论的，*仓库*规范是一个更好的方法。
- en: 'Lucky for us, we have a nice `query` method in our `PostRepository` that works
    with Specifications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们`PostRepository`中有一个不错的`query`方法，它与`Specifications`一起工作：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using a concrete implementation for the Specification is a bad idea:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用规范的具体实现是一个坏主意：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Coupling our high-level application Service with a low-level Specification implementation
    mixes layers and breaks the Separation of Concerns. In addition, this is a pretty
    bad way of coupling our Service to a concrete Infrastructure implementation. There's
    no way you could use this Service outside of the SQL persistence solution. What
    if we want to test our Service with an in-memory implementation?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将高级应用程序服务与低级规范实现耦合会混合层次并破坏关注点的分离。此外，这是一种将我们的服务耦合到具体基础设施实现中的非常糟糕的方式。你无法在 SQL
    持久化解决方案之外使用此服务。如果我们想使用内存实现来测试我们的服务怎么办？
- en: 'The solution to this problem is to decouple Specification creation from the
    Service itself by using the [Abstract Factory pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern).
    According to [OODesign.com](http://www.oodesign.com/abstract-factory-pattern.html):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是通过使用[抽象工厂模式](https://en.wikipedia.org/wiki/Abstract_factory_pattern)将规范创建与服务本身解耦。根据[OODesign.com](http://www.oodesign.com/abstract-factory-pattern.html)：
- en: Abstract Factory offers the interface for creating a family of related objects,
    without explicitly specifying their classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂提供了一个创建一组相关对象的接口，而不需要明确指定它们的类。
- en: 'As we might have multiple Specification implementations, we first need to create
    an interface for the Factory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能有多个规范实现，我们首先需要为工厂创建一个接口：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we need to create Factories for each `PostRepository` implementation.
    As an example, a Factory for the in-memory `PostRepository` implementation could
    look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为每个 `PostRepository` 实现创建工厂。例如，内存 `PostRepository` 实现的工厂可能看起来像这样：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have a centralized place for the creation logic, it''s easy to decouple
    it from the Service:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个集中化的创建逻辑位置，就很容易将其从服务中解耦：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, unit testing our Service through an in-memory `PostRepository` implementation
    is pretty easy:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过内存 `PostRepository` 实现对服务进行单元测试相当简单：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Building Aggregates
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聚合体
- en: 'Entities are agnostic to the persistence mechanism. You don''t want to couple
    and pollute your Entities with persistence details. Take a look at the next Application
    Service:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实体对持久化机制是无关的。你不希望将持久化细节耦合并污染你的实体。看看下一个应用程序服务：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Imagine a `User` Entity like the following one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个像以下这样的 `User` 实体：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Imagine we want to use Doctrine as our Infrastructure persistence mechanism.
    Doctrine requires having an `id` as a plain string instance variable in order
    to work properly. In our Entity, `$userId` is a `UserId` Value Object. Adding
    an additional `id` to our `User` Entity just because of Doctrine would couple
    our persistence mechanism with our Domain Model.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用 Doctrine 作为我们的基础设施持久化机制。Doctrine 需要有一个作为普通字符串实例变量的 `id` 才能正常工作。在我们的实体中，`$userId`
    是一个 `UserId` 值对象。仅仅因为 Doctrine 就在我们的 `User` 实体中添加一个额外的 `id` 会将我们的持久化机制与领域模型耦合。
- en: 'We saw in the [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml), *Entities* that
    we could solve this problem with a Surrogate ID by creating a wrapper around our
    `User` Entity in the Infrastructure layer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml)中看到，通过在基础设施层中围绕我们的 `User`
    实体创建一个包装器，我们可以通过代理 ID 解决这个问题：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As creating the `DoctrineUser` in our Application Service would again couple
    the persistence layer with our Domain, we need to decouple the creation logic
    out of the Service with an Abstract Factory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在应用程序服务中创建 `DoctrineUser` 会使持久化层再次与领域模型耦合，我们需要通过抽象工厂将创建逻辑从服务中解耦。
- en: 'We could do this by creating an interface in our Domain:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的领域创建一个接口来完成这个操作：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we place the implementation of it inside our Infrastructure layer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其实现在我们的基础设施层中：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once decoupled, we only need to inject the Factory into our Application Service:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解耦，我们只需要将工厂注入到我们的应用程序服务中：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing Factories
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工厂
- en: 'You''ll see a common pattern while writing your tests. This is because building
    Entities and complex Aggregates can be a very tedious and repetitive process.
    Inevitably, complexity and duplication will start creeping into your test suite.
    Consider the following Entity:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，你会看到一个常见的模式。这是因为构建实体和复杂的聚合体可能是一个非常繁琐和重复的过程。不可避免地，复杂性和重复性将开始渗透到你的测试套件中。考虑以下实体：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Somewhere in your system, you''ll end up with a test looking like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统中某个地方，你最终会得到一个看起来像这样的测试：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Services inside boundaries share concepts like Entities, Aggregates, and Value
    Objects. Imagine the clutter of repeating the same building logic over and over
    across your tests. As we'll see, extracting the building logic out of tests comes
    in handy and prevents duplication.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 边界内的服务共享诸如实体、聚合体和值对象等概念。想象一下，在测试中反复重复相同的构建逻辑是多么的杂乱。正如我们将看到的，将构建逻辑从测试中提取出来非常方便，并且可以防止重复。
- en: Object Mother
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象母体
- en: An [Object Mother](https://martinfowler.com/bliki/ObjectMother.html) is a catchy
    name for a Factory that creates fixed fixtures for your tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[对象母体](https://martinfowler.com/bliki/ObjectMother.html)是一个吸引人的名称，用于指代为你的测试创建固定配置的工厂。'
- en: 'Similar to the previous example, we could extract the duplicated logic to an
    Object Mother so it could be reused across tests:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，我们可以将重复的逻辑提取到对象母体中，以便在多个测试中复用：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You'll notice that the more tests and situations you have, the more methods
    the Factory will have.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，随着测试和情况的增加，工厂将拥有更多的方法。
- en: As Object Mothers aren't very flexible, they tend to grow in complexity quickly.
    Luckily, there's a more flexible alternative for your tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象母体不够灵活，它们往往会迅速增加复杂性。幸运的是，有一个更灵活的替代方案适用于你的测试。
- en: Test Data Builder
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据构建器
- en: 'Test Data Builders are just normal Builders with default values used exclusively
    in your test suites so that you don''t have to specify irrelevant parameters on
    specific test cases:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据构建器只是普通的构建器，它们在测试套件中仅使用默认值，这样你就不必在特定的测试用例中指定无关的参数：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could even combine Test Data Builders to build more complicated Aggregates,
    like a `Post`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将测试数据构建器组合起来构建更复杂的聚合体，例如一个`Post`：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see the corresponding Test Data Builder for our `Post`. We could reuse
    the `AuthorBuilder` for building a default `Author`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们`Post`对应的测试数据构建器。我们可以复用`AuthorBuilder`来构建默认的`Author`：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This solution is now flexible enough to cover any test case, including the
    possibility of building inner Entities:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案现在足够灵活，可以覆盖任何测试用例，包括构建内部实体的可能性：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wrap-Up
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Factories are a powerful tool for decoupling construction logic from our business
    logic. The Factory Method pattern not only helps by moving creation responsibility
    to the Aggregate Root, but it could also force Domain invariants. Using the Abstract
    Factory pattern in our Services allows us to separate our Domain logic from Infrastructure
    creation details. A common use case is that of Specifications and their respective
    persistence implementations. We've seen that Factories come in handy on our test
    suites too. While we could extract building logic into Object Mother Factories,
    Test Data Builders provide more flexibility for our tests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是将构建逻辑从我们的业务逻辑中解耦的强大工具。工厂方法模式不仅通过将创建责任转移到聚合根来帮助，还可以强制执行领域不变性。在我们的服务中使用抽象工厂模式允许我们将领域逻辑与基础设施创建细节分离。一个常见的用例是规范及其相应的持久化实现。我们已经看到，工厂在我们的测试套件中也很有用。虽然我们可以将构建逻辑提取到对象母体工厂中，但测试数据构建器为我们的测试提供了更多的灵活性。
