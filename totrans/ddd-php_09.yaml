- en: Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factories are a powerful abstraction. They help decouple the client from the
    details of how to interact with the Domain. The client doesn't need to know how
    to build complex objects and Aggregates, so you can use Factories to create whole
    Aggregates, thereby enforcing their invariants.
  prefs: []
  type: TYPE_NORMAL
- en: Factory Method on Aggregate Root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [Factory Method](https://en.wikipedia.org/wiki/Factory_method_pattern) pattern,
    as defined in the classic, [Gang of Four](http://wiki.c2.com/?GangOfFour), is
    a creational pattern that:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines an interface for creating an object, but leaves the choice of its type
    to the subclasses, creation being deferred at run-time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Factory Method in the Aggregate Root hides the internal implementation
    details of creating Aggregates from any external client. This also moves the responsibility
    for the integrity of the Aggregate back to the root.
  prefs: []
  type: TYPE_NORMAL
- en: In a Domain Model where we have a `User` Entity and a `Wish` Entity, the `User`
    acts as the Aggregate root. There's no `Wish` without `User`. The `User` Entity
    should manage its Aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to move the control of `Wish` back to the `User` Entity is by placing
    a Factory method in the Aggregate root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The client doesn''t need to know the internal details of how the Aggregate
    Root handles the creation logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Forcing Invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factory Methods in the Aggregate Root are also a good place for invariants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Domain Model with `Forum` and `Post` Entities, where `Post` is an aggregated
    part of the Aggregate Root `Forum`, publishing a `Post` could look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After talking with a Domain Expert, we came to the conclusion that a `Post`
    shouldn''t be published when the `Forum` is closed. This is an invariant, and
    we could force it directly on `Post` creation, thereby preventing an inconsistent
    Domain state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Factory on Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decoupling creation logic also comes in handy in our Services.
  prefs: []
  type: TYPE_NORMAL
- en: Building Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Specifications in our Services might be the best example to illustrate
    how to use Factories within our Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Service example. Given a request from the outside world,
    we want to build a feed based on the latest `Posts` added to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finder methods in Repositories like `latestPosts` have some limitations, as
    they keep adding complexity to our Repositories indefinitely. As we discuss in
    the [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories* Specifications
    are a better approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lucky for us, we have a nice `query` method in our `PostRepository` that works
    with Specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a concrete implementation for the Specification is a bad idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Coupling our high-level application Service with a low-level Specification implementation
    mixes layers and breaks the Separation of Concerns. In addition, this is a pretty
    bad way of coupling our Service to a concrete Infrastructure implementation. There's
    no way you could use this Service outside of the SQL persistence solution. What
    if we want to test our Service with an in-memory implementation?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to decouple Specification creation from the
    Service itself by using the [Abstract Factory pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern).
    According to [OODesign.com](http://www.oodesign.com/abstract-factory-pattern.html):'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory offers the interface for creating a family of related objects,
    without explicitly specifying their classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we might have multiple Specification implementations, we first need to create
    an interface for the Factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create Factories for each `PostRepository` implementation.
    As an example, a Factory for the in-memory `PostRepository` implementation could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a centralized place for the creation logic, it''s easy to decouple
    it from the Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, unit testing our Service through an in-memory `PostRepository` implementation
    is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Building Aggregates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Entities are agnostic to the persistence mechanism. You don''t want to couple
    and pollute your Entities with persistence details. Take a look at the next Application
    Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine a `User` Entity like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Imagine we want to use Doctrine as our Infrastructure persistence mechanism.
    Doctrine requires having an `id` as a plain string instance variable in order
    to work properly. In our Entity, `$userId` is a `UserId` Value Object. Adding
    an additional `id` to our `User` Entity just because of Doctrine would couple
    our persistence mechanism with our Domain Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in the [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml), *Entities* that
    we could solve this problem with a Surrogate ID by creating a wrapper around our
    `User` Entity in the Infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As creating the `DoctrineUser` in our Application Service would again couple
    the persistence layer with our Domain, we need to decouple the creation logic
    out of the Service with an Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do this by creating an interface in our Domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we place the implementation of it inside our Infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once decoupled, we only need to inject the Factory into our Application Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll see a common pattern while writing your tests. This is because building
    Entities and complex Aggregates can be a very tedious and repetitive process.
    Inevitably, complexity and duplication will start creeping into your test suite.
    Consider the following Entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere in your system, you''ll end up with a test looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Services inside boundaries share concepts like Entities, Aggregates, and Value
    Objects. Imagine the clutter of repeating the same building logic over and over
    across your tests. As we'll see, extracting the building logic out of tests comes
    in handy and prevents duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Object Mother
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An [Object Mother](https://martinfowler.com/bliki/ObjectMother.html) is a catchy
    name for a Factory that creates fixed fixtures for your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous example, we could extract the duplicated logic to an
    Object Mother so it could be reused across tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the more tests and situations you have, the more methods
    the Factory will have.
  prefs: []
  type: TYPE_NORMAL
- en: As Object Mothers aren't very flexible, they tend to grow in complexity quickly.
    Luckily, there's a more flexible alternative for your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test Data Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test Data Builders are just normal Builders with default values used exclusively
    in your test suites so that you don''t have to specify irrelevant parameters on
    specific test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We could even combine Test Data Builders to build more complicated Aggregates,
    like a `Post`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the corresponding Test Data Builder for our `Post`. We could reuse
    the `AuthorBuilder` for building a default `Author`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is now flexible enough to cover any test case, including the
    possibility of building inner Entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factories are a powerful tool for decoupling construction logic from our business
    logic. The Factory Method pattern not only helps by moving creation responsibility
    to the Aggregate Root, but it could also force Domain invariants. Using the Abstract
    Factory pattern in our Services allows us to separate our Domain logic from Infrastructure
    creation details. A common use case is that of Specifications and their respective
    persistence implementations. We've seen that Factories come in handy on our test
    suites too. While we could extract building logic into Object Mother Factories,
    Test Data Builders provide more flexibility for our tests.
  prefs: []
  type: TYPE_NORMAL
