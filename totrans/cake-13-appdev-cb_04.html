<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Validation and Behaviors"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Validation and Behaviors</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding multiple validation rules</li><li class="listitem" style="list-style-type: disc">Creating a custom validation rule</li><li class="listitem" style="list-style-type: disc">Using callbacks in behaviors</li><li class="listitem" style="list-style-type: disc">Using behaviors to add new fields for saving</li><li class="listitem" style="list-style-type: disc">Using the Sluggable behavior</li><li class="listitem" style="list-style-type: disc">Geocoding addresses with the Geocodable behavior</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter deals with two aspects of CakePHP models that are fundamental to most applications: validation, and behaviors.</p><p>When we are saving information to a data source, such as a database, CakePHP will automatically ensure that the data is quoted in order to prevent attacks, SQL injection being the most common one. If we also need to ensure that the data follows a certain format, for example, that a phone number is valid, we use validation rules.<a id="id109" class="indexterm"/>
</p><p>There are also times where we need to do more than just validate the data we are working with. In some cases, we need to set values for fields that the end user can't specify but are part of our application logic. CakePHP's behaviors allow us to extend the functionality provided by a model, using callbacks to manipulate the data before it's saved, or after it's fetched.<a id="id110" class="indexterm"/>
</p><p>The third recipe shows us how to use model callbacks (such as<code class="literal"> beforeFind</code> and<code class="literal"> afterFind</code>) in behaviors, while the fourth recipe shows how to use behaviors to add additional field values when a<code class="literal"> save</code> operation is being undertaken.</p><p>The last two recipes in this chapter give examples on how to use the<code class="literal"> Sluggable</code> behavior for creating SEO friendly URLs, and the<code class="literal"> Geocodable</code> behavior to add geocoding support to an<code class="literal"> Address</code> model.</p></div></div>
<div class="section" title="Adding multiple validation rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Adding multiple validation rules</h1></div></div></div><p>This recipe shows how to not only use some basic validation rules provided by CakePHP, but also how to use more than one of these rules per field.<a id="id112" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a sample table to work with. Create a table named<code class="literal"> profiles</code> using the following SQL statement:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `profiles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`email` VARCHAR(255) NOT NULL,
`name` VARCHAR(255) default NULL,
`twitter` VARCHAR(255) default NULL,
PRIMARY KEY(`id`)
);
</pre></div><p>We proceed now to create the required model. Create the model<code class="literal"> Profile</code> in a file named<code class="literal"> profile.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Profile extends AppModel {
public $validate = array(
'email' =&gt; array('rule' =&gt; 'notEmpty'),
'name' =&gt; array('rule' =&gt; 'notEmpty')
);
}
?&gt;
</pre></div><p>Create its appropriate controller<code class="literal"> ProfilesController</code> in a file named<code class="literal"> profiles_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class ProfilesController extends AppController {
public function add() {
if (!empty($this-&gt;data)) {
$this-&gt;Profile-&gt;create();
if ($this-&gt;Profile-&gt;save($this-&gt;data)) {
$this-&gt;Session-&gt;setFlash('Profile created');
$this-&gt;redirect('/');
} else {
$this-&gt;Session-&gt;setFlash('Please correct the errors');
}
}
}
}
?&gt;
</pre></div><p>Create a folder named<code class="literal"> profiles</code> in your<code class="literal"> app/views</code> folder. Create the view to hold the form in a file named<code class="literal"> add.ctp</code>, and place it in your<code class="literal"> app/views/profiles</code> folder, with the following contents:<a id="id113" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo $this-&gt;Form-&gt;create();
echo $this-&gt;Form-&gt;inputs(array(
'email',
'name',
'twitter'
));
echo $this-&gt;Form-&gt;end('Create');
?&gt;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>How to do it...</h2></div></div></div><p>We already have basic validation rules set for the<code class="literal"> email</code> and<code class="literal"> name</code> fields, which guarantee that none of these fields can be empty. We now want to add another validation rule to ensure that the email entered is always a valid e-mail address. Edit the<code class="literal"> Profile</code> model and change the defined validation rule as follows:</p><div class="informalexample"><pre class="programlisting">class Profile extends AppModel {
public $validate = array(
'email' =&gt; array(
<span class="strong"><strong>'valid' =&gt; array(
'rule' =&gt; 'email',
'message' =&gt; 'The email entered is not a valid email address'
),
'required' =&gt; array(
'rule' =&gt; 'notEmpty',
'message' =&gt; 'Please enter an email'</strong></span>
)
),
'name' =&gt; array('rule' =&gt; 'notEmpty')
);
}
</pre></div><p>If we now browse to<code class="literal"> http://localhost/profiles/add</code> and click the<span class="strong"><strong> Create</strong></span> button without entering any information, we should see the customized error message for the<code class="literal"> email</code> field and the default error message for the<code class="literal"> name</code> field as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1926_04_01.jpg" alt="How to do it..."/></div><p>If we instead specify an invalid e-mail address, the validation message should change to the one specified in the view.<a id="id114" class="indexterm"/>
</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>How it works...</h2></div></div></div><p>Each field specified in the model's<code class="literal"> validate</code> property can contain any number of validation rules. When we specify more than one rule, we wrap them in an array, indexing it with a descriptive key to help us identify which rule failed. Therefore, we chose to index the<code class="literal"> notEmpty</code> rule with a<code class="literal"> required</code> key, and the<code class="literal"> email</code> rule with a<code class="literal"> valid</code> key.</p><p>When we specify more than one validation rule, CakePHP will evaluate each rule in the order we used when adding them to the<code class="literal"> validate</code> property. If more than one validation rule fails for a field, the last rule that failed is the one that is used to trigger the error message. In our case, the first rule is<code class="literal"> valid</code>, and the second one<code class="literal"> required</code>. Therefore if both rules fail, the field is set to have failed the<code class="literal"> required</code> rule.</p><p>If we wanted to ensure that a particular rule is executed after all others have, we use the<code class="literal"> last</code> rule setting. Setting it to<code class="literal"> true</code> will ensure that a particular rule is executed after all others. In our example, we could have defined the<code class="literal"> required</code> validation first in the list of rules for the<code class="literal"> email</code> field and set its<code class="literal"> last</code> setting to<code class="literal"> true</code>, which would have the same result as defining the<code class="literal"> required</code> rule after all others.<a id="id115" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>There's more...</h2></div></div></div><p>In this recipe, we used the model to specify what error message is shown for each failing rule. We could instead choose to do it in the view.</p><p>Using the indexes that identify each rule, we can specify which error message should be shown whenever one of these rules fails validation. We do so by setting the<code class="literal"> error</code> option in the field definition to an array of error messages, each indexed by a matching validation rule key (in our case, one of<code class="literal"> required</code> and<code class="literal"> valid</code> for the<code class="literal"> email</code> field).</p><p>Edit the<code class="literal"> app/views/profiles/add.ctp</code> file and change the<code class="literal"> email</code> field definition as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo $this-&gt;Form-&gt;create();
echo $this-&gt;Form-&gt;inputs(array(
<span class="strong"><strong>'email' =&gt; array(
'error' =&gt; array(
'required' =&gt; 'Please enter an email',
'valid' =&gt; 'The email entered is not a valid email address'
)
),</strong></span>
'name',
'twitter'
));
echo $this-&gt;Form-&gt;end('Create');
?&gt;
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Internationalizing model validation messages</em></span> in the<span class="emphasis"><em> Internationalizing applications</em></span> chapter.</li></ul></div></div></div>
<div class="section" title="Creating a custom validation rule"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Creating a custom validation rule</h1></div></div></div><p>CakePHP provides a handful of validation rules out of the box, which together covers the need for most applications. The following table lists the built-in validation rules (found in CakePHP's<code class="literal"> Validation</code> class.)<a id="id116" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Rule</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_alphaNumeric</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks that the value contains only integers or letters.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_between</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks that the string length of the value is within the specified range.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_blank</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if the value is empty, or consists of only spaces (whitespaces, tabs, newlines, and so on).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_boolean</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks if value can be interpreted as a Boolean.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_cc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates a credit card number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_comparison</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Compares the value to a given value, using the specified operator.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_custom</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates the value using a custom regular expression.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_date</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates the value as a date, using the given format or regular expression.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_decimal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if value is a valid decimal number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_email</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates an e-mail address.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_equalTo</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if the value is equal to the given value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_extension</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Interprets the value as a file name and checks for the given extension.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_inList</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks that the value is within a list of allowed values.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_ip</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates an IP address.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_maxLength</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks that the length of the string value does not exceed a certain number of characters.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_minLength</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Similar to maxLength, but ensures that the string value has at least the given number of characters.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_money</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks that the value is a valid monetary amount.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_multiple</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates a multiple select against a set of options.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_numeric</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if the value is numeric.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_phone</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks a phone number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_postal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates a postal code.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_range</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if the value is within a numeric range.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_ssn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Checks a social security/national identity number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates the value as a time (24 hours format).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_uuid</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Validates the value as a UUID.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">_url</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Succeeds if the value is a valid URL.</p>
</td></tr></tbody></table></div><p>However, there are times where we require a custom validation, or where we need to change the way an existing validation works.</p><p>In this recipe, we will learn how to create our custom validation rule to check the validity of a given twitter user name.<a id="id117" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Getting ready</h2></div></div></div><p>We need some sample models to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe<span class="emphasis"><em> Adding multiple validation rules</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>How to do it...</h2></div></div></div><p>Edit the<code class="literal"> Profile</code> model by opening your<code class="literal"> app/models/profile.php</code> file and make the following changes:<a id="id118" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class Profile extends AppModel {
public $validate = array(
'email' =&gt; array('rule' =&gt; 'notEmpty'),
'name' =&gt; array('rule' =&gt; 'notEmpty'),
<span class="strong"><strong>'twitter' =&gt; array(
'rule' =&gt; 'validateTwitter',
'allowEmpty' =&gt; true,
'message' =&gt; 'This twitter account is not valid'
)</strong></span>
);
protected static $httpSocket;
<span class="strong"><strong>protected function validateTwitter($data) {
if (!isset(self::$httpSocket)) {
App::import('Core', 'HttpSocket');
self::$httpSocket = new HttpSocket();
}
$value = current($data);
self::$httpSocket-&gt;get('http://twitter.com/status/user_timeline/' . $value . '.json?count=1');
return (self::$httpSocket-&gt;response['status']['code'] != 404);
}</strong></span>
}
</pre></div><p>If we now browse to<code class="literal"> http://localhost/profiles/add</code> and click the<code class="literal"> Create</code> button after entering a Nonexistent Twitter account, we should see the error message for the<code class="literal"> twitter</code> field shown in the following screenshot:<a id="id119" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926_04_02.jpg" alt="How to do it..."/></div><p>If we instead specify a valid account, or leave it empty, there will be no error message displayed for the<code class="literal"> twitter</code> field.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>How it works...</h2></div></div></div><p>When we set the<code class="literal"> rule</code> validate option to the name of a method that is available in the model (<code class="literal">validateTwitter()</code> in our example), CakePHP calls that method when the field needs to be validated.<a id="id120" class="indexterm"/>
</p><p>The method<code class="literal"> validateTwitter()</code>, like any custom validation method, receives an array in its first argument. This array is indexed by the field name, and the value is set to the value entered by the user. In the example shown in the previous screenshot, the<code class="literal"> data</code> argument comes in as:</p><div class="informalexample"><pre class="programlisting">array('twitter' =&gt; 'nonexistingtwitteraccount')
</pre></div><p>The validation method needs to return a Boolean value to indicate success:<code class="literal"> true</code> if the validation succeeded,<code class="literal"> false</code> if it failed. If we don't set the<code class="literal"> allowEmpty</code> option to<code class="literal"> true</code>, then the validation method will also be called when the field value is empty.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"/>Note</h3><p>If the custom validation method returns a string, the field is marked to have failed validation, and the returned string is used as the error message.</p></div><p>The method<code class="literal"> validateTwitter()</code> first checks to see if an instance of the CakePHP<code class="literal"> HttpSocket</code> class is already set. We use a static instance to make sure the class is initialized only once, thus avoiding unnecessary processing if the method is called several times for the same process.</p><p>Once we have the<code class="literal"> HttpSocket</code> instance, we get the value to be validated (first value set in the array, as shown above), and we use it to fetch the contents of a twitter URL.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"/>Note</h3><p>We could have used an <a class="ulink" href="http://twitter.com/$account">http://twitter.com/$account</a> URL, which returns the HTML containing the user latest tweets. However we chose to use a<code class="literal"> JSON</code> request, and limit the number of tweets to<code class="literal"> 1</code>, to reduce bandwidth usage from our server</p></div><p>This publicly available Twitter URL is used to get the timeline for a Twitter account, which returns an HTTP status of<code class="literal"> 404</code> when the account is not registered with Twitter. If the status is indeed<code class="literal"> 404</code>, we consider the Twitter account to be nonexistent, thus failing validation. Any other status code will result in a successful validation.<a id="id121" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>There's more...</h2></div></div></div><p>Some custom validation methods need more than just the value to be validated to be able to tell if validation succeeded. Fortunately, CakePHP not only sends us an array of options utilized to perform the validation in the second argument, but also provides an easy way to add parameters to our validation methods. Using our example, we now want to be able to provide a different URL to use when checking the Twitter account.</p><p>To utilize the array of options, edit the<code class="literal"> Profile</code> model by opening your<code class="literal"> app/models/profile.php</code> file and make the following changes:</p><div class="informalexample"><pre class="programlisting">class Profile extends AppModel {
public $validate = array(
'email' =&gt; array('rule' =&gt; 'notEmpty'),
'name' =&gt; array('rule' =&gt; 'notEmpty'),
'twitter' =&gt; array(
'rule' =&gt; 'validateTwitter',
'allowEmpty' =&gt; true,
<span class="strong"><strong>'url' =&gt; 'http://twitter.com/%TWITTER%'</strong></span>
)
);
<span class="strong"><strong>protected function validateTwitter($data, $options) {</strong></span>
static $httpSocket;
if (!isset($httpSocket)) {
App::import('Core', 'HttpSocket');
$httpSocket = new HttpSocket();
}
<span class="strong"><strong>$options = array_merge(array(
'url' =&gt; 'http://twitter.com/status/user_timeline/%TWITTER%.json?count=1'
), $options);</strong></span>
$value = current($data);
<span class="strong"><strong>$httpSocket-&gt;get(str_ireplace('%TWITTER%', $value, $options['url']));</strong></span>
return ($httpSocket-&gt;response['status']['code'] != 404);
}
}
</pre></div><p>If instead of utilizing the array of options, we want to utilize the ability to use extra parameters, we simply add arguments to our validation method, and pass those argument values as elements of the<code class="literal"> validate</code> definition. To do so, edit the<code class="literal"> Profile</code> model by opening your<code class="literal"> app/models/profile.php</code> file and make the following changes:<a id="id122" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class Profile extends AppModel {
public $validate = array(
'email' =&gt; array('rule' =&gt; 'notEmpty'),
'name' =&gt; array('rule' =&gt; 'notEmpty'),
'twitter' =&gt; array(
<span class="strong"><strong>'rule' =&gt; array(
'validateTwitter',
'http://twitter.com/%TWITTER%'
),
'allowEmpty' =&gt; true</strong></span>
)
);
protected static $httpSocket;
protected function validateTwitter($data, $url = 'http://twitter.com/status/user_timeline/%TWITTER%.json?count=1') {
if (!isset(self::$httpSocket)) {
App::import('Core', 'HttpSocket');
self::$httpSocket = new HttpSocket();
}
$value = current($data);
<span class="strong"><strong>self::$httpSocket-&gt;get(str_ireplace('%TWITTER%', $value, $url));</strong></span>
return (self::$httpSocket-&gt;response['status']['code'] != 404);
}
}
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Adding multiple validation rules</em></span></li></ul></div></div></div>
<div class="section" title="Using callbacks in behaviors"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Using callbacks in behaviors</h1></div></div></div><p>CakePHP behaviors are a great way to not only extend model functionality, but also share that functionality across different models, and applications. Using behaviors, we can keep our model code concise and to the point, extracting code that may not be directly related to our business logic, but still affect how our models behave.<a id="id123" class="indexterm"/>
</p><p>In this recipe we will learn how to use model callbacks to automatically retrieve each profile's latest tweets, and how to add a custom validation method to the behavior.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Getting ready</h2></div></div></div><p>We need some sample models to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe<span class="emphasis"><em> Adding multiple validation rules</em></span>.</p><p>We will also need a method to list all profiles. Edit your<code class="literal"> app/controllers/profiles_controller.php</code> file and add the following<code class="literal"> index()</code> method to the<code class="literal"> ProfilesController</code> class:</p><div class="informalexample"><pre class="programlisting">public function index() {
$profiles = $this-&gt;Profile-&gt;find('all');
$this-&gt;set(compact('profiles'));
}
</pre></div><p>Create the respective view in a file named<code class="literal"> app/views/profiles/index.ctp</code>, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php foreach($profiles as $profile) { ?&gt;
&lt;p&gt;
&lt;?php echo $this-&gt;Html-&gt;link(
$profile['Profile']['twitter'],
'http://twitter.com/' . $profile['Profile']['twitter'],
array('title' =&gt; $profile['Profile']['twitter'])
); ?&gt;
&lt;/p&gt;
&lt;?php } ?&gt;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a class named<code class="literal"> TwitterAccountBehavior</code> in a file named<code class="literal"> twitter_account.php</code> and place it in your<code class="literal"> app/models/behaviors</code> folder, with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
App::import('Core', 'HttpSocket');
class TwitterAccountBehavior extends ModelBehavior {
protected static $httpSocket;
public function setup($model, $config = array()) {
parent::setup($model, $config);
$this-&gt;settings[$model-&gt;alias] = array_merge(array(
'field' =&gt; 'twitter'
), $config);
}
protected function timeline($twitter, $count = 10, $returnStatus = false) {
if (!isset(self::$httpSocket)) {
self::$httpSocket = new HttpSocket();
}
$content = self::$httpSocket-&gt;get('http://twitter.com/status/user_timeline/' . $twitter . '.json?count=' . $count);
$status = self::$httpSocket-&gt;response['status']['code'];
if (!empty($content)) {
$content = json_decode($content);
}
if ($returnStatus) {
return compact('status', 'content');
}
return $content;
}
}
?&gt;
</pre></div></li><li class="listitem">Now that we have created the behavior with its<code class="literal"> setup()</code> method implemented and a helper<code class="literal"> timeline()</code> method to obtain tweets from a Twitter account, we can proceed to add the required validation.<a id="id124" class="indexterm"/><p>Add the following custom validation method to the TwitterAccountBehavior class:
</p><div class="informalexample"><pre class="programlisting">public function validateTwitter($model, $data) {
$field = $this-&gt;settings[$model-&gt;alias]['field'];
if (!empty($data[$field])) {
$value = $data[$field];
$result = $this-&gt;timeline($value, 1, true);
if ($result['status'] == 404) {
$result = false;
}
}
return $result;
}
</pre></div></li><li class="listitem">Let us now attach the behavior to the<code class="literal"> Profile</code> model, and add the validation for the<code class="literal"> twitter</code> field. Open your<code class="literal"> app/models/profile.php</code> file and add the following<code class="literal"> actsAs</code> property and the<code class="literal"> twitter</code> field validation:<a id="id125" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php
class Profile extends AppModel {
<span class="strong"><strong>public $actsAs = array('TwitterAccount');</strong></span>
public $validate = array(
'email' =&gt; array('rule' =&gt; 'notEmpty'),
'name' =&gt; array('rule' =&gt; 'notEmpty'),
<span class="strong"><strong>'twitter' =&gt; array(
'rule' =&gt; 'validateTwitter',
'allowEmpty' =&gt; true,
'message' =&gt; 'This twitter account is not valid'
)</strong></span>
);
}
?&gt;
</pre></div></li><li class="listitem">Just like the recipe<span class="emphasis"><em> Creating a custom validation rule</em></span>, entering a nonexistant Twitter account should display the error message for the<code class="literal"> twitter</code> field shown in the following screenshot:<a id="id126" class="indexterm"/><div class="mediaobject"><img src="graphics/1926_04_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Let us now use other callbacks to get a certain number of tweets for each profile after a find operation is performed. Add the following<code class="literal"> beforeFind()</code> and<code class="literal"> afterFind()</code> methods to the<code class="literal"> TwitterAccountBehavior</code> class:<a id="id127" class="indexterm"/><div class="informalexample"><pre class="programlisting">public function beforeFind($model, $query) {
$this-&gt;settings[$model-&gt;alias]['tweets'] = !isset($query['tweets']) ? true : $query['tweets'];
return parent::beforeFind($model, $query);
}
public function afterFind($model, $results, $primary) {
$rows = parent::afterFind($model, $results, $primary);
if (!is_null($rows)) {
$results = $rows;
}
if (!empty($this-&gt;settings[$model-&gt;alias]['tweets'])) {
$field = $this-&gt;settings[$model-&gt;alias]['field'];
$count = is_int($this-&gt;settings[$model-&gt;alias]['tweets']) ?
$this-&gt;settings[$model-&gt;alias]['tweets'] :
10;
foreach($results as $i =&gt; $result) {
$twitter = $result[$model-&gt;alias][$field];
$tweets = array();
if (!empty($result[$model-&gt;alias][$field])) {
$result = $this-&gt;timeline($twitter, $count);
if (!empty($result) &amp;&amp; is_array($result)) {
foreach($result as $tweet) {
$tweets[] = array(
'created' =&gt; date('Y-m-d H:i:s', strtotime($tweet-&gt;created_at)),
'source' =&gt; $tweet-&gt;source,
'user' =&gt; $tweet-&gt;user-&gt;screen_name,
'text' =&gt; $tweet-&gt;text
);
}
}
}
$results[$i]['Tweet'] = $tweets;
}
}
return $results;
}
</pre></div></li><li class="listitem">Edit the<code class="literal"> app/views/profiles/index.ctp</code> view and make the following changes:<a id="id128" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php foreach($profiles as $profile) { ?&gt;
&lt;p&gt;
&lt;?php echo $this-&gt;Html-&gt;link(
$profile['Profile']['twitter'],
'http://twitter.com/' . $profile['Profile']['twitter'],
array('title' =&gt; $profile['Profile']['twitter'])
); ?&gt;
<span class="strong"><strong>&lt;?php if (!empty($profile['Tweet'])) { ?&gt;
&lt;ul&gt;
&lt;?php foreach($profile['Tweet'] as $tweet) { ?&gt;
&lt;li&gt;
&lt;code&gt;&lt;?php echo $tweet['text']; ?&gt;&lt;/code&gt;
from &lt;?php echo $tweet['source']; ?&gt;
on &lt;?php echo $tweet['created']; ?&gt;
&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
&lt;?php } ?&gt;</strong></span>
&lt;/p&gt;
&lt;?php } ?&gt;
</pre></div></li></ol></div><p>After adding a valid Twitter account, browsing to<code class="literal"> http://localhost/profiles</code> would generate a listing, such as the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1926_04_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>How it works...</h2></div></div></div><p>We started with the skeleton for our<code class="literal"> TwitterAccountBehavior</code>, implementing the<code class="literal"> setup()</code> method, called automatically by CakePHP whenever the behavior is attached to a model, and the<code class="literal"> timeline()</code> method, which is nothing more than the<code class="literal"> validateTwitter()</code> method shown in the recipe<span class="emphasis"><em> Create a custom validation rule</em></span> optimized for reutilization.<a id="id129" class="indexterm"/>
</p><p>The<code class="literal"> beforeFind</code> callback is triggered by CakePHP whenever a find operation is about to be executed, and we used it to check the existence of the custom<code class="literal"> tweets</code> find setting. We use this setting to allow the developer to either disable the fetch of tweets, by setting it to<code class="literal"> false</code>:
</p><div class="informalexample"><pre class="programlisting">$this-&gt;Profile-&gt;find('all', array('tweets' =&gt; false));
</pre></div><p>or specify how many tweets should be obtained. For example, if we wanted to obtain only the latest tweet, we would do:</p><div class="informalexample"><pre class="programlisting">$this-&gt;Profile-&gt;find('all', array('tweets' =&gt; 1));
</pre></div><p>The<code class="literal"> afterFind</code> callback is executed after a find operation is executed, and gives us an opportunity to modify the results. Therefore we check to make sure we are told to obtain the tweets, and if so we use the<code class="literal"> timeline()</code> method to obtain the specified number of tweets. We then append each tweet's basic information into the index<code class="literal"> Tweet</code> for each profile.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>There's more...</h2></div></div></div><p>One thing that is clear in our implementation is that, unless we set the<code class="literal"> tweets</code> find option to<code class="literal"> false</code>; we are obtaining tweets for each profile record on every<code class="literal"> find</code> operation performed against the<code class="literal"> Profile</code> model. Adding caching support would greatly improve the performance of our<code class="literal"> find</code> operations, since we would only obtain the tweets when the cached information is no longer valid.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"/>Note</h3><p>More information about caching through CakePHP's Cache class can be obtained at <a class="ulink" href="http://book.cakephp.org/view/1511/Cache">http://book.cakephp.org/view/1511/Cache</a>.</p></div><p>We will allow the developer to specify what cache configuration to use when caching tweets. Open the<code class="literal"> TwitterAccountBehavior</code> class and make the following modifications to its<code class="literal"> setup()</code> method:</p><div class="informalexample"><pre class="programlisting">public function setup($model, $config = array()) {
parent::setup($model, $config);
$this-&gt;settings[$model-&gt;alias] = array_merge(array(
'field' =&gt; 'twitter',
<span class="strong"><strong>'cache' =&gt; 'default'</strong></span>
), $config);
}
</pre></div><p>While editing the<code class="literal"> TwitterAccountBehavior</code> class, make the following modifications to its<code class="literal"> afterFind()</code> method:</p><div class="informalexample"><pre class="programlisting">public function afterFind($model, $results, $primary) {
$rows = parent::afterFind($model, $results, $primary);
if (!is_null($rows)) {
$results = $rows;
}
if (!empty($this-&gt;settings[$model-&gt;alias]['tweets'])) {
$field = $this-&gt;settings[$model-&gt;alias]['field'];
$count = is_int($this-&gt;settings[$model-&gt;alias]['tweets']) ?
$this-&gt;settings[$model-&gt;alias]['tweets'] :
10;
<span class="strong"><strong>$cacheConfig = $this-&gt;settings[$model-&gt;alias]['cache'];</strong></span>
foreach($results as $i =&gt; $result) {
$twitter = $result[$model-&gt;alias][$field];
$tweets = array();
<span class="strong"><strong>if (!empty($cacheConfig)) {
$tweets = Cache::read('tweets_' . $twitter, $cacheConfig);
}
if (empty($tweets) &amp;&amp; !empty($result[$model-&gt;alias][$field])) {</strong></span>
$result = $this-&gt;timeline($twitter, $count);
if (!empty($result) &amp;&amp; is_array($result)) {
foreach($result as $tweet) {
$tweets[] = array(
'created' =&gt; date('Y-m-d H:i:s', strtotime($tweet-&gt;created_at)),
'source' =&gt; $tweet-&gt;source,
'user' =&gt; $tweet-&gt;user-&gt;screen_name,
'text' =&gt; $tweet-&gt;text
);
}
}
<span class="strong"><strong>Cache::write('tweets_' . $twitter, $tweets, $cacheConfig);</strong></span>
}
$results[$i]['Tweet'] = $tweets;
}
}
return $results;
}
</pre></div><p>Finally, add the following<code class="literal"> beforeDelete</code> and<code class="literal"> afterDelete</code> callback implementations:</p><div class="informalexample"><pre class="programlisting">public function beforeDelete($model, $cascade = true) {
$field = $this-&gt;settings[$model-&gt;alias]['field'];
$this-&gt;settings[$model-&gt;alias]['delete'] = $model-&gt;field($field, array(
$model-&gt;primaryKey =&gt; $model-&gt;id
));
return parent::beforeDelete($cascade);
}
public function afterDelete($model) {
if (!empty($this-&gt;settings[$model-&gt;alias]['delete'])) {
$cacheConfig = $this-&gt;settings[$model-&gt;alias]['cache'];
$twitter = $this-&gt;settings[$model-&gt;alias]['delete'];
Cache::delete('tweets_' . $twitter, $cacheConfig);
}
return parent::afterDelete($model);
}
</pre></div><p>Using<code class="literal"> beforeDelete()</code> we are storing the tweet that is to be deleted. If indeed the profile was deleted, the<code class="literal"> afterDelete()</code> method will remove its cached tweets.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Adding multiple validation rules</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Create a custom validation rule</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using behaviors to add new fields for saving</em></span></li></ul></div></div></div>
<div class="section" title="Using behaviors to add new fields for saving"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Using behaviors to add new fields for saving</h1></div></div></div><p>In the recipe<span class="emphasis"><em> Using callbacks in behaviors</em></span> we learnt how to implement different model callbacks to perform some tasks automatically. In this recipe we will continue that process and we will learn how to automatically save data that may not be provided in a<code class="literal"> save</code> operation.<a id="id130" class="indexterm"/>
</p><p>We will use the Twitter example we have been using in this chapter, so that when a profile is saved, its Twitter URL and its last tweet are saved when creating a new record, or when updating an existing one.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Getting ready</h2></div></div></div><p>We need a working<code class="literal"> TwitterAccountBehavior</code> together with its controllers, models, and views. Follow the recipe<span class="emphasis"><em> Using callbacks in behaviors</em></span> (there's no need to enable caching in the behavior, so you can omit the<span class="emphasis"><em> There's more</em></span> section).</p><p>Add two fields to the profiles table,<code class="literal"> url</code> and<code class="literal"> last_tweet</code>, by issuing the following SQL command:</p><div class="informalexample"><pre class="programlisting">ALTER TABLE `profiles`
ADD COLUMN `url` VARCHAR(255) default NULL,
ADD COLUMN `last_tweet` VARCHAR(140) default NULL;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit your<code class="literal"> app/models/behaviors/twitter_account.php</code> file and add the following<code class="literal"> beforeSave</code> implementation to the<code class="literal"> TwitterAccountBehavior</code> class:<div class="informalexample"><pre class="programlisting">public function beforeSave($model) {
$field = $this-&gt;settings[$model-&gt;alias]['field'];
$twitter = null;
if (!array_key_exists($field, $model-&gt;data[$model-&gt;alias]) &amp;&amp; $model-&gt;exists()) {
$twitter = $model-&gt;field($field, array(
$model-&gt;primaryKey =&gt; $model-&gt;id
));
} elseif (array_key_exists($field, $model-&gt;data[$model-&gt;alias])) {
$twitter = $model-&gt;data[$model-&gt;alias][$field];
}
$data = array(
'url' =&gt; !empty($twitter) ? 'http://twitter.com/' . $twitter : null,
'last_tweet' =&gt; null
);
if (!empty($twitter)) {
$tweets = $this-&gt;timeline($twitter, 1);
if (!empty($tweets) &amp;&amp; is_array($tweets)) {
$data['last_tweet'] = $tweets[0]-&gt;text;
}
}
$model-&gt;data[$model-&gt;alias] = array_merge(
$model-&gt;data[$model-&gt;alias],
$data
);
$this-&gt;_addToWhitelist($model, array_keys($data));
return parent::beforeSave($model);
}
</pre></div></li><li class="listitem">Whenever we create a new profile with a valid Twitter account, both the<code class="literal"> url</code> and<code class="literal"> last_tweet</code> fields will be automatically populated. If we are instead modifying a profile, the<code class="literal"> last_tweet</code> field will be updated to reflect the latest tweet from the relevant account.<a id="id131" class="indexterm"/></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec18"/>How it works...</h2></div></div></div><p>The<code class="literal"> beforeSave</code> callback is triggered before a save operation is performed on a model, giving us the chance to add new fields to the set of fields that are about to be saved, or modify other field values.</p><p>We started by determining which Twitter account is linked to the profile being saved. If no Twitter account is specified in the data that is about to be saved, and if we are modifying an existing record (we use<code class="literal"> $model-&gt;exists()</code> for this check), we obtain the account specified in its<code class="literal"> twitter</code> field. If instead there's an account specified in the data to be saved, we use that instead.</p><p>Regardless of the type of save operation that is about to be performed (creating or updating a record), we set the<code class="literal"> last_tweet</code> field to the last tweet published by the specific Twitter account. However, we set the<code class="literal"> url</code> field to the appropriate URL-based, on the Twitter account only when we are creating a new record.</p><p>Once we have set the data to be saved in the<code class="literal"> $data</code> array, we append that data to the<code class="literal"> $model-&gt;data</code> property that contains all the information that will be saved. We then use the behavior's<code class="literal"> _addToWhitelist()</code> method, defined in CakePHP's<code class="literal"> ModelBehavior</code> class from which our behavior extends, so that if the developer has chosen to limit the save operation to only a specific set of fields, then our fields are guaranteed to be saved regardless of this restriction.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using callbacks in behaviors</em></span></li></ul></div></div></div>
<div class="section" title="Using the Sluggable behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Using the Sluggable behavior</h1></div></div></div><p>One of the main concerns most applications have is optimizing their content for search engines, so that their sites rank as high as possible on most engines. Among several recommendations found in most SEO (Search Engine Optimization) guides, building URLs that include relevant keywords is one of the most effective ones.<a id="id132" class="indexterm"/>
</p><p>If we are building a content-based site, this is achievable by making sure that permanent links to each item include most of the words that are part of the item title. As an example, if we have a post whose title is<span class="emphasis"><em> Top 10 CakePHP Behaviors</em></span>, an SEO-friendly URL could be:</p><p><code class="literal">http://localhost/articles/view/top-10-cakephp-behaviors</code>.</p><p>The <code class="literal">top-10-cakephp-behaviors</code> part is commonly known as a<span class="emphasis"><em> slug</em></span>, a part of the URL that uses relevant keywords. In this recipe, we will learn how to use the publicly available<code class="literal"> Sluggable</code> behavior to automatically add slugs to our application.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"/>Note</h3><p>The<code class="literal"> Sluggable</code> behavior is one of the many classes I released as open source to help fellow CakePHP developers. Feel free to send me any feedback.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Getting ready</h2></div></div></div><p>To go through this recipe, we need a sample table to work with. Create a table named<code class="literal"> posts</code>, using the following SQL statement:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `posts`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`slug` VARCHAR(255) NOT NULL,
`title` VARCHAR(255) NOT NULL,
`text` TEXT NOT NULL,
PRIMARY KEY(`id`),
UNIQUE KEY `slug`(`slug`)
);
</pre></div><p>We proceed now to create the required model. Create the model<code class="literal"> Post</code> in a file named<code class="literal"> post.php</code> and place it in your<code class="literal"> app/models</code> folder, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
public $validate = array(
'title' =&gt; array('rule' =&gt; 'notEmpty'),
'text' =&gt; array('rule' =&gt; 'notEmpty')
);
}
?&gt;
</pre></div><p>Create its appropriate controller<code class="literal"> PostsController</code> in a file named<code class="literal"> posts_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder, with the following contents:<a id="id133" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class PostsController extends AppController {
public function add() {
if (!empty($this-&gt;data)) {
$this-&gt;Post-&gt;create();
if ($this-&gt;Post-&gt;save($this-&gt;data)) {
$this-&gt;Session-&gt;setFlash('Post created');
$this-&gt;redirect('/');
} else {
$this-&gt;Session-&gt;setFlash('Please correct the errors');
}
}
}
}
?&gt;
</pre></div><p>Create a folder named<code class="literal"> posts</code> in your<code class="literal"> app/views</code> folder, then create the view to hold the form in a file named<code class="literal"> add.ctp</code> and place it in your<code class="literal"> app/views/posts</code> folder, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo $this-&gt;Form-&gt;create();
echo $this-&gt;Form-&gt;inputs(array(
'title',
'text'
));
echo $this-&gt;Form-&gt;end('Create');
?&gt;
</pre></div><p>Finally, we need to download the Syrup plugin for CakePHP. Go to <a class="ulink" href="http://github.com/mariano/syrup/downloads">http://github.com/mariano/syrup/downloads</a> and download the latest release. Uncompress the downloaded file into your<code class="literal"> app/plugins</code> folder. You should now have a directory named<code class="literal"> syrup</code> inside<code class="literal"> app/plugins</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by attaching the<code class="literal"> Sluggable</code> behavior to the<code class="literal"> Post</code> model. Edit your<code class="literal"> app/models/post.php</code> file and add the<code class="literal"> $actsAs</code> property:<a id="id134" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
<span class="strong"><strong>public $actsAs = array('Syrup.Sluggable');</strong></span>
public $validate = array(
'title' =&gt; array('rule' =&gt; 'notEmpty'),
'text' =&gt; array('rule' =&gt; 'notEmpty')
);
}
?&gt;
</pre></div></li><li class="listitem">Let's create an action to list posts. Add the following method to the<code class="literal"> PostsController</code> class:<div class="informalexample"><pre class="programlisting">public function index() {
$this-&gt;paginate['limit'] = 10;
$posts = $this-&gt;paginate();
$this-&gt;set(compact('posts'));
}
</pre></div></li><li class="listitem">Create the view<code class="literal"> views/posts/index.ctp</code> with the following contents:<div class="informalexample"><pre class="programlisting">&lt;div class="paging"&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;?php foreach($posts as $post) { ?&gt;
&lt;li&gt;&lt;?php echo $this-&gt;Html-&gt;link($post['Post']['title'], array('action'=&gt;'view', $post['Post']['slug'])); ?&gt;&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
</pre></div><p>Next, create the action to view a post by slug. Add the following method to the PostsController class:
</p><div class="informalexample"><pre class="programlisting">public function view($slug) {
$post = $this-&gt;Post-&gt;find('first', array(
'conditions' =&gt; array('Post.slug' =&gt; $slug),
'recursive' =&gt; -1
));
$this-&gt;set(compact('post'));
}
</pre></div><p>Create the view<code class="literal"> views/posts/view.ctp</code> with the following contents:<a id="id135" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;&lt;?php echo $post['Post']['title']; ?&gt;&lt;/h1&gt;
&lt;p&gt;&lt;?php echo $post['Post']['text']; ?&gt;&lt;/p&gt;
&lt;?php echo $this-&gt;Html-&gt;link('Posts', array('action'=&gt;'index')); ?&gt;
</pre></div><p>After creating some posts using the form at <code class="literal">http://localhost/posts</code>, the list of posts could look like the following screenshot:
</p><div class="mediaobject"><img src="graphics/1926_04_04.jpg" alt="How to do it..."/></div></li><li class="listitem">If you hover over the links, you should see SEO-friendly links. For example, for the post entitled<span class="emphasis"><em> Automatic tasks with CakePHP</em></span>, its URL would be:<div class="informalexample"><pre class="programlisting">http://localhost/posts/view/automatic-tasks-with-cakephp
</pre></div></li><li class="listitem">Clicking on this URL would show the details for the post.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>How it works...</h2></div></div></div><p>The<code class="literal"> Sluggable</code> behavior implements the<code class="literal"> beforeSave</code> callback to automatically add the generated slug on the specified field. It ensures that all generated slugs are unique, and provides a full set of options to modify how a slug is generated. The following options can be specified when attaching the behavior to a model:<a id="id136" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ignore</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List of words that should not be part of a slug. Optional, and defaults to:<code class="literal"> and, for, is, of</code>, and<code class="literal"> the</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">label</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field name (string), or list of field names (in an array) that are used to create the slug. Defaults to a single field named<code class="literal"> title</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">length</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maximum length of the generated slug. Defaults to<code class="literal"> 100</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">overwrite</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If set to<code class="literal"> true</code>, the slug is generated even when modifying a record that already has a slug. Defaults to<code class="literal"> false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">real</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If set to<code class="literal"> true</code>, it will ensure that the field names defined in the<code class="literal"> label</code> option exists in the table. Defaults to<code class="literal"> true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">separator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Character to use when separating words in the slug. Defaults to<code class="literal"> -</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">slug</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Name of the field where the slug is stored. Defaults to<code class="literal"> slug</code>.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Geocoding addresses with the Geocodable behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Geocoding addresses with the Geocodable behavior</h1></div></div></div><p>Since the introduction of Google Maps and other location services, a broad set of possibilities are open to web applications, allowing geographical information to be used for building services.<a id="id137" class="indexterm"/>
</p><p>This recipe shows how to use the Geocode plugin to add location information to our own<code class="literal"> Address</code> model, allowing us to search address records by proximity.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"/>Note</h3><p>The<code class="literal"> Geocode</code> plugin is another open source project I released. More information about it can be obtained at <a class="ulink" href="http://github.com/mariano/geocode">http://github.com/mariano/geocode</a>.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a sample table to work with. Create a table named<code class="literal"> addresses</code>, using the following SQL statement:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `addresses`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`address_1` VARCHAR(255) NOT NULL,
`city` VARCHAR(255) default NULL,
`state` VARCHAR(255) NOT NULL,
`zip` VARCHAR(10) default NULL,
`latitude` FLOAT(10,7) NOT NULL,
`longitude` FLOAT(10,7) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div><p>We proceed now to create the required model. Create the model<code class="literal"> Address</code> in a file named<code class="literal"> address.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents (we are only specifying a few states for readability):<a id="id138" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Address extends AppModel {
public $validate = array(
'address_1' =&gt; array('rule' =&gt; 'notEmpty'),
'state' =&gt; array('rule' =&gt; 'notEmpty')
);
public static $states = array(
'CA' =&gt; 'California',
'FL' =&gt; 'Florida',
'NY' =&gt; 'New York'
);
}
?&gt;
</pre></div><p>Create its appropriate controller<code class="literal"> AddressesController</code> in a file named<code class="literal"> addresses_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder. With the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class AddressesController extends AppController {
public function add() {
if (!empty($this-&gt;data)) {
$this-&gt;Address-&gt;create();
if ($this-&gt;Address-&gt;save($this-&gt;data)) {
$this-&gt;Session-&gt;setFlash('Address created');
$this-&gt;redirect('/');
} else {
$this-&gt;Session-&gt;setFlash('Please correct the errors');
}
}
$states = $this-&gt;Address-&gt;states;
$this-&gt;set(compact('states'));
}
}
?&gt;
</pre></div><p>Create a folder named<code class="literal"> addresses</code> in your<code class="literal"> app/views</code> folder, then create the view to hold the form in a file named<code class="literal"> add.ctp</code> and place it in your<code class="literal"> app/views/addresses</code> folder, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo $this-&gt;Form-&gt;create();
echo $this-&gt;Form-&gt;inputs(array(
'address_1' =&gt; array('label' =&gt; 'Address'),
'city',
'state' =&gt; array('options'=&gt;$states),
'zip'
));
echo $this-&gt;Form-&gt;end('Create');
?&gt;
</pre></div><p>We need to download the Geocode plugin for CakePHP. Go to <a class="ulink" href="http://github.com/mariano/geocode/downloads">http://github.com/mariano/geocode/downloads</a> and download the latest release. Uncompress the downloaded file into your<code class="literal"> app/plugins</code> folder. You should now have a directory named<code class="literal"> geocode</code> inside<code class="literal"> app/plugins</code>.<a id="id139" class="indexterm"/>
</p><p>Finally, we need to sign up for a Google Maps API key. To do so, go to <a class="ulink" href="http://code.google.com/apis/maps/signup.html">http://code.google.com/apis/maps/signup.html</a> and follow the instructions given.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"/>Note</h3><p>The Geocode plugin also supports Yahoo maps. If you wish to use Yahoo Maps instead, follow the instructions shown on the plugin homepage.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit your<code class="literal"> app/config/bootstrap.php</code> file and place the following statement right before the closing PHP statement, replacing the string<code class="literal"> APIKEY</code> with your own Google Maps API key:<div class="informalexample"><pre class="programlisting">Configure::write('Geocode.key', 'APIKEY');
</pre></div></li><li class="listitem">We will now make our<code class="literal"> Address</code> model extend the skeleton model provided by the plugin. Edit your<code class="literal"> app/models/address.php</code> file and make the following changes:<div class="informalexample"><pre class="programlisting">&lt;?php
<span class="strong"><strong>App::import('Model', 'Geocode.GeoAddress');
class Address extends GeoAddress {</strong></span>
public $validate = array(
'address_1' =&gt; array('rule' =&gt; 'notEmpty'),
'state' =&gt; array('rule' =&gt; 'notEmpty')
);
public static $states = array(
'CA' =&gt; 'California',
'FL' =&gt; 'Florida',
'NY' =&gt; 'New York'
);
}
?&gt;
</pre></div></li><li class="listitem">By extending<code class="literal"> GeoAddress</code>, the<code class="literal"> Geocodable</code> behavior is automatically attached to our model. We can now use the form at <code class="literal">http://localhost/addresses/add</code> to add new addresses. After adding quite a few, we are ready to implement a paginated listing with support to finding addresses that are near a certain location.<a id="id140" class="indexterm"/></li><li class="listitem">To simplify this operation, we will force the point of origin in our controller action, instead of letting the user specify the address. With this in mind, add the following action to the<code class="literal"> AddressesController</code> class:<div class="informalexample"><pre class="programlisting">public function index() {
$address = '1211 La Brad Lane, Tampa, FL';
$this-&gt;paginate = array(
'near',
'address' =&gt; $address
);
$addresses = $this-&gt;paginate();
$this-&gt;set(compact('address', 'addresses'));
}
</pre></div></li><li class="listitem">Now create the view<code class="literal"> app/views/addresses/index.ctp</code>, with the following contents:<div class="informalexample"><pre class="programlisting">&lt;h1&gt;Addresses near &lt;strong&gt;&lt;?php echo $address; ?&gt;&lt;/strong&gt;&lt;/h1&gt;
&lt;div class="paging"&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;?php foreach($addresses as $currentAddress) { ?&gt;
&lt;li&gt;
&lt;?php echo $currentAddress['Address']['address_1']; ?&gt;
at
&lt;strong&gt;&lt;?php echo number_format($currentAddress['Address']['distance'], 2) . ' km.'; ?&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
</pre></div></li></ol></div><p>If you inserted sample addresses that are near the specified address, the output could be similar to that shown in the following screenshot:<a id="id141" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926_04_05.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>How it works...</h2></div></div></div><p>We started by downloading the plugin and configuring it by setting our own Google Maps API key in the<code class="literal"> bootstrap.php</code> configuration file. We then made our<code class="literal"> Address</code> model inherit from the<code class="literal"> GeoAddress</code> model provided by the plugin, which makes our model use the<code class="literal"> Geocodable</code> behavior, and implements the<code class="literal"> near</code> custom find type.<a id="id142" class="indexterm"/>
</p><p>Since our<code class="literal"> Address</code> model is now attached to the<code class="literal"> Geocodable</code> behavior, every time we create new address records the plugin will use the Google Maps API to save the appropriate location in the<code class="literal"> latitude</code> and<code class="literal"> longitude</code> fields.</p><p>Using the<code class="literal"> near</code> custom find type, we can easily find addresses that are near a certain address, and we can also see what distance separates each of those addresses from the point of origin.<a id="id143" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>There's more...</h2></div></div></div><p>The Geocode plugin is quite flexible, and even includes a helper to show addresses in a visual map. To find out all it has to offer, go to its website at <a class="ulink" href="http://github.com/mariano/geocode">http://github.com/mariano/geocode</a>.</p></div></div></body></html>