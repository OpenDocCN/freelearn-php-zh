["```php\n// _test_source_code.php \n1\\. <?php \n2\\. $a = 5; \n3\\. if ($a = 1) { \n4\\.     var_dump($a); \n5\\. } elseif ($b = 2) {} \n6\\. while ($c = 3) {} \n7\\. for (; $d = 4;) {} \n\n```", "```php\n$ composer require nikic/php-parser\n\n```", "```php\n// php_parser_01.php  \nuse PhpParser\\ParserFactory; \n\n$syntax = ParserFactory::PREFER_PHP7; \n$parser = (new ParserFactory())->create($syntax); \n\n$code = file_get_contents('_test_source_code.php'); \n$stmts = $parser->parse($code); \nprint_r($stmts); \n\n```", "```php\n$ php php_parser_01.php \n...\n[2] => PhpParser\\Node\\Stmt\\If_ Object\n (\n [cond] => PhpParser\\Node\\Expr\\Assign Object (\n [var] => PhpParser\\Node\\Expr\\Variable Object (\n [name] => a\n [attributes:protected] => Array (\n [startLine] => 4\n [endLine] => 4\n )\n )\n [expr] => PhpParser\\Node\\Scalar\\LNumber Object (\n [value] => 1\n ...\n\n```", "```php\n// php_parser_02.php  \nuse PhpParser\\NodeTraverser; \nuse PhpParser\\ParserFactory; \nuse PhpParser\\Node; \nuse PhpParser\\Node\\Stmt; \nuse PhpParser\\Node\\Expr; \nuse PhpParser\\NodeVisitorAbstract; \n\nclass MyNodeVisitor extends NodeVisitorAbstract { \n  public function enterNode(Node $node) { \n    if (($node instanceof Stmt\\If_ || \n          $node instanceof Stmt\\ElseIf_ || \n          $node instanceof Stmt\\While_ \n        ) && $this->isAssign($node->cond)) { \n\n      echo $node->getLine() . \"\\n\"; \n    } elseif ($node instanceof Stmt\\For_) { \n      $conds = array_filter($node->cond, [$this, 'isAssign']); \n      foreach ($conds as $cond) { \n        echo $node->getLine() . \"\\n\"; \n      } \n    } \n  } \n\n  private function isAssign($cond) { \n    return $cond instanceof Expr\\Assign; \n  } \n} \n\n$syntax = ParserFactory::PREFER_PHP7; \n$parser = (new ParserFactory())->create($syntax); \n$code = file_get_contents('_test_source_code.php'); \n\n$traverser = new NodeTraverser(); \n$traverser->addVisitor(new MyNodeVisitor()); \n$stmts = $parser->parse($code); \n$traverser->traverse($stmts); \n\n```", "```php\n$ php php_parser_02.php \n3\n5\n6\n7\n\n```", "```php\n// php_parser_observer_01.php \nObservable::fromArray(['_test_source_code.php']) \n  ->lift(function() { \n    $classes = [AssignmentInConditionNodeVisitor::class]; \n    return new PHPParserOperator($classes); \n  }) \n  ->subscribe(new DebugSubject());   \n\n```", "```php\n// ObservableNodeVisitorInterface.php \ninterface ObservableNodeVisitorInterface { \n    public function asObservable(); \n} \n\n```", "```php\n// AssignmentInConditionNodeVisitor.php \nuse PhpParser\\NodeVisitorAbstract as Visitor; \nuse PhpParser\\Node; \n// We're omitting the rest of use statements ... \n\nclass AssignmentInConditionNodeVisitor \n    extends Visitor implements ObservableNodeVisitorInterface { \n  private $subject; \n  private $prettyPrinter; \n\n  public function __construct() { \n    $this->subject = new Subject(); \n    $this->prettyPrinter = new PrettyPrinter\\Standard(); \n  } \n  public function enterNode(Node $node) { \n    // Remains the same as above just instead of echoing the \n    // line numbers we call $this->emitNext(...) method. \n  } \n  public function afterTraverse(array $nodes) { \n    $this->subject->onCompleted(); \n  } \n  public function asObservable() { \n    return $this->subject->asObservable(); \n  } \n  private function isAssign($cond) { \n    return $cond instanceof Expr\\Assign; \n  } \n  private function emitNext(Node $node, Expr\\Assign $cond) { \n    $this->subject->onNext([ \n      'line' => $node->getLine(), \n      'expr' => $this->prettyPrinter->prettyPrintExpr($cond), \n    ]); \n  } \n} \n\n```", "```php\n// PHPParserOperator.php \nuse Rx\\ObservableInterface; \nuse Rx\\ObserverInterface; \nuse Rx\\SchedulerInterface; \nuse Rx\\Operator\\OperatorInterface; \nuse Rx\\Observer\\CallbackObserver; \nuse PhpParser\\NodeTraverser; \nuse PhpParser\\ParserFactory; \n\nclass PHPParserOperator implements OperatorInterface { \n  private $parser; \n  private $traverserClasses; \n\n  public function __construct($traverserClasses = []) { \n    $syntax = ParserFactory::PREFER_PHP7; \n    $this->parser = (new ParserFactory())->create($syntax); \n    $this->traverserClasses = $traverserClasses; \n  } \n\n  private function createTraverser() { \n    $traverser = new NodeTraverser(); \n    $visitors = array_map(function($class) use ($traverser) { \n      /** @var ObservableNodeVisitorInterface $visitor */ \n      $visitor = new $class(); \n      $traverser->addVisitor($visitor); \n\n      return $visitor->asObservable() \n        ->toArray() \n        ->map(function($violations) use ($class) { \n          return [ \n            'violations' => $violations, \n            'class' => $class \n          ]; \n        }); \n      }, $this->traverserClasses); \n    return [$traverser, $visitors]; \n  } \n  // ... \n} \n\n```", "```php\nclass PHPParserOperator implements OperatorInterface { \n  // ... \n  public function __invoke($observable, $observer, $sched=null) { \n    $onNext = function($filepath) use ($observer) { \n      $code = @file_get_contents($filepath); \n      if (!$code) { /* ... emit error message */ } \n\n      list($traverser, $visitors) = $this->createTraverser(); \n      (new ForkJoinObservable($visitors)) \n        ->map(function($results) use ($filepath) { \n          // $results = all results from all node visitors. \n          $filtered = array_filter($results, function($result) { \n            return $result['violations']; \n          }); \n          return [ \n            'file' => $filepath, \n            'results' => $filtered, \n          ]; \n        }) \n        ->subscribeCallback(function($result) use ($observer) { \n          $observer->onNext($result); \n        }); \n\n      $stmts = $this->parser->parse($code); \n      $traverser->traverse($stmts); \n    }; \n\n    $callbackObserver = new CallbackObserver( \n      $onNext, \n      [$observer, 'onError'], \n      [$observer, 'onCompleted'] \n    ); \n    return $observable->subscribe($callbackObserver, $sched); \n  } \n} \n\n```", "```php\n$ php php_parser_observer_01.php \nArray (\n [file] => _test_source_code.php\n [results] => Array (\n [0] => Array (\n [violations] => Array (\n [0] => Array (\n [line] => 3\n [expr] => $a = 1\n )\n [1] => Array (\n [line] => 5\n [expr] => $b = 2\n )\n [2] => Array (\n [line] => 6\n [expr] => $c = 3\n )\n [3] => Array (\n [line] => 7\n [expr] => $d = 4\n )\n )\n [class] => AssignmentInConditionNodeVisitor\n )\n )\n)\n\n```", "```php\n// ThreadPoolOperator.php \nclass ThreadPoolOperator implements OperatorInterface { \n  private $pool; \n\n  public function __construct($num = 4, \n      $workerClass = Worker::class, $workerArgs = []) { \n\n    $this->pool = new Pool($num, $workerClass, $workerArgs); \n  } \n\n  public function __invoke($observable, $observer, $sched=null) { \n    $callbackObserver = new CallbackObserver(function($task) { \n        /** @var AbstractRxThread $task */ \n        $this->pool->submit($task); \n      }, \n      [$observer, 'onError'], \n      [$observer, 'onCompleted'] \n    ); \n\n    $dis1 = $sched->schedulePeriodic(function() use ($observer) { \n      $this->pool->collect(function($task) use ($observer) { \n        /** @var AbstractRxThread $task */ \n        if ($task->isDone()) { \n          $observer->onNext($result); \n          return true; \n        } else { \n          return false; \n        } \n      }); \n    }, 0, 10); \n\n    $dis2 = $observable->subscribe($callbackObserver); \n    $disposable = new BinaryDisposable($dis1, $dis2); \n    return $disposable; \n  } \n} \n\n```", "```php\n$remaining = N; \nwhile ($remaining !== 0) { \n    $pool->collect(function(Thread $work) use (&$remaining) { \n        $done = $work->isDone(); \n        if ($done) { \n            $remaining--; \n        } \n        return $done; \n    }); \n}  \n\n```", "```php\nObservable::fromArray([1,2,3]) \n    ->map(function($val) { \n        return new MyThread($val); \n    }) \n    ->lift(function() { \n        return ThreadPoolOperator(...); \n    }) \n... \n\n```", "```php\n// AbstractRxThread.php \nabstract class AbstractRxThread extends Thread { \n    private $done = false; \n    protected $result; \n\n    public function getResult() { \n        return $this->result; \n    } \n    public function isDone() { \n        return $this->done; \n    } \n    protected function markDone() { \n        $this->done = true; \n    } \n} \n\n```", "```php\nclass PHPParserThread extends AbstractRxThread { \n  private $filenames; \n\n  public function __construct($filename) { \n    $this->filenames =  \n        (array)(is_array($filename) ? $filename : [$filename]); \n    /** @var Volatile result */ \n    $this->result = []; \n  } \n\n  public function run() { \n    $last = 0; \n    Observable::fromArray($this->filenames) \n      ->lift(function() { \n        $classes = ['AssignmentInConditionNodeVisitor']; \n        return new PHPParserOperator($classes); \n      }) \n      ->subscribeCallback(function ($results) use (&$last) { \n        $this->result[$last++] = (array)[ \n          'file' => $results['file'], \n          'results' => $results['results'], \n        ]; \n      }, null, function() { \n        $this->markDone(); \n      }); \n  } \n} \n\n```", "```php\npublic function setResult($result) { \n    $this->result = $result; \n} \n\n```", "```php\nrequire_once __DIR__ . '/../Chapter 02/DebugSubject.php'; \n\n```", "```php\n// PHPParserWorker.php \nclass PHPParserWorker extends \\Worker { \n  protected $loader; \n\n  public function __construct($loader) { \n    $this->loader = $loader; \n  } \n\n  public function run() { \n    $classLoader = require_once($this->loader); \n    $dir = __DIR__; \n    $classLoader->addClassMap([ \n      'DebugSubject' => $dir . '/../Chapter 02/DebugSubject.php', \n      'ThreadWorkerOperator' => $dir.'/ThreadWorkerOperator.php', \n      'PHPParserThread' => $dir . '/PHPParserThread.php', \n      'PHPParserWorker' => $dir . '/PHPParserWorker.php', \n      'PHPParserOperator' => $dir . '/PHPParserOperator.php', \n    ]); \n  } \n\n  public function start(int $options = PTHREADS_INHERIT_ALL) { \n    return parent::start(PTHREADS_INHERIT_NONE); \n  } \n} \n\n```", "```php\n// threads_php_parser_01.php \n$loop = new StreamSelectLoop(); \n$scheduler = new EventLoopScheduler($loop); \n\nObservable::create(function(ObserverInterface $observer) { \n    $observer->onNext('_test_source_code.php'); \n  }) \n  ->map(function($filename) { \n    return new PHPParserThread($filename); \n  }) \n  ->lift(function() { \n    $args = [__DIR__ . '/../vendor/autoload.php']; \n    return new ThreadPoolOperator(2,PHPParserWorker::class,$args); \n  }) \n  ->flatMap(function($result) { \n    return Observable::fromArray((array)$result); \n  }) \n  ->take(1) \n  ->subscribeCallback(function($result) { \n    print_r($result); \n  }, null, null, $scheduler); \n\n$loop->run(); \n\n```", "```php\n$ php threads_php_parser_01.php \nArray (\n [file] => _test_source_code.php\n [results] => Array (\n [0] => Array (\n [violations] => Array (\n ...\n\n```", "```php\n$ composer create-project symfony/framework-standard-edition testdir\n\n```", "```php\n// threads_php_parser_02.php \nconst MAX_FILES = 500; \nObservable::create(function($observer) use ($loop) { \n    $start = microtime(true); \n    $src = __DIR__ . '/../symfony_template'; \n    $dirIter = new \\RecursiveDirectoryIterator($src); \n    $iter = new \\RecursiveIteratorIterator($dirIter);  \n\n    while ($iter->valid()) { \n      /** @var SplFileInfo $file */ \n      $file = $iter->current(); \n      if ($file->getExtension() === 'php' && $file->isReadable()){ \n        $observer->onNext($file->getRealPath()); \n      } \n      $iter->next(); \n    }  \n\n    return new CallbackDisposable(function() use ($loop, $start) { \n      echo \"duration: \".round(microtime(true) - $start, 2).\"s\\n\"; \n      $loop->stop(); \n    }); \n  }) // End of Observable::create() \n  ->bufferWithCount(20) \n  ->map(function($filenames) { \n    return new PHPParserThread($filenames); \n  }) \n  ->lift(function() { \n    $args = [__DIR__ . '/../vendor/autoload.php']; \n    return new ThreadPoolOperator(4,PHPParserWorker::class,$args); \n  }) \n  ->flatMap(function($result) { \n    return Observable::fromArray((array)$result); \n  }) \n  ->take(MAX_FILES) \n  ->filter(function($result) { \n    return count($result['results']) > 0; \n  }) \n  ->subscribeCallback(function($result) { \n    print_r($result); \n  }, null, null, $scheduler); \n\n```", "```php\n$ php threads_php_parser_02.php\n...\nArray (\n [file] => ...vendor/symfony/src/Symfony/Bridge/Twig/AppVariable.php\n [results] => Array (\n [0] => Array (\n [violations] => Array (\n [0] => Array (\n [line] => 101\n [expr] => $request = $this->getRequest()\n )\n )\n [class] => AssignmentInConditionNodeVisitor\n )\n )\n)\n...\n\n```", "```php\nif ($request = $this->getRequest()) { \n\n```", "```php\n1 thread = 5.60s\n2 threads = 3.52s\n4 threads = 3.08s\n6 threads = 4.80s\n\n```", "```php\n// gearman_client_01.php \n$client = new GearmanClient(); \n$client->addServer('127.0.0.1'); \n$client->setTimeout(3000); \n\n$length = @$client->doNormal('strlen', 'Hello World!'); \nif (empty($length)) { \n    echo \"timeout\\n\"; \n} else { \n    var_dump(intval($length)); \n} \n\n```", "```php\n// gearman_worker_01.php \n$worker = new GearmanWorker(); \n$worker->addServer('127.0.0.1'); \n$worker->addFunction('strlen', function(GearmanJob $job) { \n    echo 'new job: ' . $job->workload() \n        . ' (' . $job->workloadSize() . \")\\n\"; \n    return strlen($job->workload()); \n}); \n\nwhile ($worker->work()) { } \n\n```", "```php\n$ gearmand --verbose DEBUG\n\n```", "```php\n$ php gearman_worker_01.php \nnew job: Hello World! (12)\n\n```", "```php\n$ php gearman_client_01.php \nint(12)\n\n```", "```php\n$ gearman -w -f strlen -- wc -c\n\n```", "```php\n// gearman_worker_02.php \n\n$worker = new GearmanWorker(); \n$worker->addServer('127.0.0.1'); \n\n$worker->addFunction('phpparser', function(GearmanJob $job) { \n    Observable::just($job->workload()) \n        ->lift(function() { \n            $classes = ['AssignmentInConditionNodeVisitor']; \n            return new PHPParserOperator($classes); \n        }) \n        ->subscribeCallback(function($results) use ($job) { \n            $job->sendComplete(json_encode($results)); \n        }); \n}); \nwhile ($worker->work()) { } \n\n```", "```php\n$ php gearman_worker_02.php\n\n```", "```php\n$ gearman -f phpparser -s \"_test_source_code.php\" | json_pp\n{\n \"results\" : [\n {\n \"violations\" : [\n {\n \"expr\" : \"$a = 1\",\n \"line\" : 3\n },\n ...\n ],\n \"class\" : \"AssignmentInConditionNodeVisitor\"\n }\n ],\n \"file\" : \"_test_source_code.php\"\n}\n\n```"]