- en: Extending Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter dives into extending Drupal using a custom module:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a custom page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the configuration on installation or update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Features 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A feature of Drupal that makes it desirable is the ability to customize it through
    modules. Whether custom or contributed, modules extend the functionalities and
    capabilities of Drupal. Modules can be used to not only extend Drupal, but also
    to create a way to provide configuration and reusable features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss how to create a module and allow Drupal to discover
    it, allowing it to be installed from the extend page. Permissions, custom pages,
    and default configurations all come from modules. We will explore how to provide
    these through a custom module.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating a module, we will discuss the Features module that provides
    a set of tools to generate a module and export its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to extend Drupal is to create a custom module. Although the task
    sounds daunting, it can be accomplished in a few simple steps. Modules can provide
    functionalities and customizations to functionalities provided by other modules,
    or they can be used as a way to contain the configuration and a site's state.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a module by defining an `info.yml` file, a file
    containing information that Drupal uses to discover extensions, and enabling the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a folder named `mymodule` in the `modules` folder in the base directory
    of your Drupal site. This will be your module's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `mymodule.info.yml` file in your module's directory. This contains
    metadata that identifies the module to Drupal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a line to the `name` key to provide a name for the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to provide the `type` key to define the type of extension. We
    provide the `module` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` key allows you to provide extra information about your module,
    which will be displayed on the module''s list page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All modules need to define the `core` key in order to specify a major release
    compatibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the `mymodule.info.yml` file, which resembles the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Log in to your Drupal site and go to Extend from the administrative toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for My Module to filter the list of options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the checkbox and click on Install to enable your module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73af832a-e99e-4bb8-8387-8d7e304599ad.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal utilizes `info.yml` files to define extensions. Drupal has a discovery
    system that locates these files and parses them to discover modules. The `info_parser`
    service, provided by the `\Drupal\Core\Extension\InfoParser` class, reads the
    `info.yml` file. The parser guarantees that the required type, core, and name
    keys are present.
  prefs: []
  type: TYPE_NORMAL
- en: When a module is installed, it is added to the `core.extension` configuration
    object, which contains a list of installed modules and themes. The collection
    of modules in the `core.extension` module array will be installed, and will have
    PHP namespaces resolved, services loaded, and hooks registered.
  prefs: []
  type: TYPE_NORMAL
- en: When Drupal prepares to execute a hook or register services, it will iterate
    through the values in the `module` key in `core.extension`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more details about Drupal modules and the module `info.yml` files
    that we can explore.
  prefs: []
  type: TYPE_NORMAL
- en: Module namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal 8 uses the PSR-4 standard developed by the **PHP Framework Interoperability
    Group** (**PHP-FIG**). The PSR-4 standard is for package-based PHP namespace autoloading.
    It defines a standard to understand how to automatically include classes based
    on a namespace and class name. Drupal modules have their own namespaces under
    the Drupal root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the module from the recipe, our PHP namespace will be `Drupal\mymodule`,
    which represents the `modules/mymodule/src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: With PSR-4, files need to contain only one class, interface, or trait. These
    files need to have the same filename as the containing class, interface, or trait
    name. This allows a class loader to resolve a namespace as a directory path and
    know the class's filename. The file can then be automatically loaded when it is
    used in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Module discovery locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal supports multiple module discovery locations. Modules can be placed
    in the following directories and discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/profiles/CURRENT PROFILE/modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sites/all/modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sites/default/modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sites/example.com/modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\Drupal\Core\Extension\ExtensionDiscovery` class handles the discovery
    of extensions by type. It will iteratively scan each location and discover modules
    that are available. The discovery order is important. If the same module is placed
    in `/modules`, but also in the `sites/default/modules` directory, the latter will
    take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a package group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules can define a `package` key to group modules on the module list page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4875d0a-cfa5-407d-bb88-dd04ab8e099f.png)'
  prefs: []
  type: TYPE_IMG
- en: Projects that include multiple submodules, such as Drupal Commerce, specify
    packages to normalize the modules' list form. Contributed modules for the Drupal
    Commerce project utilize a package name, `Commerce (contrib)`, to group them on
    the module list page.
  prefs: []
  type: TYPE_NORMAL
- en: Module dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules can define dependencies to ensure that those modules are enabled before
    your module can be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `info.yml` for the `Responsive Image` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `dependencies` key specifies that the `breakpoint` and `image` modules need
    to be enabled first before the `Responsive Image` module can be enabled. When
    enabling a module that requires dependencies that are disabled, the installation
    form will provide a prompt asking you whether you would like to install the dependencies
    as well. If a dependency module is missing, the module cannot be installed. The
    dependency will show a status of (missing).
  prefs: []
  type: TYPE_NORMAL
- en: 'A module that is a dependency of another module will state the information
    in its description, along with the other module''s status. For example, the Breakpoint
    module will show that the Re module requires it as a dependency and is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf6cea81-0985-484f-b6e3-19c4081dff92.png)'
  prefs: []
  type: TYPE_IMG
- en: Specifying the module's version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a `version` key that defines the current module's version. Projects
    on Drupal.org do not specify this directly, as the Drupal.org extension packager
    adds it when a release is created. However, this key can be important for private
    modules to track the release information.
  prefs: []
  type: TYPE_NORMAL
- en: Versions are expected to be single strings, such as `1.0-alpha1` and `2.0.1`.
    You can also pass `VERSION`, which will resolve to the current version of Drupal
    core.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal.org does not currently support semantic versioning for contributed projects.
    There is a, now postponed, policy discussion in the issue queue, which can be
    found at [https://www.drupal.org/node/1612910](https://www.drupal.org/node/1612910).
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the PSR-4: Autoloader specification at [http://www.php-fig.org/psr/psr-4/](http://www.php-fig.org/psr/psr-4/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the Drupal.org documentation for creating a module at [https://www.drupal.org/docs/8/creating-custom-modules](https://www.drupal.org/docs/8/creating-custom-modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a custom page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Drupal, there are routes that represent URL paths that Drupal interprets
    to return content. Modules can define routes and methods that return data to be
    rendered and then displayed to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will define a controller that provides an output and a route.
    The route provides a URL path that Drupal will associate with our controller to
    display the output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new module like the one in the first recipe. We will refer to the module
    as `mymodule` throughout the recipe. Use your module's name as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, we'll set up the controller. Create a `src` folder in your module's
    base directory and another folder named `Controller` inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `MyPageController.php` that will hold the route''s controller class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/edd1de71-62ec-4560-b27b-d0da427fb87b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The PSR-4 standard states that filenames match the class names they hold, so
    we will create a `MyPageController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates the `MyPageController` class, which extends the `\Drupal\Core\Controller\ControllerBase`
    class. This base class provides a handful of utilities for interacting with the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The `Drupal\mymodule\Controller` namespace allows Drupal to automatically load
    the file from `/modules/mymodule/src/Controller`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a method that returns a string of text in our class. Add
    the following method to our `MyPageController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `customPage` method returns a render array that the Drupal theming layer
    can parse. The `#markup` key denotes a value that does not have any additional
    rendering or theming processes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mymodule.routing.yml` file in the base directory of your module so
    that a route can be added to this controller and method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to define the route''s internal name for the route to be
    referenced by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the route a path (`mypage`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defaults` key allows us to provide the controller with a fully qualified
    class name, the method to use, and the page''s title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You need to provide the initial `\` when providing the fully qualified class
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Drupal uses PSR-4 autoloading. Drupal is able to determine that
    a class with the namespace of `\Drupal\mymodule\Controller` is in the `/path/to/drupal/modules/mymodule/src/Controller`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, define a `requirements` key to set the access callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Go to Configuration, and then Performance in the DEVEOLOPMENT section, and click
    on Clear all caches button to rebuild Drupal's routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `/mypage` on your Drupal site and view your custom page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45c6dbe2-0715-48ca-8506-9db1f1b5cf0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal uses routes, which define a path, that returns content. Each route has
    a method in a controller class that generates the content, in the form of a render
    array, to be delivered to the user. When a request comes to Drupal, the system
    tries to match the path to known routes. If the route is found, the route's definition
    is used to deliver the page. If the route cannot be found, the 404 page is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP kernel takes the request and loads the route. It will invoke the defined
    controller method or procedural function. The result of the invoked method or
    function is then handed to the presentation layer of Drupal to be rendered into
    the content that can be delivered to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal 8 builds on top of the Symfony HTTP kernel to provide the underlying
    functionality of its route system. It has added the ability to provide access
    requirements, cast placeholders into loaded objects, and provide partial page
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes have extra capabilities that can be configured; we will explore those
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes can accept dynamic arguments that can be passed to the route controller's
    method. Placeholder elements can be defined in the route using curly brackets
    in the URL that denote dynamic values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows what a route might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This route specifies the `/cat/{name}` path. The `{name}` placeholder will
    accept dynamic values and pass them to the controller''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts the `name` variable from the route and substitutes it into
    the render array to display it as a text.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal's routing system provides a method of upcasting a variable into a loaded
    object. In Drupal, upcasting is the process of taking a route parameter and converting
    it into a richer piece of data. This includes taking an entity ID and providing
    the loaded entity to the system. There are a set of parameter converter classes
    under the `\Drupal\Core\ParamConverter` namespace. The `EntityConverter` class
    will read options defined in the route and replace a placeholder value with a
    loaded entity object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an entity type called **cat**, we can turn the `name` placeholder
    into a method that will be provided with the loaded `cat` object in our controller''s
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is not required for entities as the defined entity route handler can automatically
    generate this. Entities are covered in [*Chapter 10*](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml),
    *The Entity API*.
  prefs: []
  type: TYPE_NORMAL
- en: Validating parameters in routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal provides regular expression validation against route parameters. If
    the parameter fails the regular expression validation, a 404 page will be returned.
    Using an example route, we can add the validation to ensure that only alphabetical
    characters are used in the route parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Under the `requirements` key, you can add a new value that matches the name
    of the placeholder. You can then set it to have the value of the regular expression
    you would like to use. This would prevent `c@ts` or `cat!` from being valid parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Route requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes can define different access requirements through the `requirements` key.
    Multiple validators can be added. However, there must be one that provides a true
    result, or else the route will return 403, access denied. This is true if the
    route defines no requirement validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Route requirement validators are defined by implementing `\Drupal\Core\Routing\Access\AccessInterface`.
    Here are some of the common requirement validators defined throughout Drupal core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_access: TRUE`: Always grants access to the route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_entity_access`: Validates that the current user has the ability to perform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type.operation`, such as `node.view`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_permission`: Checks whether the current user has the provided permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_user_is_logged_in`: Validates that the current user is logged in, which is
    defined with a Boolean value in the `routing.yml` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing dynamic routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The routing system allows modules to define routes programmatically. This can
    be accomplished by providing a `routing_callbacks` key that defines a class and
    method that will return an array of the `\Symfony\Component\Routing\Route` objects.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with entities, refer to [*Chapter 10*](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml),
    *The Entity API* to learn about overriding the default route handler to create
    dynamic routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the module''s `routing.yml`, you will define the routing callbacks key and
    related class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\Drupal\mymodule\Routing\CustomRoutes` class will then have a method named
    routes, which returns an array of Symfony route objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If a module provides a class that interacts with routes, the best practice is
    to place it in the routing portion of the module's namespace. This helps you identify
    its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The invoked method is expected to return an array of initiated route objects.
    The route class takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path`: This represents the route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Defaults`: This is an array of default values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Requirements`: This is an array of required validators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Options`: This is an array that can be passed and used optionally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering existing routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Drupal's route system is rebuilt because of a module being enabled or caches
    being rebuilt, an event is fired that allows modules to alter routes defined statically
    in YAML or dynamically. This involves implementing an event subscriber by extending
    `\Drupal\Core\Routing\RouteSubscribeBase`, which subscribes the `RoutingEvents::ALTER`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `src/Routing/RouteSubscriber.php` file in your module. It will hold
    the route subscriber class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code extends `RouteSubscribeBase` and implements the `alterRoutes()`
    method. We make an attempt to load the `mymodule.mypage` route, and, if it exists,
    we change its path to `my-page`. Since objects are always passed by reference,
    we do not need to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Drupal to recognize the subscriber, we will need to describe it in the
    module''s `services.yml` file. In the base directory of your module, create a
    `mymodule.services.yml` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This registers our route subscriber class as a service to the container so that
    Drupal can execute it when the event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: The *Creating an event subscriber* recipe later in this chapter will cover more
    about event dispatching and subscribing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the Symfony routing documentation at [http://symfony.com/doc/current/book/routing.html](http://symfony.com/doc/current/book/routing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [*Chapter 10*](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml), *The Entity
    API*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the access checking on routes community documentation at [https://www.drupal.org/node/2122195](https://www.drupal.org/node/2122195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Drupal, there are roles and permissions used to define robust access control
    lists for users. Modules use permissions to check whether the current user has
    access to perform an action, view specific items, or do other operations. Modules
    then define the permissions that are used so that Drupal is aware of them. Developers
    can then construct roles, which are made up of enabled permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will define a new permission to view custom pages defined
    in a module. The permission will be added to a custom route and will restrict
    access to the route path to users who have a role containing the permission.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new module like the one in the first recipe. We will refer to the module
    as `mymodule` throughout the recipe. Use your module's name in the following recipe
    as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also modifies a route defined in the module. We will refer to this
    route as `mymodule.mypage`. Modify the appropriate path in your module's `routing.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions are stored in a `permissions.yml` file. Add a `mymodule.permissions.yml`
    to the base directory of your module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will need to define the internal string used to identify this permission,
    such as `view mymodule pages`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each permission is a YAML array of data. We will need to provide a `title`
    key that will be displayed on the permissions page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Permissions have a `description` key to provide details of the permission on
    the permissions page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save your `permissions.yml` and edit the module's `routing.yml` to use the permission
    for controlling access to a route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the route''s `requirements` key to have a `_permission` key that is
    equal to the defined permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Go to Configuration and then to Performance in the DEVELOPMENT section and click
    on Clear all caches to rebuild Drupal's routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to People and then to Permissions to add your permission as the authenticated
    user and anonymous user roles for My module!:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a99e3644-f78c-4d2f-915a-3380c0cbacc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Log out of your Drupal site and view the `/mypage` page. You will see the content,
    and will not receive an access denied page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions and roles are provided by the `User` module. The `user.permissions`
    service discovers the `permissions.yml` provided by installed modules. By default,
    the service is defined through the `\Drupal\user\PermissionHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal does not save a list of all permissions that are available. The permissions
    for a system are loaded when the permissions page is loaded. Roles contain an
    array of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: When checking a user's access for a permission, Drupal checks all the user's
    roles to see whether they support that permission.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass an undefined permission to a user access check and not receive
    an error. The access check will simply fail unless the user is UID 1, which bypasses
    access checks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover more ways to work with permissions in your modules in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Restrict access flag for permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Permissions can be flagged as having a security risk if enabled; this is the
    `restrict access` flag. When this flag is set to `restrict access: TRUE`, it will
    add a warning to the permission description.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows module developers to provide more context to the amount of control
    a permission may give a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8951919-0813-4509-95f6-524ca634b1b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The permission definition from our recipe would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Defining permissions programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions can be defined by a module programmatically or statically in a `YAML`
    file. A module needs to provide a `permission_callbacks` key in its `permissions.yml`
    that contains either an array of classes and their methods or a procedural function
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the Filter module provides granular permissions based on the different
    text filters created in Drupal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `user_permissions` service to execute the permissions method
    of the
  prefs: []
  type: TYPE_NORMAL
- en: '`\Drupal\Filter\FilterPermissions` class. The method is expected to return
    an array that matches the same structure as that of the `permissions.yml` file.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of using generated permissions will be covered in *Implementing custom
    access control for an entity* recipe of [*Chapter 10*](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml),
    *The Entity API*.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a user has permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user account interface provides a method for checking whether a user entity
    has a permission. To check whether the current user has a permission, you will
    get the current user, and you need to invoke the `hasPermission` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `\Drupal::currentUser()` method returns the current active user object.
    This allows you to check whether the active user has the necessary permissions
    to perform certain types of actions.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the configuration on the installation or update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal provides a configuration management system, which is discussed in [*Chapter
    9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), *Configuration Management - Deploying
    in Drupal 8*, and modules can provide configuration on an installation or through
    an update system. Modules provide the configuration through `YAML` files when
    they are first installed. Once the module is enabled, the configuration is then
    placed in the configuration management system; however updates can be made to
    the configuration in code through the Drupal update system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will provide a configuration YAML that creates a new contact
    form and then manipulates it through a schema version change in the update system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new module like the one in the first recipe. We will refer to the module
    as `mymodule` throughout the recipe. Use your module's appropriate name where
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a `config` folder in your module's base directory. Drupal requires its
    configuration YAML to be in a subfolder of `config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder named `install` in the `config` folder. The configuration YAML
    in this folder will be imported on module installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `install` folder, create a `contact.form.contactus.yml` to store the
    YAML definition of the contact form, Contact Us:![](img/7ec6fd6a-85a9-4d4e-879a-6683f5a26cd9.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will define the configuration of a contact form based on the `contact.schema.yml`
    file provided by the Contact module. Add the following YAML content into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The configuration entry is based on a schema definition, which we will cover
    in [*Chapter 9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), *Configuration Management
    - Deploying in Drupal 8*. The `langcode`, `status`, and `dependencies` are the
    required configuration management keys.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` is the contact form's machine name and the label is the human display
    name. The `recipients` key is a YAML array of valid email addresses. The reply
    key is a string of text for the Auto-reply field. Finally, the `weight` defines
    the form's weight in the administrative list.
  prefs: []
  type: TYPE_NORMAL
- en: Go to Extend and enable your module to import the configuration item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Contact Us form will now be located on the Contact forms overview page,
    located under Structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd7ce3f0-23f9-44b5-a308-7234f5798d9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a `mymodule.install` file in the module's base directory. Drupal checks
    `.install` files for update hooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a function called `mymodule_update_8001()` that will be read
    by the update system and make our configuration changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the entity's class to load our configuration entity object.
    It loads `contactus`, which our module has provided, and sets the reply property
    to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `/update.php` in your browser to run the Drupal''s database update system.
    Click on Apply pending updates to run the update system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0a0ed6a-4e35-4f01-9579-b84f037769c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Review the Contact Us form settings and verify that the reply message has been
    set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal's `moduler_installer` service, provided through `\Drupal\Core\Extension\ModuleInstaller`,
    ensures that configuration items defined in the module's `config` folder are processed
    on installation. When a module is installed, the `config.installer` service, provided
    through `\Drupal\Core\Config\ConfigInstaller`, is called to process the module's
    default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the event, the `config.installer` service makes an attempt to import the
    configuration from the `install` folder that already exists, and an exception
    will be thrown. Modules cannot provide changes made to the existing configuration
    through static YAML definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Since modules cannot adjust configuration objects through static YAML definitions
    provided to Drupal, they can utilize the database update system to modify the
    configuration. Drupal utilizes a schema version for modules. The base schema version
    for a module is `8000`. Modules can provide update hooks in the form of `hook_update_N`,
    where `N` represents the next schema version. When Drupal's updates are run, they
    will execute the proper update hooks and update the module's schema version.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration objects are immutable by default. To edit a configuration, a mutable
    object needs to be loaded through the configuration factory service.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss configuration in [*Chapter 9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml),
    *Configuration Management - Deploying in Drupal 8*; however, we will now dive
    into some important notes when working with modules and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration subdirectories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three directories that the configuration management system will inspect
    in a module''s `config` folder, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`install`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optional`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `install` folder specifies the configuration that will be imported. If
    the configuration object exists, the installation will fail. The `optional` folder
    contains the configuration that will be installed if the following conditions
    are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration does not already exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a configuration entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its dependencies can be met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any one of the conditions fails, the configuration will not be installed,
    but it will not halt the module's installation process.
  prefs: []
  type: TYPE_NORMAL
- en: The `schema` folder provides configuration object definitions. This uses YAML
    definitions to structure configuration objects, and is covered in depth in [*Chapter
    9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), *Configuration Management - Deploying
    in Drupal 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the existing configuration on installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration management system does not allow modules to provide configuration
    on an installation that already exists. For example, if a module tries to provide
    `system.site` and defines the site's name, it would fail to install. This is because
    the system module provides this configuration object when you first install Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drupal provides `hook_install()` that modules can implement in their `.install`
    file. This hook is executed during the module''s installation process. The following
    code will update the site''s title to *Drupal 8 Cookbook*! on the module''s installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Configurable objects are immutable by default when loaded by the default `config`
    service. To modify a configuration object, you will need to use the configuration
    factory to receive a mutable object. The mutable object can have `set` and `save`
    methods that are executed to update the configuration in a configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [*Chapter 9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), *Configuration
    Management - Deploying in Drupal 8*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New to Drupal 8 is the event dispatcher system. One of the many benefits of
    Drupal is the ability to react to specific processes and alter or react to them.
    Unlike the hook system that exists in Drupal 8, and has for many versions of Drupal,
    the event dispatch system uses explicit registration to an event.
  prefs: []
  type: TYPE_NORMAL
- en: The events dispatcher system comes from the Symfony framework and allows components
    to easily interact with one another. Within Drupal, and integrated Symfony components,
    events are dispatched, and event subscribers can listen to the events and react
    to changes or other processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will subscribe to the `REQUEST` event, which fires when a
    request is first handled. If the user is not logged in, we will navigate them
    to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create `src/EventSubscriber/RequestSubscriber.php` in your module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `RequestSubscriber` class, which implements the `EventSubscriberInterface`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To satisfy the interface requirements, we must add a `getSubscribedEvents`
    method. This tells the system which events we are subscribing to and the method
    that needs to be invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `KernelEvents` class provides constants for available events. Our returned
    array specifies the method to invoke and its priority for that event.
  prefs: []
  type: TYPE_NORMAL
- en: Priorities will be discussed in the *How it works*... section. It is provided
    in the example to resolve possible conflicts when the `dynamic_page_cache` module
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `doAnonymousRedirect` method we specified, which will receive a
    `GetResponseEvent` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To prevent a redirect loop, we will use the `RouteMatch` service to get the
    current route object and verify that we are not already on the `user.login` route
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check whether the user is anonymous and, if the user is anonymous, set
    the event's response to a redirect response.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our class, create a `mymodule.services.yml` file in
    your module's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must register our class with the service container so that Drupal understands
    that it will act as an event subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `event_subscriber` tag tells the container to invoke the `getSubscribedEvents`
    method and register its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Install the module or rebuild Drupal's caches if it has been already installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to any page as an anonymous user--you will be redirected to the login
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout Drupal and Symfony components, and even other third-party PHP libraries,
    events can be passed to the event dispatcher. The `event_dispatcher` service in
    Drupal is an optimized version of the one provided by Symfony, but is completely
    interoperable.
  prefs: []
  type: TYPE_NORMAL
- en: When the container is built, all services tagged as `event_subscribers` are
    gathered. They are then registered into the `event_dispatcher` service, keyed
    by the events returned in the `getSubscribedEvents` method.
  prefs: []
  type: TYPE_NORMAL
- en: When the `event_dispatcher` service is told to dispatch an event, it invokes
    the proper methods on all subscribed services. With `KernelEvents::REQUEST`, `KernelEvents::EXCEPTION`
    and `KernelEvents::VIEW`, you have the opportunity to provide a response before
    the controller is invoked. Then there are events, such as `ConfigEvents::SAVE`
    and `ConfigEvents::DELETE`, that are dispatched and allow you to react to a configuration
    being saved or deleted but are not actually able to adjust the configuration entity
    directly through the event object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event subscribers require knowledge of creating services, registering them,
    and even dependency injection. We'll discuss this some more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Drupal 8 and the implementation of a service container comes the concept
    of dependency injection. Dependency injection is a software design concept, and
    at its base level, it provides a means to use a class without having to directly
    reference it. In our example, we retrieve services multiple times using the global
    static class `\Drupal`. This is bad practice within services, and can make testing
    more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement dependency injection, first, we will add a constructor to our
    class that accepts the services used (`current_route_match` and `current_user`)
    and matches protected properties to store them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace any calls to `\Drupal::` with `$this->`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will update `mymodule.services.yml` to specify our constructor
    arguments so that they will be injected when the container runs our event subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection feels and seems magical at first. However, with use and
    practice, it will begin to make more sense and become second nature when developing
    with Drupal 8.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the Drupal.org API documentation for events and a list of available
    events at [https://api.drupal.org/api/drupal/core%21core.api.php/group/events/8.3.x](https://api.drupal.org/api/drupal/core%21core.api.php/group/events/8.3.x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the Drupal.org API documentation on services and dependency injection
    at [https://api.drupal.org/api/drupal/core%21core.api.php/group/container/8.3.x](https://api.drupal.org/api/drupal/core%21core.api.php/group/container/8.3.x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Features 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Drupal users create custom modules to provide specific sets of features
    that they can reuse across multiple sites. In fact, there is a module for the
    sole purpose of providing a means to export configuration and create modules that
    provide features. This is how the Features module received its name, in fact.
  prefs: []
  type: TYPE_NORMAL
- en: The Features module has two submodules. The main Features module provides all
    the functionalities. The Features UI module provides a user interface to create
    and manage features.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Features to export a module with a configuration that contains the
    default page and article content types provided by the standard installation so
    that they can be used on other installation profiles.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will install the Features module using Composer, which will also
    download its dependency, the **Configuration Update Manager** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Go to Extend and install the Features UI module, confirming the requirements
    to install Features and Configuration Update Manager as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to Configuration, and in the DEVELOPMENT section, you will find the link
    to access the Features user interface; click on Features:![](img/e1b494ea-73af-44e3-a591-076d3681bf4d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create new feature to start making a custom Feature module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a `Name` for the feature, such as Content Authoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, you can provide a description. This acts as the `description` key
    in the module's `info.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle the Content types grouping and check the Article and Basic Page checkboxes
    to mark them for export.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Features module will automatically add detected dependencies or important
    configuration items to also be exported, such as fields and view modes:![](img/74b49b41-5338-4baa-91ea-4c9047d445ac.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Write to write the module to export the module and configuration to
    the `/modules/custom` directory in your Drupal site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to Extend, search for the Content Authoring module, and install your newly
    created module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Features exports static YAML configuration files into the module's `config/install`
    folder. Features modifies the standard configuration management workflow by ensuring
    that a specific kind of configuration exists. Configuration management does not
    allow modules to overwrite existing configuration objects, but Features manages
    and allows this to happen.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, Features provides `\Drupal\features\FeaturesConfigInstaller`,
    which extends the default `config.install` service class. It then alters the services
    definition to use its `FeaturesConfigInstaller` class instead of the default `\Drupal\Core\Config\ConfigInstaller`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond adjusting the `config.install` service, Features harnesses all the functionalities
    of the configuration management system to provide a simpler way to generate modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any module can be considered a Feature''s module by adding the `features: true`
    key to its `info.yml`. This will allow it to be managed through the Features UI.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Features is a robust tool to easily provide bundled configuration; we will discuss
    more ways to use the Features module in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested feature modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Features module provides an intelligent bundling method that reviews the
    current Drupal site's configuration and suggests feature modules that should be
    created to preserve the configuration. These are provided through package assignment
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'These plugins use logic to assign configurations to specific packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/896394f8-b6f6-4ffd-bccc-3fcc6dcee182.png)'
  prefs: []
  type: TYPE_IMG
- en: When you visit the Features UI, it will present you with suggested feature modules
    to be exported. Expanding the items will list the configuration items that will
    be bundled. Clicking on the suggested feature's link opens the creation form.
    Alternatively, the checkbox can be used in conjunction with the Download archive
    or Write button at the bottom of the form.
  prefs: []
  type: TYPE_NORMAL
- en: The unpackaged section shows a configuration that has not met any of the packaging
    rules to group the configuration into a specified module. This will need to be
    manually added to a created feature module.
  prefs: []
  type: TYPE_NORMAL
- en: Features bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Features module, there are bundles, and bundles have their own assignment
    method configurations. The purpose of bundles inside Features is to provide an
    automatic assignment of configuration that can be grouped into exported modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3db51c3-3e21-4c38-8d16-5d5090e8bb5b.png)'
  prefs: []
  type: TYPE_IMG
- en: A bundle has a human display name and machine name. The bundle's machine name
    will be prefixed on all feature modules generated under this bundle. You also
    can specify the bundle to act as an installation profile. The features UI was
    heavily used in Drupal 7 to construct distributions and spawn the concept of the
    bundle functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment methods can be rearranged and configured to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the configuration state of Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Features UI provides a means to review changes to the feature's configuration
    that may have been made. If a configuration item controlled by a feature module
    has been modified, it will show up under the differences section of the Features
    UI. This will allow you to import or update the Feature module with the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Import option will force the site to use the configuration defined in the
    module''s configuration `YAML` files. For example, in the following screenshot
    we have an exported content type whose description was modified in the user interface
    after being exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1130b56-93d9-4f5b-9207-9c8ab5b62361.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference created by the feature module is highlighted. If the difference
    was checked, and if you click on Import changes, the content type's description
    would be reset to that defined in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: From the main features overview table, the feature module can be re-exported
    to include the change and update the exported YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "Refer to the Drupal.org handbook for the Features module at [https://www.drupal.org/docs/8/modules/features\uFEFF\
    ](https://www.drupal.org/docs/8/modules/features)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
