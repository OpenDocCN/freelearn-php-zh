<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Developing an Issue-tracking Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Developing an Issue-tracking Application</h1></div></div></div><p>In the previous chapters, we worked on very simple and practical applications. As we move forward, our applications will become more complex and intricate. For our next project, we will develop an issue-tracking system that will allow customers to report issues and allow us to manage those users and issues from a single application. In this application, we <a id="id295" class="indexterm"/>will also provide support to create and update issues over e-mail. Finally, we'll be expanding upon our user management system to allow per-user roles.</p><p>In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a user management interface</li><li class="listitem" style="list-style-type: disc">Adding role-based authorization</li><li class="listitem" style="list-style-type: disc">Sending and receiving e-mails from a Yii application</li><li class="listitem" style="list-style-type: disc">Integrating third-party libraries and tools into our application</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Prerequisites</h1></div></div></div><p>Before <a id="id296" class="indexterm"/>we get started, there are a couple of things that we'll need to have set up and working:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Since we'll send and receive e-mails from our application, we're going to need a registered and active domain name. If you do not already have a working <a id="id297" class="indexterm"/>domain name, you can purchase one from a domain registrar such as <a class="ulink" href="http://www.namecheap.com">www.namecheap.com</a>, <a class="ulink" href="http://www.name.com">www.name.com</a>, or <a class="ulink" href="http://www.gandi.net">www.gandi.net</a>.</li><li class="listitem" style="list-style-type: disc">We'll also need the ability to modify the Domain Name System (DNS) records for this domain. For our application to receive e-mails, we'll need to be able to modify the DNS records for our domain. Most registrars provide a rudimentary DNS management system. If yours does not, you can use a free DNS <a id="id298" class="indexterm"/>hosting service, such as <a class="ulink" href="http://www.cloudflare.com">www.cloudflare.com</a> or <a class="ulink" href="http://www.rackspace.com/cloud/dns">http://www.rackspace.com/cloud/dns</a>.</li><li class="listitem" style="list-style-type: disc">Next, you'll need to have a web server with a public facing IP address. This will<a id="id299" class="indexterm"/> allow e-mails to be sent to our application. Many cloud <span class="strong"><strong>Virtual Private Server</strong></span> (<span class="strong"><strong>VPS</strong></span>) providers are available to use for low monthly or hourly prices. Such services include <a class="ulink" href="http://www.digitalocean.com">www.digitalocean.com</a>, <a class="ulink" href="http://www.linode.com">www.linode.com</a>, and <a class="ulink" href="http://www.rackspace.com/cloud/servers">http://www.rackspace.com/cloud/servers</a>.</li><li class="listitem" style="list-style-type: disc">Rather than create, configure, and maintain our own e-mail server and SMTP relay, we<a id="id300" class="indexterm"/> can take advantage of third-party tools and libraries. This will allow us to focus on the development of our application rather than the maintenance of a secondary service. Using this service and its accompanying PHP library, we can take advantage of code that has already been thoroughly tested and vetted, which allows us as developers to get straight to coding. To take advantage of SendGrid, we'll create a free SendGrid developer account, which can be set up <a id="id301" class="indexterm"/>at <a class="ulink" href="https://www.sendgrid.com/developers">https://www.sendgrid.com/developers</a>. For now, simply set up your account. Later in the chapter, we'll go through the process of setting up our application to receive e-mails from this service.</li><li class="listitem" style="list-style-type: disc">In this chapter, we'll once again use the latest version of MySQL (at the time of this writing, MySQL 5.6). Make sure that your MySQL server is set up and running on your server.</li><li class="listitem" style="list-style-type: disc">Finally, we'll<a id="id302" class="indexterm"/> need to download and install Composer from <a class="ulink" href="https://getcomposer.org/">https://getcomposer.org/</a>.</li></ul></div><p>Once you have acquired everything listed in the preceding steps, create a subdomain on the domain name you are using, and point it to your server. In this chapter, I'll be using <code class="literal">chapter4.example.com</code> to refer to this subdomain. After everything is set up and your server is responding to that domain name, we can get started.</p></div></div>
<div class="section" title="Describing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Describing the project</h1></div></div></div><p>Our<a id="id303" class="indexterm"/> issue-tracking project can be broken down into the following three main components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Users<a id="id304" class="indexterm"/> who will create and <a id="id305" class="indexterm"/>respond to issues</li><li class="listitem" style="list-style-type: disc">Issues<a id="id306" class="indexterm"/> that can be updated <a id="id307" class="indexterm"/>by the end user or a supporter (a specific type of user that will support our end users)</li><li class="listitem" style="list-style-type: disc">A <a id="id308" class="indexterm"/>publicly available endpoint <a id="id309" class="indexterm"/>for SendGrid to POST to with any emails we may receive</li></ul></div><div class="section" title="Users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Users</h2></div></div></div><p>The first <a id="id310" class="indexterm"/>component of our application<a id="id311" class="indexterm"/> is the user who will be using it. For this application, we will be using the same database structure that we did in <a class="link" href="ch03.html" title="Chapter 3. Scheduled Reminders">Chapter 3</a>, <span class="emphasis"><em>Scheduled Reminders</em></span>, with the addition of a new column called <code class="literal">role_id</code>, which will allow us to distinguish which position the user has within our application. For this application, we will expand upon our login process to ensure that the user's role is available for us to reference and manipulate within our application.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec26"/>Roles</h3></div></div></div><p>Rather than have a single administrator who is capable of managing our system, in this application, we can have multiple users who we can promote or demote to different roles <a id="id312" class="indexterm"/>within our application. The role that we associate with our user will allow us to determine what users of that role are permitted to do within our application.</p><p>For <a id="id313" class="indexterm"/>this application, we will be supporting<a id="id314" class="indexterm"/> three basic roles: a customer <a id="id315" class="indexterm"/>who will submit issues and updates, a supporter who has the same permissions as a customer in addition to being able to update issues that belong to other customers, and an administrator who has the same permissions as a supporter and can also manage the roles of other users.</p><p>To store this information, we'll use a simple roles table in our database setup as follows. We'll then set up a relationship between users and role so that this information is automatically associated with our users.</p><div class="informalexample"><pre class="programlisting">ID INTEGER PRIMARY KEY
name STRING
created INTEGER
updated INTEGER</pre></div></div></div><div class="section" title="Issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Issues</h2></div></div></div><p>The second component of our application is the issue that users will create. An issue is an item that can be created either within the application or from outside of it by sending an e-mail to our application. Issues can also be updated from within the application or by an e-mail sent by the customer. Issues will also have a status associated with them that will help our <a id="id316" class="indexterm"/>supporters track the current <a id="id317" class="indexterm"/>project of a particular issue. The database that we'll be using will look as follows:</p><div class="informalexample"><pre class="programlisting">ID INTEGER PRIMARY KEY
customer_id INTEGER FK
title STRING
description TEXT
status_id INTEGER FK
created INTEGER
updated INTEGER</pre></div><div class="section" title="Statuses"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec27"/>Statuses</h3></div></div></div><p>Associated <a id="id318" class="indexterm"/>with each issue will be a unique status. These statuses will allow our supporters to track the project of an issue and will allow us to trigger specific events when an issue changes from one status to another. Our table for these records will look identical to our roles table:</p><div class="informalexample"><pre class="programlisting">ID INTEGER PRIMARY KEY
name STRING
created INTEGER
updated INTEGER</pre></div></div><div class="section" title="Updates"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec28"/>Updates</h3></div></div></div><p>Also <a id="id319" class="indexterm"/>associated with each issue is an update. Each issue can have one or many updates attached to them, which will allow supporters to see what work has been done to a particular issue and which will serve as a medium for the user to communicate with our supporters. Each update will be associated with both a user and an issue. Our database table for this information will look as follows:</p><div class="informalexample"><pre class="programlisting">ID INTEGER PRIMARY KEY
issue_id INTEGER FK
author_id INTEGER FK
update TEXT
created INTEGER
updated INTEGER</pre></div></div></div><div class="section" title="Receiving e-mails"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Receiving e-mails</h2></div></div></div><p>The <a id="id320" class="indexterm"/>final component of our application <a id="id321" class="indexterm"/>will allow customers to create new issues and update existing issues via e-mail. To the end user, this process will feel seamless, yet it will allow our supporters to keep track of the work and updates that are done to a given issue. This custom endpoint will also allow us to seamlessly create new users within our application and associate information with those users as necessary.</p></div></div>
<div class="section" title="Initializing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Initializing the project</h1></div></div></div><p>By now, you should be comfortable with creating projects from scratch. To provide us with a <a id="id322" class="indexterm"/>common starting ground, a skeleton project<a id="id323" class="indexterm"/> has been included with the project resources for this chapter. Included with this skeleton project are the necessary migrations, data files, controllers, and views to get us started. Also included is the login system that we'll use for authentication throughout this chapter.</p><p>We'll start by copying the skeleton project included with the chapter resources to our web server and configure it so that it responds to <code class="literal">chapter4.example.com</code> as outlined in the beginning of the chapter, and then follow the next steps to make sure everything is set up:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since a skeleton project was provided, begin by adjusting the path to Yii framework in <code class="literal">index.php</code> to point to your Yii installation path. At this point, you'll also want to adjust the permissions on the <code class="literal">assets</code> and <code class="literal">protected/runtime</code> folders.</li><li class="listitem">Next, create the MySQL user and database table that our application will use. If you don't want to alter the main configuration file that is provided, the following MySQL commands will create the database and user for you:<div class="informalexample"><pre class="programlisting">CREATE USER 'ch4_issue'@'localhost' IDENTIFIED BY 'ch4_issue';
CREATE DATABASE IF NOT EXISTS  `ch4_issue` ;
GRANT ALL PRIVILEGES ON  `ch4\_issue` . * TO  'ch4_issue'@'localhost';
FLUSH PRIVILEGES;</pre></div></li><li class="listitem">Next, we'll need to run the initial migrations and then import the sample data that is provided in the <code class="literal">protected/data</code> folder. This sample data will allow us to immediately log in to our application and start using it once the application is running. Navigate to the root of the project, and then run the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php protected/yiic.php migrate up --interactive=0</strong></span>
<span class="strong"><strong>mysql –u ch4_issue –p ch4_issue &lt; protected/data/combined.sql</strong></span>
</pre></div></li><li class="listitem">We<a id="id324" class="indexterm"/> need to update <code class="literal">params.php</code> at <code class="literal">protected/config/</code> with our SendGrid information. Your username <a id="id325" class="indexterm"/>and password will correspond to your SendGrid username and password. In keeping with our example domain, set the from address to <code class="literal">noreply@chapter4.example.com</code>.</li><li class="listitem">Finally, we need to install the necessary composer dependencies:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>composer install</strong></span>
</pre></div></li></ol></div><p>After performing these steps, you should be able to navigate to <code class="literal">chapter4.example.com</code> in your browser and see a login page to our application. After logging in to our application using one of the credentials that are provided in the table just after this paragraph, you should see the page following this table load:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Username</p>
</th><th style="text-align: left" valign="bottom">
<p>Password</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">customer@example.com</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">test</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">supporter@example.com</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">test</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">admin@example.com</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">test</code>
</p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="graphics/7734OS_04_01.jpg" alt="Initializing the project"/></div></div>
<div class="section" title="Managing users"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Managing users</h1></div></div></div><p>Before <a id="id326" class="indexterm"/>we can begin working on issues, we first need to make sure that users can be both created and managed from within our application. In <a class="link" href="ch03.html" title="Chapter 3. Scheduled Reminders">Chapter 3</a>, <span class="emphasis"><em>Scheduled Reminders</em></span>, we used a command-line tool to do this. In this chapter, we will create a complete user management tool from a web interface to supplement that tool.</p><div class="section" title="Roles and authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Roles and authentication</h2></div></div></div><p>Before we <a id="id327" class="indexterm"/>get into managing<a id="id328" class="indexterm"/> our users, let's take a look at how authentication and roles are handled within our application. Within the <code class="literal">UserController</code> and <code class="literal">IssueController</code> provided with the skeleton application is a more complex <code class="literal">accessRules()</code> method that has a new attribute added to it. Let's take a look at this method within <code class="literal">UserController</code>:</p><div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return array(
      array('allow',
         'actions' =&gt; array('search', 'view'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role&gt;=2'
      ),
      array('allow',
         'actions' =&gt; array('index', 'save', 'delete'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role==3'
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      ),
   );
}</pre></div><p>As you<a id="id329" class="indexterm"/> can see, we now <a id="id330" class="indexterm"/>have a new attribute called <code class="literal">expression</code> listed within this method. Internally, Yii will evaluate this expression to a Boolean value. If that expression resolves to true, and the actions and user condition match, then a user is allowed to proceed to the action. In our case, we are checking that <code class="literal">Yii::app()-&gt;user-&gt;role</code> has a particular value.</p><p>Out of the box, Yii doesn't know what that value should be, so unless we define it, it will be undefined. Since <code class="literal">Yii::app()-&gt;user</code> is a <code class="literal">CWebUser</code> object, we can add additional information to it when we create the <code class="literal">UserIdentity</code> component. If we take a look at the <code class="literal">UserIdentity</code> component supplied with the project, we can see this attribute being added via the <code class="literal">CUserIdentity setState()</code> method:</p><div class="informalexample"><pre class="programlisting">public function authenticate()
{
   $record = User::model()-&gt;findByAttributes(array('email'=&gt;$this-&gt;username));

   if ($record == NULL)
      $this-&gt;errorCode = self::ERROR_UNKNOWN_IDENTITY;
   else if (password_verify($this-&gt;password, $record-&gt;password))
   {
      $this-&gt;errorCode = self::ERROR_NONE;
      $this-&gt;_id 		 = $record-&gt;id;
      $this-&gt;setState('email', $record-&gt;email);
      $this-&gt;setState('role', $record-&gt;role_id);
   }
   else
      $this-&gt;errorCode = self::ERROR_UNKNOWN_IDENTITY;

   return !$this-&gt;errorCode;
}</pre></div><p>Yii <a id="id331" class="indexterm"/>will then store this information <a id="id332" class="indexterm"/>within our <code class="literal">$_SESSION</code> variable once the user logs in, allowing us to reference it as long as the session is active.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>While using simple Boolean expressions is easy, should we ever want to change which users have access to our system, we would have to refactor our controller methods rather than data in our database. Consider instead creating a model method, such as <code class="literal">User::isSupporter()</code> or <code class="literal">User::isAdmin()</code>. These methods make it more clear who has access to our actions and will make your application easier to maintain in the future.</p></div></div></div><div class="section" title="Listing users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Listing users</h2></div></div></div><p>Now that <a id="id333" class="indexterm"/>we know how roles work within our application, let's start building our controller methods for our <code class="literal">UserController</code>. Open <code class="literal">protected/controllers/UserController.php</code>, and you can see that we already have definitions for the methods we will be implementing.</p><p>To display a list of our users, we'll be using the <code class="literal">User::search()</code> method within our controller and a <code class="literal">CGridView</code> widget within our view:</p><div class="informalexample"><pre class="programlisting">public function actionIndex()
{
   $users = new User('search');
   $users-&gt;unsetAttributes();

   if (isset($_GET['User']))
      $users-&gt;attributes = $_GET['Users'];

   $this-&gt;render('index', array(
      'model' =&gt; $users
   ));
}</pre></div><p>Within <a id="id334" class="indexterm"/>our <code class="literal">index.php</code> file at <code class="literal">views/user/</code>, we'll load a <code class="literal">CGridView</code> instance:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;Manage Users&lt;/h3&gt;
&lt;?php $this-&gt;widget('zii.widgets.grid.CGridView', array(
   'itemsCssClass' =&gt; 'table table-striped',
   'enableSorting' =&gt; true,
   'dataProvider'  =&gt;$model-&gt;search(),
    'columns' =&gt; array(
        'id',
        'email',
        'name',
       array(
            'class'=&gt;'CButtonColumn',
            'template' =&gt; '{view}{update}{delete}',
            'viewButtonOptions' =&gt; array(
                'class' =&gt; 'fa fa-search'
            ),
            'viewButtonLabel' =&gt; false,
            'viewButtonImageUrl' =&gt; false,
            'viewButtonUrl' =&gt; 'Yii::app()-&gt;createUrl("user/view", array("id" =&gt; "$data-&gt;id"))',
            'updateButtonOptions' =&gt; array(
               'class' =&gt; 'fa fa-pencil'
            ),
            'updateButtonLabel' =&gt; false,
            'updateButtonImageUrl' =&gt; false,
            'updateButtonUrl' =&gt; 'Yii::app()-&gt;createUrl("user/save", array("id" =&gt; "$data-&gt;id"))',
            'deleteButtonOptions' =&gt; array(
                'class' =&gt; 'fa fa-trash-o'
            ),
            'deleteButtonLabel' =&gt; false,
            'deleteButtonImageUrl' =&gt; false,
            'deleteButtonUrl' =&gt; 'Yii::app()-&gt;createUrl("user/delete", array("id" =&gt; "$data-&gt;id"))'
        ),
    )
));</pre></div><p>Within our <code class="literal">CGridView</code> instance's columns attribute, we've defined a custom column called <code class="literal">CButtonColumn</code>. <code class="literal">CButtonColumn</code> allows us to add a series of useful buttons to a <code class="literal">CGridView</code> instance, such as a view button, an update button, and a delete button, with all the <a id="id335" class="indexterm"/>necessary JavaScript. By taking advantage of this <a id="id336" class="indexterm"/>column, we now have quick access to these actions from within our view.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>You can<a id="id337" class="indexterm"/> read more about <code class="literal">CButtonColumn</code> on its Yii Class Reference page located at <a class="ulink" href="http://www.yiiframework.com/doc/api/1.1/CButtonColumn">http://www.yiiframework.com/doc/api/1.1/CButtonColumn</a>.</p></div></div></div><div class="section" title="Deleting users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Deleting users</h2></div></div></div><p>Next, we<a id="id338" class="indexterm"/> should implement an <code class="literal">actionDelete()</code> method<a id="id339" class="indexterm"/> to work with our delete button. To make<a id="id340" class="indexterm"/> things easier, we can add a helpful <code class="literal">loadModel()</code> method as well to perform all the necessary checks for us. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">public function actionDelete($id=NULL)
{
   if ($id == Yii::app()-&gt;user-&gt;id)
      throw new CHttpException(403, 'You cannot delete yourself');

   $user = $this-&gt;loadModel($id);

   if ($user-&gt;delete())
      $this-&gt;redirect($this-&gt;createUrl('user/index'));

   throw new CHttpException(400, 'Bad Request');
}

private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(400, 'Missing ID');

   $model = User::model()-&gt;findByPk($id);

   if ($model == NULL)
      throw new CHttpException(404, 'No user with that ID could be found');

   return $model;
}</pre></div></div><div class="section" title="Creating and updating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Creating and updating users</h2></div></div></div><p>Next, we <a id="id341" class="indexterm"/>can create our <code class="literal">actionSave()</code> method <a id="id342" class="indexterm"/>that will handle both creating and updating <a id="id343" class="indexterm"/>our users. Since our view will be passing us all the information we need, we use a simple <code class="literal">$user-&gt;save()</code> call to save our information. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">public function actionSave($id=NULL)
{
   if ($id == NULL)
      $user = new User;
   else
      $user = $this-&gt;loadModel($id);

   if (isset($_POST['User']))
   {
      $user-&gt;attributes = $_POST['User'];

      try
      {
         if ($user-&gt;save())
         {
            Yii::app()-&gt;user-&gt;setFlash('success', 'The user has sucessfully been updated');
            $this-&gt;redirect($this-&gt;createUrl('user/save', array('id' =&gt; $user-&gt;id)));
         }
      } catch (Exception $e) {
         $user-&gt;addError('email', 'A user with that email address already exists');
      }
   }

   $this-&gt;render('save', array(
      'model' =&gt; $user
   ));
}</pre></div><p>In this action, we've also deliberately thrown a <code class="literal">try</code>/<code class="literal">catch</code> block around our <code class="literal">save</code> method. We've done this because we've put a unique index constraint on the <code class="literal">email</code> field of our <a id="id344" class="indexterm"/>database. If we attempt to save two users <a id="id345" class="indexterm"/>to our database with the same e-mail, Yii will throw an internal error since it doesn't know how to handle the constraint. Within our controller, we can catch this error and simply return a more friendly error to the user in <code class="literal">$form-&gt;errorSummary($model)</code> in our view via the <code class="literal">$user-&gt;addError()</code> method.</p><p>Then, copy the <code class="literal">view/user/save.php</code> file from the project resources folder into your project. Within our view, we can populate a select dropdown of all the roles currently in our database using <code class="literal">CHtml::listData()</code>. Using this method allows us to add new roles to our database without having to alter a view in the future:</p><div class="informalexample"><pre class="programlisting">CHtml::listData(Role::model()-&gt;findAll(), 'id', 'name');</pre></div></div><div class="section" title="Viewing users and associated issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Viewing users and associated issues</h2></div></div></div><p>Finally, we <a id="id346" class="indexterm"/>should create a view to display a <a id="id347" class="indexterm"/>particular user and all the unresolved issues currently assigned to them. For our <code class="literal">actionView()</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">public function actionView($id=NULL)
{
    $user = $this-&gt;loadModel($id);
    $issues = new Issue('search');
    $issues-&gt;unsetAttributes();

    if(isset($_GET['Issue']))
        $issues-&gt;attributes=$_GET['Issue'];
    $issues-&gt;status_id = '&lt;5';

    $issues-&gt;customer_id = $user-&gt;id;

    $this-&gt;render('view', array(
       'user' 	 =&gt; $user,
      'issues' =&gt; $issues
   ));
}</pre></div><p>Then, copy the <code class="literal">view.php</code> file at <code class="literal">views/user/</code> from the project resources folder into our project, and open it. At the bottom of this file, you'll see a call to <code class="literal">renderPartial()</code> to render a view that we haven't created yet:</p><div class="informalexample"><pre class="programlisting">&lt;?php $this-&gt;renderPartial('//issue/issues', array('model' =&gt; $issues)); ?&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>In Yii, the <code class="literal">//</code> notation before a layout indicates that Yii should search for the view file in the main application <code class="literal">views</code> folder. You can read more about how Yii loads <a id="id348" class="indexterm"/>view files at <a class="ulink" href="http://www.yiiframework.com/doc/api/1.1/CController#getLayoutFile-detail">http://www.yiiframework.com/doc/api/1.1/CController#getLayoutFile-detail</a>.</p></div></div><p>We'll use<a id="id349" class="indexterm"/> this view file across our application<a id="id350" class="indexterm"/> to ensure that all of our lists look consistent. Before moving on, let's create this issue view. Create a new file in <code class="literal">views/issues/issue.php</code> and add the following <code class="literal">CGridView</code> widget:</p><div class="informalexample"><pre class="programlisting">&lt;?php $this-&gt;widget('zii.widgets.grid.CGridView', array(
   'itemsCssClass' =&gt; 'table table-striped',
   'enableSorting' =&gt; true,
    'dataProvider'=&gt;$model-&gt;search(),
    'columns' =&gt; array(
       'id',
       'customer_id' =&gt; array(
          'name' =&gt; 'Customer',
          'value' =&gt; '$data-&gt;customer-&gt;name'
       ),
       'title',
        'status_id' =&gt; array(
            'name' =&gt; 'Status',
            'value' =&gt; '$data-&gt;status-&gt;name'
        ),
       'updated' =&gt; array(
          'name' =&gt; 'Last Updated',
          'value' =&gt; 'date("F m, Y @ H:i", $data-&gt;updated) . " UTC"'
       ),
       array(
            'class'=&gt;'CButtonColumn',
            'template' =&gt; '{update}',
            'updateButtonOptions' =&gt; array(
            	'class' =&gt; 'fa fa-pencil'
            ),
            'updateButtonLabel' =&gt; false,
            'updateButtonImageUrl' =&gt; false
        ),
    )
));</pre></div><p>While <a id="id351" class="indexterm"/>our view will now render, we don't<a id="id352" class="indexterm"/> yet have any issues in our database to display, so results will not be shown. Once we've added issues, we can come back to this view to see all the issues associated with a user.</p></div></div>
<div class="section" title="Implementing the issue-management component"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Implementing the issue-management component</h1></div></div></div><p>At<a id="id353" class="indexterm"/> the core of our application are the issues that users will submit. For this application, we'll assume that users will submit new issues for themselves, and that supporters will be supporting those issues. To ensure that issues are created for just the logged-in user, we have to make a few changes to our Issues model. Open <code class="literal">protected/models/Issues.php</code>, and let's get started.</p><div class="section" title="The Issues model"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>The Issues model</h2></div></div></div><p>Provided at<a id="id354" class="indexterm"/> the top of our skeleton model are properties designed to help us later in the model:</p><div class="informalexample"><pre class="programlisting">   private $_isNewRecord = false;
   public  $_isEmailCreate = false;</pre></div><p>The first property <code class="literal">$_isNewRecord</code> is a Boolean value that we'll use within our <code class="literal">afterSave()</code> method to determine what e-mail will be sent. While <code class="literal">CActiveRecord</code> provides a property called <code class="literal">$isNewRecord</code>, Yii changes this value to FALSE before the <code class="literal">afterSave()</code> method.</p><p>The second property <code class="literal">$_isEmailCreate</code> is also a Boolean value. Since the e-mails we receive won't have a session associated with them, we need to know what user to associate the issue with. Since we'll restrict issues' owners to the currently logged-in user, we need a way to override this behavior for e-mail submissions.</p><p>After verifying that these properties are added, we can begin work on the other methods that we need to add to this model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first method we'll need to implement in our Issue model is a <code class="literal">beforeSave()</code> method to restrict the customer of an issue. Within this method, we'll want to also set the status of new issues to <code class="literal">New</code>, and flag our <code class="literal">$_isNewRecord</code> property so that we can use it in our <code class="literal">afterSave()</code> method. Additionally, we'll want to prevent accidental changes to <code class="literal">customer_id</code> should<a id="id355" class="indexterm"/> it somehow be changed on an existing issue:<div class="informalexample"><pre class="programlisting">public function beforeSave()
{
   if ($this-&gt;isNewRecord)
   {
      // If this is a new issue, set the customer_id to be the currently logged in user
      if (!$this-&gt;_isEmailCreate)
         $this-&gt;customer_id = Yii::app()-&gt;user-&gt;id;

      // And set the status to 'New'
      $this-&gt;status_id = 1;

      // Set IsNewRecord so that afterSave can pick this up
      $this-&gt;_isNewRecord = true;
   }
   else // Otherwise reset the customer_id back to what it previously was (prevent it from being changed)
      $this-&gt;customer_id = $this-&gt;_oldAttributes['customer_id'];

   return parent::beforeSave();
}</pre></div></li><li class="listitem">Next, we need to update the <code class="literal">afterSave()</code> method so that it sends e-mails to the customer. For this model, we'll send an e-mail to the user if an issue has been created for them or if an issue's status has been resolved. To do this, we'll use SendGrid. Before adding this method, verify that your <code class="literal">params.php</code> file at <code class="literal">protected/config/</code> has the correct credentials in it:<div class="informalexample"><pre class="programlisting">public function afterSave()
{
   $user = User::model()-&gt;findByPk($this-&gt;customer_id);
   $sendgrid = new SendGrid(Yii::app()-&gt;params['sendgrid']['username'], Yii::app()-&gt;params['sendgrid']['password']);
   $email    = new SendGrid\Email();
   $email-&gt;setFrom(Yii::app()-&gt;params['sendgrid']['from'])
        -&gt;addTo($user-&gt;email);

   if ($this-&gt;_isNewRecord)
   {
      $email-&gt;setSubject("[Issue #$this-&gt;id] $this-&gt;subject | A New Issue Has Been Created For You")
           -&gt;setText('Issue has been created')
           -&gt;setHtml(Yii::app()-&gt;controller-&gt;renderPartial('//email/created', array('issue' =&gt; $this, 'user' =&gt; $user), true));

      // Send the SendGrid email
      $sendgrid-&gt;send($email);
   }
   else
   {
      if ($this-&gt;status_id == 5 &amp;&amp; $this-&gt;_oldAttributes['status'] != 5)
      {
         $email-&gt;addTo($user-&gt;email)
           -&gt;setSubject("[Issue #$this-&gt;id] Issue has been resolved")
           -&gt;setText('Issue has been resolved')
           -&gt;setHtml(Yii::app()-&gt;controller-&gt;renderPartial('//email/resolved', array('issue' =&gt; $this, 'user' =&gt; $user), true));

         // Send the SendGrid email
         $sendgrid-&gt;send($email);
      }
   }
   
   return parent::afterSave();
}</pre></div></li><li class="listitem">The<a id="id356" class="indexterm"/> final change we'll need to make to the Issue model is in the <code class="literal">search()</code> method. Ideally, we'd like our supporters to be able to search for an issue by either the ID of the issue or a keyword in the title or description. To do this, we can simply repurpose the <code class="literal">Issue::search()</code> method by changing the <code class="literal">$criteria-&gt;compare()</code> call on those two attributes to <code class="literal">$criteria-&gt;addSearchCondition()</code>:<div class="informalexample"><pre class="programlisting">$criteria-&gt;addSearchCondition('title',$this-&gt;title,true, 'OR');
$criteria-&gt;addSearchCondition('description',$this-&gt;title,true, 'OR');</pre></div></li></ol></div></div><div class="section" title="The Issues Update model"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec69"/>The Issues Update model</h2></div></div></div><p>Before <a id="id357" class="indexterm"/>working on the <code class="literal">IssueController</code>, we'll also need to make a few changes to our <code class="literal">protected/models/Update.php</code> model. These changes will allow us to automatically assign the correct owner of an update to the update and help us send an e-mail to the user when an update is added to the issue.</p><p>Once again in our model, we have a property that we can use to find out whether this update came from an e-mail or not:</p><div class="informalexample"><pre class="programlisting">public $isEmailUpdate = false;</pre></div><p>In this model, we're using this attribute to determine whether an e-mail should be sent to the user or not as we shouldn't notify the user of an update that they submitted.</p><p>Additionally, we'll need to make two updates to our model methods:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first update we need to make to our model is in the <code class="literal">beforeSave()</code> method. If the user is logged in, the author of that update should be assigned to that user. Have a look at the following code:<div class="informalexample"><pre class="programlisting">public function beforeSave()
{
   // Allow the author_id to be set, but reset it to the logged in user-&gt;id if it isn't set
   if ($this-&gt;author_id == NULL)
      $this-&gt;author_id = Yii::app()-&gt;user-&gt;id;

   if ($this-&gt;update == '')
      return false;

   return parent::beforeSave();
}</pre></div></li><li class="listitem">Then we should update our <code class="literal">afterSave()</code> method so that the e-mail is sent to the user in the appropriate instances:<div class="informalexample"><pre class="programlisting">public function afterSave()
{
   // If the issue was created by the currently logged in user, or this is an email update, don't send an email
   $issue = Issue::model()-&gt;findByPk($this-&gt;issue_id);

   // Don't send an email if the customer provides an update, if this came from email, or the status of the issue is resolved
   if ($issue-&gt;customer_id == Yii::app()-&gt;user-&gt;id || $this-&gt;isEmailUpdate || $issue-&gt;status_id == 5)
      return parent::afterSave();

   // If this is a NEW issue, send the user an email with the detais
   $user = User::model()-&gt;findByPk($issue-&gt;customer_id);

   // Init the SendGrid object and the Email Object
   $sendgrid = new SendGrid(Yii::app()-&gt;params['sendgrid']['username'], Yii::app()-&gt;params['sendgrid']['password']);
   $email    = new SendGrid\Email();

   $email-&gt;setFrom(Yii::app()-&gt;params['sendgrid']['from'])
        -&gt;addTo($user-&gt;email)
        -&gt;setSubject("[Issue #$issue-&gt;id] $this-&gt;subject | Issue has been updated")
        -&gt;setText('Issue has been updated')
        -&gt;setHtml(Yii::app()-&gt;controller-&gt;renderPartial('//email/updated', array('issue' =&gt; $issue, 'update' =&gt; $this, 'user' =&gt; $user), true));

   $sendgrid-&gt;send($email);

   return parent::afterSave();
}</pre></div></li></ol></div></div><div class="section" title="Showing issues that belong to the user"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Showing issues that belong to the user</h2></div></div></div><p>With the<a id="id358" class="indexterm"/> updates to our models completed, we can now start working on the <code class="literal">IssueController</code>. The first method that we should implement is <code class="literal">actionIndex()</code>, which will show the logged-in users all the unresolved issues currently assigned to them:</p><div class="informalexample"><pre class="programlisting">public function actionIndex()
{
    $issues = new Issue('search');
    $issues-&gt;unsetAttributes();

    if(isset($_GET['Issue']))
        $issues-&gt;attributes=$_GET['Issue'];

    // Don't search resolved issues
    $issues-&gt;status_id = '&lt;5';

    $issues-&gt;customer_id = Yii::app()-&gt;user-&gt;id;

    $this-&gt;render('index', array(
      'issues' =&gt; $issues
   ));
}</pre></div><p>Then<a id="id359" class="indexterm"/> in our <code class="literal">index.php</code> file at<code class="literal"> views/issue/</code>, we can reuse the partial view that we created earlier to display all of these issues:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;My Issues&lt;/h3&gt;
&lt;?php $this-&gt;renderPartial('issues', array('model' =&gt; $issues)); ?&gt;</pre></div></div><div class="section" title="Searching for issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Searching for issues</h2></div></div></div><p>The <a id="id360" class="indexterm"/>next method we need to implement is <a id="id361" class="indexterm"/>the <code class="literal">actionSearch()</code> method that will allow us to search for issues either by the issue ID or by a keyword in the title or description. To do this, we'll create a search view that will post to our action with the search parameters. If that <code class="literal">$_GET</code> parameter is numeric, and we can find an issue with that ID, we'll immediately redirect to it. Otherwise, we'll use the <code class="literal">Issue::search()</code> method that we modified earlier to search through all the issues in our database. Our controller action will look as follows:</p><div class="informalexample"><pre class="programlisting">public function actionSearch()
{
   $issues = new Issue('search');
   $issues-&gt;status_id = '&lt;5';

   if (isset($_GET['issue']))
   {
      if (is_numeric($_GET['issue']))
      {
         $issue = Issue::model()-&gt;findByPk($_GET['issue']);
         if ($issue != NULL)
            $this-&gt;redirect($this-&gt;createUrl('issue/update', array('id' =&gt; $issue-&gt;id)));
      }

      $issues-&gt;title = $_GET['issue'];
      $issues-&gt;description = $_GET['issue'];
   }
   
   $this-&gt;render('search', array(
      'issues' =&gt; $issues
   ));
}</pre></div><p>Then, our <code class="literal">search.php</code> file<a id="id362" class="indexterm"/> at <code class="literal">views/issue/</code> will look as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;Search for Issues&lt;/h3&gt;
&lt;?php $form=$this-&gt;beginWidget('CActiveForm', array(
   'id'=&gt;'project-form',
   'method' =&gt; 'get',
   'htmlOptions' =&gt; array(
      'class' =&gt; 'form-horizontal',
      'role' =&gt; 'form',
   )
)); ?&gt;
   &lt;p&gt;Search for issues...&lt;/p&gt;
   &lt;div class="form-group"&gt;
      &lt;?php echo CHtml::textField('issue', isset($_GET['issue']) ? $_GET['issue'] : NULL, array('class' =&gt; 'form-control', 'placeholder' =&gt; 'Search for Issues by ID, Title, or Description...')); ?&gt;
   &lt;/div&gt;
   &lt;div class="row buttons"&gt;
      &lt;?php echo CHtml::submitButton('Search', array('class' =&gt; 'btn btn-primary pull-right col-md-offset-1')); ?&gt;
   &lt;/div&gt;
&lt;?php $this-&gt;endWidget(); ?&gt;

&lt;?php if ($issues != NULL): ?&gt;
   &lt;?php $this-&gt;renderPartial('issues', array('model' =&gt; $issues)); ?&gt;
&lt;?php endif; ?&gt;</pre></div></div><div class="section" title="Creating issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec72"/>Creating issues</h2></div></div></div><p>Next, we'll need to implement an action and view to create new issues. Since new issues won't<a id="id363" class="indexterm"/> have updates associated with them, create and update actions will need to be separate. For the <code class="literal">actionCreate()</code> method, we'll simply populate the values from the <code class="literal">$_POST</code> parameters:</p><div class="informalexample"><pre class="programlisting">public function actionCreate()
{
   $issue = new Issue;
   if (isset($_POST['Issue']))
   {
      $issue-&gt;attributes = $_POST['Issue'];
      
      if ($issue-&gt;save())
      {
         Yii::app()-&gt;user-&gt;setFlash('success', "Issue #{$issue-&gt;id} has successfully been created");
         $this-&gt;redirect($this-&gt;createUrl('issue/update', array('id' =&gt; $issue-&gt;id)));
      }
   }

   $this-&gt;render('create', array(
      'model' =&gt; $issue
   ));
}</pre></div><p>Then, copy the <code class="literal">create.php</code> file located at <code class="literal">views/issue/</code> from our project resources folder into your project.</p><p>Within this controller action is another reference to our <code class="literal">CWebUser</code> object. In previous chapters, every time we made a change to a database item from our controllers, we either reloaded the page or redirected to a new page. To make our applications more user friendly, we can set flash messages that will only show up once. To set these messages, we'll use the <code class="literal">setFlash()</code> method of our <code class="literal">CWebUser</code> object:</p><div class="informalexample"><pre class="programlisting">Yii::app()-&gt;user-&gt;setFlash($key, $value);</pre></div><p>Then, from within our views, we can see whether a flash message exists for a particular key using <code class="literal">hasFlash()</code>:</p><div class="informalexample"><pre class="programlisting">Yii::app()-&gt;user-&gt;hasFlash($key);</pre></div><p>Then, display that flash message using <code class="literal">getFlash()</code>:</p><div class="informalexample"><pre class="programlisting">Yii::app()-&gt;user-&gt;getFlash($key);</pre></div><p>Alternatively, if we don't want to look for flash messages in a particular view, we can tell our<a id="id364" class="indexterm"/> layout to find all flash messages and display them. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">foreach (Yii::app()-&gt;user-&gt;getFlashes() as $key =&gt; $message)
   echo '&lt;div class="flash-' . $key . '"&gt;' . $message . "&lt;/div&gt;";</pre></div></div><div class="section" title="Viewing and updating issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec73"/>Viewing and updating issues</h2></div></div></div><p>Now that <a id="id365" class="indexterm"/>we can create and find issues, we<a id="id366" class="indexterm"/> need to be able to view and update them. For this action, we'll be consolidating both functions into a single action. Because users of different roles will be accessing this action, we need to adjust it so that users of a particular role can only perform certain tasks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we should generate a <code class="literal">loadModel()</code> method:<div class="informalexample"><pre class="programlisting">private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(400, 'Missing ID');

   $model = Issue::model()-&gt;findByPk($id);

   if ($model == NULL)
      throw new CHttpException(404, 'No issue with that ID was found');

   return $model;
}</pre></div></li><li class="listitem">Then we'll need to create the <code class="literal">actionUpdate()</code> function. We'll start by loading the model with that ID and creating a new <code class="literal">Update</code> object in case an update is sent over <code class="literal">$_POST</code>:<div class="informalexample"><pre class="programlisting">public function actionUpdate($id=NULL)
{
   // Load the necessary models
   $issue = $this-&gt;loadModel($id);
   $update = new Update;
   $update-&gt;update = NULL;
   $customer_id = $issue-&gt;customer_id;</pre></div></li><li class="listitem">Then, we should make sure that only administrators, supporters, or the issue owner <a id="id367" class="indexterm"/>can view the issue. Have a<a id="id368" class="indexterm"/> look at the following code:<div class="informalexample"><pre class="programlisting">if (Yii::app()-&gt;user-&gt;role == 1)
{
   if (Yii::app()-&gt;user-&gt;id != $customer_id)
      throw new CHttpException(403, 'You do not have permission to view this issue');
}</pre></div></li><li class="listitem">Then, we should allow administrators and supporters to modify the <code class="literal">Issue</code> object itself as follows:<div class="informalexample"><pre class="programlisting">if (Yii::app()-&gt;user-&gt;role &gt;= 2)
{
   if (isset($_POST['Issue']))
   {
      $issue-&gt;attributes = $_POST['Issue'];
      if ($issue-&gt;save())
         Yii::app()-&gt;user-&gt;setFlash('success', "Issue #{$issue-&gt;id} has successfully been updated");
   }
}</pre></div></li><li class="listitem">Then, allow any user to submit an update as follows:<div class="informalexample"><pre class="programlisting">if (isset($_POST['Update']))
{
   $update-&gt;issue_id = $issue-&gt;id;
   $update-&gt;update = $_POST['Update']['update'];
   if ($update-&gt;save())
   {
      Yii::app()-&gt;user-&gt;setFlash('success', "Issue #{$issue-&gt;id} has successfully been updated");
      $this-&gt;redirect($this-&gt;createUrl('issue/update', array('id' =&gt; $issue-&gt;id)));
   }
}</pre></div></li><li class="listitem">Finally, we should render the view. When rendering the view, we are also going to pass down a <code class="literal">CMarkdownParser</code> object. Rendering the issue updates in Markdown syntax will allow us to easily have access to many different formatting features, such as line breaks, text styles, and quoting features. Rendering the updates in Markdown will also give us protection against simple XSS attacks, such as JavaScript injection attempts:<div class="informalexample"><pre class="programlisting">   $this-&gt;render('update', array(
      'issue' =&gt; $issue,
      'update' =&gt; $update,
      'md' =&gt; new CMarkdownParser
   ));
}</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>You can<a id="id369" class="indexterm"/> learn more about the Markdown syntax and how to use Markdown at <a class="ulink" href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>.</p></div></div><p>Finally <a id="id370" class="indexterm"/>we'll create an update view that will<a id="id371" class="indexterm"/> allow us to see the issue and updates from different roles. Copy the <code class="literal">update.php</code> view located at <code class="literal">view/issue/</code> from the project resources folder into your project.</p></div><div class="section" title="E-mail views"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec74"/>E-mail views</h2></div></div></div><p>Before we can start using our application, we need to create three different e-mail views, one for<a id="id372" class="indexterm"/> each type of e-mail that will be sent to the user. These views will contain information about the issue itself and information about whatever change was applied to it. It will also contain special formatting that will enable the user to reply to that e-mail and allow us to understand what parts of the e-mail should be included as an update:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first view that we should create is a created view. This view will have information about a newly created issue. It will also contain a special marker that our application will be able to identify so that only the user's response is included in the update. Create a new file in <code class="literal">views/email/created.php</code>, and add the following code:<div class="informalexample"><pre class="programlisting">--------------- DO NOT EDIT BELOW THIS LINE ---------------
&lt;div class="email"&gt;
   Hello &lt;?php echo $user-&gt;name; ?&gt;,&lt;br /&gt;&lt;br /&gt;

   This is a notification that a new issue (#&lt;?php echo $issue-&gt;id; ?&gt;) has been opened for you. A member of our team will review this shortly.&lt;br /&gt;&lt;br /&gt;

   As a reminder, here is the description of the issue you provided:&lt;br /&gt;&lt;br /&gt;

   &lt;strong&gt;&lt;?php echo $issue-&gt;title; ?&gt;&lt;/strong&gt;
   &lt;blockquote&gt;
      &lt;?php echo $issue-&gt;description; ?&gt;
   &lt;/blockquote&gt;

   &lt;br /&gt;&lt;br /&gt;

   To add additional information to this issue, you may either reply to this email, or login &lt;?php echo CHtml::link('here', $this-&gt;createAbsoluteUrl('issue/update', array('id' =&gt; $issue-&gt;id))); ?&gt;.
   &lt;br /&gt;&lt;br /&gt;

   Thank you,&lt;br /&gt;
   Issue Tracking System
&lt;/div&gt;</pre></div></li><li class="listitem">Then <a id="id373" class="indexterm"/>create an updated view in <code class="literal">views/email/updated.php</code>. This e-mail will tell the user that their issue was updated and will contain the update that was applied to the issue. Once again, it will contain a special marker so that if the user replies to our e-mail, we know what content to include in the update and what content to ignore:<div class="informalexample"><pre class="programlisting">--------------- DO NOT EDIT BELOW THIS LINE ---------------
&lt;div class="email"&gt;
   Hello &lt;?php echo $user-&gt;name; ?&gt;,&lt;br /&gt;&lt;br /&gt;

   This is a notification that a new issue (#&lt;?php echo $issue-&gt;id; ?&gt;) has been updated with the following message:&lt;br /&gt;&lt;br /&gt;

   &lt;blockquote&gt;
      &lt;?php echo $update-&gt;update; ?&gt;
   &lt;/blockquote&gt;
   &lt;hr /&gt;
   As a reminder, here is the description of the issue you provided:&lt;br /&gt;&lt;br /&gt;
   &lt;strong&gt;&lt;?php echo $issue-&gt;title; ?&gt;&lt;/strong&gt;
   &lt;blockquote&gt;
      &lt;?php echo $issue-&gt;description; ?&gt;
   &lt;/blockquote&gt;
   &lt;br /&gt;&lt;br /&gt;
   To reply to this issue you may either reply to this email, or login &lt;?php echo CHtml::link('here', $this-&gt;createAbsoluteUrl('issue/update', array('id' =&gt; $issue-&gt;id))); ?&gt;.
   &lt;br /&gt;&lt;br /&gt;
   Thank you,&lt;br /&gt;
   Issue Tracking System
&lt;/div&gt;</pre></div></li><li class="listitem">Finally, we <a id="id374" class="indexterm"/>need to create a view to notify the user that their issue has been resolved. Open <code class="literal">resolved.php</code>  at <code class="literal">views/email/</code> and add the following:<div class="informalexample"><pre class="programlisting">--------------- DO NOT EDIT BELOW THIS LINE ---------------
&lt;div class="email"&gt;
   Hello &lt;?php echo $user-&gt;name; ?&gt;,&lt;br /&gt;&lt;br /&gt;

   This is a notification that a new issue (#&lt;?php echo $issue-&gt;id; ?&gt;) has been resolved.&lt;br /&gt;&lt;br /&gt;

   Thank you,&lt;br /&gt;
   Issue Tracking System
&lt;/div&gt;</pre></div></li></ol></div></div><div class="section" title="Testing our application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec75"/>Testing our application</h2></div></div></div><p>Since<a id="id375" class="indexterm"/> the domain <code class="literal">example.com</code> is not a valid domain to send e-mails, create for yourself a new user with a valid e-mail address, log in as that user, and create several issues. For each issue you create, a new e-mail will be sent to you notifying you that the issue has been created. Moreover, updating an issue as any supporter or administrator will notify the current supporter of the issue via e-mail with the provided update. Finally, if you have a supporter or an administrator resolve an issue, then you will receive an e-mail to notify you that the issue was resolved.</p><p>Once you have verified that all the functionality is working, we can move on to handling and parsing inbound e-mails with SendGrid.</p></div></div>
<div class="section" title="Handling inbound e-mail parsing"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Handling inbound e-mail parsing</h1></div></div></div><p>While<a id="id376" class="indexterm"/> there are many different ways of handling inbound e-mail parsing, one of the easiest ways is to send that e-mail to a third party, who will then parse the contents for us, and send it as a <code class="literal">$_POST</code> request to an open endpoint in our application. This is exactly what SendGrid will do for us. However, before we can start using SendGrid, we need to make a couple of changes to our DNS server for our domain and to our SendGrid account.</p><div class="section" title="Sending e-mails to SendGrid"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec76"/>Sending e-mails to SendGrid</h2></div></div></div><p>To <a id="id377" class="indexterm"/>direct our e-mails to SendGrid <a id="id378" class="indexterm"/>in order to pass, we first need to make a change to our DNS settings. In keeping with our example domain <code class="literal">chapter4.example.com</code>, we first need to log in to our DNS host and add a new Mail Exchange (MX) record to our subdomain. Specifically, we need to add an MX record with a priority of <code class="literal">10</code> to <code class="literal">mx.sendgrid.net</code>. In most DNS systems, that record would look as follows:</p><div class="informalexample"><pre class="programlisting">chapter4     IN     MX     10     mx.sendgrid.net.</pre></div><p>Alternatively, if you're using a service like CloudFlare to handle your DNS, your entry may look as follows:</p><div class="mediaobject"><img src="graphics/7734OS_04_02.jpg" alt="Sending e-mails to SendGrid"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Depending upon your DNS provider, DNS settings may take up to 24 to 48 hours to propagate. Before leaving this step, verify that the MX record was added and propagated using either a command-line tool, such as a DIG or a free, online web tool.</p></div></div></div><div class="section" title="Adjusting SendGrid Parse settings"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec77"/>Adjusting SendGrid Parse settings</h2></div></div></div><p>Once <a id="id379" class="indexterm"/>you've <a id="id380" class="indexterm"/>updated your DNS settings, you then need to update your SendGrid Parse API settings so that SendGrid knows where to send your <a id="id381" class="indexterm"/>e-mails. Navigate to <a class="ulink" href="http://www.sendgrid.com/developer/reply">www.sendgrid.com/developer/reply</a>, and then fill in the parse settings<a id="id382" class="indexterm"/> page as follows and submit the record:</p><div class="mediaobject"><img src="graphics/7734OS_04_03.jpg" alt="Adjusting SendGrid Parse settings"/></div><p>Once you've added the record, you should see confirmation at the bottom of the page. Once this has been completed, you can now send e-mails to <code class="literal">*@chapter4.example.com</code>, and SendGrid will parse it and forward it onto your <code class="literal">actionEmailUpdate()</code> method of our <code class="literal">IssueController</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>You <a id="id383" class="indexterm"/>can read more about the SendGrid Parse API webhook<a id="id384" class="indexterm"/> at <a class="ulink" href="http://sendgrid.com/docs/API_Reference/Webhooks/parse.html">http://sendgrid.com/docs/API_Reference/Webhooks/parse.html</a>.</p></div></div></div><div class="section" title="Creating and updating issues over e-mail"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec78"/>Creating and updating issues over e-mail</h2></div></div></div><p>Now that <a id="id385" class="indexterm"/>our DNS settings and <a id="id386" class="indexterm"/>SendGrid account are set, we need to add the necessary functionality to both create and update issues over e-mail. Then, the action that we create will also create new users in our database if a new user creates an issue for us:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">With SendGrid configured, our <code class="literal">actionEmailUpdate()</code> method will receive a <code class="literal">POST</code> request from SendGrid anytime someone sends an e-mail to our application.. All the information that we will need to work with will be in a <code class="literal">$_POST</code> variable once it arrives. However, some of this information may not be readily accessible. For instance, the e-mail address will reach us as <code class="literal">Example User" &lt;test@chapter4.example.com&gt;"</code> which isn't very useful to us. To make this e-mail more useful, we need to create a utility function that will break this information apart for us in our <code class="literal">IssueController</code> as follows:<div class="informalexample"><pre class="programlisting">private function _parseEmailAddress($raw)
{
   $name = "";
   $email = trim($raw, " '\"");

   if (preg_match("/^(.*)&lt;(.*)&gt;.*$/", $raw, $matches))
   {
      array_shift($matches);
      $name = trim($matches[0], " '\"");
      $email = trim($matches[1], " '\"");
   }

   return array(
      "name" =&gt; $name,
      "email" =&gt; $email,
      "full" =&gt; $name . " &lt;" . $email . "&gt;"
   );
}</pre></div></li><li class="listitem">Then, within our <code class="literal">actionEmailUpdate()</code> method, we'll begin by retrieving this information:<div class="informalexample"><pre class="programlisting">$from = $this-&gt;_parseEmailAddress($_POST['from']);
   $subject = $_POST['subject'];</pre></div></li><li class="listitem">Then, we'll need to search for the subject of the e-mail for the ID of our issue. In the e-mails we're sending out, the subject has the format <code class="literal">[Issue #&lt;ID&gt;] &lt;info&gt;</code>. Have a look at the following code:<div class="informalexample"><pre class="programlisting">$idString = NULL;
preg_match('/\[Issue #.*?\]/', $subject, $idString);
$id = str_replace(']', '', str_replace('[Issue #', '', (isset($idString[0]) ? $idString[0] : 0)));</pre></div></li><li class="listitem">Then, we <a id="id387" class="indexterm"/>need to find a<a id="id388" class="indexterm"/> user in our system with that e-mail address. If we are unable to find that user, we need to create a new user with that e-mail address:<div class="informalexample"><pre class="programlisting">$user = User::model()-&gt;findByAttributes(array('email' =&gt; $from['email']));

if ($user == NULL)
{
   $user = new User;
   $user-&gt;attributes = array(
      'name' =&gt; $from['name'],
      'email' =&gt; $from['email'],
      'password' =&gt; 'changeme9',
      'role_id' =&gt; 1
   );

   if (!$user-&gt;save())
      return true;
}</pre></div></li><li class="listitem">Then, we need to locate an issue with that ID. If an issue with that ID doesn't exist, or the issue doesn't belong to the user we're working with, we should create a new issue rather than updating an existing one:<div class="informalexample"><pre class="programlisting">$issue = Issue::model()-&gt;findByPk($id);

// If the user or ID are NULL, or that email address doesn't belong to that customer, Create a new issue
if ($issue == NULL || $id == NULL || $issue-&gt;customer_id != $user-&gt;id)
{
   // create the issue, save it, then return - no further work needs to be done.
   $issue = new Issue;
   $issue-&gt;_isEmailCreate = true;

   $issue-&gt;attributes = array(
      'title' =&gt; $subject,
      'description' =&gt; $_POST['text'],
      'customer_id' =&gt; $user-&gt;id
   );

   $issue-&gt;save();
   return true;
}</pre></div></li><li class="listitem">Finally, if we have a good user and issue, we should apply the update. At this point, we'll <a id="id389" class="indexterm"/>split the<a id="id390" class="indexterm"/> contents of our e-mail along our special marker and only include the contents above it in our update. This reduces the amount of data we need to store in our database and keeps our interface looking clean and clear of e-mail clutter:<div class="informalexample"><pre class="programlisting">$body = explode('--------------- DO NOT EDIT BELOW THIS LINE ---------------', $_POST['text']);
$body = $body[0];

// Set the update
$update = new Update;
$update-&gt;author_id = $user-&gt;id;
$update-&gt;issue_id = $issue-&gt;id;
$update-&gt;update = $body;
$update-&gt;isEmailUpdate = true;

$update-&gt;save();
return true;</pre></div></li></ol></div><p>Now that our application can receive e-mails, reply to one of the e-mails you received earlier. After a short while, you will be able to navigate to that issue and see that your update sent over e-mail was indeed applied. Alternatively, you can send a new e-mail to your application. In a short while, a new issue will be created, and the application will respond to you with an e-mail notifying you that a new issue was created.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>We covered a lot of ground in this chapter! We went over creating and managing users from within our application, sending e-mails about certain events, and how to receive e-mails and incorporate that information into our application. We also added roles to our users and made our application only respond to certain actions of users with a particular role.</p><p>Before continuing, think of ways in which you could improve this application, and try to implement them. For example, you could change it so that the access rules expressions are answered by the models rather than hard-coded values. Alternatively, you could add new statuses to the application and send out different e-mails when those statuses change. Think of all the ways you could make this application better to use for the end user.</p><p>After adding some new features, go through the Yii documentation located at <a class="ulink" href="http://www.yiiframework.com/doc/">http://www.yiiframework.com/doc/</a> to help you better understand some of the methods and properties we used in this chapter.</p><p>In the next chapter, we will be expanding upon our knowledge to implement a micro blogging platform similar to Twitter. To our micro-blogging platform, we'll add a registration and password reset system for our end users and allow our end users to manage their own accounts. Once you're ready, turn the page and get ready to dive deeper into Yii!</p></div></body></html>