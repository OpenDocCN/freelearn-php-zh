<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;More OOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. More OOP</h1></div></div></div><p>The previous chapter creates a basis for us to kick-start OOP with PHP. This chapter will deal with some advanced features in more detail. For example, we will learn about class information functions by which we can investigate details about any class. We will then learn about some handy object-oriented information functions and also one of the great new features in PHP5, which is exception handling. </p><p>This chapter will also introduce us to the Iterators for easier array access. To store any object for later use, we need to use a special feature in OOP which is called serialization, we will also learn about this here. As a whole this chapter will strengthen your base in OOP. </p><div class="section" title="Class Information Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Class Information Functions</h1></div></div></div><a id="id76" class="indexterm"/><p>If you want to investigate and gather more information regarding any class, these functions will be your light in the dark. These functions can retrieve almost any information regarding a class. But there is an improved version of these functions and is introduced as a totally new set of API in PHP5. That API is called <span class="strong"><strong>reflection</strong></span>. We will learn about reflection API in Chapter 5.</p><div class="section" title="Checking if a Class Already Exists"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec09"/>Checking if a Class Already Exists</h2></div></div></div><a id="id77" class="indexterm"/><p>When you need to check if any class already exists in the current scope, you can use a function named <code class="literal">class_exists()</code>. Have a look at the following example:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("../ch2/class.emailer.php");
echo class_exists("Emailer");
//returns true otherwise false if doesn't exist
?&gt;</pre></div><p>The best way to use the <code class="literal">class_exists()</code> function is to first check if a class is already available. You can then create an instance of that class if it is available. This will make your code much more stable. </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("../ch2/class.emailer.php");
if( class_exists("Emailer"))
{
  $emailer = new Emailer("hasin@pageflakes.com");
}
else 
{
  die("A necessary class is not found");
}
?&gt;</pre></div></div><div class="section" title="Finding Currently Loaded Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Finding Currently Loaded Classes</h2></div></div></div><a id="id78" class="indexterm"/><p>In some cases you may need to investigate which classes are loaded in the current scope. You can do it pretty fine with the <code class="literal">get_declared_classes()</code> function. This function will return an array with currently available classes. </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("../ch2/class.emailer.php");
print_r(get_declared_classes());
?&gt;</pre></div><p>You will see a list of currently available classes on the screen. </p></div><div class="section" title="Finding out if Methods and Properties Exists"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Finding out if Methods and Properties Exists</h2></div></div></div><a id="id79" class="indexterm"/><a id="id80" class="indexterm"/><p>To find out if a property and/or a method is available inside the class, you can use the <code class="literal">method_exists()</code> and <code class="literal">property_exists()</code> functions. Please note, these functions will return true only if the properties and methods are defined in public scope. </p></div><div class="section" title="Checking the Type of Class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Checking the Type of Class</h2></div></div></div><a id="id81" class="indexterm"/><p>There is a function called <code class="literal">is_a()</code> that you can use to check the type of class. Take a look at the following example: </p><div class="informalexample"><pre class="programlisting">&lt;?
class ParentClass
{
}

class ChildClass extends ParentClass 
{
}

$cc = new ChildClass();
if  (is_a($cc,"ChildClass")) echo "It's a ChildClass Type Object";
echo "\n";
if  (is_a($cc,"ParentClass")) echo "It's also a ParentClass Type 
Object";

?&gt;</pre></div><p>You will find the output as follows: </p><div class="informalexample"><pre class="programlisting">Its a ChildClass Type Object
Its also a ParentClass Type Object</pre></div></div><div class="section" title="Finding Out the Class Name"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Finding Out the Class Name </h2></div></div></div><a id="id82" class="indexterm"/><p>In the previous example we checked the class if it's a type of a known one. What if we need to get the original name of the class itself? No worry, we have the <code class="literal">get_class()</code> function to help us.</p><div class="informalexample"><pre class="programlisting">&lt;?
class ParentClass
{
}
class ChildClass extends ParentClass 
{	
}

$cc = new ChildClass();
echo get_class($cc)
?&gt;</pre></div><p>As an output, you should get <code class="literal">ChildClass</code>. Now take a look at the following example, which "brjann" enlisted as unexpected behaviour in the PHP manual user note section. </p><div class="informalexample"><pre class="programlisting">&lt;?
class ParentClass 
{
  public function getClass()
{
    echo get_class(); //using "no $this"
  }
}
class Child extends ParentClass 
{
}
$obj = new Child();
$obj-&gt;getClass(); //outputs "ParentClass"
?&gt;</pre></div><p>If you run this code, you will see <code class="literal">ParentClass</code> as the output. But why? You are calling the method for a <code class="literal">Child</code>. Is it unexpected? Well, no. Take a serious look at the code. Though the <code class="literal">Child</code> extended the <code class="literal">ParentClass</code> object, it didn't override the method <code class="literal">getClass()</code>. So the method is still running under a <code class="literal">ParentClass</code> scope. That's why it returns the result <code class="literal">ParentClass</code>. </p><p>So what actually happened to the following piece of code? Why is it returning <code class="literal">Child</code>?</p><div class="informalexample"><pre class="programlisting">&lt;?
class ParentClass {
  public function getClass(){
    echo get_class($this); //using "$this"
  }
}
class Child extends ParentClass {
}
$obj = new Child();
$obj-&gt;getClass(); //outputs "child"
?&gt;</pre></div><a id="id83" class="indexterm"/><p>In the <code class="literal">ParentClass</code> object, the <code class="literal">get_class()</code> function returns <code class="literal">$this</code> object, which clearly holds a reference of <code class="literal">Child</code> class. That's why you are getting <code class="literal">Child</code> as your output. </p></div></div></div>
<div class="section" title="Exception Handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Exception Handling</h1></div></div></div><a id="id84" class="indexterm"/><a id="id85" class="indexterm"/><p>One of the most improved features in PHP5 is that you can now use exceptions, like other OOP languages out there. PHP5 introduces these exception objects to simplify your error management. </p><p>Let's see how these exceptions occur and how to handle them. Take a look at the following class, which simply connects to a PostgreSQL server. In the case of failing to connect to the server, let's see what it usually returns:</p><div class="informalexample"><pre class="programlisting">&lt;?
//class.db.php
class db
{
  function connect()
  {
    pg_connect("somehost","username","password");
  }
}

$db = new db();
$db-&gt;connect();
?&gt;</pre></div><p>The output is the following. </p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Warning&lt;/b&gt;: pg_connect() [&lt;a href='function.pg-connect'&gt;
function.pg-connect&lt;/a&gt;]: Unable to connect to PostgreSQL 
server: could not translate host name "somehost" to address: 
Unknown host in &lt;b&gt;C:\OOP with PHP5\Codes\ch3\exception1.php&lt;/b&gt; 
on line &lt;b&gt;6&lt;/b&gt;&lt;br /&gt;</pre></div><p>How are you going to handle it in PHP4? Generally, by using something similar to the following shown below: </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.db.php
error_reporting(E_ALL - E_WARNING);
class db
{
  function connect()
  {
    if (!pg_connect("somehost","username","password")) return false;
  }
}

$db = new db();

if (!$db-&gt;connect()) echo "Falied to connect to PostgreSQL Server";
?&gt; </pre></div><p>Now let's see how we can solve it with exception. </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.db.php
error_reporting(E_ALL - E_WARNING);
class db
{
  function connect()
  {
    if (!pg_connect("host=localhost password=pass user=username 
                    dbname=db")) throw new Exception("Cannot connect 
                    to the database");
  }
}

$db = new db();
try {
  $db-&gt;connect();
}
catch (Exception $e)
{
  print_r($e);
}

?&gt;</pre></div><a id="id86" class="indexterm"/><a id="id87" class="indexterm"/><p>The output will be something like this:</p><div class="informalexample"><pre class="programlisting">Exception Object
(
  [message:protected] =&gt; Cannot connect to the database
  [string:private] =&gt; 
  [code:protected] =&gt; 0
  [file:protected] =&gt; C:\OOP with PHP5\Codes\ch3\exception1.php
  [line:protected] =&gt; 8
  [trace:private] =&gt; Array
    (
      [0] =&gt; Array
        (
          [file] =&gt; C:\OOP with PHP5\Codes\ch3\exception1.php
          [line] =&gt; 14
          [function] =&gt; connect
          [class] =&gt; db
          [type] =&gt; -&gt;
          [args] =&gt; Array
             (
              )

        )

      [1] =&gt; Array
        (
          [file] =&gt; C:\Program Files\Zend\ZendStudio-
                                       5.2.0\bin\php5\dummy.php
          [line] =&gt; 1
          [args] =&gt; Array
            (
              [0] =&gt; C:\OOP with PHP5\Codes\ch3\exception1.php
            )

          [function] =&gt; include
        )

    )

)</pre></div><p>So you get a lot of things in this exception class. You can catch all the errors using this try-catch block. You can use try-catch inside another try-catch block. Take a look at the following example. Here we developed two of our own exception objects to make the error handling more structured.<a id="id88" class="indexterm"/>
<a id="id89" class="indexterm"/> </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("PGSQLConnectionException.class.php");
include_once("PGSQLQueryException.class.php");
error_reporting(0);
class DAL
{
  public $connection;
  public $result;
  public function connect($ConnectionString)
  {
    $this-&gt;connection = pg_connect($ConnectionString);

    if ($this-&gt;connection==false)
    {
      throw new PGSQLConnectionException($this-&gt;connection);
    }
  }

  public function execute($query)
  {
    $this-&gt;result = pg_query($this-&gt;connection,$query);

    if (!is_resource($this-&gt;result))
    {
      throw new PGSQLQueryException($this-&gt;connection);
    }

    //else do the necessary works
  }
}

$db = new DAL();
try{
  $db-&gt;connect("dbname=golpo user=postgres2");
  try{
    $db-&gt;execute("select * from abc");
  }
  catch (Exception $queryexception)
  {
    echo $queryexception-&gt;getMessage();
  }
}
catch(Exception $connectionexception)
{
  echo $connectionexception-&gt;getMessage();
}
?&gt;</pre></div><p>Now, if the code cannot connect to DB, it catches the error and displays that <span class="strong"><strong>Sorry, couldn't connect to PostgreSQL server</strong></span>: message. If the connection is successful but the problem is in the query, it will display the proper information. If you check the code, then you will find that for a connection failure we throw a <code class="literal">PGSQLConnectionException</code> object, and for a query failure we just throw a <code class="literal">PGSQLQueryException</code> object. We can custom develop these objects by extending the core Exception class of PHP5. Let's take a look at the code. The first one is the <code class="literal">PGSQLConnectionException</code> class. </p><div class="informalexample"><pre class="programlisting">&lt;?
Class PGSQLConnectionException extends Exception
{

  public function __construct()
  {  $message = "Sorry, couldn't connect to postgresql server:";
     parent::__construct($message, 0000);
  }
}
?&gt;</pre></div><a id="id90" class="indexterm"/><a id="id91" class="indexterm"/><p>And here comes <code class="literal">PGSQLQueryException</code> class</p><div class="informalexample"><pre class="programlisting">&lt;?
Class PGSQLQueryException extends Exception
{
  public function __construct($connection)
  {
    parent::__construct(pg_last_error($connection),0);
  }
}
?&gt;</pre></div><p>That's it!</p><div class="section" title="Collecting all PHP Errors as Exception"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Collecting all PHP Errors as Exception</h2></div></div></div><a id="id92" class="indexterm"/><p>If you want to collect all PHP errors (except the FATAL errors) as exception, you can use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php
function exceptions_error_handler($severity, $message, 
       $filename, $lineno) { 
          throw new ErrorException($message, 0, $severity, 
          $filename, $lineno); 
       }
set_error_handler('exceptions_error_handler');
?&gt;</pre></div><p>The credit of the above code piece goes to <code class="email">&lt;<a class="email" href="mailto:fjoggen@gmail.com">fjoggen@gmail.com</a>&gt;</code>, which I collected from the PHP manual user notes. <a id="id93" class="indexterm"/>
</p></div></div>
<div class="section" title="Iterators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Iterators</h1></div></div></div><p>An <a id="id94" class="indexterm"/>
<a id="id95" class="indexterm"/>Iterator is a new command introduced in PHP5 to help traversing through any object. Check out the following example to understand what Iterators are actually used for. In PHP4 you could iterate through an array as shown in the following example, using <code class="literal">foreach</code> statement: </p><div class="informalexample"><pre class="programlisting">&lt;?
foreach($anyarray as $key=&gt;$val)
{
  //do something
}
?&gt;</pre></div><p>You could also perform a <code class="literal">foreach</code> operation over an object, let's take a look at the following example.</p><div class="informalexample"><pre class="programlisting">&lt;?
class EmailValidator
{
  public $emails;
  public $validemails;
}

$ev = new EmailValidator();
foreach($ev as $key=&gt;$val)
{
  echo $key."&lt;br/&gt;";
}
?&gt;</pre></div><p>This code will output the following:</p><div class="informalexample"><pre class="programlisting">emails
validemails</pre></div><p>Please note that it can only iterate through the public properties. But what if we want just the valid email addresses as the output? Well, in PHP5 that's possible by implementing the <code class="literal">Iterator</code> and <code class="literal">IteratorAggregator</code> interface. Let us see using the following example. In this example, we create a <code class="literal">QueryIterator</code>, which can iterate through a valid PostgreSQL query result and returns one row per Iteration. </p><div class="informalexample"><pre class="programlisting">&lt;?
class QueryIterator implements Iterator
{
  private $result;
  private $connection;
  private $data;
  private $key=0;
  private $valid;

  function __construct($dbname, $user, $password)
  {
    $this-&gt;connection = pg_connect("dbname={$dbname} user={$user}");
  }

  public function exceute($query)
  {
    $this-&gt;result = pg_query($this-&gt;connection,$query);
     if (pg_num_rows($this-&gt;result)&gt;0)
    $this-&gt;next();
  }

  public function rewind() {}

  public function current() {
    return $this-&gt;data;
  }

  public function key() {
    return $this-&gt;key;
  }

  public function next() {
    if ($this-&gt;data = pg_fetch_assoc($this-&gt;result))
    {
      $this-&gt;valid = true;
      $this-&gt;key+=1;
    }
    else 
    $this-&gt;valid = false;
  }

  public function valid() {
    return $this-&gt;valid;
  }
}
?&gt;</pre></div><a id="id96" class="indexterm"/><a id="id97" class="indexterm"/><p>Let's see the code in action. </p><div class="informalexample"><pre class="programlisting">&lt;?
$qi= new QueryIterator("golpo","postgres2","");
$qi-&gt;exceute("select name, email from users");
while ($qi-&gt;valid())
{
  print_r($qi-&gt;current());
  $qi-&gt;next();
}
?&gt;</pre></div><p>For example, if there are two records in our table <code class="literal">users</code>, you will get the following output: </p><div class="informalexample"><pre class="programlisting">Array
(
  [name] =&gt; Afif
  [email] =&gt; mayflower@phpxperts.net
)
Array
(
  [name] =&gt; Ayesha
  [email] =&gt; florence@phpxperts.net
)</pre></div><p>Quite handy, don't you think?</p></div>
<div class="section" title="ArrayObject"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>ArrayObject</h1></div></div></div><a id="id98" class="indexterm"/><a id="id99" class="indexterm"/><p>Another useful object introduced in PHP5 is <code class="literal">ArrayObject</code> that wraps the regular PHP array and gives it an OO flavor. You can programmatically access the array in an OO style. You can create an <code class="literal">ArrayObject</code> object by simply passing to <code class="literal">ArrayObject</code> constructor. <code class="literal">ArrayObject</code> has the following useful methods:</p><p>
<span class="strong"><strong>append()</strong></span>
</p><p>This method can add any value at the end of the collection. </p><p>
<span class="strong"><strong>getIterator()</strong></span>
</p><p>This method simply creates an <code class="literal">Iterator</code> object and return so that you can perform iteration using an Iterator style. This is a very useful method for getting an <code class="literal">Iterator</code> object from any array. </p><p>
<span class="strong"><strong>offsetExists()</strong></span>
</p><p>This method can determine whether the specified offset exists in the collection.</p><p>
<span class="strong"><strong>offsetGet()</strong></span>
</p><p>This method returns the value for specified offset.</p><p>
<span class="strong"><strong>offsetSet()</strong></span>
</p><p>Like <code class="literal">offsetGet()</code>, this method can set any value to the specified <code class="literal">index()</code>.</p><p>
<span class="strong"><strong>offsetUnset()</strong></span>
</p><p>This method can unset the element at specified index. </p><p>Let us see some examples of <code class="literal">ArrayObject</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?
$users = new ArrayObject(array("hasin"=&gt;"hasin@pageflakes.com",
   "afif"=&gt;"mayflower@phpxperts.net",
   "ayesha"=&gt;"florence@pageflakes.net"));
$iterator = $users-&gt;getIterator();
while ($iterator-&gt;valid())
{
  echo "{$iterator-&gt;key()}'s Email address is 
         {$iterator-&gt;current()}\n";
         $iterator-&gt;next();
}
?&gt; </pre></div></div>
<div class="section" title="Array to Object"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Array to Object</h1></div></div></div><a id="id100" class="indexterm"/><a id="id101" class="indexterm"/><p>We can access any array element by its key, for example <code class="literal">$array[$key]</code>. However, what if we want to access it like this, <code class="literal">$array-&gt;key</code> style? It's very easy and we can do it by extending <code class="literal">ArrayObject</code>. Let's see using the following example. </p><div class="informalexample"><pre class="programlisting">&lt;?
class ArrayToObject extends ArrayObject
{
  public function __get($key)
  {
    return $this[$key];
  }

  public function __set($key,$val)
  {
    $this[$key] = $val;
  }
}
?&gt;</pre></div><p>Now let's see it in action:</p><div class="informalexample"><pre class="programlisting">&lt;?
$users = new ArrayToObject(array("hasin"=&gt;"hasin@pageflakes.com",
   "afif"=&gt;"mayflower@phpxperts.net",
   "ayesha"=&gt;"florence@pageflakes.net"));

echo $users-&gt;afif;
?&gt;</pre></div><p>It will output the email address associated with the key <code class="literal">afif</code>, as follows:</p><div class="informalexample"><pre class="programlisting">mayflower@phpxperts.net</pre></div><p>This example may come in handy if you want to convert the array of any known format into an object.</p></div>
<div class="section" title="Accessing Objects in Array Style"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Accessing Objects in Array Style</h1></div></div></div><a id="id102" class="indexterm"/><p>In the previous section we learned how to access any array in OO style. What if we want to access any object in array style? Well, PHP provides that facility too. All you have to do is implement <code class="literal">ArrayAccess</code> interface in your class. </p><p>
<code class="literal">ArrayAccess</code> interface has four methods, which you must implement in the class. The methods are <code class="literal">offsetExists()</code>, <code class="literal">offsetGet()</code>, <code class="literal">offsetSet()</code>, <code class="literal">offsetUnset()</code>. Let's create a sample class implementing <code class="literal">ArrayAccess</code> interface. <a id="id103" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php

class users implements ArrayAccess 
{
  private $users;

    public function __construct() 
{
        $this-&gt;users = array();
    }

    public function offsetExists($key) 
{
        return isset($this-&gt;users[$key]);
    }

    public function offsetGet($key) 
{
        return $this-&gt;users[$key];
    }

    public function offsetSet($key, $value) 
{
        $this-&gt;users[$key] = $value;
    }

    public function offsetUnset($key) 
{
        unset($this-&gt;users[$key]);
    }
}

$users = new users();
$users['afif']="mayflower@phpxperts.net";
$users['hasin']="hasin@pageflakes.com";
$users['ayesha']="florence@phpxperts.net";

echo $users['afif']
?&gt;</pre></div><p>The output will be <code class="literal">mayflower@phpxperts.net</code>.</p></div>
<div class="section" title="Serialization"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Serialization</h1></div></div></div><a id="id104" class="indexterm"/><p>So far we have learned how we can create objects and manipulate them. Now what happens if you need to save any state of the object and retrieve it later exactly in that form? In PHP, you can achieve this functionality by serialization. </p><p>Serialization is a process of persisting the state of an object in any location, either physical files or in variables. To retrieve the state of that object, another process is used which is called "unserialization". You can serialize any object using <code class="literal">serialize()</code> function. Let's see how we can serialize an object:</p><div class="informalexample"><pre class="programlisting">&lt;?
class SampleObject
{
  public $var1;
  private $var2;
  protected $var3;
  static $var4;

  public function __construct()
  {
    $this-&gt;var1 = "Value One";
    $this-&gt;var2 = "Value Two";
    $this-&gt;var3 = "Value Three";
    SampleObject::$var4 = "Value Four";
  }

}

$so = new SampleObject();
$serializedso =serialize($so);
file_put_contents("text.txt",$serializedso);
echo $serializedso;
?&gt;</pre></div><p>The script will output a string, which PHP understands how to unserialize. </p><p>Now it's time to retrieve our serialized object and convert into a usable PHP object. Please bear in mind that the class file you are unserializng must be loaded first. </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.sampleobject.php");
$serializedcontent = file_get_contents("text.txt");
$unserializedcontent = unserialize($serializedcontent);
print_r($unserializedcontent);
?&gt;</pre></div><a id="id105" class="indexterm"/><p>What do you think the output will be? Take a look:</p><div class="informalexample"><pre class="programlisting">SampleObject Object
(
  [var1] =&gt; Value One
  [var2:private] =&gt; Value Two
  [var3:protected] =&gt; Value Three
)</pre></div><p>It's now a regular PHP object; the same as it was just before serializing. Please note that all variables keep their values, which were set before serializing, except the static one. You cannot save the state of a static variable by serializing. </p><p>What if we didn't include the class file by <code class="literal">include_once</code> before unserializing? Let's just comment out the first line, which includes the class file and then run the example code. You will get the following output: </p><div class="informalexample"><pre class="programlisting">__PHP_Incomplete_Class Object
(
  [__PHP_Incomplete_Class_Name] =&gt; SampleObject
  [var1] =&gt; Value One
  [var2:private] =&gt; Value Two
  [var3:protected] =&gt; Value Three
)</pre></div><p>At this point, you can't use it as the object again. <a id="id106" class="indexterm"/>
</p><div class="section" title="Magic Methods in Serialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Magic Methods in Serialization</h2></div></div></div><a id="id107" class="indexterm"/><p>Do you remember we overloaded properties and methods using some magic methods like <code class="literal">__get</code>, <code class="literal">__set</code>, and <code class="literal">__call</code>? For serialization, you are allowed to use some magic methods to hook into the process of serialization. PHP5 provides two magic methods for this purpose named <code class="literal">__sleep</code> and <code class="literal">__awake</code>. These methods give some control over the whole process. </p><p>Let's develop all the static variables of a process using these magic methods, which we generally won't be able to do without a hack. Normally it's not possible to serialize the values of any static variables and return the object in same state with that static variable. However, we can make it happen, let's see the following code. </p><div class="informalexample"><pre class="programlisting">&lt;?
class SampleObject
{
  public $var1;
  private $var2;
  protected $var3;
  public static $var4;

  private $staticvars = array();

  public function __construct()
  {
    $this-&gt;var1 = "Value One";
    $this-&gt;var2 = "Value Two";
    $this-&gt;var3 = "Value Three";
    SampleObject::$var4 = "Value Four";
  }

  public function __sleep()
  {

    $vars = get_class_vars(get_class($this));
    foreach($vars as $key=&gt;$val)
    {
      if (!empty($val))
      $this-&gt;staticvars[$key]=$val;
    }
    return array_keys( get_object_vars( $this ) );
  }

  public function __wakeup()
  {
    foreach ($this-&gt;staticvars as $key=&gt;$val){
      $prop = new ReflectionProperty(get_class($this), $key);
      $prop-&gt;setValue(get_class($this), $val);
    }
    $this-&gt;staticvars=array();
  }

}
?&gt;</pre></div><p>What happens if we serialize the object, write it into the file and then later retrieve the state? You will find the static value still persists the last value assigned to it. </p><p>Let's discuss the code for a second. The <code class="literal">__sleep</code> function performs all the necessary operations. It searches for public properties with values and stores the variable's name when it finds one into a private variable <code class="literal">staticvars</code>. Later when someone tries to unserialize the object, it retrieves each value from the <code class="literal">staticvars</code> and writes it to the property itself. Pretty handy, don't you agree?</p><p>You will notice that we haven't used a hack, with the exception of the theoretical capability of the <code class="literal">__sleep()</code> and <code class="literal">__wakeup()</code> functions. So what are these two functions useful for? Where can we use them in practice? This is actually fairly simple. For example, if your class has any resource object associated with it (a live DB connection, a reference of an open file) in <code class="literal">sleep</code> function you can properly close them as they are no longer usable when someone unserializes it. Please remember that in an unserialized state someone may still use those resource pointers. So in the <code class="literal">__wakeup()</code> function you can open those DB connections, or file pointers, to give it an exact shape as it was before. Let us see using the following example:</p><div class="informalexample"><pre class="programlisting">&lt;?
class ResourceObject
{
  private $resource;
  private $dsn;
  public function __construct($dsn)
  {
    $this-&gt;dsn = $dsn;
    $this-&gt;resource = pg_connect($this-&gt;dsn);
  }

  public function __sleep()
  {
    pg_close($this-&gt;resource);
    return array_keys( get_object_vars( $this ) );
  }

  public function __wakeup()
  {
    $this-&gt;resource = pg_connect($this-&gt;dsn);
  }
}
?&gt;</pre></div><a id="id108" class="indexterm"/><p>This object, when being serialized, will free the memory that was consumed by <code class="literal">$resource</code>. Later, when it will be unserialized, it will open the connection again using the DSN string. So now, after unserialization, everything is as it was before. That's the clue!</p></div></div>
<div class="section" title="Object Cloning"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Object Cloning</h1></div></div></div><a id="id109" class="indexterm"/><a id="id110" class="indexterm"/><p>PHP5 introduces a new approach while copying objects from one into another, which is quite different to PHP4. In PHP4 when you copy an object to another, it performs a deep copy. This means it just makes a completely new object, which retains the properties of the object being copied. However, changing anything in the new object will not affect the main object. </p><p>PHP5 is different from this in the way it makes a shallow copy when you copy an object from one to another. To clearly understand the situation, you need to understand the following code. </p><div class="informalexample"><pre class="programlisting">&lt;?
$sample1 = new StdClass();
$sample1-&gt;name = "Hasin";
$sample2 = $sample1;
$sample2-&gt;name = "Afif";
echo $sample1-&gt;name;
?&gt; </pre></div><p>If you run the above code in PHP5 can you guess what will you get as the result? <code class="literal">Hasin</code> or <code class="literal">Afif</code>? Surprisingly, the output is <code class="literal">Afif</code>. As I mentioned earlier, PHP5 performs a shallow copy while copying an object; <code class="literal">$sample2</code> is just a reference to <code class="literal">$sample1</code>. So whenever you perform any change to <code class="literal">$sample1</code> object or <code class="literal">$sample2</code> object, it will affect both. </p><p>In PHP4 it works differently; it will output <code class="literal">Hasin</code>, as both are different from each other. </p><p>If you want to perform the same in PHP5, you have to use the <code class="literal">clone</code> keyword. Let's take a look at the following example</p><div class="informalexample"><pre class="programlisting">&lt;?
$sample1 = new stdClass();
$sample1-&gt;name = "Hasin";
$sample2 =clone $sample1;
$sample2-&gt;name = "Afif";
echo $sample1-&gt;name;
?&gt;</pre></div><p>The output now would be <code class="literal">Hasin</code>.</p></div>
<div class="section" title="Autoloading Classes or Classes on Demand"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Autoloading Classes or Classes on Demand</h1></div></div></div><a id="id111" class="indexterm"/><p>While working with big projects, another very good practice is loading classes only when you need it. That means you shouldn't over consume the memory by loading unnecessary classes all the time.</p><p>In our examples, you have seen that we include the original class file before making them available in our script. Unless you include the class file, you can't create an instance of it. PHP5 introduces a feature to auto load your class files so that you don't have to bother to include them manually. Usually, this feature is helpful in big applications where you have to deal with lots of classes and don't want to bother to call <code class="literal">include</code> all the time. Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">&lt;?
function __autoload($class)
{
  include_once("class.{$class}.php");
}

$s = new Emailer("hasin@somewherein.net");
?&gt;</pre></div><p>When you execute the script shown above, note that we didn't include any class file for the <code class="literal">Emailer</code> class. Because of this <code class="literal">__autoload()</code> function, PHP5 will auto load a file named <code class="literal">class.emailer.php</code> in the current directory. So you need not worry about including the class yourself. <a id="id112" class="indexterm"/>
</p></div>
<div class="section" title="Method Chaining"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Method Chaining</h1></div></div></div><a id="id113" class="indexterm"/><a id="id114" class="indexterm"/><p>Method chaining is another process introduced in PHP5 by which you can directly access the methods and attributes of an object when it is returned by any function. It is something like the following:</p><div class="informalexample"><pre class="programlisting">$SomeObject-&gt;getObjectOne()-&gt;getObjectTwo()-&gt;callMethodOfObjectTwo();</pre></div><p>The above code means that <code class="literal">$someObject</code> class has a method named <code class="literal">getObjectOne()</code> which returns an object named <code class="literal">$objectOne</code>. This <code class="literal">$objectOne</code> has another method named <code class="literal">getObjectTwo()</code> which returns an object whose method is called by the final call. </p><p>So who is going to use such things? Let's take a look at the following code; it makes you understand beautifully how a method chain can be used in real life: </p><div class="informalexample"><pre class="programlisting">$dbManager-&gt;select("id","email")-&gt;from("user")-&gt;where("id=1")
                                        -&gt;limit(1)-&gt;result();</pre></div><p>Do you find the above code meaningful and readable? The code returns a row from the <code class="literal">user</code> table containing the ID and email where the value of ID is equal to 1. Have you ever wondered how to design such a DB manager object? Let's take a look at this great example below: </p><div class="informalexample"><pre class="programlisting">&lt;?
class DBManager
{
  private $selectables = array();
  private $table;
  private $whereClause;
  private $limit;

  public function select()
  {
    $this-&gt;selectables=func_get_args();
    return $this;
  }

  public function from($table)
  {
    $this-&gt;table = $table;
    return $this;
  }

  public function where($clause)
  {
    $this-&gt;whereClause = $clause;
    return $this;
  }

  public function limit($limit)
  {
    $this-&gt;limit = $limit;
    return $this;
  }

  public function result()
  {
    $query = "SELECT ".join(",",$this-&gt;selectables)." FROM 
                                           {$this-&gt;table}";
    if (!empty($this-&gt;whereClause))
    $query .= " WHERE {$this-&gt;whereClause}";

    if (!empty($this-&gt;limit))
    $query .= " LIMIT {$this-&gt;limit}";	

    echo "The generated Query is : \n".$query;
  }

}
$db= new DBManager();
$db-&gt;select("id","name")-&gt;from("users")-&gt;where("id=1")-&gt;
                                       limit(1)-&gt;result();
?&gt;</pre></div><p>The output is:</p><div class="informalexample"><pre class="programlisting">The generated Query is : 
SELECT id,name FROM users WHERE id=1 LIMIT 1</pre></div><a id="id115" class="indexterm"/><a id="id116" class="indexterm"/><p>The class automatically builds the query. So how does this work? Well, in PHP5 you can return objects; so using this feature we return the object on each method that we want to be part of the chain. Now, it's just a matter of a few minutes to execute that query and return the result. Surprising, you can also execute the following code which generates the same result: </p><div class="informalexample"><pre class="programlisting">$db-&gt;from("users")-&gt;select("id","name")-&gt;limit(1)-&gt;where("id=1")
                                                     -&gt;result();</pre></div><p>This is the beauty of PHP5; it's amazingly powerful. </p></div>
<div class="section" title="Life Cycle of an Object in PHP and Object Caching"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Life Cycle of an Object in PHP and Object Caching</h1></div></div></div><a id="id117" class="indexterm"/><a id="id118" class="indexterm"/><p>If you are interested in understanding the lifecycle of an object, then an object is live until the script ends. As soon as the script finishes executing, any object instantiated by this script also dies. Unlike web tier in Java, there is no global or application-level scope in PHP. So you cannot persist the object normally. If you want to persist an object, you can serialize it and later unserialize it when necessary. Manually handling this serialization and unserialization process may seem boring sometimes. It would really be nice to store the object somewhere and retrieve it later (well, the same as serialization/unserialization process, but with more flexibly). </p><a id="id119" class="indexterm"/><p>There is some object caching technology available for PHP, which is very efficient indeed. The most successful among them is <span class="strong"><strong>memcached</strong></span>.<a id="id120" class="indexterm"/> PHP has an extension to memcached API, which is available to download from PECL. Memcached runs as a standalone server and caches objects directly into memory. Memcached server listens in a port. PHP memcached API understands how to talk to the memcached server, hence it saves and retrieves an object with its help. In this section we will demonstrate how to work with memcached, but we will not go into too much detail.</p><p>You can download the memcached server from <a class="ulink" href="http://danga.com/memcached">http://danga.com/memcached</a>. If you are using Linux you have to compile it by your own. With some distro you will find the memcached package. You will find a <code class="literal">win32</code> binary version of memcached 1.2.1 server from <a class="ulink" href="http://jehiah.cz/projects/memcached-win32/">http://jehiah.cz/projects/memcached-win32/</a> which is developed by kronuz (<code class="email">&lt;<a class="email" href="mailto:kronuz@users.sourceforge.net">kronuz@users.sourceforge.net</a>&gt;</code>). After getting the executable, give the following command in the console. It will start the memcached server. </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>memcached –d install</strong></span></pre></div><p>This will install memcached as a service.<a id="id121" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>memcached –d start </strong></span></pre></div><p>This will start the daemon/service.</p><p>Now it's time to store some objects into the memcached server and retrieve it. </p><div class="informalexample"><pre class="programlisting">&lt;?
$memcache = new Memcache;

$memcache-&gt;connect('localhost', 11211) or die ("Could not connect");

$tmp_object = new stdClass;
$tmp_object-&gt;str_attr = 'test';
$tmp_object-&gt;int_attr = 12364;

$memcache-&gt;set('obj', $tmp_object, false, 60*5) or die ("Failed to save data at the server");
?&gt;</pre></div><p>When you execute the code above, the memcache server saves the object <code class="literal">$tmp_object</code> against the key <code class="literal">obj</code> for five minutes. After five minutes this object will not exist. By this time, if you need to restore that object, you can execute the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?
$memcache = new Memcache;
$memcache-&gt;connect('localhost', 11211) or die ("Could not connect");

$newobj = $memcache-&gt;get('obj');
?&gt;</pre></div><p>That's it. Memcache is so popular that it has Perl, Python, Ruby, Java, and Dot Net, and C port. <a id="id122" class="indexterm"/>
</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter we learned how to use some advanced OOP concepts in PHP. We learned how to retrieve information from any object, and learned about ArrayAccess, ArrayObject, Iterators, and some other native objects which simplifies the life of a developer. Another very important thing we learned from this chapter is Exception Handling. </p><p>In next chapter we will learn about design patterns and how to use them in PHP. Untill then, happy exploring…</p></div></body></html>