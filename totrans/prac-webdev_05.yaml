- en: Chapter 5. PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed client-side programming using JavaScript
    as the language. This chapter is all about **server-side programming** and the
    programming language we will learn for that purpose is PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP was originally developed by Rasmus Lerdorf, who called it **Personal Home
    Pages**. Today the three letters refer to **PHP: Hypertext Preprocessor**. It
    is a full-featured programming language that is interpreted, not compiled (we
    now know what that means).'
  prefs: []
  type: TYPE_NORMAL
- en: When, in that 6 month class I keep mentioning, we finally reached the PHP part,
    I was expecting a new and unexplored topic, a new frontier. I was prepared to,
    as a programmer, boldly go where no one—me in particular—had gone before. Instead,
    all elements were utterly familiar to me.
  prefs: []
  type: TYPE_NORMAL
- en: When I explain this experience to people, I compare it to running into a girlfriend
    you have not seen in 15 years and realizing you still like her. Strangely enough,
    something similar happened to me last year, and this time it was a girlfriend.
  prefs: []
  type: TYPE_NORMAL
- en: That familiarity with PHP involved not just the language itself, being similar
    to the C programming language, but, in particular, all the functions that come
    with the language. Many of those are the same utility functions that you find
    in the standard C library for UNIX systems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, PHP, like JavaScript, is a language that is interpreted. So,
    we need an interpreter first. With JavaScript, that was easy, the interpreter
    is inside any browser. With PHP, you need a separate program to interpret your
    code. Assume you have such a program called `php` on your computer (I have one
    on my Mac) where you can type in PHP code or supply a file with the code inside
    it, then we could write our first program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first, not so useful, example: using your favorite editor, create a file
    called `first.php` and enter the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the strings `<?php` and `?>`. Typically, PHP code is placed in between
    those strings. So both examples really contain only a single line of PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you have that `php` program on your computer (don't panic if you don't,
    you are not going to need one), you can type `php first.php` and you will see
    `Hello, world` appear on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: As PHP is a full-featured language, you could use it this way to create standalone
    programs for your projects. However, this is not why you bought this book and
    this is not how we are going to teach you the language.
  prefs: []
  type: TYPE_NORMAL
- en: Our first real PHP program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use PHP to create **dynamic webpages**. In simple terms, these
    are HTML pages with PHP code embedded in them. The PHP interpreter will take your
    code, interpret it, and replace it with the result of your program. The resulting
    modified HTML document will have no more PHP code in it; that pure HTML file will
    be what the browser sees. Here is a good example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the interpreter has done its thing, the contents of this file will have
    transformed into the exact lines of our first example in [Chapter 2](ch02.html
    "Chapter 2. HTML"), *HTML*, and this will be what the browser sees.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the line with the `<title>` tag, we embedded PHP code inside
    the HTML tag. You can do that. The second line with PHP code in our example is
    part of a PHP statement block. That makes it a lot more readable.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can this be useful? You are pulling my leg. We are three chapters further
    down the road and all you can do is tell me how to write `Hello, world` in ten
    different ways?
  prefs: []
  type: TYPE_NORMAL
- en: Of course PHP is going to be useful. The PHP code embedded in your HTML file
    could be a while loop (yes, PHP has that too) that pulls data out of a file or
    a database, and constructs clean HTML code using that data to generate multiple
    pages of HTML. All of this can be done with just a few lines of PHP code. But
    how do we get it to work? Well, we first need to set ourselves up with a thing
    or two.
  prefs: []
  type: TYPE_NORMAL
- en: PHP and web hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything has been done by the browser, except for loading files down
    from the server into the browser, which the **web server** does at the browser's
    request - an HTTP request to be more precise.
  prefs: []
  type: TYPE_NORMAL
- en: The file that needs to be downloaded is determined by the URL, the address of
    a web page the user has typed in, or the link they clicked on; in this case, `www.sitename.com/demo.html`
    (or `demo.php`).
  prefs: []
  type: TYPE_NORMAL
- en: Once that HTML file is loaded into the browser, everything in it is read, including
    `<img>`, `<script>`, and `<link>` tags with `href` and `src` attributes. The browser
    will come up with a list of more files it needs and turn into a little Oliver
    Twist by going *Please Server, can I have some more?*
  prefs: []
  type: TYPE_NORMAL
- en: Once all of that code is present, the browser knows what to do with it and renders
    the web page on the user's computer or tablet. The `script` and `style` tags help
    you to distinguish which part is plain HTML and which is CSS or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how the hell did all these files get up there, and where is *there*? They
    got there, and back down, because behind the name `www.sitename.com`, there is
    a computer and a service called **web hosting**.
  prefs: []
  type: TYPE_NORMAL
- en: Web hosting 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been holding off explaining this part because so far, we could use our
    examples without needing a true website. With PHP, this is going to be different,
    so this is the place to outline which steps you need to take if you want a website
    of your own that people can visit.
  prefs: []
  type: TYPE_NORMAL
- en: Domain name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need is a name for your website. What you really need is
    a **domain name**. Websites cannot have any name you pick and no two websites
    can have the same name. So, if you want to call your plumbing company's site `joe.theplumber.com`,
    that is not going to happen by itself.
  prefs: []
  type: TYPE_NORMAL
- en: You want to use a web hosting company to do that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Web hosting companies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web hosting companies cannot only provide you with a domain name and the registration
    for it, they will also (for a fee) set you up on one of their computers that run
    7 days a week, 24 hours a day - 24/7 in short. That way, everybody in the world
    with an internet connection can visit your website anytime.
  prefs: []
  type: TYPE_NORMAL
- en: Can't I use my own computer to set up my website? Yes, you could, but as soon
    as you shut it down and leave the house, nobody can visit your site, and that
    is not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain name is typically `www.` followed by a string that represents a person
    or a company, and then one of the available endings representing the type of organization
    involved, or the country where it is located. Early on, there were only a few
    of these endings available: `.com`, `.orig`, `.net`, `.gov`, and so on. The list
    is still expanding.'
  prefs: []
  type: TYPE_NORMAL
- en: There are sites you can visit, for example, `dns.be` for domain names in Belgium,
    to see whether the domain name you picked is still available. I went with [paulpwellens.com](http://paulpwellens.com)
    because `paulwellens.com` was already taken by a British rugby player. Well, I
    am neither British, nor a rugby player.
  prefs: []
  type: TYPE_NORMAL
- en: A few years later, after I moved back to Belgium, `paulwellens.be` became available.
    I registered it on my name for a year but then released it as I saw no point in
    having two different names, and worse, two different hosting companies. But you
    can have more than one domain name for a single site, if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your web hosting company has set you up, it will provide you with essential
    information to allow you to transfer your web page files to your website. This
    typically involves:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain name of your website (of course)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An FTP address (an IP address or simply the same domain name)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a folder, for example `public_html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this information, you can transfer the web pages you have developed on
    your computer to your own site using the FTP protocol. This means that you need
    to have a program on your computer or tablet that can handle that. To most UNIX-based
    systems (Mac OS, Linux) that comes naturally, there are cool FTP apps for tablets,
    and FTP clients for Windows exist as well.
  prefs: []
  type: TYPE_NORMAL
- en: FTP stands for **File Transfer Protocol**. Use or install a so-called FTP client
    on your computer or tablet and it will let you transfer files in between it and
    the host, typically one file at a time. FileZilla is something to look into if
    you want to transfer files in bulk. And, to continue with more good news, a lot
    of the cool HTML editors and other tools have FTP built in.
  prefs: []
  type: TYPE_NORMAL
- en: The folder on the server that holds the home page of your site, `public_html`
    in our example, is often referred to as your document root.
  prefs: []
  type: TYPE_NORMAL
- en: Additional server-side services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we just described is exactly what you need, and nothing else, to set up
    a static website. If you plan to use other things, and you do, it is important
    that you check which additional services the web hosting company you consider
    offers. The minimal setup connects you to a Web Server with support for the HTTP
    and the FTP protocol. You also need to make sure that the following is available:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP - check which version of PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL server - also check the version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHPMyAdmin - a tool to easily to manage MySQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most vendors will supply some kind of panel, CPanel being a popular one, to
    access and configure these services. The servers themselves typically run Linux
    or MacOS as the operating system, Apache as the web server, and support MySQL
    and PHP. In `www` land, this combination is often referred to as the LAMP stack.
    How about having a LAMP of your own?
  prefs: []
  type: TYPE_NORMAL
- en: PHP development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is nothing basically wrong with the setup we just described, but it holds
    one major inconvenience: your website will always look like work in progress.
    With this environment, the only way you can test the result of your work is by
    uploading your changes to your website using FTP and being a visitor of your own
    site. There is likely going to be something wrong from time to time; even the
    tiniest typo can do a great deal of damage.'
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, you want a local development environment on your computer.
    This allows you to only update your website periodically, when milestones of stable,
    tested code have arrived. In the meantime, you can develop new features, experiment,
    learn new things, and all of that good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to develop your PHP application and test it locally you need:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer running MacOS, Linux, or Windows (at the time of writing, there was
    not a viable PHP environment on a tablet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Apache web server with PHP support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good code editor, a full blown **Integrated Development Environment** (**IDE**),
    or something in between
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I personally like Adobe Dreamweaver. It does everything I need and not a single
    thing more. It lets me look at my pages/applications and test them locally, FTP
    to the server with a mouse click, and its editor recognizes HTML tags, CSS properties,
    and JavaScript and PHP keywords. But it is not free. There are several IDEs that
    are free.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, you should have all the files that make up your website stored in
    a local directory, your local document root (for example, `$HOME/Sites/mysitename`),
    and do your testing locally using a URL that begins with `localhost`. On a Mac,
    that would be `http://localhost/~username/sitename/filename.php`
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to the language itself. Just as we did with JavaScript, we
    will go through all the available ingredients in PHP that you can use to cook
    up a PHP program. To avoid duplication, we will not repeat what is the same in
    both languages, but point you to the differences. Where appropriate, we will do
    so in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: PHP as a web development language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now we are ready to use PHP to write web programs, run and test them locally,
    and place them on a server that your web hosting company manages; in brief—to
    develop and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: We focus on the use of PHP to generate web pages dynamically. After the PHP
    code is interpreted, what remains is HTML, which you should think of as strings
    of text that are generated on the server and rendered by the client. The data
    that is used to generate these pages either comes out of an external file or a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: When invited to, the visitor of your site will interact with it. There may be
    a form to fill out, a button to click, a selection to be made out of several choices,
    and so on. The result of that intervention by the visitor needs to somehow make
    its way back to the server and be processed there, and all can be thought of as
    strings of text again. After processing, it either goes back to the client to
    inform the visitor and/or it needs to be stored somewhere. That somewhere is going
    to also be a file on the server or database.
  prefs: []
  type: TYPE_NORMAL
- en: Although I keep claiming, and I mean it, that this book is not to be used as
    a reference, we include a short reference on things related to strings and files,
    as you need them everyday. Databases are the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Variables, values, operators, and expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, you could say that in PHP, every variable will cost you a dollar, because
    every variable name has to begin with a `$`, a dollar sign. If this little word
    game helps us remember the important difference between JavaScript and PHP variables,
    we will all save quite a few dollars over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is no `var` keyword in PHP to declare variables. You can just start using
    them when you initialize them. Just like in JavaScript, there are no strict types,
    you can use numeric and string values; PHP also uses functions, and the operators
    are the same unless you want to glue strings together. However, the story on the
    scope of variables is different.
  prefs: []
  type: TYPE_NORMAL
- en: Scope of variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As is the case in JavaScript, the scope of a variable, the area inside a program
    where the variable is known and can be accessed, is a very important thing to
    understand. Compared to JavaScript, different keywords are used. I already mentioned
    that there is no `var` keyword. Instead, we have two new ones—global and static.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Local variables can be accessed inside the function they are declared. It''s
    like in JavaScript, but without the `var` keyword. Let''s, once more, produce
    the number 3 in at least three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This simply produces `3`. If we were to use the variable `$c` outside the function
    in an `echo` statement, it would produce nothing. Yes, you heard me, nothing -
    not undefined, not 0, no error message, just nothing, but in a way, it is the
    empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. This time it does not even calculate `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember the JavaScript example where we declared a variable outside a function
    and initialized it, and then modified its value by mistake inside a function?
    The declaration outside the function turned that variable into a global, without
    using that word in the program. Variables with the same name inside a function
    would hide those globals, but only if they were explicitly declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, we have the opposite. When we declare variables outside a function
    and then introduce a function in our code where we try to access them, they will
    simply disappear from our program horizon. So, in our example, in the statement
    inside the `nothing()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`$a` and `$b` are undeclared variables, and when used inside an expression,
    their value usually becomes the empty string. That is why nothing will appear
    on the screen when we use the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous line however will produce the number `0`. This is because it is
    the result of an expression containing the `+` operator. The operands of the expression
    are first converted to numeric values, so we end up adding nothing to nothing,
    which is the same as adding zero to zero and the result still being zero. So,
    how do we get access inside the function to `$a` and `$b` that we declared outside?
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is a common practice in many programming languages to take a frequently
    used sequence of statements and place them together in a reusable function, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the programming language, a function may technically not be called
    a function but a subroutine, a procedure, and so on. In a typical web development
    scenario where you need to get data out of a database, such an operation occurs
    frequently, so you want to organize your code that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many times, I was flabbergasted because my perfectly working code stopped working
    once I grouped it inside a function. The reason being: my global `$mysqli` object
    that I initialized outside everything else was not reached inside my function.
    What appeared global to me was not treated as global by PHP. Here is the remedy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not until you use the global keyword inside the function will your *global*
    variables be treated as such.
  prefs: []
  type: TYPE_NORMAL
- en: Another remedy would be to make your `$a` and `$b` variables parameters of the
    function, but I would not recommend this. Using global variables declared as global
    inside the functions where you need them is the global best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is a third kind of variable scope that could be very useful in some programming
    situations. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is probably clear what the intent is. Each time we use this function, we
    want to list the price we pass as an argument, but we expect the article number
    to be one higher as well. However, each time we re-enter the function, the `$article`
    variable is reset to 0\. Now, pay attention to this slightly different version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will provide the intended result because we declared `$article` as a static.
    The line with the keyword static where the variable is assigned its initial value
    is only used once and is ignored from that point forward when the program returns
    to the function. Each time it does that, however, the variable's value from the
    previous visit is remembered. The declaration with the static keyword cannot use
    an expression to initialize the variable, though.
  prefs: []
  type: TYPE_NORMAL
- en: The same selection of expressions and operators that we used in the [Chapter
    4](ch04.html "Chapter 4. JavaScript"), *JavaScript*, are valid in PHP, with one
    major, extremely important, exception.
  prefs: []
  type: TYPE_NORMAL
- en: String operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In JavaScript, you learned that you could not only use the `+` sign to add
    numbers but also to glue strings together - concatenate them, as it is also called.
    In PHP, there is a separate operator to do that. It comes in two flavors, which
    we illustrate here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of your PHP code will be like this: concatenating strings to build up
    the final HTML of a dynamic page. Typically, you would start with a variable,
    initialize it with an opening tag, build up from there until you reach the final
    HTML tag, and then `echo` the whole lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once we start adding attributes to the HTML tags, which require quotes, and
    start using PHP variables that contain dollar signs, it is important to pay careful
    attention, not only to properly use quotes, but also to which quotes to use.
  prefs: []
  type: TYPE_NORMAL
- en: To double quote or to single quote, that is the question
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I am a single quote guy, I start with single quotes for every string, then
    switch to double quotes inside when I need them. What is the difference between
    them? Everything inside single quotes is taken literally, so `$name` reads as
    `$name`. In text between double quotes, variables are evaluated, so `$name` would
    read as whatever the value of that variable is. If you use single quotes and need
    variables, place them outside the quotes and use the concatenation operator to
    compose your text, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use double quotes, the same statement has to look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can leave `$hello` inside as it will be evaluated, but you have to escape
    the double quotes of the class attributes with a backslash to lift its special
    meaning.
  prefs: []
  type: TYPE_NORMAL
- en: My preference is to use single quotes. Just avoid mixing the two methods. On
    the other hand, if you have to work with code from others, make sure you pay attention
    to these, not always subtle, differences.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. JavaScript"), *JavaScript*, we listed
    the principle control flow statements of the language: if, if/else, while, and
    switch. The same are available in PHP with the same syntax. Don''t forget your
    dollars in the variable names, though!'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntax for user-defined functions is also the same as in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: PHP also comes with quite a few functions predefined. Some of these are so useful
    that we decided to include the description and syntax of them. Most of them remind
    me of the C library functions from my UNIX days.
  prefs: []
  type: TYPE_NORMAL
- en: String functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you will be using strings all the time, and will often have to manipulate
    those strings before the final output, it is good to know that PHP comes with
    a nice group of string functions. For your convenience, we include the most useful
    ones here.
  prefs: []
  type: TYPE_NORMAL
- en: strpos()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `strpos()` function finds the position of the first occurrence of a string
    inside another string. It returns the position (starts at `0`, not `1`) or `FALSE`
    when the string is not found. The function takes two arguments: the string to
    look in and the string to look for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: strlen()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`strlen()` returns the length of the string that is the only argument for this
    function or `0` if the string is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: substr()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`substr()` returns a substring of a string. Its typical use is `substr($string,$start,$length)`.
    `$string` is the string used to examine, `$start` is the start position in that
    string, and the optional `$length` is used to specify the length of the string
    we want returned. The default is to the end of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also combine these functions. What would you think the following will
    do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Date functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is hard to imagine a web application that never has to do anything with the
    time or date. Moreover, you will often have the need to use a different date format,
    not only because date formats differ in different parts of the world, 07/19 is
    correct in the US but has to be 19/07 in Europe, dates in databases use a different
    format as well. There are three very convenient functions to help you with that.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a date? Well it can be something that grows in warm countries and
    hangs on trees; I used to buy dates in Death Valley and give them to my friends.
    Date is also another word for an appointment, and people, young and old, can get
    all excited when they go on a date.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, however, the definition of date or time also comes from UNIX, and is
    equal to the number of seconds between now and January 1, 1970 00:00:00 GMT. Here
    are the three functions and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: time()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will return the time of now in seconds. So, in the following code, you
    can store this in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note this will be the date and time on your hosting server, which may
    be sitting in a different part of the world than your computer or that of the
    visitor of your site. You always want to specify what the correct time zone for
    your program is with the `date_default_timezone_set` function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the date and time of your visitor needs to be determined, then that will
    have to happen on the client side, i.o.w. in JavaScript using its `date` object.
  prefs: []
  type: TYPE_NORMAL
- en: date()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `date()` function is used to take a timestamp, for example, a number of
    seconds, or right now by default, and convert it into the format you want. The
    first argument it takes is a format string. Check out a good reference for a complete
    list of items you can use in that string. The most commonly used are `m` for a
    two digit representation of the month, `d` for the day, and `Y` for the four digit
    representation of the year. So, to get today''s date in the European format with
    slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you will, from time to time, need the date and time of right now,
    but it is more common that you need to work with dates in the past (order dates)
    and the future (agenda items). So, how do we calculate the exact number of seconds
    between the time an order was placed and midnight of the last day in 1969? You
    don't. There is one more function to help us with that.
  prefs: []
  type: TYPE_NORMAL
- en: strtotime()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `strtotime()` function will, in turn, return a timestamp based on the string
    that is passed as an argument - for instance, the format coming out of a database.
    Look up a good `strtotime` reference for a list of all valid formats. So, in practice,
    you will often combine the two, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array is a collection of data elements stored in a single variable. In most
    programming languages that I knew before PHP, these elements would be referenced
    by a number, its index, starting at number 0 for the first one. What was a revelation
    to me, during the training I keep mentioning, is a different type of array that
    you can use in PHP: an associative array. More about that very soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric arrays or indexed arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The traditional array with a numeric index can be declared and initialized
    at once, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, we create a `4` element array that contains the first names
    of the Beatles. In the first example, we do it all at once, using the `array()`
    constructor - similar to what we used in JavaScript to create objects. As a matter
    of fact, JavaScript has arrays as well, but we are not going to need them as often
    as we do in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example first tells Mr. PHP that `$beatles` is supposed to be an
    array, and then we start filling it up. The first `$beatles[]="John"` assignment
    is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next ones will initialize the element with an index one higher. However,
    we could have written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then George would have become the value of `$beatles[6]` and Ringo that of `$beatles[7]`.
    It is perfectly okay for there not to be any elements with index 2, 3, 4, and
    5\. People who like to collect things probably hate that. They cannot stand having
    0 and 1 and 6 and 7 of something and not the ones in between. They will probably
    love associative arrays, just like I do.
  prefs: []
  type: TYPE_NORMAL
- en: Associative arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With what is called associative arrays in PHP, an index can be a string rather
    than a number. This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have basically recreated the JavaScript object from the previous chapter
    as an associative array. There is also a way to initialize this all in one statement.
    Its syntax is new and different and introduces key/value pairs. These key/value
    pairs will prove very useful when we start extracting data from a database such
    as MySQL, because we can have MySQL return the data to us as a...guess what...associative
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the single statement version using the special `=>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Cool control statements for associative arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are more control statements than the ones we described in this and the
    previous chapter. The `foreach` statement is extremely useful to loop through
    an array, as you can easily walk through the keys and the values. The following
    statement loops through the array of our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you''ve learned what associative arrays are, we are ready to explain
    some important array variables that we do not create ourselves, but are generated
    by the system`: $_POST` and `$_GET`. The most common scenario where we will have
    access to those is when a visitor of our site fills out a form and pushes a button.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending data back to the server – forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know one way to obtain information from the server, and you will
    learn other ones when we discuss files and databases but let's first reverse it.
    We are going to show you how we can catch and process the information that the
    visitor of our site provided us with.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way is when the visitor fills out fields in a form and submits
    it. This takes us back to [Chapter 2](ch02.html "Chapter 2. HTML"), *HTML*, where
    we discussed the `<form>` and `<input>` elements. The `<form>` tag has more attributes
    than we discussed because we could not explain them at the time. In order to validate
    the user input, for example, to see whether a ZIP code contains only numbers before
    it is sent to the server, we were required to know JavaScript. We are still postponing
    that gig, because there is a very nice jQuery plugin to do that for us. Nor could
    we explain the *action* and *method* attributes, because that involved PHP. The
    time to do that is now.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following chunk of HTML, a relatively simple, partial form
    people can use to sign up for a newsletter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Imagine this code being part of a website where a visitor fills out the form
    and pushes the submit button. The data the user has filled in will be sent to
    the server and can be processed in the PHP module that is supplied with the `action`
    attribute, `process.php` in our example. On the other side, what has been entered
    as a value for the input fields will be stored in an array, named either `$_POST`
    or `$_GET`, depending on which method was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: POST or GET, what should we get?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My personal preference is to always use **POST**, unless I need to use **GET**.
    So, what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `GET` method, the data is passed along with the URL, the address of
    the web page you can see inside the browser. You will see things like: `process.php?first=John&last=Williams&profession=conductor`
    in the URL address bar. The string behind the question mark is called the query
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: With this method, visitors (assuming you gave them instructions) can pass along
    parameters that you can then process in your PHP code. It can also be useful to
    bookmark an interesting article that is part of large website and that you can
    revisit because the creator has added support for that through, for example, a
    query string `article=number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two major downsides of using `GET` is that there is an implementation-dependent
    size limit (could be 1024 bytes) and that everything is visible. This is not how
    you want to display the login and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in general, you want to use the `POST` method; there is virtually no size
    limit, and nothing is revealed in the URL bar of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: $_POST and $_GET arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is quite simple; you can find all the values that were filled out in the
    form in an associative array `$_POST`. In the case of input tags, key/value pairs
    are the values of the `name` attribute and either the `value` attribute or what
    was filled out.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot be sure whether a user has filled out every required field and whether
    we have even done validation on the client side, which we are going to learn in
    a later chapter, there still needs to be validation on the server side. Otherwise,
    we might stuff a file or database with empty or incomplete employee records.
  prefs: []
  type: TYPE_NORMAL
- en: Note the square brackets used in the name attribute for the checkboxes. How
    can they all have the same name? They don't. The result of a user selecting hobbies
    will be an indexed array, which will be `$_POST['hobbies']`.
  prefs: []
  type: TYPE_NORMAL
- en: When processing your `POST` variables, you may want to use the `isset()` function.
    This checks to see whether the variable actually exists, which is different than
    checking to see whether it exists and has a value other than `0` or the empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: What follows is what could be code in our `process.php` module. In it, we introduce,
    `&&`, a logical operator. Think of it as a logical `AND` operator, which returns
    true if both what is on its left and right is true. Its counterpart is `||`, logical
    `OR`, which is true if at least one of its operands is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `count()` function is a function that counts how many elements there are
    in an array, i.o.w. what its size is, and returns it. In our example, this would
    amount to the number of hobbies selected, not the number to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we were dealing with inline CSS or JavaScript or,
    by using the correct tag and attribute, we could reference external files that
    contain our code. No such tags or attributes for our PHP code exist, though. But
    there is a different way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that you have written a bunch of cool functions that you plan on
    reusing in other projects. There is no point in repeating them in between `<?php`
    and `?>` in every `.html` file where you want to use them. It is a far better
    idea to keep them in a separate file that you can reference. We have some PHP
    keywords to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: include, require, and require_once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When used in a PHP statement, all three will do the same. The statement containing
    the keyword followed by a filename will be replaced by the contents of the file.
    There are nuances: if `include` is used and the file is not found, the program
    will continue, whereas if you use `require`, the program will stop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between `require` and `require_once` is that with `require_once`,
    a file that has already been loaded will not be loaded again. Make sure that you
    put your PHP code inside the files you include in between `<?php` and `?>` again.
    In the statement itself you can use parentheses or not, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Regular files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have been using all kinds of files that are stored on the server:
    programs (`.php` and `.js`), stylesheets (`.css`) plain web pages (`.html`), and
    images, used with the `<img>` tag. Those last ones can be in different kinds of
    format: `.png`, `.gif`, `.png`, even `.tiff`. The links in our web pages can reference
    even more files that reside on the server such as all kind of documents in a PDF
    format, or even Word. All of these files will be downloaded for the visitor of
    our site by the browser when needed and will have arrived on that server because
    we put them there, probably using FTP.'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are different kinds of files you could access from within your
    program, as well as creating or modifying new ones. After all, a well-structured
    file can act as a small database. There is a whole family of ready-to-use functions
    to handle files. Most of them take a path to a file, which is nothing else but
    the name itself or a number of directory names separated by a `/` and followed
    by the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those functions then return or use a file handle or file pointer. This is the
    part where I got *deja vu* in the training course. UNIX folks will remember that
    everything is treated like a file: a file proper, a printer, a hard disk, any
    device, and that the basic operations for files are: create, delete, open, close,
    read and write. For true files, text files, or binaries, there was a collection
    of convenient functions, all with a name beginning with an *f*. We rediscover
    these in PHP.'
  prefs: []
  type: TYPE_NORMAL
- en: File functions or f-functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are functions to access existing files or create new ones, to check whether
    files even exist, and are actually files and not directories, and functions to
    read from and write to files. The first one is a little bit of a study; the rest
    is easy.
  prefs: []
  type: TYPE_NORMAL
- en: fopen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no `fcreate!`, so `fopen` is used to either create a file or open an
    existing one, but for what purpose? You have to carefully study the options for
    the second argument of this function, as that determines what happens to your
    file. This can go from creating a new file for writing and an existing one for
    reading to taking a file, destroying what is already in it and starting anew.
    It is also important to realize where the file pointer is pointing to. We will
    give you just three of these options, but they should suffice for 95% of your
    work. Note that we expect the value of `$filename` to be a pathname to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will open the file for reading and the file pointer will point to the beginning
    of the file. This is typically what you want if you want to extract information
    from an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `a` stands for append. So, this will open a file for writing, starting at
    the end. So the end will be where the file pointer points to, and everything you
    write to this file will be added at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is the closest to create. If the file does already exist, it will stay
    intact, and `fopen()` will return `FALSE` rather than a file pointer. Otherwise,
    you just created a file you can write to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most other options, as I mentioned, will potentially destroy the contents of
    your file by truncating it and you do not want that. It is like executing the
    command on a UNIX system - for example: `> filename`'
  prefs: []
  type: TYPE_NORMAL
- en: file_exists(), is_file(), and is_dir()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid surprises, you may want to check whether a file you want to open exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `file_exists()` function returns `TRUE` if `$filename` exists and `FALSE`
    otherwise. It does not tell us whether it is a file or directory. For that purpose,
    we have the functions `is_dir()` and `is_file()`.
  prefs: []
  type: TYPE_NORMAL
- en: fread and fwrite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s assume that we have files open and pointers that point to somewhere
    inside those files where we can read from and write to. For that purpose, we use
    `fread` and `fwrite`. Assume we have `$fpin` to read from and `$fpout` to write
    to; this would be a simple file copy piece of code, using these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument of `fread` is used to specify how many bytes you want to
    read. Of course, we cut it short here and said: let''s read the whole file at
    once. For that purpose, the `filesize()` function comes in handy. With `fwrite`
    you can use the number of bytes you want written as an optional third argument.
    We did not do this in our example, we simply used the string that contains the
    entire file as the second argument.'
  prefs: []
  type: TYPE_NORMAL
- en: One line at a time – fgets()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We used the two previous functions to read the contents of a file all in one
    chunk, and then wrote that chunk to another file. Many files we may use instead
    of a database will have lines of information organized as fixed length records
    that are nothing other than strings or numbers of a fixed length. Wouldn''t it
    be nice if we could handle files line by? Well, we can. `fgets()` is a function
    that returns one line at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The printf family
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `printf` function is the one that gave me that *long time no see* feeling
    in the, by-now notorious, six month class. It is wonderfully powerful, and if
    you master how to compose a good format string, you can create excellent structured
    output in just a few statements.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you will probably discover that `printf`, the PHP version, is
    not going to be used a lot to produce HTML, because HTML is very far away from
    output of fields with a fixed length. First of all, subsequent spaces are stripped
    out, and by the time you see the output, the HTML tags are not shown either.
  prefs: []
  type: TYPE_NORMAL
- en: The instructor never used `printf` for two reasons - one of which is very valid.
    `printf` is a function, whereas `echo` is built in. So, most of the time, what
    you echo will be faster than what you `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why mention it at all? There are functions very similar to `printf` to
    read from or write to strings or files, and having an easy way to deal with a
    structured format is wickedly useful. They are: `sscanf`, `fscanf`, `sprintf`,
    and `fprintf`. What they all have in common is the use of a format string. First,
    we show you the syntax; next, we explain the format string itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of printf family of functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`printf($format, $arg1, $arg2, ... );`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sprintf($string,$format,$arg1,$arg2, ...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sscanf($string, $format, $arg1, $arg2, ...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fprintf($fp, $format, $arg1, $arg2, ...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fscanf($fp,$format, $arg1, $arg2, ...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this syntax, `$fp` represents a file pointer that was previously created
    using `fopen()` and a `$string` variable to contain a string; `$arg1`, `$arg2`
    and so on, are variables to store the data that we retrieve, or hold the data
    that we want to use. `$format` holds the magic on how it is all going to be formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the product name exactly 20 characters, the price 7 digits before,
    and 2 after the floating point. I know, that when displayed in a browser, these
    extra spaces will be reduced to just one, but if `fprintf` was used to write this
    to a file, and we repeat the same statement in a loop, we would end up with a
    file with all the lines nicely lined up. It is all contained by the strings with
    a `%` sign. Typically, you have one extra argument for every `%` string used.
    Here is a selection of what they can contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Format values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | What if you need a `%` sign—use two, only one will be shown |'
  prefs: []
  type: TYPE_TB
- en: '| `%b` | Shows the value as a binary number, that is, only zeroes and ones
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | The character according to the ASCII value |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Shows the value as a decimal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | Octal number |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Hexadecimal number (lowercase letters) |'
  prefs: []
  type: TYPE_TB
- en: '| `%X` | Hexadecimal number (uppercase letters) |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Treat the value as a string. You will use this the most, combined
    with additional format values, which are placed between the `%` and the letter
    (example `%.2f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9] (Specifies the minimum width held of to the variable value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[0-9] (Specifies the number of decimal digits or maximum string length)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the PHP programming language and what it takes
    to get you up and running to use it in your web pages. That was exactly the focus
    of this chapter - not to give you an in-depth coverage of everything that the
    language can do, even in the context of web development. We did not address the
    object-oriented aspects of the language, nor did we cover website-specific things,
    such as cookies and sessions.
  prefs: []
  type: TYPE_NORMAL
- en: We immediately zoomed into what everyone would need in PHP. We ended the chapter
    with a discussion on how to exchange data between client and server and use files
    to store that data. The functions allow us to add structure to these files. There
    can be even more structure in a file if you use a format such as XML, which is
    very similar to HTML. There are cool PHP libraries to deal with those, such as
    **SimpleXML**, which we will discuss in [Chapter 10](ch10.html "Chapter 10. XML
    and JSON"), *XML and JSON*.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you want to go beyond the use of files to hold your data and use
    a true database. The most commonly used database in the world of PHP-based web
    development is MySQL and that is the topic of our next chapter.
  prefs: []
  type: TYPE_NORMAL
