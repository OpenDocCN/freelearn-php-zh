- en: Chapter 5. PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 PHP
- en: In the previous chapter, we discussed client-side programming using JavaScript
    as the language. This chapter is all about **server-side programming** and the
    programming language we will learn for that purpose is PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了使用JavaScript作为语言进行客户端编程。这一章完全是关于**服务器端编程**，我们将学习用于此目的的编程语言是PHP。
- en: 'PHP was originally developed by Rasmus Lerdorf, who called it **Personal Home
    Pages**. Today the three letters refer to **PHP: Hypertext Preprocessor**. It
    is a full-featured programming language that is interpreted, not compiled (we
    now know what that means).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PHP最初是由拉斯马斯·勒德夫（Rasmus Lerdorf）开发的，他将其称为**个人主页**。如今，这三个字母代表的是**PHP：超文本预处理器**。它是一种功能齐全的编程语言，是解释执行的，而不是编译的（我们现在知道这意味着什么）。
- en: When, in that 6 month class I keep mentioning, we finally reached the PHP part,
    I was expecting a new and unexplored topic, a new frontier. I was prepared to,
    as a programmer, boldly go where no one—me in particular—had gone before. Instead,
    all elements were utterly familiar to me.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我不断提到的那个6个月课程中，当我们最终到达PHP部分时，我期待着一个全新的、未探索的主题，一个新的前沿。作为一个程序员，我准备大胆地走向没有人——尤其是我自己——曾经去过的地方。然而，所有元素对我来说都是如此熟悉。
- en: When I explain this experience to people, I compare it to running into a girlfriend
    you have not seen in 15 years and realizing you still like her. Strangely enough,
    something similar happened to me last year, and this time it was a girlfriend.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我向人们解释这个经历时，我把这比作遇到一个15年未见的女友，并意识到你仍然喜欢她。奇怪的是，去年发生了一件类似的事情，这次是一个女友。
- en: That familiarity with PHP involved not just the language itself, being similar
    to the C programming language, but, in particular, all the functions that come
    with the language. Many of those are the same utility functions that you find
    in the standard C library for UNIX systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对PHP的熟悉不仅涉及语言本身，与C编程语言相似，而且还特别涉及与语言一起提供的所有函数。其中许多与你在UNIX系统标准C库中找到的相同实用函数相同。
- en: Introduction to PHP
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP简介
- en: As we mentioned, PHP, like JavaScript, is a language that is interpreted. So,
    we need an interpreter first. With JavaScript, that was easy, the interpreter
    is inside any browser. With PHP, you need a separate program to interpret your
    code. Assume you have such a program called `php` on your computer (I have one
    on my Mac) where you can type in PHP code or supply a file with the code inside
    it, then we could write our first program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，PHP，就像JavaScript一样，是一种解释执行的编程语言。因此，我们首先需要一个解释器。对于JavaScript来说，这很简单，解释器在任何一个浏览器中都有。对于PHP来说，你需要一个单独的程序来解释你的代码。假设你在电脑上有一个名为`php`的程序（我在我的Mac上有一个），你可以在其中输入PHP代码或提供包含代码的文件，然后我们就可以编写我们的第一个程序。
- en: 'Our first, not so useful, example: using your favorite editor, create a file
    called `first.php` and enter the following text:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个，不那么有用的例子：使用你最喜欢的编辑器，创建一个名为`first.php`的文件，并输入以下文本：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the strings `<?php` and `?>`. Typically, PHP code is placed in between
    those strings. So both examples really contain only a single line of PHP code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串`<?php`和`?>`。通常，PHP代码放置在这两个字符串之间。所以这两个例子实际上只包含了一行PHP代码。
- en: So, if you have that `php` program on your computer (don't panic if you don't,
    you are not going to need one), you can type `php first.php` and you will see
    `Hello, world` appear on your screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在你的电脑上有那个`php`程序（如果你没有，不要慌张，你不需要一个），你可以输入`php first.php`，你会在屏幕上看到`Hello,
    world`出现。
- en: As PHP is a full-featured language, you could use it this way to create standalone
    programs for your projects. However, this is not why you bought this book and
    this is not how we are going to teach you the language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP是一种功能齐全的语言，你可以用它以这种方式为你的项目创建独立的程序。然而，这并不是你购买这本书的原因，也不是我们将要教你的语言的方式。
- en: Our first real PHP program
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个真正的PHP程序
- en: 'We are going to use PHP to create **dynamic webpages**. In simple terms, these
    are HTML pages with PHP code embedded in them. The PHP interpreter will take your
    code, interpret it, and replace it with the result of your program. The resulting
    modified HTML document will have no more PHP code in it; that pure HTML file will
    be what the browser sees. Here is a good example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PHP来创建**动态网页**。简单来说，这些是嵌入PHP代码的HTML页面。PHP解释器将取走你的代码，进行解释，并用程序的结果替换它。生成的修改后的HTML文档将不再包含PHP代码；那个纯HTML文件将是浏览器看到的。这里有一个很好的例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the interpreter has done its thing, the contents of this file will have
    transformed into the exact lines of our first example in [Chapter 2](ch02.html
    "Chapter 2. HTML"), *HTML*, and this will be what the browser sees.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解释器完成了它的任务，这个文件的 内容将会转换成我们[第2章](ch02.html "第2章。HTML")中的第一个示例的精确行，*HTML*，这就是浏览器所看到的。
- en: Notice that in the line with the `<title>` tag, we embedded PHP code inside
    the HTML tag. You can do that. The second line with PHP code in our example is
    part of a PHP statement block. That makes it a lot more readable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在带有`<title>`标签的行中，我们在HTML标签内嵌入了PHP代码。你可以这样做。我们例子中的第二行带有PHP代码的部分是一个PHP语句块的一部分。这使得它更容易阅读。
- en: So, how can this be useful? You are pulling my leg. We are three chapters further
    down the road and all you can do is tell me how to write `Hello, world` in ten
    different ways?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么用呢？你在开玩笑吧。我们已经走了三个章节的路，而你所能做的只是告诉我用十种不同的方式来写`Hello, world`？
- en: Of course PHP is going to be useful. The PHP code embedded in your HTML file
    could be a while loop (yes, PHP has that too) that pulls data out of a file or
    a database, and constructs clean HTML code using that data to generate multiple
    pages of HTML. All of this can be done with just a few lines of PHP code. But
    how do we get it to work? Well, we first need to set ourselves up with a thing
    or two.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然PHP是有用的。嵌入到你的HTML文件中的PHP代码可以是一个while循环（是的，PHP也有这个），从文件或数据库中提取数据，并使用这些数据构建干净的HTML代码来生成多个HTML页面。所有这些都可以用几行PHP代码完成。但我们如何让它工作呢？好吧，我们首先需要做一些准备工作。
- en: PHP and web hosting
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP和网络托管
- en: So far, everything has been done by the browser, except for loading files down
    from the server into the browser, which the **web server** does at the browser's
    request - an HTTP request to be more precise.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，除了在浏览器的请求下从服务器加载文件到浏览器之外，所有的事情都是由浏览器完成的，这是**网络服务器**做的——更准确地说，是一个HTTP请求。
- en: The file that needs to be downloaded is determined by the URL, the address of
    a web page the user has typed in, or the link they clicked on; in this case, `www.sitename.com/demo.html`
    (or `demo.php`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要下载的文件由URL决定，即用户输入的网页地址，或者他们点击的链接；在这种情况下，`www.sitename.com/demo.html`（或`demo.php`）。
- en: Once that HTML file is loaded into the browser, everything in it is read, including
    `<img>`, `<script>`, and `<link>` tags with `href` and `src` attributes. The browser
    will come up with a list of more files it needs and turn into a little Oliver
    Twist by going *Please Server, can I have some more?*
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦HTML文件被加载到浏览器中，其中的所有内容都会被读取，包括带有`href`和`src`属性的`<img>`、`<script>`和`<link>`标签。浏览器会列出它还需要更多的文件，并变成一个小奥利弗·退斯特，说“请服务器，我能再要点吗？”
- en: Once all of that code is present, the browser knows what to do with it and renders
    the web page on the user's computer or tablet. The `script` and `style` tags help
    you to distinguish which part is plain HTML and which is CSS or JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些代码都准备好了，浏览器就知道如何处理它，并在用户的电脑或平板电脑上渲染网页。`script`和`style`标签帮助你区分哪些是纯HTML，哪些是CSS或JavaScript。
- en: Now, how the hell did all these files get up there, and where is *there*? They
    got there, and back down, because behind the name `www.sitename.com`, there is
    a computer and a service called **web hosting**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在究竟是怎么把这些文件弄到那里的，*那里*又是哪里呢？它们到了那里，又回来了，因为`www.sitename.com`这个名字背后有一台计算机和一个叫做**网络托管**的服务。
- en: Web hosting 101
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络托管101
- en: We have been holding off explaining this part because so far, we could use our
    examples without needing a true website. With PHP, this is going to be different,
    so this is the place to outline which steps you need to take if you want a website
    of your own that people can visit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直推迟解释这部分，因为我们到目前为止可以用我们的例子而不需要真正的网站。使用PHP，这将会不同，所以这是概述如果你想要一个人们可以访问的自己的网站需要采取哪些步骤的地方。
- en: Domain name
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名
- en: The first thing you need is a name for your website. What you really need is
    a **domain name**. Websites cannot have any name you pick and no two websites
    can have the same name. So, if you want to call your plumbing company's site `joe.theplumber.com`,
    that is not going to happen by itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要给你的网站起一个名字。实际上你需要的是一个**域名**。网站不能有你想取的任何名字，而且两个网站不能有相同的名字。所以，如果你想叫你的管道公司网站为`joe.theplumber.com`，这不会自动发生。
- en: You want to use a web hosting company to do that for you.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用一家网络托管公司来帮你完成这件事。
- en: Web hosting companies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络托管公司
- en: Web hosting companies cannot only provide you with a domain name and the registration
    for it, they will also (for a fee) set you up on one of their computers that run
    7 days a week, 24 hours a day - 24/7 in short. That way, everybody in the world
    with an internet connection can visit your website anytime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 网络托管公司不仅能为您提供域名和注册服务，他们还会（收取费用）在他们的计算机上为您设置一个服务器，这些计算机每周7天，每天24小时运行——简称为24/7。这样，世界上任何有互联网连接的人都可以随时访问您的网站。
- en: Can't I use my own computer to set up my website? Yes, you could, but as soon
    as you shut it down and leave the house, nobody can visit your site, and that
    is not what you want.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能用自己的电脑来设置我的网站吗？是的，您可以，但一旦您关闭它并离开家，就没有人能访问您的网站了，这并不是您想要的。
- en: 'A domain name is typically `www.` followed by a string that represents a person
    or a company, and then one of the available endings representing the type of organization
    involved, or the country where it is located. Early on, there were only a few
    of these endings available: `.com`, `.orig`, `.net`, `.gov`, and so on. The list
    is still expanding.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 域名通常是`www.`后面跟着代表一个人或公司的字符串，然后是一个表示涉及的组织类型或所在国家的可用结尾。一开始，这些结尾只有几个：`.com`、`.org`、`.net`、`.gov`等等。这个列表仍在扩展。
- en: There are sites you can visit, for example, `dns.be` for domain names in Belgium,
    to see whether the domain name you picked is still available. I went with [paulpwellens.com](http://paulpwellens.com)
    because `paulwellens.com` was already taken by a British rugby player. Well, I
    am neither British, nor a rugby player.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问一些网站，例如，访问`dns.be`查看您选择的域名是否仍然可用。我选择了[paulpwellens.com](http://paulpwellens.com)，因为`paulwellens.com`已经被一位英国橄榄球运动员占用。嗯，我既不是英国人，也不是橄榄球运动员。
- en: A few years later, after I moved back to Belgium, `paulwellens.be` became available.
    I registered it on my name for a year but then released it as I saw no point in
    having two different names, and worse, two different hosting companies. But you
    can have more than one domain name for a single site, if you like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，当我回到比利时后，`paulwellens.be`变得可用。我以我的名义注册了一年，但后来我放弃了它，因为我看不出保留两个不同名称的必要性，更糟糕的是，两个不同的托管公司。但如果你愿意，你可以为单个网站拥有多个域名。
- en: Server-side setup
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端设置
- en: 'Once your web hosting company has set you up, it will provide you with essential
    information to allow you to transfer your web page files to your website. This
    typically involves:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的网络托管公司为您设置好，它将提供必要的信息，以便您可以将您的网页文件转移到您的网站上。这通常包括：
- en: The domain name of your website (of course)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您网站的域名（当然）
- en: An FTP address (an IP address or simply the same domain name)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP地址（一个IP地址或简单地是相同的域名）
- en: A login and password
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录名和密码
- en: The name of a folder, for example `public_html`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹的名称，例如 `public_html`
- en: With this information, you can transfer the web pages you have developed on
    your computer to your own site using the FTP protocol. This means that you need
    to have a program on your computer or tablet that can handle that. To most UNIX-based
    systems (Mac OS, Linux) that comes naturally, there are cool FTP apps for tablets,
    and FTP clients for Windows exist as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，您可以使用FTP协议将您在计算机上开发的网页转移到您自己的网站上。这意味着您需要在您的计算机或平板电脑上有一个可以处理该协议的程序。对于大多数基于UNIX的系统（如Mac
    OS、Linux）来说，这很自然，平板电脑上有一些很酷的FTP应用程序，同时Windows也存在FTP客户端。
- en: FTP stands for **File Transfer Protocol**. Use or install a so-called FTP client
    on your computer or tablet and it will let you transfer files in between it and
    the host, typically one file at a time. FileZilla is something to look into if
    you want to transfer files in bulk. And, to continue with more good news, a lot
    of the cool HTML editors and other tools have FTP built in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: FTP代表**文件传输协议**。在您的计算机或平板电脑上使用或安装一个所谓的FTP客户端，它将允许您在客户端和主机之间传输文件，通常一次传输一个文件。如果您想批量传输文件，FileZilla是一个不错的选择。而且，还有更多的好消息，许多酷的HTML编辑器和其他工具都内置了FTP功能。
- en: The folder on the server that holds the home page of your site, `public_html`
    in our example, is often referred to as your document root.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上存放您网站主页的文件夹，在我们的例子中是`public_html`，通常被称为您的文档根目录。
- en: Additional server-side services
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加的服务器端服务
- en: 'What we just described is exactly what you need, and nothing else, to set up
    a static website. If you plan to use other things, and you do, it is important
    that you check which additional services the web hosting company you consider
    offers. The minimal setup connects you to a Web Server with support for the HTTP
    and the FTP protocol. You also need to make sure that the following is available:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的正是你需要的一切，没有其他东西，来设置一个静态网站。如果你计划使用其他东西，而且你确实会使用，那么检查你考虑的网站托管公司提供的附加服务非常重要。最基本设置将连接你到一个支持
    HTTP 和 FTP 协议的 Web 服务器。你还需要确保以下内容可用：
- en: PHP - check which version of PHP
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP - 检查 PHP 的版本
- en: MySQL server - also check the version
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 服务器 - 也请检查版本
- en: PHPMyAdmin - a tool to easily to manage MySQL databases
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPMyAdmin - 一个易于管理 MySQL 数据库的工具
- en: Most vendors will supply some kind of panel, CPanel being a popular one, to
    access and configure these services. The servers themselves typically run Linux
    or MacOS as the operating system, Apache as the web server, and support MySQL
    and PHP. In `www` land, this combination is often referred to as the LAMP stack.
    How about having a LAMP of your own?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数供应商都会提供某种类型的面板，CPanel 是其中流行的一个，用于访问和配置这些服务。服务器本身通常运行 Linux 或 MacOS 作为操作系统，Apache
    作为 web 服务器，并支持 MySQL 和 PHP。在 `www` 领域，这种组合通常被称为 LAMP 架构。拥有自己的 LAMP 会怎样呢？
- en: PHP development environment
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP 开发环境
- en: 'There is nothing basically wrong with the setup we just described, but it holds
    one major inconvenience: your website will always look like work in progress.
    With this environment, the only way you can test the result of your work is by
    uploading your changes to your website using FTP and being a visitor of your own
    site. There is likely going to be something wrong from time to time; even the
    tiniest typo can do a great deal of damage.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的设置基本上没有问题，但它有一个主要的不便之处：你的网站总是会看起来像是在进行中。在这个环境中，你测试工作结果的唯一方法是通过使用 FTP
    上传你的更改到网站，并作为你自己的网站的访客。很可能时不时会出现一些问题；即使是微小的错误也可能造成巨大的损害。
- en: For that reason, you want a local development environment on your computer.
    This allows you to only update your website periodically, when milestones of stable,
    tested code have arrived. In the meantime, you can develop new features, experiment,
    learn new things, and all of that good stuff.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要在电脑上设置一个本地开发环境。这样，你就可以在稳定、经过测试的代码里程碑到达时，定期更新你的网站。在此期间，你可以开发新功能，进行实验，学习新事物，以及所有这些美好的事情。
- en: 'To be able to develop your PHP application and test it locally you need:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够本地开发和测试你的 PHP 应用程序，你需要：
- en: A computer running MacOS, Linux, or Windows (at the time of writing, there was
    not a viable PHP environment on a tablet)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 MacOS、Linux 或 Windows 的计算机（在撰写本文时，平板电脑上没有可行的 PHP 环境）
- en: An Apache web server with PHP support
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 PHP 的 Apache 网络服务器
- en: A good code editor, a full blown **Integrated Development Environment** (**IDE**),
    or something in between
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的代码编辑器，一个完整的 **集成开发环境**（**IDE**），或者介于两者之间的工具
- en: I personally like Adobe Dreamweaver. It does everything I need and not a single
    thing more. It lets me look at my pages/applications and test them locally, FTP
    to the server with a mouse click, and its editor recognizes HTML tags, CSS properties,
    and JavaScript and PHP keywords. But it is not free. There are several IDEs that
    are free.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢 Adobe Dreamweaver。它做了我需要的一切，没有多余的东西。它让我可以查看我的页面/应用程序并在本地测试它们，只需点击鼠标即可通过
    FTP 连接到服务器，并且它的编辑器可以识别 HTML 标签、CSS 属性以及 JavaScript 和 PHP 关键字。但它不是免费的。有几个 IDE 是免费的。
- en: Either way, you should have all the files that make up your website stored in
    a local directory, your local document root (for example, `$HOME/Sites/mysitename`),
    and do your testing locally using a URL that begins with `localhost`. On a Mac,
    that would be `http://localhost/~username/sitename/filename.php`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你应该将构成你网站的文件都存储在本地目录中，你的本地文档根目录（例如，`$HOME/Sites/mysitename`），并使用以 `localhost`
    开头的 URL 在本地进行测试。在 Mac 上，这将是 `http://localhost/~username/sitename/filename.php`
- en: Now, let's go back to the language itself. Just as we did with JavaScript, we
    will go through all the available ingredients in PHP that you can use to cook
    up a PHP program. To avoid duplication, we will not repeat what is the same in
    both languages, but point you to the differences. Where appropriate, we will do
    so in the same order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到语言本身。就像我们对 JavaScript 所做的那样，我们将遍历 PHP 中所有可用的成分，你可以使用它们来编写 PHP 程序。为了避免重复，我们不会重复两种语言中相同的内容，但会指出它们之间的差异。在适当的地方，我们将按照相同的顺序进行。
- en: PHP as a web development language
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 作为一种网络开发语言
- en: So, now we are ready to use PHP to write web programs, run and test them locally,
    and place them on a server that your web hosting company manages; in brief—to
    develop and deploy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们准备好使用PHP编写网络程序，在本地运行和测试它们，并将它们放置在你网络托管公司管理的服务器上；简而言之——开发和部署。
- en: We focus on the use of PHP to generate web pages dynamically. After the PHP
    code is interpreted, what remains is HTML, which you should think of as strings
    of text that are generated on the server and rendered by the client. The data
    that is used to generate these pages either comes out of an external file or a
    database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于使用PHP动态生成网页。在PHP代码被解释后，剩下的就是HTML，你应该将其视为在服务器上生成并由客户端渲染的文本字符串。用于生成这些页面的数据要么来自外部文件，要么来自数据库。
- en: When invited to, the visitor of your site will interact with it. There may be
    a form to fill out, a button to click, a selection to be made out of several choices,
    and so on. The result of that intervention by the visitor needs to somehow make
    its way back to the server and be processed there, and all can be thought of as
    strings of text again. After processing, it either goes back to the client to
    inform the visitor and/or it needs to be stored somewhere. That somewhere is going
    to also be a file on the server or database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的网站被邀请时，访客会与之互动。可能会有一个需要填写的表单，一个需要点击的按钮，从几个选择中做出选择，等等。访客的这种干预结果需要以某种方式返回服务器并处理，所有这些都可以再次被视为文本字符串。处理完毕后，它要么返回客户端通知访客，要么需要存储在某个地方。那个地方也将是服务器上的文件或数据库。
- en: Although I keep claiming, and I mean it, that this book is not to be used as
    a reference, we include a short reference on things related to strings and files,
    as you need them everyday. Databases are the topic of the next chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我一直在宣称，并且我是认真的，这本书不应该用作参考，但我们包括了一个关于字符串和文件相关内容的简短参考，因为你们每天都需要它们。数据库是下一章的主题。
- en: Variables, values, operators, and expressions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量、值、运算符和表达式
- en: Well, you could say that in PHP, every variable will cost you a dollar, because
    every variable name has to begin with a `$`, a dollar sign. If this little word
    game helps us remember the important difference between JavaScript and PHP variables,
    we will all save quite a few dollars over time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以说在PHP中，每个变量都会让你损失一美元，因为每个变量名都必须以一个`$`符号开始，一个美元符号。如果这个小小的文字游戏能帮助我们记住JavaScript和PHP变量之间的重要区别，那么我们都会随着时间的推移节省很多美元。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is no `var` keyword in PHP to declare variables. You can just start using
    them when you initialize them. Just like in JavaScript, there are no strict types,
    you can use numeric and string values; PHP also uses functions, and the operators
    are the same unless you want to glue strings together. However, the story on the
    scope of variables is different.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中没有`var`关键字来声明变量。你可以在初始化它们时开始使用它们。就像在JavaScript中一样，没有严格的类型，你可以使用数字和字符串值；PHP也使用函数，并且运算符相同，除非你想拼接字符串。然而，关于变量作用域的故事是不同的。
- en: Scope of variables
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量作用域
- en: As is the case in JavaScript, the scope of a variable, the area inside a program
    where the variable is known and can be accessed, is a very important thing to
    understand. Compared to JavaScript, different keywords are used. I already mentioned
    that there is no `var` keyword. Instead, we have two new ones—global and static.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在JavaScript中一样，变量的作用域，即变量在程序中已知并可访问的区域，是一个非常重要的事情需要理解。与JavaScript相比，使用了不同的关键字。我已经提到过没有`var`关键字。相反，我们有两个新的关键字——全局和静态。
- en: Local variables
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'Local variables can be accessed inside the function they are declared. It''s
    like in JavaScript, but without the `var` keyword. Let''s, once more, produce
    the number 3 in at least three lines:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量可以在声明它们的函数内部访问。这就像在JavaScript中，但没有`var`关键字。让我们再次在至少三行中生成数字`3`：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This simply produces `3`. If we were to use the variable `$c` outside the function
    in an `echo` statement, it would produce nothing. Yes, you heard me, nothing -
    not undefined, not 0, no error message, just nothing, but in a way, it is the
    empty string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地产生`3`。如果我们想在函数外部使用变量`$c`在`echo`语句中，它将不会产生任何东西。是的，你听到的，什么都没有——不是未定义的，不是0，没有错误信息，就是什么都没有，但以某种方式，它是一个空字符串。
- en: 'Here is another example. This time it does not even calculate `3`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子。这次它甚至不计算`3`：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember the JavaScript example where we declared a variable outside a function
    and initialized it, and then modified its value by mistake inside a function?
    The declaration outside the function turned that variable into a global, without
    using that word in the program. Variables with the same name inside a function
    would hide those globals, but only if they were explicitly declared.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前提到的JavaScript示例，我们在函数外部声明了一个变量并初始化它，然后在函数内部不小心修改了它的值？函数外部的声明将那个变量变成了全局变量，而无需在程序中使用那个词。函数内部具有相同名称的变量会隐藏这些全局变量，但只有当它们被显式声明时。
- en: 'In PHP, we have the opposite. When we declare variables outside a function
    and then introduce a function in our code where we try to access them, they will
    simply disappear from our program horizon. So, in our example, in the statement
    inside the `nothing()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，情况正好相反。当我们在外部声明变量，然后在我们的代码中引入一个函数尝试访问它们时，它们将简单地从我们的程序视图中消失。所以，在我们的例子中，在`nothing()`函数内部的语句中：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`$a` and `$b` are undeclared variables, and when used inside an expression,
    their value usually becomes the empty string. That is why nothing will appear
    on the screen when we use the statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`$a`和`$b`是未声明的变量，当它们在表达式中使用时，它们的值通常变为空字符串。这就是为什么当我们使用以下语句时，屏幕上不会显示任何内容：'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous line however will produce the number `0`. This is because it is
    the result of an expression containing the `+` operator. The operands of the expression
    are first converted to numeric values, so we end up adding nothing to nothing,
    which is the same as adding zero to zero and the result still being zero. So,
    how do we get access inside the function to `$a` and `$b` that we declared outside?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上一行将产生数字`0`。这是因为它是包含`+`运算符的表达式的结果。表达式的操作数首先被转换为数值，所以我们最终什么也没有加到什么也没有上，这和将零加到零一样，结果仍然是零。那么，我们如何在函数内部访问我们在外部声明的`$a`和`$b`呢？
- en: Global variables
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'It is a common practice in many programming languages to take a frequently
    used sequence of statements and place them together in a reusable function, for
    example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，将频繁使用的语句序列取出来，放在一个可重用的函数中，这是一种常见的做法，例如：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on the programming language, a function may technically not be called
    a function but a subroutine, a procedure, and so on. In a typical web development
    scenario where you need to get data out of a database, such an operation occurs
    frequently, so you want to organize your code that way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程语言的不同，一个函数在技术上可能不被称为函数，而是子程序、过程等等。在一个典型的Web开发场景中，你需要从数据库中获取数据，这种操作经常发生，因此你希望以这种方式组织你的代码。
- en: 'Many times, I was flabbergasted because my perfectly working code stopped working
    once I grouped it inside a function. The reason being: my global `$mysqli` object
    that I initialized outside everything else was not reached inside my function.
    What appeared global to me was not treated as global by PHP. Here is the remedy:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次，我感到非常惊讶，因为当我将代码分组到函数中时，原本正常工作的代码突然停止工作。原因是：我在其他所有内容之外初始化的全局`$mysqli`对象在函数内部无法访问。对我来说是全局的，但PHP并没有将其视为全局。以下是补救措施：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not until you use the global keyword inside the function will your *global*
    variables be treated as such.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在函数内部使用全局关键字，否则你的全局变量才会被当作全局变量处理。
- en: Another remedy would be to make your `$a` and `$b` variables parameters of the
    function, but I would not recommend this. Using global variables declared as global
    inside the functions where you need them is the global best practice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种补救措施是将你的`$a`和`$b`变量作为函数的参数，但我不会推荐这样做。在需要使用全局变量的函数中将它们声明为全局变量是全局最佳实践。
- en: Static variables
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态变量
- en: 'There is a third kind of variable scope that could be very useful in some programming
    situations. Consider this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程情况下，存在一种非常有用的变量作用域类型。考虑以下情况：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is probably clear what the intent is. Each time we use this function, we
    want to list the price we pass as an argument, but we expect the article number
    to be one higher as well. However, each time we re-enter the function, the `$article`
    variable is reset to 0\. Now, pay attention to this slightly different version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能已经很清楚我们的意图。每次我们使用这个函数时，我们希望列出我们作为参数传递的价格，但我们期望文章编号也要高一个。然而，每次我们重新进入函数时，`$article`变量都会重置为0。现在，请注意这个略有不同的版本：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will provide the intended result because we declared `$article` as a static.
    The line with the keyword static where the variable is assigned its initial value
    is only used once and is ignored from that point forward when the program returns
    to the function. Each time it does that, however, the variable's value from the
    previous visit is remembered. The declaration with the static keyword cannot use
    an expression to initialize the variable, though.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供预期的结果，因为我们已将`$article`声明为静态。变量被赋予初始值的带有关键字`static`的行只使用一次，并且从那时起，当程序返回到函数时将被忽略。然而，每次它这样做时，都会记住上一次访问的变量的值。使用`static`关键字声明的变量不能使用表达式来初始化。
- en: The same selection of expressions and operators that we used in the [Chapter
    4](ch04.html "Chapter 4. JavaScript"), *JavaScript*, are valid in PHP, with one
    major, extremely important, exception.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。JavaScript")中使用的相同的选择表达式和运算符在PHP中也是有效的，只有一个主要且极其重要的例外。
- en: String operators
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串运算符
- en: 'In JavaScript, you learned that you could not only use the `+` sign to add
    numbers but also to glue strings together - concatenate them, as it is also called.
    In PHP, there is a separate operator to do that. It comes in two flavors, which
    we illustrate here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你学习了不仅可以使用`+`符号来加数字，还可以用来连接字符串——连接它们，也可以称为连接。在PHP中，有一个专门的运算符来做这件事。它有两种形式，我们在这里展示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Most of your PHP code will be like this: concatenating strings to build up
    the final HTML of a dynamic page. Typically, you would start with a variable,
    initialize it with an opening tag, build up from there until you reach the final
    HTML tag, and then `echo` the whole lot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分PHP代码将像这样：将字符串连接起来构建动态页面的最终HTML。通常，你会从一个变量开始，用开标签初始化它，然后从那里构建，直到达到最终的HTML标签，然后`echo`整个内容：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once we start adding attributes to the HTML tags, which require quotes, and
    start using PHP variables that contain dollar signs, it is important to pay careful
    attention, not only to properly use quotes, but also to which quotes to use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始向HTML标签添加需要引号的属性，并开始使用包含美元符号的PHP变量，就必须仔细注意，不仅要正确使用引号，还要注意使用哪种引号。
- en: To double quote or to single quote, that is the question
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双引号还是单引号，这是一个问题
- en: 'I am a single quote guy, I start with single quotes for every string, then
    switch to double quotes inside when I need them. What is the difference between
    them? Everything inside single quotes is taken literally, so `$name` reads as
    `$name`. In text between double quotes, variables are evaluated, so `$name` would
    read as whatever the value of that variable is. If you use single quotes and need
    variables, place them outside the quotes and use the concatenation operator to
    compose your text, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个单引号爱好者，我总是用单引号开始字符串，然后在需要时切换到双引号。它们之间有什么区别？单引号内的内容将被当作字面意思处理，所以`$name`读作`$name`。在双引号之间的文本中，变量将被评估，所以`$name`将读作该变量的值。如果你使用单引号并需要变量，请将它们放在引号外，并使用连接运算符来组合你的文本，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to use double quotes, the same statement has to look like this.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用双引号，相同的语句看起来应该是这样的。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can leave `$hello` inside as it will be evaluated, but you have to escape
    the double quotes of the class attributes with a backslash to lift its special
    meaning.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`$hello`放在里面，因为它将被评估，但你必须使用反斜杠转义类属性的引号以取消其特殊含义。
- en: My preference is to use single quotes. Just avoid mixing the two methods. On
    the other hand, if you have to work with code from others, make sure you pay attention
    to these, not always subtle, differences.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我的偏好是使用单引号。只是避免混合这两种方法。另一方面，如果你必须处理他人的代码，请确保你注意这些，虽然不是总是微妙的，但差异。
- en: Control flow
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流
- en: 'In [Chapter 4](ch04.html "Chapter 4. JavaScript"), *JavaScript*, we listed
    the principle control flow statements of the language: if, if/else, while, and
    switch. The same are available in PHP with the same syntax. Don''t forget your
    dollars in the variable names, though!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。JavaScript")中，*JavaScript*，我们列出了该语言的原则控制流语句：if，if/else，while和switch。PHP中也有相同的语法，但不要忘记变量名中的美元符号！
- en: Functions
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: The syntax for user-defined functions is also the same as in JavaScript.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义函数的语法与JavaScript中的语法相同。
- en: PHP also comes with quite a few functions predefined. Some of these are so useful
    that we decided to include the description and syntax of them. Most of them remind
    me of the C library functions from my UNIX days.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 还提供了一些预定义的函数。其中一些非常有用，所以我们决定包括它们的描述和语法。大多数都让我想起了UNIX时代的C库函数。
- en: String functions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串函数
- en: As you will be using strings all the time, and will often have to manipulate
    those strings before the final output, it is good to know that PHP comes with
    a nice group of string functions. For your convenience, we include the most useful
    ones here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将始终使用字符串，并且经常需要在最终输出之前对这些字符串进行操作，因此了解PHP提供了一组不错的字符串函数是很有用的。为了您的方便，我们在此包括最实用的函数。
- en: strpos()
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strpos()
- en: 'The `strpos()` function finds the position of the first occurrence of a string
    inside another string. It returns the position (starts at `0`, not `1`) or `FALSE`
    when the string is not found. The function takes two arguments: the string to
    look in and the string to look for:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`strpos()` 函数在另一个字符串中查找字符串首次出现的位置。如果找到字符串，则返回位置（从 `0` 开始，而不是 `1`），如果没有找到字符串，则返回
    `FALSE`。该函数接受两个参数：要查找的字符串和要查找的字符串：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: strlen()
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strlen()
- en: '`strlen()` returns the length of the string that is the only argument for this
    function or `0` if the string is empty.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`strlen()` 返回该函数唯一参数的字符串长度，如果字符串为空则返回 `0`。'
- en: substr()
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: substr()
- en: '`substr()` returns a substring of a string. Its typical use is `substr($string,$start,$length)`.
    `$string` is the string used to examine, `$start` is the start position in that
    string, and the optional `$length` is used to specify the length of the string
    we want returned. The default is to the end of the string.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr()` 返回字符串的子串。其典型用法是 `substr($string,$start,$length)`。`$string` 是用于检查的字符串，`$start`
    是该字符串中的起始位置，可选的 `$length` 用于指定要返回的字符串长度。默认值是字符串的末尾。'
- en: We can also combine these functions. What would you think the following will
    do?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合这些函数。您认为以下代码会做什么？
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Date functions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期函数
- en: It is hard to imagine a web application that never has to do anything with the
    time or date. Moreover, you will often have the need to use a different date format,
    not only because date formats differ in different parts of the world, 07/19 is
    correct in the US but has to be 19/07 in Europe, dates in databases use a different
    format as well. There are three very convenient functions to help you with that.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个不需要与时间或日期有任何关系的Web应用程序。此外，您将经常需要使用不同的日期格式，这不仅因为世界各地的日期格式不同，例如，07/19在美国是正确的，但在欧洲必须是19/07，数据库中的日期也使用不同的格式。有三个非常方便的函数可以帮助您处理这些。
- en: So, what is a date? Well it can be something that grows in warm countries and
    hangs on trees; I used to buy dates in Death Valley and give them to my friends.
    Date is also another word for an appointment, and people, young and old, can get
    all excited when they go on a date.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是日期呢？嗯，它可以是生长在温暖国家并挂在树上的东西；我过去在死亡谷买枣，然后给我的朋友们吃。日期也可以是约会的另一个词，年轻人和老年人都可以在约会时兴奋起来。
- en: In PHP, however, the definition of date or time also comes from UNIX, and is
    equal to the number of seconds between now and January 1, 1970 00:00:00 GMT. Here
    are the three functions and how to use them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP中，日期或时间的定义也来自UNIX，等于现在与1970年1月1日00:00:00 GMT之间的秒数。以下是三个函数及其用法。
- en: time()
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: time()
- en: 'This will return the time of now in seconds. So, in the following code, you
    can store this in a variable:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回现在的秒数。因此，在以下代码中，您可以将它存储在一个变量中：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Please note this will be the date and time on your hosting server, which may
    be sitting in a different part of the world than your computer or that of the
    visitor of your site. You always want to specify what the correct time zone for
    your program is with the `date_default_timezone_set` function, for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这将是托管服务器上的日期和时间，它可能位于与您的计算机或网站访问者所在的不同地区。您始终可以使用 `date_default_timezone_set`
    函数指定程序的正确时区，例如：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the date and time of your visitor needs to be determined, then that will
    have to happen on the client side, i.o.w. in JavaScript using its `date` object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要确定访问者的日期和时间，那么这将在客户端发生，即使用 JavaScript 的 `date` 对象。
- en: date()
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: date()
- en: 'The `date()` function is used to take a timestamp, for example, a number of
    seconds, or right now by default, and convert it into the format you want. The
    first argument it takes is a format string. Check out a good reference for a complete
    list of items you can use in that string. The most commonly used are `m` for a
    two digit representation of the month, `d` for the day, and `Y` for the four digit
    representation of the year. So, to get today''s date in the European format with
    slashes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`date()` 函数用于获取时间戳，例如，秒数或默认情况下为当前时间，并将其转换为所需的格式。它接受的第一个参数是一个格式字符串。查看一个良好的参考，以获取该字符串中可以使用的完整项目列表。最常用的有
    `m` 表示两位数的月份，`d` 表示日期，`Y` 表示四位数的年份。因此，要获取今天的日期，以欧洲格式使用斜杠分隔：'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, you will, from time to time, need the date and time of right now,
    but it is more common that you need to work with dates in the past (order dates)
    and the future (agenda items). So, how do we calculate the exact number of seconds
    between the time an order was placed and midnight of the last day in 1969? You
    don't. There is one more function to help us with that.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你时不时地需要现在的日期和时间，但更常见的是你需要处理过去的日期（订单日期）和未来的日期（日程事项）。那么，我们如何计算订单时间与1969年最后一天午夜之间的确切秒数？你不需要。还有一个函数可以帮助我们做到这一点。
- en: strtotime()
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`strtotime()`'
- en: 'The `strtotime()` function will, in turn, return a timestamp based on the string
    that is passed as an argument - for instance, the format coming out of a database.
    Look up a good `strtotime` reference for a list of all valid formats. So, in practice,
    you will often combine the two, as in:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtotime()` 函数将根据传递给它的字符串作为参数返回一个时间戳——例如，来自数据库的格式。查找一个良好的 `strtotime` 参考，以获取所有有效格式的列表。因此，在实践中，你通常会结合使用这两个函数，如下所示：'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Arrays
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a collection of data elements stored in a single variable. In most
    programming languages that I knew before PHP, these elements would be referenced
    by a number, its index, starting at number 0 for the first one. What was a revelation
    to me, during the training I keep mentioning, is a different type of array that
    you can use in PHP: an associative array. More about that very soon.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是存储在单个变量中的数据元素集合。在我之前知道的几乎所有编程语言中，这些元素都会通过一个数字，即它的索引来引用，第一个元素的索引从0开始。在我提到的培训期间，对我来说是一个启示的是，PHP中可以使用的一种不同类型的数组：关联数组。关于这一点，很快就会详细介绍。
- en: Numeric arrays or indexed arrays
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字数组或索引数组
- en: 'The traditional array with a numeric index can be declared and initialized
    at once, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 具有数字索引的传统数组可以一次声明和初始化，如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In both examples, we create a `4` element array that contains the first names
    of the Beatles. In the first example, we do it all at once, using the `array()`
    constructor - similar to what we used in JavaScript to create objects. As a matter
    of fact, JavaScript has arrays as well, but we are not going to need them as often
    as we do in PHP.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们创建了一个包含披头士乐队成员名字的首字母缩写的`4`元素数组。在第一个例子中，我们一次完成，使用`array()`构造函数——类似于我们在JavaScript中创建对象时使用的方法。实际上，JavaScript也有数组，但我们不会像在PHP中那样经常需要它们。
- en: 'The second example first tells Mr. PHP that `$beatles` is supposed to be an
    array, and then we start filling it up. The first `$beatles[]="John"` assignment
    is equivalent to:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子首先告诉PHP先生，`$beatles` 应该是一个数组，然后我们开始填充它。第一个 `$beatles[]="John"` 赋值相当于：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next ones will initialize the element with an index one higher. However,
    we could have written this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个将初始化索引高一位的元素。然而，我们可以这样写：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then George would have become the value of `$beatles[6]` and Ringo that of `$beatles[7]`.
    It is perfectly okay for there not to be any elements with index 2, 3, 4, and
    5\. People who like to collect things probably hate that. They cannot stand having
    0 and 1 and 6 and 7 of something and not the ones in between. They will probably
    love associative arrays, just like I do.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，乔治将成为`$beatles[6]`的值，林戈将成为`$beatles[7]`的值。没有元素具有索引2、3、4和5是完全可以接受的。喜欢收集东西的人可能不喜欢这样。他们无法忍受有0和1和6和7而没有中间的。他们可能会像我一样喜欢关联数组。
- en: Associative arrays
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联数组
- en: 'With what is called associative arrays in PHP, an index can be a string rather
    than a number. This is how it works:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中所谓的关联数组中，索引可以是一个字符串而不是一个数字。这是它的工作方式：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have basically recreated the JavaScript object from the previous chapter
    as an associative array. There is also a way to initialize this all in one statement.
    Its syntax is new and different and introduces key/value pairs. These key/value
    pairs will prove very useful when we start extracting data from a database such
    as MySQL, because we can have MySQL return the data to us as a...guess what...associative
    array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将上一章中的JavaScript对象重新创建为一个关联数组。还有一种方法可以在一个语句中初始化所有这些。它的语法是新的，并且不同，引入了键/值对。当我们开始从数据库（如MySQL）提取数据时，这些键/值对将非常有用，因为MySQL可以将数据以……猜猜看……关联数组的形式返回给我们。
- en: 'So, here is the single statement version using the special `=>` operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个使用特殊 `=>` 操作符的单行版本：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Cool control statements for associative arrays
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联数组的酷控制语句
- en: 'There are more control statements than the ones we described in this and the
    previous chapter. The `foreach` statement is extremely useful to loop through
    an array, as you can easily walk through the keys and the values. The following
    statement loops through the array of our example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句比我们在本章和上一章中描述的要多。`foreach` 语句在遍历数组时非常有用，因为你可以轻松地遍历键和值。以下语句遍历了我们的示例数组：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that you''ve learned what associative arrays are, we are ready to explain
    some important array variables that we do not create ourselves, but are generated
    by the system`: $_POST` and `$_GET`. The most common scenario where we will have
    access to those is when a visitor of our site fills out a form and pushes a button.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经了解了关联数组是什么，我们准备解释一些重要的数组变量，我们不是自己创建的，而是由系统生成的：`: $_POST` 和 `$_GET`。我们将能够访问这些变量的最常见场景是当我们的网站访客填写表单并点击按钮时。'
- en: Sending data back to the server – forms
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据发送回服务器 – 表单
- en: You already know one way to obtain information from the server, and you will
    learn other ones when we discuss files and databases but let's first reverse it.
    We are going to show you how we can catch and process the information that the
    visitor of our site provided us with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道一种从服务器获取信息的方法，当我们讨论文件和数据库时，你将学习其他方法，但让我们首先反过来。我们将向你展示我们如何捕捉和处理我们的网站访客提供给我们信息。
- en: The most common way is when the visitor fills out fields in a form and submits
    it. This takes us back to [Chapter 2](ch02.html "Chapter 2. HTML"), *HTML*, where
    we discussed the `<form>` and `<input>` elements. The `<form>` tag has more attributes
    than we discussed because we could not explain them at the time. In order to validate
    the user input, for example, to see whether a ZIP code contains only numbers before
    it is sent to the server, we were required to know JavaScript. We are still postponing
    that gig, because there is a very nice jQuery plugin to do that for us. Nor could
    we explain the *action* and *method* attributes, because that involved PHP. The
    time to do that is now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方式是当访客填写表单字段并提交时。这把我们带回到[第2章](ch02.html "第2章。HTML")，*HTML*，在那里我们讨论了 `<form>`
    和 `<input>` 元素。`<form>` 标签具有比我们讨论的更多属性，因为我们当时无法解释它们。例如，为了验证用户输入，比如在发送到服务器之前查看ZIP代码是否只包含数字，我们需要了解JavaScript。我们仍在推迟这个任务，因为有一个非常棒的jQuery插件可以为我们完成这个任务。我们也不能解释
    `*action*` 和 `*method*` 属性，因为这涉及到PHP。现在是做这件事的时候了。
- en: Take a look at the following chunk of HTML, a relatively simple, partial form
    people can use to sign up for a newsletter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下HTML片段，这是一个相对简单的、部分表单，人们可以用它来注册通讯。
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Imagine this code being part of a website where a visitor fills out the form
    and pushes the submit button. The data the user has filled in will be sent to
    the server and can be processed in the PHP module that is supplied with the `action`
    attribute, `process.php` in our example. On the other side, what has been entered
    as a value for the input fields will be stored in an array, named either `$_POST`
    or `$_GET`, depending on which method was chosen.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这段代码是网站的一部分，访客填写表单并点击提交按钮。用户填写的数据将被发送到服务器，并可以在带有 `action` 属性的PHP模块中处理，例如我们例子中的
    `process.php`。另一方面，输入字段中输入的值将被存储在一个数组中，名为 `$_POST` 或 `$_GET`，具体取决于选择了哪种方法。
- en: POST or GET, what should we get?
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST 或 GET，我们应该获取什么？
- en: My personal preference is to always use **POST**, unless I need to use **GET**.
    So, what is the difference?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的偏好是始终使用 **POST**，除非我需要使用 **GET**。那么，区别是什么？
- en: 'With the `GET` method, the data is passed along with the URL, the address of
    the web page you can see inside the browser. You will see things like: `process.php?first=John&last=Williams&profession=conductor`
    in the URL address bar. The string behind the question mark is called the query
    string.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`方法，数据会与URL一起传递，这是你在浏览器内可以看到的网页地址。你会在地址栏看到类似：`process.php?first=John&last=Williams&profession=conductor`这样的内容。问号后面的字符串被称为查询字符串。
- en: With this method, visitors (assuming you gave them instructions) can pass along
    parameters that you can then process in your PHP code. It can also be useful to
    bookmark an interesting article that is part of large website and that you can
    revisit because the creator has added support for that through, for example, a
    query string `article=number`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，访客（假设你给了他们指示）可以传递参数，然后你可以在PHP代码中处理这些参数。如果有一个大型网站中的有趣文章，你可以通过例如查询字符串`article=number`来重新访问它，那么这也会很有用。
- en: 'The two major downsides of using `GET` is that there is an implementation-dependent
    size limit (could be 1024 bytes) and that everything is visible. This is not how
    you want to display the login and password:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`的两个主要缺点是，实现依赖于大小限制（可能是1024字节）以及所有内容都是可见的。这不是你想要用来显示登录名和密码的方式：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, in general, you want to use the `POST` method; there is virtually no size
    limit, and nothing is revealed in the URL bar of the browser:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，你想要使用`POST`方法；实际上没有大小限制，并且浏览器地址栏中不会显示任何内容：
- en: $_POST and $_GET arrays
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: $_POST和$_GET数组
- en: It is quite simple; you can find all the values that were filled out in the
    form in an associative array `$_POST`. In the case of input tags, key/value pairs
    are the values of the `name` attribute and either the `value` attribute or what
    was filled out.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单；你可以在关联数组`$_POST`中找到在表单中填写过的所有值。在输入标签的情况下，键/值对是`name`属性的值和`value`属性或填写的内容。
- en: We cannot be sure whether a user has filled out every required field and whether
    we have even done validation on the client side, which we are going to learn in
    a later chapter, there still needs to be validation on the server side. Otherwise,
    we might stuff a file or database with empty or incomplete employee records.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能确定用户是否填写了所有必填字段，以及我们是否在客户端进行了验证（我们将在后面的章节中学习这一点），但在服务器端仍然需要进行验证。否则，我们可能会在文件或数据库中填充空或不完整的员工记录。
- en: Note the square brackets used in the name attribute for the checkboxes. How
    can they all have the same name? They don't. The result of a user selecting hobbies
    will be an indexed array, which will be `$_POST['hobbies']`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在复选框的名称属性中使用的方括号。它们怎么可能都有相同的名称？它们并不相同。用户选择爱好后的结果将是一个索引数组，它将是`$_POST['hobbies']`。
- en: When processing your `POST` variables, you may want to use the `isset()` function.
    This checks to see whether the variable actually exists, which is different than
    checking to see whether it exists and has a value other than `0` or the empty
    string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理你的`POST`变量时，你可能想要使用`isset()`函数。这个函数检查变量实际上是否存在，这与检查它是否存在并且具有除`0`或空字符串之外的其他值是不同的。
- en: What follows is what could be code in our `process.php` module. In it, we introduce,
    `&&`, a logical operator. Think of it as a logical `AND` operator, which returns
    true if both what is on its left and right is true. Its counterpart is `||`, logical
    `OR`, which is true if at least one of its operands is true.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的是我们`process.php`模块中可能出现的代码。在其中，我们引入了`&&`，这是一个逻辑运算符。把它想象成一个逻辑`AND`运算符，如果其左右两边都是真的，则返回true。它的对应物是`||`，逻辑`OR`，如果至少有一个操作数是真的，则返回true。
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `count()` function is a function that counts how many elements there are
    in an array, i.o.w. what its size is, and returns it. In our example, this would
    amount to the number of hobbies selected, not the number to choose from.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`函数是一个函数，它计算数组中有多少个元素，即它的大小，并返回它。在我们的例子中，这将等于所选爱好的数量，而不是可供选择的数量。'
- en: Files
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: In the previous chapters, we were dealing with inline CSS or JavaScript or,
    by using the correct tag and attribute, we could reference external files that
    contain our code. No such tags or attributes for our PHP code exist, though. But
    there is a different way to do that.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们处理的是内联CSS或JavaScript，或者通过使用正确的标签和属性，我们可以引用包含我们代码的外部文件。但是，对于我们的PHP代码，没有这样的标签或属性。但是，有另一种方法可以做到这一点。
- en: Let's assume that you have written a bunch of cool functions that you plan on
    reusing in other projects. There is no point in repeating them in between `<?php`
    and `?>` in every `.html` file where you want to use them. It is a far better
    idea to keep them in a separate file that you can reference. We have some PHP
    keywords to do exactly that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经编写了一组您计划在其他项目中重用的酷函数。在您想要使用的每个`.html`文件中的`<?php`和`?>`之间重复它们是没有意义的。将它们保存在一个单独的文件中，您可以引用它，这是一个更好的主意。我们有一些PHP关键字可以做到这一点。
- en: include, require, and require_once
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: include、require和require_once
- en: 'When used in a PHP statement, all three will do the same. The statement containing
    the keyword followed by a filename will be replaced by the contents of the file.
    There are nuances: if `include` is used and the file is not found, the program
    will continue, whereas if you use `require`, the program will stop.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当在PHP语句中使用时，这三个关键字都会做同样的事情。包含关键字和文件名的语句将被文件的内容所替换。有一些细微差别：如果使用`include`且文件未找到，程序将继续执行，而如果您使用`require`，程序将停止。
- en: 'The difference between `require` and `require_once` is that with `require_once`,
    a file that has already been loaded will not be loaded again. Make sure that you
    put your PHP code inside the files you include in between `<?php` and `?>` again.
    In the statement itself you can use parentheses or not, for example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`和`require_once`之间的区别在于，使用`require_once`时，已经加载的文件将不会再次加载。请确保您将PHP代码放在您在`<?php`和`?>`之间包含的文件中。在语句本身中，您可以使用括号或不使用括号，例如：'
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Regular files
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常规文件
- en: 'So far, we have been using all kinds of files that are stored on the server:
    programs (`.php` and `.js`), stylesheets (`.css`) plain web pages (`.html`), and
    images, used with the `<img>` tag. Those last ones can be in different kinds of
    format: `.png`, `.gif`, `.png`, even `.tiff`. The links in our web pages can reference
    even more files that reside on the server such as all kind of documents in a PDF
    format, or even Word. All of these files will be downloaded for the visitor of
    our site by the browser when needed and will have arrived on that server because
    we put them there, probably using FTP.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用存储在服务器上的各种文件：程序（`.php`和`.js`）、样式表（`.css`）、纯网页（`.html`）和图像，这些图像与`<img>`标签一起使用。这些图像可以是不同的格式：`.png`、`.gif`、`.png`，甚至是`.tiff`。我们网页中的链接可以引用存储在服务器上的更多文件，例如所有格式的PDF文档，甚至Word文档。所有这些文件在需要时将由浏览器下载给我们的网站访客，并且它们会到达服务器，因为我们可能使用FTP将它们放在那里。
- en: However, there are different kinds of files you could access from within your
    program, as well as creating or modifying new ones. After all, a well-structured
    file can act as a small database. There is a whole family of ready-to-use functions
    to handle files. Most of them take a path to a file, which is nothing else but
    the name itself or a number of directory names separated by a `/` and followed
    by the filename.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以从程序内部访问不同类型的文件，以及创建或修改新文件。毕竟，一个结构良好的文件可以充当一个小型数据库。有一系列现成的函数来处理文件。大多数函数需要一个指向文件的路径，这不过是文件名本身或由一个或多个目录名通过`/`分隔的名称。
- en: 'Those functions then return or use a file handle or file pointer. This is the
    part where I got *deja vu* in the training course. UNIX folks will remember that
    everything is treated like a file: a file proper, a printer, a hard disk, any
    device, and that the basic operations for files are: create, delete, open, close,
    read and write. For true files, text files, or binaries, there was a collection
    of convenient functions, all with a name beginning with an *f*. We rediscover
    these in PHP.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数随后返回或使用文件句柄或文件指针。这就是我在培训课程中感到似曾相识的部分。UNIX用户会记得，一切都被当作文件来处理：一个真正的文件、打印机、硬盘、任何设备，而文件的基本操作是：创建、删除、打开、关闭、读取和写入。对于真正的文件、文本文件或二进制文件，有一系列方便的函数，所有这些函数的名字都以一个`f`开头。我们在PHP中重新发现了这些函数。
- en: File functions or f-functions
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件函数或f函数
- en: There are functions to access existing files or create new ones, to check whether
    files even exist, and are actually files and not directories, and functions to
    read from and write to files. The first one is a little bit of a study; the rest
    is easy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有函数可以访问现有文件或创建新文件，检查文件是否存在，以及它们实际上是文件而不是目录，还有从文件中读取和写入的函数。第一个函数需要一点学习；其余的都很简单。
- en: fopen
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fopen
- en: There is no `fcreate!`, so `fopen` is used to either create a file or open an
    existing one, but for what purpose? You have to carefully study the options for
    the second argument of this function, as that determines what happens to your
    file. This can go from creating a new file for writing and an existing one for
    reading to taking a file, destroying what is already in it and starting anew.
    It is also important to realize where the file pointer is pointing to. We will
    give you just three of these options, but they should suffice for 95% of your
    work. Note that we expect the value of `$filename` to be a pathname to a file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 没有名为`fcreate!`的函数，所以`fopen`用于创建一个新文件或打开一个现有文件，但目的是什么？你必须仔细研究这个函数第二个参数的选项，因为这决定了你的文件会发生什么。这可以从为写入创建一个新文件和为读取打开一个现有文件，到获取一个文件，销毁其中的内容并重新开始。了解文件指针指向的位置也很重要。我们将给你提供这三个选项中的三个，但它们应该足以满足95%的工作。请注意，我们期望`$filename`的值是一个指向文件的路径名。
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will open the file for reading and the file pointer will point to the beginning
    of the file. This is typically what you want if you want to extract information
    from an existing file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开文件用于读取，文件指针将指向文件的开始。如果你想要从现有文件中提取信息，这通常是你要做的。
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `a` stands for append. So, this will open a file for writing, starting at
    the end. So the end will be where the file pointer points to, and everything you
    write to this file will be added at the end.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`代表追加。因此，这将打开一个文件用于写入，从文件末尾开始。所以文件指针指向的位置就是末尾，你写入此文件的所有内容都将添加到末尾。'
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the closest to create. If the file does already exist, it will stay
    intact, and `fopen()` will return `FALSE` rather than a file pointer. Otherwise,
    you just created a file you can write to.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最接近创建的。如果文件已经存在，它将保持完整，并且`fopen()`将返回`FALSE`而不是文件指针。否则，你刚刚创建了一个可以写入的文件。
- en: 'Most other options, as I mentioned, will potentially destroy the contents of
    your file by truncating it and you do not want that. It is like executing the
    command on a UNIX system - for example: `> filename`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所述，大多数其他选项可能会通过截断文件内容来破坏你的文件，你肯定不希望这样。这就像在UNIX系统上执行命令一样 - 例如：`> filename`
- en: file_exists(), is_file(), and is_dir()
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: file_exists(), is_file(), 和 is_dir()
- en: To avoid surprises, you may want to check whether a file you want to open exists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外，你可能想要检查你想要打开的文件是否存在。
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `file_exists()` function returns `TRUE` if `$filename` exists and `FALSE`
    otherwise. It does not tell us whether it is a file or directory. For that purpose,
    we have the functions `is_dir()` and `is_file()`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_exists()`函数如果`$filename`存在则返回`TRUE`，否则返回`FALSE`。它不会告诉我们它是一个文件还是一个目录。为此，我们有`is_dir()`和`is_file()`函数。'
- en: fread and fwrite
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fread 和 fwrite
- en: 'Now, let''s assume that we have files open and pointers that point to somewhere
    inside those files where we can read from and write to. For that purpose, we use
    `fread` and `fwrite`. Assume we have `$fpin` to read from and `$fpout` to write
    to; this would be a simple file copy piece of code, using these functions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经有文件打开，并且指针指向文件内部，我们可以从中读取和写入。为此，我们使用`fread`和`fwrite`。假设我们有`$fpin`用于读取和`$fpout`用于写入；这将是一个简单的文件复制代码片段，使用这些函数：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second argument of `fread` is used to specify how many bytes you want to
    read. Of course, we cut it short here and said: let''s read the whole file at
    once. For that purpose, the `filesize()` function comes in handy. With `fwrite`
    you can use the number of bytes you want written as an optional third argument.
    We did not do this in our example, we simply used the string that contains the
    entire file as the second argument.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`fread`的第二个参数用于指定你想要读取的字节数。当然，我们在这里简化了，说：让我们一次性读取整个文件。为此，`filesize()`函数非常有用。使用`fwrite`，你可以将你想要写入的字节数作为可选的第三个参数。在我们的例子中我们没有这样做，我们只是简单地使用包含整个文件的字符串作为第二个参数。'
- en: One line at a time – fgets()
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐行读取 - fgets()
- en: 'We used the two previous functions to read the contents of a file all in one
    chunk, and then wrote that chunk to another file. Many files we may use instead
    of a database will have lines of information organized as fixed length records
    that are nothing other than strings or numbers of a fixed length. Wouldn''t it
    be nice if we could handle files line by? Well, we can. `fgets()` is a function
    that returns one line at a time:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了前两个函数来一次性读取文件的内容，然后将这个块写入另一个文件。我们可能会用到的许多文件，而不是数据库，将会有组织成固定长度记录的信息行，这些记录不过是固定长度的字符串或数字。如果我们能够逐行处理文件会怎么样呢？我们可以。`fgets()`是一个一次返回一行内容的函数：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The printf family
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: printf函数族
- en: The `printf` function is the one that gave me that *long time no see* feeling
    in the, by-now notorious, six month class. It is wonderfully powerful, and if
    you master how to compose a good format string, you can create excellent structured
    output in just a few statements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`函数是让我在现在臭名昭著的六个月课程中感到“好久不见”的那个函数。它非常强大，如果你掌握了如何编写好的格式字符串，你只需几个语句就能创建出色的结构化输出。'
- en: Unfortunately, you will probably discover that `printf`, the PHP version, is
    not going to be used a lot to produce HTML, because HTML is very far away from
    output of fields with a fixed length. First of all, subsequent spaces are stripped
    out, and by the time you see the output, the HTML tags are not shown either.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你可能会发现`printf`，PHP版本，不太可能被大量用于生成HTML，因为HTML与固定长度字段的输出相去甚远。首先，后续空格会被删除，等你看到输出时，HTML标签也不会显示。
- en: The instructor never used `printf` for two reasons - one of which is very valid.
    `printf` is a function, whereas `echo` is built in. So, most of the time, what
    you echo will be faster than what you `printf`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 讲师从未使用`printf`有两个原因——其中一个是很有道理的。`printf`是一个函数，而`echo`是内置的。所以，大多数时候，你echo的内容会比`printf`快。
- en: 'So, why mention it at all? There are functions very similar to `printf` to
    read from or write to strings or files, and having an easy way to deal with a
    structured format is wickedly useful. They are: `sscanf`, `fscanf`, `sprintf`,
    and `fprintf`. What they all have in common is the use of a format string. First,
    we show you the syntax; next, we explain the format string itself.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要提它呢？有一些与`printf`非常相似的功能可以读取或写入字符串或文件，并且有一个简单的方法来处理结构化格式是非常有用的。它们是：`sscanf`、`fscanf`、`sprintf`和`fprintf`。它们共同的特点是使用格式字符串。首先，我们向您展示语法；然后，我们解释格式字符串本身。
- en: Syntax of printf family of functions
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`printf`函数族的语法'
- en: '`printf($format, $arg1, $arg2, ... );`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf($format, $arg1, $arg2, ... );`'
- en: '`sprintf($string,$format,$arg1,$arg2, ...);`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprintf($string,$format,$arg1,$arg2, ...);`'
- en: '`sscanf($string, $format, $arg1, $arg2, ...);`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sscanf($string, $format, $arg1, $arg2, ...);`'
- en: '`fprintf($fp, $format, $arg1, $arg2, ...);`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fprintf($fp, $format, $arg1, $arg2, ...);`'
- en: '`fscanf($fp,$format, $arg1, $arg2, ...);`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fscanf($fp,$format, $arg1, $arg2, ...);`'
- en: 'In this syntax, `$fp` represents a file pointer that was previously created
    using `fopen()` and a `$string` variable to contain a string; `$arg1`, `$arg2`
    and so on, are variables to store the data that we retrieve, or hold the data
    that we want to use. `$format` holds the magic on how it is all going to be formatted:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语法中，`$fp`代表一个文件指针，它之前使用`fopen()`和`$string`变量来包含字符串创建；`$arg1`、`$arg2`等，是存储我们检索的数据或持有我们想要使用的数据的变量。`$format`包含如何格式化的魔法：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This makes the product name exactly 20 characters, the price 7 digits before,
    and 2 after the floating point. I know, that when displayed in a browser, these
    extra spaces will be reduced to just one, but if `fprintf` was used to write this
    to a file, and we repeat the same statement in a loop, we would end up with a
    file with all the lines nicely lined up. It is all contained by the strings with
    a `%` sign. Typically, you have one extra argument for every `%` string used.
    Here is a selection of what they can contain:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得产品名称正好是20个字符，价格在浮点数前有7位，后跟2位。我知道，当在浏览器中显示时，这些额外空格将减少到只有一个，但如果使用`fprintf`将此写入文件，并在循环中重复相同的语句，我们最终会得到一个所有行都整齐排列的文件。所有这些都包含在带有`%`符号的字符串中。通常，每使用一个`%`字符串就有一个额外的参数。以下是他们可以包含的内容：
- en: '| Format values | Description |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 格式值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%%` | What if you need a `%` sign—use two, only one will be shown |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 如果你需要一个`%`符号——使用两个，只显示一个 |'
- en: '| `%b` | Shows the value as a binary number, that is, only zeroes and ones
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `%b` | 显示值为二进制数，即只有零和一 |'
- en: '| `%c` | The character according to the ASCII value |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 根据ASCII值显示字符 |'
- en: '| `%d` | Shows the value as a decimal number |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 显示值为十进制数 |'
- en: '| `%f` | Floating-point number |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | 浮点数 |'
- en: '| `%o` | Octal number |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | 八进制数 |'
- en: '| `%x` | Hexadecimal number (lowercase letters) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 十六进制数（小写字母） |'
- en: '| `%X` | Hexadecimal number (uppercase letters) |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `%X` | 十六进制数（大写字母） |'
- en: '| `%s` | Treat the value as a string. You will use this the most, combined
    with additional format values, which are placed between the `%` and the letter
    (example `%.2f`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| `%s` | 将值视为字符串。你将最常使用它，结合额外的格式值，这些值放在`%`和字母之间（例如`%.2f`）：'
- en: '[0-9] (Specifies the minimum width held of to the variable value)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[0-9]（指定变量值保持的最小宽度）'
- en: '[0-9] (Specifies the number of decimal digits or maximum string length)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[0-9]（指定小数位数或最大字符串长度）'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the PHP programming language and what it takes
    to get you up and running to use it in your web pages. That was exactly the focus
    of this chapter - not to give you an in-depth coverage of everything that the
    language can do, even in the context of web development. We did not address the
    object-oriented aspects of the language, nor did we cover website-specific things,
    such as cookies and sessions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了PHP编程语言以及你需要做什么才能开始在你的网页中使用它。这正是本章的重点——不是深入覆盖语言能做什么，即使在Web开发的情况下。我们没有涉及语言的对象化方面，也没有涵盖特定于网站的内容，如cookies和会话。
- en: We immediately zoomed into what everyone would need in PHP. We ended the chapter
    with a discussion on how to exchange data between client and server and use files
    to store that data. The functions allow us to add structure to these files. There
    can be even more structure in a file if you use a format such as XML, which is
    very similar to HTML. There are cool PHP libraries to deal with those, such as
    **SimpleXML**, which we will discuss in [Chapter 10](ch10.html "Chapter 10. XML
    and JSON"), *XML and JSON*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即聚焦于每个人在PHP中都需要的内容。我们以讨论如何在客户端和服务器之间交换数据以及如何使用文件存储这些数据结束本章。这些函数使我们能够为这些文件添加结构。如果你使用XML等格式，文件甚至可以有更多的结构，XML与HTML非常相似。有一些酷的PHP库可以处理这些，例如**SimpleXML**，我们将在[第10章](ch10.html
    "第10章。XML和JSON")中讨论，*XML和JSON*。
- en: Ultimately, you want to go beyond the use of files to hold your data and use
    a true database. The most commonly used database in the world of PHP-based web
    development is MySQL and that is the topic of our next chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你希望超越仅使用文件来存储数据的使用，并使用真正的数据库。在基于PHP的Web开发领域，最常用的数据库是MySQL，这也是我们下一章的主题。
