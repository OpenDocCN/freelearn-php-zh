- en: Chapter 4. Clever Website Coordination Using the PEAR Installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we learned how to use the PEAR installer's features
    to manage libraries and applications for public distribution. In this chapter,
    we'll learn how the PEAR installer can be used to make managing the contents of
    a complex and rapidly evolving website easy. In fact, the PEAR installer can be
    used to provide an extra level of insurance that a website will function as expected,
    and even make diagnosing problems easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll begin by understanding the details of our problem at
    a high level, and seeing how PEAR installer can help us to solve it. Then we'll
    look at the first step of the solution, setting up the source control system,
    and we will finally finish off with managing the complexity of a multi-segment
    website using a live site as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important tasks is keeping the structure of a complex and dynamic
    website coherent and up to date as the information represented evolves. In many
    cases, re-organization may result in files that are no longer in use cluttering
    the directory layout. Worse, when deleting unused files, there is a risk of accidentally
    removing an essential file without realizing it. In addition, coordinating a multi-developer
    modular website presents an obvious challenge: how does one prevent conflicts
    in updates and additions?'
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with a revision control system such as CVS (Concurrent Versions
    System), the PEAR installer provides a unique and battle-tested solution to manage
    all of these problems effectively. Revision control systems provide a combination
    of redundancy and flexibility that cannot be matched by simple file systems. The
    ability to check out a personal **sandbox** in which to do development without
    the fear of disrupting the primary code base is an essential part of any serious
    code development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, branches (CVS and Subversion) and tags (CVS only) are used to
    document "release points", where a program is ready for usage. For instance, PEAR
    version 1.4.5 can be retrieved directly from `cvs.php.net` via these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This sequence checks out the source of the PEAR installer, which is located
    at `cvs.php.net` in `/repository/pear-core`, and then retrieves the tag `RELEASE_1_4_5`,
    which was set at the release time of PEAR version 1.4.5 via the convenient `cvstag`
    command (covered in depth later in the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example is the most complex possible command. In most cases, a developer
    can tag a package simply with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the PEAR installer and a revision control system is only as effective
    as the coordinating plan behind them, and so devising a good strategy for developing
    the website in conjunction with the two tools is an essential part of the equation,
    and is covered in the last segment of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using a **roadmap** or a development timeline describing approximately when
    new features will be added and old ones removed is a good first step. Defining
    ways in which developers should coordinate and synchronize their efforts is another.
    Using design tools and strategies such as UML and extreme programming (test-driven
    development and its friends) may also be of use, but ultimately the clarity of
    thought present in the website architects' design goals is usually far more significant,
    and will lead to the best solution, regardless of the tools chosen to get there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary problem we will address is how to coordinate a complex website,
    specifically, how to safely and systematically update the live website from a
    development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the solution to a problem, it makes sense that we should understand
    the problem at a high level. In our case, it is important to understand the main
    issues that surround coordinating the development of a major website. A good website
    will draw users back to view it as often as possible, developing a community.
    This will only happen if there is both exciting content and pleasing visual and
    logical layout. Often, content can be updated without changing any code (think
    of blogs or content management systems), but changing the visual layout and logical
    structure of a site requires more extensive internal changes to a site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you design the perfect site on the first attempt (congratulations!)
    and have a simple method for adjusting the content and even the logical structure
    of a site, this may lead to the largest challenge of transitioning from a small
    website to a hugely successful website with thousands of hits per minute: **scalability**.
    Often at this stage, a comprehensive redesign may be necessary to accommodate
    unexpected needs. Success inevitably leads to the need for bringing on new developers
    who may be unfamiliar with the website structure or design goals. The constant
    threat of re-factoring to improve things also threatens to bring unexpected chaos
    to even the best-intentioned web team.'
  prefs: []
  type: TYPE_NORMAL
- en: All of this uncertainty will lead to greater potential for breakage of code,
    confusing and cluttered directory structure, and other problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at four typical problem areas, and get a better picture of how
    PEAR Installer will help us:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing code breakage and reverting to a previous version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing missing or extraneous files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinating development with a team of developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backing up code: redundancy as a necessary precaution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Code Breakage and Reverting to Previous Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, it becomes apparent that in spite of careful design and even more
    careful testing, something in a recent update has broken a critical portion of
    a website. Even worse, a security breach may have resulted in a rogue hacker destroying
    a carefully worked out web structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, this could mean hoping that a restore from backup would do the
    trick. In some cases, a hack was not noticed for a long time, requiring restoration
    from an early backup. This can result in tremendous difficulty determining the
    correct files to transfer and delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PEAR installer manages these problems in a tremendously efficient manner.
    Instead of spending feverish hours going over each directory by hand, two commands
    are sufficient to completely remove and restore the most current website structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference in complexity between this and a frantic "*is-everything-all-right-oops-I-need-to-restore-that-file-and-delete-this-one*"
    is staggering.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PEAR Installer or rsync?**'
  prefs: []
  type: TYPE_NORMAL
- en: Experienced web developers should also know about the `rsync` command, which
    facilitates remote synchronization of directories on machines separated by a great
    distance. In many cases, this is a very efficient way of ensuring that local and
    remote repositories are in sync. However, if you are coordinating between several
    developers, or developing some portions of a site while others are stable, it
    may cause more difficulty than ease. In this case, you will benefit more from
    the strengths of the versioning and simple reversion provided by the PEAR installer.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Missing or Extraneous Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Theoretically, problems of missing or extra files should never happen if you
    fully test a website on a development machine prior to upload, but there are times
    when a mistake in a `rsync` transfer occurs and files are removed that should
    not be. In the best-case scenario, this will result in the immediate breakage
    of the site, and will be easily tracked down and fixed. In the worst case, however,
    the breakage may be subtle, and in fact not apparent until a rare but crucial
    task is performed by one of your website's end users or a hacker discovers a security
    vulnerability in an unused file. This can lead to scaring off users, lost profits
    for commercial websites, or even legal problems if your site was used by a hacker
    to commit a crime and negligence on your part can be proven.
  prefs: []
  type: TYPE_NORMAL
- en: 'How are these problems any different when managing a website using the PEAR
    installer? There are two features of the PEAR installer that set it apart from
    traditional solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through the concept of versioning, it is possible to determine precisely which
    files are present by either examining the contents of `package.xml` or by running
    the `list-files` command like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing or extraneous files are easily detectable with this system without
    the need to resort to a slow recursive check of actual directories. In addition,
    the ability to quickly revert to an earlier version, even temporarily, and then
    restore a newer fixed version is also incredibly simple, as evidenced by this
    sample command sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The PEAR installer takes advantage of a concept from relational databases and
    implements transaction-based file installation and removal. This means that no
    changes to the directory structure occur until all have been successfully completed.
    In addition, atomic file operations are performed whenever possible. The life
    cycle of a file is rather simple, and consists of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: File `path/to/foo.php` is installed as `/path/to/pear/path/to/.tmpfoo.php`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File `/path/to/pear/path/to/foo.php` if present, is renamed to `/path/to/pear/path/to/foo.php.bak`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File `/path/to/pear/path/to/.tmpfoo.php` is renamed to `/path/to/pear/path/to/foo.php`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After installation, all of the `.bak` files created are removed.
  prefs: []
  type: TYPE_NORMAL
- en: However, if there is a problem at any step along the way, the installed files
    are removed, and the `.bak` files are renamed to the original filename. In this
    way, it is possible to very safely manage file upgrades. Additional checks are
    performed to ensure that the installer is capable of writing to the directory
    of the installation, and that the files are actually installed as expected. All
    of this extra work helps to guarantee the success of an installation.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating Development with a Team of Developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PEAR installer also helps coordinate a team of web developers in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Discrete packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File conflict resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discrete packaging** simply means that each developer or sub-team''s set
    of files can occupy its own package and be installed/upgraded independently of
    the others. In addition, they can all be managed from a central package using
    dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**File conflict resolution** solves the potential for accidentally overwriting
    files from another team and makes it possible to share directory space safely.
    The PEAR installer does not allow different packages to conflict with any files
    from other packages. This simple technical fact will augment your team''s file
    naming conventions with an additional layer of error-checking.'
  prefs: []
  type: TYPE_NORMAL
- en: Even when the `--force` option is specified, file conflict resolution is used.
    Only the dangerous `--ignore-errors` option overrides file conflict checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backing Up Code: Redundancy as a Necessary Precaution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing a website using the PEAR installer provides what is perhaps a less
    obvious benefit by duplicating the code. The need to back up code from a website
    is often thought of only in terms of keeping a duplicate of the entire site. This
    is important, but may not be enough. The ability to quickly restore corrupted
    segments of a website, if only a few files are corrupted, is again quite simple
    with the PEAR installer; one only needs to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the storage of website code as packaged archives at the channel
    server provides an additional level of redundancy above and beyond the redundancy
    provided by source control and traditional full back-up methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the problem areas and how PEAR installer can help us deal with
    them, let's get into the solution in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Solution, Part I: All-Important Source Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before taking advantage of the PEAR installer, it is important to set up a
    source control system. There are many fine commercial software programs that can
    be used to perform source control, including **Perforce** and **Visual SourceSafe**,
    but we will focus on the tried and true, free open-source revision control systems:
    *CVS* and **Subversion**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CVS** (**Concurrent Versioning System**) is one of the oldest source-control
    products, and is based on the even older **RCS** (**Revision Control System**)
    source control program. CVS implements its source control by using a client-server
    model. The server contains the final code, organized into directories and files.
    However, on the server, each file actually contains a full revision history of
    that file. On the client end, users check out a local **sandbox** — a copy of
    the server code, which can then be developed independently of other developers.
    When the code is ready to be committed to the server, the user sends a special
    command to the server. At that time, the server checks to see if there have been
    any changes to the repository by other users, and if so, prevents the conflict
    that may occur. Conflict resolution between users'' commits is fully supported,
    as well as merging compatible changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Although CVS does a very good job, there are a few limitations that prompted
    the Subversion development team to begin work on a new model. Like CVS, Subversion
    provides the same collaborative tools. The difference is in how Subversion stores
    its information. Using a Berkeley database file to document changes and revisions
    (or in the latest releases, the FSFS file-based database), Subversion has the
    capability to track changes to groups of files and directories as well as to individual
    files, something that is far more difficult to do with CVS. In addition, Subversion
    stores a complete copy of the server code in the client sandbox, allowing for
    very efficient use of bandwidth when performing actions such as checking changes
    and making patches.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Redundancy and Revision History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary benefit of a source control system is the combination of redundancy
    and revision history. Source control systems are designed around the principle
    of human fallibility: we just make mistakes sometimes, and it is important to
    be able to recover from those mistakes as easily as possible. Through the redundancy
    provided by separating a developer sandbox from the server repository, it becomes
    possible to quickly recover from a mistake on the developer''s machine. The existence
    of revision history, and CVS/Subversion''s sophisticated ability to check out
    code from a particular point in time, or a particular tag or branch, mean that
    it is also a simple matter to revert a faulty commit, or change to the server
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing CVS or Subversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, setting up a revision control system is easy. This text is not
    the best resource for installation, but does cover the basics. For extended support,
    it is best to consult the support resources of CVS or Subversion directly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, you will learn how to initialize a repository in CVS
    or Subversion and to create new projects within the repository, and how to create
    a local sandbox for development. There are a few prerequisites for setting up
    a revision control system. It is important that you have access to a shell on
    the host for which you wish to set up the revision control system. If you do not
    have access to the file system, it will be exceedingly difficult to fix any problems
    with the repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have shell access to your remote host, and do not have the resources
    to switch to an internet provider that does provide shell access, all is not lost.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows-based systems, it is very easy to set up a local repository using
    the freeware TortoiseCVS or TortoiseSVN programs, and on unix-based systems like
    Mac OS X or Linux, you can compile and use the CVS and Subversion tools directly
    to initialize a repository. The only drawback to this approach is that you lose
    some of the fail-safe advantages of having a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, remote or local repository, you will need to make regular backups
    of the system to avoid trouble in case of catastrophic hardware failure or other
    unpleasant truths of Murphy's Law.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Here is Murphy''s Law:**'
  prefs: []
  type: TYPE_NORMAL
- en: '"If anything can go wrong, it will."'
  prefs: []
  type: TYPE_NORMAL
- en: Always plan for problems — Hardware failure, data corruption, and security breaches
    just begin the list of issues plaguing our work.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent Versions System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Concurrent Versions System (CVS) is hosted at [http://www.nongnu.org/cvs/](http://www.nongnu.org/cvs/)
    and is the oldest form of revision control. CVS is very stable, and has been stable
    for years. As such, it is the old warhorse of revision control, having stood the
    test of time. CVS is based on a very simple file-based revision control. In the
    repository, each file contains content and metadata containing differences between
    revisions. The repository should never be used for direct access or work. Instead,
    a complete copy of a directory is checked out for development. No changes are
    saved to the main repository until you check in or commit the code.
  prefs: []
  type: TYPE_NORMAL
- en: CVS is designed to coordinate the work of multiple developers, and as such has
    the capability to refuse a commit if there may be a conflict between the work
    of two different developers. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP repository has several modules hosted by `cvs.php.net`, which are organized
    like a file system. To check out a module, you must first log into the CVS server.
    Users with accounts will use their account name, but PHP also provides anonymous
    read-only CVS access. To log into the CVS server, one types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `cvs` command will prompt for a password. For anonymous
    CVS access, enter your email address. Once you are logged in, check out a module.
    For instance, to view the source of the PEAR_PackageFileManager package, you would
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the directory `pear` and subdirectory `PEAR_PackageFileManager`,
    and populates them with all the files and directories contained within the project.
    In addition, it creates special directories named `CVS` that contain information
    about the state of the local copy of the repository. Each directory must contain
    files named `Entries, Root`, and `Repository`. Depending on the state of the repository,
    there may be other files as well. These files should *never* be hand-altered except
    in extreme circumstances, but it is important to know what controls your CVS checkout.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and help on using CVS, it is probably good to start by
    reading the *manpage on unix* via `man cvs`, and to read the CVS book published
    by O'Reilly and distributed online under the GNU General Public Licence at [http://cvsbook.red-bean.com/](http://cvsbook.red-bean.com/).
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, it is probably easiest to use a tool like **TortoiseCVS**, which
    is available from [http://www.tortoisecvs.org](http://www.tortoisecvs.org). This
    free tool adds an extension to Windows Explorer that allows direct manipulation
    of CVS checkouts and repository simply by right-clicking on files or directories
    with the mouse. It is very intuitive and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a CVS Repository
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in setting up a CVS repository is to determine where you are
    going to put the repository. CVS has several methods of connecting to the repository
    remotely. In most cases, it is best to require access through secure shell (**SSH**),
    via the `ext` method, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Parsing this command line further, the `-d` option tells CVS where to locate
    the root of CVS, or `CVSROOT`. In this case, it tells CVS to connect to the remote
    CVSROOT at `cvs.phpdoc.org` via the `pserver` protocol, using the `cellog` username.
    In addition, it informs the remote CVS daemon that the CVSROOT is located at `/opt/cvsroot`.
    On `cvs.php.net`, the CVSROOT is located at `/repository`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're on a shared host, assuming your remote username is `youruser`, it
    is probably best to put the `cvsroot` in `/home/youruser/cvs` or something of
    that nature. Otherwise, you are not likely to have write access to the directory
    in which you initialize your CVS repository. Obviously, write access is very important;
    otherwise there is no way to commit code from a development sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have decided where to put the CVS repository, the next step is to
    initialize it. This is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creates the `/home/youruser/cvs/CVSROOT` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create the module you will use for the website. Before importing
    the website, first create the module for the website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a module named `website` that can be checked out. To ensure
    success, check out a copy of the `website` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, this will result in the creation of directory `/home/youruser/website`
    and the file `/home/youruser/website/README`. To test that CVS is accessible remotely,
    check out a copy of the `website` module via something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next step is adding the contents of the website into the CVS repository.
    Simply copy all of the website files with the directory hierarchy you desire into
    your local checkout of the `website` module. The next step is the most complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Most websites contain both text files (like our PHP scripts) and binary files,
    like images or sound clips. CVS treats binary and text files differently. Text
    files are processed, and special CVS in-file tags like `$Id$` or `$Revision$`
    are replaced with special values based on the state of the file in the repository.
    Tags like "$Id$" must be manually added to the files by the developer, CVS does
    not create them automatically. Binary files are treated as a single entity, and
    their contents are not touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding files to a CVS module, they must first be added via the `cvs add`
    command, and then committed via the `cvs commit` command. Text files and directories
    are simply added like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Binary files are added with the `-kb` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Files can be added with wildcards, but be very careful to ensure that you do
    not add image files as text files or text files as binary! In the worst case,
    you can remove files prior to committing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that files that have been committed to the repository must be deleted
    prior to removal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Windows, TortoiseCVS makes adding files far easier, as it does
    so recursively and hides the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subversion was developed a few years ago to address some of the shortcomings
    of CVS. Specifically, Subversion stores the repository information using a database,
    and so supports grouping changes together by commit rather than by file. Subversion
    is newer and as such has not been battle-tested as long as CVS, but both have
    been used in production for years.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://svnbook.red-bean.com](http://svnbook.red-bean.com) contains several
    different formats of the same book as published by O''Reilly. The Subversion book
    contains everything needed to set up, configure, and administer a Subversion repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subversion differs from CVS in a few important ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete copy of the remote repository is stored locally, simplifying diffs
    and making it possible to do this offline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags are stored as branches, unlike CVS. In CVS, tags are read-only and it is
    difficult to accidentally modify a tag. Modifying a branch is quite simple, and
    because tags are branches in Subversion, this makes it more difficult to implement
    a read-only tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large files are easier to manage. Because the sandbox contains a complete copy
    of the current state of the repository module, this means that committing large
    text files only requires sending a diff. Ultimately, this saves both bandwidth
    and processor cycles on the server, which can be very important. (I once locked
    up the entire live server requiring a reboot just by committing a minor change
    to a 133MB database dump in a CVS repository. This was bad.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keywords (`$Id$, $Revision$`, and so on) are not substituted by default; all
    files in subversion are treated as binary files. To set a keyword substitution
    for a file, you need to set a property with something like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More information is available at [http://svnbook.red-bean.com/nightly/en/svn.advanced.props.html#svn.advanced.props.special.keywords](http://svnbook.red-bean.com/nightly/en/svn.advanced.props.html#svn.advanced.props.special.keywords)
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Subversion Repository
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like CVS, setting up a repository is relatively painless. Simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a Subversion repository as a subdirectory of the current directory.
    To import your website code into the repository, first set up the standard Subversion
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the complete contents of your current website into the `website/trunk`
    directory. Finally execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have successfully imported, test by checking out the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WARNING: check out website/trunk, not website.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you check out the entire module, you will get all branches and tags as well.
    This will eventually eat up all available disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the `website` module remotely requires that either the `svnserve`
    daemon is running or that `mod_svn` is running as an Apache web-server module.
    Consult the Subversion book at [http://svnbook.red-bean.com](http://svnbook.red-bean.com)
    for extended details on setting this up if one is not set up for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running `svnserve`, either check out via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you support the highly recommended secure shell (SSH) tunneling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, if you have `mod_svn` running, checking out is far simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you have a secure server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These commands will create a directory named `website` that contains the code
    for your website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding and removing files in a Subversion repository is very straightforward,
    and similar to CVS. Simply use this format to add a file or directory from within
    the `website` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this format to remove a file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with CVS, it is possible to move files around or copy them, retaining
    their revision history, with the `move` and `copy` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to have keywords like `$Id$` or `$Revision$` replaced, you need
    to manually tell Subversion to perform this substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough information to get started with using the repository that
    you choose to use.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent Source Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, now you have a version control repository set up and configured. Great!
    What next? Using a version control system intelligently is a very important step.
    Basic principles should be followed to ensure this is happening. Although many
    are common sense, it is not easy to remain vigilant and adhere to them.
  prefs: []
  type: TYPE_NORMAL
- en: Make regular backups of your repository and store them on independent media
    from the machine hosting the repository. If you remember nothing else, remember
    this!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only commit working code to the repository — test before committing to avoid
    obvious errors like syntax errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tags to mark point releases of working code that will be deployed to a live
    server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use branches to support innovation and stable code bases simultaneously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have multiple developers, define some basic coding standards (like PEAR's
    coding standards) so that diffs between revisions do not contain spurious changes
    to whitespace and other noise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have multiple developers, set up a mailing list that is explicitly for
    commits to the repository. There are many excellent programs available for use
    in post-commit scripts that will mail diffs to a mailing list. Ensure that every
    developer is subscribed to the mailing list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining Branches for Complex Versioning Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Branches** allow development of more than one version of the same software
    at the same time. For instance, when software has reached stability, and major
    new features will be added, branch off a copy of the software so that small bugs
    can be fixed in the stable version at the same time as development continues.
    Best practice has the stable version branched off and development continuing on
    HEAD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop the stable version 1.2.X in a branch using CVS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `update` command is an unintuitive requirement, but is very important; without
    updating your sources, you will not be editing the branch code, and any changes
    will end up on HEAD.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good idea to have two separate directories. For instance, when developing
    PEAR version 1.5.0 I have two directories that I use, which are created like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because I specified the `-d pear1.4` option to the `checkout` command (abbreviated
    as `co`), the files will be checked out to the `pear1.4` directory. The `-r PEAR_1_4`
    option retrieves the PEAR_1_4 branch for fixing bugs in PEAR version 1.4.X. In
    the second case, files from the default HEAD branch are checked out to the `pear-core`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same task using Subversion is performed by something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using Tags to Mark Point Releases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tags are important for several reasons, not the least of which is the ability
    to reconstruct older releases in the event of a disastrous loss of data. There
    are two ways to create a tag using CVS. The recommended way is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This command parses `package.xml`, and for each file found, that file is tagged
    with `RELEASE_X_Y_Z` where X_Y_Z is the version number. Version 1.2.3 will be
    tagged with `RELEASE_1_2_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tagging manually from within the module checkout can be accomplished with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Subversion does not differentiate between tags and branches, so the only difference
    between creating a tag and a branch is where you copy it with the `svn` copy command.
    By default, tags should be copied to the trunk/tags branch using `svn` copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The Solution, Part II: Using the PEAR Installer to Update the Website'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be familiar with the basic usage of both the PEAR
    installer and a source control system. Now we will take that knowledge to the
    next level and discover how to use the strengths of both tools to manage the complexity
    of a multi-segment website with inter-dependencies. First, it is important to
    think of the website code in terms of discrete packages and dependencies. To do
    this, it is often helpful to use a diagram. For complex systems, it makes a great
    deal of sense to use the **Uniform Modelling Language** (**UML**) to describe
    the system, as this is the universal standard of description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine a real-world example: the Chiara String Quartet website, [http://www.chiaraquartet.net](http://www.chiaraquartet.net).
    As of early 2006, this is a mid-size website designed by a single developer, but
    the principles would scale well to a multi-developer situation. The website consists
    of a number of sub-sites as well as the main site.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of a few days prior to publication, the Chiara Quartet's website is now managed
    by an independent developer, and is no longer maintained directly by the author
    as described. For an example of a website that is being manged using `package.xml`,
    at the time of publication, `pear.php.net` was migrating to this approach. Check
    out the pearweb module from `cvs.php.net`, and the `package.php` script and corresponding
    `package.xml` and post-installation script which can be used to set up a MySQL
    database and configure `http.conf` file for a development copy of `pear.php.net's`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public sites are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.chiaraquartet.net](http://www.chiaraquartet.net) (main site)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://music.chiaraquartet.net](http://music.chiaraquartet.net) (MP3s/audio
    samples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://calendar.chiaraquartet.net](http://calendar.chiaraquartet.net) (schedule
    information)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The private back-end sites include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://addressbook.chiaraquartet.net](http://addressbook.chiaraquartet.net)
    (data entry for contact database)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://database.chiaraquartet.net](http://database.chiaraquartet.net) (management
    of general back end data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these sites has an independent code base, but there are interlinked
    dependencies on elements such as images and templates used to unify the look of
    different sites. In addition, as the quartet's career grows, the needs of the
    website change dramatically, and the ability to add new sub-sites and remove obsolete
    ones is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Also important is to note that very large files are needed, such as high resolution
    press pictures and MP3 audio clips that will not change as regularly as the PHP
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, the website can be grouped into several simple packages:'
  prefs: []
  type: TYPE_NORMAL
- en: website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website database back end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website contact data entry back end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website MP3s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: website press PDFs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary website package itself can be broken up at a later date into separate
    packages such as a primary website and a website blog package without penalty
    through a couple of methods that we will examine later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have determined the logical partitioning of the website into packages,
    all that is needed is to create a private channel, generate proper `package.xml`
    files for each package, and install the website. Each component can be upgraded
    — and downgraded — independently, making maintenance and tracking changes far
    less of a magical ritual.
  prefs: []
  type: TYPE_NORMAL
- en: A wonderful technique for backing up a database is not only to save full dumps,
    but to commit these to a Subversion repository. This way, you are storing smaller
    versions and have the capability to check out the database dump on a remote machine
    for development and testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion is greatly preferred to CVS because it handles extremely large files
    far more gracefully. CVS can easily bring down an entire machine when calculating
    the difference between two 150 MB database dumps. I learned this the hard way.
    Subversion is far superior in this regard simply because it calculates differences
    using the local copy, and so only differences are sent back and forth, reducing
    net traffic exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that if there is any private data in the database, access
    should be restricted to `svn+ssh` in order to reduce the possibility of accidentally
    giving the sensitive data to the wrong people.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, if there are any crucially sensitive data such as credit-card
    numbers or data that identity thieves would love to get their hands on, do not
    allow any remote access to the data whatsoever; instead resort to a tool like
    rdiff-backup ( [http://www.nongnu.org/rdiff-backup/](http://www.nongnu.org/rdiff-backup/)).
  prefs: []
  type: TYPE_NORMAL
- en: When porting an existing website, it is best to add it to CVS/Subversion in
    exactly the source layout of the existing website.
  prefs: []
  type: TYPE_NORMAL
- en: 'One difficulty in developing a remote website is the need for code that understands
    it will run on a different IP and possibly a different hostname. There are three
    ways of handling this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the live host name to the `/etc/hosts` file as an alias to localhost, so
    all requests go to localhost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use host-neutral code, for example depending on the `$_SERVER['HTTP_HOST']`
    variable used by the Apache web server, or `$_SERVER['PHP_SELF']`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use PEAR's replacements facility and custom file roles to define per-machine
    host information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the live host name to the `/etc/hosts` file (usually `C:\WINDOWS\system32\drivers\etc\hosts`
    on Microsoft Windows systems) will make it impossible to actually access the live
    web server — or FTP server — from the development machine, and so is no solution
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Using host-neutral code appears to be a good idea at first, but as recent security
    concerns have shown, cross-site scripting (XSS) attacks thrive on vulnerabilities
    created through the use of these tools. Although it is not difficult to avoid
    the security issues, it does add considerable complexity, and makes the chance
    of introducing another bug or security issue higher than is comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: The third option involves creating custom PEAR installer file roles that define
    special configuration variables, and then coupling these with PEAR's replacement
    task to customize files automatically per-machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, our example website, [http://www.chiaraquartet.net](http://www.chiaraquartet.net),
    would require setting up virtual hosts `www.chiaraquartet.net, database.chiaraquartet.net,
    music.chiaraquartet.net`, and `calendar.chiaraquartet.net` on the development
    machine. What a pain! Instead, I created two custom packages that define five
    configuration variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root_url:` This defines the base URL of the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`music_url` :This defines the base URL of the music-audio portion of the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calendar_url:` This defines the base URL of the concert and event schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addressbook_url:` This defines the base URL of the back-end contact list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database_url:` This defines the base URL of the back-end database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the *development* server, I set these configuration variables to their needed
    values with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'On the *live* server, I set the configuration variables to their needed values
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to set this information directly in the source, I use something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `@DATABASE-URL@` value will be replaced with the value of the `database_url`
    configuration variable if this tag is specified in `package.xml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After this work, when installed on the local *development* machine, the code
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And on the *live* server, the code will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The best thing about this is that the URL is guaranteed to be correct on both
    machines without any extra work. This basic principle can also be applied for
    any important difference between development and live servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another specific difference between standard library packages and websites
    is that websites should be installed into publicly accessible directories, but
    standard library package files should be installed into non-accessible locations.
    For this purpose, we have default configuration variables like `php_dir, data_dir`,
    and `test_dir`. There is no default role for web files. Fortunately, a custom
    file role package does exist on the `pearified.com` channel. To acquire this package,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use it in `package.xml`, simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you should specify a required dependency on `pearified.com/Role_Web`
    and a`<usesrole>` tag as described in [Chapter 2](ch02.html "Chapter 2. Mastering
    PHP Software Management with the PEAR Installer").
  prefs: []
  type: TYPE_NORMAL
- en: After these details are worked out, it is time to generate the `package.xml`
    files that are needed by the PEAR installer in order to manage installation of
    the website.
  prefs: []
  type: TYPE_NORMAL
- en: Generating package.xml from the Source Control Checkout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate `package.xml`, there are a number of options available. The oldest
    and simplest for a complex website is to use the PEAR_PackageFileManager package
    to create a `package.xml` generation script. The script should generate each `package.xml`
    file that is needed, making it simple to update. In addition, it should correctly
    ignore irrelevant files and sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generation script for our real website, [http://www.chiaraquartet.net](http://www.chiaraquartet.net),
    was maintained using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The next section simply sets release notes and versions for each sub-package's
    `package.xml` in a centralized location near the top of the file, making it easier
    to edit the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create each of the `package.xml` files by importing from the existing
    `package.xml` for each sub-package. We''ll cut out a few of the sub-packages,
    just for brevity. Here is a typical one (website images):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will add replacement tasks to all files, demonstrating the customization
    we need for development versus production machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This next line is crucial; we need to ignore the contents of all the sub-packages,
    or they will be duplicated and will conflict with the parent package!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add dependencies on each of the sub-packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create each of the `package.xml` files or display them for error-checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Each sub-package has its own PEAR_PackageFileManager2 object, and imports options
    from an existing `package.xml`, only modifying what is necessary. To create the
    `package.xml`, I copied an existing one from a PEAR package (in this case, PEAR's
    own `package2.xml`), and modified the sections`<summary>, <description>, <license>`,
    and the list of maintainers to suit the website package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the script, I saved it as `package.php` and now run it with PHP 5.1.0
    or newer, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows me to view the `package.xml` files and check them for errors. To
    save changes to `package.xml`, I run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! `package.xml` is created in `website/, website/database, website/calendar,
    website/press`, and `website/music`.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we are ready to start making releases of the code and deploying
    it to a test server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging: Coordinating Release Versions with Tags and Branches'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arriving at this stage means we are ready to start packaging our website up
    into PEAR packages for installation. At this point, the process begins to merge
    with the packaging we learned to do in the previous chapter. Ultimately, this
    is the reason that packaging a website using the PEAR installer is a good idea.
    The process of installing, upgrading, and even reverting the website is no different
    from installing, upgrading, and reverting any PEAR package. This process makes
    it incredibly simple to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'When converting from the old way of managing a website to the PEAR way, there
    are several important steps that must be undertaken:'
  prefs: []
  type: TYPE_NORMAL
- en: Test the release on a local development server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back up the live server immediately prior to deployment if possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the PEAR package on the remote server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the website has been successfully deployed, then it is a simple process
    of upgrading the respective package on the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a release is made, it is very important to mark that release in the source
    control system using a tag. If you chose to use CVS, tagging is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically scan `package.xml` for the files contained within the
    release, and using the release version will create a tag named `RELEASE_X_Y_Z`
    and apply it to all of the files. If the release version is 0.10.0, the tag will
    be `RELEASE_0_10_0`, if the release version is 1.2.3, the tag will be `RELEASE_1_2_3`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tagging with Subversion is not quite as automatic, but is accomplished simply
    via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With these steps, release version X.Y.Z is tagged.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Release before Uploading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are ready to deploy the website, it is important to create a test
    package and install it locally to ensure that all is OK. Output from packaging
    will be something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What about all those "Warning: in index.php..." Things?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning is intended for those folks who are actively developing for the
    official PEAR repository at [http://pear.php.net](http://pear.php.net) to help
    catch cases where classes are misnamed. We could easily eliminate these warnings
    by creating a custom channel validator as discussed in [Chapter 5](ch05.html "Chapter 5. Releasing
    to the World: PEAR Channels"), but this is unnecessary since we know that they
    are superfluous warnings (one of the advantages of having written the software
    or of having read this book!)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, browse to every page and click links (or run your test suite if you have
    one) to be sure that it is working properly. Once you are convinced it is ready
    and working, it is time to upgrade the live server.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the Live Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it is actually possible to upgrade the live server without taking
    steps to shut it down, this is generally a bad idea. It is in fact best to create
    a test directory with an `index.html` and a `404.html` file; something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, save an `.htaccess` file (assuming you are using Apache) that looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is assuming your web host has `mod_rewrite` enabled in Apache (not all
    hosts do). Better yet, if you have access to `httpd.conf`, simply change the directory
    for `DocumentRoot` to the test directory, and add the `ErrorDocument` reference.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the PEAR installer uses atomic file transactions, there is very little
    chance of ending up with a half-done install. The purpose of the temporary site
    is to avoid users having to see the site should there be any major problems. You
    can test the site by adding a RewriteCond rule that specifies your computer's
    IP will ignore the rule, which allows you to see the full site and detect any
    problems that need to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the site properly hidden behind a RewriteRule, it is time to
    actually upgrade the site. First, check out a copy of the website from source
    control using `cvs checkout` or `svn checkout` as we learned at the beginning
    of this chapter. Next, we need to create the package and install it. Before we
    can do this, we need to install all of the necessary custom file roles we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to initialize the custom file roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is complete, we are ready to begin installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now that we have finished the initial installation, upgrading to
    the next version when it is time is as easy as it gets.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pear upgrade Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this section, we will use CVS as our source-control example, but substitute
    what we've learned about Subversion if you are using a Subversion repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to fix a bug or add a new feature, simply modify the release
    notes from the `package.php package.xml` generation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `package.xml` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, commit your work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, test on the local server via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And when you are certain it works on the remote server, simply run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, you have successfully upgraded to version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you discover a critical error in version 0.11.0 that didn''t
    exist in version 0.10.0? Fortunately, the sequence to fix the problem is straightforward
    and elegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Two lines of typing is all that you need. This is assuming you kept the 0.10.0
    release tarball sitting around. Even if you didn''t, the process is still very
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, the last line returning to `HEAD` of CVS is not really necessary
    for the recovery of the website, but it will save later headaches when you have
    forgotten that you have checked out the `RELEASE_0_10_0` tag. The same process
    is also simple in Subversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the $10 million question: how can you perform these tasks if you have
    no shell access on the remote server, as many folks on shared hosts have experienced?
    (Hint: read the section on *PEAR_RemoteInstaller* in [Chapter 1](ch01.html "Chapter 1. Acquiring
    PEAR: What is it and How do I Get It?"), and you''ll have the answer).'
  prefs: []
  type: TYPE_NORMAL
- en: The Real Beauty of Using Pear to Fix Problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The worst moment in a web developer''s life is when a serious flaw is discovered
    in a website. It is often difficult to quickly revert to an older version. The
    PEAR installer makes this process simple. If testing determines that the problem
    was introduced in version 1.2.3 and does not exist in version 1.2.2, reverting
    to version 1.2.2 is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Or if you have set up a channel (we'll assume you have aliased it as `private):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Abbreviated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In addition, any required dependencies will also be downgraded if you pass in
    the `-o` command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have seen how to use PEAR installer to manage a complicated
    and rapidly evolving website. We saw a number of issues involved in the development
    of a website, such as code breakage, missing or extra files, and how the PEAR
    Installer can help us with them.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to set up a revision control system, either CVS or Subversion.
    Finally, we saw how to use PEAR installer and source control systems to update
    a website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter you will learn about ways of publicly distributing your
    libraries and applications over the Internet.
  prefs: []
  type: TYPE_NORMAL
