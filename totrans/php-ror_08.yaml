- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Models, DBs, and Active Record
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型、数据库和 Active Record
- en: The **M** in the **MVC** application design pattern stands for **model**, and
    in this context, we will be using Ruby’s model abstraction to connect to a database
    using another design pattern called Active Record. We must remember that while
    models are mostly used to connect to databases, they can also be used to connect
    to other data sources. We could have a model connect to a filesystem, a web service,
    and so on. The purpose behind a model is to organize our business rules, and that
    purpose may include connecting to various data sources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **MVC** 应用程序设计模式中，**M** 代表 **model**，在这个上下文中，我们将使用 Ruby 的模型抽象通过另一个称为 Active
    Record 的设计模式连接到数据库。我们必须记住，虽然模型主要用于连接到数据库，但它们也可以用于连接到其他数据源。我们可能有一个模型连接到文件系统、Web
    服务等等。模型背后的目的是组织我们的业务规则，而这个目的可能包括连接到各种数据源。
- en: In this chapter, we will first generate a model using some of our command-line
    generators in Rails. Then, we will use this model to connect to our database.
    Finally, we will look at Active Record and perform operations inside our database
    in a very intuitive way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先使用 Rails 的一些命令行生成器生成一个模型。然后，我们将使用这个模型连接到我们的数据库。最后，我们将查看 Active Record
    并以非常直观的方式在我们的数据库中执行操作。
- en: 'With this purpose and Active Record in mind, in this chapter, we will cover
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个目的和 Active Record 的想法，在本章中，我们将涵盖以下主题：
- en: Generating models using Rails
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rails 生成模型
- en: Connecting to a database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Active Record operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Active Record 操作
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的内容，您需要以下内容：
- en: Any IDE to view/edit code (e.g. SublimeText, Visual Studio Code, Notepad++ Vim,
    Emacs, etc.)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何用于查看/编辑代码的 IDE（例如 SublimeText、Visual Studio Code、Notepad++ Vim、Emacs 等）
- en: For macOS users, you will also need to have the Xcode command line tools installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您还需要安装 Xcode 命令行工具
- en: Ruby version 2.6 or later installed and ready to use
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并准备好使用的 Ruby 版本 2.6 或更高版本
- en: Git client installed on your local machine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地机器上安装 Git 客户端
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在 [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)
    找到。
- en: Generating models using Rails
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rails 生成模型
- en: 'Models are abstractions of objects we might find in everyday life. Whether
    they are people, books, or cars, a model serves as a representation of those objects
    on the database. And just like controllers, Rails comes with generators that help
    us create models in a very easy and intuitive way. But first, let’s set up our
    environment. You can either start where we left off in the previous chapter, or
    download the example code for this chapter. If you haven’t yet done so, open a
    terminal and type the following `git` command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是我们可能在日常生活中找到的对象的抽象。无论是人、书还是汽车，模型都充当数据库中这些对象的表示。就像控制器一样，Rails 内置了生成器，可以帮助我们以非常简单直观的方式创建模型。但首先，让我们设置我们的环境。您可以选择从上一章结束的地方开始，或者下载本章的示例代码。如果您还没有这样做，请打开终端并输入以下
    `git` 命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you have already done so, then just navigate to the `chapter08` folder within
    your project by running the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经这样做，那么只需通过运行以下命令导航到您项目中的 `chapter08` 文件夹：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, let’s install our dependencies with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们使用以下命令安装我们的依赖项：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And to confirm our setup was done correctly, let’s run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的设置是否正确，让我们运行以下命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should read something like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now we are ready to generate our model. We will generate a model that represents
    people. We will add an attribute called `name` for each person, and another attribute
    called `birthday`. To generate our model, let’s type the following command on
    our shell:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好生成我们的模型了。我们将生成一个代表人的模型。我们将为每个人添加一个名为 `name` 的属性，另一个名为 `birthday` 的属性。要生成我们的模型，让我们在我们的
    shell 中输入以下命令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this command, we are telling our Rails generator to create a model called
    `Person` with an attribute called `name`, and another attribute called `birthday`.
    The `name` attribute will be a string, and the `birthday` attribute a date. Once
    we press the *Enter* key, we should see the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我们告诉我们的Rails生成器创建一个名为`Person`的模型，它有一个名为`name`的属性，还有一个名为`birthday`的属性。`name`属性将是一个字符串，而`birthday`属性是一个日期。一旦我们按下*Enter*键，我们应该看到以下输出：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we look closely at this output, we should notice two important files that
    have been created, the migration and the model itself. Let’s first open our migration
    file, `db/migrate/20230727031200_create_people.rb`. Its contents should look something
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察这个输出，我们应该会注意到两个重要的文件已经被创建，一个是迁移文件，另一个是模型本身。让我们首先打开我们的迁移文件，`db/migrate/20230727031200_create_people.rb`。其内容应该看起来像这样：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This file includes the instructions to generate our database structure. If we
    look closely, it states that it will create a `people` table with the `name`,
    `birthday`, and `timestamps` columns. Why was this file needed? To answer that
    question, we need to take a look at what Rails migrations are.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含了生成我们数据库结构的指令。如果我们仔细观察，它指出将创建一个包含`name`、`birthday`和`timestamps`列的`people`表。为什么需要这个文件？要回答这个问题，我们需要看看Rails迁移是什么。
- en: Rails migrations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rails migrations
- en: In the old days, keeping track of a **database** (**DB**) was a hassle. Whenever
    you worked on a project with other developers that required a DB, someone had
    to create the DB and its tables, and often also populate it with testing data.
    If someone new joined the team, you would just hand them a copy of the DB and
    off they would go. But wait – what would happen if someone made changes to the
    DB structure? What if we needed a new field? What if a field was no longer needed?
    Then, whoever was in charge of this DB would have to make the change and then
    hand out the new copy of the DB to all the developers in the team. You can see
    how this might get out of control, especially if you have more than two developers
    working on the same project. In comes migrations to the rescue!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，跟踪一个**数据库**（**DB**）是一件麻烦事。每当你在需要数据库的其他开发者项目上工作时，总有人需要创建数据库及其表，并且通常还需要填充测试数据。如果新成员加入团队，你只需给他们一个数据库的副本，他们就可以开始工作了。但是等等——如果有人修改了数据库结构会怎样？如果我们需要一个新的字段呢？如果某个字段不再需要了呢？那么，负责这个数据库的人将不得不进行更改，然后将新的数据库副本分发给团队中的所有开发者。你可以看到，如果项目上有两个以上的开发者，这种情况可能会变得难以控制。这时，迁移就出现了来拯救我们！
- en: 'A migration is a series of commands to rebuild the structure of a DB in sequence.
    In the same hypothetical example that I just outlined, migrations would solve
    the problem with no issues. Initially, you would create a migration that created
    a table with certain fields. If the table required a new field, you would create
    another migration to create that new field. If a field was no longer required,
    you would create a migration to remove that field. And, as you may have noticed,
    the name of the migration has a timestamp. This is to run the migrations in sequence
    – we would first create the table, then add a field, and lastly remove a field.
    If a new developer joined the team, they could just run all the migrations and
    have the exact same database structure that everyone else has. Back to the migration
    at hand, we have the instructions (migration) but we still need to execute these
    instructions to impact the DB. So now, let’s run the command to execute this migration.
    On the command shell, type the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是一系列按顺序重建数据库结构的命令。在刚才我刚刚概述的假设例子中，迁移可以无问题地解决这个问题。最初，你会创建一个迁移来创建一个具有特定字段的表。如果表需要一个新的字段，你会创建另一个迁移来创建那个新字段。如果某个字段不再需要，你会创建一个迁移来删除那个字段。而且，你可能已经注意到了，迁移的名称有一个时间戳。这是为了按顺序运行迁移——我们首先创建表，然后添加字段，最后删除字段。如果新开发者加入团队，他们只需运行所有迁移，就可以拥有与所有人相同的数据库结构。回到当前的迁移，我们有（迁移）指令，但我们仍然需要执行这些指令来影响数据库。所以现在，让我们运行命令来执行这个迁移。在命令行中，输入以下命令：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should output the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that our DB structure has been created, with a table called `people`.
    This is part of the Rails magic. We have not configured any DB on our project,
    yet if this command is successful, it means that Rails is connected to a DB. The
    reason behind this is that the Rails developers wanted you to have a ready-to-use
    project out of the box, and to do this, they made the initial project connect
    to a database called SQLite by default. SQLite is a series of libraries that allow
    us to have a ready-to-use, lightweight database based on a `sqlite3` file in your
    project. If you’re interested in this topic, I recommend you read the SQLite official
    page: [https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的数据库结构已经创建，有一个名为`people`的表。这是Rails魔法的部分。我们还没有在我们的项目中配置任何数据库，但是这个命令成功执行，这意味着Rails已经连接到了一个数据库。背后的原因是Rails的开发者希望您能够直接使用一个现成的项目，为此，他们让初始项目默认连接到一个名为SQLite的数据库。SQLite是一系列库，允许我们使用基于项目中的`sqlite3`文件的轻量级数据库。如果您对这个主题感兴趣，我建议您阅读SQLite官方页面：[https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)
- en: We’ve now generated our model and we’re ready to move on to the next section,
    where we will connect to our database using our model and the Rails configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经生成了模型，并准备好进入下一部分，我们将使用我们的模型和Rails配置来连接到数据库。
- en: Connecting to a database
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'So far, we’ve created a `Person` model and the migrations needed for the structure
    of our database. Now we are ready to connect to our database. But wait, we’ve
    already connected to a database! As previously stated, if we were able to run
    our migration successfully, it means that we did indeed connect to the SQLite
    database. Now let’s take a look at how Rails is configured to do this. Let’s examine
    our Gemfile, and in doing so, we’ll see the following line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个`Person`模型以及我们数据库结构所需的迁移。现在我们准备连接到我们的数据库。但是等等，我们之前已经连接到一个数据库了！正如之前所述，如果我们能够成功运行迁移，这意味着我们确实连接到了SQLite数据库。现在让我们看看Rails是如何配置来做到这一点的。让我们检查我们的Gemfile，在这个过程中，我们会看到以下这一行：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding line installs the `sqlite3` gem that allows Rails to communicate
    with a SQLite database. But wait, there’s more. If we open the `app/config/database.yml`
    file, we will also see some of the database settings for our project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行安装了`sqlite3`gem，它允许Rails与SQLite数据库通信。但是等等，还有更多。如果我们打开`app/config/database.yml`文件，我们还会看到我们项目的数据库设置：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `default` stanza defines the database adapter as `sqlite3` and the environment
    sets the database source file to be in `db/development.sqlite3` . If we check
    this, we’ll see that the file is indeed there. The Rails migration command is
    the one responsible for creating this file. Don’t bother opening the file as it
    is a binary file and unless you have a plugin to read SQLite files on your IDE,
    you’ll only see data that only makes sense to computers and not to humans. Now
    let’s use this newly acquired information to actually manipulate data in the database
    with the Rails console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`部分定义了数据库适配器为`sqlite3`，环境设置数据库源文件位于`db/development.sqlite3`。如果我们检查这个，我们会看到文件确实存在。Rails迁移命令是负责创建这个文件的命令。请不要打开这个文件，因为它是一个二进制文件，除非你在IDE上安装了读取SQLite文件的插件，否则你只能看到对计算机有意义而对人类无意义的数据。现在让我们使用这些新获得的信息，实际上使用Rails控制台来操作数据库中的数据。'
- en: The Rails console
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rails控制台
- en: 'The creators of Rails have made an enormous effort to make Ruby on Rails the
    framework of choice to pair with Rails. As such, they were inspired by some of
    the tools that come with Ruby, and more specifically the **Interactive Ruby**
    (**IRB**) console. Rails comes with a similar console but tweaked to be able to
    load and query Rails components. Let’s try it out with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rails的创造者付出了巨大的努力，使Ruby on Rails成为与Rails搭配的首选框架。因此，他们受到了Ruby附带的一些工具的启发，特别是**交互式Ruby**（**IRB**）控制台。Rails附带了一个类似的控制台，但经过调整，可以加载和查询Rails组件。让我们用以下命令试一试：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will show the following output and enable us to interact with Rails:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出，并使我们能够与Rails交互：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And this is where our `Person` model comes in handy. Let’s create a new object
    called `single_person` and add some data to our database. Inside this Rails console,
    let’s run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，我们的`Person`模型派上了用场。让我们创建一个名为`single_person`的新对象，并将一些数据添加到我们的数据库中。在这个Rails控制台中，让我们运行以下命令：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will create an object based on the `Person` model that we defined with
    our `Model` file and the migrations. The previous command will output the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于我们通过`Model`文件和迁移定义的`Person`模型创建一个对象。前面的命令将输出以下内容：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see that we’ve created an empty object that has no ID, no name, and
    no birthday. Now let’s set the object’s name and birthday. We’ll do this by first
    typing the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经创建了一个没有ID、没有名字和没有生日的空对象。现在让我们设置对象的名字和生日。我们将通过首先输入以下命令来完成：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our prompt will confirm with the following output that we’ve set the name:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的提示将使用以下输出确认我们已经设置了名字：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let’s set the birthday with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令设置生日：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’re setting a date in the `year-month-day` format. The preceding command
    sets the birth date to February 3, 1986\. And just like the previous command,
    it will confirm this by returning the value we’ve just set:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在以`year-month-day`格式设置日期。前面的命令将出生日期设置为1986年2月3日。就像前面的命令一样，它将通过返回我们刚刚设置的值来确认这一点：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can go a little further with our object and see what attributes we’ve set
    so far by just typing the name of our `single_person` variable and view the contents
    of the object. Let’s do that as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步了解我们的对象，通过仅输入我们的`single_person`变量名来查看我们迄今为止设置的属性。让我们这样做：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding comand will return the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将返回以下输出：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One thing to remember is that this information is still only available in memory.
    We have not persisted (or written) the data into the database. You’ll hear the
    term *persist* often when dealing with databases, and it refers to writing the
    data into the database. As it stands now, if we were to leave the Rails console,
    the data would be lost. How do we persist the data, you may ask? Simple: we call
    the `save` method from our `single_person` object. But before we do that, let’s
    confirm that there is no data in our database. We will do so by typing the following
    static method from our `Person` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，这个信息目前仅在内存中。我们还没有将数据持久化（或写入）到数据库中。你可能会经常听到*持久化*这个词，当处理数据库时，它指的是将数据写入数据库。按照现在的状况，如果我们离开Rails控制台，数据将会丢失。你可能会问，我们如何持久化数据？简单：我们调用`single_person`对象的`save`方法。但在我们这样做之前，让我们确认我们的数据库中没有数据。我们将通过输入以下来自`Person`类的静态方法来完成：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will output the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This output shows a command in the **Structured Query Language** (**SQL**)
    used by databases to manipulate data. SQL is a standard language used to “talk”
    to databases. Many databases use this language, so you don’t have to learn a different
    language for each one. If you wish to know more about SQL, I recommend you take
    a look at this page:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了数据库用于操作数据的**结构化查询语言**（**SQL**）命令。SQL是一种标准语言，用于“与”数据库“交流”。许多数据库使用这种语言，因此你不需要为每个数据库学习不同的语言。如果你想了解更多关于SQL的信息，我建议你查看这个页面：
- en: '[https://aws.amazon.com/what-is/sql/](https://aws.amazon.com/what-is/sql/)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/what-is/sql/](https://aws.amazon.com/what-is/sql/)'
- en: 'If you have not encountered SQL commands before, this might seem a little cryptic,
    but believe me, it is not so bad in reality. The first part of the output tells
    us Rails is loading a SQL command, the command being `SELECT "people".* FROM "people"`.
    The star (`*`) is a filter to select all of the fields associated with the `people`
    table. In this case, it means that Rails will fetch the ID, `name`, `birthday`,
    and `timestamp` fields. The `FROM` part of the command tells the database engine
    to fetch entries from the `people` table without any filters. Lastly, the last
    line of the output tells us that there are no entries in the people table. As
    I mentioned before, the data is still in memory, so now let’s persist the data
    into the database with the `save` method. Let’s type the following command in
    the Rails console:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有遇到过SQL命令，这可能会显得有些晦涩，但请相信我，在现实中它并不那么糟糕。输出的一部分告诉我们Rails正在加载一个SQL命令，该命令是`SELECT
    "people".* FROM "people"`。星号（`*`）是一个过滤器，用于选择与`people`表关联的所有字段。在这种情况下，这意味着Rails将获取ID、`name`、`birthday`和`timestamp`字段。命令中的`FROM`部分告诉数据库引擎从`people`表获取条目，没有任何过滤器。最后，输出的最后一行告诉我们`people`表中没有条目。正如我之前提到的，数据仍在内存中，所以现在让我们使用`save`方法将数据持久化到数据库中。让我们在Rails控制台中输入以下命令：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will output a message confirming that we saved our data into the database:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一条消息，确认我们已经将数据保存到数据库中：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let’s again fetch all of the entries in the database with the following
    command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次使用以下命令检索数据库中的所有条目：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will return the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last line states that we have indeed persisted information in the database.
    If we closed the Rails console and opened it up again, and fetched all the records,
    we would get the same result as we did just now. Congratulations, we have successfully
    connected to a DB using simple but powerful commands. Now it’s time to take full
    advantage of Active Record.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行表明我们确实在数据库中持久化了信息。如果我们关闭 Rails 控制台并再次打开，然后获取所有记录，我们会得到刚才同样的结果。恭喜你，我们已经成功使用简单但强大的命令连接到数据库。现在是我们充分利用
    Active Record 的时候了。
- en: Active Record operations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Active Record 操作
- en: 'Active Record is a design pattern created to simplify communication with the
    DB. Historically, SQL is a standard for communicating with most databases. However,
    each database has adopted its own unique set of SQL commands and standards. While
    they are all very similar, each one has its own peculiarities, in part because
    not all databases have the same set of features. A great article detailing some
    of the concepts regarding the Active Record design pattern is this one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Active Record 是一种设计模式，旨在简化与数据库的通信。历史上，SQL 是与大多数数据库通信的标准。然而，每个数据库都采用了自己独特的一套
    SQL 命令和标准。虽然它们都非常相似，但每个都有其独特的特性，部分原因是因为并非所有数据库都有相同的功能集。一篇详细介绍 Active Record 设计模式概念的精彩文章是这篇：
- en: '[https://blog.savetchuk.com/overview-of-the-active-record-pattern](https://blog.savetchuk.com/overview-of-the-active-record-pattern)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[Active Record 模式概述](https://blog.savetchuk.com/overview-of-the-active-record-pattern)'
- en: 'As an example, PostgreSQL offers a more sophisticated set of data types than
    MySQL. Another example is SQLite in web applications, which is very easy to set
    up, but does not work well in large applications. In Rails, SQLite is mostly used
    for quick setups and development. Where does Active Record come into the picture?
    Active Record uses a technique called **Object Relational Mapper** (**ORM**).
    This technique involves “mapping” a database object into a programming object.
    An example of this mapping is where an entry on a table becomes an object, and
    each column becomes an attribute of said object. Why would we do this? The simple
    answer is that, as we are developers, it’s easier to handle objects than SQL commands.
    The more complex answer is that Active Record uses the same language (objects)
    and translates these objects into any particular flavor of SQL used by a database.
    You could potentially switch the database type (PostgreSQL, MySQL, SQLite, etc.)
    with very little effort on the developer side. Actions on the database are executed
    using more readable commands than SQL syntax. It’s much easier to learn a few
    intuitive commands than the whole syntax required for SQL. We’ve already seen
    this in action, but let’s see the difference between a simple Active Record command
    and a SQL command. While still inside the Rails console, let’s type the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以为例，PostgreSQL 提供的数据类型比 MySQL 更为复杂。另一个例子是用于网络应用的 SQLite，它非常容易设置，但在大型应用中表现不佳。在
    Rails 中，SQLite 主要用于快速设置和开发。Active Record 在哪里发挥作用呢？Active Record 使用一种称为 **对象关系映射器**（**ORM**）的技术。这种技术涉及将数据库对象“映射”到编程对象。这种映射的一个例子是表中的条目变成一个对象，而每个列成为该对象的属性。我们为什么要这样做呢？简单的答案是，作为开发者，我们处理对象比处理
    SQL 命令更容易。更复杂的答案是，Active Record 使用相同的语言（对象）并将这些对象转换为数据库使用的任何特定风格的 SQL。你可以在开发者几乎不费力的前提下切换数据库类型（PostgreSQL、MySQL、SQLite
    等）。使用比 SQL 语法更易读的命令来执行数据库操作。学习几个直观的命令比学习 SQL 所需的整个语法要容易得多。我们已经看到了这个功能在行动中的表现，但让我们看看简单
    Active Record 命令和 SQL 命令之间的区别。当仍然在 Rails 控制台中时，让我们输入以下内容：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will return an array of entries inside our database:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回数据库中的条目数组：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can get the same result by using the ORM technique used by Active Record
    with the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Active Record 使用的 ORM 技术通过以下命令获得相同的结果：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding command also returns an array of entries:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令也返回条目数组：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I don’t know about you, but I think it’s easier to remember `Person.all` than
    `SELECT * FROM people`. Don’t get me wrong – it is always an advantage having
    a developer who knows SQL syntax. However, it’s more advantageous to both know
    SQL syntax and how to exploit Active Record. Let’s see other operations we can
    do with Active Record.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你们是否这样认为，但我觉得记住 `Person.all` 比记住 `SELECT * FROM people` 更容易。请别误会——知道 SQL
    语法总是有优势的。然而，知道 SQL 语法和如何利用 Active Record 更有利。让我们看看我们可以使用 Active Record 执行的其他操作。
- en: 'At this point, I believe it would be very useful to install a client to analyze
    our SQLite data visually. There are many clients and browser plugins for this
    task, but I recommend DB Browser for SQLite. You can check out its page here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信安装一个客户端来可视化我们的SQLite数据将非常有用。有许多客户端和浏览器插件可以完成这项任务，但我推荐使用DB Browser for
    SQLite。您可以在以下页面查看其页面：
- en: '[https://sqlitebrowser.org/](https://sqlitebrowser.org/)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite Browser](https://sqlitebrowser.org/)'
- en: 'This will accomplish the goal of visualizing data on Windows and Mac, and even
    some distributions of Linux, but for those platforms for which this tool is not
    available, you can also rely on Chrome’s SQLite Manager for Google Chrome plugin:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Windows和Mac上实现可视化数据的目标，甚至在某些Linux发行版上，但对于这个工具不可用的平台，您也可以依赖Chrome的SQLite Manager
    for Google Chrome插件：
- en: '[https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb](https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite Manager for Google Chrome](https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb)'
- en: They all work in a similar manner, and besides, we just want to use the tool
    as a visual data browser.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都以类似的方式工作，而且，我们只想将这个工具用作可视数据浏览器。
- en: 'Once we’ve installed the tool, let’s open the database file. In this case,
    the DB file is in `chapter08/rails5_models/db/development.sqlite3`. With the DB
    Browser for SQLite app open, let’s click on the **Open Database** button shown
    here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了工具，让我们打开数据库文件。在这种情况下，数据库文件位于`chapter08/rails5_models/db/development.sqlite3`。在DB
    Browser for SQLite应用程序打开的情况下，让我们点击这里显示的**打开数据库**按钮：
- en: '![Figure 8.1 – Open Database button in DB Browser for SQLite](img/B19230_08_01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 在SQLite Browser中打开数据库的按钮](img/B19230_08_01.jpg)'
- en: Figure 8.1 – Open Database button in DB Browser for SQLite
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 在SQLite Browser中打开数据库的按钮
- en: 'Then let’s navigate into our `development.sqlite3` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们导航到我们的`development.sqlite3`文件：
- en: '![Figure 8.2 – Navigating into the sqlite3 file](img/B19230_08_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 导航到sqlite3文件](img/B19230_08_02.jpg)'
- en: Figure 8.2 – Navigating into the sqlite3 file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 导航到sqlite3文件
- en: Once we open that file, we will be able to view the tables that we’ve created
    so far, along with a few others that Rails creates on its own.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打开那个文件，我们就能查看我们迄今为止创建的表，以及Rails自己创建的一些其他表。
- en: '![Figure 8.3 – Open the people table on DB Browser for SQLite](img/B19230_08_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 在SQLite Browser中打开人表](img/B19230_08_03.jpg)'
- en: Figure 8.3 – Open the people table on DB Browser for SQLite
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 在SQLite Browser中打开人表
- en: 'We can ignore all the other tables for now, and just focus on the `people`
    table. As you can see, we have the same columns (`id`, `name`, `birthday`, `created_at`,
    and `updated_at`) as we saw on the `Person` object when we created an instance
    of the `Person` model. But more than the structure, we’re interested in the entries
    (or records) inside this table. Let’s right-click on the `people` table and let’s
    select the **Browse Table** option, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以忽略所有其他表，只需专注于`people`表。如您所见，我们具有与创建`Person`模型实例时在`Person`对象上看到的相同的列（`id`、`name`、`birthday`、`created_at`和`updated_at`）。但除了结构之外，我们对这个表内的条目（或记录）更感兴趣。让我们右键单击`people`表，并选择以下截图所示的**浏览表**选项：
- en: '![Figure 8.4 – Browse table data on DB Browser for SQLite](img/B19230_08_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 在DB Browser for SQLite中浏览表数据](img/B19230_08_04.jpg)'
- en: Figure 8.4 – Browse table data on DB Browser for SQLite
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 在DB Browser for SQLite中浏览表数据
- en: 'Now we should see the single entry that we added when playing around with the
    Rails console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能看到我们在用Rails控制台玩耍时添加的单个条目：
- en: '![Figure 8.5 – Entries on the people table shown on DB Browser for SQLite](img/B19230_08_05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 在SQLite Browser上显示的人表条目](img/B19230_08_05.jpg)'
- en: Figure 8.5 – Entries on the people table shown on DB Browser for SQLite
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 在SQLite Browser for SQLite上显示的人表条目
- en: The entry should have the same data that we fed to the Rails console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 条目应包含我们输入到Rails控制台中的相同数据。
- en: We’ve confirmed the initial data was set correctly, but now it’s time to use
    Active Record to create new records on the database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已确认初始数据设置正确，但现在是我们使用Active Record在数据库上创建新记录的时候了。
- en: Creating records
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建记录
- en: 'We previously saw that we could add entries to our database by creating a `Person`
    object, adding attributes (`name` and `birthday`), and finally saving the record.
    But there is a one-liner that does the same thing. Let’s try the following line
    inside our Rails console:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，我们可以通过创建一个`Person`对象，添加属性（`name`和`birthday`），并最终保存记录来向我们的数据库添加条目。但有一个单行命令可以完成相同的事情。让我们在Rails控制台中尝试以下行：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It should output the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应该输出以下内容：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The value for the name `"Oscarr"` is on purpose. As we can see, the `create`
    method generates a SQL statement to create a record on the same table we’ve been
    working on but with different attributes. The more attributes we have, the more
    lines of code we would need had we used the other method to add data. Both ways
    are valid ways to insert data into our database. I just wanted to demonstrate
    both options so that you can choose the one that is more convenient for your specific
    use case. Now, let’s confirm that this new entry does in fact exist on the database.
    Let’s go back to the DB Browser for SQLite app, and refresh the view either with
    the refresh button or by pressing *CMD + R* for Mac users or *Ctrl + R* for Windows
    and Linux users. This should now show the new entry on the table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Oscarr"`这个名字是有意为之的。正如我们所见，`create`方法生成一个SQL语句，在我们在其上工作的同一张表上创建记录，但具有不同的属性。我们拥有的属性越多，如果我们使用其他方法添加数据，我们就需要更多的代码行。这两种方法都是将数据插入我们数据库的有效方法。我只是想展示两种选项，这样你可以选择对你特定用例更方便的一种。现在，让我们确认这个新条目确实存在于数据库中。让我们回到SQLite浏览器应用程序，通过刷新按钮或按Mac用户的*CMD
    + R*或Windows和Linux用户的*Ctrl + R*来刷新视图。现在，这个新条目应该会显示在表格上：'
- en: '![Figure 8.6 – New entries on the people table shown on DB Browser for SQLite](img/B19230_08_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 在SQLite浏览器中显示的人员表上的新条目](img/B19230_08_06.jpg)'
- en: Figure 8.6 – New entries on the people table shown on DB Browser for SQLite
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 在SQLite浏览器中显示的人员表上的新条目
- en: 'Oh, but wait. We’ve made two mistakes. I made typo by adding the name `"Oscarr"`
    when I meant to type just `"Oscar"`. I also made a mistake with the year, as I
    meant to add `1980` instead of `1981`. This fortunate mistake brings us to the
    next operation: `SELECT`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，等等。我们犯了两个错误。我在添加名字`"Oscarr"`时打错了字，我本想只输入`"Oscar"`。我还犯了一个关于年份的错误，因为我本想添加`1980`而不是`1981`。这个幸运的错误带我们到了下一个操作：`SELECT`。
- en: Selecting record(s)
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择记录
- en: 'So far, we’ve seen one method to select all of our entries: the `all` method.
    But Active Record comes with two other very useful methods: `first` and `last`
    . As the name implies, we can select the first record of any selection. Let’s
    do that by typing the following command on the Rails console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了一种选择所有条目的方法：`all`方法。但Active Record还提供了两个其他非常有用的方法：`first`和`last`。正如其名所示，我们可以选择任何选择中的第一个记录。让我们在Rails控制台中输入以下命令来执行此操作：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should return the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下输出：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the command selects the very first entry from our `people`
    table. Now let’s try the `last` method by typing the following on the Rails console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个命令选择了我们`people`表中的第一个条目。现在让我们在Rails控制台中尝试使用`last`方法，输入以下内容：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should output the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ve selected the last record on our database. These methods come in handy
    when looking for test data. Now let’s use the `where` method to filter data by
    a determined field. Let’s try the following code on the Rails console:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择了数据库中的最后一个记录。这些方法在寻找测试数据时非常有用。现在让我们使用`where`方法通过一个确定的字段来过滤数据。让我们在Rails控制台中尝试以下代码：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will output the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code has selected all entries that have the name `"Benjamin"`. In this
    case, there is just one entry. However, there is a little catch here that we should
    be careful with. Notice that after the word `Relation` in the previous output,
    there is a square bracket (`[`), which is eventually closed almost at the end
    of the line (`>]>`). This is because when we use the `where` method, it always
    returns an array of objects. This is useful when displaying data on a grid or
    table on the view, but can be tricky when we want to select a single entry. Now,
    let’s talk about selecting single records. Before updating any record, we need
    to select which record we’re going to modify. For that purpose, the implementation
    of Active Record on Rails comes with two handy methods. The first one is `find_by`.
    The `find_by` method requires a parameter in the form of a hash that includes
    the attribute that we want to filter, followed by the value. In this case, we
    want to filter by the `name` attribute and the `Oscarr` value. Let’s test this
    by typing the following on the Rails console:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码已选择所有名为`"Benjamin"`的条目。在这种情况下，只有一个条目。然而，这里有一个需要注意的小陷阱。注意，在前一个输出中的`Relation`一词之后，有一个方括号（`[`），它最终在行尾几乎关闭（`>]>`）。这是因为当我们使用`where`方法时，它总是返回一个对象数组。这在显示视图中的网格或表格数据时很有用，但当我们想要选择单个条目时可能会很棘手。现在，让我们谈谈选择单个记录。在更新任何记录之前，我们需要选择我们要修改的记录。为此，Rails上的Active
    Record实现提供了两个方便的方法。第一个是`find_by`。`find_by`方法需要一个参数，形式为包含我们想要过滤的属性的哈希，后跟值。在这种情况下，我们想要通过`name`属性和`Oscarr`值进行过滤。让我们通过在Rails控制台中输入以下内容来测试它：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will return the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Rails returns the first entry that it finds with the criteria that we supplied
    to the `find_by` method. In this case, it finds the first entry that complies
    with having the name equal to `"Oscarr"`. We can confirm this by typing any attribute
    and viewing its contents. Let’s try this by typing the following line in the Rails
    console:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Rails返回它通过`find_by`方法提供的标准找到的第一个条目。在这种情况下，它找到第一个名字等于`"Oscarr"`的条目。我们可以通过输入任何属性并查看其内容来确认这一点。让我们通过在Rails控制台中输入以下行来尝试：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And this will return the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can do the same with any other attribute. Let’s try it with the `birthday`
    attribute. Let’s type the following on our Rails console:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用任何其他属性做同样的事情。让我们用`birthday`属性试一试。让我们在我们的Rails控制台中输入以下内容：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And we should get the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下输出：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, as you can see, the `found_person` object has the entry that we were looking
    for. However, this comes with a caveat. There may be more than one person with
    the same name. If we were looking to select the second person, then our code would
    fail as the `find_by` method automatically returns the first found entry. To solve
    this conundrum, Active Record provides a special method called `find`. This method
    assumes that our table has an `id` column, which is unique for each entry. So,
    in our previous use case, if there were two people with the same name, we would
    just filter it by the unique ID. In this case, we would just type the following
    in our Rails console:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，`found_person`对象包含了我们正在寻找的条目。然而，这有一个前提。可能有不止一个人有相同的名字。如果我们想要选择第二个人，那么我们的代码将失败，因为`find_by`方法自动返回第一个找到的条目。为了解决这个难题，Active
    Record提供了一个特殊的方法，称为`find`。此方法假设我们的表有一个唯一的`id`列，每个条目都是唯一的。所以，在我们的上一个用例中，如果有两个人有相同的名字，我们只需通过唯一的ID进行过滤。在这种情况下，我们只需在我们的Rails控制台中输入以下内容：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And this would output the same as before:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出与之前相同的内容：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Should there be another entry with the same name, it wouldn’t matter to us.
    Our code would select the one with the `id` equal to `2`. Now that we’ve selected
    an entry, let’s move on to updating its contents.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在另一个同名条目，对我们来说无关紧要。我们的代码将选择`id`等于`2`的那个条目。既然我们已经选择了一个条目，那么让我们继续更新其内容。
- en: Updating records
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新记录
- en: 'Just like creating records, there are a couple of ways that we can update a
    record in the database. Since we’ve already selected our record that has a typo
    in the name, let’s see the first option we can use to update records. Let’s say
    we typed the following code into our Rails console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像创建记录一样，我们有几种方法可以在数据库中更新记录。既然我们已经选择了名字中存在错别字的记录，让我们看看我们可以使用的第一个更新记录的选项。假设我们将以下代码输入到我们的Rails控制台中：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This would output the following record:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下记录：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this, we can confirm that this is the right record we want to modify.
    To modify the name, we would type the following code on our Rails console:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以确认这是我们想要修改的正确记录。要修改名称，我们将在 Rails 控制台中输入以下代码：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This would just output the string we have just assigned to our `name` attribute:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只输出我们刚刚分配给 `name` 属性的字符串：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But remember what we said about the object: this change is still only in memory.
    We need to persist the change. We would use the same `save` method as before.
    Let’s type the following on the Rails console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住我们之前所说的关于对象的话：这个更改仍然只是在内存中。我们需要持久化这个更改。我们将使用之前相同的 `save` 方法。让我们在 Rails 控制台中输入以下内容：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This would output the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will save our change into the database and return a true value. This true
    value will come in handy later on in the next chapter. But for now, we can just
    confirm this change by opening DB Browser for SQLite and refreshing the view.
    It should now show the correct name:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的更改保存到数据库中，并返回一个 true 值。这个 true 值将在下一章中非常有用。但就现在而言，我们可以通过打开 SQLite 浏览器并刷新视图来确认这个更改。现在应该显示正确的名称：
- en: '![Figure 8.7 – Modified entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 在 SQLite 浏览器中显示的人表修改条目](img/B19230_08_07.jpg)'
- en: Figure 8.7 – Modified entry on the people table as shown in DB Browser for SQLite
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 在 SQLite 浏览器中显示的人表修改条目
- en: 'That was one way to modify a record. However, there is another way using the
    `update` method. Let’s try it with the following code on the Rails console:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种修改记录的方法。然而，还有另一种方法可以使用 `update` 方法。让我们在 Rails 控制台中用以下代码尝试一下：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This would output the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let’s confirm the change again on the DB Browser for SQLite app. Let’s
    just refresh the view and we should see the change show up:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次在 SQLite 浏览器应用中确认这个更改。让我们只是刷新视图，我们应该能看到更改显示出来：
- en: '![Figure 8.8 – Updated entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 在 SQLite 浏览器中显示的人表更新条目](img/B19230_08_08.jpg)'
- en: Figure 8.8 – Updated entry on the people table as shown in DB Browser for SQLite
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 在 SQLite 浏览器中显示的人表更新条目
- en: So as you can see, we’ve updated our record in two different ways. Again, both
    of these methods are valid and you can choose whichever method fits your needs
    more. Now let’s look at the last method (for now), which is the `destroy` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，我们已经以两种不同的方式更新了我们的记录。再次强调，这两种方法都是有效的，你可以选择更适合你需求的方法。现在让我们看看最后一种方法（目前），即
    `destroy` 方法。
- en: Deleting record(s)
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'So far, we’ve created, selected, and updated records in our database. The last
    Active Record action we’re going to look at is the destroy action. You should
    be especially careful with this action as this deletes data from your database
    without any confirmation required beforehand. Furthermore, this action is permanent
    – once the destroy action has been done, it cannot be reverted. So, let’s first
    create another entry with the following command on the Rails console:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在数据库中创建了、选择了和更新了记录。接下来我们要查看的最后一种 Active Record 操作是销毁操作。你应该特别小心这个操作，因为这个操作会从你的数据库中删除数据，而无需事先进行任何确认。此外，这个操作是不可逆的——一旦执行了销毁操作，就无法撤销。所以，让我们首先在
    Rails 控制台中用以下命令创建另一个条目：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This should output the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And once again, let’s refresh our view on the DB Browser for SQLite app:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次在 SQLite 浏览器应用中刷新我们的视图：
- en: '![Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite](img/B19230_08_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 在 SQLite 浏览器中显示的人表新条目](img/B19230_08_09.jpg)'
- en: Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 在 SQLite 浏览器中显示的人表新条目
- en: 'Now that we’ve confirmed that the new entry exists, we can proceed to delete
    it. Just like the `update` method, we first must select an entry on the database.
    Let’s do this by typing the following on the Rails console:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认新条目存在，我们可以继续删除它。就像 `update` 方法一样，我们首先必须在数据库中选中一个条目。让我们在 Rails 控制台中输入以下内容：
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This should output the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'With this, we confirm that we’ve selected the right record. Finally, let’s
    delete the record with the following code on our Rails console:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们确认我们已经选中了正确的记录。最后，让我们在 Rails 控制台中用以下代码删除记录：
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This would output the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As you can see, it generated and executed the code to delete the entry. If
    we go to our DB Browser for SQLite app and refresh the view, we should see that
    the entry no longer exists:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它生成了并执行了删除条目的代码。如果我们进入我们的SQLite浏览器应用程序并刷新视图，我们应该会看到该条目已不再存在：
- en: '![Figure 8.9 – Deleted entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_10.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 如在SQLite浏览器中所示，已删除的人事表条目](img/B19230_08_10.jpg)'
- en: Figure 8.10 – Deleted entry on the people table as shown in DB Browser for SQLite
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 如在SQLite浏览器中所示，已删除的人事表条目
- en: As we can see, the entry has been deleted and is forever gone. I cannot stress
    enough how dangerous this operation can be when developing an application. All
    I can say is, be careful while using it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该条目已被删除，并且永远消失。我无法强调这种操作在开发应用程序时有多么危险。我所能说的是，使用时要格外小心。
- en: 'You may have noticed that all the data manipulation on the database was done
    through the Rails console. This is because I believe the Rails console is the
    easiest way to understand and learn how to use Active Record actions. Once we
    have mastered these easy-to-use intuitive methods, then applying this knowledge
    in our controllers and views can be achieved without any difficulty whatsoever.
    Should you wish to learn more about these Active Record actions, please take a
    look at the Active Record basics page:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，所有数据库的数据操作都是通过Rails控制台完成的。这是因为我相信Rails控制台是理解和学习如何使用Active Record操作的最简单方式。一旦我们掌握了这些易于使用且直观的方法，那么在控制器和视图中应用这些知识将毫无困难。如果您想了解更多关于这些Active
    Record操作的信息，请查看Active Record基础知识页面：
- en: '[https://guides.rubyonrails.org/active_record_basics.html](https://guides.rubyonrails.org/active_record_basics.html)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://guides.rubyonrails.org/active_record_basics.html](https://guides.rubyonrails.org/active_record_basics.html)'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about models, migrations, and the Rails console
    as the go-to tool to easily manipulate data on a database. We also learned how
    useful the implementation of Active Record is on Rails and how we can communicate
    with a database with very easy-to-use commands. Now we are ready to put it all
    together by fetching data from a database and displaying it on the view, which
    is what we’ll be doing in the next chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了模型、迁移以及Rails控制台作为轻松操作数据库数据的首选工具。我们还学习了Active Record在Rails中的实现是多么有用，以及我们如何可以通过非常易于使用的命令与数据库进行通信。现在，我们已经准备好通过从数据库中获取数据并在视图中显示它来将这些知识综合起来，这正是我们将在下一章中要做的。
