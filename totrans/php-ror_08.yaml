- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models, DBs, and Active Record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **M** in the **MVC** application design pattern stands for **model**, and
    in this context, we will be using Ruby’s model abstraction to connect to a database
    using another design pattern called Active Record. We must remember that while
    models are mostly used to connect to databases, they can also be used to connect
    to other data sources. We could have a model connect to a filesystem, a web service,
    and so on. The purpose behind a model is to organize our business rules, and that
    purpose may include connecting to various data sources.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first generate a model using some of our command-line
    generators in Rails. Then, we will use this model to connect to our database.
    Finally, we will look at Active Record and perform operations inside our database
    in a very intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this purpose and Active Record in mind, in this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating models using Rails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active Record operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (e.g. SublimeText, Visual Studio Code, Notepad++ Vim,
    Emacs, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have the Xcode command line tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby version 2.6 or later installed and ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git client installed on your local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  prefs: []
  type: TYPE_NORMAL
- en: Generating models using Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Models are abstractions of objects we might find in everyday life. Whether
    they are people, books, or cars, a model serves as a representation of those objects
    on the database. And just like controllers, Rails comes with generators that help
    us create models in a very easy and intuitive way. But first, let’s set up our
    environment. You can either start where we left off in the previous chapter, or
    download the example code for this chapter. If you haven’t yet done so, open a
    terminal and type the following `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already done so, then just navigate to the `chapter08` folder within
    your project by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, let’s install our dependencies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And to confirm our setup was done correctly, let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should read something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we are ready to generate our model. We will generate a model that represents
    people. We will add an attribute called `name` for each person, and another attribute
    called `birthday`. To generate our model, let’s type the following command on
    our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, we are telling our Rails generator to create a model called
    `Person` with an attribute called `name`, and another attribute called `birthday`.
    The `name` attribute will be a string, and the `birthday` attribute a date. Once
    we press the *Enter* key, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look closely at this output, we should notice two important files that
    have been created, the migration and the model itself. Let’s first open our migration
    file, `db/migrate/20230727031200_create_people.rb`. Its contents should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This file includes the instructions to generate our database structure. If we
    look closely, it states that it will create a `people` table with the `name`,
    `birthday`, and `timestamps` columns. Why was this file needed? To answer that
    question, we need to take a look at what Rails migrations are.
  prefs: []
  type: TYPE_NORMAL
- en: Rails migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the old days, keeping track of a **database** (**DB**) was a hassle. Whenever
    you worked on a project with other developers that required a DB, someone had
    to create the DB and its tables, and often also populate it with testing data.
    If someone new joined the team, you would just hand them a copy of the DB and
    off they would go. But wait – what would happen if someone made changes to the
    DB structure? What if we needed a new field? What if a field was no longer needed?
    Then, whoever was in charge of this DB would have to make the change and then
    hand out the new copy of the DB to all the developers in the team. You can see
    how this might get out of control, especially if you have more than two developers
    working on the same project. In comes migrations to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'A migration is a series of commands to rebuild the structure of a DB in sequence.
    In the same hypothetical example that I just outlined, migrations would solve
    the problem with no issues. Initially, you would create a migration that created
    a table with certain fields. If the table required a new field, you would create
    another migration to create that new field. If a field was no longer required,
    you would create a migration to remove that field. And, as you may have noticed,
    the name of the migration has a timestamp. This is to run the migrations in sequence
    – we would first create the table, then add a field, and lastly remove a field.
    If a new developer joined the team, they could just run all the migrations and
    have the exact same database structure that everyone else has. Back to the migration
    at hand, we have the instructions (migration) but we still need to execute these
    instructions to impact the DB. So now, let’s run the command to execute this migration.
    On the command shell, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that our DB structure has been created, with a table called `people`.
    This is part of the Rails magic. We have not configured any DB on our project,
    yet if this command is successful, it means that Rails is connected to a DB. The
    reason behind this is that the Rails developers wanted you to have a ready-to-use
    project out of the box, and to do this, they made the initial project connect
    to a database called SQLite by default. SQLite is a series of libraries that allow
    us to have a ready-to-use, lightweight database based on a `sqlite3` file in your
    project. If you’re interested in this topic, I recommend you read the SQLite official
    page: [https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now generated our model and we’re ready to move on to the next section,
    where we will connect to our database using our model and the Rails configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve created a `Person` model and the migrations needed for the structure
    of our database. Now we are ready to connect to our database. But wait, we’ve
    already connected to a database! As previously stated, if we were able to run
    our migration successfully, it means that we did indeed connect to the SQLite
    database. Now let’s take a look at how Rails is configured to do this. Let’s examine
    our Gemfile, and in doing so, we’ll see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line installs the `sqlite3` gem that allows Rails to communicate
    with a SQLite database. But wait, there’s more. If we open the `app/config/database.yml`
    file, we will also see some of the database settings for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `default` stanza defines the database adapter as `sqlite3` and the environment
    sets the database source file to be in `db/development.sqlite3` . If we check
    this, we’ll see that the file is indeed there. The Rails migration command is
    the one responsible for creating this file. Don’t bother opening the file as it
    is a binary file and unless you have a plugin to read SQLite files on your IDE,
    you’ll only see data that only makes sense to computers and not to humans. Now
    let’s use this newly acquired information to actually manipulate data in the database
    with the Rails console.
  prefs: []
  type: TYPE_NORMAL
- en: The Rails console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creators of Rails have made an enormous effort to make Ruby on Rails the
    framework of choice to pair with Rails. As such, they were inspired by some of
    the tools that come with Ruby, and more specifically the **Interactive Ruby**
    (**IRB**) console. Rails comes with a similar console but tweaked to be able to
    load and query Rails components. Let’s try it out with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the following output and enable us to interact with Rails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is where our `Person` model comes in handy. Let’s create a new object
    called `single_person` and add some data to our database. Inside this Rails console,
    let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an object based on the `Person` model that we defined with
    our `Model` file and the migrations. The previous command will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we’ve created an empty object that has no ID, no name, and
    no birthday. Now let’s set the object’s name and birthday. We’ll do this by first
    typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our prompt will confirm with the following output that we’ve set the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s set the birthday with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re setting a date in the `year-month-day` format. The preceding command
    sets the birth date to February 3, 1986\. And just like the previous command,
    it will confirm this by returning the value we’ve just set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go a little further with our object and see what attributes we’ve set
    so far by just typing the name of our `single_person` variable and view the contents
    of the object. Let’s do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comand will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to remember is that this information is still only available in memory.
    We have not persisted (or written) the data into the database. You’ll hear the
    term *persist* often when dealing with databases, and it refers to writing the
    data into the database. As it stands now, if we were to leave the Rails console,
    the data would be lost. How do we persist the data, you may ask? Simple: we call
    the `save` method from our `single_person` object. But before we do that, let’s
    confirm that there is no data in our database. We will do so by typing the following
    static method from our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows a command in the **Structured Query Language** (**SQL**)
    used by databases to manipulate data. SQL is a standard language used to “talk”
    to databases. Many databases use this language, so you don’t have to learn a different
    language for each one. If you wish to know more about SQL, I recommend you take
    a look at this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/what-is/sql/](https://aws.amazon.com/what-is/sql/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not encountered SQL commands before, this might seem a little cryptic,
    but believe me, it is not so bad in reality. The first part of the output tells
    us Rails is loading a SQL command, the command being `SELECT "people".* FROM "people"`.
    The star (`*`) is a filter to select all of the fields associated with the `people`
    table. In this case, it means that Rails will fetch the ID, `name`, `birthday`,
    and `timestamp` fields. The `FROM` part of the command tells the database engine
    to fetch entries from the `people` table without any filters. Lastly, the last
    line of the output tells us that there are no entries in the people table. As
    I mentioned before, the data is still in memory, so now let’s persist the data
    into the database with the `save` method. Let’s type the following command in
    the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a message confirming that we saved our data into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s again fetch all of the entries in the database with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last line states that we have indeed persisted information in the database.
    If we closed the Rails console and opened it up again, and fetched all the records,
    we would get the same result as we did just now. Congratulations, we have successfully
    connected to a DB using simple but powerful commands. Now it’s time to take full
    advantage of Active Record.
  prefs: []
  type: TYPE_NORMAL
- en: Active Record operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Active Record is a design pattern created to simplify communication with the
    DB. Historically, SQL is a standard for communicating with most databases. However,
    each database has adopted its own unique set of SQL commands and standards. While
    they are all very similar, each one has its own peculiarities, in part because
    not all databases have the same set of features. A great article detailing some
    of the concepts regarding the Active Record design pattern is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blog.savetchuk.com/overview-of-the-active-record-pattern](https://blog.savetchuk.com/overview-of-the-active-record-pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, PostgreSQL offers a more sophisticated set of data types than
    MySQL. Another example is SQLite in web applications, which is very easy to set
    up, but does not work well in large applications. In Rails, SQLite is mostly used
    for quick setups and development. Where does Active Record come into the picture?
    Active Record uses a technique called **Object Relational Mapper** (**ORM**).
    This technique involves “mapping” a database object into a programming object.
    An example of this mapping is where an entry on a table becomes an object, and
    each column becomes an attribute of said object. Why would we do this? The simple
    answer is that, as we are developers, it’s easier to handle objects than SQL commands.
    The more complex answer is that Active Record uses the same language (objects)
    and translates these objects into any particular flavor of SQL used by a database.
    You could potentially switch the database type (PostgreSQL, MySQL, SQLite, etc.)
    with very little effort on the developer side. Actions on the database are executed
    using more readable commands than SQL syntax. It’s much easier to learn a few
    intuitive commands than the whole syntax required for SQL. We’ve already seen
    this in action, but let’s see the difference between a simple Active Record command
    and a SQL command. While still inside the Rails console, let’s type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an array of entries inside our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the same result by using the ORM technique used by Active Record
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command also returns an array of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I don’t know about you, but I think it’s easier to remember `Person.all` than
    `SELECT * FROM people`. Don’t get me wrong – it is always an advantage having
    a developer who knows SQL syntax. However, it’s more advantageous to both know
    SQL syntax and how to exploit Active Record. Let’s see other operations we can
    do with Active Record.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I believe it would be very useful to install a client to analyze
    our SQLite data visually. There are many clients and browser plugins for this
    task, but I recommend DB Browser for SQLite. You can check out its page here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://sqlitebrowser.org/](https://sqlitebrowser.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will accomplish the goal of visualizing data on Windows and Mac, and even
    some distributions of Linux, but for those platforms for which this tool is not
    available, you can also rely on Chrome’s SQLite Manager for Google Chrome plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb](https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb)'
  prefs: []
  type: TYPE_NORMAL
- en: They all work in a similar manner, and besides, we just want to use the tool
    as a visual data browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve installed the tool, let’s open the database file. In this case,
    the DB file is in `chapter08/rails5_models/db/development.sqlite3`. With the DB
    Browser for SQLite app open, let’s click on the **Open Database** button shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Open Database button in DB Browser for SQLite](img/B19230_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Open Database button in DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'Then let’s navigate into our `development.sqlite3` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Navigating into the sqlite3 file](img/B19230_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Navigating into the sqlite3 file
  prefs: []
  type: TYPE_NORMAL
- en: Once we open that file, we will be able to view the tables that we’ve created
    so far, along with a few others that Rails creates on its own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Open the people table on DB Browser for SQLite](img/B19230_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Open the people table on DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ignore all the other tables for now, and just focus on the `people`
    table. As you can see, we have the same columns (`id`, `name`, `birthday`, `created_at`,
    and `updated_at`) as we saw on the `Person` object when we created an instance
    of the `Person` model. But more than the structure, we’re interested in the entries
    (or records) inside this table. Let’s right-click on the `people` table and let’s
    select the **Browse Table** option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Browse table data on DB Browser for SQLite](img/B19230_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Browse table data on DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should see the single entry that we added when playing around with the
    Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Entries on the people table shown on DB Browser for SQLite](img/B19230_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Entries on the people table shown on DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: The entry should have the same data that we fed to the Rails console.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve confirmed the initial data was set correctly, but now it’s time to use
    Active Record to create new records on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously saw that we could add entries to our database by creating a `Person`
    object, adding attributes (`name` and `birthday`), and finally saving the record.
    But there is a one-liner that does the same thing. Let’s try the following line
    inside our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The value for the name `"Oscarr"` is on purpose. As we can see, the `create`
    method generates a SQL statement to create a record on the same table we’ve been
    working on but with different attributes. The more attributes we have, the more
    lines of code we would need had we used the other method to add data. Both ways
    are valid ways to insert data into our database. I just wanted to demonstrate
    both options so that you can choose the one that is more convenient for your specific
    use case. Now, let’s confirm that this new entry does in fact exist on the database.
    Let’s go back to the DB Browser for SQLite app, and refresh the view either with
    the refresh button or by pressing *CMD + R* for Mac users or *Ctrl + R* for Windows
    and Linux users. This should now show the new entry on the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – New entries on the people table shown on DB Browser for SQLite](img/B19230_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – New entries on the people table shown on DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, but wait. We’ve made two mistakes. I made typo by adding the name `"Oscarr"`
    when I meant to type just `"Oscar"`. I also made a mistake with the year, as I
    meant to add `1980` instead of `1981`. This fortunate mistake brings us to the
    next operation: `SELECT`.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting record(s)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve seen one method to select all of our entries: the `all` method.
    But Active Record comes with two other very useful methods: `first` and `last`
    . As the name implies, we can select the first record of any selection. Let’s
    do that by typing the following command on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the command selects the very first entry from our `people`
    table. Now let’s try the `last` method by typing the following on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve selected the last record on our database. These methods come in handy
    when looking for test data. Now let’s use the `where` method to filter data by
    a determined field. Let’s try the following code on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has selected all entries that have the name `"Benjamin"`. In this
    case, there is just one entry. However, there is a little catch here that we should
    be careful with. Notice that after the word `Relation` in the previous output,
    there is a square bracket (`[`), which is eventually closed almost at the end
    of the line (`>]>`). This is because when we use the `where` method, it always
    returns an array of objects. This is useful when displaying data on a grid or
    table on the view, but can be tricky when we want to select a single entry. Now,
    let’s talk about selecting single records. Before updating any record, we need
    to select which record we’re going to modify. For that purpose, the implementation
    of Active Record on Rails comes with two handy methods. The first one is `find_by`.
    The `find_by` method requires a parameter in the form of a hash that includes
    the attribute that we want to filter, followed by the value. In this case, we
    want to filter by the `name` attribute and the `Oscarr` value. Let’s test this
    by typing the following on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Rails returns the first entry that it finds with the criteria that we supplied
    to the `find_by` method. In this case, it finds the first entry that complies
    with having the name equal to `"Oscarr"`. We can confirm this by typing any attribute
    and viewing its contents. Let’s try this by typing the following line in the Rails
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same with any other attribute. Let’s try it with the `birthday`
    attribute. Let’s type the following on our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as you can see, the `found_person` object has the entry that we were looking
    for. However, this comes with a caveat. There may be more than one person with
    the same name. If we were looking to select the second person, then our code would
    fail as the `find_by` method automatically returns the first found entry. To solve
    this conundrum, Active Record provides a special method called `find`. This method
    assumes that our table has an `id` column, which is unique for each entry. So,
    in our previous use case, if there were two people with the same name, we would
    just filter it by the unique ID. In this case, we would just type the following
    in our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And this would output the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Should there be another entry with the same name, it wouldn’t matter to us.
    Our code would select the one with the `id` equal to `2`. Now that we’ve selected
    an entry, let’s move on to updating its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Updating records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like creating records, there are a couple of ways that we can update a
    record in the database. Since we’ve already selected our record that has a typo
    in the name, let’s see the first option we can use to update records. Let’s say
    we typed the following code into our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can confirm that this is the right record we want to modify.
    To modify the name, we would type the following code on our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This would just output the string we have just assigned to our `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'But remember what we said about the object: this change is still only in memory.
    We need to persist the change. We would use the same `save` method as before.
    Let’s type the following on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will save our change into the database and return a true value. This true
    value will come in handy later on in the next chapter. But for now, we can just
    confirm this change by opening DB Browser for SQLite and refreshing the view.
    It should now show the correct name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Modified entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Modified entry on the people table as shown in DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'That was one way to modify a record. However, there is another way using the
    `update` method. Let’s try it with the following code on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s confirm the change again on the DB Browser for SQLite app. Let’s
    just refresh the view and we should see the change show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Updated entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Updated entry on the people table as shown in DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: So as you can see, we’ve updated our record in two different ways. Again, both
    of these methods are valid and you can choose whichever method fits your needs
    more. Now let’s look at the last method (for now), which is the `destroy` method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting record(s)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve created, selected, and updated records in our database. The last
    Active Record action we’re going to look at is the destroy action. You should
    be especially careful with this action as this deletes data from your database
    without any confirmation required beforehand. Furthermore, this action is permanent
    – once the destroy action has been done, it cannot be reverted. So, let’s first
    create another entry with the following command on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And once again, let’s refresh our view on the DB Browser for SQLite app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite](img/B19230_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve confirmed that the new entry exists, we can proceed to delete
    it. Just like the `update` method, we first must select an entry on the database.
    Let’s do this by typing the following on the Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we confirm that we’ve selected the right record. Finally, let’s
    delete the record with the following code on our Rails console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it generated and executed the code to delete the entry. If
    we go to our DB Browser for SQLite app and refresh the view, we should see that
    the entry no longer exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Deleted entry on the people table as shown in DB Browser for
    SQLite](img/B19230_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Deleted entry on the people table as shown in DB Browser for SQLite
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the entry has been deleted and is forever gone. I cannot stress
    enough how dangerous this operation can be when developing an application. All
    I can say is, be careful while using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that all the data manipulation on the database was done
    through the Rails console. This is because I believe the Rails console is the
    easiest way to understand and learn how to use Active Record actions. Once we
    have mastered these easy-to-use intuitive methods, then applying this knowledge
    in our controllers and views can be achieved without any difficulty whatsoever.
    Should you wish to learn more about these Active Record actions, please take a
    look at the Active Record basics page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://guides.rubyonrails.org/active_record_basics.html](https://guides.rubyonrails.org/active_record_basics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about models, migrations, and the Rails console
    as the go-to tool to easily manipulate data on a database. We also learned how
    useful the implementation of Active Record is on Rails and how we can communicate
    with a database with very easy-to-use commands. Now we are ready to put it all
    together by fetching data from a database and displaying it on the view, which
    is what we’ll be doing in the next chapter.
  prefs: []
  type: TYPE_NORMAL
