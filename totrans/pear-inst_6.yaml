- en: 'Chapter 6. Embedding the PEAR Installer: Designing a Custom Plug-In System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。嵌入PEAR安装程序：设计自定义插件系统
- en: At this point, practically everything that can be done with the `pear` and `pecl`
    commands and existing PEAR software has been revealed. In the previous chapter,
    we learned how to set up a custom PEAR channel, completing our quest to master
    the usage of the PEAR installer. Now that we can conquer the universe of PEAR,
    let's look even further, and see how we can solve some of the most common problems
    of a web-based framework with the PEAR installer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用`pear`和`pecl`命令以及现有的PEAR软件所能做的几乎所有事情都已经揭晓。在前一章中，我们学习了如何设置自定义PEAR频道，完成了掌握PEAR安装程序使用的任务。现在，既然我们可以征服PEAR的宇宙，让我们进一步看看，如何使用PEAR安装程序解决基于网络的框架的一些最常见问题。
- en: In this chapter, we will design a custom plug-in system for a fake blog application,
    called **MyBlog**. For MyBlog, we will design a plug-in system to manage templates,
    and use the PEAR installer to manage the details of querying the remote server
    for templates, handling dependencies between versioning, and doing the actual
    installation process as well. In addition, it will use an extension of REST on
    the remote server to store thumbnail images of the templates to aid in choosing
    a template. Of course, since this is a fake blog, the thumbnail images are pictures
    of cats, but they would be screenshots of the templates for a real blog.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为假博客应用程序**MyBlog**设计一个自定义插件系统。对于MyBlog，我们将设计一个插件系统来管理模板，并使用PEAR安装程序来管理查询远程服务器模板的细节，处理版本之间的依赖关系，以及执行实际的安装过程。此外，它将使用远程服务器上REST的扩展来存储模板的缩略图，以帮助选择模板。当然，由于这是一个假博客，缩略图是猫的图片，但对于真实博客来说，它们将是模板的截图。
- en: 'For those who do not wish to type in every character, the code for MyBlog is
    always available for download directly from Packt website, or by direct installation
    using the PEAR installer (the fun way) via:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不想逐个字符输入的用户，MyBlog的代码可以从Packt网站直接下载，或者通过直接使用PEAR安装程序（一种有趣的方式）进行安装，具体方法如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although a bit ugly (I never claimed to be a designer), here is the administration
    page of our fake MyBlog application, demonstrating the image pulled from a remote
    server and pagination:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有点丑陋（我从未声称自己是设计师），以下是我们的假MyBlog应用程序的管理页面，展示了从远程服务器拉取的图片和分页：
- en: '![Embedding the PEAR Installer: Designing a Custom Plug-In System](img/1904811191_6_1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入PEAR安装程序：设计自定义插件系统](img/1904811191_6_1.jpg)'
- en: 'Here is a screenshot of the post-install process after clicking on the second
    template to install it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击第二个模板进行安装后的安装过程截图：
- en: '![Embedding the PEAR Installer: Designing a Custom Plug-In System](img/1904811191_6_2.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入PEAR安装程序：设计自定义插件系统](img/1904811191_6_2.jpg)'
- en: Why Embed PEAR?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么嵌入PEAR？
- en: 'In many cases, PHP applications are web applications like Content Management
    Systems (CMS) or some other customizable framework that can be extended. Inevitably,
    at some point, end users will think: "Wouldn''t it be nice to just click and get
    the functionality that I want downloaded and installed automatically?"'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，PHP应用程序是像内容管理系统（CMS）或其他可扩展的自定义框架这样的网络应用程序。不可避免地，在某个时候，最终用户会想：“如果只需点击就能自动下载和安装我想要的功能，那不是很好吗？”
- en: At this point, it would be simpler for you to require users to install the extra
    functionality using the PEAR installer, but what if we don't want our application's
    users to have to learn how to use PEAR at all? Users who download your CMS or
    framework (let's call it the XYZ framework) already have a lot to learn about
    how the framework is designed, how to customize and use it to author content.
    The last thing they want to learn is some external tool just in order to install
    a special voting plug-in or a new template.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，要求用户使用PEAR安装程序安装额外功能可能会更简单，但如果我们不希望我们的应用程序用户必须学习如何使用PEAR怎么办？下载您的CMS或框架（让我们称它为XYZ框架）的用户已经有很多关于框架设计、如何定制和使用它来创建内容要学习。他们最不想学习的是一些外部工具，只是为了安装一个特殊的投票插件或一个新的模板。
- en: What we really need is a simple page on the administration portion of the XYZ
    framework that allows the user to browse plug-ins, and click on one for installation,
    without worrying about details. Even better would be to allow the possibility
    for advanced users to customize the remote server used for download, whether to
    install experimental plug-ins, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一个简单的XYZ框架管理部分的页面，允许用户浏览插件，并点击一个进行安装，无需担心细节。更好的是，允许高级用户自定义用于下载的远程服务器，无论是安装实验性插件，等等。
- en: In other words, we need to embed the PEAR installer directly inside the XYZ
    framework, and use it to handle the dirty work of querying remote servers, retrieving
    plug-ins, and doing the actual installing/upgrading process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要将PEAR安装器直接嵌入到XYZ框架中，并使用它来处理查询远程服务器、检索插件以及执行实际的安装/升级过程。
- en: Simplify User Choices for Installation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化安装的用户选择
- en: 'Embedding the PEAR installer makes it possible to focus on the important part
    of your application: ease of use and features for your users. The last thing you
    need is for confused users to simply give up on your application because you wasted
    too much time on re-inventing the internals, and not enough time on the visual
    and logical layout.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入PEAR安装器使得可以专注于应用程序的重要部分：易用性和为用户提供的特性。您最不希望的事情就是用户因为您在重造内部结构上浪费了太多时间，而没有足够的时间在视觉和逻辑布局上。
- en: Relying on the PEAR installer will give both, more time for streamlining the
    look and flow of the plug-ins page, and also allow creation of simple "click here
    to install" links that will properly download the right plug-in for the current
    combination of PHP version, framework version, and requested stability level.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖PEAR安装器将为优化插件页面的外观和流程提供更多时间，并允许创建简单的“点击此处安装”链接，这些链接将正确下载适合当前PHP版本、框架版本和请求的稳定性级别的正确插件。
- en: Eliminate Chances for Error
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除错误的可能性
- en: As always, by avoiding the urge to re-invent the wheel, this cuts down on the
    complexity of your application, making it much less likely that a bug will be
    introduced, and saving both time and future effort. PEAR's robust test suite and
    large community of users can be relied upon to ensure the stability of the PEAR
    installer, freeing you to work on the robustness of your own code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总是避免重造轮子的冲动，这可以减少应用程序的复杂性，使得引入错误的几率大大降低，同时节省时间和未来的努力。可以信赖PEAR的健壮测试套件和庞大的用户群体，以确保PEAR安装器的稳定性，让您可以专注于自己的代码的健壮性。
- en: Other Plug-In Systems
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他插件系统
- en: 'Before diving in, let''s take a look at other possibilities for bundling plug-ins.
    There are three models currently employed by major PHP applications:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们看看其他打包插件的可能性。目前，主要PHP应用程序采用了三种模型：
- en: Bundling plug-ins directly in the source code
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在源代码中打包插件
- en: Using PEAR dependencies for subpackages
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子包的PEAR依赖
- en: Customized remote plug-in servers
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制的远程插件服务器
- en: Bundling Plug-Ins Directly in the Source Code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接在源代码中打包插件
- en: By far, the most common solution employed in the PHP world is bundling plug-ins
    directly in the source code. This method, as explored in previous chapters results
    in code that can be simpler to create, but is far more difficult to maintain,
    and particularly to upgrade, often resulting in out-of-date code. As recent security
    vulnerabilities in popular programs demonstrate, keeping code up-to-date and bug-free
    is not just important for minor annoyances; it can make the difference between
    a secure and an insecure application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP世界中，最常用的解决方案是将插件直接打包在源代码中。这种方法，如前几章所探讨的，结果是可以创建更简单的代码，但维护起来却困难得多，尤其是升级，往往导致代码过时。正如最近在流行程序中发现的网络安全漏洞所证明的，保持代码更新和没有错误不仅对微小的烦恼很重要；它可能是一个安全和不安全应用程序之间的区别。
- en: Although it is the most common choice, bundling plug-ins directly in the source
    code is just not a very flexible idea, and so we won't explore this idea in depth.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是最常见的选择，但将插件直接打包在源代码中并不是一个非常灵活的想法，所以我们不会深入探讨这个想法。
- en: Subpackages - PEAR Dependencies
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子包 - PEAR依赖
- en: Using the PEAR installer's facility to manage dependencies is another approach
    to bundling plug-ins, which is starting to gain momentum at `pear.php.net`. This
    approach was first suggested by the work I did on maintaining phpDocumentor. I
    noticed that when implementing a new template or a new converter for phpDocumentor,
    this often meant that point releases of the entire phpDocumentor package was necessary
    even when a small change was made to a template or to a converter. Although it
    is not necessarily bad to be releasing often, it is important to provide a good
    reason for users to upgrade. In this case, it meant choosing between a release
    with a small change and postponing the release.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PEAR 安装程序的依赖关系管理功能是捆绑插件的其他方法，这种方法在 `pear.php.net` 上开始获得动力。这种方法最初是由我在维护 phpDocumentor
    的工作中提出的。我注意到，在实现 phpDocumentor 的新模板或新转换器时，这通常意味着即使只是对模板或转换器进行了小的更改，也需要整个 phpDocumentor
    包的点发布。虽然频繁发布并不一定是一件坏事，但提供良好的理由让用户升级是很重要的。在这种情况下，这意味着在包含小更改的发布和推迟发布之间做出选择。
- en: In addition, when a new experimental converter, such as the PDF converter, was
    introduced, the stability level of the converter could only be documented as being
    less stable. Users often became confused about why an unstable converter was released
    with a stable phpDocumentor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当引入了新的实验性转换器，如 PDF 转换器时，转换器的稳定性只能记录为不太稳定。用户经常对为什么一个不稳定的转换器会与稳定的 phpDocumentor
    一起发布感到困惑。
- en: All of the problems pointed to the need for a better way to handle sub-sections
    of an application. The answer came in the form of subpackages. Subpackages are
    discrete PEAR packages that define a parent-child relationship between the larger
    application and a smaller section of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都指向了需要一种更好的方式来处理应用程序的子部分。答案以子包的形式出现。子包是离散的 PEAR 包，它们定义了大型应用程序与较小应用程序部分之间的父子关系。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A subpackage is a self-contained portion of an application that can not work
    without a parent application; for example, the **MDB2_mysqli** subpackage to the
    **MDB2** package. MDB2 can handle connections to the mysqli driver for MySQL versions
    4.1 and newer if the MDB2_mysqli package is installed. MDB2_mysqli cannot work
    on its own, and requires MDB2 in order to be useful. Hence, MDB2_mysqli is a subpackage
    of MDB2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 子包是应用程序的一个自包含部分，没有父应用程序就无法工作；例如，**MDB2_mysqli** 子包属于 **MDB2** 包。如果安装了 MDB2_mysqli
    包，MDB2 可以处理 MySQL 4.1 及以上版本的 mysqli 驱动程序连接。MDB2_mysqli 不能独立工作，需要 MDB2 才能发挥作用。因此，MDB2_mysqli
    是 MDB2 的子包。
- en: 'Case Study: MDB2'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究：MDB2
- en: The first package to take advantage of this idea was the MDB2 package ( [http://pear.php.net/MDB2](http://pear.php.net/MDB2))
    designed by Lukas Smith and Lorenzo Alberton to supersede the MDB package designed
    by Smith, Alberton, and inspired by Metabase created by Manuel Lemos.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个利用这一想法的包是 MDB2 包 ([http://pear.php.net/MDB2](http://pear.php.net/MDB2))，由
    Lukas Smith 和 Lorenzo Alberton 设计，旨在取代 Smith、Alberton 设计的 MDB 包，并受到 Manuel Lemos
    创建的 Metabase 的启发。
- en: MDB2 is a database abstraction layer that has a core set of functionality contained
    in the basic MDB2 package. Each specific database is accessed using a driver package.
    For instance, the mysqli driver is accessed using the MDB2_Driver_mysqli package.
    Unlike older database abstraction packages like the popular DB package, MDB2 has
    split off these drivers, so that each driver is maintained separately.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MDB2 是一个数据库抽象层，其核心功能包含在基本的 MDB2 包中。每个特定的数据库都通过一个驱动包来访问。例如，mysqli 驱动是通过 MDB2_Driver_mysqli
    包来访问的。与像 DB 这样的流行数据库抽象包不同，MDB2 已经将这些驱动程序分离出来，以便每个驱动程序可以单独维护。
- en: 'Each driver encapsulates the functionality of a single database, and as such,
    the subpackages are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个驱动程序封装了一个数据库的功能，因此，子包是：
- en: MDB2_Driver_mssql ( [http://pear.php.net/MDB2_Driver_mssql](http://pear.php.net/MDB2_Driver_mssql))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_mssql ([http://pear.php.net/MDB2_Driver_mssql](http://pear.php.net/MDB2_Driver_mssql))
- en: MDB2_Driver_sqlite ( [http://pear.php.net/MDB2_Driver_sqlite](http://pear.php.net/MDB2_Driver_sqlite))
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_sqlite ([http://pear.php.net/MDB2_Driver_sqlite](http://pear.php.net/MDB2_Driver_sqlite))
- en: MDB2_Driver_querysim ( [http://pear.php.net/MDB2_Driver_querysim](http://pear.php.net/MDB2_Driver_querysim))
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_querysim ([http://pear.php.net/MDB2_Driver_querysim](http://pear.php.net/MDB2_Driver_querysim))
- en: MDB2_Driver_pgsql ( [http://pear.php.net/MDB2_Driver_pgsql](http://pear.php.net/MDB2_Driver_pgsql))
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_pgsql ([http://pear.php.net/MDB2_Driver_pgsql](http://pear.php.net/MDB2_Driver_pgsql))
- en: MDB2_Driver_oci8 ( [http://pear.php.net/MDB2_Driver_oci8](http://pear.php.net/MDB2_Driver_oci8))
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_oci8 ([http://pear.php.net/MDB2_Driver_oci8](http://pear.php.net/MDB2_Driver_oci8))
- en: MDB2_Driver_mysqli ( [http://pear.php.net/MDB2_Driver_mysqli](http://pear.php.net/MDB2_Driver_mysqli))
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_mysqli ([http://pear.php.net/MDB2_Driver_mysqli](http://pear.php.net/MDB2_Driver_mysqli))
- en: MDB2_Driver_mysql ( [http://pear.php.net/MDB2_Driver_mysql](http://pear.php.net/MDB2_Driver_mysql))
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_mysql ([http://pear.php.net/MDB2_Driver_mysql](http://pear.php.net/MDB2_Driver_mysql))
- en: MDB2_Driver_ibase ( [http://pear.php.net/MDB2_Driver_ibase](http://pear.php.net/MDB2_Driver_ibase))
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_ibase ([http://pear.php.net/MDB2_Driver_ibase](http://pear.php.net/MDB2_Driver_ibase))
- en: MDB2_Driver_fbsql ( [http://pear.php.net/MDB2_Driver_fbsql](http://pear.php.net/MDB2_Driver_fbsql))
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2_Driver_fbsql ([http://pear.php.net/MDB2_Driver_fbsql](http://pear.php.net/MDB2_Driver_fbsql))
- en: Each driver has its own versioning, stability, and more importantly, a dependency
    on the database driver needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个驱动程序都有自己的版本、稳定性和更重要的是，对所需数据库驱动程序的依赖。
- en: The old model used by the DB package makes it impossible to specify dependencies
    on database extensions. In other words, to require the needed extensions for each
    driver would mean a dependency on the mssql, sqlite, pgsql, oci8, mysqli, mysql,
    ibase, and fbsql PHP extensions. Not only would this force unnecessary database
    extensions to be loaded in `php.ini`, it would cause potential conflicts between
    database extensions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DB包之前使用的旧模型使得无法指定对数据库扩展的依赖。换句话说，要为每个驱动程序要求所需的扩展，就意味着对mssql、sqlite、pgsql、oci8、mysqli、mysql、ibase和fbsql
    PHP扩展的依赖。这不仅会强制在`php.ini`中加载不必要的数据库扩展，还可能导致数据库扩展之间的潜在冲突。
- en: In addition, if a new driver was introduced, the stability of the DB package
    (stable) would automatically filter down to the extension. To get around this
    problem, DB uses a text file in the documentation describing the stability of
    each driver using a table. This information does not show up at installation time.
    If a new driver is introduced for MDB2, it could have a stability of `devel` or
    `alpha` even though MDB2 is `stable`. Also beneficial is the ability to release
    a new version of a driver independent from the parent MDB2 package. Any time a
    change is made to a DB driver, the entire DB package with all of its other drivers
    must be released.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果引入了新的驱动程序，数据库包（稳定版）的稳定性会自动过滤到扩展。为了解决这个问题，DB在文档中使用一个文本文件来描述每个驱动程序的稳定性，并使用表格来呈现。这些信息在安装时不会显示。如果为MDB2引入了新的驱动程序，即使MDB2是稳定的，它也可能具有`devel`或`alpha`的稳定性。还有益的是，可以独立于父MDB2包发布驱动程序的新版本。每次对DB驱动程序进行更改时，都必须发布包含所有其他驱动程序的整个DB包。
- en: 'There are some drawbacks to the MDB2 approach. First, in order to install MDB2,
    there are two steps needed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MDB2方法有一些缺点。首先，为了安装MDB2，需要两个步骤：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This requires knowing how to use the pear command-line as well as the name
    of the drivers. A common mistake (one I, myself, have made) is to instead type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要知道如何使用pear命令行以及驱动程序的名字。一个常见的错误（我自己也犯过）是输入：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This, of course, results in a very unhelpful error message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会导致一个非常不友好的错误信息：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition, uninstalling requires the same two steps, or passing both packages
    on the command-line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，卸载也需要相同的两个步骤，或者在命令行上传递两个包：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is, however, a better way to implement the subpackages model when using
    `package.xml` version 2.0 (MDB2 still uses the original version 1.0 implementation
    of `package.xml` as of the writing of this chapter). If MDB2 were to define install
    groups for each driver, this would allow users to install MDB2 and the proper
    database. For instance, consider this approach in `package.xml:`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用`package.xml`版本2.0（截至本章编写时，MDB2仍然使用原始的1.0版本实现）时，实现子包模型有更好的方法。如果MDB2为每个驱动程序定义安装组，这将使用户能够安装MDB2和适当的数据库。例如，考虑在`package.xml`中的这种方法：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This `package.xml` would allow users much more flexibility. When installing,
    users would see:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`package.xml`将为用户提供更多的灵活性。在安装时，用户会看到：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In order to install MDB2 with mysqli support, the user would simply type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装具有mysqli支持的MDB2，用户只需输入：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the MDB2_Driver_mysqli package would be downloaded and installed. Better
    yet, if at some point in time, MDB2 needs to be uninstalled, MDB2 and all of its
    drivers could be installed with a single command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将下载并安装MDB2_Driver_mysqli包。更好的是，如果在某个时间点需要卸载MDB2，可以使用单个命令安装MDB2及其所有驱动程序：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The disadvantage to this approach is that the output when installing or upgrading
    MDB2 is quite wordy, and could make it difficult to notice a stray error or warning.
    In addition, should a new driver be released, it must be added to `package.xml`
    in order to make the handy feature available. On the other hand, this could be
    an easy way to differentiate between recommended and experimental drivers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，在安装或升级 MDB2 时输出的信息相当冗长，可能会使得难以注意到一个意外的错误或警告。此外，如果发布了新的驱动程序，必须将其添加到
    `package.xml` 中，以便使便捷的功能可用。另一方面，这也可以是一个区分推荐和实验性驱动程序的好方法。
- en: In short, this approach is ripe for exploration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这种方法非常适合探索。
- en: 'Custom Plug-In Systems: Remote Server'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制插件系统：远程服务器
- en: The primary drawback of the subpackage approach used by MDB2 is that the end-user
    of MDB2 must have a working understanding of the PEAR installer in order to properly
    install the drivers. This can be a significant stumbling block for graphically-oriented
    users who are expecting to go to one location in order to manage and use your
    application. For instance, bloggers expect to be able to concentrate on authoring
    and the tasks associated with blogging. Very few bloggers want to spend time studying
    the intricacies of a subtle and powerful installation system like the PEAR installer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MDB2 使用的分包方法的缺点是，MDB2 的最终用户必须对 PEAR 安装程序有实际的理解，才能正确安装驱动程序。这对那些期望在一个地方管理并使用应用程序的图形化用户来说可能是一个重大的障碍。例如，博客作者期望能够专注于创作和与博客相关的任务。很少有博客作者愿意花时间去研究像
    PEAR 安装程序这样的微妙而强大的安装系统的复杂性。
- en: Instead, they want to be able to customize the look and feel of their blog,
    add or remove functional components of the blog at will, and do all of this from
    the same visual interface that is used for blogging.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，他们希望能够自定义博客的外观和感觉，随意添加或删除博客的功能组件，并且这一切都可以从用于博客的相同视觉界面中完成。
- en: 'If your application fits into a similar one-stop-for-everything model (and
    most web-based applications do fit this model), you will want to consider a way
    to remotely manage plug-ins and/or templates. In order to do this, your application
    needs to have three abstract components:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序适合于类似的一站式解决方案（并且大多数基于网络的程序都符合这种模式），你将希望考虑一种远程管理插件和/或模板的方法。为了做到这一点，你的应用程序需要具备三个抽象组件：
- en: The application plug-in manager
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序插件管理器
- en: The remote plug-in server
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程插件服务器
- en: A plug-in downloader/installer
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件下载/安装器
- en: 'If you''ve been paying attention in the last four chapters, you might note
    the striking similarity this bears to the goals of the PEAR Installer. Pairing
    up a PEAR Channel Server (refer [Chapter 5](ch05.html "Chapter 5. Releasing to
    the World: PEAR Channels")) with a customized embedded PEAR installer will enable
    construction of a highly sophisticated plug-in manager with minimal coding.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了前四章的内容，你可能会注意到这种相似性与 PEAR 安装程序的目标非常相似。将一个 PEAR Channel Server（参见 [第 5
    章](ch05.html "第 5 章。向世界发布：PEAR 通道"））与一个定制的嵌入式 PEAR 安装程序配对，将能够以最少的编码构建一个高度复杂的插件管理器。
- en: However, before we dive into the PEAR-based solution, let's look at another
    example from the current state of affairs, the fantastic **Serendipity** blog
    ( [http://www.s9y.org](http://www.s9y.org)). The Serendipity blog is an easy-to-install,
    highly configurable PHP-based blogging program that is very stable and feature-rich.
    In addition, it has had full support for PHP 5 and the latest database extensions
    for longer than most PHP-based blogging software, and has just recently reached
    the landmark of version 1.0\. Serendipity is licensed under the BSD license.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入探讨基于 PEAR 的解决方案之前，让我们先看看当前状况下的另一个例子，那就是令人惊叹的 **Serendipity** 博客（[http://www.s9y.org](http://www.s9y.org)）。Serendipity
    博客是一个易于安装、高度可配置的基于 PHP 的博客程序，它非常稳定且功能丰富。此外，它比大多数基于 PHP 的博客软件更早地完全支持 PHP 5 和最新的数据库扩展，并且最近刚刚达到了
    1.0 版本的里程碑。Serendipity 是在 BSD 许可证下授权的。
- en: 'Case Study: Serendipity Blog''s Spartacus Plug-In Manager'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究：Serendipity 博客的 Spartacus 插件管理器
- en: The Serendipity blog manages plug-ins through the use of a specialized plug-in
    called **Spartacus**. Spartacus is designed to work in the same way as any other
    Serendipity plug-in, but has the ability to query a list of trusted servers for
    both plug-ins and templates for the Serendipity blog, and then to easily allow
    users to download and/or upgrade the plug-ins.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Serendipity博客通过使用一个名为**Spartacus**的专业插件来管理插件。Spartacus设计成与任何其他Serendipity插件以相同的方式工作，但具有查询受信任服务器中Serendipity博客的插件和模板列表的能力，并允许用户轻松下载和/或升级插件。
- en: '![Case Study: Serendipity Blog''s Spartacus Plug-In Manager](img/1904811191_6_3.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![案例研究：Serendipity博客的Spartacus插件管理器](img/1904811191_6_3.jpg)'
- en: The structure of a Serendipity plug-in consists of a single PHP file located
    at a special location. Each plug-in resides within a separate directory, and the
    directory may contain a number of additional files. As such, the Spartacus plug-in
    consists of the `serendipity_event_spartacus.php` file and a number of different
    language translations for text prompts used in the plug-in.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Serendipity插件的架构由位于特殊位置的单一PHP文件组成。每个插件都位于一个单独的目录中，该目录可能包含多个附加文件。因此，Spartacus插件由`serendipity_event_spartacus.php`文件和用于插件中使用的文本提示的不同语言翻译组成。
- en: 'Within the `serendipity_event_spartacus.php` file, there is a single class
    containing a number of different methods. The methods can be roughly grouped into
    a few simple categories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`serendipity_event_spartacus.php`文件中，有一个包含多个不同方法的单个类。这些方法可以大致分为几个简单的类别：
- en: Utility methods such as `microtime_float()`, which works around deficiencies
    in PHP's internal `microtime()` function in PHP versions prior to 5.0.0.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如`microtime_float()`之类的实用方法，它解决了PHP版本5.0.0之前PHP内部`microtime()`函数的不足。
- en: Universal plug-in methods, common to every plug-in needed for introspection
    of plug-in name/author, Serendipity events hooked into, configuration variables,
    and so on.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用插件方法，适用于每个插件，用于插件名称/作者、Serendipity事件钩入、配置变量等的检查。
- en: XML-manipulation methods for processing remote meta-data about plug-ins and
    templates.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理关于插件和模板的远程元数据的XML操作方法。
- en: File-management methods for installing and uninstalling plug-ins and templates.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和卸载插件及模板的文件管理方法。
- en: Remote HTTP download methods based on PEAR's **HTTP_Request** package.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于PEAR的**HTTP_Request**包的远程HTTP下载方法。
- en: Data-caching methods for storing downloaded plug-in information.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储下载的插件信息的数据缓存方法。
- en: Methods for building plug-in list.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建插件列表的方法。
- en: Methods for building the template list and downloading the preview thumbnail.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模板列表和下载预览缩略图的方法。
- en: Even with all of this functionality, the entire plug-in file weighs in at 805
    lines with comments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有所有这些功能，整个插件文件（包含注释）也有805行。
- en: The basic design behind Spartacus is to fetch a descriptive XML file (basically
    a REST service) from a trusted server, parse information about plug-ins or templates
    from the file, format this into the style needed by Serendipity to display plug-ins,
    and then to process user requests from Serendipity's event hooks and download/install
    plug-ins and templates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Spartacus背后的基本设计是从受信任的服务器获取描述性XML文件（基本上是一个REST服务），从文件中解析有关插件或模板的信息，将其格式化为Serendipity显示插件所需的形式，然后从Serendipity的事件钩子处理用户请求，下载/安装插件和模板。
- en: 'In order to download the plug-ins, Serendipity uses a simple but inflexible
    system based on static URLs. Constructing the URL for a plug-in''s meta-data takes
    place in this manner:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载插件，Serendipity使用了一个简单但不够灵活的系统，该系统基于静态URL。构建插件元数据的URL的方式如下：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `$url` is then used to download the actual meta-data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`$url`用于下载实际的元数据。
- en: 'Displaying the meta-data requires a check to see if the plug-in is already
    installed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显示元数据需要检查插件是否已经安装：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note the highlighted entries showing the essential test of whether the plug-in
    can be upgraded. This is used to decide whether a plug-in is clickable (installable/upgradable).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意突出显示的条目，这些条目显示了插件是否可以升级的基本测试。这用于决定插件是否可点击（可安装/升级）。
- en: 'Once a user decides to download a plug-in, Spartacus cycles through the list
    of files from the plug-in''s metadata, and downloads them one-by-one using a static
    URL and a ViewCVS trick (highlighted in the following example) to retrieve them.
    Here is the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户决定下载插件，Spartacus将遍历插件元数据中的文件列表，并使用静态URL和ViewCVS技巧（如下例所示）逐个下载它们。以下是代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This ViewCVS trick (retrieving revision 1.9999) is a very simple way of retrieving
    the correct version of files to install, but it does not allow for much flexibility,
    and requires strict control over revisions on the server — a single mistake will
    bring down the installation of an entire plug-in, and potentially the entire local
    install of our personal Serendipity blog.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ViewCVS技巧（检索修订版1.9999）是一种非常简单的方法来检索要安装的正确版本的文件，但它并不提供太多的灵活性，并且需要在服务器上严格控制修订版本——一个错误就会使整个插件甚至我们个人Serendipity博客的本地安装崩溃。
- en: 'As such, the Serendipity developers have placed a to-do note at the top of
    the page with some ideas for the next implementation of Spartacus to address these
    issues:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Serendipity的开发者已在页面顶部放置了一个待办事项笔记，其中包含一些关于Spartacus下一个实现版本以解决这些问题的想法：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both of these are hard problems to solve. To solve the first, we need to be
    able to do some relatively complex dependency validation, and have the ability
    to cycle through available versions of the plug-in until we find one that can
    work with the current Serendipity version. The second also requires some sophisticated
    server/client communication, and could add significant bloat to Serendipity as
    they move forward in development of Spartacus.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是难以解决的问题。要解决第一个，我们需要能够进行一些相对复杂的依赖验证，并且有能力遍历插件的可用版本，直到找到一个可以与当前Serendipity版本一起工作的版本。第二个也需要一些复杂的服务器/客户端通信，并且可能会在Spartacus的开发过程中给Serendipity增加显著的冗余。
- en: Fortunately, there is a solution to this issue. The PEAR installer is specifically
    designed to handle situations even more complex than what Serendipity's Spartacus
    plug-in is attempting to grapple with, and can be embedded within an application
    with surprisingly minimal effort.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案。PEAR安装器专门设计来处理比Serendipity的Spartacus插件试图解决的问题更为复杂的情况，并且可以以惊人的最小努力嵌入到应用程序中。
- en: 'Case Study: Seagull Framework''s Embedded PEAR Installer'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究：Seagull框架的嵌入式PEAR安装器
- en: '**Seagull Framework** ( [http://www.seagullproject.org/](http://www.seagullproject.org/))
    is an example of a web-based application that takes an extremely minimal approach
    to embedding the'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seagull框架**（[http://www.seagullproject.org/](http://www.seagullproject.org/））是一个基于网络的示例，它采取了极简的方法来嵌入'
- en: PEAR installer. Unlike Serendipity, Seagull is more of a general-purpose framework,
    designed to make it easy to build other things. Seagull provides glue and more
    than a few handy buzzword-friendly ideas for your development pleasure, like software
    patterns implemented in PHP (Front Controller, Observer, Service Locator, Task
    Runner, Wizard, etc.), and utility classes such as HtmlRenderer, UrlParser, and
    Emailer.php. A quick browse of [http://trac.seagullproject.org/browser/trunk/lib/SGL](http://trac.seagullproject.org/browser/trunk/lib/SGL)
    shows the full range of power available.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR安装器。与Serendipity不同，Seagull更像是一个通用框架，旨在使构建其他事物变得容易。Seagull提供了粘合剂以及许多方便的 buzzword-friendly
    理念，以供您在开发中享受，例如在PHP中实现的软件模式（前端控制器、观察者、服务定位器、任务运行器、向导等），以及如HtmlRenderer、UrlParser和Emailer.php之类的实用类。快速浏览[http://trac.seagullproject.org/browser/trunk/lib/SGL](http://trac.seagullproject.org/browser/trunk/lib/SGL)可以看到可用的全部功能范围。
- en: Like phpDocumentor, Seagull is available as a one-stop unzip-and-go zip file,
    or can be installed using the PEAR installer. Also like phpDocumentor, lesser
    configuration is needed on installation or upgrade, when installing via the PEAR
    Installer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与phpDocumentor一样，Seagull也提供了一站式解压即用的zip文件，或者可以通过PEAR安装器进行安装。同样，与phpDocumentor一样，通过PEAR安装器安装或升级时，所需的配置较少。
- en: 'In addition, Seagull bases much of its work on the pre-existing foundation
    of PEAR packages available from [http://pear.php.net](http://pear.php.net). Seagull
    uses a full range of PEAR packages. Here''s a sampling of some of the dependencies:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Seagull的大部分工作基于从[http://pear.php.net](http://pear.php.net)可获得的现有PEAR包的基础。Seagull使用了一系列的PEAR包。以下是一些依赖性的样本：
- en: Archive_Tar
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档Tar
- en: Cache_Lite
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存Lite
- en: Config
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Date
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: DB
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: DB_DataObject
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库数据对象
- en: DB_NestedSet
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库嵌套集合
- en: File
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: HTML_Common
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML公共部分
- en: HTML_TreeMenu
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML树菜单
- en: HTML_QuickForm
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML快速表单
- en: HTML_Template_Flexy
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML模板Flexy
- en: HTTP_Header
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头部
- en: HTTP_Download
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP下载
- en: Log
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Mail_Mime
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件MIME
- en: Net_Socket
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络套接字
- en: Net_Useragent_Detect
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络用户代理检测
- en: Pager
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页器
- en: Text_Password
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本密码
- en: Translation2
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译2
- en: Validate
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: XML_Parser
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML解析器
- en: XML_Util
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML实用工具
- en: Whew!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: In addition, Seagull makes use of the **Role_Web** package available from the
    `pearified.com` channel so that installation and upgrading is a one-stop shop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Seagull 利用来自 `pearified.com` 频道的 **Role_Web** 包，使得安装和升级变得一站式服务。
- en: Managing all of these PEAR dependencies can be a real pain in the rear end,
    especially when users are installing Seagull expecting to only use Seagull. When
    they discover that they need to use the PEAR installer to manage Seagull's dependencies,
    this confuses the issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 管理所有这些 PEAR 依赖项可能真的会让人头疼，尤其是当用户安装 Seagull 期望只使用 Seagull 时。当他们发现需要使用 PEAR 安装器来管理
    Seagull 的依赖项时，这会使得问题更加复杂。
- en: 'As such, Seagull creator Demian Turner has developed the first-ever experimental
    embedding of the PEAR installer into Seagull. The embedding is only available
    in the latest versions of Seagull, and is considered to be of alpha-code quality,
    but is well worth examining for the principles the code employs. Here is a screenshot
    of the actual Seagull PEAR Manager:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Seagull 的创造者 Demian Turner 开发了第一个实验性的将 PEAR 安装器嵌入到 Seagull 中的实例。这种嵌入仅适用于
    Seagull 的最新版本，并且被认为是 alpha 级代码质量，但非常值得研究其代码所采用的原理。以下是实际的 Seagull PEAR 管理器的截图：
- en: '![Case Study: Seagull Framework''s Embedded PEAR Installer](img/1904811191_6_4.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![案例研究：Seagull 框架的嵌入式 PEAR 安装器](img/1904811191_6_4.jpg)'
- en: Found in the `modules/default/classes/PearMgr.php` file, the PEAR Manager for
    Seagull provides a customized web-based front end to any PEAR channel for listing
    of packages, installation, and upgrading.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `modules/default/classes/PearMgr.php` 文件中，Seagull 的 PEAR 管理器提供了一个定制的基于 Web
    的前端，用于列出任何 PEAR 频道的包、安装和升级。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Location of PearMgr.php**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**PearMgr.php 的位置**'
- en: Seagull takes advantage of the subpackage feature of `package.xml` version 2.0,
    and has split its large code base into a base package and three subpackages. The
    `PearMgr.php` file is found in the `pear.phpkitchen.com/Seagull_Default` package,
    which is required and automatically installed by default when installing Seagull.
    Users installing from SourceForge unzip-and-go will get all the files in one zip
    file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Seagull 利用 `package.xml` 版本 2.0 的子包功能，将其庞大的代码库分为一个基础包和三个子包。`PearMgr.php` 文件位于
    `pear.phpkitchen.com/Seagull_Default` 包中，该包在安装 Seagull 时默认需要和自动安装。从 SourceForge
    安装源代码的用户将获得一个包含所有文件的单一压缩文件。
- en: 'Seagull uses a customized version (one line is changed, and the templates are
    different) of the **PEAR_Frontend_Web** package available from `pear.php.net`
    along with `PearMgr.php` to manage PEAR installation/upgrading. Seagull also adds
    seven commands to the PEAR installer: `sgl-clear-cache, sgl-download, sgl-list-all,
    sgl-list-upgrades, sgl-remote-info`, and `sgl-search`. These commands are again
    implemented in a near carbon-copy of the PEAR equivalents, except they remove
    all calls to the `outputData()` method, something we will address later on in
    the text.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Seagull 使用了来自 `pear.php.net` 的 **PEAR_Frontend_Web** 包的定制版本（更改了一行，模板不同），以及 `PearMgr.php`
    来管理 PEAR 的安装/升级。Seagull 还向 PEAR 安装器添加了七个命令：`sgl-clear-cache, sgl-download, sgl-list-all,
    sgl-list-upgrades, sgl-remote-info` 和 `sgl-search`。这些命令再次以 PEAR 等价物的几乎完全相同的方式实现，除了它们移除了所有对
    `outputData()` 方法的调用，这一点我们将在稍后的文本中讨论。
- en: The code in `PearMgr.php` is approximately 200 lines. So, in a quarter of the
    length of Serendipity's Spartacus, Seagull has implemented a fully functional
    remote plug-in installer that can also be used to upgrade Seagull itself!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`PearMgr.php` 中的代码大约有 200 行。因此，在 Serendipity 的 Spartacus 长度的四分之一内，Seagull 实现了一个功能齐全的远程插件安装器，也可以用来升级
    Seagull 本身！'
- en: 'Let''s take a look at the code that is used to determine which channels can
    be used:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于确定哪些频道可以使用的代码：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with Spartacus, the servers are hard-coded. However, unlike Spartacus, should
    any of these channels add a mirror at any point in the future, PEAR will take
    care of updating this information, and the mirror will automatically be available
    to the user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与斯巴达克斯一样，服务器是硬编码的。然而，与斯巴达克斯不同，如果这些频道中的任何一个在未来任何时候添加一个镜像，PEAR 将会负责更新这些信息，并且镜像将自动对用户可用。
- en: 'The actual package download/install/upgrade management all uses PEAR''s abstract
    command interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的包下载/安装/升级管理全部使用 PEAR 的抽象命令接口：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The PEAR-specific code has been highlighted in the example. The entire complexity
    of listing packages is taken care of in just two lines of code. The same is true
    of installation, uninstallation, and upgrading.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中突出显示了 PEAR 特定的代码。列出包的整个复杂性仅用两行代码就解决了。安装、卸载和升级也是如此。
- en: There is a rather curious usage of output buffering to capture the informational
    output of the PEAR command. This appears to be necessary because PEAR will output
    information to the screen if given a choice, but in fact it is possible to capture
    this output without resorting to hacks. In defense of the Seagull developers,
    I can't imagine much more cutting edge code than what they are trying to do, and
    they did it without the benefit of this book!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to capturing the output of the PEAR-installation process is in fact
    to register a front-end object. The code below shows an example of the right way
    to do this kind of thing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this point, the `$capture->data` array contains all of the information that
    would normally be displayed by the PEAR installer in the order in which it occurred,
    and it can be ignored or displayed in appropriate fashion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen an example of embedding the PEAR installer, it is time
    for our feature attraction: designing a customized PEAR channel-based plug-in
    system that takes full advantage of the customizability of the PEAR installer.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Custom PEAR Channel-Based Plug-In System
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this system, we will design a template installer that is for the fictional
    blogging program "MyBlog." Before we look at the code, it is important to understand
    the problem. Here are the requirements of the MyBlog template system:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Templates need to have thumbnail images associated with them that the user can
    use to visually preview the template.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates must be listed without requiring scrolling (paginated results).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be possible to label new templates as experimental.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates must be matched to the MyBlog version they are intended for.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any template that does not fit the needs of the blog user should not be displayed
    in the list of templates, like the templates that are too experimental or do not
    work with the current version of MyBlog.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates must be remotely installable only from a discrete list of trusted
    servers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template should also be installable from a locally downloaded template.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plug-in manager should work in PHP 5.0.0 and later. PEAR is of course compatible
    with PHP versions 4.2.0 and newer, but let's assume that MyBlog is designed to
    take advantage of some of the fantastic new features in PHP version 5\. Porting
    this code to work with PHP 4 is a simple task, it would involve replacing a few
    keywords and using PEAR_Error instead of exceptions; an exercise left to the reader.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of these requirements, we will need to take advantage of `channel.xml's`
    ability to specify customized web services, in this case an additional REST protocol
    for the template thumbnail images. In addition, we will need to implement a customized
    remote listing of templates that is able to filter out templates that will not
    work with the current version of MyBlog, and also filter by stability. The rest
    of the requirements can be handled easily by existing PEAR functionality.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement the PEAR-specific code. As such, we will
    not make the next cool CMS out of our MyBlog program nor will we implement the
    server-side template thumbnail uploader, as this is a common task that is easily
    implemented using PHP.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement the tasks required, we will create a class responsible
    for downloading and processing REST from the remote server, a class for organizing
    and paginating the templates, and a class for downloading and installing the templates.
    In this case, once a template is installed, there is no need to uninstall directly,
    but implementing this is quite simple once the basic principles are understood.
    Our template switcher simply installs or upgrades if necessary.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Existing Functionality
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will make full use of the `PEAR_REST` class, `PEAR_Downloader`
    and `PEAR_Installer` classes, and also the `PEAR_Config/PEAR_Registry` internal
    classes. Re-using components is the primary strength of this approach, and is
    of course the primary purpose of the PEAR repository. It cannot be overstressed
    how important this is for both cutting down on initial development time and on
    the pain of debugging later on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: When re-using code, it is important to verify the stability and the robustness
    of the user community surrounding the code. The PEAR installer of course has an
    extensive test suite and both a large user base and a core of experienced and
    dedicated developers from all over the planet, who work to maintain and enhance
    the package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the classes from the PEAR package that we will be using.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'PEAR Installer Infrastructure: REST and PEAR Installer Classes'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The PEAR installer primarily consists of several classes. The classes that
    we will need to understand for our template plug-in system are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_Config`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_Dependency2`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_REST`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_REST_11`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_REST_10`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_Downloader`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_Downloader_Package`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_Installer`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complexity of these multi-purpose classes can be quite daunting; so let's
    take a step back and examine what we will actually need from each class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_Config
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PEAR_Config` class is used to manage basic configuration issues for the
    PEAR installer. As such, it is designed to easily retrieve the related internal-package
    registry, a REST object, and all kinds of other features that we don't really
    need to care about.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, we only really need to understand three things about the
    `PEAR_Config` object as it is used by the PEAR installer:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: A `PEAR_Config` object is generally used as a singleton by the installer.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get()` method is used to retrieve configuration values.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `set()` method is used to set configuration values in-memory only, and will
    not affect on-disk configuration files unless `writeConfigFile()` is used to save
    the values.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the PEAR installer is initialized, the `PEAR_Config::singleton()` method
    is called with default values. If these values are not set to the proper location,
    then our template plug-in system will save templates in the global PEAR location.
    In some cases, this is great, as the application is designed to work within the
    system context.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application instead uses a local install for plug-ins internal to the
    application, you''ll need to set all of the configuration values before performing
    installation tasks. Seagull Framework is a good example of a program that needs
    to set the configuration values, and the method with which they are set, is the
    best practice. Here it is:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At a minimum, you will need to set all of the `_dir` configuration values (`bin_dir,
    doc_dir, ext_dir, php_dir, cache_dir, data_dir, download_dir, temp_dir`, and `test_dir`
    as of PEAR 1.4.10) to valid values. The `preferred_state` variable should be set
    to `stable` unless the user expects to be able to install experimental templates,
    then one of `beta, alpha`, or `devel` should be used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be using the low-level registry in order to determine whether
    a template package is already installed, in a similar fashion to the method used
    by Serendipity''s Spartacus plug-in:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In our example, we retrieve the currently installed version of the template,
    and as a sanity check, ensure that we are not attempting to install the currently
    installed version.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that it may be desirable to allow the user to force re-installation.
    If this is the case, the code should be modified such that if the versions are
    the same, the `force` option is passed to installation. The topic of installation
    options will be discussed in the later section on `PEAR_Installer`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_Dependency2
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PEAR_Dependency2` class is a simple utility class that is used by the PEAR
    installer to validate `package.xml` dependencies against all of the variables
    on a system. This is a low-level class that in fact expects as its input the unserialized
    XML dependency straight from `package.xml`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, consider the following to be the dependency you are trying
    to validate:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`PEAR_Dependency2` then expects the variable representing the dependency to
    contain this array:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For our application, the only use we have for the `PEAR_Dependency2` class is
    to validate the dependency against the parent MyBlog application. We need to make
    sure that the template actually works with the current MyBlog version. As such,
    the only dependency we will need to validate is the required package dependency
    on the MyBlog package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This greatly simplifies the usage of `PEAR_Dependency2`, and all we need to
    understand is how to use it to validate a package dependency. The method that
    will be used for this task is called `validatePackageDependency()`, as one might
    expect. The method signature expects the dependency array as our example above,
    a boolean representing whether the dependency is required or optional, and an
    array containing the list of all packages that will attempt to be installed in
    this iteration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is irrelevant to our task, as only one template will ever
    be installed at a time, and so we will always pass an empty array for this parameter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP code, the signature as we use it will look something like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with all of `PEAR_Dependency2's` validation methods, `validatePackageDependency()`
    returns either `true`, an array, or a `PEAR_Error` object. `true` is returned
    upon success, an array containing an error message is returned if there is a warning
    that does not invalidate the dependency, and a `PEAR_Error` object is returned
    if the dependency validation fails.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'As PEAR''s error handling allows registering a callback, it is very important
    to disable any callbacks while calling the dependency validation, and so our total
    code looks like:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The above code tells PEAR to simply return `PEAR_Error` objects, temporarily
    ignoring any special handling the user has specified, attempt to validate the
    dependency, and then if the validation fails, to skip this release of the template.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we extract the `$pdep` variable from dependency information? The answer
    is semi-intuitive, actually. Just as the example dependency from above is extracted
    to an array matching the XML tag name to the tag contents, the same is true of
    its parent tag. The full array for the dependency above is:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that if we have more than one required package dependency, the array will
    look like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, the package tags are in fact an array of arrays. I've found that
    the easiest way to handle this fact is to always convert the package element into
    an array of itself if it does not contain numeric indices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code that accesses the required package dependencies of a
    template:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we can also easily skip static uri-based dependencies by checking
    for the existence of a`<channel>` tag inside the dependency, and skip them accordingly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_REST and PEAR_REST_10/PEAR_REST_11
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PEAR_REST` class is a general utility class for downloading, parsing, and
    caching remote REST files. It is the REST equivalent of the XML-RPC class that
    PEAR used to use for the older XMLRPC-based channels. We will be using this low-level
    class to retrieve the PNG thumbnail image of templates, and so need to know about
    the `retrieveCacheFirst()` method. This method first checks the local cache, and
    if it exists, never attempts to query the remote server. If the file has never
    been downloaded, it then queries the server to retrieve it. As its argument, it
    simply takes a full URL to the file that one wishes to download, and returns its
    contents in a string.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The `retrieveData()` method takes a different approach. If the cache is young
    enough (3600 seconds by default), it is used without querying the remote server.
    After this time, the server is queried using HTTP 1.1 and HTTP caching is used
    to determine whether downloading is necessary. This can dramatically cut down
    on bandwidth, as the file is only downloaded if there are any changes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that XML files (as identified by the Content-Type HTTP header)
    will be parsed into an array automatically by both `retrieveData()` and `retrieveCacheFirst()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_REST_10` and `PEAR_REST_11` implement the REST1.0 and REST1.1 PEAR REST
    standards, as described in [Chapter 5](ch05.html "Chapter 5. Releasing to the
    World: PEAR Channels"). As such, the methods implement ways of retrieving useful
    information from the raw REST data, such as the download information for a particular
    package, or a list of all packages with current releases. For our purposes, we
    will need to implement a modified version of the REST1.1 `listAll()` method, one
    that filters out incompatible templates and experimental templates. In order to
    implement this, we will cut-and-paste the code from `PEAR_REST_11` and use that
    to implement our `listTemplates()` method by tweaking the loop that examines each
    package.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cutting and pasting from `PEAR_REST_11` may seem to be an unclean approach,
    as cut and paste is generally frowned upon by the purist element, but in our case
    it demonstrates an important principle of the REST design. If PEAR still used
    XML-RPC, it would in fact be impossible to implement the customized template listing
    that we desire, because some of the necessary information would have been stripped
    on the server side.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The REST model makes the data available and expects the client to do any filtering
    of that data. This is in fact both more efficient and more flexible, which cuts
    down on programming time and completely eliminates the hacks that used to be necessary
    when designing around the system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we are cutting and pasting, but the code is drawing upon a well-defined,
    simple system of remote REST resources, and so we can be certain it will continue
    to work as the standards evolve.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'In our simple implementation, the only method of the REST1.0-based `PEAR_REST_10`
    class that we will need is the `getDownloadURL()` method, in order to implement
    our customized template download with restrictions. The API signature of `getDownloadURL()`
    is somewhat complex, and as such it is helpful to examine the actual code with
    comment from the `PEAR_REST_10` class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`getDownloadURL()` either returns a `PEAR_Error` or an array. The array will
    contain an associative index `url` if the package can be successfully downloaded.
    If none of the releases meet the conditions specified, then the `url` index will
    not be present. As such, we can use the `getDownloadURL()` method very simply:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `url` does not contain a file extension, as this is determined
    by the presence of the zlib extension. If we have zlib, then we can download the
    compressed release, and save some time and bandwidth. Otherwise, the uncompressed
    `.tar` is downloaded and installed instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This is essentially all of the code needed to successfully leverage our remote
    server querying! The only task left is the actual downloading and installation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_Downloader and PEAR_Downloader_Package
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Downloading, as seen by the PEAR installer, is not just a simple task of grabbing
    a url via HTTP and saving its contents locally as a file. The PEAR installer intelligently
    downloads the right version of a package based on its dependencies and the local
    system, and also automatically downloads package dependencies in certain situations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PEAR Downloader` mechanism understands three different kinds of installable
    packages:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Abstract package names, i.e. `pear install PEAR` or `pear install PEAR-beta`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute URLs, i.e. `pear install` [http://pear.example.com/Blah-1.2.3.tgz](http://pear.example.com/Blah-1.2.3.tgz)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local files, i.e. `pear install /path/to/Blah-1.2.3.tgz`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance is handled very differently. Local packages are handled in a simple
    manner, as one might expect. Absolute URLs are first downloaded, and then treated
    in the same way as local packages. Abstract packages are treated very differently.
    No downloading is performed until the installer is sure that all dependencies
    have been satisfied. This ensures that if a complex application's dependencies
    are not satisfied, no time or bandwidth will be wasted downloading large package
    files.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: However, in each of the three kinds of downloadable packages, the way their
    dependencies and package information are handled is the same. Because of this,
    to avoid unnecessary code duplication, the three kinds of downloadable packages
    are abstracted into the `PEAR_Downloader_Package` class. Many of the API functions
    in `PEAR_Downloader` and `PEAR_Installer` expect or return a `PEAR_Downloader_Package`
    object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the first and most important method to investigate is `PEAR_Downloader''s
    download()` method. This method expects as input a simple array of strings, each
    string representing one of the three forms of downloadable packages. Here is an
    example demonstrating all three:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Options can be passed to the `download()` method, but they must be specified
    when creating the `PEAR_Downloader` object:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Options available for the `PEAR_Downloader` include `force, downloadonly, soft,
    offline, packagingroot, nodeps, pretend, ignore-errors, nocompress, alldeps, onlyreqdeps`,
    and `installroot`. In other words, the options that are displayed when executing
    `pear help install` are all available, plus the internal option `downloadonly`,
    which is used by the `pear download` command.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The main options that may be of interest when designing an embedded PEAR installer
    are the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`force:` This option forcibly installs even if dependencies are invalid, or
    the package is already installed. The best usage of the `force` option is to repair
    a corrupted installation.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offline:` This option prevents any attempts to contact remote servers, and
    can be useful in installation settings.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nocompress:` This option instructs the installer to download uncompressed
    `.tar` files rather than `.tgz` files, and is useful when the zlib extension is
    not present.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodeps:` This option prevents the downloader from attempting to validate dependencies,
    or from downloading required package dependencies.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pretend:` This option instructs the downloader to simply grab a listing of
    all packages that would be downloaded, and to return that, but not to do any actual
    downloading. This is useful for displaying to the user what packages would need
    to be installed or upgraded.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alldeps/onlyreqdeps:` These options instruct the downloader to automatically
    download package dependencies. The `onlyreqdeps` option instructs the installer
    to only download required dependencies, whereas `alldeps` downloads all dependencies.
    `onlyreqdeps` is obsolete by `package.xml` version 2.0, but is still useful for
    the many PEAR packages that still use `package.xml 1.0` at `pear.php.net`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `download()` method can return either a `PEAR_Error` object, or an `array()`.
    Now this is where things get a bit tricky. A `PEAR_Error` object is only returned
    in the case of an egregious error, such as the inability to access the local package
    registry, or some other exceptional circumstance. An array is returned in other
    situations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if downloading fails because every package passed in failed
    dependency validation, an empty array will be returned instead of a `PEAR_Error`
    object. Another way of thinking about this is that `PEAR_Downloader` is smart
    enough to skip downloads that fail and continue with ones that work, rather than
    halting the entire download experience just because a single package depended
    on the Gronk_Wzilnk package and it was unavailable.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the condition of multiple errors, `PEAR_Downloader` provides a `getErrorMsgs()`
    method that should always be checked after downloading. This method implements
    a simplistic array of multiple error messages that predated the advanced `PEAR_ErrorStack`
    class (and incidentally helped to inspire its creation). As such, the code that
    is used to download should look something like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `$info` variable should contain the name of a template to download
    in this example.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_Installer
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we arrive at the `PEAR_Installer` class. This class is monstrous, containing
    code for handling file transactions, basic installation, uninstallation, and is
    very significantly huge in general. `PEAR_Installer` is also one of the oldest
    classes in the PEAR package and although it has undergone a serious liposuction
    in PEAR 1.4.0 and newer, it will undergo further trimming in future versions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File transactions are the PEAR installer's equivalent to database transactions.
    When installing a package, the PEAR installer either fully installs a package,
    or rolls back the installation completely. When upgrading, the PEAR installer
    makes a backup copy of the previous version. If there are any problems in upgrading,
    the previous version is completely restored. This ensures that it is *impossible*
    for the package to be in a half-installed state of limbo if there are any errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we need to know about in our quest to install templates is not too
    surprisingly named `install()`. The `install()` method is rather flexible in its
    input, because of backwards compatibility. It is possible to pass in the array
    that we would pass to `PEAR_Downloader->download()`, but this results in significant
    guesswork by the installer to do what you should be telling it to do, and is deprecated.
    It is better is to pass in the array returned from `PEAR_Downloader->downloader()`,
    and to prepare for installation with a few helper methods:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Code specifically relating to installation has been highlighted above. Again,
    because the `PEAR_Installer` class is an older relic within the larger PEAR installer
    package, some of the things we can do with `PEAR_Downloader` must be done manually.
    For instance, options should be set with the `setOptions()` method. In addition,
    packages should be sorted for proper installation order using `sortPackagesForInstall()`.
    This ensures that dependencies are installed before any packages that depend upon
    them, as packages are installed by the `install()` method one at a time, without
    knowledge of the other packages that are being installed. This system also helps
    to ensure that the packages are rarely left in a dangerously corrupted state,
    should installation of any package fail.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Immediately preceding the `install()` method, packages that have already been
    downloaded should be registered as such so that pre-installation validation is
    only performed once. This must be done with the `setDownloadedPackages()` method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working understanding of the internals of the PEAR installer,
    let's look at the server side.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Extending REST with Custom Information
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to implement thumbnails on the server, first we need to implement customized
    REST for the server. Let's look at a typical `channel.xml:`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to add support for our custom-thumbnail REST, all we need to do
    is add another`<baseurl>` tag:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The new `baseurl` is highlighted in the previous example. This allows us to
    retrieve a template-thumbnail image with one line of code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we finally have enough information to actually implement our template manager!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing a Lightweight Installer Plug-In: The Code At Last'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our fake MyBlog, we will use this directory tree:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The PEAR-embedding occurs in the files located in the `Template/` subdirectory.
    The blog is implemented in the abstract by the `Config.php` and `Main.php` files,
    and the actual web files are `index.php, image.php`, and `admin.php`. We won''t
    concern ourselves yet with the design of the fake MyBlog blog. If you would like
    to play around with the fake MyBlog, you can install it via these steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MyBlog package from `pear.chiaraquartet.net` makes use of a post-installation
    script that has no prompting of the user at all. We'll go into the details of
    the post-install script in greater detail later on, as it shows another side of
    PEAR's versatility.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: MyBlog_Template_IConfig and MyBlog_Template_Config
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's dive in; first, `Interfaces.php:`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It doesn't get much simpler than that! This allows flexibility, loosely coupling
    the embedded PEAR with the template's configuration, and is always a good idea.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see the exception class, yet another example of complexity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'OK, I know what you''re thinking: that doesn''t look very complex. Actually,
    you''re right. I was just kidding. Now for the real deal; let''s start off with
    the configuration class from the MyBlog package. The `getTemplateChannel()` and'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '`getCurrentTemplate()` methods are simply hard-coded strings for our sample
    application, but let''s look at the `getPearConfig()` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Much like Seagull's package, we grab the `PEAR_Config` singleton object and
    customize it. However, our blog's templates will only ever use the php or the
    data role, and we are installing into an internal PEAR repository, so we can take
    advantage of PEAR's replacement tasks (see [Chapter 3](ch03.html "Chapter 3. Leveraging
    Full Application Support with the PEAR Installer") for a refresher on replacement
    tasks) to replace `@php-dir@` with the value of the `php_dir` configuration variable
    on the local computer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: In essence, this instructs PEAR to install templates into `@php-dir@/MyBlog/templates/`,
    which is exactly where we want them to go.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: MyBlog_Template_REST
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s jump into the REST class. This class simply requires a `PEAR_Config`
    object to get started, and is instantiated in `admin.php` like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Again, simplicity of use is the emphasis. Let''s see the complete code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: MyBlog_Template_Lister
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s look at the template lister. The template lister class, aptly
    named `MyBlog_Template_Lister`, is instantiated via this simple code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The primary method is `listRemoteTemplates()` and is called like so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The only argument passed is the number of templates to include per page. We
    pass in `1` because there are two sample templates for the fake MyBlog that are
    available for installation. The return value is a simple array, the first element
    being an array of data for paging, and the second a Pager object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of code re-use. When I first began designing the code,
    I thought it would make the most sense to write my own pager, as it seemed to
    be a 10-line deal. However, as I began to get further involved in the implementation,
    the complexity spiraled out of control, and I quickly switched to using the Pager
    package from `pear.php.net` ( [http://pear.php.net/Pager](http://pear.php.net/Pager)).
    This well-designed package is also well documented, and became a 10-minute job
    to implement the paging.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'From our example usage above, the `$info` variable is an array in our application,
    and its format is simply a numerically indexed array of arrays:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This can be iterated over quite easily to create the template listings. At this
    point, we should be ready to see the entire `MyBlog_Template_Lister` class file
    `Lister.php:`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: MyBlog_Template_Fetcher
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the installation manager class, which we''ll call `MyBlog_Template_Fetcher`.
    This class is also instantiated simply, but is a bit more involved than the other
    classes:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `MyBlog_Template_Fetcher` is instantiated by a factory method because it must
    be registered as a `PEAR_Frontend` object in order for the PEAR installer to use
    it to display output (as was mentioned in the section on the Seagull Framework
    earlier).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary method we''ll be using is `installTemplate()` and its usage is
    like so:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As the `MyBlog_Template_Fetcher` class mimics a `PEAR Frontend`, we need to
    define three methods, `log(), outputData()`, and `userConfirm()`. The first two
    simply store their input in an internal array for display later, and the last
    is a dummy method that will not be used in our sample application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the class listing:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is all we need to embed the PEAR installer, a mere 610 lines of code including
    extensive comments!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The MyBlog Post-Install Script
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To wrap up the installation, we''ll need a post-install script to initialize
    the environment. This time, let''s see the code before we learn about it:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As with all post-installation scripts, this one has a class named according
    to the file name with `DIRECTORY_SEPARATOR` replaced by`'_'` in the class name,
    and `_postinstall` appended. In other words, since this is `blogsetup.php` and
    is in the root directory of our `package.xml`, our class name is `blogsetup_postinstall`.
    The script has required `init()` and `run()` methods.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is needed because we are going to set up a customized internal
    PEAR repository inside the working directory of the application. In other words,
    the templates will be installed in their own internal universe with a unique registry
    and configuration settings. As such, the directory structure will need to look
    like the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Registry files for installed templates will go in `pear/MyBlog/templates/.registry/.channel.pear.chiaraquartet.net_template/`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: In addition, in our design, the default template is copied over and is always
    available, so that the blog can work out of the box.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we did not implement this in the fake blog or the lister class, the
    `MyBlog_Template_Fetcher` class is also capable of installing local template files,
    which allows blog maintainers to design their own templates, or modify existing
    ones and install them directly. For a challenge, see if you can implement local
    listing of installed templates. Hint: check out code from the `PEAR_Registry`
    class found in `PEAR/Registry.php`, and how it is used by the `pear list` command
    in `PEAR/Command/Registry.php`.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The last new feature to look at is how we can retrieve and display the thumbnail
    images for each template. To do this, we'll set up a small file called `image.php`,
    and our `src` attributes in`<img>` tags will refer to it in order to grab images.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`image.php` simply takes a template name and version, and then grabs the remote
    thumbnail. It is important that a file of this nature is not in fact reading local
    files and displaying them, as it constitutes a severe security risk. For instance,
    if `image.php` simply read local files relative to the current path and displayed
    them, a few guesses later, something like this request would retrieve the `/etc/passwd`
    file:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In our case, if the requested template doesn't have a thumbnail on the remote
    server, it won't be displayed. Here is `image.php:`
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, note the highlighted security-conscious code. Security must always be
    a concern!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The Rest of the Fake MyBlog Package
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we have examined all of the PEAR-specific code, so let''s look
    at the fake MyBlog package (again, installable from `pear.chiaraquartet.net` as
    package `chiara/MyBlog`). First, let''s see the code for the `MyBlog_Config` class,
    controlling basic configuration needs:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Simplicity itself, eh? Next, we'll look at the main MyBlog class. To implement
    the MyBlog, I chose to use the excellent Savant3 package (installable from the
    `savant.pearified.com` channel at [http://savant.pearified.com](http://savant.pearified.com))),
    a PHP template system that uses PHP as the templating language. For our fake blog,
    we will have two (or three) template files, one for the`<head>` element, another
    optional template for the attributes of the`<body>` tag, and a third for the contents
    of the blog. For our sample templates, we only use `head.tpl.php` and `body.tpl.php`.
    Here is the main blog file, `MyBlog_Main:`
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have a few unused methods that are there just to show what could be done.
    Templates are actually displayed by `index.php`, which consists of this code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The actual templates should be looked at for completeness, so here is `head.tpl.php`
    from one of the sample templates:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And `body.tpl.php:`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now I think it is clear why I keep referring to MyBlog as a fake blog! To demonstrate
    how the templates are installed, here is a `package.xml` file from the example1
    template:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To conclude this final chapter, let''s look at `admin.php`, the administrative
    control center, to see how all of these elements are brought together to display
    templates, download the right template versions, and install them:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For experimentation purposes, there are two `package.xml` files available for
    the MyBlog package in the code included with this book. The first, `package1.xml`,
    describes itself as MyBlog version 0.1.0, and will display the templates example1
    version 1.0.0 and example2 version 1.0.0 as being available for installation.
    After testing this, execute a from the MyBlog directory, a simple:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You will be upgraded to MyBlog version 0.2.0\. Immediately, you''ll notice
    that only example1 version 2.0.0 is available for installation. This is based
    upon the fact that example1''s `package1.xml` (version 1.0.0) has this required
    dependency in it:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Whereas `package.xml` (version 2.0.0) has this required dependency in it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These dependencies ensure that the templates are only available for blog versions
    they are compatible with. As such, if you decide to adopt this model, you'll need
    to ensure that all templates are released with a`<max>` element in their dependency
    on the blog, defining the highest version they are known to work with. As new
    versions are released, the templates can be released with updated`<max>` tags,
    or modified and then released. In this way, working templates will always be available
    for the differing blog versions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'In short: complexity is all managed by the internals of the PEAR installer,
    freeing you to write great programs!'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Improvements for the Ambitious
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the vexing problems of all web-based plug-in installation systems involves
    security of directory permissions. In order to install something, the web server's
    user (nobody or apache are common web users) must have write access to the plug-in
    directory. This means that anyone with an account on the machine and a public
    web page can write and read from your application's plug-in directory, simply
    by creating a web page that does this.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In our sample MyBlog, I made the dubious assumption that you are the sole owner
    of the blog server and do not need to worry about such issues, and did not implement
    a system for this important security issue.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a simple solution that requires a bit of work, and is a wonderful
    exercise for the ambitious. The trick is to provide a link on the page that is
    a little lock. The user must unlock the directory prior to installation, and it
    must be locked after.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Locking the page consists of recursively iterating over the internal plug-in
    directory, and running this simple command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Unlocking is its opposite, recursively iterating over the internal plug-in
    directory and running this simple command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Why, you might ask, are there no blog or other applications performing this
    task? There are several answers. First of all, the same task can be accomplished
    quite easily using a shell script. In other words "let the user take care of their
    own dang security." Also, this particular security issue simply hasn't been on
    the radar because it requires a malicious hacker to already have access to the
    machine to take advantage of it — or so one would think.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The fact is, if the application happens to have a PHP code injection vulnerability,
    this would allow a malicious hacker to inject code that creates a malicious PHP
    script on the server, thereby gaining control over the server through the fact
    that the plug-in directory is writeable! Although it takes a very, very serious
    vulnerability to become a problem, having writeable directories can make the difference
    between having and losing control over a production server.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Keep this in mind as you develop — security is always an important task! Try
    to think like an evildoer as you design, and you will have (and cause) far fewer
    security vulnerabilities.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been quite a ride. In it, we investigated common practice methods
    for embedding plug-ins into web applications. Specifically, we examined three
    examples — MDB2 (subpackages), Serendipity (Spartacus), Seagull (partially embedded
    PEAR installer). For each of these examples, we weighed the pros and cons of their
    respective approaches.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Having determined that there may be a better way to do things, we learned how
    to embed the PEAR installer most effectively, in order to create a plug-in manager.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we created a fake blog program in just under 1000 lines of
    code that provides the ability to seamlessly query a remote PEAR Channel server
    designed to distribute templates. Using the internal classes of the PEAR installer,
    our MyBlog web application can intelligently install and upgrade templates with
    all of the sophistication expected from the PEAR installer.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: We took full advantage of the PEAR installer's built-in REST client to query
    the remote server, the PEAR installer's download capabilities, and its robust
    file installer complete with file transactions. In addition, we learned how to
    extend the remote server's REST code to include a thumbnail image, and instructed
    our MyBlog's administration page to display these thumbnail images.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I would like to thank you for reading this guide to the exciting and
    innovative PEAR installer, and I hope it will serve you well in your quest for
    the perfect website and developing environment!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
