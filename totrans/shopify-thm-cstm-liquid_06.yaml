- en: '[*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079): Diving into
    Liquid Core with Objects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第四章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)：使用对象深入Liquid核心'
- en: In the previous three chapters, we have been referencing objects. However, in
    this chapter, we will learn about objects, their attributes, and some of the best
    ways to use them. By learning about objects, we will finalize some projects that
    we have started and work on new projects to develop our knowledge further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们已经提到了对象。然而，在本章中，我们将学习关于对象、它们的属性以及一些最佳使用方法。通过学习对象，我们将完成一些已经开始的项目，并着手新的项目以进一步发展我们的知识。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with global objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局对象
- en: Improving the workflow with metafields
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元字段改进工作流程
- en: Content and special objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容和特殊对象
- en: Upon completing this chapter, we will understand what content objects are, why
    they are mandatory, and how to use them, which is the first step in creating future
    templates. We will have also learned more about the global objects that we have
    been referencing up until now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将了解内容对象是什么，为什么它们是必需的，以及如何使用它们，这是创建未来模板的第一步。我们还将了解更多关于我们迄今为止一直在引用的全局对象。
- en: However, due to the significant number of global objects and attributes they
    offer us, we will not cover all of them. Instead, we will only explain some of
    the essential global objects and attributes, which will set us on the right path
    to understanding objects entirely. By learning about objects, we will also learn
    to understand metafields, which allow us to store and dynamically output additional
    data on our store. Lastly, we will learn about the special objects that will help
    us output some helpful functionalities on our store.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于它们提供了大量的全局对象和属性，我们不会涵盖所有这些。相反，我们只会解释一些基本的全局对象和属性，这将帮助我们正确理解对象。通过学习对象，我们还将学习理解元字段，这允许我们在我们的商店中存储和动态输出额外的数据。最后，我们将学习关于将帮助我们在我们的商店上输出一些有用功能的特殊对象。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While we will explain each topic and have it presented with the accompanying
    graphics, we will need an internet connection to follow the steps outlined in
    this chapter, considering that Shopify is a hosted service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将解释每个主题，并用相应的图形展示，但考虑到Shopify是一个托管服务，我们需要网络连接来跟随本章中概述的步骤。
- en: The code for this chapter is available on GitHub at https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到，网址为https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04。
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3u7hqyB](https://bit.ly/3u7hqyB)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可在此处找到：[https://bit.ly/3u7hqyB](https://bit.ly/3u7hqyB)
- en: Working with global objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局对象
- en: We referenced objects and their attributes in the previous chapter. *But what
    exactly are objects?*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了对象及其属性。*但对象究竟是什么呢？*
- en: These objects, or so-called `{{ collection.title }}`, where the `collection`
    keyword would be our object and `title` would be the attribute.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象，或所谓的 `{{ collection.title }}`，其中 `collection` 关键字将作为我们的对象，而 `title` 将是属性。
- en: We can reference these global objects inside any file by directly visiting the
    page whose content we are looking to recover and calling the object, or manually
    invoking the object for the specific page using its handle and combining it with
    the variable tags. Let's see this in action.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接访问我们想要恢复内容的页面，并调用对象，或者通过其handle手动调用特定页面的对象，并将其与变量标签结合，来在任意文件中引用这些全局对象。让我们看看实际操作。
- en: 'As you may recall from the previous chapter, while we were working on the project
    on our indoor collection page, we initially used `collection.title` to recover
    the collection''s name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一章中回忆的那样，当我们正在我们的室内集合页面上进行项目工作时，我们最初使用 `collection.title` 来恢复集合的名称：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When used inside the collection page, the preceding code will provide us with
    the data we are looking for. However, *what if we wanted to access the* `indoor`
    *collection object while visiting the outdoor collection page?*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当在集合页面内部使用时，前面的代码将为我们提供我们所需的数据。然而，*如果我们想在访问户外集合页面时访问* `indoor` *集合对象，该怎么办呢？*
- en: This is where our knowledge of accessing the page object using the page handle,
    which we covered in [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030),
    *The Basic Flow of Liquid*, in the *EmptyDrop* subsection of the *Understanding
    the types of data* section comes to help.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用页面句柄访问页面对象的知识所在，我们在[*第二章*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030)“理解数据类型”部分的*EmptyDrop*子节中介绍了这个知识，它对我们有所帮助。
- en: 'We can access the object using its handle by pluralizing the object''s name
    we are trying to access, followed by either a squared bracket (`[]`) or dot (`.`)
    notation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们要访问的对象的名称复数化，然后使用方括号`[]`或点`.`表示法来通过句柄访问对象：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By defining a variable with the object of the indoor collection, we can output
    the data for that collection on any page by simply invoking the object, followed
    by the attribute that we need:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个包含室内收藏对象的变量，我们可以通过简单地调用对象，然后是所需的属性，在任何页面上输出该收藏的数据：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While our object name differs from the original object name, it will allow us
    to output the same information compared to when we used `{{ collection.title }}`
    inside the collection template.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的对象名称与原始对象名称不同，但它将允许我们输出与我们在收藏模板中使用`{{ collection.title }}`时相同的信息。
- en: 'Important note:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: In the previous example, we created a variable using the `customCollection`
    name. However, note that you can create this variable using any name of your choice,
    including the collection itself. While the `collection` keyword is not reserved,
    we should pay close attention when using the keywords already in use as this can
    cause unexpected results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用`customCollection`名称创建了一个变量。然而，请注意，您可以使用任何您选择的名称来创建这个变量，包括收藏本身。虽然`collection`关键字不是保留的，但我们应该在使用已经使用的关键字时格外小心，因为这可能会导致意外结果。
- en: Considering that global objects is an extensive topic, it would not be very
    productive to explain each object and their attributes separately. Instead, we
    will be creating a few projects to see firsthand how to work with different kinds
    of objects and the data types they return.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到全局对象是一个广泛的话题，单独解释每个对象及其属性并不会很有成效。相反，我们将创建几个项目，以便亲自了解如何处理不同类型的对象及其返回的数据类型。
- en: As we have already mentioned, an object, in combination with attributes, allows
    us to read the information from our admin and dynamically output it to create
    various functionalities. Let's start by familiarizing ourselves with the collection
    and product objects, which we will use to finalize the `Custom collection` project
    that we started in the previous chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，一个对象，结合属性，允许我们从管理员那里读取信息，并动态输出以创建各种功能。让我们首先熟悉一下收藏和产品对象，我们将使用这些对象来完成上一章中开始创建的`Custom
    collection`项目。
- en: Custom collection
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义收藏
- en: 'In the previous chapter, we created a `for` loop that outputs the names of
    the products from the outdoor collection, whose price is lower than $100.00\.
    We did this by creating a `collection-form` snippet whose content we are outputting
    using the `for` parameter, combined with the `render` tag. We placed this at the
    bottom of our `collection.liquid` template file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个`for`循环，输出了户外收藏中价格低于$100.00的产品名称。我们通过创建一个`collection-form`片段来实现这一点，我们使用`for`参数输出其内容，并结合`render`标签。我们将这个片段放置在我们的`collection.liquid`模板文件的底部：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside our snippet, we added an `if` statement to check if the product price
    is higher than `10000`. If it is, we should output the product `form` tag and
    the product title:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的片段内部，我们添加了一个`if`语句来检查产品价格是否高于`10000`。如果是，我们应该输出产品`form`标签和产品标题：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we were to preview our code by vising the indoor collection page, we would
    only see a list of names, so let's try to improve this snippet by writing some
    code that will output the entire product block instead of only the product's name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过访问室内收藏页面来预览我们的代码，我们只会看到一系列的名称，所以让我们尝试通过编写一些代码来改进这个片段，使其输出整个产品块而不是仅输出产品的名称。
- en: 'Let''s start by refactoring the code inside the snippet by removing the `continue`
    and `capture` tags, refining our statement by removing the `else` statement, wrapping
    `{{ product.title }}`, positioning it above the product form, and finally removing
    the extra parameters from our product `form` tag:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重构片段内部的代码开始，通过删除`continue`和`capture`标签，通过删除`else`语句来精炼我们的语句，将`{{ product.title
    }}`包裹起来，将其放置在产品表单上方，并最终从我们的产品`form`标签中删除额外的参数：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The newly refactored code will do the same thing as it did previously, but now,
    it will be easier to understand and maintain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新重构的代码将执行与之前相同的功能，但现在，它将更容易理解和维护。
- en: Let's proceed by creating our product block. Currently, we only have a product
    name, so let's include the hyperlink that will redirect us to the actual product
    name when we click on the product's name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的产品块。目前，我们只有一个产品名称，所以让我们包括一个超链接，当我们点击产品名称时，它将重定向我们到实际的产品名称。
- en: 'We can do this by wrapping `{{ product.title }}` inside of the hyperlink tag,
    with its `href` attribute set to `{{ product.url }}`. This will return the relative
    path:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`{{ product.title }}`包裹在超链接标签内，并设置其`href`属性为`{{ product.url }}`来实现这一点。这将返回相对路径：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The addition of the hyperlink has ensured that we will be redirected to the
    actual product page by clicking the product's name. The next thing we need to
    do is include the image for each of our products.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加超链接确保了我们通过点击产品名称将被重定向到实际的产品页面。接下来，我们需要做的是包括我们每个产品的图片。
- en: 'We can do this by creating an image HTML tag inside the hyperlink tag, just
    above the product title, and setting its `src` attribute to `{{ product | img_url
    }}`. This will return a string to the location of the product image on Shopify''s
    **Content Delivery Network** (**CDN**):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在超链接标签内创建一个图像HTML标签，位于产品标题上方，并将它的`src`属性设置为`{{ product | img_url }}`来实现这一点。这将返回一个字符串，指向Shopify的**内容分发网络**（**CDN**）上的产品图片位置：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our product block is starting to look a lot better, but we still need to show
    the price of our products. We can include the product price by wrapping `{{ product.price
    | money }}` inside the `p` HTML tags:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品块开始看起来好多了，但我们仍然需要显示产品的价格。我们可以通过将`{{ product.price | money }}`包裹在`p`HTML标签内来包括产品价格：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Tip:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: Notice that we have a small addition separated by a pipe character for both
    the `image` and `price` objects. This addition is called a **filter**, which helps
    us modify the output that we would otherwise receive from the object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`image`和`price`对象之间通过管道字符添加了一个小的修改。这个修改被称为**过滤器**，它帮助我们修改我们本应从对象接收到的输出。
- en: For example, if we were to call the `product` object with the `price` attribute,
    we would receive a number value without any format, such as `2599`. However, by
    applying the `money` filter to the object, we have automatically changed the otherwise
    meaningless number into a string data type and formatted it according to our store-selected
    currency formatting, resulting in a $25.99 string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们调用具有`price`属性的`product`对象，我们会收到一个没有格式的数字值，例如`2599`。然而，通过将`money`过滤器应用于对象，我们自动将原本无意义的数字转换为字符串数据类型，并按照我们选择的货币格式进行格式化，结果是一个`$25.99`字符串。
- en: We will not go into too much detail regarding filters right now, as we will
    be learning about them in the next chapter. For now, this basic information about
    filters will have to suffice. Let's return to our example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会过多地详细介绍过滤器，因为我们将在下一章学习它们。目前，关于过滤器的基本信息将足够。让我们回到我们的例子。
- en: 'So far, we have included the product name, image, and price, which check most
    of the necessary boxes that are needed to present a product. However, notice that
    the product `form` is currently empty. Let''s change this by introducing an `input`
    element so that it''s of the `submit` type, which should allow us to purchase
    the product directly from the collection page:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经包括了产品名称、图片和价格，这些检查了展示产品所需的大部分必要框。然而，请注意，产品的`form`目前是空的。让我们通过引入一个`input`元素来改变这一点，使其为`submit`类型，这样我们就可以直接从收藏页面购买产品：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the addition of the **Add to Cart** button, we have created a button that
    should allow us to purchase the products directly from our collection page, without
    having to navigate to the product page. However, if we were to click it right
    now, we would encounter an error stating **Parameter Missing or Invalid: Required
    parameter missing or invalid: items**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加**添加到购物车**按钮，我们创建了一个按钮，它应该允许我们直接从收藏页面购买产品，而无需导航到产品页面。然而，如果我们现在点击它，我们会遇到一个错误，指出**参数缺失或无效：缺少或无效的必需参数：items**：
- en: '![Figure 4.1 – Result of submitting a product form with missing parameters'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 缺少参数提交产品表单的结果'
- en: '](img/Figure_4.01_B17606.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.01_B17606.jpg)'
- en: Figure 4.1 – Result of submitting a product form with missing parameters
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 缺少参数提交产品表单的结果
- en: The parameter that we are missing is the `id` property of the variant that we
    are looking to purchase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少的参数是我们想要购买的变体的 `id` 属性。
- en: Every product on Shopify can have up to three different sets of options. For
    example, a product can have multiple sizes, colors, and materials. Each combination
    of these three choices generates a unique number called a variant `id`, which
    tells our product `form` which combination of options it should place in the cart.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify 上的每个产品最多可以有三种不同的选项集。例如，一个产品可以有多个尺寸、颜色和材料。这三个选择的每一种组合都会生成一个唯一的数字，称为变体
    `id`，它告诉我们产品 `form` 应该将哪种选项组合放入购物车中。
- en: 'Note that these options are entirely optional as we can have a product without
    any variant options. However, even then, we still need to include the variant
    `id`. We should include this variant `id` as a `value` attribute of the `hidden`
    HTML input element with `id` as its `name` attribute:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些选项完全是可选的，因为我们甚至可以有一个没有任何变体选项的产品。然而，即使在这种情况下，我们仍然需要包含变体 `id`。我们应该将这个变体 `id`
    作为 `hidden` HTML 输入元素的 `value` 属性，其 `id` 作为其 `name` 属性：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the addition of the variant `id`, we now have a fully functional product
    `form`. By clicking the `id` and added to our cart.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加变体 `id`，我们现在拥有了一个完全功能的产品 `form`。通过点击 `id` 并将其添加到我们的购物车中。
- en: Notice that we will also be automatically redirected to the cart page after
    clicking the **Add to Cart** button. This is the default behavior that we can
    rectify in one of two ways.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点击 **添加到购物车** 按钮后，我们也会自动重定向到购物车页面。这是我们可以在两种方式中纠正的默认行为。
- en: The first way would require us to add the `return_to` parameter to our product
    `form` tag, which will allow us to set the page we should return to after submitting
    the form. We can remind ourselves of how to use the `return_to` parameter by returning
    to the previous chapter and revisiting *The form tag* subsection, located under
    the *Theme tags* section. The other way would be to use the **Shopify Ajax API**,
    which we will learn about later in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法需要我们在产品 `form` 标签中添加 `return_to` 参数，这将允许我们设置在提交表单后应返回的页面。我们可以通过回到前面的章节并重新访问位于
    *Theme tags* 部分的 *The form tag* 子部分来提醒自己如何使用 `return_to` 参数。另一种方法是使用 **Shopify
    Ajax API**，我们将在本书的后面部分学习。
- en: Let's return to the indoor collection for now. Let's look at the entire collection
    page and compare the initial collection products with our custom collection at
    the bottom. You will notice that besides being styled in a much better way than
    our collection, the initial collection products also contain a red sale badge,
    along with a regular and discounted price.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回到室内集合。让我们查看整个集合页面，并将初始集合产品与底部的自定义集合进行比较。你会注意到，除了比我们的集合样式好得多之外，初始集合产品还包含一个红色销售徽章，以及常规和折扣价格。
- en: Each product in the admin contains two different fields for price, located under
    the `product` object with the `compare_at_price` attribute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理员中，每个产品都包含两个不同的价格字段，位于具有 `compare_at_price` 属性的 `product` 对象下。
- en: 'Let''s return to our code on the collection page and modify it so that it includes
    both the sale badge and the compare price to match the initial collection. We
    can show the comparison price by wrapping `{{ product.compare_at_price | money
    }}` inside the `span` element and positioning it right after `{{ product.price
    | money }}`. Additionally, we can implement the sale badge by creating a simple
    string message inside the `span` tag and placing it under the `price` element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到集合页面的代码，并对其进行修改，使其包括销售徽章和比较价格，以匹配初始集合。我们可以通过将 `{{ product.compare_at_price
    | money }}` 包裹在 `span` 元素中，并将其放置在 `{{ product.price | money }}` 之后来显示比较价格。此外，我们可以通过在
    `span` 标签内创建一个简单的字符串消息并将其放置在 `price` 元素下方来实现销售徽章：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have included all the necessary elements for the `Custom collection` items.
    However, quite a few products do not have their comparison price and sale badges
    visible, which results from the `if` statement on our first line so that it shows
    products with a defined comparison price:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为 `Custom collection` 项包含了所有必要的元素。然而，相当多的产品没有显示其比较价格和销售徽章，这是由于我们第一行上的 `if`
    语句导致的，以便显示具有定义的比较价格的产品：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By modifying the `if` statement, we have ensured that we only display products
    on sale, consequently creating a custom on-sale addition for our initial collection.
    The only thing left to do is update the HTML formatting and add some CSS styling.
    While formatting and styling are entirely optional, we advise you to use the same
    formatting as it will be easier to follow up with future changes. The HTML formatted
    code, along with some basic CSS styling, can be found at the following GitHub
    link within the `Learning Projects` directory, under the name `Custom collection`:
    https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20collection.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改`if`语句，我们确保只显示正在销售的产品，从而为我们的初始集合创建一个自定义的促销添加。剩下要做的就是更新HTML格式和添加一些CSS样式。虽然格式化和样式完全是可选的，但我们建议您使用相同的格式，这样在未来的更改中会更容易跟进。HTML格式化代码和一些基本的CSS样式可以在以下GitHub链接中找到，位于`Learning
    Projects`目录下，名称为`Custom collection`：https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20collection。
- en: This GitHub repository contains three files, each named according to the location
    where the code should be included.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GitHub仓库包含三个文件，每个文件都根据代码应包含的位置命名。
- en: 'If we preview our collection indoor collection now, we will see a significant
    improvement compared to when we started:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在预览我们的室内集合，我们将看到与开始时相比有显著的改进：
- en: '![Figure 4.2 – Example of a complete custom collection project'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 完整自定义集合项目的示例'
- en: '](img/Figure_4.02_B17606.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 完整自定义集合项目的示例](img/Figure_4.02_B17606.jpg)'
- en: Figure 4.2 – Example of a complete custom collection project
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 完整自定义集合项目的示例
- en: So far, we have only mentioned objects whose attributes return a single value,
    such as `product.price`, `product.title`, or `product.first_available_variant.id`.
    However, they can also return an array or even act as helper tools for our programming
    logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只提到了返回单个值的属性的对象，例如`product.price`、`product.title`或`product.first_available_variant.id`。然而，它们也可以返回数组，甚至可以作为我们编程逻辑的辅助工具。
- en: One of the most used objects that returns an array is the `linklist` object.
    Combined with the `link` object, it will help us read the data from the menu within
    the navigation admin and help us create a custom navigation menu.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的对象中最常用的是`linklist`对象。结合`link`对象，它将帮助我们读取导航管理员中的菜单数据，并帮助我们创建自定义导航菜单。
- en: Custom navigation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义导航
- en: 'For our next project, we will create a multi-level navigation menu specifically
    for our collection page. However, before we can learn about the `linklist` and
    `link` objects, we need to create a navigation menu. Let''s get started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将创建一个专门针对我们的集合页面的多级导航菜单。然而，在我们了解`linklist`和`link`对象之前，我们需要创建一个导航菜单。让我们开始吧：
- en: We can create a new navigation menu by navigating to admin, clicking on **Online
    store** to expand it, and clicking on the **Navigation** link, where we can create
    the new menu by clicking the **Add menu** button:![Figure 4.3 – Example of accessing
    the Navigation menu
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过导航到管理员，点击**在线商店**以展开它，然后点击**导航**链接来创建一个新的导航菜单，我们可以通过点击**添加菜单**按钮来创建新菜单：![图4.3
    – 访问导航菜单的示例
- en: '](img/Figure_4.03_B17606.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.3 – 访问导航菜单的示例](img/Figure_4.03_B17606.jpg)'
- en: Figure 4.3 – Example of accessing the Navigation menu
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.3 – 访问导航菜单的示例
- en: After clicking the **Add menu** button, set the menu's title to **Indoor Navigation**.
    The page's handle will be automatically populated once we set the menu's name,
    so there is no need to modify it manually.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加菜单**按钮后，将菜单的标题设置为**室内导航**。一旦我们设置了菜单的名称，页面的句柄将自动填充，因此无需手动修改。
- en: We are now ready to populate the menu. Click on the **Add menu item** button
    and click on the **Link** field, which will automatically display a dropdown menu.
    For the first menu item, click on **Collections**, then **All collections**, which
    should immediately populate the menu item's name and link fields. Click on the
    **Add** button to finish adding the menu item.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已准备好填充菜单。点击**添加菜单项**按钮，然后点击**链接**字段，这将自动显示一个下拉菜单。对于第一个菜单项，点击**集合**，然后点击**所有集合**，这将立即填充菜单项的名称和链接字段。点击**添加**按钮完成添加菜单项。
- en: Repeat the previous step six more times by creating two menu items named and
    linked to the two collections **Indoor** and **Outdoor**, and then four menu items
    to any four products in our store.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建两个名为并链接到两个集合**室内**和**室外**的菜单项，然后为我们的商店中的任意四个产品创建四个菜单项，重复执行前一个步骤六次。
- en: Once we have created the additional menu items, move the **Indoor** and **Outdoor**
    menu items under the **All collections** menu item to create a nesting menu. We
    can do this by clicking on the six dots before the menu item's name, and then
    holding and moving them over the **All collections** menu item until the indented
    blue line shows, at which point we should release the click:![Figure 4.4 – Example
    of creating a dropdown menu inside the Navigation menu
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了额外的菜单项，将**室内**和**室外**菜单项移动到**所有集合**菜单项下以创建嵌套菜单。我们可以通过点击菜单项名称前的六个点来完成此操作，然后按住并移动它们到**所有集合**菜单项上，直到缩进的蓝色线条出现，此时我们应该释放点击：![图
    4.4 – 在导航菜单内创建下拉菜单的示例
- en: '](img/Figure_4.04_B17606.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.04_B17606.jpg)'
- en: Figure 4.4 – Example of creating a dropdown menu inside the Navigation menu
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4 – 在导航菜单内创建下拉菜单的示例
- en: Repeat the previous step and move the two product menu items under the **Indoor**
    collection menu item, which we have already moved under the **All collections**
    menu item. Repeat the same process for the **Outdoor** collection menu item and
    the two product menu items that are remaining.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，将两个产品菜单项移动到已经移动到**所有集合**菜单项下的**室内**集合菜单项下。对**室外**集合菜单项和剩余的两个产品菜单项重复相同的操作。
- en: If we have done everything right, we should end up with an **Indoor Navigation**
    menu containing a single menu item containing **All collections**, which contains
    two collection menu items containing two product menu items each. Suppose the
    menu format does not look the same after following the preceding steps. In that
    case, we can consult the Shopify documentation on nesting the menu items, where
    we can find more detailed instructions and a YouTube link on this topic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一切操作正确，最终应该得到一个包含单个菜单项的**室内导航**菜单，该菜单项包含**所有集合**，其中包含两个集合菜单项，每个集合菜单项包含两个产品菜单项。假设按照前面的步骤操作后，菜单格式看起来并不相同。在这种情况下，我们可以查阅Shopify关于嵌套菜单项的文档，在那里我们可以找到更详细的说明和关于此主题的YouTube链接。
- en: For additional information on creating nesting navigation, please refer to https://help.shopify.com/en/manual/online-store/menus-and-links/drop-down-menus.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建嵌套导航的更多信息，请参阅https://help.shopify.com/en/manual/online-store/menus-and-links/drop-down-menus。
- en: 'Important note:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The maximum amount of nesting menu items we can have inside a single menu is
    up to three levels long. We can consider the menu that we previously created as
    a three-level navigation menu, which is the limit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个菜单内我们可以有的最大嵌套菜单项数是三个层级长。我们可以将我们之前创建的菜单视为一个三级导航菜单，这是极限。
- en: 'Now that we have successfully created the navigation menu, we can start creating
    a variable that we will assign the value of the `linklist` object to, followed
    by the handle of the navigation we are trying to access. Remember that when accessing
    the object using the handle, we need to pluralize the object by adding the letter
    `s` at the end of the object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了导航菜单，我们可以开始创建一个变量，我们将把`linklist`对象的值分配给这个变量，然后是我们要访问的导航的句柄。记住，当我们使用句柄访问对象时，我们需要通过在对象末尾添加字母`s`来使对象复数化：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With that, we have successfully saved the object of our indoor navigation to
    the `collection-menu` variable. Let''s test it inside our `collection.template`.
    To do so, we will call the `collection-menu` object, followed by the `title` and
    `levels` attributes, just above `{% section ''collection-template'' %}` so that
    we can see the name of our navigation and the number of nesting menus it has:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功将室内导航的对象保存到了`collection-menu`变量中。现在让我们在`collection.template`内部测试它。为此，我们将调用`collection-menu`对象，然后是`title`和`levels`属性，就在`{%
    section 'collection-template' %}`上方，这样我们就可以看到我们的导航名称以及它包含的嵌套菜单数量：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we preview our indoor collection, we will be able to see the name of our
    navigation and the number of nested levels the navigation menu has:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预览我们的室内集合，我们将能够看到我们的导航名称以及导航菜单的嵌套层级数：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have confirmed that we have recovered the correct menu object,
    we can remove the `collection-menu.title` and `collection-menu.levels` lines.
    For the next step, we will need to use the `for` tag to loop over the array of
    links inside the object, which we can recover by calling the `collection-menu`
    object, followed by the `links` attribute:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认我们已经恢复了正确的菜单对象，我们可以删除`collection-menu.title`和`collection-menu.levels`行。对于下一步，我们需要使用`for`标签遍历对象内部的链接数组，我们可以通过调用`collection-menu`对象，然后是`links`属性来恢复它：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we preview our **Indoor** collection now, we will notice that the only menu
    item that's visible on our page is the first level item, **All Collections**.
    Suppose we would like to loop over the additional nested menus located inside
    the **All Collections** menu item. In that case, we will need to create a second
    loop inside the first loop to recover the data from the second level.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在预览**室内**集合，我们会注意到页面上唯一可见的菜单项是第一级项，**所有集合**。假设我们想要遍历位于**所有集合**菜单项内部的额外嵌套菜单。在这种情况下，我们将在第一个循环内部创建第二个循环来恢复第二级的数据。
- en: 'The key difference is that we will not use `collection-menu` as our object.
    Instead, we will use the `link` object from our first `for` loop, combined with
    the `links` attribute, which will give us access to the array of links inside
    the `link` object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于，我们不会使用`collection-menu`作为我们的对象。相反，我们将使用第一个`for`循环中的`link`对象，结合`links`属性，这将使我们能够访问`link`对象内部的链接数组：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By looping over the `link` object, we were able to recover the array links
    nested inside the **All Collections** menu item. Using the same technique, we
    can loop over the array of links inside the final level of the **Indoor** navigation
    menu:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历`link`对象，我们能够恢复嵌套在**所有集合**菜单项中的数组链接。使用同样的技术，我们可以遍历**室内**导航菜单最后一层的链接数组：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have all the necessary elements to create a working on-hover navigation
    menu. The only thing left is to add some `HTML` tags and apply the necessary styling
    to create the on-hover dropdown effect. However, before we proceed with styling,
    let's try to be a bit more creative.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建工作悬浮导航菜单所需的所有必要元素。唯一剩下的事情就是添加一些`HTML`标签并应用必要的样式来创建悬浮下拉效果。然而，在我们进行样式设计之前，让我们尝试变得更有创意。
- en: 'Notice that our menu links are just that – links. *But what if we wanted to
    be more creative by showing an image with every product menu item?* For this to
    work, we would need to identify which menu items are pointing toward the products,
    which we can do by using the `type` attribute and comparing whether the returned
    value is equal to the `product_link` string. Since we already know that only the
    third level of the navigation contains the product menu items, we will only include
    this feature inside the third `for` loop:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的菜单链接仅仅是链接。*但如果我们想通过在每个产品菜单项中显示图片来更有创意呢？*为了实现这一点，我们需要确定哪些菜单项指向产品，这可以通过使用`type`属性并比较返回值是否等于`product_link`字符串来完成。由于我们已经知道导航的第三级只包含产品菜单项，因此我们只将此功能包含在第三个`for`循环中：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, it makes sense that this should work and that, as a result, we should be
    able to see four images of our products inside the navigation menu. However, note
    that `sub_sub_link` is still only a `link` object, and the `link` object does
    not have an image attached to it. To show the image that's attached to the product,
    we will have to recover the object of the product that our link is pointing to.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法应该能够工作，并且我们应该能够在导航菜单中看到我们产品的四张图片。然而，请注意，`sub_sub_link`仍然只是一个`link`对象，而`link`对象并没有附加图片。为了显示附加到产品上的图片，我们必须恢复链接指向的产品对象。
- en: 'We can easily do this by modifying the `sub_sub_link` object inside the `IMG`
    tag so that it includes the `object` attribute:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`IMG`标签内的`sub_sub_link`对象来实现这一点，使其包含`object`属性：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**With the addition of the `object` attribute, we now have access to the entire
    product object, including its title, price, images, and all other data. In comparison,
    `sub_sub_link.object.price` would return precisely the same results as writing
    `product.price` would, which we used in the previous project to display the prices
    of our `Custom collection` products.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**随着`object`属性的添加，我们现在可以访问整个产品对象，包括其标题、价格、图片以及所有其他数据。相比之下，`sub_sub_link.object.price`将返回与直接编写`product.price`相同的结果，这是我们之前在项目中用来显示`自定义集合`产品价格的方法。**'
- en: 'The only thing left to do now is provide our code with some HTML format and
    apply the necessary styling. The HTML formatted code, along with some basic CSS
    styling, can be found at the following GitHub link, under the name `Custom navigation`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情就是为我们的代码提供一些HTML格式并应用必要的样式。HTML格式的代码以及一些基本的CSS样式可以在以下GitHub链接中找到，名称为`Custom
    navigation`：
- en: https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20Navigation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20Navigation.
- en: This GitHub repository contains two files, each named according to the location
    where the code should be included.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GitHub仓库包含两个文件，每个文件都按照代码应包含的位置命名。
- en: While working on this project, we were able to create a fundamental version
    of the mega menu, allowing us to output any image attached to our pages easily.
    While it might not look impressive, the knowledge we have learned from this project
    has taught us how to create any navigation menu, as well as a custom subcollections
    page where we can output other collections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个项目时，我们能够创建一个基础版本的巨量菜单，使我们能够轻松输出我们页面上的任何图像。虽然它可能看起来并不令人印象深刻，但我们从这个项目中学到的知识教会了我们如何创建任何导航菜单，以及一个自定义子集合页面，我们可以输出其他集合。
- en: So far, all our projects have been related to recovering the predefined data
    from our admin. *However, what if we needed to capture data regarding the customization
    of a particular product, show the choice on the cart page, and then forward the
    captured data with the order?*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的项目都与从我们的管理后台恢复预定义数据有关。*然而，如果我们需要捕获有关特定产品定制的相关数据，显示在购物车页面上，然后随订单转发捕获的数据呢？*
- en: Product customization
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品定制
- en: For our next project, we will be creating a custom HTML input on the product
    page, which will allow us to capture any data that the customer may input and
    learn how to forward the value of the input, along with the order itself.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个项目中，我们将在产品页面上创建一个自定义HTML输入，这将允许我们捕获客户可能输入的任何数据，并学习如何转发输入的值，包括订单本身。
- en: To achieve this functionality, we will be using the `line_item` object. `line_item`
    represents each item within our cart. We can access the `line_item` object through
    the `cart` object, followed by the `items` attribute, which will provide us with
    access to the `line_item` object for each product.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们将使用`line_item`对象。`line_item`代表我们购物车中的每个项目。我们可以通过`cart`对象访问`line_item`对象，然后是`items`属性，这将为我们提供访问每个产品的`line_item`对象的权限。
- en: Before we can use `line_item object` to output the data on our cart page, we
    will need to create a field to capture this data. Let's start by navigating to
    our `product.liquid` template and find the opening tag of the `product` form.
    As we can see, the `product` form tag is not present in this file, but we do have
    a `section` tag, which, as you may recall from the previous chapter, allows us
    to render a static section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用`line_item object`在购物车页面上输出数据之前，我们需要创建一个字段来捕获这些数据。让我们首先导航到我们的`product.liquid`模板，并找到`product`表单的起始标签。正如我们所见，`product`表单标签不在这个文件中，但我们确实有一个`section`标签，正如你可能从上一章回忆起来的，它允许我们渲染一个静态部分。
- en: 'Let''s proceed by navigating to the `product-template.liquid` section file.
    We can access it by hovering over the section tag''s name and clicking on the
    small arrow. Alternatively, we can find it inside the `Sections` directory. After
    finding the `product` form tag, we can start creating the customization feature
    by adding an HTML input tag of the `text` type, which we will be using to capture
    information related to each specific product. We can add this field at the top
    of the `product` form tag, just above the first `unless` statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过导航到`product-template.liquid`部分文件来继续操作。我们可以通过悬停在部分标签的名称上并点击小箭头来访问它。或者，我们可以在`Sections`目录中找到它。在找到`product`表单标签后，我们可以通过添加一个`text`类型的HTML输入标签来开始创建定制功能，我们将使用它来捕获与每个特定产品相关的信息。我们可以在`product`表单标签的顶部添加此字段，就在第一个`unless`语句之上：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we try to preview our product page, we will see an input field with **Your
    Name** as the placeholder:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试预览我们的产品页面，我们会看到一个带有**您的姓名**作为占位符的输入字段：
- en: '![Figure 4.5 – Example of a custom field on the product page'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 产品页面上自定义字段的示例]'
- en: '](img/Figure_4.05_B17606.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.05_B17606.jpg]'
- en: Figure 4.5 – Example of a custom field on the product page
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 产品页面上自定义字段的示例
- en: 'However, if we fill in the input, add the product to the cart, and visit our
    cart page by clicking the cart icon in the top-right corner, we will notice that
    we did not capture the data successfully with the product. To save the `line_item`
    data value, we will need to modify the HTML input by adding the `name` property
    in `name="properties[Your Name]"` format:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们填写输入，将产品添加到购物车，并通过点击右上角的购物车图标访问我们的购物车页面，我们会注意到我们没有成功捕获与产品相关的数据。为了保存`line_item`数据值，我们需要通过添加`name`属性以`name="properties[Your
    Name]"`格式修改HTML输入：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `name` property is a predefined attribute that allows us to capture the
    `input` element's value, followed by a mandatory keyword, called `properties`,
    and a pair of square brackets. Any value inside these square brackets – in our
    case, **Your Name** – will serve as that property name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性是一个预定义的属性，它允许我们捕获`input`元素的值，后面跟着一个强制性的关键字，称为`properties`，以及一对方括号。方括号内的任何值（在我们的情况下，**您的姓名**）将作为该属性名称。'
- en: With the `name` attribute in place, if we fill in the input field, click on
    the `line_item` attribute's name and value were successfully captured and chained
    to each product.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了`name`属性后，如果我们填写输入字段，点击`line_item`属性名称，名称和值就成功捕获并链接到每个产品。
- en: When dealing with newer themes, such as the one we are using, this would be
    the last step in capturing customization for each product. However, for some older
    themes, which are still quite present today, we would need to write some code
    that will display the `line_item` properties inside the cart page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理较新的主题，例如我们正在使用的主题时，这将是在每个产品中捕获自定义的最后一步。然而，对于一些仍然相当普遍的旧主题，我们可能需要编写一些代码来在购物页面上显示`line_item`属性。
- en: 'Before writing this code, we will need to identify where we should add our
    code. As we mentioned previously, to access the `line_item` object, we will need
    to use `cart.items` to recover an array of products in our cart, which should
    already be present in our `cart.liquid` section file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此代码之前，我们需要确定我们应该在哪里添加我们的代码。正如我们之前提到的，为了访问`line_item`对象，我们需要使用`cart.items`来恢复购物车中的产品数组，这些产品应该已经存在于我们的`cart.liquid`部分文件中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the `cart.items` loop, we have gained access to the objects of each product,
    which, similar to the `product` object, provides us with access to various attributes,
    such as the `product` object's title, price, and the quantity that we have added
    to the cart, as well as its properties.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`cart.items`循环，我们获得了每个产品的对象，这与`product`对象类似，为我们提供了访问各种属性的能力，例如`product`对象的标题、价格以及我们添加到购物车中的数量，以及其属性。
- en: 'We can access the properties of each product by using `item` as our object,
    followed by the `properties` attribute. However, since we can capture multiple
    properties for each product, `item.properties` will return an array of data, meaning
    that we will need to use the `for` tag:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`item`作为我们的对象，然后是`properties`属性来访问每个产品的属性。然而，由于我们可以为每个产品捕获多个属性，`item.properties`将返回一个数据数组，这意味着我们需要使用`for`标签：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that `{{ property }}` is considered an array data type since it contains
    both the name of the `line_item` property and its value. If we were to use this
    code to output the `line_item` code on our page, we would end up with both values
    stuck together. Since using another `for` tag to go over the array that contains
    two elements would be excessive, we can use the `first` and `last` filters to
    output the split values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`{{ property }}`被认为是一个数组数据类型，因为它包含`line_item`属性名称及其值。如果我们使用此代码在页面上输出`line_item`代码，我们最终会得到两个值粘在一起。由于使用另一个`for`标签遍历包含两个元素的数组会过于冗余，我们可以使用`first`和`last`过滤器来输出分割的值：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `first` and `last` filters, as their names suggest, allow us to access the
    first and last element inside an array. However, since we are looking to split
    our array into two separate elements, it is perfect as it helps us avoid writing
    another `for` loop. We will learn more about this and other filters in the next
    chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`和`last`过滤器，正如其名称所暗示的，允许我们访问数组中的第一个和最后一个元素。然而，由于我们希望将我们的数组拆分为两个单独的元素，这非常完美，因为它帮助我们避免了编写另一个`for`循环。我们将在下一章中了解更多关于此和其他过滤器的内容。'
- en: 'Important note:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Adding the same product variant multiple times to the cart with a different
    `line_item` property value will not override the product we previously added to
    the cart, nor affect its `line_item` property value. Instead, we will end up with
    each product positioned on a new line, as if it were a different product.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的产品变体多次添加到购物车中，并且具有不同的`line_item`属性值，不会覆盖我们之前添加到购物车中的产品，也不会影响其`line_item`属性值。相反，每个产品将位于新的一行上，就像它是不同的产品一样。
- en: 'The only time when we can include multiple variants of the same product on
    the same line is if the product variant contains the same data, the `line_item`
    property included. Here is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一次我们可以在同一行包含同一产品的多个变体的情况是，如果产品变体包含相同的数据，包括`line_item`属性。以下是一个示例：
- en: '![Figure 4.6 – Example of the line item property chained to different product
    variants'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 将行项目属性链接到不同产品变体的示例'
- en: '](img/Figure_4.06_B17606.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.06_B17606.jpg](img/Figure_4.06_B17606.jpg)'
- en: Figure 4.6 – Example of the line item property chained to different product
    variants
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 将行项目属性链接到不同产品变体的示例
- en: If we were to click the `line_item` values were visible inside the checkout
    summary as well. Note that the same `line_item` property will be visible inside
    the order admin if we complete the purchase through our checkout page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`line_item`，那么在结账摘要中也会显示其值。请注意，如果我们通过我们的结账页面完成购买，相同的`line_item`属性将在订单管理界面中可见。
- en: 'Important note:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: We can only capture the `line_item` properties through Shopify's default checkout.
    If we were to complete the payment through any other checkout, such as `line_item`
    properties to our products, and they will not be visible inside the order admin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能通过Shopify的默认结账来捕获`line_item`属性。如果我们通过任何其他结账完成支付，例如将`line_item`属性添加到我们的产品中，它们将不会在订单管理界面中可见。
- en: With that, we have learned how to capture custom data for each of our products
    and display them on the cart and checkout pages. However, sometimes, we will be
    forced to recover the `line_item` data and visually hide it from both the cart
    and checkout pages. We can easily hide the `line_item` data from the cart page
    with some CSS code, *but how are we supposed to modify the code on the checkout
    page, considering that we do not have access to it?*
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何为我们的每个产品捕获自定义数据并在购物车和结账页面上显示它们。然而，有时我们被迫恢复`line_item`数据，并从购物车和结账页面上视觉上隐藏它。我们可以很容易地使用一些CSS代码从购物车页面隐藏`line_item`数据，*但是考虑到我们没有访问结账页面的权限，我们应该如何修改代码呢？*
- en: 'This is where the underscore character will help us. If we are looking to collect
    `line_items` and have them visible when we receive the order in our admin, while
    at the same time visually hiding the `line_items` properties from the checkout
    page, we would need to modify the `name` property inside the `product.liquid`
    section file to include the underscore inside the square bracket:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是下划线字符能帮到我们的地方。如果我们想要收集`line_items`并在我们的管理界面中看到它们，同时从结账页面视觉上隐藏`line_items`属性，我们需要修改`product.liquid`部分文件中的`name`属性，在方括号内包含下划线：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Any property name with the underscore as the first character inside the square
    bracket will not be visible on the checkout page. However, it will still be visible
    once we receive the order in our admin.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以下划线作为方括号内第一个字符的属性名在结账页面上将不可见。然而，一旦我们在管理界面收到订单，它仍然可见。
- en: Besides allowing us to hide the `line_items` properties from the checkout page
    automatically, the underscore character also helps us create a more automatic
    process for hiding the `line_items` property from the cart page, without having
    to write CSS code for every `line_items` property that we want to hide.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们自动从结账页面隐藏`line_items`属性外，下划线字符还帮助我们创建一个更自动化的过程来隐藏购物车页面上的`line_items`属性，而无需为每个想要隐藏的`line_items`属性编写CSS代码。
- en: With the introduction of the underscore character, we now have one uniquely
    distinctive character that we can use to filter the `line_items` properties we
    would like to show and which ones we would like to hide.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着下划线字符的引入，我们现在有一个独特的字符，我们可以用它来过滤我们想要显示和隐藏的`line_items`属性。
- en: 'Since we are dealing with string-type data, we can use the `truncate` filter,
    which, as its name suggests, allows us to truncate a string. The `truncate` filter
    accepts the following two parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是字符串类型的数据，我们可以使用`truncate`过滤器，正如其名称所暗示的，它允许我们截断字符串。`truncate`过滤器接受以下两个参数：
- en: The first parameter is a required number value, which allows us to set how many
    characters we expect the `truncate` filter to return.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个必需的数字值，它允许我们设置期望`truncate`过滤器返回的字符数。
- en: The second parameter is an optional parameter, which allows us to set a specific
    string value we would like to append to each returned string value. Note that
    if we do not include the second parameter, by default, the `truncate` filter will
    append three dots to the end of the string, which will count inside the previous
    parameter number value's `count`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个可选参数，它允许我们设置要附加到每个返回字符串值上的特定字符串值。请注意，如果我们不包括第二个参数，默认情况下，`truncate`过滤器将在字符串末尾附加三个点，这将计入之前参数数值的`count`。
- en: 'Since we are looking to check whether the `line_items` key value contains the
    underscore character as the first character in the string, we can apply the `truncate`
    filter and set the first parameter to `1`. However, we will also need to include
    the second parameter and set it equal to an empty string to avoid the previously
    mentioned ellipsis:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要检查 `line_items` 键值是否以下划线字符作为字符串的第一个字符，我们可以应用 `truncate` 过滤器并将第一个参数设置为
    `1`。然而，我们还需要包含第二个参数并将其设置为空字符串，以避免之前提到的省略号：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that throughout this project, we have only used a single `text` input type.
    However, we are free to use any input type at our disposal, including the `date`,
    `color`, `radio`, and `select` inputs. The only limitation is that we cannot use
    the `file` upload input type with Ajax. The product `form` tag will also need
    to include the `enctype="multipart/form-data`" attribute to capture the file upload
    input value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在整个项目过程中，我们只使用了单个 `text` 输入类型。然而，我们可以自由使用任何可用的输入类型，包括 `date`、`color`、`radio`
    和 `select` 输入。唯一的限制是不能使用 `file` 上传输入类型与 Ajax 一起使用。产品 `form` 标签还需要包含 `enctype="multipart/form-data"`
    属性以捕获文件上传输入值。
- en: With this project, we have learned how to create a valuable feature that will
    allow us to create specific customization for each product template, or even each
    product separately. We can design it as a simple feature with a single input or
    create an entire form with various inputs to fill in before purchasing a product.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个项目，我们学习了如何创建一个有价值的特性，这将使我们能够为每个产品模板或每个单独的产品创建特定的定制。我们可以将其设计为一个简单的具有单个输入的功能，或者创建一个包含各种输入的完整表单，在购买产品之前填写。
- en: We can also use the `line_items` easily and simply paste them inside our product
    templates. We can find the Shopify UI Elements generator at https://ui-elements-generator.myshopify.com/pages/line-item-property.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以轻松地使用 `line_items` 并将其简单地粘贴到我们的产品模板中。我们可以在 https://ui-elements-generator.myshopify.com/pages/line-item-property
    找到 Shopify UI 元素生成器。
- en: Let's say that we were looking to save page-specific data for some of the pages
    in our admin. However, if we were to navigate to our admin and open a product,
    collection, or any other page, we would notice that each page contains a predefined
    number of fields to store data. This is where the metafields objects come to the
    rescue.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要保存我们管理中某些页面的页面特定数据。然而，如果我们导航到我们的管理界面并打开一个产品、收藏夹或任何其他页面，我们会注意到每个页面都包含预定义的一定数量的字段来存储数据。这就是元字段对象大显身手的地方。
- en: Improving the workflow with metafields
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元字段改进工作流程
- en: '**Metafields** are global objects that allow us to store additional data inside
    our admin and output it to the storefront. As such, they are both powerful and
    necessary tools for creating complex designs with unique content.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**元字段**是全球对象，允许我们在管理界面中存储额外的数据并将其输出到店面。因此，它们是创建具有独特内容的复杂设计的强大且必要的工具。'
- en: 'Metafields consist of three mandatory elements:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 元字段由三个必填元素组成：
- en: The **namespace**, which we can use to group different metafields, so long as
    they share the same namespace.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**，我们可以用它来分组不同的元字段，只要它们共享相同的命名空间。'
- en: The `key` attribute, which allows us to access a specific metafield.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` 属性，它允许我们访问特定的元字段。'
- en: A `json_string` data type.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 `json_string` 数据类型。
- en: We can also use a `description` field for the short description of a metafield,
    which is optional compared to the previous three.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `description` 字段来为元字段的简短描述，与之前的三个相比，这是可选的。
- en: Metafields, while powerful tools, had quite a disadvantage as they were only
    available through third-party apps. However, since the Shopify Unite 2021 event,
    the metafields functionality has become available natively inside the Shopify
    dashboard, and not only that, but it has received quite the upgrade!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 元字段虽然功能强大，但有一个相当大的缺点，那就是它们只能通过第三方应用程序访问。然而，自从 Shopify Unite 2021 大会以来，元字段功能已经原生地集成在
    Shopify 控制面板中，不仅如此，它还得到了相当大的升级！
- en: The `metafields` functionality, while functional, at the time of writing, is
    only partially available as we can only access the product and variant metafields.
    The `page`, `blog`, `article`, `collection`, `order`, `customer`, and `shop` metafields
    are pending to be released. For this reason, we will learn how to handle these
    metafields through a third-party app and the Shopify dashboard.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`metafields` 功能虽然可用，但仅部分可用，因为我们只能访问产品和变体元字段。`page`、`blog`、`article`、`collection`、`order`、`customer`
    和 `shop` 元字段尚未发布。因此，我们将学习如何通过第三方应用程序和 Shopify 控制面板来处理这些元字段。
- en: Considering that most of today's themes still rely on third-party apps for their
    metafields needs, let's start by learning how to utilize a metafields app to create
    custom content for our pages.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到今天的大多数主题仍然依赖于第三方应用来满足他们的metafields需求，让我们先学习如何利用metafields应用为我们页面创建自定义内容。
- en: Setting up a metafields app
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置metafields应用
- en: 'For us to use and access metafields objects, we will need to either install
    an app or a browser extension that allows us to use this functionality. For this
    book''s purposes, we will proceed by installing an app so that we can familiarize
    ourselves with that Shopify app market as well:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用和访问metafields对象，我们需要安装一个应用或一个允许我们使用此功能的浏览器扩展。出于本书的目的，我们将通过安装一个应用来熟悉Shopify应用市场：
- en: To install an app on our store, we need to navigate to our admin and click on
    **Apps**, just above **Sales Channels**. Inside the **Apps** section, we will
    be able to see a list of all the apps that we have installed on our store. However,
    as we currently do not have any, the list is empty. Let's change this by clicking
    on the **Shop for apps** button in the top-right corner:![Figure 4.7 – Example
    of starting the app install process
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在我们的商店中安装应用，我们需要导航到我们的管理员界面，点击**Apps**，位于**Sales Channels**正上方。在**Apps**部分，我们将能够看到我们在商店上安装的所有应用的列表。然而，由于我们目前没有任何应用，列表是空的。让我们通过点击右上角的**Shop
    for apps**按钮来改变这种情况：![图4.7 – 开始应用安装过程的示例
- en: '](img/Figure_4.07_B17606.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07_B17606.jpg)'
- en: Figure 4.7 – Example of starting the app install process
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.7 – 开始应用安装过程的示例
- en: Clicking the `metafields` inside the search field.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索字段内点击`metafields`。
- en: After submitting a search, we will receive a significant number of apps that
    we can use, and most of them have a free plan available. For our purposes, we
    will be using the **Metafields Guru** app. While which app you choose is entirely
    optional, since they all offer the same functionality, we advise you to use the
    same app here as it will be easier to follow up with future development. Upon
    clicking on the app, you will be redirected to the app window.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交搜索后，我们将收到大量我们可以使用的应用，其中大多数都提供免费计划。出于我们的目的，我们将使用**Metafields Guru**应用。虽然选择哪个应用完全取决于你，因为它们都提供相同的功能，但我们建议你在这里使用相同的应用，这样在未来的开发中跟进会更容易。点击应用后，你将被重定向到应用窗口。
- en: After opening the app's landing page, we will be able to see more information
    about the page, which we should always read to check whether the app offers the
    features that we need. Let's click on the **Add app** button, which should immediately
    redirect us to our store and start the app installation process. On the other
    hand, if we are not, we will need to log in by submitting a store URL inside the
    popup window and clicking on the **Log in** button, which will start the app installation
    process:![Figure 4.8 – Example of the login popup on the Shopify app store
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开应用的着陆页后，我们将能够看到有关页面的更多信息，我们应该始终阅读这些信息，以检查应用是否提供了我们需要的功能。让我们点击**Add app**按钮，它应该立即将我们重定向到我们的商店并开始应用安装过程。另一方面，如果我们没有登录，我们需要在弹出窗口内提交商店URL并点击**Log
    in**按钮，这将开始应用安装过程：![图4.8 – Shopify应用商店中登录弹出窗口的示例
- en: '](img/Figure_4.08_B17606.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B17606.jpg)'
- en: Figure 4.8 – Example of the login popup on the Shopify app store
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.8 – Shopify应用商店中登录弹出窗口的示例
- en: After starting the installation process, we will see one last window, where
    we will need to provide the app with requested access to our store. Since we are
    working on a development store, we can immediately proceed by clicking on the
    **Install app** button. However, if we are working on a managed store for a client,
    it is strongly advised that we never install the app on someone else's store,
    even if they have asked us to do so. The store owner should be the one to install
    any necessary app once they know about all the personal information that the app
    will be collecting. Otherwise, we might be accountable for any possible problems.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始安装过程后，我们将看到一个最后的窗口，我们需要向应用提供请求的访问权限。由于我们正在开发商店上工作，我们可以立即通过点击**Install app**按钮来继续。然而，如果我们正在为客户管理一个商店，强烈建议我们永远不要在别人的商店上安装应用，即使他们要求我们这样做。商店所有者应该是在他们了解应用将收集的所有个人信息后安装任何必要的应用的人。否则，我们可能对任何可能的问题负责。
- en: 'With the **Metafields Guru** app now installed, we will see the first view
    within the app, where we can see all the different types of pages we can create
    metafields for:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装了**元字段大师**应用后，我们将在应用内看到第一个视图，其中我们可以看到我们可以为创建元字段的所有不同类型的页面：
- en: '![Figure 4.9 – Different types of pages we can use metafields objects for'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 我们可以使用元字段对象的不同页面类型'
- en: '](img/Figure_4.09_B17606.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.09_B17606.jpg)'
- en: Figure 4.9 – Different types of pages we can use metafields objects for
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 我们可以使用元字段对象的不同页面类型
- en: 'As shown in the preceding screenshot, metafields are powerful tools that allow
    us to customize any section of our store. So, let''s begin by creating the metafield
    for a product page:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，元字段是强大的工具，允许我们自定义我们商店的任何部分。因此，让我们从为产品页面创建元字段开始：
- en: The first thing we need to do is navigate to the **Product** section of our
    admin, select any product of our choosing, and click on it.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导航到我们的管理员中的**产品**部分，选择我们选择的任何产品，然后点击它。
- en: After opening the product page, click on the **More actions** button in the
    top-right corner to reveal the **Edit Metafields** button. Click on it to launch
    the **Metafields Guru** app:![Figure 4.10 – Example of starting the Metafield
    Guru app for a specific page
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开产品页面后，点击右上角的**更多操作**按钮，以显示**编辑元字段**按钮。点击它以启动**元字段大师**应用：![图 4.10 – 为特定页面启动元字段大师应用的示例
- en: '](img/Figure_4.10_B17606.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B17606.jpg)'
- en: Figure 4.10 – Example of starting the Metafield Guru app for a specific page
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.10 – 为特定页面启动元字段大师应用的示例
- en: Once inside the app, we will be able to see a list of all the metafields that
    we have for this specific product, or even the variant if we select the **Variants**
    card. However, since we don't have any, the screen is empty. Let's create our
    first metafield by clicking the **Create metafield** button.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入应用，我们将能够看到所有针对此特定产品（或如果我们选择**变体**卡，甚至是变体）的元字段列表。然而，由于我们没有，屏幕是空的。让我们通过点击**创建元字段**按钮来创建我们的第一个元字段。
- en: Inside this first field, we can select the data type that we will save inside
    this specific metafield. This is where we will be populating the other three fields
    with the `key`, `namespace`, and `metafield` values. We can leave the `String`
    value selected for our example and then, inside the `key` field, type in the word
    `example`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个第一个字段中，我们可以选择我们将要保存在这个特定元字段中的数据类型。这就是我们将使用`key`、`namespace`和`metafield`值来填充其他三个字段的地方。在我们的示例中，我们可以选择`String`值，然后在`key`字段中输入单词`example`。
- en: 'The `namespace` field already contains the `global` keyword, but we can enter
    any type of text in the final field. For example, we will use `Metafields are
    awesome!`. After filling in all the fields, save your changes by clicking the
    **Save** button in the top-right corner:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`namespace`字段已经包含`global`关键字，但我们可以将任何类型的文本输入到最后一个字段中。例如，我们将使用`Metafields are
    awesome!`。填写完所有字段后，通过点击右上角的**保存**按钮保存您的更改：'
- en: '![Figure 4.11 – Example of creating a product metafield'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 创建产品元字段的示例'
- en: '](img/Figure_4.11_B17606.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B17606.jpg)'
- en: Figure 4.11 – Example of creating a product metafield
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 创建产品元字段的示例
- en: Now that we have learned how to create a metafield, it is time to learn how
    to output the previously saved data to our storefront.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何创建元字段，是时候学习如何将之前保存的数据输出到我们的店面上了。
- en: Rendering the metafields value
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染元字段值
- en: 'We can access the `metafields` object through the object of the page we created
    the metafield for, followed by the `metafields` object, followed by `namespace`,
    followed by `key`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为我们创建元字段的页面对象访问`metafields`对象，然后是`metafields`对象，然后是`namespace`，然后是`key`：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can enter the metafield code anywhere where we have access to the `product`
    object. However, for our purposes, we should place the code inside the `product.liquid`
    section, just above the `line_item` input that we included in one of our previous
    projects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何我们可以访问`product`对象的地方输入元字段代码。然而，出于我们的目的，我们应该将代码放置在`product.liquid`部分中，正好在我们之前项目中包含的`line_item`输入之上。
- en: 'Now that we have created the product metafield and have the metafield object
    code in place, all we need to do is test it out. However, remember that we have
    created a metafield for a specific product only, meaning that we can only preview
    it on that specific product. If we were to preview the product we created the
    metafield for, we would see the following metafield string value displayed correctly
    on our page:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了产品元字段并且已经放置了元字段对象代码，我们所需做的只是测试它。然而，请记住，我们只为特定产品创建了一个元字段，这意味着我们只能在那个特定产品上预览它。如果我们预览为创建元字段的产品，我们将在页面上正确显示以下元字段字符串值：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With that, we have successfully created and displayed a single metafield value.
    However, *what if we had a larger number of similar metafields? How would we output
    all of them?* We initially mentioned that we could use the `namespace` attribute
    to different group metafields together, so long as they share the same `namespace`.
    Using `namespace` with the `for` tag, we can loop over all the metafields with
    the same `namespace` and recover their values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功创建并显示了一个单个元字段值。然而，*如果我们有更多类似的元字段怎么办？我们该如何输出所有这些字段呢？* 我们最初提到，只要它们共享相同的`namespace`，我们就可以使用`namespace`属性将不同的元字段分组在一起。使用`namespace`与`for`标签结合，我们可以遍历具有相同`namespace`的所有元字段并恢复它们的值：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the previous code would recover any metafields with the `global` keyword
    as its namespace. However, since we are not using the `key` attribute this time,
    we will receive the results in array format:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将恢复任何具有`global`关键字作为其`namespace`的元字段。然而，由于这次我们没有使用`key`属性，我们将以数组格式接收结果：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To split the array, we will need to use the `first` and `last` filters, as
    we did previously, to split the `line_item` object on the cart page:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分割数组，我们需要使用`first`和`last`过滤器，就像我们之前做的那样，来分割购物车页面上的`line_item`对象：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the `first` and `last` filters, we have successfully split the array into
    two separate elements that we can now use in any way we require.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`first`和`last`过滤器，我们已经成功将数组分割成两个独立的元素，我们现在可以按需使用它们。
- en: With that, we have taken a significant step forward by learning how to output
    single and multiple metafield values through a third-party app.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经通过第三方应用学习了如何输出单个和多个元字段值，迈出了重要的一步。
- en: While helpful, adding metafields through a third-party app requires quite a
    bit of hardcoding, which we can avoid by creating metafields through the Shopify
    dashboard instead. However, while metafields have received a powerful upgrade,
    they also have a prerequisite, which we learned about previously. For this reason,
    we will learn how to set up and handle metafields through the Shopify dashboard
    in the following chapters to gain a better understanding of this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有帮助，但通过第三方应用添加元字段需要相当多的硬编码，我们可以通过通过Shopify仪表板创建元字段来避免这一点。然而，尽管元字段得到了强大的升级，它们也有一个先决条件，我们之前已经了解过。因此，在接下来的章节中，我们将学习如何通过Shopify仪表板设置和处理元字段，以更好地理解这一点。
- en: Using metafields, we can now add well-organized, unique content to each page
    or even create complex functionalities. For example, with metafields, we can create
    product accordions, show hand-picked recommended products, and use them to show
    the expected delivery time for each product/variant and other features. We are
    only limited by our inspiration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元字段，我们现在可以为每个页面添加组织良好、独特的内 容，甚至创建复杂的功能。例如，使用元字段，我们可以创建产品折叠面板，展示精选的推荐产品，并使用它们来显示每个产品/变体的预期交货时间和其他功能。我们只受限于我们的灵感。
- en: The few projects that we have covered by now might look inadequate compared
    to the number of different types of global objects we have at our disposal. However,
    the knowledge we have attained through these projects has set us on the right
    path of understanding objects entirely. Our primary focus was not simply listing
    objects and their attributes, which we can quickly get from Shopify documentation,
    but learning how to use different objects and attributes through real-life projects
    that we will be working on tomorrow as Shopify experts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们涵盖的几个项目可能看起来与我们可以使用的不同类型的全局对象数量相比显得不足。然而，通过这些项目获得的知识已经让我们走上了完全理解对象的正确道路。我们的主要焦点不仅仅是列出对象及其属性，我们可以快速从Shopify文档中获得这些信息，而是学习如何通过我们明天将作为Shopify专家从事的实际项目来使用不同的对象和属性。
- en: Before we can say that we understand how objects work, we will need to learn
    more about content objects, without which we would not be able to output any content
    on our pages.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以说我们理解对象的工作原理之前，我们需要更多地了解内容对象，没有它们，我们就无法在我们的页面上输出任何内容。
- en: Content and special objects
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容和特殊对象
- en: 'Previously, we learned how to use global objects to output the data from our
    admin on our templates and section files. Now, it is time to learn how to use
    content objects to output the content of template and sections files, as well
    as any other assets that are necessary for the Shopify store to operate. We can
    divide the content objects into three separate groups: `content_for_header`, `content_for_index`,
    and `content_for_layout`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何使用全局对象在模板和部分文件中输出管理员的数据。现在，是时候学习如何使用内容对象来输出模板和部分文件的内容，以及 Shopify 店铺运行所需的任何其他资产。我们可以将内容对象分为三个不同的组：`content_for_header`、`content_for_index`
    和 `content_for_layout`。
- en: All three types of content objects have descriptive names that tell us what
    they do. However, to ensure that we fully understand their importance, we will
    provide a small explanation for each.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种内容对象都有描述性的名称，告诉我们它们的功能。然而，为了确保我们完全理解它们的重要性，我们将为每个对象提供简短的解释。
- en: The content_for_header object
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: content_for_header 对象
- en: '`content_for_header` is a mandatory object located inside the `theme.liquid`
    layout file – more specifically, inside the HTML `<head>` tag:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`content_for_header` 是位于 `theme.liquid` 布局文件内的一个强制对象——更具体地说，位于 HTML `<head>`
    标签内：'
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The whole purpose of this object is to load all the scripts that Shopify requires
    into the document's header dynamically. Among these scripts, we can find Shopify
    and Google Analytics scripts, and even the scripts required for some Shopify apps.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的主要目的是动态地将 Shopify 所需的所有脚本加载到文档的头部。在这些脚本中，我们可以找到 Shopify 和 Google Analytics
    脚本，甚至是一些 Shopify 应用所需的脚本。
- en: The content_for_index object
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: content_for_index 对象
- en: '`content_for_index` is a not mandatory object and it''s located within the
    `index.liquid` template, which we can find inside the `Template` directory:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`content_for_index` 是一个非强制对象，它位于 `index.liquid` 模板中，我们可以找到这个模板在 `Template`
    目录下：'
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, this object allows us to dynamically output dynamic sections from the
    theme editor, making it mandatory. Without it, we would not be able to output
    any content from our theme editor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个对象允许我们动态地从主题编辑器输出动态部分，因此它是强制性的。没有它，我们就无法从我们的主题编辑器输出任何内容。
- en: The content_for_layout object
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: content_for_layout 对象
- en: '`content_for_layout` is the final mandatory object located inside the `theme.liquid`
    layout file. This object allows us to load content that''s been dynamically generated
    by other templates, such as `index.liquid` and `collection.liquid`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`content_for_layout` 是位于 `theme.liquid` 布局文件内的最后一个强制对象。这个对象允许我们加载由其他模板（如 `index.liquid`
    和 `collection.liquid`）动态生成的内容：'
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that it is not possible to delete the `content_for_header` and `content_for_layout`
    objects from their respective positions, so we don't need to worry too much about
    them. However, it is essential to know what each of the content objects does since
    even though we cannot delete them, we can comment them out, which will create
    issues with our storefront.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无法从它们各自的位置删除 `content_for_header` 和 `content_for_layout` 对象，所以我们不必过于担心它们。然而，了解每个内容对象的功能是至关重要的，因为尽管我们无法删除它们，但我们仍然可以取消注释它们，这可能会对我们的店面造成问题。
- en: Finally, besides global and content objects, we also have another set of objects
    that we can only use under specific circumstances. The only two objects we currently
    have at our disposal are the `additional_checkout_buttons` and `content_for_additional_checkout_buttons`
    objects, which will provide us with a way to dynamically generate a set of buttons
    leading to a third-party provider's checkout page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了全局和内容对象之外，我们还有另一组只能在特定情况下使用的对象。我们目前可用的唯一两个对象是 `additional_checkout_buttons`
    和 `content_for_additional_checkout_buttons` 对象，它们将为我们提供一种动态生成一组按钮的方法，这些按钮可以链接到第三方支付提供商的结账页面。
- en: However, note that deciding which buttons will be visible depends on the payment
    methods that we have set in the admin, as well as some other parameters. For example,
    for the **Apple Pay** checkout button to be visible, besides enabling the payment
    method in the admin, the customer will also have to use an Apple device to see
    it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，决定哪些按钮可见取决于我们在管理员中设置的支付方式以及一些其他参数。例如，为了让 **Apple Pay** 结账按钮可见，除了在管理员中启用支付方式外，客户还必须使用苹果设备才能看到它。
- en: The `additional_checkout_buttons` object allows us to check whether the store
    offers payment using third-party payment providers, such as PayPal, Apple, and
    others. Suppose we have enabled a payment gateway to some third-party payment
    providers. The `additional_checkout_buttons` object, in combination with an `if`
    statement, will return `true`, which will allow us to use our next special object;
    that is, `content_for_additional_checkout_buttons`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “额外结账按钮”对象允许我们检查商店是否提供使用第三方支付提供商（如PayPal、Apple等）的支付方式。假设我们已经为某些第三方支付提供商启用了支付网关，那么“额外结账按钮”对象与一个“if”语句结合，将返回“true”，这将允许我们使用我们的下一个特殊对象；即“content_for_additional_checkout_buttons”。
- en: 'After confirming that we have enabled these payment methods with third parties,
    we can use the `content_for_additional_checkout_buttons` object to generate the
    buttons for those payment providers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认我们已经与第三方启用了这些支付方式后，我们可以使用“content_for_additional_checkout_buttons”对象为那些支付提供商生成按钮：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While the placement of the code is entirely optional, it is usually placed on
    the cart page, next to the default **Checkout** button.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码的位置完全是可选的，但它通常放置在购物页面上，紧邻默认的**结账**按钮旁边。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about different types of objects while considering
    various projects. Within our first project, `Custom collection`, we learned how
    to access single-valued attributes within the `product` object by creating a custom
    collection feature with a fully functional product form. The second project, `Custom
    navigation`, taught us how to access and handle objects whose attributes return
    an array. Working through the `Product Customization` project, we understood how
    to capture multiple data types, chain them with the selected variant, and output
    the same data on both the cart and checkout pages.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在考虑各种项目的同时，学习了不同类型的对象。在我们的第一个项目“自定义集合”中，我们学会了如何通过创建一个功能齐全的产品表单来自定义集合功能，以访问“产品”对象中的单值属性。第二个项目“自定义导航”教会了我们如何访问和处理那些属性返回数组的对象。通过“产品定制”项目，我们了解了如何捕获多种数据类型，将它们与选定的变体链接起来，并在购物车和结账页面上输出相同的数据。
- en: Besides working on different projects, we also had the pleasure of learning
    how to install new apps from the store and how to use a third-party app to create
    additional input fields within our admin, which gave us access to `metafields`
    objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参与不同的项目，我们还很荣幸地学习了如何从商店安装新应用，以及如何使用第三方应用在我们的管理后台中创建额外的输入字段，这使我们能够访问“元字段”对象。
- en: Finally, we learned about the different types of content and special objects,
    why some are mandatory, where we can find them, and how we can use some of them
    to connect our store to various payment providers outside Shopify.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了不同类型的内容和特殊对象，为什么有些是必需的，在哪里可以找到它们，以及我们如何使用其中一些将我们的商店连接到Shopify之外的各个支付提供商。
- en: The knowledge that we have attained through this chapter will be especially
    helpful in the next chapter, where we will learn more about the filters that we
    have been referencing through our projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中获得的知识将在下一章特别有用，在下一章中，我们将学习更多关于我们在项目中引用的过滤器。
- en: Questions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are we missing in the following block of code to make `form` functional?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们缺少什么来使“表单”功能正常？
- en: '[PRE37]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How can we get access to the `product` object through a link defined in the
    admin navigation?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何通过管理导航中定义的链接来获取“产品”对象的访问权限？
- en: What are the two approaches to accessing single and multiple `metafield` objects?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问单值和多个“元字段”对象有哪些两种方法？
- en: What adjustment do we need to make to the input element if we were looking to
    capture the `line_item` value and hide it on the checkout page?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要捕获“行项目”值并在结账页面上隐藏它，我们需要对输入元素进行哪些调整？
- en: '[PRE38]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Practice makes perfect
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟能生巧
- en: In the previous chapter, we worked together through various projects and implementations.
    However, we can only gain a proper understanding by working on the projects ourselves
    and forcing ourselves to make that next step. So far, we haven't completed any
    personal projects as we were still learning the basics. However, with objects
    behind us, we are now set to start creating our own solutions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过各种项目和实现一起工作。然而，只有通过亲自参与项目并强迫自己迈出下一步，我们才能获得正确的理解。到目前为止，我们还没有完成任何个人项目，因为我们还在学习基础知识。然而，随着我们对对象的理解，我们现在可以开始创建自己的解决方案了。
- en: The few mini-projects we will cover here will help us solidify some of our already
    attained knowledge from the previous chapters. It will also push our limits by
    forcing us to think outside of the box and find solutions for the problems that
    we haven't faced so far.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将涵盖的几个小型项目将帮助我们巩固我们从上一章中获得的一些知识。它还将通过迫使我们跳出思维定势并找到我们尚未遇到的问题的解决方案来挑战我们的极限。
- en: Each project will contain detailed information about what we need to do to help
    us achieve the results.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都将包含关于我们需要做什么的详细信息，以帮助我们实现结果。
- en: We recommend working on each project independently from the previous chapters
    since this will ensure that we have truly understood what we have learned so far.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议独立于前几章完成每个项目，因为这将确保我们真正理解了我们迄今为止所学的内容。
- en: No single project has either a correct or incorrect solution. However, if by
    any chance we get stuck, we can always consult the project solution at the end
    of this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个单独的项目有正确或错误的解决方案。然而，如果我们有任何困难，我们总是可以查阅本书末尾的项目解决方案。
- en: Project 1
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 1
- en: For our first project, we will be creating a custom collection on a general
    page. However, the difference between this project and the one we worked on previously
    is that this custom collection will be a dynamic and reusable code block. Depending
    on the page name, we should see different products in the featured collection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个项目，我们将在一个通用页面上创建一个自定义收藏夹。然而，这个项目与我们之前工作的项目之间的区别在于，这个自定义收藏夹将是一个动态且可重用的代码块。根据页面名称，我们应该在特色收藏夹中看到不同的产品。
- en: 'Here are the steps for the assets:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是资产步骤：
- en: Create a new page template called `featured-collection.liquid`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `featured-collection.liquid` 的新页面模板。
- en: Create a new page, name it similarly to one of the collection pages on our store,
    and assign it the new page template that we created previously.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新页面，将其命名为与我们商店中的某个收藏页面类似，并分配我们之前创建的新页面模板。
- en: Create the new menu item inside the current main menu navigation, called `Projects`,
    and add the newly created page as a nested menu inside the `Projects` menu item.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前主菜单导航中创建一个新的菜单项，命名为“项目”，并将新创建的页面作为嵌套菜单添加到“项目”菜单项中。
- en: Create a new snippet file named `custom-collection`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `custom-collection` 的新片段文件。
- en: 'Here are the assignment steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是分配步骤：
- en: Include the `custom-collection` snippet inside `featured-collection.liquid`
    with `collection` as a parameter. Since the page shares a name that's similar
    to our collections', we should use the page handle to create the `collection`
    object.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `featured-collection.liquid` 中包含 `custom-collection` 片段，并将 `collection` 作为参数。由于页面名称与我们的收藏夹相似，我们应该使用页面处理程序来创建
    `collection` 对象。
- en: Using the `collection` object that we passed previously, create a custom collection
    using the `for` tag to display no more than four products.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前传递的 `collection` 对象，使用 `for` 标签创建一个自定义收藏夹，显示不超过四个产品。
- en: The products should contain an image, title, vendor, regular price, comparing
    price visible, and a working product form.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品应包含图片、标题、供应商、常规价格、比较价格可见以及一个工作的产品表单。
- en: If a product has more than one variant, include a dropdown so that we can select
    the exact variant we are looking to select.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个产品有多个变体，包括一个下拉菜单，以便我们可以选择我们想要选择的精确变体。
- en: After submitting the form, return us to the same page we were previously on.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交表单后，返回我们之前所在的页面。
- en: Once complete, any page with `featured-collection.liquid` assigned as its template
    should display different types of products based on the page name; for example,
    Indoor or Outdoor.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，任何将 `featured-collection.liquid` 分配为其模板的页面都应该根据页面名称显示不同类型的产品；例如，室内或室外。
- en: Project 2
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 2
- en: For our second project, we will be creating a subcollection template page where
    we will be able to output different collection pages. The code that we will create,
    similar to the previous project, should be reusable. We should receive different
    results based on the name of the page we have assigned the template to, and the
    collections that have been assigned to the navigation menu with the same name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个项目，我们将创建一个子收藏模板页面，我们将能够输出不同的收藏页面。我们将创建的代码，类似于前一个项目，应该是可重用的。我们应该根据我们分配模板的页面名称以及分配给具有相同名称的导航菜单的收藏来获得不同的结果。
- en: 'Here are the steps for the assets:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是资产步骤：
- en: Create a new page template called `page-subcollection.liquid`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `page-subcollection.liquid` 的新页面模板。
- en: Create a new page and assign it to the new page template that we created previously.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新页面并将其分配给我们之前创建的新页面模板。
- en: Create the new navigation menu and give it the same name we gave the page that
    we created previously.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的导航菜单，并给它起与我们之前创建的页面相同的名字。
- en: Inside the new navigation menu, include no less than six collection menu items.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的导航菜单中，至少包含六个收藏菜单项。
- en: Create a new snippet file called `custom-subcollection`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`custom-subcollection`的新片段文件。
- en: 'Here are the assignment steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分配步骤：
- en: Include the `custom-subcollection` snippet inside `page-subcollection.liquid`
    with `subcollection` as a parameter. Since the page shares a name that's similar
    to our navigation menu, we should use the page handle to create the `subcollection`
    object.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`page-subcollection.liquid`中包含`custom-subcollection`片段，并将`subcollection`作为参数。由于页面名称与我们的导航菜单相似，我们应该使用页面处理程序来创建`subcollection`对象。
- en: Using the `subcollection` object that we passed previously, use a `for` tag
    to create a list of all the collection pages inside the specific navigation menu.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前传递的`subcollection`对象，使用`for`标签创建特定导航菜单内所有收藏页面的列表。
- en: The collection list should contain an image and a title.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收藏列表应包含一张图片和标题。
- en: If the collection does not have the image assigned to it, we should take the
    image of the first product inside that collection and show it as the collection
    image.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该收藏没有分配图片，我们应该取该收藏中第一个产品的图片并将其作为收藏图片显示。
- en: Once complete, any page with `custom-subcollection.liquid` assigned as its template
    should display different results based on its name, as well as the collection
    that was assigned to the navigation menu with the same name.**
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，任何被分配`custom-subcollection.liquid`作为模板的页面应根据其名称以及分配给具有相同名称导航菜单的收藏显示不同的结果。**
