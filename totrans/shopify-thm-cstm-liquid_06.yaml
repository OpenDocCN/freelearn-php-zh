- en: '[*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079): Diving into
    Liquid Core with Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we have been referencing objects. However, in
    this chapter, we will learn about objects, their attributes, and some of the best
    ways to use them. By learning about objects, we will finalize some projects that
    we have started and work on new projects to develop our knowledge further.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with global objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the workflow with metafields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content and special objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon completing this chapter, we will understand what content objects are, why
    they are mandatory, and how to use them, which is the first step in creating future
    templates. We will have also learned more about the global objects that we have
    been referencing up until now.
  prefs: []
  type: TYPE_NORMAL
- en: However, due to the significant number of global objects and attributes they
    offer us, we will not cover all of them. Instead, we will only explain some of
    the essential global objects and attributes, which will set us on the right path
    to understanding objects entirely. By learning about objects, we will also learn
    to understand metafields, which allow us to store and dynamically output additional
    data on our store. Lastly, we will learn about the special objects that will help
    us output some helpful functionalities on our store.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will explain each topic and have it presented with the accompanying
    graphics, we will need an internet connection to follow the steps outlined in
    this chapter, considering that Shopify is a hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub at https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3u7hqyB](https://bit.ly/3u7hqyB)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with global objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We referenced objects and their attributes in the previous chapter. *But what
    exactly are objects?*
  prefs: []
  type: TYPE_NORMAL
- en: These objects, or so-called `{{ collection.title }}`, where the `collection`
    keyword would be our object and `title` would be the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We can reference these global objects inside any file by directly visiting the
    page whose content we are looking to recover and calling the object, or manually
    invoking the object for the specific page using its handle and combining it with
    the variable tags. Let's see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from the previous chapter, while we were working on the project
    on our indoor collection page, we initially used `collection.title` to recover
    the collection''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When used inside the collection page, the preceding code will provide us with
    the data we are looking for. However, *what if we wanted to access the* `indoor`
    *collection object while visiting the outdoor collection page?*
  prefs: []
  type: TYPE_NORMAL
- en: This is where our knowledge of accessing the page object using the page handle,
    which we covered in [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030),
    *The Basic Flow of Liquid*, in the *EmptyDrop* subsection of the *Understanding
    the types of data* section comes to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the object using its handle by pluralizing the object''s name
    we are trying to access, followed by either a squared bracket (`[]`) or dot (`.`)
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By defining a variable with the object of the indoor collection, we can output
    the data for that collection on any page by simply invoking the object, followed
    by the attribute that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While our object name differs from the original object name, it will allow us
    to output the same information compared to when we used `{{ collection.title }}`
    inside the collection template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we created a variable using the `customCollection`
    name. However, note that you can create this variable using any name of your choice,
    including the collection itself. While the `collection` keyword is not reserved,
    we should pay close attention when using the keywords already in use as this can
    cause unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that global objects is an extensive topic, it would not be very
    productive to explain each object and their attributes separately. Instead, we
    will be creating a few projects to see firsthand how to work with different kinds
    of objects and the data types they return.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, an object, in combination with attributes, allows
    us to read the information from our admin and dynamically output it to create
    various functionalities. Let's start by familiarizing ourselves with the collection
    and product objects, which we will use to finalize the `Custom collection` project
    that we started in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Custom collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a `for` loop that outputs the names of
    the products from the outdoor collection, whose price is lower than $100.00\.
    We did this by creating a `collection-form` snippet whose content we are outputting
    using the `for` parameter, combined with the `render` tag. We placed this at the
    bottom of our `collection.liquid` template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our snippet, we added an `if` statement to check if the product price
    is higher than `10000`. If it is, we should output the product `form` tag and
    the product title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we were to preview our code by vising the indoor collection page, we would
    only see a list of names, so let's try to improve this snippet by writing some
    code that will output the entire product block instead of only the product's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by refactoring the code inside the snippet by removing the `continue`
    and `capture` tags, refining our statement by removing the `else` statement, wrapping
    `{{ product.title }}`, positioning it above the product form, and finally removing
    the extra parameters from our product `form` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The newly refactored code will do the same thing as it did previously, but now,
    it will be easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed by creating our product block. Currently, we only have a product
    name, so let's include the hyperlink that will redirect us to the actual product
    name when we click on the product's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by wrapping `{{ product.title }}` inside of the hyperlink tag,
    with its `href` attribute set to `{{ product.url }}`. This will return the relative
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The addition of the hyperlink has ensured that we will be redirected to the
    actual product page by clicking the product's name. The next thing we need to
    do is include the image for each of our products.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by creating an image HTML tag inside the hyperlink tag, just
    above the product title, and setting its `src` attribute to `{{ product | img_url
    }}`. This will return a string to the location of the product image on Shopify''s
    **Content Delivery Network** (**CDN**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our product block is starting to look a lot better, but we still need to show
    the price of our products. We can include the product price by wrapping `{{ product.price
    | money }}` inside the `p` HTML tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have a small addition separated by a pipe character for both
    the `image` and `price` objects. This addition is called a **filter**, which helps
    us modify the output that we would otherwise receive from the object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we were to call the `product` object with the `price` attribute,
    we would receive a number value without any format, such as `2599`. However, by
    applying the `money` filter to the object, we have automatically changed the otherwise
    meaningless number into a string data type and formatted it according to our store-selected
    currency formatting, resulting in a $25.99 string.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go into too much detail regarding filters right now, as we will
    be learning about them in the next chapter. For now, this basic information about
    filters will have to suffice. Let's return to our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have included the product name, image, and price, which check most
    of the necessary boxes that are needed to present a product. However, notice that
    the product `form` is currently empty. Let''s change this by introducing an `input`
    element so that it''s of the `submit` type, which should allow us to purchase
    the product directly from the collection page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the addition of the **Add to Cart** button, we have created a button that
    should allow us to purchase the products directly from our collection page, without
    having to navigate to the product page. However, if we were to click it right
    now, we would encounter an error stating **Parameter Missing or Invalid: Required
    parameter missing or invalid: items**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Result of submitting a product form with missing parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Result of submitting a product form with missing parameters
  prefs: []
  type: TYPE_NORMAL
- en: The parameter that we are missing is the `id` property of the variant that we
    are looking to purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Every product on Shopify can have up to three different sets of options. For
    example, a product can have multiple sizes, colors, and materials. Each combination
    of these three choices generates a unique number called a variant `id`, which
    tells our product `form` which combination of options it should place in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these options are entirely optional as we can have a product without
    any variant options. However, even then, we still need to include the variant
    `id`. We should include this variant `id` as a `value` attribute of the `hidden`
    HTML input element with `id` as its `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the addition of the variant `id`, we now have a fully functional product
    `form`. By clicking the `id` and added to our cart.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we will also be automatically redirected to the cart page after
    clicking the **Add to Cart** button. This is the default behavior that we can
    rectify in one of two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first way would require us to add the `return_to` parameter to our product
    `form` tag, which will allow us to set the page we should return to after submitting
    the form. We can remind ourselves of how to use the `return_to` parameter by returning
    to the previous chapter and revisiting *The form tag* subsection, located under
    the *Theme tags* section. The other way would be to use the **Shopify Ajax API**,
    which we will learn about later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to the indoor collection for now. Let's look at the entire collection
    page and compare the initial collection products with our custom collection at
    the bottom. You will notice that besides being styled in a much better way than
    our collection, the initial collection products also contain a red sale badge,
    along with a regular and discounted price.
  prefs: []
  type: TYPE_NORMAL
- en: Each product in the admin contains two different fields for price, located under
    the `product` object with the `compare_at_price` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our code on the collection page and modify it so that it includes
    both the sale badge and the compare price to match the initial collection. We
    can show the comparison price by wrapping `{{ product.compare_at_price | money
    }}` inside the `span` element and positioning it right after `{{ product.price
    | money }}`. Additionally, we can implement the sale badge by creating a simple
    string message inside the `span` tag and placing it under the `price` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included all the necessary elements for the `Custom collection` items.
    However, quite a few products do not have their comparison price and sale badges
    visible, which results from the `if` statement on our first line so that it shows
    products with a defined comparison price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By modifying the `if` statement, we have ensured that we only display products
    on sale, consequently creating a custom on-sale addition for our initial collection.
    The only thing left to do is update the HTML formatting and add some CSS styling.
    While formatting and styling are entirely optional, we advise you to use the same
    formatting as it will be easier to follow up with future changes. The HTML formatted
    code, along with some basic CSS styling, can be found at the following GitHub
    link within the `Learning Projects` directory, under the name `Custom collection`:
    https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20collection.'
  prefs: []
  type: TYPE_NORMAL
- en: This GitHub repository contains three files, each named according to the location
    where the code should be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we preview our collection indoor collection now, we will see a significant
    improvement compared to when we started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Example of a complete custom collection project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Example of a complete custom collection project
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only mentioned objects whose attributes return a single value,
    such as `product.price`, `product.title`, or `product.first_available_variant.id`.
    However, they can also return an array or even act as helper tools for our programming
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most used objects that returns an array is the `linklist` object.
    Combined with the `link` object, it will help us read the data from the menu within
    the navigation admin and help us create a custom navigation menu.
  prefs: []
  type: TYPE_NORMAL
- en: Custom navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our next project, we will create a multi-level navigation menu specifically
    for our collection page. However, before we can learn about the `linklist` and
    `link` objects, we need to create a navigation menu. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new navigation menu by navigating to admin, clicking on **Online
    store** to expand it, and clicking on the **Navigation** link, where we can create
    the new menu by clicking the **Add menu** button:![Figure 4.3 – Example of accessing
    the Navigation menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.3 – Example of accessing the Navigation menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After clicking the **Add menu** button, set the menu's title to **Indoor Navigation**.
    The page's handle will be automatically populated once we set the menu's name,
    so there is no need to modify it manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to populate the menu. Click on the **Add menu item** button
    and click on the **Link** field, which will automatically display a dropdown menu.
    For the first menu item, click on **Collections**, then **All collections**, which
    should immediately populate the menu item's name and link fields. Click on the
    **Add** button to finish adding the menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step six more times by creating two menu items named and
    linked to the two collections **Indoor** and **Outdoor**, and then four menu items
    to any four products in our store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have created the additional menu items, move the **Indoor** and **Outdoor**
    menu items under the **All collections** menu item to create a nesting menu. We
    can do this by clicking on the six dots before the menu item's name, and then
    holding and moving them over the **All collections** menu item until the indented
    blue line shows, at which point we should release the click:![Figure 4.4 – Example
    of creating a dropdown menu inside the Navigation menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.4 – Example of creating a dropdown menu inside the Navigation menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repeat the previous step and move the two product menu items under the **Indoor**
    collection menu item, which we have already moved under the **All collections**
    menu item. Repeat the same process for the **Outdoor** collection menu item and
    the two product menu items that are remaining.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have done everything right, we should end up with an **Indoor Navigation**
    menu containing a single menu item containing **All collections**, which contains
    two collection menu items containing two product menu items each. Suppose the
    menu format does not look the same after following the preceding steps. In that
    case, we can consult the Shopify documentation on nesting the menu items, where
    we can find more detailed instructions and a YouTube link on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on creating nesting navigation, please refer to https://help.shopify.com/en/manual/online-store/menus-and-links/drop-down-menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum amount of nesting menu items we can have inside a single menu is
    up to three levels long. We can consider the menu that we previously created as
    a three-level navigation menu, which is the limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have successfully created the navigation menu, we can start creating
    a variable that we will assign the value of the `linklist` object to, followed
    by the handle of the navigation we are trying to access. Remember that when accessing
    the object using the handle, we need to pluralize the object by adding the letter
    `s` at the end of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have successfully saved the object of our indoor navigation to
    the `collection-menu` variable. Let''s test it inside our `collection.template`.
    To do so, we will call the `collection-menu` object, followed by the `title` and
    `levels` attributes, just above `{% section ''collection-template'' %}` so that
    we can see the name of our navigation and the number of nesting menus it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we preview our indoor collection, we will be able to see the name of our
    navigation and the number of nested levels the navigation menu has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have confirmed that we have recovered the correct menu object,
    we can remove the `collection-menu.title` and `collection-menu.levels` lines.
    For the next step, we will need to use the `for` tag to loop over the array of
    links inside the object, which we can recover by calling the `collection-menu`
    object, followed by the `links` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we preview our **Indoor** collection now, we will notice that the only menu
    item that's visible on our page is the first level item, **All Collections**.
    Suppose we would like to loop over the additional nested menus located inside
    the **All Collections** menu item. In that case, we will need to create a second
    loop inside the first loop to recover the data from the second level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key difference is that we will not use `collection-menu` as our object.
    Instead, we will use the `link` object from our first `for` loop, combined with
    the `links` attribute, which will give us access to the array of links inside
    the `link` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By looping over the `link` object, we were able to recover the array links
    nested inside the **All Collections** menu item. Using the same technique, we
    can loop over the array of links inside the final level of the **Indoor** navigation
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the necessary elements to create a working on-hover navigation
    menu. The only thing left is to add some `HTML` tags and apply the necessary styling
    to create the on-hover dropdown effect. However, before we proceed with styling,
    let's try to be a bit more creative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that our menu links are just that – links. *But what if we wanted to
    be more creative by showing an image with every product menu item?* For this to
    work, we would need to identify which menu items are pointing toward the products,
    which we can do by using the `type` attribute and comparing whether the returned
    value is equal to the `product_link` string. Since we already know that only the
    third level of the navigation contains the product menu items, we will only include
    this feature inside the third `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, it makes sense that this should work and that, as a result, we should be
    able to see four images of our products inside the navigation menu. However, note
    that `sub_sub_link` is still only a `link` object, and the `link` object does
    not have an image attached to it. To show the image that's attached to the product,
    we will have to recover the object of the product that our link is pointing to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily do this by modifying the `sub_sub_link` object inside the `IMG`
    tag so that it includes the `object` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**With the addition of the `object` attribute, we now have access to the entire
    product object, including its title, price, images, and all other data. In comparison,
    `sub_sub_link.object.price` would return precisely the same results as writing
    `product.price` would, which we used in the previous project to display the prices
    of our `Custom collection` products.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do now is provide our code with some HTML format and
    apply the necessary styling. The HTML formatted code, along with some basic CSS
    styling, can be found at the following GitHub link, under the name `Custom navigation`:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20Navigation.
  prefs: []
  type: TYPE_NORMAL
- en: This GitHub repository contains two files, each named according to the location
    where the code should be included.
  prefs: []
  type: TYPE_NORMAL
- en: While working on this project, we were able to create a fundamental version
    of the mega menu, allowing us to output any image attached to our pages easily.
    While it might not look impressive, the knowledge we have learned from this project
    has taught us how to create any navigation menu, as well as a custom subcollections
    page where we can output other collections.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all our projects have been related to recovering the predefined data
    from our admin. *However, what if we needed to capture data regarding the customization
    of a particular product, show the choice on the cart page, and then forward the
    captured data with the order?*
  prefs: []
  type: TYPE_NORMAL
- en: Product customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our next project, we will be creating a custom HTML input on the product
    page, which will allow us to capture any data that the customer may input and
    learn how to forward the value of the input, along with the order itself.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this functionality, we will be using the `line_item` object. `line_item`
    represents each item within our cart. We can access the `line_item` object through
    the `cart` object, followed by the `items` attribute, which will provide us with
    access to the `line_item` object for each product.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use `line_item object` to output the data on our cart page, we
    will need to create a field to capture this data. Let's start by navigating to
    our `product.liquid` template and find the opening tag of the `product` form.
    As we can see, the `product` form tag is not present in this file, but we do have
    a `section` tag, which, as you may recall from the previous chapter, allows us
    to render a static section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by navigating to the `product-template.liquid` section file.
    We can access it by hovering over the section tag''s name and clicking on the
    small arrow. Alternatively, we can find it inside the `Sections` directory. After
    finding the `product` form tag, we can start creating the customization feature
    by adding an HTML input tag of the `text` type, which we will be using to capture
    information related to each specific product. We can add this field at the top
    of the `product` form tag, just above the first `unless` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to preview our product page, we will see an input field with **Your
    Name** as the placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Example of a custom field on the product page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Example of a custom field on the product page
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we fill in the input, add the product to the cart, and visit our
    cart page by clicking the cart icon in the top-right corner, we will notice that
    we did not capture the data successfully with the product. To save the `line_item`
    data value, we will need to modify the HTML input by adding the `name` property
    in `name="properties[Your Name]"` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `name` property is a predefined attribute that allows us to capture the
    `input` element's value, followed by a mandatory keyword, called `properties`,
    and a pair of square brackets. Any value inside these square brackets – in our
    case, **Your Name** – will serve as that property name.
  prefs: []
  type: TYPE_NORMAL
- en: With the `name` attribute in place, if we fill in the input field, click on
    the `line_item` attribute's name and value were successfully captured and chained
    to each product.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with newer themes, such as the one we are using, this would be
    the last step in capturing customization for each product. However, for some older
    themes, which are still quite present today, we would need to write some code
    that will display the `line_item` properties inside the cart page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing this code, we will need to identify where we should add our
    code. As we mentioned previously, to access the `line_item` object, we will need
    to use `cart.items` to recover an array of products in our cart, which should
    already be present in our `cart.liquid` section file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the `cart.items` loop, we have gained access to the objects of each product,
    which, similar to the `product` object, provides us with access to various attributes,
    such as the `product` object's title, price, and the quantity that we have added
    to the cart, as well as its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the properties of each product by using `item` as our object,
    followed by the `properties` attribute. However, since we can capture multiple
    properties for each product, `item.properties` will return an array of data, meaning
    that we will need to use the `for` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `{{ property }}` is considered an array data type since it contains
    both the name of the `line_item` property and its value. If we were to use this
    code to output the `line_item` code on our page, we would end up with both values
    stuck together. Since using another `for` tag to go over the array that contains
    two elements would be excessive, we can use the `first` and `last` filters to
    output the split values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `first` and `last` filters, as their names suggest, allow us to access the
    first and last element inside an array. However, since we are looking to split
    our array into two separate elements, it is perfect as it helps us avoid writing
    another `for` loop. We will learn more about this and other filters in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the same product variant multiple times to the cart with a different
    `line_item` property value will not override the product we previously added to
    the cart, nor affect its `line_item` property value. Instead, we will end up with
    each product positioned on a new line, as if it were a different product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only time when we can include multiple variants of the same product on
    the same line is if the product variant contains the same data, the `line_item`
    property included. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Example of the line item property chained to different product
    variants'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Example of the line item property chained to different product
    variants
  prefs: []
  type: TYPE_NORMAL
- en: If we were to click the `line_item` values were visible inside the checkout
    summary as well. Note that the same `line_item` property will be visible inside
    the order admin if we complete the purchase through our checkout page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: We can only capture the `line_item` properties through Shopify's default checkout.
    If we were to complete the payment through any other checkout, such as `line_item`
    properties to our products, and they will not be visible inside the order admin.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to capture custom data for each of our products
    and display them on the cart and checkout pages. However, sometimes, we will be
    forced to recover the `line_item` data and visually hide it from both the cart
    and checkout pages. We can easily hide the `line_item` data from the cart page
    with some CSS code, *but how are we supposed to modify the code on the checkout
    page, considering that we do not have access to it?*
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the underscore character will help us. If we are looking to collect
    `line_items` and have them visible when we receive the order in our admin, while
    at the same time visually hiding the `line_items` properties from the checkout
    page, we would need to modify the `name` property inside the `product.liquid`
    section file to include the underscore inside the square bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Any property name with the underscore as the first character inside the square
    bracket will not be visible on the checkout page. However, it will still be visible
    once we receive the order in our admin.
  prefs: []
  type: TYPE_NORMAL
- en: Besides allowing us to hide the `line_items` properties from the checkout page
    automatically, the underscore character also helps us create a more automatic
    process for hiding the `line_items` property from the cart page, without having
    to write CSS code for every `line_items` property that we want to hide.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the underscore character, we now have one uniquely
    distinctive character that we can use to filter the `line_items` properties we
    would like to show and which ones we would like to hide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are dealing with string-type data, we can use the `truncate` filter,
    which, as its name suggests, allows us to truncate a string. The `truncate` filter
    accepts the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is a required number value, which allows us to set how many
    characters we expect the `truncate` filter to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is an optional parameter, which allows us to set a specific
    string value we would like to append to each returned string value. Note that
    if we do not include the second parameter, by default, the `truncate` filter will
    append three dots to the end of the string, which will count inside the previous
    parameter number value's `count`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are looking to check whether the `line_items` key value contains the
    underscore character as the first character in the string, we can apply the `truncate`
    filter and set the first parameter to `1`. However, we will also need to include
    the second parameter and set it equal to an empty string to avoid the previously
    mentioned ellipsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that throughout this project, we have only used a single `text` input type.
    However, we are free to use any input type at our disposal, including the `date`,
    `color`, `radio`, and `select` inputs. The only limitation is that we cannot use
    the `file` upload input type with Ajax. The product `form` tag will also need
    to include the `enctype="multipart/form-data`" attribute to capture the file upload
    input value.
  prefs: []
  type: TYPE_NORMAL
- en: With this project, we have learned how to create a valuable feature that will
    allow us to create specific customization for each product template, or even each
    product separately. We can design it as a simple feature with a single input or
    create an entire form with various inputs to fill in before purchasing a product.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `line_items` easily and simply paste them inside our product
    templates. We can find the Shopify UI Elements generator at https://ui-elements-generator.myshopify.com/pages/line-item-property.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we were looking to save page-specific data for some of the pages
    in our admin. However, if we were to navigate to our admin and open a product,
    collection, or any other page, we would notice that each page contains a predefined
    number of fields to store data. This is where the metafields objects come to the
    rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the workflow with metafields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Metafields** are global objects that allow us to store additional data inside
    our admin and output it to the storefront. As such, they are both powerful and
    necessary tools for creating complex designs with unique content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Metafields consist of three mandatory elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The **namespace**, which we can use to group different metafields, so long as
    they share the same namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` attribute, which allows us to access a specific metafield.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `json_string` data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use a `description` field for the short description of a metafield,
    which is optional compared to the previous three.
  prefs: []
  type: TYPE_NORMAL
- en: Metafields, while powerful tools, had quite a disadvantage as they were only
    available through third-party apps. However, since the Shopify Unite 2021 event,
    the metafields functionality has become available natively inside the Shopify
    dashboard, and not only that, but it has received quite the upgrade!
  prefs: []
  type: TYPE_NORMAL
- en: The `metafields` functionality, while functional, at the time of writing, is
    only partially available as we can only access the product and variant metafields.
    The `page`, `blog`, `article`, `collection`, `order`, `customer`, and `shop` metafields
    are pending to be released. For this reason, we will learn how to handle these
    metafields through a third-party app and the Shopify dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that most of today's themes still rely on third-party apps for their
    metafields needs, let's start by learning how to utilize a metafields app to create
    custom content for our pages.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a metafields app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For us to use and access metafields objects, we will need to either install
    an app or a browser extension that allows us to use this functionality. For this
    book''s purposes, we will proceed by installing an app so that we can familiarize
    ourselves with that Shopify app market as well:'
  prefs: []
  type: TYPE_NORMAL
- en: To install an app on our store, we need to navigate to our admin and click on
    **Apps**, just above **Sales Channels**. Inside the **Apps** section, we will
    be able to see a list of all the apps that we have installed on our store. However,
    as we currently do not have any, the list is empty. Let's change this by clicking
    on the **Shop for apps** button in the top-right corner:![Figure 4.7 – Example
    of starting the app install process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.7 – Example of starting the app install process
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking the `metafields` inside the search field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After submitting a search, we will receive a significant number of apps that
    we can use, and most of them have a free plan available. For our purposes, we
    will be using the **Metafields Guru** app. While which app you choose is entirely
    optional, since they all offer the same functionality, we advise you to use the
    same app here as it will be easier to follow up with future development. Upon
    clicking on the app, you will be redirected to the app window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After opening the app's landing page, we will be able to see more information
    about the page, which we should always read to check whether the app offers the
    features that we need. Let's click on the **Add app** button, which should immediately
    redirect us to our store and start the app installation process. On the other
    hand, if we are not, we will need to log in by submitting a store URL inside the
    popup window and clicking on the **Log in** button, which will start the app installation
    process:![Figure 4.8 – Example of the login popup on the Shopify app store
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.08_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.8 – Example of the login popup on the Shopify app store
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After starting the installation process, we will see one last window, where
    we will need to provide the app with requested access to our store. Since we are
    working on a development store, we can immediately proceed by clicking on the
    **Install app** button. However, if we are working on a managed store for a client,
    it is strongly advised that we never install the app on someone else's store,
    even if they have asked us to do so. The store owner should be the one to install
    any necessary app once they know about all the personal information that the app
    will be collecting. Otherwise, we might be accountable for any possible problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the **Metafields Guru** app now installed, we will see the first view
    within the app, where we can see all the different types of pages we can create
    metafields for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Different types of pages we can use metafields objects for'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.09_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Different types of pages we can use metafields objects for
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, metafields are powerful tools that allow
    us to customize any section of our store. So, let''s begin by creating the metafield
    for a product page:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is navigate to the **Product** section of our
    admin, select any product of our choosing, and click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After opening the product page, click on the **More actions** button in the
    top-right corner to reveal the **Edit Metafields** button. Click on it to launch
    the **Metafields Guru** app:![Figure 4.10 – Example of starting the Metafield
    Guru app for a specific page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.10 – Example of starting the Metafield Guru app for a specific page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once inside the app, we will be able to see a list of all the metafields that
    we have for this specific product, or even the variant if we select the **Variants**
    card. However, since we don't have any, the screen is empty. Let's create our
    first metafield by clicking the **Create metafield** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this first field, we can select the data type that we will save inside
    this specific metafield. This is where we will be populating the other three fields
    with the `key`, `namespace`, and `metafield` values. We can leave the `String`
    value selected for our example and then, inside the `key` field, type in the word
    `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `namespace` field already contains the `global` keyword, but we can enter
    any type of text in the final field. For example, we will use `Metafields are
    awesome!`. After filling in all the fields, save your changes by clicking the
    **Save** button in the top-right corner:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Example of creating a product metafield'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Example of creating a product metafield
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to create a metafield, it is time to learn how
    to output the previously saved data to our storefront.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the metafields value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can access the `metafields` object through the object of the page we created
    the metafield for, followed by the `metafields` object, followed by `namespace`,
    followed by `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can enter the metafield code anywhere where we have access to the `product`
    object. However, for our purposes, we should place the code inside the `product.liquid`
    section, just above the `line_item` input that we included in one of our previous
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the product metafield and have the metafield object
    code in place, all we need to do is test it out. However, remember that we have
    created a metafield for a specific product only, meaning that we can only preview
    it on that specific product. If we were to preview the product we created the
    metafield for, we would see the following metafield string value displayed correctly
    on our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have successfully created and displayed a single metafield value.
    However, *what if we had a larger number of similar metafields? How would we output
    all of them?* We initially mentioned that we could use the `namespace` attribute
    to different group metafields together, so long as they share the same `namespace`.
    Using `namespace` with the `for` tag, we can loop over all the metafields with
    the same `namespace` and recover their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code would recover any metafields with the `global` keyword
    as its namespace. However, since we are not using the `key` attribute this time,
    we will receive the results in array format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To split the array, we will need to use the `first` and `last` filters, as
    we did previously, to split the `line_item` object on the cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using the `first` and `last` filters, we have successfully split the array into
    two separate elements that we can now use in any way we require.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have taken a significant step forward by learning how to output
    single and multiple metafield values through a third-party app.
  prefs: []
  type: TYPE_NORMAL
- en: While helpful, adding metafields through a third-party app requires quite a
    bit of hardcoding, which we can avoid by creating metafields through the Shopify
    dashboard instead. However, while metafields have received a powerful upgrade,
    they also have a prerequisite, which we learned about previously. For this reason,
    we will learn how to set up and handle metafields through the Shopify dashboard
    in the following chapters to gain a better understanding of this.
  prefs: []
  type: TYPE_NORMAL
- en: Using metafields, we can now add well-organized, unique content to each page
    or even create complex functionalities. For example, with metafields, we can create
    product accordions, show hand-picked recommended products, and use them to show
    the expected delivery time for each product/variant and other features. We are
    only limited by our inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: The few projects that we have covered by now might look inadequate compared
    to the number of different types of global objects we have at our disposal. However,
    the knowledge we have attained through these projects has set us on the right
    path of understanding objects entirely. Our primary focus was not simply listing
    objects and their attributes, which we can quickly get from Shopify documentation,
    but learning how to use different objects and attributes through real-life projects
    that we will be working on tomorrow as Shopify experts.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can say that we understand how objects work, we will need to learn
    more about content objects, without which we would not be able to output any content
    on our pages.
  prefs: []
  type: TYPE_NORMAL
- en: Content and special objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we learned how to use global objects to output the data from our
    admin on our templates and section files. Now, it is time to learn how to use
    content objects to output the content of template and sections files, as well
    as any other assets that are necessary for the Shopify store to operate. We can
    divide the content objects into three separate groups: `content_for_header`, `content_for_index`,
    and `content_for_layout`.'
  prefs: []
  type: TYPE_NORMAL
- en: All three types of content objects have descriptive names that tell us what
    they do. However, to ensure that we fully understand their importance, we will
    provide a small explanation for each.
  prefs: []
  type: TYPE_NORMAL
- en: The content_for_header object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`content_for_header` is a mandatory object located inside the `theme.liquid`
    layout file – more specifically, inside the HTML `<head>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The whole purpose of this object is to load all the scripts that Shopify requires
    into the document's header dynamically. Among these scripts, we can find Shopify
    and Google Analytics scripts, and even the scripts required for some Shopify apps.
  prefs: []
  type: TYPE_NORMAL
- en: The content_for_index object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`content_for_index` is a not mandatory object and it''s located within the
    `index.liquid` template, which we can find inside the `Template` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, this object allows us to dynamically output dynamic sections from the
    theme editor, making it mandatory. Without it, we would not be able to output
    any content from our theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: The content_for_layout object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`content_for_layout` is the final mandatory object located inside the `theme.liquid`
    layout file. This object allows us to load content that''s been dynamically generated
    by other templates, such as `index.liquid` and `collection.liquid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is not possible to delete the `content_for_header` and `content_for_layout`
    objects from their respective positions, so we don't need to worry too much about
    them. However, it is essential to know what each of the content objects does since
    even though we cannot delete them, we can comment them out, which will create
    issues with our storefront.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, besides global and content objects, we also have another set of objects
    that we can only use under specific circumstances. The only two objects we currently
    have at our disposal are the `additional_checkout_buttons` and `content_for_additional_checkout_buttons`
    objects, which will provide us with a way to dynamically generate a set of buttons
    leading to a third-party provider's checkout page.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that deciding which buttons will be visible depends on the payment
    methods that we have set in the admin, as well as some other parameters. For example,
    for the **Apple Pay** checkout button to be visible, besides enabling the payment
    method in the admin, the customer will also have to use an Apple device to see
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The `additional_checkout_buttons` object allows us to check whether the store
    offers payment using third-party payment providers, such as PayPal, Apple, and
    others. Suppose we have enabled a payment gateway to some third-party payment
    providers. The `additional_checkout_buttons` object, in combination with an `if`
    statement, will return `true`, which will allow us to use our next special object;
    that is, `content_for_additional_checkout_buttons`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After confirming that we have enabled these payment methods with third parties,
    we can use the `content_for_additional_checkout_buttons` object to generate the
    buttons for those payment providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While the placement of the code is entirely optional, it is usually placed on
    the cart page, next to the default **Checkout** button.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different types of objects while considering
    various projects. Within our first project, `Custom collection`, we learned how
    to access single-valued attributes within the `product` object by creating a custom
    collection feature with a fully functional product form. The second project, `Custom
    navigation`, taught us how to access and handle objects whose attributes return
    an array. Working through the `Product Customization` project, we understood how
    to capture multiple data types, chain them with the selected variant, and output
    the same data on both the cart and checkout pages.
  prefs: []
  type: TYPE_NORMAL
- en: Besides working on different projects, we also had the pleasure of learning
    how to install new apps from the store and how to use a third-party app to create
    additional input fields within our admin, which gave us access to `metafields`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the different types of content and special objects,
    why some are mandatory, where we can find them, and how we can use some of them
    to connect our store to various payment providers outside Shopify.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge that we have attained through this chapter will be especially
    helpful in the next chapter, where we will learn more about the filters that we
    have been referencing through our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are we missing in the following block of code to make `form` functional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can we get access to the `product` object through a link defined in the
    admin navigation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two approaches to accessing single and multiple `metafield` objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What adjustment do we need to make to the input element if we were looking to
    capture the `line_item` value and hide it on the checkout page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Practice makes perfect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we worked together through various projects and implementations.
    However, we can only gain a proper understanding by working on the projects ourselves
    and forcing ourselves to make that next step. So far, we haven't completed any
    personal projects as we were still learning the basics. However, with objects
    behind us, we are now set to start creating our own solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The few mini-projects we will cover here will help us solidify some of our already
    attained knowledge from the previous chapters. It will also push our limits by
    forcing us to think outside of the box and find solutions for the problems that
    we haven't faced so far.
  prefs: []
  type: TYPE_NORMAL
- en: Each project will contain detailed information about what we need to do to help
    us achieve the results.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend working on each project independently from the previous chapters
    since this will ensure that we have truly understood what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: No single project has either a correct or incorrect solution. However, if by
    any chance we get stuck, we can always consult the project solution at the end
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Project 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our first project, we will be creating a custom collection on a general
    page. However, the difference between this project and the one we worked on previously
    is that this custom collection will be a dynamic and reusable code block. Depending
    on the page name, we should see different products in the featured collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new page template called `featured-collection.liquid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new page, name it similarly to one of the collection pages on our store,
    and assign it the new page template that we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the new menu item inside the current main menu navigation, called `Projects`,
    and add the newly created page as a nested menu inside the `Projects` menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new snippet file named `custom-collection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the assignment steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `custom-collection` snippet inside `featured-collection.liquid`
    with `collection` as a parameter. Since the page shares a name that's similar
    to our collections', we should use the page handle to create the `collection`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `collection` object that we passed previously, create a custom collection
    using the `for` tag to display no more than four products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The products should contain an image, title, vendor, regular price, comparing
    price visible, and a working product form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a product has more than one variant, include a dropdown so that we can select
    the exact variant we are looking to select.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After submitting the form, return us to the same page we were previously on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once complete, any page with `featured-collection.liquid` assigned as its template
    should display different types of products based on the page name; for example,
    Indoor or Outdoor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our second project, we will be creating a subcollection template page where
    we will be able to output different collection pages. The code that we will create,
    similar to the previous project, should be reusable. We should receive different
    results based on the name of the page we have assigned the template to, and the
    collections that have been assigned to the navigation menu with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new page template called `page-subcollection.liquid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new page and assign it to the new page template that we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the new navigation menu and give it the same name we gave the page that
    we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new navigation menu, include no less than six collection menu items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new snippet file called `custom-subcollection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the assignment steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `custom-subcollection` snippet inside `page-subcollection.liquid`
    with `subcollection` as a parameter. Since the page shares a name that's similar
    to our navigation menu, we should use the page handle to create the `subcollection`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `subcollection` object that we passed previously, use a `for` tag
    to create a list of all the collection pages inside the specific navigation menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The collection list should contain an image and a title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the collection does not have the image assigned to it, we should take the
    image of the first product inside that collection and show it as the collection
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once complete, any page with `custom-subcollection.liquid` assigned as its template
    should display different results based on its name, as well as the collection
    that was assigned to the navigation menu with the same name.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
