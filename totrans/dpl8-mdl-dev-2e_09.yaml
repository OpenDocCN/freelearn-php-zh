- en: Custom Fields
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义字段
- en: In [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entities and Plugin Types,* we talked quite extensively about content entities
    and how they use fields to store the actual data that they are supposed to represent.
    Then, we saw how these fields, apart from interacting with the storage layer for
    persisting it, extend Typed Data API classes in order to organize this data better
    at the code level. For example, we saw that the `BaseFieldDefinition` instances
    used on entities are actually data definitions (and so are the `FieldConfig` ones).
    Moreover, we also saw the DataType plugins at play there, namely the `FieldItemList`
    with their individual items, which down the line extend a basic DataType plugin
    (`Map` in most cases). Also, if you remember, when we were talking about these
    items, I mentioned how they are actually instances of yet another plugin—`FieldType`.
    So essentially, they are a plugin type whose plugins extend plugins of another
    type. I recommend that you revisit that section if you are fuzzy on the matter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)《数据建模和存储》和[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)《您的自定义实体和插件类型》中，我们广泛地讨论了内容实体以及它们如何使用字段来存储它们应该表示的实际数据。然后，我们看到了这些字段如何除了与存储层交互以持久化数据之外，还扩展了Typed
    Data API类，以便在代码级别更好地组织这些数据。例如，我们看到了在实体上使用的`BaseFieldDefinition`实例实际上是数据定义（`FieldConfig`也是）。此外，我们还看到了起作用的DataType插件，即`FieldItemList`及其各自的项，这些项最终扩展了一个基本的DataType插件（在大多数情况下是`Map`）。此外，如果你还记得，当我们讨论这些项时，我提到了它们实际上是另一种插件的实例——`FieldType`。所以本质上，它们是一种插件类型，其插件扩展了另一种类型的插件。我建议如果你对此事不太清楚，请重新阅读那一节。
- en: Most of these concepts are buried inside the Entity API and are only seen and
    understood by developers. However, the `FieldType` plugins (together with their
    corresponding `FieldWidget` and `FieldFormatter` plugins) break out and are one
    of the principal things site builders and content editors actually work with in
    the UI. They allow users to input structured data and save it to the database.
    If you recall, I mentioned them a few times in Chapters 6 and 7, and I promised
    you a chapter in which we will see how we can create field types that a site builder
    can then add to an entity type and use to input data. Well, this is that chapter,
    but first, let's do a quick recap on what we know about them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念中的大多数都隐藏在实体API内部，只有开发人员才能看到和理解。然而，`FieldType`插件（以及它们对应的`FieldWidget`和`FieldFormatter`插件）脱颖而出，是网站构建者和内容编辑人员在UI中实际操作的主要事物之一。它们允许用户输入结构化数据并将其保存到数据库中。如果你还记得，我在第6章和第7章中提到了它们几次，并承诺会有一章介绍我们如何创建网站构建者可以添加到实体类型并用于输入数据的字段类型。好吧，这就是那一章，但首先，让我们快速回顾一下我们对它们的了解。
- en: A recap of Field type plugins
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段类型插件回顾
- en: Field type plugins extend the lower-level TypedData API to create a unique way
    of not only representing data (within the context of entities), but also storing
    it to the database (and other stuff as well). They are primarily known as the
    type of fields site builders can add to an entity type bundle. For example a plain
    text field or a select list with multiple options. Nothing can be more common
    than that in a CMS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 字段类型插件扩展了低级别的TypedData API，以创建一种独特的方式，不仅表示数据（在实体的上下文中），而且将其存储到数据库中（以及其他一些内容）。它们主要被用作网站构建者可以添加到实体类型包中的字段类型。例如，一个纯文本字段或具有多个选项的选择列表。在CMS中，没有什么比这更常见了。
- en: 'However, they are also used as entity base field types. If you remember our
    product entity type''s `name` field definition, we actually did use these plugin
    types:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们也被用作实体基本字段类型。如果你还记得我们的产品实体类型的`name`字段定义，我们实际上确实使用了这些插件类型：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `create()` method of the definition class accepts a `FieldType` plugin ID.
    Also, the `type` of the `view` display option provided a bit below in the code
    is a `FieldFormatter` plugin ID, whereas the `type` of the `form` display option
    provided even lower in the code is a `FieldWidget` plugin ID.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的`create()`方法接受一个`FieldType`插件ID。此外，下面代码中提供的`view`显示选项的`type`是一个`FieldFormatter`插件ID，而下面代码中提供的`form`显示选项的`type`是一个`FieldWidget`插件ID。
- en: 'A crucial lesson from this recap that I insist you retain: when defining your
    custom entities, think about the types of fields you need. If there are bundles
    that need to have different sets of fields, configurable fields are your choice.
    Otherwise, base fields are perhaps more appropriate. They sit tightly with your
    Entity type class, appear on all bundles (if that''s something you need), and
    encourage you to explore the Drupal code base and understand the existing field
    types, widgets, and formatters better (as well as relevant settings they come
    with).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Also, when you define base fields, think the same way as you would if adding
    them through the UI—which field type do I want (find a `FieldType` plugin), how
    do I want users to interact with it (find a `FieldWidget` plugin), and how do
    I want its values to be shown (find a `FieldFormatter` plugin). Then, inspect
    the relevant classes to determine the right settings that will go with them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at how we can create our own custom field
    type with its own default widget and formatter. To provide a bit of continuity,
    I am going to ask you to think back to the more complex example we used when talking
    about the TypedData API—the license plate. We will create a field type designed
    specifically to store license plates in the following format: *CODE NUMBER* (just
    as we saw with the example New York plate). Why?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, there is no field type that can represent this accurately. Of
    course, we have the simple text field, but that implies having to add both pieces
    of data that make up a license plate into the same field, stripping them of its
    meaning. When we were discussing the TypedData API, we saw that one of its core
    principles is the ability to apply meaning to a piece of data so as to understand
    that `$license_plate` (for example) is actually a license plate from which we
    can ask its code and its number (as well as a general description if we want to).
    Similar to this (or actually building on top of this), fields are also about storing
    this data. So, apart from understanding it in code, we also need to persist it
    in the same way. That is, placing the individual pieces of data in separate meaningful
    table columns in order to also persist that meaning.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: An example from Drupal core that does the same thing is the `Text (formatted)`
    field. Apart from its string value, this field also stores a format for each value,
    which is used upon rendering. Without that format, the string value loses its
    meaning, and Drupal is no longer able to reliably render it in the way it was
    intended upon creation. So you can now see that fields take the idea of *meaning*
    from TypedData and also apply it to storage as needed. So, in this chapter, you
    will learn how these three types of plugin work by creating your own license plate
    type field. Let's get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Field type
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary plugin type for creating a field is, as we discussed, the `FieldType`.
    It is responsible for defining the field structure, how it is stored in the database,
    and various other settings. Moreover, it also defines a default widget and formatter
    plugin that will be autoselected when we create the field in the UI. You see,
    a single field type can work with more than one widget and formatter. If more
    exist, the site builder can choose one when creating the field and adding it to
    an entity type bundle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字段的主要插件类型，正如我们讨论的那样，是 `FieldType`。它负责定义字段结构、如何在数据库中存储以及各种其他设置。此外，它还定义了一个默认的
    widget 和 formatter 插件，当我们在 UI 中创建字段时将自动选择。您可以看到，单个字段类型可以与多个 widget 和 formatter
    一起工作。如果存在更多，网站构建者可以在创建字段并将其添加到实体类型包时选择一个。
- en: Otherwise, it will be the default; each field needs one because without a widget,
    users can't add data, and without a formatter, they can't see it. Also, as you'd
    expect, widgets and formatters can also work with more than one field type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将是默认的；每个字段都需要一个，因为没有 widget，用户无法添加数据，没有 formatter，他们无法看到数据。同样，如您所预期的那样，widgets
    和 formatters 也可以与多个字段类型一起工作。
- en: 'The field we will create in this section is for the license plate data, which
    as we saw, needs two individual pieces of information: a code (such as the state
    code) and the number. License plates around the world are more complex than this,
    but I chose this example to keep things simple.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的字段是用于车牌数据的，正如我们所看到的，它需要两个独立的信息片段：一个代码（例如州代码）和一个数字。世界各地的车牌比这更复杂，但我选择这个例子是为了保持简单。
- en: 'Our new `FieldType` plugin needs to go inside the `Plugin/Field/FieldType`
    namespace of a new module we will create called `license_plate`. Although not
    mandatory, the class name should end with the word `Item`. It''s a pretty standard
    thing in Drupal core, and we will follow suit. So, let''s take a look at our `LicensePlateItem`
    plugin implementation and then talk about the code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新开发的 `FieldType` 插件需要放置在我们即将创建的新模块 `license_plate` 的 `Plugin/Field/FieldType`
    命名空间内。虽然这不是强制性的，但类的名称应该以单词 `Item` 结尾。这在 Drupal 核心中是一个相当标准的事情，我们将遵循这一做法。因此，让我们来看看我们的
    `LicensePlateItem` 插件实现，然后讨论代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I omitted the class contents, as we will be adding the methods one by one and
    discussing them individually. However, first, we have the plugin annotation, which
    is very important. We have the typical plugin metadata such as the ID, label,
    and description, as well as the plugin IDs for the widget and formatter that will
    be used by default with this field type. Make a note of those, because we will
    create them soon.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了类的内容，因为我们将会逐个添加方法并分别讨论。然而，首先，我们有插件注释，这非常重要。我们有了典型的插件元数据，如 ID、标签和描述，以及默认情况下将与该字段类型一起使用的
    widget 和 formatter 插件的插件 ID。请记住这些，因为我们很快就会创建它们。
- en: Speaking from experience, often, when creating a field type, you'll extend the
    class of an already existing field type plugin, such as a text field or an entity
    reference. This is because Drupal core already comes with a great set of available
    types and usually all you need is to either make some tweaks to an existing one,
    maybe combine them or add an extra functionality. This makes things easier, and
    you don't have to copy and paste code or come up with it again yourself. Naturally,
    though, at some point, you'll be extending from `FieldItemBase` because that is
    the base class all field types need to extend from.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从经验来看，在创建字段类型时，通常会扩展一个已经存在的字段类型插件类，例如文本字段或实体引用。这是因为 Drupal 核心已经提供了一套很好的可用类型，通常你只需要对现有的一种类型进行一些调整，也许将它们组合起来或添加额外的功能。这使得事情变得更容易，你不必复制粘贴代码或自己再次想出它。然而，自然地，在某个时候，你将需要从
    `FieldItemBase` 扩展，因为这是所有字段类型都需要扩展的基类。
- en: In our example, however, we will extend straight from the `FieldItemBase` abstract
    class because we want our field to stand on its own. Also, it's not super practical
    to extend from any existing ones in this case. That is not to say, though, that
    it doesn't have commonalities with other field types, such as `TextItem`, for
    example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，我们将直接从 `FieldItemBase` 抽象类扩展，因为我们希望我们的字段能够独立存在。此外，在这种情况下从任何现有的类扩展并不十分实用。但这并不意味着它与其他字段类型没有共性，例如
    `TextItem`。
- en: 'Let''s now take a look at the first method in our class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们类中的第一个方法：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we do in our class is override the `defaultStorageSettings()`
    method. The parent class method returns an empty array; however, it's still a
    good idea to include whatever it returns to our own array. If the parent method
    changes and returns something later on, we are a bit more robust.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中，我们首先重写 `defaultStorageSettings()` 方法。父类方法返回一个空数组；然而，将父类方法返回的内容包含到我们自己的数组中仍然是一个好主意。如果父类方法在以后更改并返回某些内容，我们就会更加健壮。
- en: 'The purpose of this method is two-fold: specifying what storage settings this
    field has and setting some defaults for them. Also, note that it is a static method,
    which means that we are not inside the plugin instance. However, what are storage
    settings, you may ask?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的目的有两个：指定这个字段有哪些存储设置，并为它们设置一些默认值。此外，请注意，这是一个静态方法，这意味着我们不在插件实例内部。然而，你可能想知道什么是存储设置？
- en: Storage settings are the configuration that applies to the field everywhere
    it's used. As you know, a field can be added to multiple bundles of an entity
    type. In Drupal 7, you could reuse a field even across entity types, but this
    is no longer possible as fields are now reusable only on the bundles of a single
    entity type. You'll need to create another field of that type if you need it on
    some other content entity type. So the storage settings are those that apply to
    this field across each bundle it is attached to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储设置是应用于字段在其使用的任何地方的配置。正如你所知，一个字段可以被添加到实体类型的多个捆绑包中。在Drupal 7中，你可以跨实体类型重用字段，但现在这不再可能，因为字段现在只能在单个实体类型的捆绑包中重用。如果你需要在其他内容实体类型上使用它，你需要创建另一个该类型的字段。因此，存储设置是应用于这个字段在其附加的每个捆绑包中的那些设置。
- en: They usually deal with things related to the schema—how the database table columns
    are constructed for this field—but they also deal with a lot of other things.
    Also, even more important to know is that once there is data in the field tables,
    they cannot be changed. It makes sense as you cannot easily change database tables
    when there is data in them. This restriction is something we enforce, as we will
    see in a bit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常处理与架构相关的事情——如何为该字段构建数据库表列——但它们也处理许多其他事情。更重要的是，要知道一旦字段表中有了数据，它们就不能更改。当你无法轻松更改包含数据的数据库表时，这很有意义。这种限制是我们强制执行的，正如我们稍后将看到的那样。
- en: 'In our example, we only have two storage settings: `number_max_length` and
    `code_max_length`. These will be used when defining the schema for the two table
    columns where the license plate data will be stored (as the maximum length that
    can be stored in those table fields). By default, we will go with the ever-so-used
    255 character maximum length on the number column and 5 for the code column, but
    these are just defaults. The user will be able to change them when creating the
    field or when editing, as long as there is no data yet.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只有两个存储设置：`number_max_length` 和 `code_max_length`。这些设置将在定义存储车牌数据的两个表列的架构时使用（作为那些表字段可以存储的最大长度）。默认情况下，我们将使用在数字列上常用的255个字符的最大长度，以及代码列的5个字符，但这些只是默认值。用户在创建字段或编辑时可以更改它们，只要还没有数据。
- en: 'Next, we can write our storage settings form which allows users to provide
    the actual settings when creating a field:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编写我们的存储设置表单，允许用户在创建字段时提供实际设置：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is called by the main field configuration form and we need to return
    an array of form elements that can be used to set values to the storage settings
    we defined earlier. We have access to the main `$form` and `$form_state` of the
    form where this is embedded, as well as a handy Boolean `$has_data` which tells
    us whether there is already any data in this field. We use this to disable the
    elements we don't want to be changed if there is data in the field (in our case,
    both).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法由主字段配置表单调用，我们需要返回一个表单元素数组，可以用来设置我们之前定义的存储设置值。我们有权访问嵌入此表单的 `$form` 和 `$form_state`
    的主要部分，以及一个方便的布尔值 `$has_data`，它告诉我们这个字段中是否已经有数据。我们使用这个布尔值来禁用如果字段中有数据我们不希望更改的元素（在我们的例子中，是两个）。
- en: So basically, our form consists of two number form elements (both required),
    whose values default to the lengths we specified earlier. The `number` form element
    also comes with `#min` and `#max` properties, which we can use to restrict the
    number to a range. Also, we obviously want our minimum lengths to be a positive
    number, that is, above 1\. This method is relatively straightforward to understand
    if you get the basics of the Form API, which you should by now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们的表单由两个数字表单元素组成（都是必填项），其值默认为我们之前指定的长度。`number`表单元素还带有`#min`和`#max`属性，我们可以使用这些属性来限制数字的范围。显然，我们希望我们的最小长度是一个正数，即大于1。如果你现在已经掌握了表单API的基础，这个方法相对容易理解。
- en: 'Finally, for our storage handling, we will need to implement the schema method
    and define our table columns:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的存储处理，我们需要实现模式方法并定义我们的表列：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is another static method, but one that receives the current field's `FieldStorageDefinitionInterface`
    instance. From there, we can access the settings the user has saved when creating
    the field, and based on those, we define our schema. If you were paying attention
    in the previous chapter when we discussed `hook_schema()`, this should already
    be clear to you. What we need to return is an array of column definitions keyed
    by their name. So we define two columns of the `varchar` type with the maximum
    lengths the user has configured. Of course, we could have had more storage settings
    and made this schema definition even more configurable if we wanted to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态方法，但它接收当前字段的`FieldStorageDefinitionInterface`实例。从那里，我们可以访问用户在创建字段时保存的设置，并根据这些设置定义我们的模式。如果你在上一章讨论`hook_schema()`时注意到了，这应该对你来说已经很清晰了。我们需要返回的是一个按名称键控的列定义数组。因此，我们定义了两个`varchar`类型的列，其最大长度与用户配置的长度相同。当然，如果我们想有更多的存储设置，并使这个模式定义更加可配置，我们也可以做到。
- en: With these three methods our storage handling is complete; however, our field
    type is not quite so. We still have a couple more things to take care of.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个方法，我们的存储处理就完成了；然而，我们的字段类型还没有完成。我们还有几件事情要处理。
- en: 'Apart from storage, as we discussed, fields also deal with data representation
    at the code level with TypedData structures. So our field type needs to define
    its individual properties for which we create storage. For this we have two main
    methods: first, to actually define the properties, and then to set some potential
    constraints on them:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储之外，正如我们讨论的，字段还通过TypedData结构在代码级别处理数据表示。因此，我们的字段类型需要定义其单个属性，为这些属性创建存储。为此，我们有两个主要方法：首先，实际定义属性，然后对它们设置一些潜在的约束：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code will look very familiar to the one in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage,* when we talked about TypedData. Again, this is a
    static method that needs to return the `DataDefinitionInterface` instance for
    the individual properties. We choose to call them `number` and `code`, respectively,
    and set some sensible labels—nothing too complicated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)中的代码非常相似，*数据建模与存储*，我们在讨论TypedData时提到了。再次强调，这是一个静态方法，需要为单个属性返回`DataDefinitionInterface`实例。我们选择分别称它们为`number`和`code`，并设置一些合理的标签——不会太复杂。
- en: 'The previous code is actually enough to define the properties, but if you remember,
    our storage has some maximum lengths in place, meaning that the table columns
    are only so long. So, if the data that gets into our field is longer, the database
    engine will throw a fit in a not-so-graceful way. In other words, it will throw
    a big exception, and we can''t have that. So, there are two things we can do to
    prevent that: put the same maximum length on the form widget to prevent users
    from inputting more than they should and add a constraint on our data definitions.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实际上足以定义属性，但如果你还记得，我们的存储有一些最大长度限制，这意味着表列的长度是有限的。因此，如果进入我们字段的数据过长，数据库引擎将以不太优雅的方式抛出异常。换句话说，它会抛出一个大异常，我们无法接受这种情况。所以，为了防止这种情况，我们可以做两件事：在表单小部件上设置相同的最大长度，以防止用户输入过多的内容，并在我们的数据定义上添加约束。
- en: The second one is more important because it ensures that the data is valid in
    any case, whereas the first one only deals with forms. However, since Drupal 8
    is so much more API-oriented than its previous version, if we create an entity
    programmatically and set its field values, we bypass forms completely. However,
    not to worry; we will also take care of the form, so our users can have a nicer
    experience and are aware of the maximum size of the values they need to input.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the following constraints:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since our field class actually implements the `TypedDataInterface`, it also
    has to implement the `getConstraints()` method (which the `TypedData` parent already
    starts up). However, we can override it and provide our own constraints based
    on our field values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We are taking a slightly different approach here from adding constraints to
    what we saw in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data
    Modeling and Storage*. Instead of adding them straight to the data definitions,
    we will create them manually using the validation constraint manager (which is
    the plugin manager of the `Constraint` plugin type we saw in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*). This is because fields use a specific `ComplexDataConstraint`
    plugin that can combine the constraints of multiple properties (data definitions).
    Do note that even if we had only one property in this field, we'd still be using
    this constraint plugin.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: There aren't many types of class in Drupal 8 in which you cannot inject dependencies,
    but `FieldType` plugins are one of them. This is because these plugins are actually
    built on top of the `Map` TypedData plugin, and their manager doesn't use a container-aware
    factory for instantiation but instead delegates it to the `TypedDataManger` service,
    which, as we saw, is not container-aware either. For this reason, we have to request
    the services we need statically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The data needed to create this constraint plugin is a multidimensional array
    keyed by the property name which contains constraint definitions for each of them.
    So, we have a `Length` constraint for both properties, whose options denote a
    maximum length and a corresponding message if that length is exceeded. If we wanted,
    we could have had a minimum length in the same way as well: `min` and `minMessage`.
    As for the actual length, we will use the values chosen by the user when creating
    the field (the storage maximum). Now, regardless of the form widget, our field
    will not validate unless the maximum lengths are respected.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to finish this class with the following two methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With `generateSampleValue()`, we create some random words that fit within our
    field. That's it. This can be used when profiling or site building to populate
    the field with demo values. Arguably, this is not going to be your top priority,
    but it is good to know.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `isEmpty()` method which is used to determine whether the
    field has values or not. It may seem pretty obvious, but it's an important method,
    especially for us, and you can probably deduce from the implementation why. When
    creating the field in the UI, the user can specify whether it's required or not.
    However, typically, that applies (or should apply) to the entire set of values
    within the field. Also, if the field is not required, and the user only inputs
    a license plate code without a number, what kind of useful value is that to save?
    So, we want to make sure that both of them have something before even considering
    this field as having a value (not being empty), and that is what we are checking
    in this method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we started writing the class, we made references to a bunch of classes
    that we should *use* at the top before moving on:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we are finished with the actual plugin class, there is one last thing
    that we need to take care of, something that we tend to forget, myself included:
    the configuration schema. Our new field is a configurable field whose settings
    are stored. Guess where? In configuration. Also, as you may remember, all configuration
    needs to be defined by a schema. Drupal already takes care of those storage settings
    that come from the parent. However, we need to include ours. So, let''s create
    the typical `license_plate.schema.yml` (inside `config/schema`), where we will
    put all the schema definitions we need in this module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The actual definition will already be familiar, so the only thing that is interesting
    to explain is its actual naming. The pattern is `field.storage_settings.[field_type_plugin_id]`.
    Drupal will dynamically read the schema and apply it to the settings of the actual
    `FieldStorageConfig` entity being exported.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for our `FieldType` plugin. When creating a new field of this type,
    we have the two storage settings we can configure (which will be disabled when
    editing if there is actual field data already in the database):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96367f4d-d73b-4516-be18-f188d8f002e6.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Unless we work only programmatically or via an API to manage the entities that
    use this field, it won't really be useful, as there are no widgets or formatters
    it can work with. So, we will need to create those as well. As a matter of fact,
    before we can create a field of this type, we need to ensure we have the widget
    and formatter plugins as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Field widget
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our new license plate field type could be added to an entity type, but there
    would be no way users could use it. For this, we will need at least a widget.
    A given field type can work, however, with multiple widgets. So, let''s create
    that default license plate widget plugin we referenced in the annotation of the
    field type, which belongs in the `Plugin/Field/FieldWidget` namespace of our module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we started by examining the annotation and class parents for just a bit.
    You will notice nothing particularly complicated, except maybe the `field_types`
    key, which specifies the `FieldType` plugin IDs this widget can work with. Just
    as a field type can have more than one widget, a widget can work with more than
    one field type. Also, it's important that we specify it here, otherwise site builders
    won't be able to use this widget with our license plate field type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We extended `WidgetBase` which implements the obligatory `WidgetInterface` and
    provides some common defaults for all its subclasses.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we can do inside the class is handle our settings. First, we
    will define what settings this widget has and set the default values for these
    settings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have some settings specific to how the form widget would be configured for
    our field. We will use the first two settings mentioned in the previous code to
    limit the size of the form element. It will not actually prevent users from filling
    in longer values, but will be a good indication for them as to how long the values
    should be. Then, we have the `fieldset_state` setting which we will use to indicate
    whether the form fieldset used to group the two license place textfields is by
    default open or closed. We will see that in a minute. Lastly, each of these textfields
    can have a placeholder value (potentially). So, we have that setting as well.
    Do note that these are all settings we make up and that make sense for our field.
    You can add your own if you want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the form used to configure these settings (as part of the widget
    configuration):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have to return the elements for our widget settings, which will then be added
    to a bigger form (passed as an argument). There is nothing special about the first
    three form elements. We have two `number` fields and a `select` list to control
    the first three settings we saw in our defaults. For the first two settings, we
    want the numbers to be positive and max out at the same maximum length we have
    set in the storage. We don't want the widget exceeding that length. However, if
    we want, we can shorten the size of the element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The textfields for the two placeholder values are wrapped inside a `details`
    form element. The latter is a fieldset that can be open or closed and can contain
    other form elements. We will use it to wrap the actual textfields with which users
    will input license plate data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous form will look like this when users configure the widget:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46ced2d4-8a43-4433-9d06-533131f1f3ab.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we have the summary of the settings the widget, which will be displayed
    on the Manage form display page for our field:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method needs to return an array of strings that will make up the settings
    summary. That is what we do now: read all of our settings values and list them
    in a human-friendly way. The end result will look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bc7c788-7c6f-4b39-b88c-983dbd4eea7c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will have to implement the core of the field widget plugins—the actual
    form used for inputting the field data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a bit more complicated at first glance, but we'll break it down and
    you'll see that it actually makes sense with what you've been learning in the
    previous chapters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The first argument passed to this method is the entire list of values for this
    field. Remember that each field can have multiple values, hence the usage of the
    `FieldItemListInterface` instance to hold them. So, from there, we can get the
    values of any of the items in the list. The second argument is the actual delta
    of the item in the list, which we can use to pinpoint the one for which the form
    is being built (in order to retrieve the default value). Then, we have an `$element`
    array that we should actually return, but which contains some pieces of data already
    prepared for us based on the field configuration. For example, when creating a
    field, if we set it to be required, then this `$element` already contains the
    form property `#required => TRUE`. Likewise, it contains the weight of the field
    (compared to the others on the entity type), the `#title` property, and many others.
    I recommend that you debug that array and see what's in it. Also, you can look
    inside `WidgetBase::formMultipleElments()` and `WidgetBase::formSingleElement()`
    and see how this array is prepared. Lastly, we get the form definition and form
    state information of the larger form our field element gets embedded in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: So, what we are doing inside the method is getting a bit creative with the data
    that we have. The one-value (columns) fields would typically just add to the `$element`
    array and then simply return that. However, we have two values we want to wrap
    inside a nice collapsible fieldset, so we create a `details` element for that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: It is on this element that we copy over the field title and description the
    user has specified when creating the field, which is prepared for us in the `$element`
    array. This is because those relate to the entire field, not just one of the values.
    Moreover, we also set the default `#open` state to whatever was stored in the
    widget settings. Lastly, to all this we add the rest of the values found in the
    `$elements` array because we want to inherit them as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Note that I could have left the `#title` and `#description` to be inherited
    as well, but overtly added it to make it more visible for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Next, within our details element, we can add the two textfields for the license
    plate code and number. For both of these, we use the widget settings to set the
    element size and placeholder value, as well as a maximum length value equal to
    the field item storage. This is what will prevent users from providing values
    that are longer than what the database columns can handle. The default value for
    the two form elements will be set to the actual field values of these properties,
    retrieved from the list of items using the current delta key. Finally, we set
    the `#required` property to whatever the user has configured for this field. This
    property would be useless on the parent `details` element, so we have to move
    it down to the actual text fields. And that's pretty much it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method we can implement, and in our case, have to, is one that prepares
    the field values a bit when submitting:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s what happens. From our property definitions, our field expects two
    properties: number and code. However, submitting this form will present only one
    property called "details" because that is what we arbitrarily named our fieldset
    form element (which contains the properties). Since we made this choice, we will
    need to now massage the submitted values a bit to match the expected properties.
    In other words, we have to bring the number and code properties to the top level
    of the `$values` array and unset the details element, as it''s no longer needed
    upon submission. So, now, the field receives the array in the following format:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you remember, this is incidentally also what we would pass to the `set()`
    method of the field if we wanted to set this value on the field. Take a look at
    the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With that, our widget is done; well, not quite. We should ensure we use all
    the newly referenced classes at the top:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, we again forgot about the configuration schema. Let''s not do that again.
    In the same file as we wrote the field storage schema, we can add the definition
    for the widget settings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It works just like before: a dynamic schema name that starts with `field.widget.settings.`
    and has the actual plugin ID at the end; and inside, we have a property mapping
    as we''ve seen before. With this, we really are done.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Field formatter
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, so our field now also has a widget that users can input data with.
    Let's create the default field formatter to make the field whole.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Before actually coding it, let''s establish what we want our formatter to look
    and behave like. By default, we want the license plate data to be rendered like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, each component is wrapped inside its own span tag, and some handy classes
    are applied to them. Alternatively, we may want to concatenate the two values
    together into one single span tag:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This could be a setting on the formatter, allowing the user to choose the preferred
    output. So, let's do it then.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Field formatters go inside the `Plugin/Field/FieldFormatter` namespace of our
    module, so let''s go ahead and create our own:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, we start by inspecting the annotation, which looks very unsurprising.
    It looks almost like the one for our widget earlier, as formatters can also be
    used on multiple field types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The class extends `FormatterBase`, which itself implements the obligatory `FormatterInterface`.
    By now, you recognize the pattern used with plugins—they all have to implement
    an interface and typically extend a base class, which provides some helpful functionalities
    common to all plugins of those types. Fields are no different.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do inside this formatter class is, again, deal with its
    own settings (if we need any). As it happens, we have a configurable setting for
    our formatter, so let''s define it and provide a default value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is just like with the previous plugins. The `concatenated` setting will
    be used to determine the output of this field according to the two options we
    talked about earlier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, predictably, we will need the form to manage this setting:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, nothing special; we have a checkbox, which we use to manage a Boolean
    value (represented by 1 or 0). Lastly, just like with the widget, we have a summary
    display for formatters as well that we can define:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we just print in a human-readable name of whatever has been configured,
    and this will be displayed when managing the field display in the UI and will
    look just like it did with the widget. Consistency is nice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ve reached the most critical aspect of any field formatter—the actual
    display:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The method used for this is `viewElements()`, but for each element in the list,
    we simply delegate the processing to a helper method, because as you remember,
    the field is itself a list of value items (depending on the field cardinality),
    even if there is only one value in the field. These are keyed by a delta, which
    we also use to key the array of `$elements` that we return from the method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'For each individual item in the list, we then retrieve the value of the license
    plate code and number using the TypedData accessors we'' saw earlier. Remember
    that at this point we are working with a `FieldItemInterface` whose `get()` method
    returns the DataType plugin that represents the actual value, which, in our case,
    is `StringData`. Because that is what our field property definitions were:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, the actual values inside these plugins are the string representations
    the user actually provided. We use these values together with the setting to determine
    whether to concatenate and pass them to a custom theme function (we have yet to
    define this). The important thing to keep in mind is that we need to return, for
    each item, a render array. This can be anything; consider the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, that doesn''t look nice, nor is it configurable or overridable. So,
    we opt for a clean new theme function that takes those three arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We default the value for `concatenated` to `TRUE` because that is what we used
    inside `defaultSettings()` as well. We have to be consistent. The template file
    that goes with this, `license-plate.html.twig`, is also very simple:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Depending on our setting, we output the markup differently. Other modules and
    themes now have a host of options to alter this output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: They can create a new formatter plugin altogether.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can override the template inside a theme.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can alter the template to be used by this theme hook.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s it for the formatter plugin itself, but this time we''re not forgetting
    about the configuration schema. Although we have a measly little Boolean value
    to define, it still needs to be done:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works the same way as the other ones but with a different prefix: `field.formatter.settings`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have our field formatter in the bag. We should not forget, however,
    the missing *use* statements at the top of the formatter plugin class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now after clearing the cache, the new field type can be used to create fields.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: However, I still think we can do one better. Since we are working with license
    plates that deal with certain known formats, what if we make our field configurable
    to provide a list of license plate codes that can be used when inputting the data?
    This will have the added benefit of us learning something new about fields—field
    settings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Field settings
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created our field type, we specified some storage settings and we saw
    that these are typically linked to underlying storage and cannot be changed once
    the field has data in it. This is because databases have a hard time making table
    column changes when there is data present in them. However, apart from storage
    settings, we also have something called field settings, which are specific to
    the field instance on a certain entity bundle. Even more, they can (or should)
    be changeable even after the field has been created and has data in it. An example
    of such a field setting, which is available from Drupal core on all field types,
    is the "required" option which marks a field as required or not. So let's see
    how we can add our own field settings to configure what we said we want to do.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `LicensePlateItem` plugin class, we start by adding the default
    field settings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the same pattern we''ve been seeing by which we specify what are the
    settings and what are their relevant defaults. Then, as expected, we need the
    form, where users can specify the setting values for each field instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So what we provide here is a `textarea` form element by which the administrator
    can add multiple license plate codes, one per each line. In our widget, we will
    use these and turn them into a select list. However, before we do that, we need
    to provide the configuration schema for this new setting:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place, we can turn to our field widget and make the necessary changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `formElement()` method, let''s replace the block where we defined
    the code form element with this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since the logic for determining that element depends on configuration, it''s
    a bit more complicated, so it''s best to refactor to its own method. Now let''s
    write it up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by defining the code form element defaults, such as title, default,
    and value. Then, we get the field settings for the `codes` setting we just created.
    Note that `getFieldSetting()` and `getFieldSettings()` delegate to the actual
    field type and return both storage and field settings combined. So, we don't need
    to use separate methods. However, an implication is that you should probably stick
    to different setting names for the two categories.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Then, if we don't have any codes configured in this particular field instance,
    we build up our textfield form element as we did before. Otherwise, we break them
    up into an array and use them in a select list form element. Also, note that in
    this latter case we no longer need to apply any length limits because of the validation
    inherent to select lists. Values not present in the original options list will
    be considered invalid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty much it. The field can now be configured to either default to
    the open textfield for adding a license plate code or to a select list of predefined
    ones. Also, the same field can be used in these two ways on two different bundles,
    which is neat.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Using our custom field type as a base field
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I stressed the importance of understanding
    the makeup of a field (type, widget, and formatter) so as to easily define base
    fields on custom entity types. This understanding allows you to navigate through
    Drupal core code, discover their settings and use them on base fields. So, let's
    cement this understanding by seeing how our new field could be defined as a base
    field on a custom entity type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example where we actually use all the available settings we defined
    for each of the three plugins. Note that any settings that are left out default
    to the values we specified in the relevant *defaults* method, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is very similar to what we've been seeing. For the `create()` method, we
    use the `FieldType` plugin ID. Inside the `setSettings()` method we pass both
    storage and field settings. They will then be used appropriately. Note that since
    the `codes` setting is stored as a string with codes separated by line breaks,
    we will need to add it accordingly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for the `view` and `form` display options, we use the formatter and
    widget plugin IDs, respectively, and inside a `settings` array, we pass any of
    the settings we have defined. Lastly, the `setDisplayConfigurable()` indicates
    that all these settings for the formatter and widget are also configurable through
    the UI. Doing so will turn the `BaseFieldDefinition` into a `BaseFieldOverride`,
    as it needs to store the configured overrides.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This should be a recap for you, as we covered all these concepts in earlier
    chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at how we can create custom fields that site builders
    (and developers) can add to entity types. This implied defining three plugin types:
    `FieldType`, `FieldWidget`, and `FieldFormatter`, each with its own responsibility.
    The first defined the actual field, its storage and individual data properties,
    using the TypedData API. The second defined the form through which users can input
    field data when creating or editing entities that use the field. The third defined
    how the values inside this field can be displayed when viewing the entity.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that each of these plugins can have arbitrary sets of configurable
    settings that can be used to make the field dynamic—both in how the widget works
    and in how the values are displayed. Moreover, these settings are part of the
    exported field configuration, so we saw how we can define their respective configuration
    schemas.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we also saw how—aside from creating our new field through the UI—developers
    can add it to an entity type as a base field, making it available on all bundles
    of that entity type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about access control, a very important topic,
    as we need to ensure that our data and functionality are only exposed to the users
    we want, when we want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
