- en: Automated Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Automated testing is a process by which we rely on special software to continuously
    run pre-defined tests that verify the integrity of our application. To this end,
    automated tests are a collection of steps that cover the functionality of an application
    and compare triggered outcomes to expected ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是一个过程，我们依靠特殊的软件来持续运行预定义的测试，以验证我们应用程序的完整性。为此，自动化测试是一系列覆盖应用程序功能并比较触发结果与预期结果的步骤。
- en: Manual testing is a great way to ensure that a piece of written functionality
    works as expected. The main problem encountered by most adopters of this strategy,
    especially those who use it exclusively, is regression. Once a piece of functionality
    is tested, the only way they can guarantee regressions (or bugs) were not introduced
    by another piece of functionality is by retesting it. And as the application grows,
    this becomes impossible to handle. This is where automated tests come in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试是确保所编写的功能按预期工作的一种很好的方法。大多数采用这种策略的人遇到的主要问题是回归。一旦某个功能被测试，他们唯一能保证没有引入回归（或错误）的方法是重新测试它。随着应用程序的增长，这变得难以处理。这就是自动化测试发挥作用的地方。
- en: Automated testing uses special software that has an API that allows us to automate
    the steps involved in testing the functionality. This means that we can rely on
    machines to run these tests as many times as we want, and the only thing stopping
    us from having a fully-working application is the lack of proper test coverage
    with well-defined tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试使用具有 API 的特殊软件，该 API 允许我们自动化测试功能中涉及的步骤。这意味着我们可以依赖机器运行这些测试，次数不限，阻止我们拥有一个完全工作的应用程序的唯一因素是缺乏适当的测试覆盖率以及定义良好的测试。
- en: There's a lot of different software available for performing such tests and
    it's usually geared toward specific types of automated testing. For example, Behat
    is a powerful PHP-based open source behavior testing framework that allows the
    scripting of tests that mirror quite closely what a manual tester would do—interact
    with the application through the browser and test its behavior. There are other
    testing frameworks that go much lower in the level of their testing target. For
    example, the PHP industry standard tool, PHPUnit, is widely used for performing
    unit tests. This type of testing focuses on the actual code at the lowest possible
    level; it tests that class methods work properly by verifying their output after
    providing them with different input. A strong argument in favor of this kind of
    testing is that it encourages better code architecture, which can be (partly)
    measured by the ease with which unit testing can be written for it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的软件可用于执行此类测试，并且通常针对特定类型的自动化测试。例如，Behat 是一个基于 PHP 的强大开源行为测试框架，允许编写与手动测试人员所做非常相似的测试脚本——通过浏览器与应用程序交互并测试其行为。还有其他测试框架在测试目标的级别上更低。例如，PHP
    行业标准工具 PHPUnit 广泛用于执行单元测试。这种类型的测试专注于尽可能低级别的实际代码；通过提供不同的输入来验证类方法是否正常工作，并检查它们的输出。这种测试的强烈论点是它鼓励更好的代码架构，这可以通过编写单元测试的容易程度（部分地）来衡量。
- en: We also have functional or integration tests which fall somewhere in between
    the two examples. These go higher than code level and enlist application subsystems
    in order to test more comprehensive sets of functionality, without necessarily
    considering browser behavior and user interaction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有功能测试或集成测试，它们介于上述两种示例之间。这些测试高于代码级别，将应用程序子系统纳入其中，以测试更全面的功能集，而不必考虑浏览器行为和用户交互。
- en: It is not difficult to agree that a well-tested application features a combination
    of the different testing methodologies. For example, testing the individual architectural
    units of an application does not guarantee that the entire subsystem works, just
    as testing only the subsystem does not guarantee that its individual components
    will work properly under all circumstances. Also, the same is true for certain
    subsystems that depend on user interaction—these require test coverage as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 同意一个经过良好测试的应用程序应结合不同的测试方法并不困难。例如，测试应用程序的各个架构单元并不能保证整个子系统正常工作，就像只测试子系统并不能保证其各个组件在所有情况下都能正常工作。同样，对于依赖于用户交互的某些子系统也是如此——这些子系统也需要测试覆盖率。
- en: In this chapter, we will see how automated testing works in Drupal 8\. More
    specifically, we will go through and explain all testing methodologies available
    for us as module developers and exemplify them with two tests each. By the end
    of this chapter, you'll be ready to write your own tests and be familiar enough
    with the code to further explore the available testing capabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Drupal 8 中自动化测试的工作原理。更具体地说，我们将逐一解释所有可用的测试方法，并以每个测试为例进行说明。到本章结束时，您将准备好编写自己的测试，并对代码足够熟悉，以便进一步探索可用的测试功能。
- en: Testing methodologies in Drupal 8
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal 8 的测试方法
- en: Like many other development aspects, automated testing has been greatly improved
    in Drupal 8\. In the previous version, the testing framework was a custom one
    built specifically for testing Drupal applications—*Simpletest*. Its main testing
    capability focused on functional testing with a strong emphasis on user interaction
    with a pseudo-browser. However, it was quite strong and allowed a wide range of
    functionality to be tested.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他开发方面一样，在 Drupal 8 中，自动化测试得到了极大的改进。在之前的版本中，测试框架是一个专门为测试 Drupal 应用程序定制的自定义框架——*Simpletest*。其主要测试能力集中在功能测试上，并强调用户与伪浏览器的交互。然而，它相当强大，允许测试广泛的功能。
- en: Drupal 8 development started with *Simpletest* as well. However, with the adoption
    of PHPUnit, Drupal is moving away from it and is in the process of deprecating
    it. To replace it, there is a host of different types of tests—all run by PHPUnit—that
    can cover more testing methodologies. So let's see what these are.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 的开发也是从 *Simpletest* 开始的。然而，随着 PHPUnit 的采用，Drupal 正在远离它，并正在逐步淘汰它。为了替代它，有一系列不同类型的测试——所有这些测试都由
    PHPUnit 运行——可以覆盖更多的测试方法。那么，让我们看看这些是什么。
- en: 'Drupal 8 comes with the following types of testing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 包含以下类型的测试：
- en: 'Simpletest: exists for legacy reasons but no longer used to create new tests.
    This will be removed in Drupal 9.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Simpletest：由于遗留原因而存在，但不再用于创建新的测试。这将在 Drupal 9 中被移除。
- en: 'Unit: low-level class testing with minimal dependencies (usually mocked).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：使用最小依赖（通常为模拟）的低级别类测试。
- en: 'Kernel: functional testing with the kernel bootstrapped, access to the database
    and only a few loaded modules.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核测试：使用启动的内核、数据库访问以及仅加载的几个模块进行的功能测试。
- en: 'Functional: functional testing with a bootstrapped Drupal instance, a few installed
    modules and using a Mink-based browser emulator (Goutte driver).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试：使用启动的 Drupal 实例、一些已安装的模块以及基于 Mink 的浏览器模拟器（Goutte 驱动器）进行的功能测试。
- en: 'Functional JavaScript: functional testing like the previous, using the Selenium
    driver for Mink that allows for testing JavaScript powered functionality.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能 JavaScript：与之前的类似，使用 Selenium 驱动器进行 Mink 测试，允许测试由 JavaScript 驱动的功能。
- en: Apart from Simpletest, all of these test suites are built on top of PHPUnit
    and are, consequently, run by it. Based on the namespace the test classes reside
    in, as well as the directory placement, Drupal can discover these tests and know
    what type they are.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Simpletest 之外，所有这些测试套件都是建立在 PHPUnit 之上的，因此由它运行。根据测试类所在的命名空间以及目录位置，Drupal
    可以发现这些测试并知道它们的类型。
- en: In this chapter, we will see examples of all of them (except Simpletest) as
    we go about testing some of the functionality we've been writing in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将随着测试我们在本书中编写的某些功能，看到所有这些示例（除了 Simpletest）。
- en: PHPUnit
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHPUnit
- en: Drupal 8 uses PHPUnit as the testing framework for all types of tests. In this
    section, we will see how we can work with it to run tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 使用 PHPUnit 作为所有类型测试的测试框架。在本节中，我们将了解如何与之合作来运行测试。
- en: On your development environment (or wherever you want to run the tests), make
    sure you have the composer dependencies installed with the `--dev` flag. This
    will include PHPUnit. Keep in mind not to ever do this on your production environment
    as you can compromise the security of your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的开发环境（或您想要运行测试的任何地方），请确保您已使用 `--dev` 标志安装了 composer 依赖项。这将包括 PHPUnit。请记住，永远不要在生产环境中这样做，因为这可能会危及您应用程序的安全性。
- en: 'Although Drupal has a UI for running tests, PHPUnit is not well integrated
    with this. So, it''s recommended that we run them using the command line instead.
    Actually, it''s very easy to do so. To run the entire test suite (of a certain
    type), we have to navigate to the Drupal core folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Drupal有一个用于运行测试的用户界面，但PHPUnit与该界面集成得并不好。因此，建议我们使用命令行来运行它们。实际上，这样做非常简单。要运行整个测试套件（某种类型的），我们必须导航到
    Drupal 核心文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command goes back a folder through the vendor directory and uses the installed
    `phpunit` executable. As an option, in the previous example, we specified that
    we only want to run unit tests. Omitting that would run all types of tests. However,
    for most of the others, there will be some configuration needed, as we will see
    in the respective sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令通过供应商目录回退一个文件夹，并使用安装的`phpunit`可执行文件。作为一个选项，在之前的例子中，我们指定了只想运行单元测试。省略这一点将运行所有类型的测试。然而，对于大多数其他测试，将需要一些配置，正如我们将在相应的部分中看到的那样。
- en: 'If we want to run a specific test, we can pass it as an argument to the `phpunit`
    command (the path to the file):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想运行特定的测试，我们可以将其作为参数传递给`phpunit`命令（文件的路径）：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we run a Drupal core test that tests the `UrlGenerator` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们运行了一个Drupal核心测试，该测试用于测试`UrlGenerator`类。
- en: 'Alternatively, we can run multiple tests that belong to the same *group* (we
    will see how tests are added to a group soon):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行属于同一*组*的多个测试（我们很快就会看到如何将测试添加到组中）：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This runs all the tests from the `Routing` group which actually contains the
    `UrlGeneratorTest` we saw earlier. We can run tests from multiple groups if we
    separate them by a comma.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行来自`Routing`组的所有测试，实际上它包含了我们之前看到的`UrlGeneratorTest`。如果我们用逗号分隔它们，我们也可以运行来自多个组的测试。
- en: 'Also, to check what the available groups are, we can run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了检查可用的组，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will list all the groups that have been registered with PHPUnit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有已注册到PHPUnit的组。
- en: 'Finally, we can also run a specific method found inside a test by using the
    `—filter` argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以通过使用`—filter`参数来运行测试中的特定方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is one of the test methods from the same `UrlGeneratorTest` we saw before
    and is the only one that would run.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前看到的同一个`UrlGeneratorTest`中的一个测试方法，并且是唯一会运行的方法。
- en: Registering tests
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册测试
- en: There are certain commonalities between the various test suite types regarding
    what we need to do in order for Drupal (and PHPUnit) to be able to discover and
    run them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的测试套件类型之间，关于我们需要做什么以便Drupal（以及PHPUnit）能够发现和运行它们，有一些共同之处。
- en: 'First, we have the directory placement where the test classes should go in.
    The pattern is this: `tests/src/[suite_type]`, where `[suite_type]` is a name
    of the test suite type this test should be. And it can be one of the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定测试类应该放在哪个目录中。模式是这样的：`tests/src/[suite_type]`，其中`[suite_type]`是这个测试套件类型的名称，这个测试应该属于这个类型。它可以有以下几种：
- en: Unit
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元
- en: Kernel
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心库
- en: Functional
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: FunctionalJavascript
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能JavaScript测试
- en: So, for example, unit tests would go inside the `tests/src/Unit` folder of our
    module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单元测试应该放在我们模块的`tests/src/Unit`文件夹中。
- en: 'Second, the test classes need to respect a namespace structure as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，测试类还需要遵循一个命名空间结构：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is also pretty straightforward to understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点也很容易理解。
- en: Third, there is a certain metadata that we need to have in the test class PHPDoc.
    Every class must have a summary line describing what the test class is for. Only
    classes that use the `@coversDefaultClass` attribute can omit the summary line.
    Moreover, all test classes must have the `@group` PHPDoc annotation indicating
    the group they are part of. This is how PHPUnit can run tests that belong to certain
    groups only.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们需要在测试类的PHPDoc中包含某些元数据。每个类都必须有一行总结，描述测试类的用途。只有使用`@coversDefaultClass`属性的类可以省略总结行。此外，所有测试类都必须有`@group`
    PHPDoc注释，指出它们所属的组。这就是PHPUnit如何只运行属于某些组的测试。
- en: So now that we know how to register and run tests, let's look at unit tests
    and see how we can write our own.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何注册和运行测试，让我们来看看单元测试，看看我们如何编写自己的测试。
- en: Unit tests
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: As briefly mentioned at the beginning, unit tests are used for testing single
    *units* that make up the code architecture. In practice, this means testing individual
    classes, especially the methods they contain and what they should be doing. Since
    the testing happens at such a low level, they are by far the fastest tests that
    can be run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如开头简要提到的，单元测试用于测试构成代码架构的单个*单元*。在实践中，这意味着测试单个类，特别是它们包含的方法以及它们应该做什么。由于测试发生在如此低级别，它们是目前可以运行的最快的测试。
- en: 'The logic behind unit tests is quite simple: after providing input, the test
    asserts that the method output is correct. Typically, the more *input -> output*
    scenarios it covers, the more stable the tested code is. For example, tests should
    also cover unexpected scenarios, as well as exercise all the code contained in
    the tested methods (such as forks created by *if/else* statements).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试背后的逻辑相当简单：在提供输入后，测试断言方法输出是正确的。通常，它覆盖的`输入 -> 输出`场景越多，测试的代码就越稳定。例如，测试还应涵盖意外场景，以及练习测试方法中包含的所有代码（例如由`if/else`语句创建的分支）。
- en: The programming pattern of dependency injection—objects should receive as dependencies other
    objects they might need—becomes critical when it comes to unit testing. The reason
    is that if class methods work with the global scope or instantiate other objects,
    we can no longer test them cleanly. Instead, if they require dependencies, we
    can *mock* them and pass these within the context of the executed tests. We will
    see some examples shortly. But before we do that, let's create a simple class
    that can be easily tested using a unit test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的编程模式——对象应该接收它们可能需要的其他对象作为依赖项——在单元测试中变得至关重要。原因是如果类方法与全局作用域一起工作或实例化其他对象，我们就无法干净地测试它们。相反，如果它们需要依赖项，我们可以*模拟*它们，并在执行测试的上下文中传递这些依赖项。我们很快就会看到一些示例。但在我们这样做之前，让我们创建一个可以轻松使用单元测试进行测试的简单类。
- en: 'A typical example is a simple calculator class. It will take two numbers as
    arguments to its constructor and have four methods for performing basic arithmetic
    on those numbers. We''ll put this into our *Hello World* module:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是一个简单的计算器类。它将接受两个数字作为构造函数的参数，并具有四个方法来对这些数字执行基本算术运算。我们将把它放入我们的*Hello World*模块中：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nothing so complicated here. You could argue that a calculator class should
    not get any dependencies but instead pass the numbers to the actual arithmetic
    methods. However, this will work just as fine for our example and is a bit less
    repetitive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有这么复杂。你可以争论说计算器类不应该有任何依赖，而是应该将数字传递给实际的算术方法。然而，这在我们示例中也能很好地工作，并且稍微少一些重复。
- en: 'Now, let''s create the first unit test to make sure that this class behaves
    as we expect it. In the previous section, we saw which directory these need to
    go in. So, in our case, it will be `/tests/src/Unit`. And the test class looks
    like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个单元测试，以确保这个类表现如我们所期望。在上一个部分中，我们看到了这些测试需要放入哪个目录。所以，在我们的情况下，它将是`/tests/src/Unit`。测试类看起来像这样：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First of all, you notice the namespace corresponds to the pattern what we saw
    in the previous chapter. Second of all, the PHPDoc contains the required information:
    a summary and the `@group` tag. Third of all, the class name ends with the word
    `Test`. Finally, the class extends `UnitTestCase`, which is the base class we
    need to extend for all unit tests.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到命名空间与我们在上一章中看到的模式相对应。其次，PHPDoc包含所需的信息：摘要和`@group`标签。第三，类名以单词`Test`结尾。最后，该类扩展了`UnitTestCase`，这是我们为所有单元测试需要扩展的基类。
- en: All types of test class names in Drupal 8 need to end with the word *Test* and
    extend the relevant base class that provides specific code for that type of test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，所有类型的测试类名称都需要以单词*Test*结尾，并扩展提供该类型测试特定代码的相关基类。
- en: Then, we have the actual methods that test various aspects of the `Calculator`
    class and which always have to start with the word `test`. This is what tells
    PHPUnit that they need to be run. These methods are the actual standalone tests
    themselves, meaning that the `CalculatorTest` class has four tests. Moreover,
    each of these tests runs independently of the other.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有实际的方法来测试`Calculator`类的各个方面，并且这些方法总是必须以单词`test`开头。这就是告诉PHPUnit它们需要被执行。这些方法是实际的独立测试本身，这意味着`CalculatorTest`类有四个测试。此外，这些测试都是独立于其他测试运行的。
- en: Since the `Calculator` arithmetic is very simple, it's not difficult to understand
    what we are doing to test it. For each method, we are instantiating a new instance
    with some numbers, and then we *assert* that the result from the arithmetic operation
    equals to what we expect. The base class provides a multitude of different assertion
    methods that we can use in our tests. Since there are so many of them, we are
    not going to cover them all here. We will see more as we write more tests, but
    I strongly recommend you check the base classes of the various types of test suites
    for methods that start with the word `assert`. A great way is also to use an IDE
    that autocompletes as you type the method name. It can be very handy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`计算器`的算术运算非常简单，理解我们如何测试它并不困难。对于每种方法，我们使用一些数字实例化一个新的实例，然后我们*断言*算术运算的结果等于我们预期的结果。基类提供了许多不同的断言方法，我们可以在测试中使用。由于它们有很多，我们在这里不会全部涵盖。随着我们编写更多的测试，我们将看到更多。但我强烈建议您检查各种测试套件的基类，看看是否有以单词`assert`开头的方法。一个很好的方法也是使用一个在你输入方法名时自动补全的IDE。这可以非常方便。
- en: 'With this, we can already run the test and see whether it passes. Normally,
    it should because we can do math in our heads and we know it''s correct:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以运行测试并查看它是否通过。通常情况下，它应该会通过，因为我们可以在脑海中做数学运算，并且我们知道它是正确的：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result should be green:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是绿色的：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, earlier I mentioned that a good test also accounts for unexpected
    situations and negative responses. However, we have not done so very well in our
    example. If we look at `testAdd()`, we can see that the assertion is correct with
    those two numbers. But what if we later go to the `Calculator::add()` method and
    change it to this by accident:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我之前提到，一个好的测试也应该考虑到意外情况和负面响应。然而，在我们的例子中，我们并没有做得很好。如果我们看看`testAdd()`，我们可以看到使用这两个数字时断言是正确的。但如果我们后来不小心将`Calculator::add()`方法改为这样：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The test will still pass but will it actually be a true positive? Not really,
    because if we pass different numbers, the calculation won't match anymore. So
    we should test these methods with more than just one set of numbers to actually
    prove that the math behind the `Calculator` class is valid.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仍然会通过，但它实际上是一个真正的阳性吗？并不一定，因为如果我们传递不同的数字，计算结果将不再匹配。因此，我们应该使用不止一组数字来测试这些方法，以实际证明`计算器`类背后的数学是有效的。
- en: 'So instead, we can do something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以做类似这样的事情：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, we are sure that the addition operation works correctly. One trade-off
    in this is that we have a bit of repetitive code, especially if we have to do
    this for all the other operations as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以确保加法操作是正确的。在这个方法中，一个权衡是，我们有一些重复的代码，特别是如果我们必须对所有其他操作也这样做的话。
- en: Generally, when writing tests, repetition is much more accepted than when writing
    the actual code. Many times, there is nothing you can do about it as the code
    will seem very repetitive. However, in our case, we can actually do something
    by using the `setUp()` method which is called by PHPUnit before each test method
    runs. Its purpose is to perform various preparation tasks that are common for
    all the tests in the class. However, don't take this to mean that it runs only
    once and then is used by all. In fact, it runs before each individual test method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在编写测试时，重复性比编写实际代码时更被接受。很多时候，你对此无能为力，因为代码看起来非常重复。然而，在我们的情况下，我们可以通过使用`setUp()`方法来实际做些事情，这个方法是在PHPUnit运行每个测试方法之前被调用的。它的目的是执行对类中所有测试都通用的各种准备任务。然而，不要认为它只运行一次然后被所有测试使用。实际上，它在每个单独的测试方法运行之前都会运行。
- en: 'So, what we can do is something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以做的是类似这样的事情：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We create two class properties and inside the `setUp()` method we assign them
    to our calculator objects. A very important thing to keep in mind is to always
    call the parent call of this method because it does very important things for
    the environment setup. Especially as we move to Kernel and Functional tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建两个类属性，并在`setUp()`方法中将它们分配给我们的计算器对象。需要记住的一个重要事情是始终调用此方法的父调用，因为它为环境设置做了非常重要的事情。特别是当我们转向Kernel和功能测试时。
- en: 'Now, the `testAdd()` method can look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`testAdd()`方法可以看起来像这样：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much cleaner and less repetitive. Based on this, you can extrapolate and apply
    the same changes to the other methods yourself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更加简洁，重复性更低。基于此，你可以自己推断并应用相同的更改到其他方法。
- en: Mocked dependencies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖
- en: Seldom are tested classes so simple as our calculator class. Most of the time, they
    will have dependencies that in turn also have dependencies. So unit testing becomes
    a bit more complicated. In fact, the ease with which unit tests are written has
    become a litmus test for the quality of the code being tested—the less complicated
    the unit test, the better the code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的类很少像我们的计算器类那样简单。大多数情况下，它们将具有依赖关系，而这些依赖关系反过来也有依赖关系。因此，单元测试变得稍微复杂一些。事实上，编写单元测试的容易程度已经成为被测试代码质量的一个试金石——单元测试越简单，代码质量越好。
- en: As our second example of writing unit tests, let's go into the "real world"
    and test one of the classes we wrote in this book, namely, the `UserTypesAccess`
    class. If you remember from [Chapter 10](bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml),
    *Access Control*, we created this service to be used on routes as an access checker.
    Although we can write functional tests that verify that it works well as part
    of the access system, we can also write a unit test to check the actual code in
    the `access()` method. So let's get started.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编写单元测试的第二个示例，让我们进入“现实世界”，并测试我们在这本书中编写的其中一个类，即 `UserTypesAccess` 类。如果你记得从第
    10 章 [访问控制](bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml)，我们创建了这个服务，用于在路由上作为访问检查器。虽然我们可以编写功能测试来验证它作为访问系统一部分的工作情况，但我们也可以编写一个单元测试来检查
    `access()` 方法中的实际代码。所以让我们开始吧。
- en: 'The first thing we need to do is to create the class (respecting the directory
    placement as well as the class namespace):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建类（同时尊重目录放置以及类命名空间）：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So far things look like our previous example—we have the PHPDoc information
    and we are extending the `UnitTestCase` class. So let's write a test for the `access()`
    method of the `UserTypesAccess` class. However, if you remember, this method takes
    two arguments (a user account and a route object) and also uses the entity type
    manager which is injected in the class. So that is where the bulk of our complication
    lies. What we need to test is the return value of the method depending on these
    arguments. Basically, whether it will allow or deny access if the user account
    has certain values found on the route.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情看起来像我们之前的例子——我们有 PHPDoc 信息，并且正在扩展 `UnitTestCase` 类。所以让我们为 `UserTypesAccess`
    类的 `access()` 方法编写一个测试。然而，如果你记得，这个方法接受两个参数（一个用户账户和一个路由对象），并且还使用了注入到类中的实体类型管理器。这就是我们复杂性的大部分所在。我们需要测试的是方法返回值取决于这些参数。基本上，如果用户账户在路由上具有某些值，它将允许或拒绝访问。
- en: 'In unit testing, dependencies are usually mocked. This means PHPUnit will create
    empty lookalike objects that behave as we describe them to and we can use these
    as the dependencies. The way to create a simple mock object is this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，依赖项通常被模拟。这意味着 PHPUnit 将创建空的外观对象，它们的行为就像我们描述的那样，我们可以将这些用作依赖项。创建简单模拟对象的方法如下：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `$user` object will now be a mock of the Drupal 8 `User` entity class.
    It, of course, won''t do anything but it can be used as a dependency. But to actually
    make it useful, we need to prescribe some behavior to it based on what the tested
    code does with it. For example, if it calls its `id()` method, we need to prescribe
    this behavior. We can do this with *expectations*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`$user` 对象现在将成为 Drupal 8 `User` 实体类的模拟。当然，它不会做任何事情，但它可以用作依赖项。但是，为了使其真正有用，我们需要根据测试代码对它的使用来指定一些行为。例如，如果它调用了其
    `id()` 方法，我们需要指定这种行为。我们可以通过 *预期* 来做到这一点：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells the mock object that for every call to the `id()` method on it, it
    should return the value `1`. The `expects()` method takes in a matcher which can
    be even more restrictive. For example, instead of `$this->any()`, we can use `$this->once()`, which
    means that the mock object can have its `id()` method called only once. Check
    out the base class for the other available options, as well as what you can pass
    to the `will()` method—although `$this->returnValue()` is going to be the most
    common one. Finally, if the `id()` method takes an argument, we can also have
    the `with()` method to which we pass the value of the expected argument in the
    matcher.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉模拟对象，对于对它的 `id()` 方法的每次调用，它应该返回值 `1`。`expects()` 方法接受一个匹配器，它可以更加限制性。例如，我们不仅可以使用
    `$this->any()`，还可以使用 `$this->once()`，这意味着模拟对象的 `id()` 方法只能被调用一次。查看基类以获取其他可用选项，以及可以传递给
    `will()` 方法的选项——尽管 `$this->returnValue()` 将是最常见的一个。最后，如果 `id()` 方法接受一个参数，我们还可以使用
    `with()` 方法，将预期的参数值传递给匹配器。
- en: 'A more complex way of creating a mock is by using the mock builder:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟对象的一种更复杂的方式是使用模拟构建器：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will get the same mock object but will allow for some more options in its
    construction. I recommend checking out the PHPUnit documentation for more information
    as this is as deep as we are going to go in this book on mocking objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取相同的模拟对象，但将允许在它的构建中拥有更多选项。我建议查看PHPUnit文档以获取更多信息，因为这是我们在这本书中关于模拟对象将要深入探讨的深度。
- en: 'Now that we know a bit about mocking, we can proceed with writing our test.
    To do this, we need to think about the end goal and work our way back to all the
    method calls we need to mock. Just as a reminder, this is the code that we need
    to test:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模拟有了些了解，我们可以继续编写我们的测试。为此，我们需要考虑最终目标，并从所有需要模拟的方法调用回溯。提醒一下，这是我们需要测试的代码：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, at the first glance, we need to mock `EntityTypeManager`. The method arguments
    we will instantiate manually with some dummy data inside. However, mocking `EntityTypeManager`
    is going to be quite complicated. A call to its `getStorage()` method needs to
    return a `UserStorage` object. This needs to also be mocked because a call on
    its `load()` method needs to return a `User` entity object. Finally, we also need
    to mock that because a call to its `get()` method is also expected to return a
    value object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乍一看，我们需要模拟`EntityTypeManager`。我们将手动使用一些虚拟数据实例化其方法参数。然而，模拟`EntityTypeManager`将会相当复杂。对其`getStorage()`方法的调用需要返回一个`UserStorage`对象。这也需要被模拟，因为对其`load()`方法的调用需要返回一个`User`实体对象。最后，我们也需要模拟它，因为对其`get()`方法的调用预期也将返回一个值对象。
- en: 'As I mentioned, we will proceed by going back from our end goal. So we can
    start with instantiating the types of `AccountInterface` objects we want to pass,
    as well as the route objects:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，我们将从我们的最终目标开始回溯。因此，我们可以从实例化我们想要传递的`AccountInterface`对象类型以及路由对象开始：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the new *use* statements at the top:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新的`use`语句：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Basically, we want to test what happens for both types of users: anonymous
    and registered. When instantiating the `UserSession` objects (which implement
    `AccountInterface`), we pass in some data to be stored with it. In our case, we
    need the user `uid` because it will be requested by the tested code when checking
    whether the user is anonymous or not.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们想要测试两种用户类型的情况：匿名用户和注册用户。在实例化`UserSession`对象（这些对象实现了`AccountInterface`接口）时，我们传递一些与它一起存储的数据。在我们的情况下，我们需要用户`uid`，因为测试代码在检查用户是否匿名时将请求它。
- en: 'Then, we create three routes: one where managers should have access, one where
    board members should have access, and one where no one should have access (as
    indicated by the `_user_types` option on the route). Do check back to [Chapter
    10](bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml), *Access Control,* if you don''t
    remember what this functionality is about.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建三个路由：一个管理器应该可以访问的路由，一个董事会成员应该可以访问的路由，以及一个没有人可以访问的路由（如路由上的`_user_types`选项所示）。如果你不记得这个功能是什么，请回顾第10章，*访问控制*。
- en: 'Once this is done, it follows to instantiate our `UserTypesAccess` class, in
    view of calling its `access()` method with various combinations of our account
    and route objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，接下来就是实例化我们的`UserTypesAccess`类，以便使用各种组合的账户和路由对象调用其`access()`方法：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And the new *use* statement at the top:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新的`use`语句：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, we don''t yet have an entity type manager so we need to mock it. Here
    is all the code we need to mock the entity type manager to work for our tested
    code (this goes before the code we wrote so far in this test):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有实体类型管理器，因此我们需要对其进行模拟。以下是我们需要模拟实体类型管理器以使其为测试代码工作所需的所有代码（这些代码在我们迄今为止编写的测试代码之前）：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First of all, you will notice that the entity type manager is only mocked at
    the very end. We first need to start the call chain which ends with a User entity
    object field value. So the first block mocks the User entity object which expects
    any number of calls to its `get()` method to which it will always return a `stdClass()`
    object with the property `value` that equals to the `manager` string. This way
    we are mocking the entity field system accessor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到实体类型管理器只是在最后才被模拟。我们首先需要启动调用链，该链以用户实体对象字段值为结束。因此，第一个块模拟了用户实体对象，它期望对其`get()`方法进行任意次数的调用，并将始终返回一个具有`value`属性等于`manager`字符串的`stdClass()`对象。这样我们就模拟了实体字段系统访问器。
- en: While using the mock builder for creating our mocks, we can use the `disableOriginalConstructor()`
    method to prevent PHPUnit from calling the constructor of the original class.
    This is important in order to prevent the need for all sorts of other dependencies
    that don't actually impact the tested code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模拟构建器创建模拟时，我们可以使用 `disableOriginalConstructor()` 方法来防止 PHPUnit 调用原始类的构造函数。这很重要，以防止需要所有各种其他依赖项，而这些依赖项实际上并不影响被测试的代码。
- en: 'Now that we have the User entity mock, we can use it as the return value of
    the `UserStorage` mock''s `load()` method. This, in turn, is the return value
    of the entity type manager mock''s `getStorage()` method. So, all of the code
    we wrote means that we have mocked the following chain:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户实体模拟，我们可以将其用作 `UserStorage` 模拟的 `load()` 方法的返回值。这反过来又是实体类型管理模拟的 `getStorage()`
    方法的返回值。因此，我们编写的所有代码意味着我们已经模拟了以下链：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It doesn't really matter what we pass to the `load()` method as we will always
    have that one user entity that has the `manager` user type.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `load()` 方法的参数实际上并不重要，因为我们始终有一个具有 `manager` 用户类型的用户实体。
- en: 'Now that everything is mocked, we can use the `$access` object we created earlier
    and make assertions based on calls to its `access()` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已模拟，我们可以使用之前创建的 `$access` 对象，并根据对其 `access()` 方法的调用进行断言：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The return value is always an object that implements an interface—either `AccessResultAllowed`
    or `AccessResultForbidden`, so that is what we need to assert. We are checking
    four different use cases:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值始终是一个实现接口的对象——要么是 `AccessResultAllowed`，要么是 `AccessResultForbidden`，因此这是我们需要断言的内容。我们正在检查四个不同的用例：
- en: Access denied if there is no route option
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有路由选项，则拒绝访问
- en: Access denied for anonymous users on any of the routes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何路由上的匿名用户访问被拒绝
- en: Access denied for registered users with the wrong user type
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有错误用户类型的注册用户，拒绝访问
- en: Access allowed for registered users with the proper user type
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于注册用户且具有正确用户类型的情况，允许访问
- en: 'So with this, we can run the test and should hopefully get a green result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以运行测试，并希望得到一个绿色的结果：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the basics of writing unit tests. There are a lot more types of assertions
    and you'll end up mocking quite a lot of dependencies in Drupal 8\. But don't
    be put off by the slow pace encountered at first as things will become faster
    as you get more experience.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编写单元测试的基础。在 Drupal 8 中，还有更多类型的断言，你最终会模拟很多依赖项。但不要因为一开始遇到的缓慢速度而气馁，随着经验的积累，事情会变得更快。
- en: Kernel tests
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核测试
- en: Kernel tests are the immediate higher-level testing methodology we can have
    in Drupal 8 and are actually integration tests that focus on testing various components.
    They are faster than regular Functional tests as they don't do a full Drupal install,
    but use an in-memory pseudo installation that is much faster to bootstrap. For
    this reason, they also don't handle any browser interactions and don't install
    any modules automatically.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 内核测试是 Drupal 8 中我们可以拥有的直接高级测试方法，实际上是集成测试，专注于测试各种组件。它们比常规功能测试更快，因为它们不执行完整的 Drupal
    安装，而是使用一个内存中的伪安装，启动速度更快。因此，它们也不处理任何浏览器交互，并且不会自动安装任何模块。
- en: Apart from the code itself, Kernel tests also work with the database and allow
    us to load the modules that we need for running the test. However, unlike the
    Functional tests we will see next, Kernel tests also require us to manually trigger
    the installation of any database schemas we need. But we will see how we can do
    this in the two examples we cover in this section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码本身之外，内核测试还与数据库一起工作，并允许我们加载运行测试所需的模块。然而，与下一节中我们将看到的函数测试不同，内核测试还要求我们手动触发所需数据库模式的安装。但我们将看到在本节中涵盖的两个示例中如何做到这一点。
- en: Before we can work with Kernel tests though, we need to make sure we have a
    connection to the database and PHPUnit is aware of this. Inside the `core` folder
    of our Drupal installation we find a `phpunit.xml.dist` file which we need to
    duplicate and rename to `phpunit.xml`. This is the PHPUnit configuration file.
    Normally this file should already be ignored by Git so no need to worry about
    committing it to the repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够进行内核测试之前，我们需要确保我们有一个数据库连接，并且 PHPUnit 意识到这一点。在我们的 Drupal 安装 `core` 文件夹中，我们找到一个
    `phpunit.xml.dist` 文件，我们需要将其复制并重命名为 `phpunit.xml`。这是 PHPUnit 的配置文件。通常，这个文件应该已经被
    Git 忽略，因此无需担心将其提交到仓库。
- en: 'In this file, we find an environment variable called `SIMPLETEST_DB` where
    we can specify the connection to the database, using the format exemplified in
    the following commented code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们找到一个名为`SIMPLETEST_DB`的环境变量，我们可以使用以下注释代码中展示的格式来指定数据库连接：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once that is in, PHPUnit will be able to connect to the database in order to
    install Drupal for Kernel tests as well as Functional and FunctionalJavascript
    tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，PHPUnit将能够连接到数据库，以便为内核测试以及功能测试和功能JavaScript测试安装Drupal。
- en: As a rule of thumb, you should always opt for Kernel tests over Functional tests
    whenever browser interactions are not involved and Kernel tests are enough to
    do the job. This is because a suite full of tests can end up taking a long time
    to run so you should make it as performant as possible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，当不涉及浏览器交互且内核测试足以完成任务时，你应该始终选择内核测试而不是功能测试。这是因为充满测试的套件可能会花费很长时间运行，所以你应该尽可能提高其性能。
- en: TeamCleaner test
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TeamCleaner 测试
- en: Now that we have that covered, it's time to write our first Kernel test. And
    a nice simple example can be to test the `TeamCleaner``QueueWorker` plugin we
    created in [Chapter 14](88a7281a-cb61-4079-8dde-3041babf698e.xhtml), *Batches,
    Queues, and Cron*. If you are wondering why this cannot be tested using the ultra-fast
    unit testing methodology, the answer is that its single method doesn't return
    anything. Instead, it alters database values that we need to access in order to
    check it happened correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了这些内容，是时候编写我们的第一个内核测试了。一个简单的好例子可以是对我们在第14章中创建的`TeamCleaner`和`QueueWorker`插件进行测试，*批处理、队列和Cron*。如果你想知道为什么不能使用超快的单元测试方法进行测试，答案是它的单一方法不返回任何内容。相反，它改变了我们需要访问以检查其是否正确发生的数据库值。
- en: 'The test class goes naturally in the `tests/src/Kernel` folder of our module
    and can start off like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类自然位于我们的模块的`tests/src/Kernel`文件夹中，可以开始如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The namespace is consistent with the ones we've seen so far and we have the
    correct PHPDoc annotations to register the test. Moreover, this time, we are extending
    from `KernelTestBase`. Do pay attention to the actual version of this class because
    the one that comes from the old Simpletest framework is also called `KernelTestBase`.
    So make sure you extend the correct one as seen in the *use* statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间与我们之前看到的保持一致，并且我们有正确的PHPDoc注释来注册测试。此外，这次，我们是从`KernelTestBase`扩展的。请注意这个类的实际版本，因为来自旧Simpletest框架的版本也称为`KernelTestBase`。所以请确保你扩展的是在*use*语句中看到的正确版本。
- en: 'The first thing we need to do is specify which modules we want loaded when
    running this test. For our case, this is the `sports` module so we can add a class
    property that contains this name:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是指定在运行此测试时要加载哪些模块。在我们的例子中，这是`sports`模块，因此我们可以添加一个包含此名称的类属性：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Specifying a list of modules here does not actually install them but simply
    loads and adds them to the service container. So yes, we have access to the module
    and code as well as the container. But that also means that schemas defined by
    these modules are not actually created so we need to do that manually. The same
    is true for the configuration the module is shipped with. But we can handle these
    things in the `setUp()` method or in the actual test method itself. We''ll opt
    for the latter because, in this case, we only have one test method in the class.
    And the whole thing can look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处指定模块列表实际上并不安装它们，只是将它们加载并添加到服务容器中。所以是的，我们可以访问模块和代码以及容器。但这也意味着这些模块定义的模式实际上并没有创建，因此我们需要手动完成。同样，对于模块附带配置也是如此。但我们可以将这些事情处理在`setUp()`方法中或在实际的测试方法本身中。我们将选择后者，因为在这种情况下，我们只有一个测试方法在类中。整个事情可以看起来像这样：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the *use* statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以及*use*语句：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since the `TeamCleaner` plugin removes teams, it's enough to only install that
    table. We can do that using the parent `installSchema()` method to which we pass
    the module name and table we want installed. We don't actually deal with players
    so we should avoid doing unnecessary work like the creation of the `players` table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TeamCleaner`插件会删除团队，因此只需安装该表就足够了。我们可以使用父`installSchema()`方法来做到这一点，我们将模块名称和要安装的表传递给它。我们实际上不处理玩家，因此我们应该避免进行不必要的操作，如创建`players`表。
- en: Then, very similar to how we do it in real code, we get the `database` service
    from the container and add a record to the `teams` table. This will be the test
    record that we delete so we remember its `$id`. But before we test this, we want
    to make absolutely sure that our record got saved. So we query for it and assert
    that the result is not empty. The `assertNotEmpty()` method is another helpful
    assertion that we can use when dealing with arrays.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，非常类似于我们在实际代码中这样做，我们从容器中获取 `database` 服务并向 `teams` 表添加一条记录。这将是我们将要删除的测试记录，这样我们就能记住它的
    `$id`。但在测试之前，我们想确保我们的记录确实被保存了。因此，我们查询它并断言结果不为空。`assertNotEmpty()` 方法是我们在处理数组时可以使用的另一个有用的断言。
- en: 'Now that we are certain the record is in the database, we can "process" it
    using our plugin. So we instantiate a `TeamCleaner` object, passing all its required
    dependencies—most importantly the database service. Then we create a simple object
    that mimics what the `processItem()` method expects and calls the latter while
    passing the former to it. At this point, if our plugin did its job correctly,
    the team record should have been deleted from the database. So we can query for
    it and this time assert the opposite of what we did before: that the query comes
    back empty.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确定记录已经在数据库中，我们可以使用我们的插件来“处理”它。因此，我们实例化一个 `TeamCleaner` 对象，传递所有其所需的依赖项——最重要的是数据库服务。然后我们创建一个简单的对象，模拟
    `processItem()` 方法所期望的，并调用后者，同时将前者传递给它。在这个时候，如果我们的插件正确执行了其任务，团队记录应该已经被从数据库中删除。因此，我们可以查询它，这次断言与之前相反：查询结果为空。
- en: 'And with this, our test is finished. As always, we should actually run it and
    make sure it passes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试就结束了。像往常一样，我们应该实际运行它并确保它通过：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And that is a very simple example of using Kernel tests for testing a component,
    particularly one that integrates with the database. We could have used a Functional
    test as well but that would have been overkill—it would run slower and make no
    use of the benefits that it offers over Kernel testing, such as browser integration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，展示了如何使用内核测试来测试一个组件，特别是那些与数据库集成的组件。我们也可以使用功能测试，但这会有些过度——它会运行得更慢，并且无法利用它相对于内核测试的优势，比如浏览器集成。
- en: CsvImporter test
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CsvImporter 测试
- en: After this simple example, let's write another test that illustrates a more
    complex scenario. And we will write one that tests the `CsvImporter` plugin we
    created in the previous chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子之后，让我们再写一个测试，来展示一个更复杂的场景。我们将写一个测试来测试我们在上一章中创建的 `CsvImporter` 插件。
- en: There is quite a lot of functionality that goes into this plugin and working
    with it—we have the actual importing, the plugin and configuration entity creation,
    the user interface for doing so, and so on. And it's a very good example of functionality
    that can benefit from a multi-methodology test coverage. And in this respect,
    we start with testing its underlying purpose, that of the product import, for
    which we don't need browser interactions. This means that we can use a Kernel
    test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件中包含了很多功能，与之一起工作——我们有实际的导入、插件和配置实体创建、用户界面等等。这是一个很好的例子，说明了可以从多方法测试覆盖中受益的功能。在这方面，我们从测试其基本目的开始，即产品导入，这不需要浏览器交互。这意味着我们可以使用内核测试。
- en: 'Similar to how we wrote the previous test, we can start with the class like
    so (this time in the `products` module):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们编写的前一个测试类似，我们可以从类开始（这次在 `products` 模块中）：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Nothing new so far.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有新的内容。
- en: 'Next, we need to specify the modules we need loaded. And here we have a bigger
    list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定需要加载的模块。这里有一个更长的列表：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Only the `products` module may seem obvious to you at this point, but all the
    rest are also needed. The `system`, `image`, `file` and `user` modules are all
    somehow needed for dealing with the file upload and storage process that is needed
    for the `CsvImporter` plugin.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `products` 模块可能对你来说很明显，但所有其他模块也都是必需的。`system`、`image`、`file` 和 `user` 模块都是处理
    `CsvImporter` 插件所需的文件上传和存储过程所必需的。
- en: It's not always so easy to figure out which modules are needed so it will involve
    a bit of a trial and error, at least in the beginning. A typical scenario is to
    run the test and notice failures due to missing functionality. Tracking this functionality
    to a module and specifying this module in the list is how you usually end up with
    a complete module list, especially when the test is complex and needs a wide range
    of subsystems with dependencies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是那么容易确定需要哪些模块，所以这可能会涉及一些试错，至少在开始时是这样。一个典型的场景是运行测试并注意到由于缺少功能而导致的失败。将此功能追踪到模块并在列表中指定此模块通常是您获得完整模块列表的方法，尤其是当测试复杂且需要广泛的子系统及其依赖项时。
- en: But you may be wondering what's with the `csv_importer_test` module there. Oftentimes,
    you may need to create modules used only for the tests—usually because they contain
    some configuration you want to use in your testing. In our case, we did so to
    demonstrate where these modules would go and to add a `products.csv` test file
    that we can use in our tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能想知道`csv_importer_test`模块在那里有什么用。通常，你可能需要创建仅用于测试的模块——通常是因为它们包含一些你希望在测试中使用的配置。在我们的案例中，我们这样做是为了演示这些模块将放在哪里，并添加一个`products.csv`测试文件，我们可以在测试中使用它。
- en: 'Tests modules go inside the `tests/modules` folder of the module that contains
    the tests that use them. So, in our case, we have `csv_importer_test` with its
    `info.yml` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块位于包含使用它们的测试的模块的`tests/modules`文件夹中。因此，在我们的案例中，我们有`csv_importer_test`及其`info.yml`文件：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And the mentioned CSV file we will use is right next to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的提到的CSV文件就在它的旁边：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we covered that, we can write the test method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了这一点，我们可以编写测试方法：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the *use* statement at the top:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的`use`语句：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The initial setup here is a bit more complicated, partly because of Kernel tests
    not installing module schemas. Using the parent `installEntitySchema()`, method
    we can install all the necessary tables for the Product and File content entities.
    However, since we are working with managed files, we also need to install the
    `file_usage` table manually. It is not technically an entity table. Again, there
    is no shame in arriving at these steps using trial and error.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的初始设置稍微复杂一些，部分原因是因为内核测试没有安装模块模式。使用父`installEntitySchema()`方法，我们可以安装产品实体和文件内容实体所需的所有必要表。然而，由于我们正在处理管理文件，我们还需要手动安装`file_usage`表。从技术上讲，它不是一个实体表。再次强调，使用试错法到达这些步骤并不丢脸。
- en: Now that we have the basics set up, we do a sanity check and ensure that we
    don't have any product entities in the database. There is no reason why we should
    have any, but it doesn't hurt to ensure it. This guarantees a valid test since
    our goal will be to later assert the existence of products.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基础，我们进行一次合理性检查，确保数据库中没有产品实体。我们没有理由应该有任何，但确保这一点并无害处。这保证了测试的有效性，因为我们的目标将是后来断言产品的存在。
- en: Then we create a managed File entity by using the `products.csv` file from the
    `csv_importer_test` module. The `drupal_get_path()` function is a very common
    way of retrieving the relative path to a module or a theme, regardless of where
    it is actually located. And we save the contents of this file into the `public://`
    filesystem of the testing environment. Keep in mind, though, that after the test
    runs successfully, this file gets removed as Drupal cleans up after itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用来自`csv_importer_test`模块的`products.csv`文件创建一个管理的文件实体。`drupal_get_path()`函数是一种非常常见的检索模块或主题的相对路径的方法，无论它实际上位于何处。我们将此文件的
    内容保存到测试环境的`public://`文件系统中。但请记住，一旦测试成功运行，此文件将被删除，因为Drupal会自行清理。
- en: Next, we need to create an Importer configuration entity that uses the CSV-based
    plugin to run the import. And instead of doing it through the UI, we do it programmatically.
    Using the storage manager, we create the entity as we learned in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*. Once we have that, we use the Importer plugin manager
    to create an instance based on this configuration entity (to which we gave the
    ID `csv`). And finally, we run the import of the products.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个使用基于CSV的插件来运行导入的导入器配置实体。而不是通过UI进行，我们以编程方式完成。使用存储管理器，我们创建实体，就像我们在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模和存储”中学到的那样。一旦我们有了这个，我们就使用导入器插件管理器根据这个配置实体（我们给它分配了ID
    `csv`）创建一个实例。最后，我们运行产品的导入。
- en: 'Now, for the assertions, we do a double check. Since our test CSV contains
    two rows, we load all the product entities again and assert that we have a total
    of two. No more, no less. And here we see another useful assertion method for
    working with arrays: `assertCount()`. But then we get a bit more specific and
    try to load a product that has a field value (the `number`) equal to an expected
    number from the test CSV file. And assert that it is, in fact, found as well.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于断言，我们进行双重检查。由于我们的测试CSV文件包含两行，我们再次加载所有产品实体并断言总数为两个。不多也不少。在这里，我们看到了另一种用于处理数组的实用断言方法：`assertCount()`。但接下来我们更加具体，尝试加载一个字段值（即`number`）等于测试CSV文件中预期数值的产品。并断言它确实被找到。
- en: We could even do some more assertions. For example, we can check that all the
    Product field values have been set correctly. I'll let you explore ways in which
    you can do this—either by querying based on these values or asserting equality
    between field values and their expected ones. But it's important to not go overboard
    as it will impact speed and, in some cases, add insufficient value to the test
    coverage to compensate for it. The trick is to find the right balance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进行更多的断言。例如，我们可以检查所有产品字段值是否已正确设置。我将让您探索如何进行此操作——要么基于这些值进行查询，要么断言字段值与其预期值之间的相等性。但重要的是不要过度，因为这会影响速度，在某些情况下，还会给测试覆盖率增加不足的价值，以补偿它。诀窍是找到正确的平衡。
- en: 'Finally, with our test in place, we can actually run it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着我们的测试已经就绪，我们实际上可以运行它：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And this test should pass as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试也应该通过。
- en: Functional tests
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: In the previous section we looked at Kernel tests and said that they are basically
    integration tests that focus on components rather than interactions with the browser.
    In this section, we'll go one level up and talk about the fully-fledged Functional
    tests, otherwise called browser tests (from the name of the base class we need
    to extend).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一节中，我们讨论了内核测试，并表示它们基本上是集成测试，侧重于组件而不是与浏览器的交互。在本节中，我们将上升一个层次，讨论全面的功能测试，也称为浏览器测试（从我们需要扩展的基本类名称）。 '
- en: Functional tests in Drupal 8 use a simulated browser (using the popular Mink
    emulator) that allows users to click links, navigate to pages, work with forms
    and make assertions regarding HTML elements on the page. What they don't allow
    us is to test JavaScript-based interactions (see the next section for those).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8中的功能测试使用模拟浏览器（使用流行的Mink模拟器），允许用户点击链接、导航到页面、处理表单以及就页面上的HTML元素做出断言。它们不允许我们测试基于JavaScript的交互（有关这些内容，请参阅下一节）。
- en: 'In Drupal 7, Functional tests were the most common type of tests used, most
    classes extending from Simpletest''s `WebTestBase` class. But in Drupal 8 we have
    the `Drupal\Tests\BrowserTestBase` class which is integrated with PHPUnit like
    the ones we''ve seen before. And the base class contains loads of methods both
    for asserting things and shortcuts to performing Drupal (and web) related tasks:
    creating users, entities, navigating to pages, filling in and submitting forms,
    logging in, and so on. And just like before, each test (class method), runs in
    isolation so things like content and users cannot be shared across multiple tests
    but would have to be recreated (perhaps using the `setUp()` method as we''ve already
    seen).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 7中，功能测试是最常用的测试类型，大多数类都扩展了Simpletest的`WebTestBase`类。但在Drupal 8中，我们有`Drupal\Tests\BrowserTestBase`类，它像之前看到的那些一样与PHPUnit集成。基类包含大量用于断言的方法以及执行Drupal（和Web）相关任务的快捷方式：创建用户、实体、导航到页面、填写和提交表单、登录等。就像之前一样，每个测试（类方法）都是独立运行的，因此像内容和用户这样的东西不能在多个测试之间共享，而必须重新创建（可能使用我们之前看到的`setUp()`方法）。
- en: Browser tests perform a full Drupal installation with a minimal number of modules
    (using the *Testing* installation profile). This means that we can specify to
    install other modules as well, and the schema for these also gets installed. Moreover,
    it's also important to understand that the resulting installation has got nothing
    in common with our current development site. Any configuration we need, we have
    to create. There are no users, no content and no files. So it is a brand new,
    parallel installation, that runs for the duration of one single test and gets
    cleaned up as it finishes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器测试使用具有最少数量的模块（使用*Testing*安装配置文件）执行完整的Drupal安装。这意味着我们可以指定安装其他模块，这些模块的架构也会被安装。此外，重要的是要理解，生成的安装与我们的当前开发站点没有任何共同之处。我们需要的所有配置，我们都需要创建。没有用户，没有内容，也没有文件。因此，这是一个全新的、并行的安装，它在单个测试的持续时间内运行，并在完成后被清理。
- en: Configuration for functional tests
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试的配置
- en: 'Before writing our functional tests, we need to turn back to our `phpunit.xml`
    file and change some environment variables. Apart from the `SIMPLETEST_DB` variable
    we adjusted earlier, we also have the `SIMPLETEST_BASE_URL` and `BROWSERTEST_OUTPUT_DIRECTORY`.
    The first is used to know where the application can be accessed in the browser.
    The latter is the directory where output data can be saved by PHPUnit and needs
    to be an absolute local path (for example, a folder in the local `files` folder):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的功能测试之前，我们需要回到我们的`phpunit.xml`文件并更改一些环境变量。除了我们之前调整的`SIMPLETEST_DB`变量外，我们还有`SIMPLETEST_BASE_URL`和`BROWSERTEST_OUTPUT_DIRECTORY`。第一个用于知道应用程序在浏览器中可以访问的位置。后者是PHPUnit可以保存输出数据的目录，需要是一个绝对本地路径（例如，本地`files`文件夹中的一个文件夹）：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Moreover, make sure the user running the test has permissions to write into
    the `sites/simpletest` folder as that is where the virtual filesystem is created
    for each test. The easiest way to do it is to change the folder ownership to the
    web server user that runs the process. In the case of Apache, this is usually
    `www-data`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保运行测试的用户有权限写入`sites/simpletest`文件夹，因为虚拟文件系统就是在这里为每个测试创建的。最简单的方法是将文件夹的所有权更改为运行该进程的Web服务器用户。在Apache的情况下，这通常是`www-data`。
- en: Hello World page test
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World页面测试
- en: 'The first Functional test we will write is for the *Hello World* page we created
    and the functionality behind it. We will test whether the page shows the correct
    *Hello World* message, also depending on the value found in the configuration.
    So let''s create the class for it, naturally in the `hello_world` module, inside
    the `tests/src/Functional` folder:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个功能测试是针对我们创建的*Hello World*页面及其背后的功能。我们将测试页面是否显示了正确的*Hello World*消息，这也取决于配置中找到的值。所以让我们创建一个类，自然是在`hello_world`模块中，在`tests/src/Functional`文件夹内：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can really see the consistency with the other types of tests. But in this
    case, as mentioned, we extend from `BrowserTestBase`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的可以看到与其他测试类型的连贯性。但在这个案例中，正如之前提到的，我们扩展了`BrowserTestBase`。
- en: 'Also, like before, we can configure a number of modules we want installed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像之前一样，我们可以配置我们想要安装的模块数量：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will need the User module for the second test we run, which will go in the
    same class as this one. But let''s proceed with the first, easier test:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要在运行的第二个测试中使用用户模块，它将和这个模块属于同一类。但让我们先进行第一个，更简单的测试：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you remember, our `/hello` page shows a greeting depending on the time of
    day, unless an administrator has overridden that message through a configuration
    form. So we start this test by asserting that with a fresh install that has no
    override, we see the time-based greeting. And for that we create a separate assertion
    message since it''s a bit wordy and we will reuse it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们的`/hello`页面会根据一天中的时间显示问候语，除非管理员通过配置表覆盖了该消息。因此，我们从这个测试开始，断言在一个没有覆盖的新安装中，我们看到基于时间的问候语。为此，我们创建了一个单独的断言消息，因为它有点长，我们将重用它：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The very first thing we do here is use the `drupalGet()` method to navigate
    to a path on the site. Do check out the method signature for all the options you
    can pass to it. And the first assertion we make is that the page contains the
    text *Our first route* (which is the page title). The parent `assertSession()`
    method returns an instance of `WebAssert` which contains all sorts of methods
    for asserting the presence of elements on the current page in the Mink session.
    One such method is the generic `pageTextContains()` with which we simply check
    that the given text can be found anywhere on the page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是使用`drupalGet()`方法导航到网站上的一个路径。请检查方法签名，看看你可以传递给它所有选项。我们做的第一个断言是页面包含文本*我们的第一个路由*（这是页面标题）。父`assertSession()`方法返回一个`WebAssert`实例，它包含所有
    sorts of 方法，用于断言在Mink会话中当前页面上元素的存在。其中一种方法是通用的`pageTextContains()`，我们只需检查给定的文本是否可以在页面的任何地方找到。
- en: 'Although in quite a lot of cases asserting the presence of a text string is
    enough, you may want to ensure that it is actually the right one (to avoid false
    positives). For example, in our case, we could check that it is really the page
    title that is rendered inside an `<h1>` tag. We can do it like so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多情况下断言文本字符串的存在就足够了，但你可能想确保它确实是正确的（以避免误报）。例如，在我们的案例中，我们可以检查它是否真的是在`<h1>`标签内渲染的页面标题。我们可以这样做：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `elementTextContains()` method can be used to find an element on the page
    based on a locator (CSS selector or xpath) and assert that it contains the specified
    text. In our example we use the CSS selector locator and we try to find the `<h1>`
    element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementTextContains()`方法可以根据定位器（CSS选择器或xpath）在页面上找到元素，并断言它包含指定的文本。在我们的例子中，我们使用CSS选择器定位器，并尝试找到`<h1>`元素。'
- en: If all of that is okay, we proceed with asserting that the actual salutation
    message is present on the page. Unfortunately, we have to duplicate quite some
    code because it is dependent on the time of day. A good homework for you would
    be to extract this logic to a service that determines the message and use this
    service both here and in the actual code. And since we need this message later,
    we also return it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些都正常，我们就继续断言实际的问候消息出现在页面上。不幸的是，我们必须重复相当多的代码，因为它是依赖于一天中的时间的。对你来说，一个好的家庭作业就是将这个逻辑提取到一个确定消息的服务中，并在这个服务和实际代码中使用这个服务。而且由于我们稍后需要这个消息，我们也返回它。
- en: 'Going back to our actual test method, we can proceed knowing that the message
    is showing correctly on the page. And the next thing we want to test is the following:
    if there is a `hello_world.custom_salutation` configuration object with a `salutation`
    value, that is what should be shown. So we programmatically create it. Next, we
    again navigate to the same path (we essentially reload the page) and check that
    the old message is not shown anymore and that the new one is instead.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的实际测试方法，我们可以继续进行，知道消息已经在页面上正确显示。接下来，我们想要测试的是以下内容：如果存在一个具有`salutation`值的`hello_world.custom_salutation`配置对象，那么应该显示的就是这个。因此，我们程序性地创建它。接下来，我们再次导航到相同的路径（我们实际上是在重新加载页面）并检查旧消息不再显示，而新消息则显示出来。
- en: 'So if we actually run this test:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们实际运行这个测试：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '...darn. We get an error:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '...该死。我们得到了一个错误：'
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It's as if we didn't even override the salutation message. But we did.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像我们没有覆盖问候消息一样。但我们确实覆盖了。
- en: The problem is caching. Keep in mind, we are navigating these pages as anonymous
    users and caching is enabled on the site like in normal scenarios. In [Chapter
    11](13739cad-2542-40b4-ae42-9a7f9e159716.xhtml), *Caching*, I made a note about
    this particular problem—the `max-age` property only bubbles up to the page level
    for the dynamic page cache (logged-in users) and not for anonymous users.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于缓存。请记住，我们作为匿名用户在这些页面上导航，并且网站上启用了缓存，就像在正常情况下一样。在[第11章](13739cad-2542-40b4-ae42-9a7f9e159716.xhtml)“缓存”中，我记录了这个问题——`max-age`属性只对动态页面缓存（登录用户）的页面级别有效，而不是对匿名用户。
- en: This is a great example of automated testing shedding light on mistakes we introduce
    while developing and that we don't notice. We most likely wrote our functionality
    while having caching disabled and/or always visiting the page as a logged-in user.
    So it's an easy mistake to make. Luckily, automated testing comes to the rescue.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自动测试如何揭示我们在开发过程中引入的错误，而这些错误我们没有注意到的绝佳例子。我们很可能在禁用缓存和/或始终以登录用户身份访问页面时编写了我们的功能。所以这是一个很容易犯的错误。幸运的是，自动测试来救命。
- en: The solution to this problem can be found using an all-out cache kill switch.
    This means that we need to alter a bit our logic to tell Drupal to never cache
    the pages where our salutation component is shown. This is the price we have to
    pay for the highly dynamic nature of our functionality and it's always a good
    exercise to evaluate if it is worth it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案可以通过使用全出缓存关闭开关来实现。这意味着我们需要稍微修改我们的逻辑，告诉Drupal永远不缓存显示我们的问候语组件的页面。这是我们必须付出的代价，因为我们功能的高度动态性，而且始终是一个好的练习来评估这是否值得。
- en: 'The kill switch is actually easy to use. It''s a service that we need to inject
    into our `HelloWorldSalutation` service:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭开关实际上很容易使用。它是一个我们需要注入到我们的`HelloWorldSalutation`服务中的服务：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And the appropriate *use* statement at the top:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部适当的 *use* 声明：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And at the beginning of both the `getSalutation()` and `getSalutationComponent()`
    methods, we simply have to add this line:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getSalutation()`和`getSalutationComponent()`方法的开始处，我们只需添加这一行：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will tell Drupal's internal page cache to never cache this page. But before
    we go running the test again, we mustn't forget to add the `page_cache_kill_switch`
    service as a dependency to the `HelloWorldSalutation` service inside `hello_world.services.yml`.
    And now if we run this test, we should get a green result.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Drupal的内部页面缓存永远不要缓存这个页面。但在我们再次运行测试之前，我们别忘了将`page_cache_kill_switch`服务作为依赖项添加到`hello_world.services.yml`中的`HelloWorldSalutation`服务中。现在如果我们运行这个测试，我们应该得到一个绿色结果。
- en: Hello World form test
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World 表单测试
- en: 'The second Functional test we will write should test the salutation override
    form itself. In the previous one, we interacted with the configuration API directly
    to make changes to the configuration value. Now we will see whether the form to
    do so actually works. But since we can reuse quite a lot from the previous test,
    and they are very closely related, we can add it to the same class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第二个功能测试应该测试问候语覆盖表单本身。在上一个测试中，我们直接与配置API交互来更改配置值。现在我们将看到执行此操作的表单是否真的起作用。但由于我们可以从上一个测试中重用很多内容，并且它们非常紧密相关，我们可以将其添加到同一个类中：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We start this test in the same way, asserting that the hour dependent message
    is shown. This also proves that each test runs in its own independent environment
    and changes to the configuration in one test has no impact on the other. They
    all start with a blank slate.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以同样的方式开始这个测试，断言显示基于小时的问候消息。这也证明了每个测试都在自己的独立环境中运行，一个测试中的配置更改不会影响另一个。它们都是从一张白纸开始的。
- en: Then we navigate to the configuration form page and assert that we do not have
    access. For this, we use the `statusCodeEquals()` assertion method to check the
    response code. This is good because we need to be logged in with a user that has
    a certain permission.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们导航到配置表单页面并断言我们没有访问权限。为此，我们使用`statusCodeEquals()`断言方法来检查响应代码。这是好的，因为我们需要用具有特定权限的用户登录。
- en: The access restrictions on the configuration form allow any user that has a
    certain permission. For this reason, our test should focus on that permission
    rather than something else that may indirectly include this permission. For example,
    it should not assume that a user with the administrator role has that permission.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 配置表单的访问限制允许任何具有特定权限的用户。因此，我们的测试应该专注于那个权限，而不是可能间接包含这个权限的其他东西。例如，它不应该假设具有管理员角色的用户有那个权限。
- en: So we create a new user account using the handy `drupalCreateUser()` method
    whose first parameter is an array of permissions the user should have. We can
    then use the resulting User entity with the `drupalLogin()` method to log in.
    Under the hood, this navigates to the user login page, submits the form and then
    asserts that everything went well. Now we can go back to the configuration form
    page and should have access— something that we also assert. In addition, we assert
    that we have the page title and that we have the salutation text field HTML element
    on the page. We do so using the `elementExists()` method, using the CSS selector
    locator as we had done in the previous test. Again, check out `WebAssert` for
    all sorts of assertion methods that help you identify things on the page.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用方便的 `drupalCreateUser()` 方法创建一个新的用户账户，其第一个参数是一个数组，包含用户应该拥有的权限。然后我们可以使用
    `drupalLogin()` 方法使用生成的用户实体进行登录。在底层，这将导航到用户登录页面，提交表单，并断言一切顺利。现在我们可以回到配置表单页面，并且应该有访问权限——这也是我们断言的内容。此外，我们断言页面上有页面标题，并且有问候文本字段的
    HTML 元素。我们使用 `elementExists()` 方法这样做，使用 CSS 选择器定位符，就像我们在之前的测试中所做的那样。再次提醒，查看 `WebAssert`
    了解各种断言方法，这些方法可以帮助你识别页面上的内容。
- en: Now it's time to submit the form and override the salutation message. And we
    do this with `drupalPostForm()`, whose most important parameter is an array of
    values to fill in the form elements, keyed by the `name` parameter of the individual
    form HTML element. In our case, we only have one. Do check out the documentation
    of this method for more information on all the things you can do with it. Once
    the form is submitted, the page will reload and we can assert the presence of
    the confirmation message. And finally, we can go back to the `/hello` path and
    assert that the old message is no longer showing but the new overridden one does
    so instead.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提交表单并覆盖问候消息了。我们使用 `drupalPostForm()` 来完成这项任务，其最重要的参数是一个数组，包含要填充表单元素的值，以单个表单
    HTML 元素的 `name` 参数为键。在我们的例子中，我们只有一个。务必查看该方法的文档，以获取有关你可以用它做什么的所有信息。一旦表单提交，页面将重新加载，我们可以断言确认消息的存在。最后，我们可以回到
    `/hello` 路径并断言旧消息不再显示，而是显示新的覆盖消息。
- en: Running the test class again should now include this new test as well and everything
    should be green. And noticeably much slower as two full Drupal installations are
    done. In the next section, we'll bring JavaScript into the picture so that we
    can also test the more dynamic browser integrations. But already you can notice
    that Kernel tests are much faster to run if you don't need to interact with a
    browser.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试类时，应该包括这个新测试，并且所有内容都应该显示为绿色。但速度明显慢得多，因为已经完成了两个完整的 Drupal 安装。在下一节中，我们将引入
    JavaScript，以便我们可以测试更动态的浏览器集成。但已经可以注意到，如果你不需要与浏览器交互，内核测试的运行速度会快得多。
- en: Functional JavaScript tests
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性 JavaScript 测试
- en: The last type of tests we can write in Drupal 8 is the JavaScript-powered functional
    test. FunctionalJavascript tests are useful when we want to test more dynamic
    client-side functionality such as JavaScript behaviors or Ajax interactions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，我们可以编写的最后一种测试类型是 JavaScript 驱动的功能测试。当我们需要测试更动态的客户端功能，如 JavaScript
    行为或 Ajax 交互时，功能 JavaScript 测试非常有用。
- en: They are an extension of the regular Functional tests, but which use WebDriver.
    The latter is an API that allows things like Selenium to control browsers such
    as Chrome or Firefox. Drupal uses Chrome for this so make sure you have Selenium
    installed and working with the Chrome driver. We won't cover this here because
    it depends on your local environment and the current latest versions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是常规功能测试的扩展，但使用 WebDriver。后者是一个 API，允许像 Selenium 这样的工具控制 Chrome 或 Firefox 等浏览器。Drupal
    使用 Chrome 来完成这项任务，所以请确保你已经安装并配置了 Selenium 和 Chrome 驱动程序。我们在这里不会涉及这部分内容，因为它取决于你的本地环境和当前最新版本。
- en: 'Assuming you have Selenium running, we can write some tests. But only after
    we add another environment variable to the PHPUnit configuration file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经运行了 Selenium，我们可以编写一些测试。但只有在我们将另一个环境变量添加到 PHPUnit 配置文件之后：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Time test
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间测试
- en: If you remember from [Chapter 12](ca6e92fc-24fa-41b4-bd57-c3884f9d16b1.xhtml),
    *JavaScript and Ajax API*, we added to our Hello World salutation component a
    little time widget that displays the current hour in real time if the salutation
    is not overridden. This component is powered by JavaScript, and more importantly,
    appended to the page using JavaScript.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得从第 12 章 [JavaScript 和 Ajax API]，我们向 Hello World 问候组件添加了一个小的时间小部件，如果问候没有被覆盖，它会实时显示当前的小时。这个组件由
    JavaScript 驱动，更重要的是，使用 JavaScript 添加到页面中。
- en: Moreover, in the previous section, we wrote a Functional test for the Hello
    World page in which we asserted the presence of the salutation message. However,
    the actual time widget would never show up there because the Mink driver used
    in these types of tests do not support JavaScript. So if we want to test that,
    we need to write a FunctionalJavascript test.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前一节中，我们为 Hello World 页面编写了一个功能测试，其中我们断言了问候信息的存在。然而，实际的时间小部件永远不会出现在那里，因为在这些类型测试中使用的
    Mink 驱动程序不支持 JavaScript。所以如果我们想测试这一点，我们需要编写一个功能 JavaScript 测试。
- en: 'As expected, these types of tests follow the same patterns for the directory
    placement and namespaces. So our first test class can start like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这些类型的测试遵循相同的目录放置和命名空间模式。所以我们的第一个测试类可以开始如下：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By now most of the above code should be clear. However, the base class we extend
    this time is the `WebDriverTestBase` class, which itself is a child of `BrowserTestBase`.
    Interestingly, it doesn't actually add much to the mix apart from configuring
    the test to use Selenium Web Driver and adding a few JavaScript specific helper
    methods. This is to demonstrate that most of the difference between Functional
    and FunctionalJavascript tests is given by the actual Mink driver.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，上述代码中的大部分应该已经很清晰了。然而，我们这次扩展的基类是 `WebDriverTestBase` 类，它本身是 `BrowserTestBase`
    的子类。有趣的是，它实际上并没有添加很多功能，除了配置测试使用 Selenium Web Driver 和添加一些特定的 JavaScript 辅助方法。这是为了说明，功能测试和功能
    JavaScript 测试之间的大部分差异是由实际的 Mink 驱动程序造成的。
- en: Be aware that until Drupal 8.1, the default driver for JavaScript tests was
    Phantom.js so you may find deprecated references to this. We are staying ahead
    of the curve though and using the latest Web Driver API with Selenium and Chrome
    to run our tests.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到 Drupal 8.1，JavaScript 测试的默认驱动程序是 Phantom.js，因此你可能会找到对这个的过时引用。但我们仍然走在曲线的前面，使用最新的
    Web Driver API 与 Selenium 和 Chrome 来运行我们的测试。
- en: One extremely handy addition, though, is the ability to take screenshots. Many
    times when testing frontend interactions, things don't go as we thought and we
    don't understand why. The parent `createScreenshot()` method allows us to save
    a full page screenshot at any given moment, that we can investigate for debugging
    purposes. All we have to do is pass in the name of the file we want to be saved.
    So do check that out.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个极其方便的添加功能是截图功能。很多时候在测试前端交互时，事情并不像我们想象的那样进行，我们也不理解为什么。父 `createScreenshot()`
    方法允许我们在任何给定时刻保存整个页面的截图，我们可以用来进行调试。我们只需要传入我们想要保存的文件名。所以请务必检查一下。
- en: 'Moving on with our test, let''s add the modules we want to be enabled:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行我们的测试，让我们添加我们想要启用的模块：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As expected, the `Hello World` module is enough. And the very simple test method
    can look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Hello World` 模块就足够了。非常简单的测试方法可以看起来像这样：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are using the exact same assertion techniques as before, but because JavaScript
    is enabled, the time widget text should show up now. And like before, we also
    test that if the salutation method is overridden, the time widget does not show
    up.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用与之前完全相同的断言技术，但由于启用了 JavaScript，时间小部件文本现在应该会显示出来。而且，就像之前一样，我们也测试了如果覆盖了问候方法，时间小部件不会显示。
- en: CsvImporter test
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CsvImporter 测试
- en: When learning about Kernel tests, we wrote a test for the `CsvImporter` that
    focused on the importing functionality given an existing Importer configuration
    entity (which we created programmatically). However, another important angle of
    this functionality is the process of creating this configuration entity as we
    are relying on Ajax to dynamically inject form elements related to the selected
    Importer plugin. So let's write a test for that as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习关于内核测试时，我们为 `CsvImporter` 编写了一个测试，该测试侧重于在现有的导入器配置实体（我们通过编程创建）的情况下导入功能。然而，这个功能的重要角度之一是创建这个配置实体的过程，因为我们依赖于
    Ajax 来动态注入与所选导入器插件相关的表单元素。所以，让我们也为此编写一个测试。
- en: 'Just as before, the test class can start with something like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，测试类可以从以下内容开始：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And like always, let''s enable some modules:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们启用一些模块：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You may be wondering why, for example, the `products` module is not in that
    list. At the time of writing, it did not work, as a dependency-related error was
    being thrown when enabling it (missing plugin defined by the `image` module).
    So instead, we can also enable modules directly in our test or `setUp()` methods.
    And that is exactly what we will do.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么，例如，`products`模块不在那个列表中。在撰写本文时，它不起作用，因为启用它时抛出了一个与依赖项相关的错误（缺少由`image`模块定义的插件）。因此，我们也可以直接在我们的测试或`setUp()`方法中启用模块。这正是我们将要做的。
- en: The node module is enabled because it defines the `access content` permission
    which is used by the core `machine_name` form element. And this element is used
    on the Importer entity form so we'll need it in order for the tests to actually
    work.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 节点模块已启用，因为它定义了`access content`权限，该权限被核心`machine_name`表单元素使用。该元素用于导入实体表单，因此我们需要它才能使测试真正工作。
- en: 'Even though we only write one test method, there is quite a bit of preparation
    for it that we might want to reuse elsewhere. Plus, it also looks cleaner to be
    separated from the actual test method. So we can add it to the `setUp()` method
    instead:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只编写了一个测试方法，但为此进行的准备工作相当多，我们可能希望在其他地方重用。此外，将其与实际测试方法分离看起来也更整洁。因此，我们可以将其添加到`setUp()`方法中：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And the new *use* statement:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以及新的*使用*语句：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As expected, the first thing we do is install the `products` and `csv_importer_test`
    modules. We use the `ModuleInstaller` service for that. Then, we do the same thing
    as we did in the previous test—load the test CSV file from the `csv_importer_test`
    module and "upload" it to Drupal creating a new managed File entity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们首先安装`products`和`csv_importer_test`模块。我们使用`ModuleInstaller`服务来这样做。然后，我们像先前的测试中那样做——从`csv_importer_test`模块加载测试CSV文件并将其“上传”到Drupal，创建一个新的管理文件实体。
- en: Then, we create an administrator user account that has the permission needed
    for creating Importer configuration entities, as well as a bundle for the Product
    entity so that we can actually create products. We didn't need to worry about
    the bundle in the previous test because we created the Importer configuration
    programmatically. But now, through the UI, a bundle needs to exist in order to
    select it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个具有创建导入配置实体所需权限的管理员用户账户，以及一个用于产品实体的包，以便我们实际上可以创建产品。在先前的测试中，我们不需要担心包，因为我们以编程方式创建了导入配置。但现在，通过UI，必须存在一个包才能选择它。
- en: 'The resulting File entity, admin user account and ProductType configuration
    entity we store on class properties so we should also define those:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储在类属性上的结果文件实体、管理员用户账户和ProductType配置实体，因此我们也应该定义这些：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And with this we are ready to write our empty test method and start filling
    it up step by step:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们就准备好编写我们的空测试方法并逐步填充它：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can start with the basics:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从基础知识开始：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We navigate to the form for creating importer configuration entities and assert
    that the user does not have access. This is because by default we are browsing
    as anonymous users. Next, we need to log in and try this again:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导航到创建导入配置实体的表单，并断言用户没有访问权限。这是因为默认情况下，我们是以匿名用户身份浏览的。接下来，我们需要登录并再次尝试：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We use the same `drupalLogin()` method and navigate back to the form. This time
    we assert that we have the title as well as various HTML elements—the form elements
    used for creating the entity. Moreover, we also assert that we do not have the
    element for uploading the CSV file because that should only show up if we select
    that we want to use the CSV Importer plugin.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`drupalLogin()`方法并导航回表单。这次我们断言我们有标题以及各种HTML元素——用于创建实体的表单元素。此外，我们还断言我们没有上传CSV文件的元素，因为那应该只在我们选择使用CSV导入插件时显示。
- en: 'It follows we do just that:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们确实这样做了：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using the `getSession()` method, we get the current Mink session, from which
    we can get the object representing the actual page we are looking at. This is
    a `DocumentElement` object which can be traversed, inspected and manipulated in
    all sorts of ways. I recommend you check out the `TraversableElement` class for
    all the available methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getSession()`方法，我们获取当前的Mink会话，从中我们可以获取代表我们正在查看的实际页面的对象。这是一个`DocumentElement`对象，可以通过各种方式遍历、检查和操作。我建议您查看`TraversableElement`类以了解所有可用方法。
- en: One such method is `selectFieldOption()` by which we can specify the locator
    of an HTML select element (ID, name or label) and a value, and it will trigger
    the selection. As you know, this is supposed to make an Ajax request bringing
    in our new form elements. And using `assertWaitOnAjaxRequest()` on the `JSWebAssert`
    object, we can wait until that is complete. Finally, we can assert that the file
    upload field is present on the page.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是`selectFieldOption()`，我们可以指定HTML选择元素的定位器（ID、名称或标签）和一个值，它将触发选择。正如你所知，这应该会触发一个Ajax请求，引入我们的新表单元素。通过在`JSWebAssert`对象上使用`assertWaitOnAjaxRequest()`，我们可以等待它完成。最后，我们可以断言文件上传字段出现在页面上。
- en: 'Next, we proceed with filling in the form:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续填写表单：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The generic `fillField()` method is useful for things like text fields while
    the `checkField()` method is expectedly useful for checkboxes. The locator for
    both is again either the ID, the name or the label of the element.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通用`fillField()`方法对于文本字段等很有用，而`checkField()`方法则预期对复选框很有用。两者的定位器都是元素的ID、名称或标签。
- en: We also use the `assertJsCondition` method to have the execution wait until
    a JavaScript change has happened on the page. And we do this to ensure that the
    entity machine name field has been currently filled in.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`assertJsCondition`方法让执行等待页面上的JavaScript发生变化。我们这样做是为了确保实体机器名字段已被当前填写。
- en: Next, with the help of the stream wrapper of the file that we uploaded, and
    more specifically its `realpath()` method, we attach the file to the field using
    the `attachFileToField()` method. This triggers an Ajax request, which again we
    wait for to complete. Lastly, we use the `pressButton()` method to click on the
    submit button and then assert that we have a confirmation message printed out
    (the form has been saved and the page refreshed).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，借助我们上传的文件的流包装器，更具体地说，是其`realpath()`方法，我们使用`attachFileToField()`方法将文件附加到字段上。这触发了一个Ajax请求，我们再次等待其完成。最后，我们使用`pressButton()`方法点击提交按钮，并断言打印出了确认消息（表单已保存且页面已刷新）。
- en: 'Now to check that the operation actually went through properly:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来检查操作是否真正正确完成：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And the new *use* statements:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以及新的*使用*语句：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We load the configuration entity using the ID we gave it and then assert that
    the resulting object is an instance of the correct interface. This checks we actually
    did save the entity. Next, we load the File entity based on the ID found in the
    Importer configuration entity and assert that it itself also implements the correct
    interface. This proves that the file actually got saved and the configuration
    is correct.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用给定的ID加载配置实体，然后断言生成的对象是正确接口的实例。这检查我们实际上是否保存了实体。接下来，我们根据在导入器配置实体中找到的ID加载文件实体，并断言它本身也实现了正确的接口。这证明了文件实际上已保存且配置正确。
- en: 'Instead of checking the rest of the field values programmatically, in the same
    way, we opt for navigating to the edit form of the Importer entity and asserting
    that the values are pre-filled correctly:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是以相同的方式程序化地检查其余字段值，我们选择导航到导入器实体的编辑表单并断言值已正确预填充：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `fieldValueEquals()` and `checkboxChecked()` methods are handy for checking
    field values. Moreover, we also use the `hasLink()` method to check whether there
    is a link with that name on the page. This is actually to prove the uploaded file
    is shown correctly:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldValueEquals()`和`checkboxChecked()`方法对于检查字段值很有用。此外，我们还使用`hasLink()`方法检查页面上是否存在具有该名称的链接。这实际上是为了证明上传的文件显示正确：'
- en: '![](img/f24f8b1c-23ea-411e-bf80-c6db74f5fcbc.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f24f8b1c-23ea-411e-bf80-c6db74f5fcbc.png)'
- en: 'And finally, since the bundle field is a reference field and not a simple text
    field, we need to construct the value the testing framework actually sees there
    and which is in this pattern: `Label (ID)`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于捆绑字段是一个引用字段而不是简单的文本字段，我们需要构建测试框架实际看到的值，其模式如下：`标签 (ID)`。
- en: 'And with this, our test is complete and we can run it in its entirety:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试就完成了，我们可以运行整个测试：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked a bit about automated testing in Drupal 8\. We started
    with an introduction about why it's useful and actually important to write automated
    tests, and then briefly covered a few of the more popular types of software development
    testing methodologies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要讨论了Drupal 8中的自动化测试。我们首先介绍了编写自动化测试为什么有用且实际上很重要，然后简要概述了几种流行的软件开发测试方法。
- en: Drupal 8 comes with advantages in this field over its predecessor by integrating
    with the PHPUnit framework for all the different types of testing it does. And
    there is a capability for quite a lot of methodologies as we've seen exemplified.
    We have unit tests—the lowest level form of testing that focuses on single architectural
    units and which are by far the fastest running tests of them all. Then we have
    Kernel tests which are integration tests focusing on lower level components and
    their interactions. Next, we have Functional tests which are higher level tests
    that focus on interactions with the browser. And finally, we have the FunctionalJavascript
    tests which extend on the latter and bring Selenium and Chrome into the picture
    to allow for the testing of functionalities that depend on JavaScript.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8通过集成PHPUnit框架，在测试方面相对于其前辈具有优势。正如我们所看到的例子，它具有相当多的方法论能力。我们有单元测试——这是测试中最低级别的形式，它专注于单个架构单元，并且是所有测试中运行速度最快的。然后我们有内核测试，这是集成测试，专注于较低级别的组件及其交互。接下来，我们有功能测试，这是较高级别的测试，专注于与浏览器的交互。最后，我们有功能JavaScript测试，它扩展了后者，并将Selenium和Chrome纳入其中，以便测试依赖于JavaScript的功能。
- en: We've also seen that all these different types of tests are integrated with
    PHPUnit so we can run them all using this tool. This means that all the different
    types of tests follow the same "rules" for registering them with Drupal, namely,
    the directory placement, the namespacing, and the PHPDoc information.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，所有这些不同类型的测试都集成了PHPUnit，因此我们可以使用这个工具运行它们。这意味着所有不同类型的测试在注册到Drupal时都遵循相同的“规则”，即目录放置、命名空间和PHPDoc信息。
- en: The world of automated testing is huge and there can be no single chapter in
    a book that can cover all the different ways something can be tested. For this
    reason, especially for beginners, the journey towards good test coverage is full
    of trial and error when reading Drupal and PHPUnit code and documentation, and
    even has the occasional frustration. But out of this, we get stable code that
    works always and that is protected from regressions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的世界非常庞大，一本书中不可能涵盖所有不同的测试方式。因此，特别是对于初学者来说，在阅读Drupal和PHPUnit代码和文档时，通往良好测试覆盖率的道路充满了试错，甚至偶尔会有挫败感。但从中，我们得到了始终稳定且不受回归影响的代码。
