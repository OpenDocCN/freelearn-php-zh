<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Using Existing PHP Frameworks" id="23MNU1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Using Existing PHP Frameworks</h1></div></div></div><p class="calibre8">In the same way that you wrote your framework with PHP, other people did it too. It did not take long for people to realize that entire frameworks were reusable too. Of course, one man's meat is another man's poison, and as with many other examples in the IT world, loads of frameworks started to appear. You will never hear about most of them, but a handful of these frameworks got quite a lot of users.</p><p class="calibre8">As we write, there are four or five main frameworks that most PHP developers know of: <span class="strong"><strong class="calibre2">Symfony</strong></span>
<a id="id634" class="calibre1"/> and <span class="strong"><strong class="calibre2">Zend Framework</strong></span>
<a id="id635" class="calibre1"/> were the main characters of this last PHP generation, but Laravel is also there, providing a lightweight and fast framework for those who need fewer features. Due to the nature of this book, we will focus on the latest ones, <span class="strong"><strong class="calibre2">Silex</strong></span>
<a id="id636" class="calibre1"/> and <a id="id637" class="calibre1"/>
<span class="strong"><strong class="calibre2">Laravel</strong></span>, as they are quick enough to learn in a chapter—or at least their basics are.</p><p class="calibre8">In this chapter, you will learn about:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The importance of frameworks</li><li class="listitem">Other features of frameworks</li><li class="listitem">Working with Laravel</li><li class="listitem">Writing applications with Silex</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Using Existing PHP Frameworks" id="23MNU1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Reviewing frameworks"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec65" class="calibre1"/>Reviewing frameworks</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 6. Adapting to MVC" href="part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851">Chapter 6</a>, <span class="strong"><em class="calibre12">Adapting to MVC</em></span>, we <a id="id638" class="calibre1"/>barely introduced the idea of frameworks using the MVC design pattern. In fact, we did not explain what a framework is; we just developed a very simple one. If you are looking for a definition, here it is: a framework is the structure that you choose to build your program on. Let's discuss this in more detail.</p></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Using Existing PHP Frameworks" id="23MNU1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Reviewing frameworks">
<div class="book" title="The purpose of frameworks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec123" class="calibre1"/>The purpose of frameworks</h2></div></div></div><p class="calibre8">When <a id="id639" class="calibre1"/>you write an application, you need to add your models, views, and controllers if you use the MVC design pattern, which we really encourage you to do. These three elements, together with the JavaScript and CSS files that complete your views, are the ones that differentiate your application from others. There is no way you can skip on writing them.</p><p class="calibre8">On the other hand, there is a set of classes that, even though you need them for the correct functioning of your application, they are common to all other applications, or at least, they are very similar. Examples of these classes are the ones we have in the <code class="email">src/Core</code> directory, such as the router, the configuration reader, and so on.</p><p class="calibre8">The purpose of frameworks is clear and necessary: they add some structure to your application and connect the different elements of it. In our example, it helped us route the HTTP requests to the correct controller, connect to the database, and generate dynamic HTML as the response. However, the idea that has to strive is the reusability of frameworks. If you had to write the framework each time you start an application, would that be okay?</p><p class="calibre8">So, in order for a framework to be useful, it must be easy to reuse in different environments. This means that the framework has to be downloaded from a source, and it has to be easy to install. Download and install a dependency? It seems Composer is going to be useful again! Even though this was quite different some years ago, nowadays, all the main frameworks can be installed using Composer. We will show you how to in a bit.</p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Using Existing PHP Frameworks" id="23MNU1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Reviewing frameworks">
<div class="book" title="The main parts of a framework"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec124" class="calibre1"/>The main parts of a framework</h2></div></div></div><p class="calibre8">If we open source <a id="id640" class="calibre1"/>our framework so that other developers can make use of it, we need to structure our code in a way that is intuitive. We need to reduce the learning curve as much as we can; nobody wants to spend weeks on learning how to work with a framework.</p><p class="calibre8">As MVC is the de facto web design pattern used in web applications, most frameworks will separate the three layers, model, view, and controller, in three different directories. Depending on the framework, they will be under a <code class="email">src/</code> directory, even though it is quite common to find the views outside of this directory, as we did with our own. Nevertheless, most frameworks will give you enough flexibility to decide where to place each of the layers.</p><p class="calibre8">The rest of the classes that complete the frameworks used to be all grouped in a separate directory—for example, <code class="email">src/Core</code>. It is important to separate these elements from yours so that you do not mix the code and modify a core class unintentionally, thus messing up the whole framework. Even better, this last generation of PHP frameworks used to incorporate the core components as independent modules, which will be required via Composer. In doing so, the framework's <code class="email">composer.json</code> file will require all the different components, such as routers, configuration, database connections, loggers, template engine, and so on, and Composer will download them in the <code class="email">vendor/</code> directory, making them available with the autogenerated autoloader.</p><p class="calibre8">Separating the different components in different codebases has many benefits. First of all, it allows different teams of developers to work in an isolated way with the different components. Maintaining them is also easier as the code is separated enough not to affect each other. Finally, it allows the end user to choose which components to get for his application in an attempt to customize the framework, leaving out those heavy components that are not used.</p><p class="calibre8">Either the<a id="id641" class="calibre1"/> framework is organized in independent modules or everything is together; however, there are always the same<a id="id642" class="calibre1"/> common components, which are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">The router</strong></span>: This is<a id="id643" class="calibre1"/> the class that, given an HTTP request, finds the correct controller, instantiates it, and executes it, returning the HTTP response.</li><li class="listitem"><span class="strong"><strong class="calibre2">The request</strong></span>: This <a id="id644" class="calibre1"/>contains a handful of methods that allows you to access parameters, cookies, headers, and so on. This is mostly used by the router and sent to the controller.</li><li class="listitem"><span class="strong"><strong class="calibre2">The configuration handler</strong></span>: This allows you to get the correct configuration file, read it, and use its<a id="id645" class="calibre1"/> contents to configure the rest of the components.</li><li class="listitem"><span class="strong"><strong class="calibre2">The template engine</strong></span>: This<a id="id646" class="calibre1"/> merges HTML with content from the controller in order to render the template with the response.</li><li class="listitem"><span class="strong"><strong class="calibre2">The logger</strong></span>: This<a id="id647" class="calibre1"/> adds entries to a log file with the errors or other messages that we consider important.</li><li class="listitem"><span class="strong"><strong class="calibre2">The dependency injector</strong></span>: This manages all the dependencies that your classes need. Maybe <a id="id648" class="calibre1"/>the framework does not have a dependency injector, but it has something similar—that is, a service locator—which tries to help you in a similar way.</li><li class="listitem"><span class="strong"><strong class="calibre2">The way you can write and run your unit tests</strong></span>: Most of the time, the frameworks include PHPUnit, but there are more options in the community.</li></ul></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Other features of frameworks"><div class="book" id="24L8G2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec66" class="calibre1"/>Other features of frameworks</h1></div></div></div><p class="calibre8">Most frameworks <a id="id649" class="calibre1"/>have <a id="id650" class="calibre1"/>more than just the features that we described in the previous section, even though these are enough to build simple applications as you already did by yourself. Still, most web applications have a lot more common features, so the frameworks tried to implement generic solutions to each of them. Thanks to this, we do not have to reinvent the wheel with features that virtually all medium and big web applications need to implement. We will try to describe some of the most useful ones so that you have a better idea when choosing a framework.</p></div>

<div class="book" title="Other features of frameworks">
<div class="book" title="Authentication and roles"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec125" class="calibre1"/>Authentication and roles</h2></div></div></div><p class="calibre8">Most <a id="id651" class="calibre1"/>websites enforce users to authenticate in order to <a id="id652" class="calibre1"/>perform some action. The reason for this is to let the system know whether the user trying to perform certain action has the right to do so. Therefore, managing users and their roles is something that you will probably end up implementing in all your web applications. The problem comes when way too many people try to attack your system in order to get the information of other users or performing actions authenticated as someone else, which is called <a id="id653" class="calibre1"/>
<span class="strong"><strong class="calibre2">impersonification</strong></span>. It is for this reason that your authentication and authorization systems should be as secure as possible—a task that is never easy.</p><p class="calibre8">Several frameworks include a pretty secure way of managing users, permissions, and sessions. Most of the time, you can manage this through a configuration file probably by pointing the credentials to a database where the framework can add the user data, your customized roles, and some other customizations. The downside is that each framework has its own way of configuring it, so you will have to dig into the documentation of the framework you are using at this time. Still, it will save you more time than if you had to implement it by yourself.</p></div></div>

<div class="book" title="Other features of frameworks">
<div class="book" title="ORM"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec126" class="calibre1"/>ORM</h2></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Object-relational mapping</strong></span> (<span class="strong"><strong class="calibre2">ORM</strong></span>)<a id="id654" class="calibre1"/> is a technique that converts data from a <a id="id655" class="calibre1"/>database or any other data storage into objects. The main goal is to separate the business logic as much as possible from the structure of the database and to reduce the complexity of your code. When using ORM, you will probably never write a query in MySQL; instead, you will use a chain of methods. Behind the scenes, ORM will write the query with each method invocation.</p><p class="calibre8">There are good and bad things when using ORM. On one hand, you do not have to remember all the SQL syntax all the time and only the correct methods to invoke, which can be easier if you work with an IDE that can autocomplete methods. It is also good to abstract your code from the type of storage system, because even though it is not very common, you might want to change it later. If you use ORM, you probably have to change only the type of connection, but if you were writing raw queries, you would have a lot of work to do in order to migrate your code.</p><p class="calibre8">The arguable downside of using ORM could be that it may be quite difficult to write complicated queries using method chains, and you will end up writing them manually. You are also at the mercy of ORM in order to speed up the performance of your queries, whereas when writing them manually, it is you who can choose better what and how to use when querying. Finally, something that OOP purists complain about quite a lot is that using ORM fills your code with a large amount of dummy objects, similar to the domain objects that you already know.</p><p class="calibre8">As you can see, using <a id="id656" class="calibre1"/>ORM is not always an easy decision, but<a id="id657" class="calibre1"/> just in case you choose to use it, most of the big frameworks include one. Take your time in deciding whether or not to use one in your applications; in case you do, choose wisely which one. You might end up requiring an ORM different from the one that the framework provides.</p></div></div>

<div class="book" title="Other features of frameworks">
<div class="book" title="Cache"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec127" class="calibre1"/>Cache</h2></div></div></div><p class="calibre8">The bookstore is a pretty good<a id="id658" class="calibre1"/> example that may help in describing the cache feature. It has a database of books that is queried every time that someone either lists all the books or asks for the details of a specific one. Most of the time the information related to books will be the same; the only change would be the stock of the books from time to time. We could say that our system has way more reads than writes, where reads means querying for data and writes means updating it. In this kind of system, it seems like a waste of time and resources to access the database each time, knowing that most of the time, we will get the same results. This feeling increases if we do some expensive transformation to the data that we retrieve.</p><p class="calibre8">A <span class="strong"><strong class="calibre2">cache layer</strong></span>
<a id="id659" class="calibre1"/> allows the application to store temporary data in a storage system faster than our database, usually in memory rather than disk. Even though cache systems are getting more complex, they usually allow you to store data by key-value pairs, as in an array.</p><p class="calibre8">The idea is not to access the database for data that we know is the same as the last time we accessed it in order to save time and resources. Implementations can vary quite a lot, but the main flow is as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">You try to access a certain piece of data for the first time. We ask the cache whether a certain key is there, which it is not.</li><li class="listitem" value="2">You query the database, getting back the result. After processing it—and maybe transforming it to your domain objects—you store the result in the cache. The key would be the same you used in step 1, and the value would be the object/array/JSON that you generated.</li><li class="listitem" value="3">You try to access the same piece of data again. You ask the cache whether the key is there; here, it is, so you do not need to access the database at all.</li></ol><div class="calibre13"/></div><p class="calibre8">It seems easy, right? The main problem with caches comes when we need to invalidate a certain key. How and when should we do it? There are a couple of approaches that are worth mentioning:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You will set an expiration time to the key-value pair in the cache. After this time passes, the cache will remove the key-value pair automatically, so you will have to query the database again. Even though this system might work for some applications, it does not for ours. If the stock changes to 0 before the cache expires, the user will see books that they cannot borrow or buy.</li><li class="listitem">The data never <a id="id660" class="calibre1"/>expires, but each time we make a change in the database, we will identify which keys in the cache are affected by this change and then purge them. This is ideal since the data will be in the cache until it is no longer valid, whether this is 2 seconds or 3 weeks. The downside is that identifying these keys could be a hard task depending on your data structure. If you miss deleting some of them, you will have corrupted data in your cache, which is quite difficult to debug and detect.</li></ul></div><p class="calibre8">You can see that cache is a double-edged sword, so we would recommend you to only use it when necessary and not just because your framework comes with it. As with ORM, if you are not convinced by the cache system that your framework provides, using a different one should not be difficult. In fact, your code should not be aware of which cache system you are using except when creating the connection object.</p></div></div>

<div class="book" title="Other features of frameworks">
<div class="book" title="Internationalization"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec128" class="calibre1"/>Internationalization</h2></div></div></div><p class="calibre8">English is not the only <a id="id661" class="calibre1"/>language out there, and you would like to make your website <a id="id662" class="calibre1"/>as accessible as possible. Depending on your target, it would be a good idea to have your website translated to other languages too, but how do you do this? We hope that by now you did not answer: "Copy-pasting all the templates and translating them". This is way too inefficient; when making a little change in a template, you need to replicate the change everywhere.</p><p class="calibre8">There are tools that can be integrated with either controllers and/or template engines in order to translate strings. You usually keep a file for each language that you have, in which you will add all the strings that need to be translated plus their translation. One of the most common formats for this is PO files, in which you have a map of key-value pairs with originally translated pairs. Later on, you will invoke a <code class="email">translate</code> method sending the original string, which will return the translated string depending on the language you selected.</p><p class="calibre8">When writing templates, it might be tiring to invoke the translation each time you want to display a string, but you will end up with only one template, which is much easier to maintain than any other option.</p><p class="calibre8">Usually, internationalization is very much tied to the framework that you use; however, if you have the opportunity to use the system of your choice, pay special attention to its performance, the translation files it uses, and how it manages strings with parameters—that is, how we can ask the system to translate<a id="id663" class="calibre1"/> messages such as "Hello %s, who are you?" in which "%s" needs to be <a id="id664" class="calibre1"/>injected each time.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Types of frameworks" id="25JP21-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec67" class="calibre1"/>Types of frameworks</h1></div></div></div><p class="calibre8">Now that you know <a id="id665" class="calibre1"/>quite a lot about what a framework can offer you, you are in a position to decide what kind of framework you would like to use. In order to make this decision, it might be useful to know what kinds of frameworks are available. This categorization is nothing official, just some guidelines that we offer you to make your choice easier.</p></div>

<div class="book" title="Types of frameworks" id="25JP21-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Complete and robust frameworks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec129" class="calibre1"/>Complete and robust frameworks</h2></div></div></div><p class="calibre8">This type of framework comes <a id="id666" class="calibre1"/>with the whole package. It contains all the <a id="id667" class="calibre1"/>features that we discussed earlier, so it will allow you to develop very complete applications. Usually, these frameworks allow you to create applications very easily with just a few configuration files that define things such as how to connect to a database, what kind of roles you need, or whether you want to use a cache. Other than this, you will just have to add your controllers, views, and models, which saves you a lot of time.</p><p class="calibre8">The problem with these frameworks is the learning curve. Given all the features they contain, you need to spend quite a lot of time on learning how to use each one, which is usually not very pleasant. In fact, most companies looking for web developers require that you have experience with the framework they use; otherwise, it will be a bad investment for them.</p><p class="calibre8">Another thing you should consider when choosing these frameworks is whether they are structured in modules or come as a huge monolith. In the first case, you will be able to choose which modules to use that add a lot of flexibility. On the other hand, if you have to stick with all of them, it might make your application slow even if you do not use all of the features.</p></div></div>

<div class="book" title="Types of frameworks" id="25JP21-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Lightweight and flexible frameworks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec130" class="calibre1"/>Lightweight and flexible frameworks</h2></div></div></div><p class="calibre8">Even when working on a <a id="id668" class="calibre1"/>small application, you would like to use a framework<a id="id669" class="calibre1"/> to save you a lot of time and pain, but you should avoid using one of the larger frameworks as they will be too much to handle for what you really need. In this case, you should choose a lightweight framework, one that contains very few features, similar to what we implemented in previous chapters.</p><p class="calibre8">The benefit of these frameworks is that even though you get the basic features such as routing, you are completely free to implement the login system, cache layer, or internationalization system that suits your specific application better. In fact, you could build a more complete framework using this one as the base and then adding all the complements you need, making it completely customized.</p><p class="calibre8">As you can note, both <a id="id670" class="calibre1"/>types have their pros and cons. It will be up to you to<a id="id671" class="calibre1"/> choose the correct one each time, depending on your needs, the time that you can spend, and the experience that you have with each one.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="An overview of famous frameworks" id="26I9K1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec68" class="calibre1"/>An overview of famous frameworks</h1></div></div></div><p class="calibre8">You already have a good idea <a id="id672" class="calibre1"/>about what a framework can offer and what types there are. Now, it is time to review some of the most important ones out there so that you get an idea of where to start looking for your next PHP web application. Note that with the release of PHP 7, there will be quite a lot of new or improved PHP frameworks. Try to always be in the loop!</p></div>

<div class="book" title="An overview of famous frameworks" id="26I9K1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Symfony 2"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec131" class="calibre1"/>Symfony 2</h2></div></div></div><p class="calibre8">Symfony has been <a id="id673" class="calibre1"/>one of the most favorite frameworks of developers during the last <a id="id674" class="calibre1"/>10 years. After reinventing itself for its version 2, Symfony entered the generation of frameworks by modules. In fact, it is quite common to find other projects using Symfony 2 components mixed up with some other framework as you just need to add the name of the module in your Composer file to use it.</p><p class="calibre8">You can start applications with Symfony 2 by just executing a command. Symfony 2 creates all the directories, empty configuration files, and so on ready for you. You can also add empty controllers from the command line. They use Doctrine 2 as ORM, which is probably one of the most reliable ORMs that PHP can offer nowadays. For the template engine, you will find Twig, which is the same as what we used in our framework.</p><p class="calibre8">In general, this is a very attractive framework with a huge community behind it giving support; plus, a lot of companies also use it. It is always worth at least checking the list of modules in case you do not want to use the whole framework but want to take advantage of some bits of it.</p></div></div>

<div class="book" title="An overview of famous frameworks" id="26I9K1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Zend Framework 2"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec132" class="calibre1"/>Zend Framework 2</h2></div></div></div><p class="calibre8">The second <a id="id675" class="calibre1"/>big PHP framework, at least since last year, is Zend Framework 2. As<a id="id676" class="calibre1"/> with Symfony, it has been out there for quite a long time too. Also, as with any other modern framework, it is built in an OOP way, trying to implement all the good design patterns used for web applications. It is composed of multiple components that you can reuse in other projects, such as their well-known authentication system. It lacks some elements, such as a template engine—usually they mix PHP and HTML—and ORM, but you can easily integrate the ones that you prefer.</p><p class="calibre8">There is a lot of work going on in order to release Zend Framework 3, which will come with support for PHP 7, performance improvements, and some other new components. We recommend you to keep an eye on it; it could be a good candidate.</p></div></div>

<div class="book" title="An overview of famous frameworks" id="26I9K1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Other frameworks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec133" class="calibre1"/>Other frameworks</h2></div></div></div><p class="calibre8">Even though Symfony and Zend Framework are the two big players, more and more PHP frameworks have appeared in these last years, evolving quite fast and bringing to the game more interesting features. Names such as CodeIgniter, Yii, PHPCake, and others will start to sound familiar as soon as you start browsing PHP projects. As some of them came into play later than Symfony and Zend Framework, they implement some new features that the others do not have, such as components related to JavaScript and jQuery, integration with Selenium for UI testing, and others.</p><p class="calibre8">Even though it is always a good thing to have diversification simply because you will probably get exactly what you need from one or the other, be smart when choosing your framework. The community plays an important role here because if you have any problem, it will help you to fix it or you can just help evolve the framework with each new PHP release.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The Laravel framework"><div class="book" id="27GQ62-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec69" class="calibre1"/>The Laravel framework</h1></div></div></div><p class="calibre8">Even though<a id="id677" class="calibre1"/> Symfony and Zend Framework have been the big players for quite a long time, during this last couple of years, a third framework came into play that has grown in popularity so much that nowadays it is the favorite framework among developers. Simplicity, elegant code, and high speed of development are the trump cards of this "framework for artisans". In this section, you will have a glance at what Laravel can do, taking the first steps to create a very simple application.</p></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Installation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec134" class="calibre1"/>Installation</h2></div></div></div><p class="calibre8">Laravel comes with a set of <a id="id678" class="calibre1"/>command-line tools that will make your life easier. Because of this, it is recommended to install it globally instead of per project—that is, to have Laravel as another program in your environment. You can still do this with Composer by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer global require "laravel/installer"</strong></span>
</pre></div><p class="calibre8">This command should download the Laravel installer to <code class="email">~/.composer/vendor</code>. In order to be able to use the executable from the command line, you will need to run something similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ sudo ln -s ~/.composer/vendor/bin/laravel /usr/bin/laravel</strong></span>
</pre></div><p class="calibre8">Now, you are able to use the <code class="email">laravel</code> command. To ensure that everything went all right, just run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ laravel –version</strong></span>
</pre></div><p class="calibre8">If everything went OK, this should output the version installed.</p></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Project setup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec135" class="calibre1"/>Project setup</h2></div></div></div><p class="calibre8">Yes, we know. Every single <a id="id679" class="calibre1"/>tutorial starts by creating a blog. However, we are building web applications, and this is the easiest approach we can take that adds some value to you. Let's start then; execute the following command wherever you want to add your application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ laravel new php-blog</strong></span>
</pre></div><p class="calibre8">This command will output something similar to what Composer does, simply because it fetches dependencies using Composer. After a few seconds, the application will hopefully tell you that everything was installed successfully and that you are ready to go.</p><p class="calibre8">Laravel created a new <code class="email">php-blog</code> directory with quite a lot of content. You should have something similar to the directory structure shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Project setup" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Let's set up the database. The<a id="id680" class="calibre1"/> first thing you should do is update the <code class="email">.env</code> file with the correct database credentials. Update the <code class="email">DB_DATABASE</code> values with your own; here's an example:</p><div class="informalexample"><pre class="programlisting">DB_HOST=localhost
DB_DATABASE=php_blog
DB_USERNAME=root
DB_PASSWORD=</pre></div><p class="calibre8">You will also need to create the <code class="email">php_blog</code> database. Do it with just one command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ mysql -u root -e "CREATE SCHEMA php_blog"</strong></span>
</pre></div><p class="calibre8">With Laravel, you have a migrations system; that is, you keep all the database schema changes under <code class="email">database/migrations</code> so that anyone else using your code can quickly set up their database. The first step is to run the following command, which will create a migrations file for the <code class="email">blogs</code> table:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan make:migration create_posts_table --create=posts</strong></span>
</pre></div><p class="calibre8">Open the generated file, which should be something similar to <code class="email">database/migrations/&lt;date&gt;_create_posts_table.php</code>. The <code class="email">up</code> method defines the table blogs with an autoincremental ID and timestamp field. We would like to add a title, the content of the <a id="id681" class="calibre1"/>post, and the user ID that created it. Replace the <code class="email">up</code> method with the following:</p><div class="informalexample"><pre class="programlisting">public function up()
{
    Schema::create('posts', function (Blueprint $table) {
<span class="strong"><strong class="calibre2">        $table-&gt;increments('id');</strong></span>
<span class="strong"><strong class="calibre2">        $table-&gt;timestamps();</strong></span>
<span class="strong"><strong class="calibre2">        $table-&gt;string('title');</strong></span>
<span class="strong"><strong class="calibre2">        $table-&gt;text('content');</strong></span>
<span class="strong"><strong class="calibre2">        $table-&gt;integer('user_id')-&gt;unsigned();</strong></span>
<span class="strong"><strong class="calibre2">        $table-&gt;foreign('user_id')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;references('id')-&gt;on('users');</strong></span>
    });
}</pre></div><p class="calibre8">Here, the title will be a string, whereas the content is a text. The difference is in the length of these fields, string being a simple <code class="email">VARCHAR</code> and text a <code class="email">TEXT</code> data type. For the user ID we defined <code class="email">INT UNSIGNED</code>, which references the <code class="email">id</code> field of the <code class="email">users</code> table. Laravel already defined the <code class="email">users</code> table when creating the project, so you do not have to worry about it. If you are interested in how it looks, check the <code class="email">database/migrations/2014_10_12_000000_create_users_table.php</code> file. You will note that a user is composed by an ID, a name, the unique e-mail, and the password.</p><p class="calibre8">So far, we have just written the migration files. In order to apply them, you need to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan migrate</strong></span>
</pre></div><p class="calibre8">If everything went as expected, you should have a <code class="email">blogs</code> table now similar to the following:</p><div class="mediaobject"><img src="../images/00037.jpeg" alt="Project setup" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">To finish with all the preparations, we need to create a model for our <code class="email">blogs</code> table. This model will extend from<a id="id682" class="calibre1"/> <span class="strong"><strong class="calibre2">Illuminate\Database\Eloquent\Model</strong></span>, which is the ORM that Laravel uses. To <a id="id683" class="calibre1"/>generate this model automatically, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan make:model Post</strong></span>
</pre></div><p class="calibre8">The name of the model should be the same as that of the database table but in singular. After running this command, you can find the empty model in <code class="email">app/Post.php</code>.</p></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Adding the first endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec136" class="calibre1"/>Adding the first endpoint</h2></div></div></div><p class="calibre8">Let's add a quick<a id="id684" class="calibre1"/> endpoint just to understand how routes work and how to link controllers with templates. In order to avoid database access, let's build the add new post view, which will display a form that allows the user to add a new post with a title and text. Let's start by adding the route and controller. Open the <code class="email">app/Http/routes.php</code> file and add the following:</p><div class="informalexample"><pre class="programlisting">Route::group(['middleware' =&gt; ['web']], function () {
<span class="strong"><strong class="calibre2">    Route::get('/new', function () {</strong></span>
<span class="strong"><strong class="calibre2">        return view('new');</strong></span>
<span class="strong"><strong class="calibre2">    });</strong></span>
});</pre></div><p class="calibre8">These three very simple lines say that for the <code class="email">/new</code> endpoint, we want to reply with the <code class="email">new</code> view. Later on, we will complicate things here in the controller, but for now, let's focus on the views.</p><p class="calibre8">Laravel uses Blade as the template engine instead of Twig, but the way they work is quite similar. They can also define layouts from where other templates can extend. The place for your layouts is in <code class="email">resources/views/layouts</code>. Create an <code class="email">app.blade.php</code> file with the following content inside this directory, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;PHP Blog&lt;/title&gt;
<span class="strong"><strong class="calibre2">    &lt;link rel="stylesheet" href="{{ URL::asset('css/layout.css') }}" type="text/css"&gt;</strong></span>
<span class="strong"><strong class="calibre2">    @yield('css')</strong></span>
&lt;/head&gt;
&lt;body&gt;
&lt;div class="navbar"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="/new"&gt;New article&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="/"&gt;Articles&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="content"&gt;
<span class="strong"><strong class="calibre2">@yield('content')</strong></span>
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">This is just a normal<a id="id685" class="calibre1"/> layout with a title, some CSS, and an <code class="email">ul</code> list of sections in the body, which will be used as the navigation bar. There are two important elements to note here other than the HTML code that should already sound familiar:</p><div class="book"><ul class="itemizedlist"><li class="listitem">To define a block, Blade uses the <code class="email">@yield</code> annotation followed by the name of the block. In our layout, we defined two blocks: <code class="email">css</code> and <code class="email">content</code>.</li><li class="listitem">There is a feature that allows you to build URLs in templates. We want to include the CSS file in <code class="email">public/css/layout.css</code>, so we will use <code class="email">URL::asset</code> to build this URL. It is also helpful to include JS files.</li></ul></div><p class="calibre8">As you saw, we included a <code class="email">layout.css</code> file. CSS and JS files are stored under the <code class="email">public</code> directory. Create yours in <code class="email">public/css/layout.css</code> with the following code:</p><div class="informalexample"><pre class="programlisting">.content {
    position: fixed;
    top: 50px;
    width: 100%
}
.navbar ul {
    position: fixed;
    top: 0;
    width: 100%;
    list-style-type: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #333;
}
.navbar li {
    float: left;
    border-right: 1px solid #bbb;
}
.navbar li:last-child {
    border-right: none;
}
.navbar li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
}
.navbar li a:hover {
    background-color: #111;
}</pre></div><p class="calibre8">Now, we can focus on<a id="id686" class="calibre1"/> our view. Templates are stored in <code class="email">resources/views</code>, and, as with layouts, they need the <code class="email">.blade.php</code> file extension. Create your view in <code class="email">resources/views/new.blade.php</code> with the following content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">@extends('layouts.app')</strong></span>

<span class="strong"><strong class="calibre2">@section('css')</strong></span>
    &lt;link rel="stylesheet" href="{{ URL::asset('css/new.css') }}" type="text/css"&gt;
<span class="strong"><strong class="calibre2">@endsection</strong></span>

@section('content')
    &lt;h2&gt;Add new post&lt;/h2&gt;
    &lt;form method="post" action="/new"&gt;
        &lt;div class="component"&gt;
            &lt;label for="title"&gt;Title&lt;/label&gt;
            &lt;input type="text" name="title"/&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;label&gt;Text&lt;/label&gt;
            &lt;textarea rows="20" name="content"&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;button type="submit"&gt;Save&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
@endsection</pre></div><p class="calibre8">The syntax is quite<a id="id687" class="calibre1"/> intuitive. This template extends from the layouts' one and defines two sections or blocks: <code class="email">css</code> and <code class="email">content</code>. The CSS file included follows the same format as the previous one. You can create it in <code class="email">public/css/new.css</code> with content similar to the following:</p><div class="informalexample"><pre class="programlisting">label {
    display: block;
}
input {
    width: 80%;
}
button {
    font-size: 30px;
    float: right;
    margin-right: 20%;
}
textarea {
    width: 80%;
}
.component {
    padding: 10px;
}</pre></div><p class="calibre8">The rest of the template just defines the POST form pointing to the same URL with title and text fields. Everything is ready to test it in your browser! Try accessing <code class="email">http://localhost:8080/new</code> or the port number of your choice. You should see something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="Adding the first endpoint" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Managing users"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec137" class="calibre1"/>Managing users</h2></div></div></div><p class="calibre8">As explained before, user<a id="id688" class="calibre1"/> authentication and authorization is one of the <a id="id689" class="calibre1"/>features that most frameworks contain. Laravel makes our lives very easy by providing the user model and the registration and authentication controllers. It is quite easy to make use of them: you just need to add the routes pointing to the already existing controllers and add the views. Let's begin.</p><p class="calibre8">There are five routes that you need to consider here. There are two that belong to the registration step, one to get the form and another one for the form to submit the information provided by the user. The other three are related to the authentication part: one to get the form, one to post the form, and one for the logout. All five of them are included in the <code class="email">Auth\AuthController</code> class. Add to your <code class="email">routes.php</code> file the following routes:</p><div class="informalexample"><pre class="programlisting">// Registration routes...
Route::get('auth/register', 'Auth\AuthController@getRegister');
Route::post('auth/register', 'Auth\AuthController@postRegister');

// Authentication routes...
Route::get('/login', 'Auth\AuthController@getLogin');
Route::post('login', 'Auth\AuthController@postLogin');
Route::get('logout', 'Auth\AuthController@getLogout');</pre></div><p class="calibre8">Note how we defined these routes. As opposed to the one that we created previously, the second argument of these is a string with the concatenation of the controller's class name and method. This is a better way to create routes because it separates the logic to a different class that can later be reused and/or unit tested.</p><p class="calibre8">If you are interested, you <a id="id690" class="calibre1"/>can browse the code for this controller. You <a id="id691" class="calibre1"/>will find a complex design, where the functions the routes will invoke are actually part of two traits that the <code class="email">AuthController</code> class uses: <code class="email">RegistersUsers</code> and <code class="email">AuthenticatesUsers</code>. Checking these methods will enable you to understand what goes on behind the scenes.</p><p class="calibre8">Each <code class="email">get</code> route expects a view to render. For the user's registration, we need to create a template in <code class="email">resources/views/auth/register.blade.php</code>, and for the login view, we need a template in <code class="email">resources/views/auth/login.blade.php</code>. As soon as we send the correct POST parameters to the correct URL, we can add any content that we think necessary.</p><div class="book" title="User registration"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec17" class="calibre1"/>User registration</h3></div></div></div><p class="calibre8">Let's start with the <a id="id692" class="calibre1"/>registration form; this form needs four POST parameters: name, e-mail, password, and password confirmation, and as the route says, we need to submit it to <code class="email">/auth/register</code>. The template could look similar to the following:</p><div class="informalexample"><pre class="programlisting">@extends('layouts.app')

@section('css')
    &lt;link rel="stylesheet" href="{{ URL::asset('css/register.css') }}" type="text/css"&gt;
@endsection

@section('content')
    &lt;h2&gt;Account registration&lt;/h2&gt;

    &lt;form method="post" action="/auth/register"&gt;
        {{ csrf_field() }}
        &lt;div class="component"&gt;
            &lt;label for="name"&gt;Name&lt;/label&gt;
<span class="strong"><strong class="calibre2">            &lt;input type="text" name="name" </strong></span>
<span class="strong"><strong class="calibre2">                   value="{{ old('name') }}" /&gt;</strong></span>
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;label&gt;Email&lt;/label&gt;
<span class="strong"><strong class="calibre2">            &lt;input type="email" name="email"</strong></span>
<span class="strong"><strong class="calibre2">                   value="{{ old('email') }}"/&gt;</strong></span>
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input type="password" name="password" /&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;label&gt;Password confirmation&lt;/label&gt;
            &lt;input type="password" name="password_confirmation" /&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;button type="submit"&gt;Create&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
@endsection</pre></div><p class="calibre8">This template is quite<a id="id693" class="calibre1"/> similar to the form for new posts: it extends the layout, adds a CSS file, and populates the content section with a form. The new addition here is the use of the <code class="email">old</code> function that retrieves the value submitted on the previous request in case that the form was not valid and we showed it back to the user.</p><p class="calibre8">Before we try it, we need to add a <code class="email">register.css</code> file with the styles for this form. A simple one could be as follows:</p><div class="informalexample"><pre class="programlisting">div.content {
    text-align: center;
}
label {
    display: block;
}
input {
    width: 250px;
}
button {
    font-size: 20px;
}
.component {
    padding: 10px;
}</pre></div><p class="calibre8">Finally, we should edit the layout in order to add a link on the menu pointing to the registration and login pages. This is as simple as adding the following <code class="email">li</code> elements at the end of the <code class="email">ul</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;li class="right"&gt;&lt;a href="/auth/register"&gt;Sign up&lt;/a&gt;&lt;/li&gt;
&lt;li class="right"&gt;&lt;a href="/login"&gt;Sign in&lt;/a&gt;&lt;/li&gt;</pre></div><p class="calibre8">Add also the style for the <code class="email">right</code> class at the end of <code class="email">layout.css</code>:</p><div class="informalexample"><pre class="programlisting">div.alert {
    color: red;
}</pre></div><p class="calibre8">To make things even more <a id="id694" class="calibre1"/>useful, we could add the information for what went wrong when submitting the form. Laravel flashes the errors into the session, and they can be accessed via the <code class="email">errors</code> template variable. As this is common to all forms and not only to the registration one, we could add it to the <code class="email">app.blade.php</code> layout, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="content"&gt;
<span class="strong"><strong class="calibre2">    @if (count($errors) &gt; 0)</strong></span>
<span class="strong"><strong class="calibre2">        &lt;div class="alert"&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;strong&gt;Whoops! Something went wrong!&lt;/strong&gt;</strong></span>
<span class="strong"><strong class="calibre2">            @foreach ($errors-&gt;all() as $error)</strong></span>
<span class="strong"><strong class="calibre2">                &lt;p&gt;{{ $error }}&lt;/p&gt;</strong></span>
<span class="strong"><strong class="calibre2">            @endforeach</strong></span>
<span class="strong"><strong class="calibre2">        &lt;/div&gt;</strong></span>
<span class="strong"><strong class="calibre2">    @endif</strong></span>
@yield('content')</pre></div><p class="calibre8">In this piece of code, we will use Blade's <code class="email">@if</code> conditional and <code class="email">@foreach</code> loop. The syntax is the same as PHP; the only difference is the <code class="email">@</code> prefix.</p><p class="calibre8">Now, we are ready to go. Launch your application and click on the registration link on the right-hand side of the menu. Attempt to submit the form, but leave some fields blank so that we can note how the errors are displayed. The result should be something similar to this:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="User registration" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">One thing that we should<a id="id695" class="calibre1"/> customize is where the user will be redirected once the registration is successful. In this case, we can redirect them to the login page. In order to achieve this, you need to change the value of the <code class="email">$redirectTo</code> property of <code class="email">AuthController</code>. So far, we only have the new post page, but later, you could add any path that you want via the following:</p><div class="informalexample"><pre class="programlisting">protected $redirectPath= '/new;</pre></div></div><div class="book" title="User login"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec18" class="calibre1"/>User login</h3></div></div></div><p class="calibre8">The user's login has a few<a id="id696" class="calibre1"/> more changes other than the registration. We not only need to add the login view, we should also modify the menu in the layout in order to acknowledge the authenticated user, remove the register link, and add a logout one. The template, as mentioned earlier, has to be saved in <code class="email">resources/views/auth/login.blade.php</code>. The form needs an e-mail and password and optionally a checkbox for the <span class="strong"><em class="calibre12">remember me</em></span> functionality. An example could be the following:</p><div class="informalexample"><pre class="programlisting">@extends('layouts.app')

@section('css')
    &lt;link rel="stylesheet" href="{{ URL::asset('css/register.css') }}" type="text/css"&gt;
@endsection

@section('content')
    &lt;h2&gt;Login&lt;/h2&gt;

    &lt;form method="POST" action="/login"&gt;
        {!! csrf_field() !!}
        &lt;div class="component"&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input type="email" name="email"
                   value="{{ old('email') }}"&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input type="password" name="password"&gt;
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;input class="checkbox" type="checkbox" name="remember"&gt;                
            Remember Me
        &lt;/div&gt;
        &lt;div class="component"&gt;
            &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
@endsection</pre></div><p class="calibre8">The layout has to be<a id="id697" class="calibre1"/> changed slightly. Where we displayed the links to register and log in users, now we need to check whether there is a user already authenticated; if so, we should rather show a logout link. You can get the authenticated user through the <code class="email">Auth::user()</code> method even from the view. If the result is not empty, it means that the user was authenticated successfully. Change the two links using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ul&gt;
    &lt;li&gt;&lt;a href="/new"&gt;New article&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/"&gt;Articles&lt;/a&gt;&lt;/li&gt;
<span class="strong"><strong class="calibre2">    @if (Auth::user() !== null)</strong></span>
<span class="strong"><strong class="calibre2">        &lt;li class="right"&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;a href="/logout"&gt;Logout&lt;/a&gt;</strong></span>
<span class="strong"><strong class="calibre2">        &lt;/li&gt;</strong></span>
<span class="strong"><strong class="calibre2">    @else</strong></span>
<span class="strong"><strong class="calibre2">        &lt;li class="right"&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;a href="/auth/register"&gt;Sign up&lt;/a&gt;</strong></span>
<span class="strong"><strong class="calibre2">        &lt;/li&gt;</strong></span>
<span class="strong"><strong class="calibre2">        &lt;li class="right"&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;a href="/login"&gt;Sign in&lt;/a&gt;</strong></span>
<span class="strong"><strong class="calibre2">        &lt;/li&gt;</strong></span>
<span class="strong"><strong class="calibre2">    @endif</strong></span>
&lt;/ul&gt;</pre></div></div><div class="book" title="Protected routes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec19" class="calibre1"/>Protected routes</h3></div></div></div><p class="calibre8">This last part of the user<a id="id698" class="calibre1"/> management session is probably the most important one. One of the main goals when authenticating users is to authorize them to certain content—that is, to allow them to visit certain pages that unauthenticated users cannot. In Laravel, you can define which routes are protected in this way by just adding the <code class="email">auth</code> middleware. Update the new post route with the following code:</p><div class="informalexample"><pre class="programlisting">Route::get('/new', ['middleware' =&gt; 'auth', function () {
    return view('new');
}]);</pre></div><p class="calibre8">Everything is ready! Try to access the new post page after logging out; you will be redirected automatically to the login page. Can you feel how powerful a framework can be?</p></div></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Setting up relationships in models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec138" class="calibre1"/>Setting up relationships in models</h2></div></div></div><p class="calibre8">As we mentioned<a id="id699" class="calibre1"/> before, Laravel comes with an ORM, Eloquent ORM, which makes dealing with models a very easy task. In our simple database, we defined one table for posts, and we already had another one for users. Posts contain the ID of the user that owns it—that is, <code class="email">user_id</code>. It is good practice to use the singular of the name of the table followed by <code class="email">_id</code> so that Eloquent will know where to look. This was all we did regarding the foreign key.</p><p class="calibre8">We should also mention this relationship on the model side. Depending on the type of the relationship (one to one, one to many, or many to many), the code will be slightly different. In our case, we have a one-to-many relationship because one user can have many posts. To say so in Laravel, we need to update both the <code class="email">Post</code> and the <code class="email">User</code> models. The <code class="email">User</code> model needs to specify that it has many posts, so you need to add a <code class="email">posts</code> method with the following content:</p><div class="informalexample"><pre class="programlisting">public function posts() {
    return $this-&gt;hasMany('App\Post');
}</pre></div><p class="calibre8">This method says that the model for users has many posts. The other change that needs to be made in <code class="email">Post</code> is similar: we need to add a <code class="email">user</code> method that defines the relationship. The method should be similar to this one:</p><div class="informalexample"><pre class="programlisting">public function user() {
    return $this-&gt;belongsTo('App\User');
}</pre></div><p class="calibre8">It looks like very <a id="id700" class="calibre1"/>little, but this is the whole configuration that we need. In the next section, you will see how easy it is to save and query using these two models.</p></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Creating complex controllers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec139" class="calibre1"/>Creating complex controllers</h2></div></div></div><p class="calibre8">Even though the title of this <a id="id701" class="calibre1"/>section mentions complex controllers, you will note that we can create complete and powerful controllers with very little code. Let's start by adding the code that will manage the creation of posts. This controller needs to be linked to the following route:</p><div class="informalexample"><pre class="programlisting">Route::post('/new', 'Post\PostController@createPost');</pre></div><p class="calibre8">As you can imagine, now, we need to create the <code class="email">Post\PostController</code> class with the <code class="email">createPost</code> method in it. Controllers should be stored in <code class="email">app/Http/Controllers</code>, and if they can be organized in folders, it would be even better. Save the following class in <code class="email">app/Http/Controllers/Post/PostController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Http\Controllers\Post;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;
use App\Post;

class PostController extends Controller {

    public function createPost(Request $request) {
        
    }
}</pre></div><p class="calibre8">So far, the only two things we can note from this class are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Controllers extend from the <code class="email">App\Http\Controllers\Controller</code> class, which contains some general helpers for all the controllers.</li><li class="listitem">Methods of controllers can get the <code class="email">Illuminate\Http\Request</code> argument as the user's request. This object will contain elements such as the posted parameters, cookies, and so on. This is very similar to the one we created in our own application.</li></ul></div><p class="calibre8">The first thing we <a id="id702" class="calibre1"/>need to do in this kind of controller is check whether the parameters posted are correct. For this, we will use the following code:</p><div class="informalexample"><pre class="programlisting">public function createPost(Request $request) {
<span class="strong"><strong class="calibre2">    $validator = Validator::make($request-&gt;all(), [</strong></span>
<span class="strong"><strong class="calibre2">        'title' =&gt; 'required|max:255',</strong></span>
<span class="strong"><strong class="calibre2">        'content' =&gt; 'required|min:20',</strong></span>
<span class="strong"><strong class="calibre2">    ]);</strong></span>

<span class="strong"><strong class="calibre2">    if ($validator-&gt;fails()) {</strong></span>
<span class="strong"><strong class="calibre2">        return redirect()-&gt;back()</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;withInput()</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;withErrors($validator);</strong></span>
    }
}</pre></div><p class="calibre8">The first thing we did is create a validator. For this, we used the <code class="email">Validator::make</code> function and sent two arguments: the first one contains all the parameters from the request, and the second one is an array with the expected fields and their constraints. Note that we expect two required fields: <code class="email">title</code> and <code class="email">content</code>. Here, the first one can be up to 255 characters long, and the second one needs to be at least 20 characters long.</p><p class="calibre8">Once the <code class="email">validator</code> object is created, we can check whether the data posted by the user matches the requirements with the <code class="email">fails</code> method. If it returns <code class="email">true</code>—that is, the validation fails—we will redirect the user back to the previous page with <code class="email">redirect()-&gt;back()</code>. To perform this invocation, we will add two more method calls: <code class="email">withInput</code> will send the submitted values so that we can display them again, and <code class="email">withErrors</code> will send the errors the same way <code class="email">AuthController</code> did.</p><p class="calibre8">At this point, it would be helpful to the user if we show the previously submitted title and text in case the post is not valid. For this, use the already known <code class="email">old</code> method in the view:</p><div class="informalexample"><pre class="programlisting">{{--...--}}
    &lt;input type="text" name="title" 
<span class="strong"><strong class="calibre2">           value="{{ old('title') }}"/&gt;</strong></span>
&lt;/div&gt;
&lt;div class="component"&gt;
    &lt;label&gt;Text&lt;/label&gt;
    &lt;textarea rows="20" name="content"&gt;
<span class="strong"><strong class="calibre2">        {{ old('content') }}</strong></span>
    &lt;/textarea&gt;
{{--...--}}</pre></div><p class="calibre8">At this point, we can already test how the controller behaves when the post does not match the required validations. If you miss any of the parameters or they do not have correct lengths, you will get an error page similar to the following one:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Creating complex controllers" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Let's now add the <a id="id703" class="calibre1"/>logic to save the post in case it is valid. If you remember the interaction with the models from our previous application, you will be gladly surprised at how easy it is to work with them here. Take a look at the following:</p><div class="informalexample"><pre class="programlisting">public function createPost(Request $request) {
    $validator = Validator::make($request-&gt;all(), [
        'title' =&gt; 'required|max:255',
        'content' =&gt; 'required|min:20',
    ]);

    if ($validator-&gt;fails()) {
        return redirect()-&gt;back()
            -&gt;withInput()
            -&gt;withErrors($validator);
    }

<span class="strong"><strong class="calibre2">    $post = new Post();</strong></span>
<span class="strong"><strong class="calibre2">    $post-&gt;title = $request-&gt;title;</strong></span>
<span class="strong"><strong class="calibre2">    $post-&gt;content = $request-&gt;content;</strong></span>

<span class="strong"><strong class="calibre2">    Auth::user()-&gt;posts()-&gt;save($post);</strong></span>

<span class="strong"><strong class="calibre2">    return redirect('/new');</strong></span>
}</pre></div><p class="calibre8">The first thing we will do is create a <code class="email">post</code> object setting the title and content from the request values. Then, given the result of <code class="email">Auth::user()</code>, which gives us the instance of the currently authenticated user model, we will save the post that we just created through <code class="email">posts()-&gt;save($post)</code>. If we wanted to save the post without the information of the user, we could use <code class="email">$post-&gt;save()</code>. Really, that is all.</p><p class="calibre8">Let's quickly add <a id="id704" class="calibre1"/>another endpoint to retrieve the list of posts for a given user so that we can take a look at how Eloquent ORM allows us to fetch data easily. Add the following route:</p><div class="informalexample"><pre class="programlisting">Route::get('/', ['middleware' =&gt; 'auth', function () {
    $posts = Auth::user()
        -&gt;posts()
        -&gt;orderBy('created_at')
        -&gt;get();
    return view('posts', ['posts' =&gt; $posts]);
}]);</pre></div><p class="calibre8">The way we retrieve data is very similar to how we save it. We need the instance of a model—in this case, the authenticated user—and we will add a concatenation of method invocations that will internally generate the query to execute. In this case, we will ask for the posts ordered by the creation date. In order to send information to the view, we need to pass a second argument, which will be an array of parameter names and values.</p><p class="calibre8">Add the following template as <code class="email">resources/views/posts.blade.php</code>, which will display the list of posts for the authenticated user as a table. Note how we will use the <code class="email">$post</code> object, which is an instance of the model, in the following code:</p><div class="informalexample"><pre class="programlisting">@extends('layouts.app')

@section('css')
    &lt;link rel="stylesheet" href="{{ URL::asset('css/posts.css') }}" type="text/css"&gt;
@endsection

@section('content')
    &lt;h2&gt;Your posts&lt;/h2&gt;

    &lt;table&gt;
    @foreach ($posts as $post)
        &lt;tr&gt;
<span class="strong"><strong class="calibre2">            &lt;td&gt;{{ $post-&gt;title }}&lt;/td&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;td&gt;{{ $post-&gt;created_at }}&lt;/td&gt;</strong></span>
<span class="strong"><strong class="calibre2">            &lt;td&gt;{{ str_limit($post-&gt;content, 100) }}&lt;/td&gt;</strong></span>
        &lt;/tr&gt;
    @endforeach
    &lt;/table&gt;
@endsection</pre></div><p class="calibre8">The lists of posts are <a id="id705" class="calibre1"/>finally displayed. The result should be something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Creating complex controllers" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div class="book" title="The Laravel framework">
<div class="book" title="Adding tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch08lvl2sec140" class="calibre1"/>Adding tests</h2></div></div></div><p class="calibre8">In a very short time, we created<a id="id706" class="calibre1"/> an application that allows you to register, log in, and create and list posts from scratch. We will end this section by talking about how to test your Laravel application with PHPUnit.</p><p class="calibre8">It is extremely easy to write tests in Laravel as it has a very nice integration with PHPUnit. There is already a <code class="email">phpunit.xml</code> file, a customized <code class="email">TestCase</code> class, customized assertions, and plenty of helpers in order to test with the database. It also allows you to test routes, emulating the HTTP request instead of testing the controllers. We will visit all these features while testing the creation of new posts.</p><p class="calibre8">First of all, we need to remove <code class="email">tests/ExampleTest.php</code> because it tested the home page, and as we modified it, it will fail. Do not worry; this is an example test that helps developers to start testing, and making it fail is not a problem at all.</p><p class="calibre8">Now, we need to create our new test. To do this, we can either add the file manually or use the command line and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php artisan make:test NewPostTest</strong></span>
</pre></div><p class="calibre8">This command creates the <code class="email">tests/NewPostTest.php</code> file, which extends from <code class="email">TestCase</code>. If you open it, you will note that there is already a dummy test, which you can also remove. Either way, you can run PHPUnit to make sure everything passes. You can do it in the same way we did previously, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ ./vendor/bin/phpunit</strong></span>
</pre></div><p class="calibre8">The first test we can add is <a id="id707" class="calibre1"/>one where we try to add a new post but the data passed by the POST parameters is not valid. In this case, we should expect that the response contains errors and old data, so the user can edit it instead of rewriting everything again. Add the following test to the <code class="email">NewPostTest</code> class:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class NewPostTest extends TestCase
{
    public function testWrongParams() {
        $user = factory(App\User::class)
            -&gt;make(['email' =&gt; 'test@user.laravel']);

        $this-&gt;be($user);

        $this-&gt;call(
            'POST',
            '/new',
            ['title' =&gt; 'the title', 'content' =&gt; 'ojhkjhg']
        );

        $this-&gt;assertSessionHasErrors('content');
        $this-&gt;assertHasOldInput();
    }
}</pre></div><p class="calibre8">The first thing we can note in the test is the creation of a <code class="email">user</code> instance using a factory. You can pass an array with any parameter that you want to set to the <code class="email">make</code> invocation; otherwise, defaults will be used. After we get the <code class="email">user</code> instance, we will send it to the <code class="email">be</code> method to let Laravel know that we want that user to be the authorized one for this test.</p><p class="calibre8">Once we set the grounds for the test, we will use the <code class="email">call</code> helper that will emulate a real HTTP request. To this method, we have to send the HTTP method (in this case, POST), the route to request, and optionally the parameters. Note that the <code class="email">call</code> method returns the response object in case you need it.</p><p class="calibre8">We will send a title and the content, but this second one is not long enough, so we will expect some errors. Laravel comes with several customized assertions, especially when testing these kinds of responses. In this case, we could use two of them: <code class="email">assertSessionHasErrors</code>, which checks whether there are any flash errors in the session (in particular, the ones for the content parameter), and <code class="email">assertHasOldInput</code>, which checks whether the response contains old data in order to show it back to the user.</p><p class="calibre8">The second test that we would<a id="id708" class="calibre1"/> like to add is the case where the user posts valid data so that we can save the post in the database. This test is trickier as we need to interact with the database, which is usually a not a very pleasant experience. However, Laravel gives us enough tools to help us in this task. The first and most important is to let PHPUnit know that we want to use database transactions for each test. Then, we need to persist the authenticated user in the database as the post has a foreign key pointing to it. Finally, we should assert that the post is saved in the database correctly. Add the following code to the <code class="email">NewPostTest</code> class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">use DatabaseTransactions;</strong></span>

//...

public function testNewPost() {
    $postParams = [
        'title' =&gt; 'the title',
        'content' =&gt; 'In a place far far away.'
    ];

    $user = factory(App\User::class)
        -&gt;make(['email' =&gt; 'test@user.laravel']);
<span class="strong"><strong class="calibre2">    $user-&gt;save();</strong></span>

    $this-&gt;be($user);

    $this-&gt;call('POST', '/new', $postParams);

<span class="strong"><strong class="calibre2">    $this-&gt;assertRedirectedTo('http://localhost/new');</strong></span>
<span class="strong"><strong class="calibre2">    $this-&gt;seeInDatabase('posts', $postParams);</strong></span>
}</pre></div><p class="calibre8">The <code class="email">DatabaseTransactions</code> trait will make the test to start a transaction at the beginning and then roll it back once the test is done, so we will not leave the database with data from tests. Saving the authenticated user in the database is also an easy task as the result of the factory is an instance of the user's model, and we can just invoke the <code class="email">save</code> method on it.</p><p class="calibre8">The <code class="email">assertRedirectedTo</code> assertion will make sure that the response contains the valid headers that redirect the user to the specified URL. More interestingly, <code class="email">seeInDatabase</code> will verify that there is an entity in the <code class="email">posts</code> table, which is the first argument, with the data provided in the array, which is the second argument.</p><p class="calibre8">There are quite a lot of<a id="id709" class="calibre1"/> assertions, but as you can note, they are extremely useful, reducing what could be a long test to a very few lines. We recommend you to visit the official documentation for the full list.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The Silex microframework"><div class="book" id="28FAO2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec70" class="calibre1"/>The Silex microframework</h1></div></div></div><p class="calibre8">After a <a id="id710" class="calibre1"/>taste of what Laravel can offer you, you most likely do not want to hear about minimalist microframeworks. Still, we think it is good to know more than one framework. You can get to know different approaches, be more versatile, and everyone will want you in their team.</p><p class="calibre8">We chose Silex because it is a microframework, which is very different from Laravel, and also because it is part of the Symfony family. With this introduction to Silex, you will learn how to use your second framework, which is of a totally different type, and you will be one step closer to knowing Symfony as well, which is one of the big players.</p><p class="calibre8">What is the benefit of microframeworks? Well, they provide the very basics—that is, a router, a simple dependency injector, request helpers, and so on, but this is the end of it. You have plenty of room to choose and build what you really need, including external libraries or even your own ones. This means that you can have a framework specially customized for each different project. In fact, Silex provides a handful of built-in service providers that you can integrate very easily, from template engines to logging or security.</p></div>

<div class="book" title="The Silex microframework">
<div class="book" title="Installation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec141" class="calibre1"/>Installation</h2></div></div></div><p class="calibre8">There's no news here. Composer <a id="id711" class="calibre1"/>does everything for you, as it does with Laravel. Execute the following command on your command line at the root of your new project in order to include Silex in your <code class="email">composer.json</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require silex/silex</strong></span>
</pre></div><p class="calibre8">You may require more dependencies, but let's add them when we need them.</p></div></div>

<div class="book" title="The Silex microframework">
<div class="book" title="Project setup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec142" class="calibre1"/>Project setup</h2></div></div></div><p class="calibre8">Silex's most <a id="id712" class="calibre1"/>important class is <code class="email">Silex\Application</code>. This <a id="id713" class="calibre1"/>class, which extends from <a id="id714" class="calibre1"/>
<span class="strong"><strong class="calibre2">Pimple</strong></span> (a lightweight dependency injector), manages almost anything. You can use it as an array as it implements the <code class="email">ArrayAccess</code> interface, or you could invoke its methods to add dependencies, register services, and so on. The first thing to do is to instantiate it in your <code class="email">public/index.php</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Silex\Application;

require_once __DIR__ . '/../vendor/autoload.php';

<span class="strong"><strong class="calibre2">$app = new Application();</strong></span>
</pre></div><div class="book" title="Managing configuration"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec20" class="calibre1"/>Managing configuration</h3></div></div></div><p class="calibre8">One of the first things we <a id="id715" class="calibre1"/>like to do is load the configuration. We could do something very simple, such as including a file with PHP or JSON content, but let's make use of one of the service providers, <code class="email">ConfigServiceProvider</code>. Let's add it with Composer via the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require igorw/config-service-provider</strong></span>
</pre></div><p class="calibre8">This service allows us to have multiple configuration files, one for each environment we need. Imagining that we want to have two environments, <code class="email">prod</code> and <code class="email">dev</code>, this means we need two files: one in <code class="email">config/prod.json</code> and one in <code class="email">config/dev.json</code>. The <code class="email">config/dev.json</code> file would look similar to this:</p><div class="informalexample"><pre class="programlisting">{
  "debug": true,
  "cache": false,
  "database": {
    "user": "dev",
    "password": ""
  }
}</pre></div><p class="calibre8">The <code class="email">config/prod.json</code> file would look similar to this:</p><div class="informalexample"><pre class="programlisting">{
  "debug": false,
  "cache": true,
  "database ": {
    "user": "root",
    "password": "fsd98na9nc"
  }
}</pre></div><p class="calibre8">In order to work in a development environment, you will need to set the correct value to the environment variable by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">export APP_ENV=dev</strong></span>
</pre></div><p class="calibre8">The <code class="email">APP_ENV</code> environment variable will be the one telling us which environment we are in. Now, it is time to use this service provider. In order to register it by reading from the configuration file of the current environment, add the following lines to your <code class="email">index.php</code> file:</p><div class="informalexample"><pre class="programlisting">$env = getenv('APP_ENV') ?: 'prod';
$app-&gt;register(
    new Igorw\Silex\ConfigServiceProvider(
        __DIR__ . "/../config/$env.json"
    )
);</pre></div><p class="calibre8">The first thing we <a id="id716" class="calibre1"/>did here is to get the environment from the environment variable. By default, we set it to <code class="email">prod</code>. Then, we invoked <code class="email">register</code> from the <code class="email">$app</code> object to add an instance of <code class="email">ConfigServiceProvider</code> by passing the correct configuration file path. From now on, the <code class="email">$app</code> "array" will contain three entries: <code class="email">debug</code>, <code class="email">cache</code>, and <code class="email">db</code> with the content of the configuration files. We will be able to access them whenever we have access to <code class="email">$app</code>, which will be mostly everywhere.</p></div><div class="book" title="Setting the template engine"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec21" class="calibre1"/>Setting the template engine</h3></div></div></div><p class="calibre8">Another of the <a id="id717" class="calibre1"/>handy service providers is Twig. As you might remember, Twig is the template engine that we used in our own framework, and it is, in fact, from the same people that developed Symfony and Silex. You also already know how to add the dependency with Composer; simply run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require twig/twig</strong></span>
</pre></div><p class="calibre8">To register the service, we will need to add the following lines in our <code class="email">public/index.php</code> file:</p><div class="informalexample"><pre class="programlisting">$app-&gt;register(
    new Silex\Provider\TwigServiceProvider(),
    ['twig.path' =&gt; __DIR__ . '/../views']
);</pre></div><p class="calibre8">Also, create the <code class="email">views/</code> directory where we will later store our templates. Now, you have the <code class="email">Twig_Environment</code> instance available by just accessing <code class="email">$app['twig']</code>.</p></div><div class="book" title="Adding a logger"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec22" class="calibre1"/>Adding a logger</h3></div></div></div><p class="calibre8">The last one of the <a id="id718" class="calibre1"/>service providers that we will register for now is the logger. This time, the library to use is <a id="id719" class="calibre1"/>
<span class="strong"><strong class="calibre2">Monolog</strong></span>, and you can include this via the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require monolog/monolog</strong></span>
</pre></div><p class="calibre8">The quickest way to register a service is by just providing the path of the log file, which can be done as follows:</p><div class="informalexample"><pre class="programlisting">$app-&gt;register(
    new Silex\Provider\MonologServiceProvider(),
    ['monolog.logfile' =&gt; __DIR__ . '/../app.log']
);</pre></div><p class="calibre8">If you would like to add more information to this service provider, such as what level of logs you want to save, the name of the log, and so on, you can add them to the array together with the log file. Take a <a id="id720" class="calibre1"/>look at the documentation at <a class="calibre1" href="http://silex.sensiolabs.org/doc/providers/monolog.html">http://silex.sensiolabs.org/doc/providers/monolog.html</a> for the full list of parameters available.</p><p class="calibre8">As with the template engine, from now on, you can access the <code class="email">Monolog\Logger</code> instance from the <code class="email">Application</code> object by accessing <code class="email">$app['monolog']</code>.</p></div></div></div>

<div class="book" title="The Silex microframework">
<div class="book" title="Adding the first endpoint"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec143" class="calibre1"/>Adding the first endpoint</h2></div></div></div><p class="calibre8">It is time to see how the <a id="id721" class="calibre1"/>router works in Silex. We would like to add a simple endpoint for the home page. As we already mentioned, the <code class="email">$app</code> instance can manage almost anything, including routes. Add the following code at the end of the <code class="email">public/index.php</code> file:</p><div class="informalexample"><pre class="programlisting">$app-&gt;get('/', function(Application $app) {
    return $app['twig']-&gt;render('home.twig');
});</pre></div><p class="calibre8">This is a similar way of adding routes to the one that Laravel follows. We invoked the <code class="email">get</code> method as it is a GET endpoint, and we passed the route string and the <code class="email">Application</code> instance. As we mentioned here, <code class="email">$app</code> also acts as a dependency injector—in fact, it extends from one: Pimple—so you will notice the <code class="email">Application</code> instance almost everywhere. The result of the anonymous function will be the response that we will send to the user—in this case, a rendered Twig template.</p><p class="calibre8">Right now, this will not do the trick. In order to let Silex know that you are done setting up your application, you need to invoke the <code class="email">run</code> method at the very end of the <code class="email">public/index.php</code> file. Remember that if you need to add anything else to this file, it has to be before this line:</p><div class="informalexample"><pre class="programlisting">$app-&gt;run();</pre></div><p class="calibre8">You have already worked with Twig, so we will not spend too much time on this. The first thing to add is the <code class="email">views/home.twig</code> template:</p><div class="informalexample"><pre class="programlisting">{% extends "layout.twig" %}

{% block content %}
    &lt;h1&gt;Hi visitor!&lt;/h1&gt;
{% endblock %}</pre></div><p class="calibre8">Now, as you might have already guessed, we will add the <code class="email">views/layout.twig</code> template, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Silex Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{% block content %}
{% endblock %}
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">Try accessing the home <a id="id722" class="calibre1"/>page of your application; you should get the following result:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Adding the first endpoint" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div class="book" title="The Silex microframework">
<div class="book" title="Accessing the database"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec144" class="calibre1"/>Accessing the database</h2></div></div></div><p class="calibre8">For this section, we <a id="id723" class="calibre1"/>will write an endpoint that will create recipes for our cookbook. Run the following MySQL queries in order to set up the <code class="email">cookbook</code> database and create the empty <code class="email">recipes</code> table:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mysql&gt; CREATE SCHEMA cookbook;</strong></span>
<span class="strong"><strong class="calibre2">Query OK, 1 row affected (0.00 sec)</strong></span>
<span class="strong"><strong class="calibre2">mysql&gt; USE cookbook;</strong></span>
<span class="strong"><strong class="calibre2">Database changed</strong></span>
<span class="strong"><strong class="calibre2">mysql&gt; CREATE TABLE recipes(</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; name VARCHAR(255) NOT NULL,</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; ingredients TEXT NOT NULL,</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; instructions TEXT NOT NULL,</strong></span>
<span class="strong"><strong class="calibre2">    -&gt; time INT UNSIGNED NOT NULL);</strong></span>
<span class="strong"><strong class="calibre2">Query OK, 0 rows affected (0.01 sec)</strong></span>
</pre></div><p class="calibre8">Silex does not come with any ORM integration, so you will need to write your SQL queries by hand. However, there is a Doctrine service provider that gives you a simpler interface than the one PDO offers, so let's try to integrate it. To install this, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require "doctrine/dbal:~2.2"</strong></span>
</pre></div><p class="calibre8">Now, we are ready to register the service provider. As with the rest of services, add the following code to your <code class="email">public/index.php</code> before the route definitions:</p><div class="informalexample"><pre class="programlisting">$app-&gt;register(new Silex\Provider\DoctrineServiceProvider(), [
    'dbs.options' =&gt; [
        [
            'driver'    =&gt; 'pdo_mysql',
            'host'      =&gt; '127.0.0.1',
            'dbname'    =&gt; 'cookbook',
            'user'      =&gt; $app['database']['user'],
            'password'  =&gt; $app['database']['password']
        ]
    ]
]);</pre></div><p class="calibre8">When registering, you need<a id="id724" class="calibre1"/> to provide the options for the database connection. Some of them will be the same regardless of the environment, such as the driver or even the host, but some will come from the configuration file, such as <code class="email">$app['database']['user']</code>. From now on, you can access the database connection via <code class="email">$app['db']</code>.</p><p class="calibre8">With the database set up, let's add the routes that will allow us to add and fetch recipes. As with Laravel, you can specify either the anonymous function, as we already did, or a controller and method to execute. Replace the current route with the following three routes:</p><div class="informalexample"><pre class="programlisting">$app-&gt;get(
    '/',
    'CookBook\\Controllers\\RecipesController::getAll'
);
$app-&gt;post(
    '/recipes',
    'CookBook\\Controllers\\RecipesController::create'
);
$app-&gt;get(
    '/recipes',
    'CookBook\\Controllers\\RecipesController::getNewForm'
);</pre></div><p class="calibre8">As you can observe, there will be a new controller, <code class="email">CookBook\Controllers\RecipesController</code>, which will be placed in <code class="email">src/Controllers/RecipesController.php</code>. This means that you need to change the autoloader in Composer. Edit your <code class="email">composer.json</code> file with the following:</p><div class="informalexample"><pre class="programlisting">"autoload": {
    "psr-4": {"CookBook\\": "src/"}
}</pre></div><p class="calibre8">Now, let's add the controller class, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace CookBook\Controllers;

class Recipes {
    
}</pre></div><p class="calibre8">The first method we<a id="id725" class="calibre1"/> will add is the <code class="email">getNewForm</code> method, which will just render the add a new recipe page. The method looks similar to this:</p><div class="informalexample"><pre class="programlisting">public function getNewForm(Application $app): string {
    return $app['twig']-&gt;render('new_recipe.twig');
}</pre></div><p class="calibre8">The method will just render <code class="email">new_recipe.twig</code>. An example of this template could be as follows:</p><div class="informalexample"><pre class="programlisting">{% extends "layout.twig" %}

{% block content %}
    &lt;h1&gt;Add recipe&lt;/h1&gt;
    &lt;form method="post"&gt;
        &lt;div&gt;
            &lt;label for="name"&gt;Name&lt;/label&gt;
            &lt;input type="text" name="name"
                   value="{{ name is defined ? name : "" }}" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for="ingredients"&gt;Ingredients&lt;/label&gt;
            &lt;textarea name="ingredients"&gt;
                {{ ingredients is defined ? ingredients : "" }}
            &lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for="instructions"&gt;Instructions&lt;/label&gt;
            &lt;textarea name="instructions"&gt;
                {{ instructions is defined ? instructions : "" }}
            &lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for="time"&gt;Time (minutes)&lt;/label&gt;
            &lt;input type="number" name="time"
                   value="{{ time is defined ? time : "" }}" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;button type="submit"&gt;Save&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
{% endblock %}</pre></div><p class="calibre8">This template sends the name, ingredients, instructions, and the time that it takes to prepare the dish. The endpoint that will get this form needs to get the response object in order to extract this<a id="id726" class="calibre1"/> information. In the same way that we could get the <code class="email">Application</code> instance as an argument, we can get the <code class="email">Request</code> one too if we specify it in the method definition. Accessing the POST parameters is as easy as invoking the <code class="email">get</code> method by sending the name of the parameter or calling <code class="email">$request-&gt;request-&gt;all()</code> to get all of them as an array. Add the following method that checks whether all the data is valid and renders the form again if it is not, sending the submitted data and errors:</p><div class="informalexample"><pre class="programlisting">public function create(Application $app, Request $request): string {
    $params = $request-&gt;request-&gt;all();
    $errors = [];

    if (empty($params['name'])) {
        $errors[] = 'Name cannot be empty.';
    }
    if (empty($params['ingredients'])) {
        $errors[] = 'Ingredients cannot be empty.';
    }
    if (empty($params['instructions'])) {
        $errors[] = 'Instructions cannot be empty.';
    }
    if ($params['time'] &lt;= 0) {
        $errors[] = 'Time has to be a positive number.';
    }
    
    if (!empty($errors)) {
        $params = array_merge($params, ['errors' =&gt; $errors]);
        return $app['twig']-&gt;render('new_recipe.twig', $params);
    }
}</pre></div><p class="calibre8">The <code class="email">layout.twig</code> template needs to be edited too in order to show the errors returned. We can do this by executing the following:</p><div class="informalexample"><pre class="programlisting">{# ... #}
{% if errors is defined %}
    &lt;p&gt;Something went wrong!&lt;/p&gt;
    &lt;ul&gt;
    {% for error in errors %}
        &lt;li&gt;{{ error }}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% endif %}
{% block content %}
{# ... #}</pre></div><p class="calibre8">At this point, you can<a id="id727" class="calibre1"/> already try to access <code class="email">http://localhost/recipes</code>, fill the form leaving something empty, submitting, and getting the form back with the errors. It should look something similar to this (with some extra CSS styles):</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="Accessing the database" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The continuation of the<a id="id728" class="calibre1"/> controller should allow us to store the correct data as a new recipe in the database. To do so, it would be a good idea to <a id="id729" class="calibre1"/>create a separate class, such as <code class="email">CookBook\Models\RecipeModel</code>; however, to speed things up, let's add the following few lines that would go into the model to the controller. Remember that we have the Doctrine service provider, so there is no need to use PDO directly:</p><div class="informalexample"><pre class="programlisting">$sql = 'INSERT INTO recipes (name, ingredients, instructions, time) '
    . 'VALUES(:name, :ingredients, :instructions, :time)';
<span class="strong"><strong class="calibre2">$result = $app['db']-&gt;executeUpdate($sql, $params);</strong></span>

if (!$result) {
    $params = array_merge($params, ['errors' =&gt; $errors]);
    return $app['twig']-&gt;render('new_recipe.twig', $params);
}

return $app['twig']-&gt;render('home.twig');</pre></div><p class="calibre8">Doctrine also helps when fetching data. To see it working, check the third and final method, in which we will fetch all the recipes in order to show the user:</p><div class="informalexample"><pre class="programlisting">public function getAll(Application $app): string {
<span class="strong"><strong class="calibre2">    $recipes = $app['db']-&gt;fetchAll('SELECT * FROM recipes');</strong></span>
    return $app['twig']-&gt;render(
        'home.twig',
        ['recipes' =&gt; $recipes]
    );
}</pre></div><p class="calibre8">With only one line, we performed a query. It is not as clean as the Eloquent ORM of Laravel, but at least it is much less verbose than using raw PDO. Finally, you can update your <code class="email">home.twig</code> template with the following content in order to display the recipes that we just fetched from the database:</p><div class="informalexample"><pre class="programlisting">{% extends "layout.twig" %}

{% block content %}
    &lt;h1&gt;Hi visitor!&lt;/h1&gt;
    &lt;p&gt;Check our recipes!&lt;/p&gt;
    &lt;table&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;th&gt;Time&lt;/th&gt;
        &lt;th&gt;Ingredients&lt;/th&gt;
        &lt;th&gt;Instructions&lt;/th&gt;
    {% for recipe in recipes %}
        &lt;tr&gt;
            &lt;td&gt;{{ recipe.name }}&lt;/td&gt;
            &lt;td&gt;{{ recipe.time }}&lt;/td&gt;
            &lt;td&gt;{{ recipe.ingredients }}&lt;/td&gt;
            &lt;td&gt;{{ recipe.instructions }}&lt;/td&gt;
        &lt;/tr&gt;
    {% endfor %}
    &lt;/table&gt;
{% endblock %}</pre></div></div></div>
<div class="book" title="Silex versus Laravel" id="29DRA1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec71" class="calibre1"/>Silex versus Laravel</h1></div></div></div><p class="calibre8">Even though we<a id="id730" class="calibre1"/> did some similar comparison before starting the chapter, it is<a id="id731" class="calibre1"/> time to recapitulate what we said and compare it with what you noted by yourself. Laravel belongs to the type of framework that allows you to create great things with very little work. It contains all the components that you, as a web developer, will ever need. There has to be some good reason for how fast it became the most popular framework of the year!</p><p class="calibre8">On the other hand, Silex is a microframework, which by itself does very little. It is just the skeleton on which you can build the framework that you exactly need. It already provides quite a lot of <a id="id732" class="calibre1"/>service providers, and we did not discuss even half of them; we recommend you to visit <a class="calibre1" href="http://silex.sensiolabs.org/doc/providers.html">http://silex.sensiolabs.org/doc/providers.html</a> for the full list. However, if you prefer, you can always add other dependencies with Composer and use them. If, for some reason, you stop liking the ORM or the template engine that you use, or it just happens that a new and better one appears in the community, switching them should be easy. On the other hand, when working with Laravel, you will probably stick to what it comes with it.</p><p class="calibre8">There is always an occasion for each framework, and we would like to encourage you to be open to all the possibilities that there are out there, keep up to date, and explore new frameworks or technologies from time to time.</p></div>
<div class="book" title="Summary" id="2ACBS1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec72" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned how important it is to know some of the most important frameworks. You also learned the basics of two famous ones: Laravel and Silex. Now, you are ready to either use your framework or to use these two for your next application. With this, you also have the capacity to take any other similar framework and understand it easily.</p><p class="calibre8">In the next chapter, we will study what REST APIs are and how to write one with Laravel. This will expand your set of skills and give you more flexibility for when you need to decide which approach to take when designing and writing applications.</p></div></body></html>