<html><head></head><body>
		<div id="_idContainer061">
			<h1 id="_idParaDest-92"><em class="italic"><a id="_idTextAnchor093"/>Chapter 5</em>: Exploring Objects and Classes</h1>
			<p>In this chapter, we are going to see one of the main functionalities that Pimcore offers to us: the possibility of defining a personal and completely custom dataset for each project by creating classes and objects.</p>
			<p>The big advantage of using Pimcore is that you can do everything through the user interface, without the need of writing a single line of code or to define complex database structures, changing or adding new attributes whenever you want. Pimcore will do all the magic, and you can update your dataset with no worries of running risky migrations on the database. Besides, you can export and import all class definitions to share them between different projects without the need for reinventing the wheel every time.</p>
			<p>In the following sections, we will present class configuration, focusing on various field types that could be added to them, and how to concretely see these classes in action through data entry. If we've caught your curiosity, just go through this chapter to discover how simple it is to create and update your classes with Pimcore. The chapter structure is organized as follows:</p>
			<ul>
				<li>What is a Class?</li>
				<li>Creating and Editing a class definition</li>
				<li>Discovering Relevant Field Types</li>
				<li>Understanding and Establishing relations</li>
				<li>Performing Data Entry</li>
			</ul>
			<p>By the end of this chapter, you will know how to create Pimcore classes and how to properly configure them to make the most of their potential.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>As you previously have done in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, all you need to run the demo connected with this chapter is to navigate to the <strong class="source-inline">5. Object and Classes</strong> folder on the official book repository and start a Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings on your local machine, just open a new shell and type the following:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>You can access the official book repository to get the source code through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/5.%20Object%20and%20Classes">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/5.%20Object%20and%20Classes</a></p>
			<p>Now you are ready to navigate the demo to discover all the aspects related to this chapter.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>What is a Class?</h1>
			<p>In this section, you<a id="_idIndexMarker216"/> will learn what a class is in Pimcore and how it is useful for managing any kind of data. In the context of Object-Oriented-Programming, a <strong class="bold">class</strong> consists of a set of variables (or properties) suitable to represent a concept, methods to affect values, and the behavior of objects that instantiate the class itself.</p>
			<p>Pimcore classes reflect this definition, but there is more. In the following sections, we will better understand how those classes work, and how they simplify our work on dataset development. In particular, we will see that despite the name, Pimcore is not limited to product information management; moreover, you will discover that no coding at all is needed to define classes.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Designing different concepts</h2>
			<p>As we already know, one of Pimcore's main features is product information management, so we are led to believe that everything revolves around the definition of a <strong class="source-inline">Product</strong> class. This is often true, of course, but it must not be seen as a limitation.</p>
			<p>Think about a basic <a id="_idIndexMarker217"/>e-commerce structure: there will be the <strong class="source-inline">Product</strong> class, as we would expect, but maybe we want to categorize our products; we can think about creating a <strong class="source-inline">Category</strong> class to link to the product, instead of repeating the category's attributes in each one. We can apply the same reasoning on product materials or other attributes, gradually increasing the complexity of our structure as needed. And what if we need to implement a store locator for our e-commerce site? All we would need to do is create a <strong class="source-inline">Store</strong> class!</p>
			<p>To be more generic, we can design every different kind of concept creating the respective class. That said, you can easily understand how simple it could be to design the dataset for your CMS. You just need to define classes for articles, authors, and so on and start to insert your data. Even better is the fact that you can do it without writing a single line of code.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>No code required</h2>
			<p>You may think that defining these classes will require a lot of code <a id="_idIndexMarker218"/>development or database engineering, but you would be wrong. You just need to define your classes and their attributes, and Pimcore will do all the magic. To be more specific, we may say that every operation that we make on each of our classes affects a couple of PHP files that are needed to define the classes themselves.</p>
			<p>The <strong class="source-inline">definition</strong> file contains a complex structure of arrays that represent class fields, all information regarding visual aspects, such as width, height, or CSS rules, and the spatial organization of these fields. This file contains all class attribute definitions, so it can be used to restore the class itself.</p>
			<p>The <strong class="source-inline">class</strong> file, named after the class itself, contains all getters, setters, and other common methods that allow us to manipulate objects that will instantiate the class. This class can be referenced within the project and used to access class properties and create or update class instances.</p>
			<p>Those come with flexible and dedicated database tables for each class and the relations between them. Once more, all this happens behind the scenes and so you will never have to worry about that; all you need to do is define the structure that reflects your needs.</p>
			<p>In this section, we discovered what a class is and how anybody can configure it without any knowledge of code development. In the next section, we'll see <a id="_idIndexMarker219"/>how to create and edit a class definition.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/>Creating and Editing a Class Definition</h1>
			<p>Now that <a id="_idIndexMarker220"/>we<a id="_idIndexMarker221"/> know the basic definitions, in this section, we are ready to create our first class. To open up the class definition panel, go through <strong class="bold">Settings</strong> | <strong class="bold">Data Objects</strong> |<strong class="bold"> Classes</strong>. Now, we can click on the <strong class="bold">Add</strong> button on the left side. In the following screenshot, we can see the class creation pop-up modal that appears:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_5.01_B17073.jpg" alt="Figure 5.1: Creating a new class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Creating a new class</p>
			<p>In the popup that appears, we must define the following:</p>
			<ul>
				<li><strong class="bold">Class name</strong>: The name of our class. Pay attention to avoid whitespaces.</li>
				<li><strong class="bold">Unique identifier</strong>: A short string to identify the class uniquely. If we omit the identifier, the first available integer ID will be applied to the class. This identifier cannot be updated again.</li>
			</ul>
			<p>Click on <strong class="bold">OK</strong> and the class will be created.</p>
			<p>Now we need to define the general settings for the class. We will list all these settings, explaining their meanings and how to properly configure them. Remember that all settings are optional, and some may not be useful for your project.</p>
			<p>In the<a id="_idIndexMarker222"/> following <a id="_idIndexMarker223"/>screenshot, we can see these settings with plausible values:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_5.02_B17073.jpg" alt="Figure 5.2: General settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: General settings</p>
			<p>Let's now describe each property that we see in the preceding screenshot:</p>
			<ul>
				<li><strong class="bold">Description</strong>: Just a description of your class. It has no other implications. It may be useful to transmit the purpose of the class in the case of remote collaboration.</li>
				<li><strong class="bold">Parent PHP Class</strong>: A PHP class that you want your class to extend. It is crucial that, on the inheritance chain, the class extends the <strong class="source-inline">Pimcore\Model\DataObject\Concrete</strong> class, which contains common methods for all classes.</li>
				<li><strong class="bold">Implements interface(s)</strong>: A comma-separated list of interfaces that you want your class to implement.</li>
				<li><strong class="bold">Use (traits)</strong>: In PHP, traits are mechanisms for code reuse, which allows reducing some limitations given by single inheritance. In Pimcore, we could use traits to implement methods of the previous interface(s).</li>
				<li><strong class="bold">Listing Parent PHP Class</strong>: We can also define a parent PHP class for the listing class. This class must extend the <strong class="source-inline">Pimcore\Model\DataObject\Listing\Concrete</strong> class.</li>
				<li><strong class="bold">Listing Use (traits)</strong>: As we just mentioned, traits are a PHP paradigm of code development <a id="_idIndexMarker224"/>used to implement interface methods. The<a id="_idIndexMarker225"/> same concept is valid for class listing.</li>
				<li><strong class="bold">Link Provider Class or Service Name</strong>: Link generation is a particular class used to dynamically generate web links for objects and is automatically called when objects are linked in documents or other link tags. It must extend the <strong class="source-inline">AbstractProductLinkGenerator</strong> class and implements the <strong class="source-inline">LinkGeneratorInterface</strong> interface. The link generator will receive the referenced object and additional data depending on the context.</li>
				<li><strong class="bold">Preview URL</strong>: The preview URL is useful to generate a dynamic URL for the object directly on the class definition. You can use placeholders for each defined attribute of your class, in addition to common properties such as object ID or key. This feature became deprecated in the last version, and it is suggested to use <strong class="bold">Link Provider Class</strong>.</li>
				<li><strong class="bold">Icon</strong>: You can choose a custom icon for your class from the icon list. If you prefer, there is the possibility to link your icons, providing the path to the icon itself. It is recommended to use SVG files.</li>
				<li><strong class="bold">Group</strong>: This property is necessary to group your classes into folders in the class definitions tree. Classes with the same prefix word are automatically grouped even if no group is explicitly provided.</li>
				<li><strong class="bold">Allow Inheritance</strong>: If checked, this property enables the inheritance among objects in a tree-structured way. Child objects could be instances of the same class or objects of a different class. If child objects belong to the same class as the parent object, they automatically inherit all data values from the parent object and can override them.</li>
				<li><strong class="bold">Allow Variants</strong>: Object variants are a particular kind of inheritance. A variant's class cannot be chosen; it's forced to be the same as the parent object. We must note that, by default, variants are excluded from listing queries.</li>
				<li><strong class="bold">Show variants in tree</strong>: This property allows you to see the variants in the object tree. If<a id="_idIndexMarker226"/> not enabled, variants are only shown in the<a id="_idIndexMarker227"/> appropriate tab inside the object edit modal.</li>
				<li><strong class="bold">Show App Logger Tab</strong>: If enabled, the <strong class="bold">Application Logger</strong> tab is shown inside the object edit modal. In that tab, it's possible to read eventually created log events related to the object.</li>
				<li><strong class="bold">Enable grid locking</strong>: This allows you to block some columns in the object grid views.</li>
				<li><strong class="bold">Encrypt Data</strong>: This property enables the possibility to encrypt the object's data in the tables created to store information for the class.</li>
				<li><strong class="bold">Visibility of system properties</strong>: This allows you to choose which attributes are shown by default in the grid view and the search view. These attributes are <strong class="bold">Id</strong>, <strong class="bold">Key</strong>, <strong class="bold">Path</strong>, <strong class="bold">Published</strong>, <strong class="bold">Creation Date</strong>, and <strong class="bold">Modification date</strong>. These properties are useful for grid filtering.</li>
				<li><strong class="bold">Composite Indices</strong>: Pimcore allows you to create custom indices in tables that store the information of your class objects. You can choose the index name and the class attributes involved in it.</li>
			</ul>
			<p>Once you have filled in these class properties, you must click on the <strong class="bold">Save</strong> button to apply them.</p>
			<p>In this section, you learned how to create Pimcore classes. Then, you discovered what the main settings for a class are, and how to properly fill in these properties concerning your specific <a id="_idIndexMarker228"/>needs. Moreover, you have seen how to enable class<a id="_idIndexMarker229"/> inheritance. In the next section, we will present all the different kinds of components that can be attached to the class.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Discovering Relevant Field Types</h1>
			<p>In the previous<a id="_idIndexMarker230"/> section, we created our first class. The created class is just like an empty box of which, let's say, we have just established the shape and the dimensions. In this section, we will see how we can model our class, defining layout components and all different kinds of attributes. These concepts are crucial to properly configure your classes according to your needs. In particular, we will describe the two different kinds of attributes:</p>
			<ul>
				<li>The Layout Components</li>
				<li>The Data Components</li>
			</ul>
			<p>Let's see both of these kinds of components in the following sections.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Layout Components</h2>
			<p>The layout components allow us to organize the class attributes through space. To <a id="_idIndexMarker231"/>better understand the usefulness of these components, let's think about a website structure. There are no rules that prevent putting all site information vertically on the page. All text, input fields, images, and related links, just listed one below the previous one. Sure, it's easy to create, but the reading experience for the user is quite a mess, don't you think?</p>
			<p>Maybe it'd be better to group common information in different tabs or create a box with input fields that the user must fill in with the required information. Images can be grouped into a gallery, on the right-hand side, or we may want to expand or collapse certain information.</p>
			<p>Well, class layout components are designed for just that purpose. You must add at least one layout component to the class to be allowed to add the class attributes; to add a layout component, just right-click on <strong class="bold">General Settings</strong> in your class definition.</p>
			<p>Let's see the common <a id="_idIndexMarker232"/>characteristic of all kinds of components and the specific properties for each of them:</p>
			<ul>
				<li><strong class="bold">Name</strong>: The component name will only be shown inside the class definition panel.</li>
				<li><strong class="bold">Region</strong>: Combined with a parent layout component, this can be used to locate the component in different positions, using <strong class="bold">North</strong>, <strong class="bold">West</strong>, <strong class="bold">Center</strong>, <strong class="bold">East</strong>, and <strong class="bold">South</strong>.</li>
				<li><strong class="bold">Title</strong>: The component title will be shown in object instances of the class. The position and style of the title depend on the specific component.</li>
				<li><strong class="bold">Width</strong>: The width of the component in the object edit modal.</li>
				<li><strong class="bold">Height</strong>: The height of the component in the object edit modal.</li>
				<li><strong class="bold">Collapsible</strong>: If enabled, this makes the component collapsible by the user.</li>
				<li><strong class="bold">Collapsed</strong>: If enabled, the component is collapsed by default on object opening.</li>
				<li><strong class="bold">CSS Style</strong>: Consent to write custom CSS style rules for the component, such as a margin or floating position.</li>
				<li><strong class="bold">Border</strong>: Adds a border to the element.</li>
			</ul>
			<p>We can now have a specific look at each kind of layout component. In the following screenshot, we can see all the different types of layout components:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_5.03_B17073.jpg" alt="Figure 5.3: Add Layout Component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Add Layout Component</p>
			<p>Let's describe the properties of each component in the following sections as shown in the screenshot.</p>
			<h3>Tabpanel</h3>
			<p>This component allows you to group different panels<a id="_idIndexMarker233"/> inside. Each panel will act as a tab in the object edit modal. Besides <a id="_idIndexMarker234"/>the common properties, for Tabpanel, you can specify the <strong class="bold">Tab Position</strong> property. This lets you choose in which position you want to put your tabs; possible values are <strong class="bold">top</strong> (default), <strong class="bold">left</strong>, <strong class="bold">right</strong>, and <strong class="bold">bottom</strong>.</p>
			<h3>Panel</h3>
			<p>A simple component that lets you add attributes inside. This component can <a id="_idIndexMarker235"/>be nested inside other components, such as Tabpanel <a id="_idIndexMarker236"/>and Region, and located in different positions.</p>
			<p>For this component, we can specify these additional properties:</p>
			<ul>
				<li><strong class="bold">Layout</strong>: If the <strong class="bold">Fit</strong> option is selected, all fields inside the panel will fit the screen dimension.</li>
				<li><strong class="bold">Label Width</strong>: Sets the width of the panel label.</li>
				<li><strong class="bold">Icon</strong>: Allows choosing <a id="_idIndexMarker237"/>a custom<a id="_idIndexMarker238"/> icon that will be shown at the left of the label.</li>
			</ul>
			<h3>Accordion</h3>
			<p>Similar to the Panel component, this component is designed to<a id="_idIndexMarker239"/> be collapsed and expanded as needed. This <a id="_idIndexMarker240"/>concept is often used for site development to let the user hide or show some extra information that may or may not be useful. For this component, there are no extra properties to add.</p>
			<p>In the following screenshot, you will see the difference between panels and accordions:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_5.04_B17073.jpg" alt="Figure 5.4: Panels and accordions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: Panels and accordions</p>
			<p>As you can see in the preceding screenshots, the panels are placed on top inside the <strong class="bold">Tab Panel Component</strong>. The accordion component contains other layout and data components and can be collapsed or expanded.</p>
			<h3>Region</h3>
			<p>This <a id="_idIndexMarker241"/>component is designed to contain only other layout components. If you <a id="_idIndexMarker242"/>add panels inside a region, you can organize them in the five fixed positions mentioned previously. Note that you must specify a fixed region height, or your region will not be shown. As for the panel, you can choose a custom icon.</p>
			<h3>Fieldset</h3>
			<p>This component just lets you add some data components inside<a id="_idIndexMarker243"/> of it, grouping them with a small border with a label on top. You can use it to group a list of similar fields that make <a id="_idIndexMarker244"/>sense if shown together. The only specific property that can be set is the label width.</p>
			<h3>Field Container</h3>
			<p>The behavior of a Field Container is similar to a Fieldset. The <a id="_idIndexMarker245"/>main difference is just that you can choose<a id="_idIndexMarker246"/> whether you want to group your fields vertically or horizontally, by properly selecting the <strong class="bold">Layout</strong> property.</p>
			<p>In the following screenshot, you can see the difference between <strong class="bold">Fieldset</strong> and <strong class="bold">Field Container</strong>:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_5.05_B17073.jpg" alt="Figure 5.5: Fieldset and Field Container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: Fieldset and Field Container</p>
			<p>As you can see in the preceding screenshot, the data components inside <strong class="bold">Fieldset</strong> are grouped inside a box vertically. <strong class="bold">Field Container</strong> does not have a designed border, and the inner components can be grouped horizontally.</p>
			<h3>Button</h3>
			<p>Allows <a id="_idIndexMarker247"/>you to add a custom button inside the object edit modal. The <a id="_idIndexMarker248"/>handler of the button must be defined in the component definition.</p>
			<h3>Text</h3>
			<p>This <a id="_idIndexMarker249"/>component is just a static text box that <a id="_idIndexMarker250"/>can be shown in the object edit modal. The HTML text inside the box can be directly defined in the class definition, or you can generate dynamic text specifying the class namespace in the <strong class="bold">Custom Renderer Class</strong> attribute.</p>
			<h3>Preview/Iframe</h3>
			<p>This component simply lets us render a custom Iframe inside our object edit modal. The Iframe URL must be a <a id="_idIndexMarker251"/>relative URL <a id="_idIndexMarker252"/>of action inside a controller<a id="_idIndexMarker253"/> that extends the <strong class="source-inline">Pimcore\Controller\FrontendController</strong> class.</p>
			<p>Now that we have discovered all the options for the layout components, let's have a look at the data components.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Data Components</h2>
			<p>Data components <a id="_idIndexMarker254"/>are the concrete attributes of classes. There are tons of available attributes,grouped into different main types, that allow you to model your class according to your needs. In the following screenshot, you can see a panoramic of all types of data components:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_5.06_B17073.jpg" alt="Figure 5.6: Add Data Component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: Add Data Component</p>
			<p>As you can see in the preceding screenshot, there are 10 main data component types, which contain a different number of components. Each component type and every attribute have their<a id="_idIndexMarker255"/> specific properties, but all data components have a set of common properties that we explain here:</p>
			<ul>
				<li><strong class="bold">Name</strong>: The name of the attribute. It cannot have spaces or special characters, because this is the name that will be used in the database table column and the PHP class.</li>
				<li><strong class="bold">Title</strong>: The label of the attribute that will be shown in the object edit modal.</li>
				<li><strong class="bold">Tooltip</strong>: Suggested text to explain the meaning of the attribute used to help the user.</li>
				<li><strong class="bold">Mandatory Field</strong>: If checked, makes the attribute mandatory. An object cannot be published if all mandatory fields are not filled in.</li>
				<li><strong class="bold">Indexed</strong>: If checked, creates an index for the field in the database tables.</li>
				<li><strong class="bold">Unique</strong>: If checked, creates the unique constraint in the database tables.</li>
				<li><strong class="bold">Not Editable</strong>: If checked, the attribute becomes read-only.</li>
				<li><strong class="bold">Invisible</strong>: If checked, the attribute is not visible in the object edit modal.</li>
				<li><strong class="bold">Visible in Grid View</strong>: If checked, the attribute is shown in the class' predefined grid.</li>
				<li><strong class="bold">Visible in Search Result</strong>: If checked, the attribute is visible and searchable in the dedicated search modal for the class.</li>
				<li><strong class="bold">CSS Style</strong>: As for layout components, consent to write custom CSS style rules for the component, such as margin or floating position.</li>
				<li><strong class="bold">Width</strong>: The width of the component in pixels.</li>
				<li><strong class="bold">Height</strong>: The height of the<a id="_idIndexMarker256"/> component in pixels.</li>
				<li><strong class="bold">Default value</strong>: A lot of field types give the possibility to define a default value. If any value is typed for the field, the default value is saved. If inheritance is enabled for the class, this value is persisted in the database for its children.</li>
				<li><strong class="bold">Default value generator service</strong>: Instead of setting a fixed default value directly on the component, there's the possibility to create a PHP class that dynamically calculates the default value. This class must implement the <strong class="source-inline">\Pimcore\Model\DataObject\ClassDefinition\DefaultValueGeneratorInterface</strong> class, and it is invoked once you open the object to perform the default value calculation. </li>
			</ul>
			<p>Now that you have learned about the common properties of all kinds of data components, we will focus on each specific group of components to describe their peculiarities.</p>
			<h3>Text Components</h3>
			<p>This kind of component contains basic text input fields. All these<a id="_idIndexMarker257"/> components are quite similar and share all the common properties we mentioned before, but there are some differences:</p>
			<ul>
				<li>The <strong class="bold">Input</strong> component<a id="_idIndexMarker258"/> is the simplest text field. It's not possible to set the input height because it is meant to contain only one line. We can indeed show the character count and add a regular expression validation.</li>
				<li>The <strong class="bold">Textarea</strong> component<a id="_idIndexMarker259"/> is quite similar to the previous one but allows you to specify the height for your text. As the input component, it's possible to show the character count, bet we cannot add regular expressions.</li>
				<li>The <strong class="bold">WYSIWYG</strong> component, as the <a id="_idIndexMarker260"/>famous acronym suggests, allows you to insert and edit HTML-formatted text. It's possible to customize the editor configuration by<a id="_idIndexMarker261"/> providing a CKEditor configuration in the component definition. </li>
				<li>The <strong class="bold">Password</strong> component<a id="_idIndexMarker262"/> is an input text with hidden input characters. The column length cannot be chosen because contents are always hashed using the selected algorithm.</li>
				<li>The <strong class="bold">Input Quantity Value</strong> field is composed of value and measure units. We will look in depth into this concept in the following section regarding numeric fields.</li>
			</ul>
			<h3>Number Components</h3>
			<p>This section contains some simple numeric attributes. </p>
			<p>The <strong class="bold">Number</strong> component<a id="_idIndexMarker263"/> is the simplest numeric field. It's possible to define the decimal size for the database column and the decimal precision for input values. Values can be restricted to be only integers or only unsigned. We can also specify minimum and maximum values.</p>
			<p>The <strong class="bold">Slider</strong> component<a id="_idIndexMarker264"/> stores a numeric value but it renders a sliding cursor to select the value. By specifying min-max values and incremental steps, it's possible to define this slider component.</p>
			<p>As mentioned before, the <strong class="bold">Quantity Value</strong> component consents to attach measure units to numeric fields, giving the possibility to define concepts such as prices, weights, and so on. To define your units, just go through <strong class="bold">Settings</strong> | <strong class="bold">Data Object</strong> | <strong class="bold">Quantity Value</strong> and simply add the units that you need. Units can be added and deleted at any moment, and every operation is auto-saved in the database. In the following screenshot, you will see the <strong class="bold">QuantityValue</strong> definition panel:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_5.07_B17073.jpg" alt="Figure 5.7: Quantity value units&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: Quantity value units</p>
			<p>As you can see in <a id="_idIndexMarker265"/>the screenshot, different units can be related using a static conversion factor or by defining a converter service class; the second option could be useful for conversions that need a formula, such as temperature conversions.</p>
			<h3>Date Components</h3>
			<p>These components are designed to contain date and time values. Dates in the<a id="_idIndexMarker266"/> database can be stored as a timestamp or a date string.</p>
			<h3>Select Components</h3>
			<p>This kind of component lets you define different types of picklists. Some of them come with predefined options, such as <strong class="bold">Country</strong>, <strong class="bold">Language</strong>, and <strong class="bold">User</strong>. Instead, there<a id="_idIndexMarker267"/> are three types of custom picklists that we can define. For <strong class="bold">Boolean Select</strong>, we cannot define picklist values, but we can customize labels for the two states. <strong class="bold">Select</strong> is the most common component of this group. Picklist values can be added, removed, and ordered at any time. Values can be numbers or strings likewise. In the next screenshot, you will see how <strong class="bold">Select</strong> options are defined:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_5.08_B17073.jpg" alt="Figure 5.8: Select values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: Select values</p>
			<p>As you can see, we can define both the value and display name. Alternatively, you may also define a custom class to provide dynamic options for your field. The behavior of the <strong class="bold">Multiselection</strong> component is<a id="_idIndexMarker268"/> the same as the previous one, with the difference that we can select multiple values in objects.</p>
			<h3>Media Components</h3>
			<p>This set of components permits us to show media files in our class objects. We<a id="_idIndexMarker269"/> can link internal assets or external images, create galleries, and show video previews.</p>
			<p>We will look into this part in depth in <a href="B17073_06_ePub_RK.xhtml#_idTextAnchor112"><em class="italic">Chapter 6</em></a>, <em class="italic">Using Digital Asset Management</em>.</p>
			<h3>Relation components</h3>
			<p>These components are used to establish relations between different classes or to link class objects to documents or assets. Note that for assets <a id="_idIndexMarker270"/>relations, the asset preview will not be shown in the object like the previously mentioned group of components. All kinds of relations may be many-to-one or many-to-many. For many-to-many object relations, we can choose which fields we want to show in the relation box. We may also use <strong class="bold">Advanced relation components</strong> to add custom metadata fields to the relationship.</p>
			<p>We will have a look at relation details in the next section of this chapter.</p>
			<h3>Geographic Components</h3>
			<p>These<a id="_idIndexMarker271"/> particular kinds of fields allow us to search and put marks on a rendered map. You can add a simple geographic point or draw lines and polygons on the map. All points' latitude and longitude are stored in the database.</p>
			<h3>CRM Components</h3>
			<p>These components are designed to register customer information in<a id="_idIndexMarker272"/> Pimcore. We must pay attention that almost all these components, such as email, for example, have a fixed field name, so it's not possible to add this kind of component multiple times in the same class.</p>
			<h3>Other Components</h3>
			<p>This section contains a batch of mixed components.</p>
			<p>There are <a id="_idIndexMarker273"/>simple components such as <strong class="bold">Checkbox</strong> and <strong class="bold">Color</strong>, or <strong class="bold">Link</strong> to external websites. We can then cite the <strong class="bold">Encrypted Field</strong> component, which allows storing encrypted values in the database as long as a secret key has been generated and properly configured.</p>
			<p>We have mentioned all components apart from <strong class="bold">Calculated Value</strong>, because this particular kind of component is not intended to let the user input a value. By defining a PHP class that extends the <strong class="source-inline">Pimcore\Model\DataObject\ClassDefinition\CalculatorClassInterface</strong> interface, it's possible to dynamically calculate the value for the field, based on other object values. The calculated value is not stored in the database, but the calculation is made every time you open the object and every time the specific getter is invoked.</p>
			<p>To summarize, throughout this section we described all different kinds of components. Firstly, we introduced all the common properties of all data components. We then listed different kinds of components, specifying eventual additional properties for each of them. In the next section, we describe a particular type of data component named structured components.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Structured Components</h2>
			<p>These particular kinds of components are designed to extend the <a id="_idIndexMarker274"/>class definition, defining structures or patterns with groups of attributes that can be attached to class objects.</p>
			<p>We will see some of these components in action in future chapters regarding Product Information Management and Master Data Management features. Throughout this section, we will describe these components and when they are designed to be used.</p>
			<h3>Field-Collection</h3>
			<p>The most used component is <strong class="bold">Field-Collection</strong>. You can define your field collection in the same way that we explained for<a id="_idIndexMarker275"/> classes. Just go through <strong class="bold">Settings</strong> | <strong class="bold">Data Objects</strong> | <strong class="bold">Field-Collection</strong> and simply create a new one by adding layout and <a id="_idIndexMarker276"/>data components.</p>
			<p>On your class definition, a <strong class="bold">Field-Collection</strong> component can allow one or more different <strong class="bold">Field-Collection</strong> types. In the class object instances, you can dynamically add multiple instances of the defined field collection to add the same group of attributes multiple times. This kind of component is useful when you have certain properties that can appear with different cardinality in various objects. In the following figure, you can see a schema that outlines how the <strong class="bold">Field-Collection</strong> works:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_5.09_B17073.jpg" alt="Figure 5.9: Field-Collection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: Field-Collection</p>
			<p>As you can see in the preceding figure, we can add a <strong class="bold">Field-Collection</strong> component to the class definition. As we can do for the class definition, in the <strong class="bold">Field-Collection</strong> definition, we can add a set of layout and <a id="_idIndexMarker277"/>data components. In the class objects, you <a id="_idIndexMarker278"/>can add one or more instances of the same <strong class="bold">Field-Collection</strong>.</p>
			<h3>Objectbricks</h3>
			<p>With <strong class="bold">Objectbricks</strong>, unlike <strong class="bold">Field-Collection</strong>, objects can be extended without changing the class definition.</p>
			<p>Think about a fashion<a id="_idIndexMarker279"/> company that wants to store information<a id="_idIndexMarker280"/> about their products. We can easily imagine that shirts and shoes will have different attributes. Sure, we could create two different classes for shirts and shoes, but you would need to define redundant fields for properties that are not shared between the two classes.</p>
			<p>With <strong class="bold">Objectbricks</strong>, we just need to create little sets of attributes to describe specific fields and allow our class to dynamically add these bricks. As the name suggests, class objects can be composed of one or more bricks added to the common attributes.</p>
			<p>Similar to classes and <strong class="bold">Field-Collection</strong>, just go through <strong class="bold">Settings</strong> | <strong class="bold">Data Objects</strong> | <strong class="bold">Objectbricks</strong> to define them. <strong class="bold">Objectbricks</strong> is inheritable between parent and child objects.</p>
			<p>In the following figure, you can see a schema that illustrates how <strong class="bold">Objectbricks</strong> works:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_5.10_B17073.jpg" alt="Figure 5.10: Objectbricks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Objectbricks</p>
			<p>As you can see in the preceding figure, we can add an <strong class="bold">Objectbricks</strong> component to the class definition. In the class instances, we can attach one or more bricks to add specific sets of components to the object itself, to give a categorization to the object.</p>
			<h3>Localized fields</h3>
			<p>We may also need to define attributes that should be<a id="_idIndexMarker281"/> translated into multiple languages within an object, such as titles and descriptions for a multilanguage site. Using <a id="_idIndexMarker282"/>the <strong class="bold">Localized Fields</strong> component, we just have to insert child components inside and configure languages in <strong class="bold">System Settings</strong>. In the following screenshot, we can see how the component is rendered on objects:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_5.11_B17073.jpg" alt="Figure 5.11: Localized Fields&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Localized Fields</p>
			<p>As you can see, a specific tab is added in the component for each defined language.</p>
			<h3>Block</h3>
			<p>The <strong class="bold">Block</strong> component acts as a simple container for other data <a id="_idIndexMarker283"/>components. Similar to <strong class="bold">Field-Collection</strong>, an unlimited number of block elements can be created. The block data just gets serialized<a id="_idIndexMarker284"/> into a single database column. As a consequence, this container type is not suitable if you are planning to query the data.</p>
			<h3>Tables</h3>
			<p>Two other quite simple components are <strong class="bold">Table</strong> and <strong class="bold">Structured Table</strong>. In a <strong class="bold">Table</strong> component<a id="_idIndexMarker285"/>, you can <a id="_idIndexMarker286"/>dynamically add rows and columns inside objects, or define a fixed number of rows and columns in the component definition. In the database, values for tables are stored in a <strong class="source-inline">TEXT</strong> field, with column values separated by the pipe character. Structured tables respect the same principle, but rows and columns are always fixed and named.</p>
			<h3>Classification store</h3>
			<p>The final and most complex component is <strong class="bold">Classification Store</strong>. This <a id="_idIndexMarker287"/>component allows you to define a hierarchical key-value pairs structure to dynamically add groups of attributes to class object instances. To define<a id="_idIndexMarker288"/> a <strong class="bold">Classification Store</strong> component, go through <strong class="bold">Settings</strong> | <strong class="bold">Data Objects</strong> | <strong class="bold">Classification Store</strong>. To properly create a classification store, we must define the following:</p>
			<ul>
				<li><strong class="bold">Key Definitions</strong>: Define keys for your classification store. All basic data components are available for that purpose. For each key, we can choose whether it should be mandatory or editable, and other standard properties.</li>
				<li><strong class="bold">Groups</strong>: Select one or more keys to define groups. Within the group, you can define which keys are mandatory and define the order.</li>
				<li><strong class="bold">Group Collections</strong>: Different groups can be grouped into collections. In the object edit modal, we can add one or more of the defined collections.</li>
			</ul>
			<p>Now that you have discovered all kinds of data components, in the next section, we will focus on relations, looking in depth into component definitions and providing a concrete example of relations.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Understanding and Establishing Relations</h1>
			<p>In this section, we will look in depth into how to relate objects with<a id="_idIndexMarker289"/> other entities in Pimcore. As we have seen in the previous section, the first step is to add the appropriate fields onto our class to configure relations between two classes, or relations between classes and other entities (such as documents or assets). Here, you will see all the different kinds of relation components:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_5.12_B17073.jpg" alt="Figure 5.12: Relation components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Relation components</p>
			<p>As you may see, there are two main different types of relation fields, the generic relation fields that allow relating objects, documents, or assets, and specific relation fields for object classes. For each type, we can establish a many-to-one relation, many-to-many relation, or advanced many-to-many relation. The last one lets you define some additional metadata fields that can be attached to the relation instances.</p>
			<p>In the following sections, we will <a id="_idIndexMarker290"/>focus on the two main types of relation components, which are as follows:</p>
			<ul>
				<li><strong class="bold">Generic Relations</strong>: Relations between an object instance and other entities (this could include another object or instances of assets or documents).</li>
				<li><strong class="bold">Object Relations</strong>: Specific relations between object instances.</li>
			</ul>
			<p>Let's see the details of these different types of relations.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/>Generic Relations</h2>
			<p>The <strong class="bold">Generic Relations</strong> field allows relations <a id="_idIndexMarker291"/>between object instances and other previously created entities, which could be either other objects, documents, or assets. It's not possible to decide which properties of related entities we want to show on the object. For many-to-one relations, only the entity path is shown; for many-to-many relations, the ID and entity type are shown as additional information.</p>
			<p>Besides, we can provide some limitations to the relation attribute, in particular, the following:</p>
			<ul>
				<li>For documents, we can specify which types are allowed in the relation. If none are selected, all types are allowed.</li>
				<li>For assets, we can specify which types are allowed in the relation. If no specific one is selected, all<a id="_idIndexMarker292"/> types are allowed. There is also the possibility to define an upload path for assets that could be directly uploaded through the object.</li>
				<li>For objects, we can specify which classes are allowed in the relation. If no specific one is selected, all classes are allowed.</li>
			</ul>
			<p>In the next section, we will focus on the other kind of relation components, the ones specifically used to relate objects.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Object Relations</h2>
			<p>This kind of relationship is strictly limited to relations between<a id="_idIndexMarker293"/> objects. As for the previous group, there is the possibility to limit the relations to one or more classes. The main difference is that we can select which fields we want to show in the relationship within the object element. But if more than one class is selected, only common fields between the involved classes can be selected.</p>
			<p>For advanced relations, we can define specific metadata fields for each relation. These fields could be created as one of the basic data types (<strong class="bold">Text</strong>, <strong class="bold">Number</strong>, <strong class="bold">Boolean</strong>, or <strong class="bold">Select</strong>) and will be added after the original object fields. Another particular component is <strong class="bold">Reverse Many-To-Many Object Relation</strong>. This component could only work if <strong class="bold">Many-To-Many Object Relation</strong> was previously configured.</p>
			<p>In the following section, through a concrete example, we will see how to practically use relation components to connect objects of different classes.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/>A Concrete Example of Relations</h2>
			<p>To provide a concrete example, think about <a id="_idIndexMarker294"/>products and categories. We can specify a direct relation between a <strong class="source-inline">Product</strong> class and a <strong class="source-inline">Category</strong> class, and specify a reverse relation in the <strong class="source-inline">Category</strong> class that is related to the direct one. Let's first create a <strong class="source-inline">Product</strong> class. Follow the steps given here:</p>
			<ol>
				<li value="1">For the first component, add a tabpanel called <strong class="source-inline">Product Data</strong>.</li>
				<li>Create a panel named <strong class="source-inline">General Information</strong> as a child of the previously created tabpanel component.</li>
				<li>Add an input field for the product title and then save your class.</li>
				<li>Create the <strong class="source-inline">Category</strong> class. </li>
				<li>Then create the <strong class="source-inline">Product</strong> class. Here, create a new panel and add the <strong class="bold">code</strong> and <strong class="bold">name</strong> fields, and then save the class.</li>
				<li>Now, come back to the product class and add a many-to-many relation component to relate the <strong class="source-inline">Product</strong> and <strong class="source-inline">Category</strong> classes. </li>
				<li>On the relation, specify that you want to show <strong class="bold">code</strong> and <strong class="bold">name</strong> properties, and save the class again.</li>
				<li>Now, we can add a reverse relation component to the <strong class="source-inline">Category</strong> class. To add this component, we just need to define the class and field for the original relation. Set this component as not editable, to make the reverse relation completely automatic.</li>
			</ol>
			<p>In the following screenshot, we can see the final result:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_5.13_B17073.jpg" alt="Figure 5.13: Reverse Many-To-Many Object Relation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Reverse Many-To-Many Object Relation</p>
			<p>In the preceding <a id="_idIndexMarker295"/>screenshot, you can see how the configured components appear. On the left side, we can see the components that appear in the class configuration tree. On the right side, there are some specific settings of the defined components. On top of that, we can see the many-to-many relation component that relates the <strong class="source-inline">Product</strong> class with the <strong class="source-inline">Category</strong> class. On the bottom, the reverse relation is shown.</p>
			<p>In this section, you learned how to relate classes with other entities. In the next section, we will see how these defined relations are reflected in object data entry.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Performing Data Entry</h1>
			<p>In this section, we <a id="_idIndexMarker296"/>will check how class definitions are reflected in concrete object instances, discovering how to create Pimcore objects and perform data entry to fill their information. We will see how to easily create folders and objects, how to relate them, and how to create object variants. Then we will discover how easy and fast it is to add new attributes or edit some existing ones, paying attention to this last point to avoid the loss of data.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor108"/>Creating Folders and Objects</h2>
			<p>In Pimcore, unlike<a id="_idIndexMarker297"/> what you might think, folders are just instances of a common base class for which we are not able to add custom attributes. It's not mandatory to create folders; think of it just as a helping feature to organize your objects semantically as you do on your PC desktop. Different folders can be nested in a tree structure. To create your first folder, follow the steps given here:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Data Objects</strong> section on the main left panel, and right-click the <strong class="bold">Home</strong> element.</li>
				<li>Select <strong class="bold">Add Folder</strong> and type your folder name. As you may see when hovering on that element, <strong class="source-inline">Home</strong> is a special folder object with <strong class="bold">Id</strong> equal to <strong class="source-inline">1</strong>. This component cannot be deleted, and it will be the root element for the whole tree structure.</li>
				<li>Having said that, let's create a <strong class="source-inline">Products</strong> folder and a <strong class="source-inline">Categories</strong> folder. Once again, this naming is just needed to separate concepts, but it's not mandatory. You can create all objects within a unique folder, or as direct children of the <strong class="source-inline">Home</strong> component itself.</li>
				<li>Right-click on the created folders to add objects inside them, choosing the class and adding the object name. Note that these names are just keys that appear in the tree structure and must be unique within the same folder, but they are completely unrelated to any class data property.</li>
				<li>With this information, let's create a <strong class="source-inline">Product</strong> object. As previously defined in the class definition, an input field for the product title can be filled. The relation with categories cannot be done yet, because we need to create categories first.</li>
				<li>Replicate the previous actions to add a couple of category objects in the dedicated folder, and fill in the information for them. You will see that it will not be possible to select a related product since we have a reverse relation.</li>
				<li>Switch back to the product and click on the search button in the relation component to select the created categories, and save the product.</li>
				<li>Refresh the <a id="_idIndexMarker298"/>category objects, and see how the relation with the product appears. The result is shown in the following figure:</li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_5.14_B17073.jpg" alt="Figure 5.14: Object relations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Object relations</p>
			<p>In the preceding figure, we see clearly how objects are mutually related. As you may see in the direct relation component, the categories attribute that we required in the component configuration is shown in the relation.</p>
			<p>In the next section, you will learn how inheritance work and how to add object variants.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Adding Object Variants</h2>
			<p>If enabled in <a id="_idIndexMarker299"/>the class definition, it's possible to add variants for the created objects. To create a variant, just right-click on the previously created object, select <strong class="bold">Add Variant</strong>, and type the variant name.</p>
			<p>The variants inherit all values from parent properties. As you will see in the following screenshot, inherited values appear as read-only, but it's possible to override the value on variants:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_5.15_B17073.jpg" alt="Figure 5.15: Object variants&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Object variants</p>
			<p>Variants appear in the object tree structure like other objects, but for each object, it is possible to<a id="_idIndexMarker300"/> easily access variants by clicking on the opposite button in the object toolbar.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/>Editing Classes and Objects</h2>
			<p>In the <em class="italic">Creating and Editing a Class Definition</em> section, we saw how easy it is to create a class and add some data components. One big advantage of using Pimcore is that this can be<a id="_idIndexMarker301"/> done incrementally since we can add new <a id="_idIndexMarker302"/>components or edit existing ones at any time.</p>
			<p>Every operation on a class is reflected in the corresponding PHP class and, above all, in the database tables. For these reasons, editing data components could be dangerous and lead, in the worst scenario, to the loss of data. Obviously, if an input component is converted into a relation component, or if a checkbox becomes an image component, loss of data is expected. This is not our focus, but we will point our attention to apparently safe operations that are not safe at all because they could lead to irreversible loss of data. These are covered in the following sections.</p>
			<h3>Text To Number</h3>
			<p>Converting a numeric component into a text one will never lead to<a id="_idIndexMarker303"/> loss of data because it just <a id="_idIndexMarker304"/>alters the database column from decimal to text, and decimal values are valid input for a text column. The opposite flow is not valid at the same. In this scenario, we have three possible cases:</p>
			<ul>
				<li>If the field value is a valid number, the data will be safe.</li>
				<li>If the field value is a mixed number with text, only the "numeric" part is left, removing all content after the first encountered letter or whitespace.</li>
				<li>If the field value is text, the converted value becomes <strong class="source-inline">0</strong>.</li>
			</ul>
			<p>Let's now see what the risks of changing data types between different kinds of numeric fields are.</p>
			<h3>Number to QuantityValue</h3>
			<p>We may think that this operation has no risks because <a id="_idIndexMarker305"/>we are just attaching a unit of measure<a id="_idIndexMarker306"/> to our numeric value, but this is quite false.</p>
			<p>Indeed, in object tables, the original numeric column is dropped with the inevitable loss of data, and two new columns are created. In particular, given a certain "fieldname," we have the following columns:</p>
			<ul>
				<li><strong class="source-inline">fieldname__value</strong></li>
				<li><strong class="source-inline">fieldname__unit</strong></li>
			</ul>
			<p>For this reason, modifying numeric components to <strong class="source-inline">QuantityValue</strong> is discouraged.</p>
			<h3>Moving a Component to LocalizedFields</h3>
			<p>If we move a component into<a id="_idIndexMarker307"/> LocalizedFields, data of the component is lost. This happens because the database column is dropped from the main object table and created in the specific localized table for each defined language.</p>
			<p>In this section, we described different aspects of data entry. Firstly, you learned how to create folders and objects on the object tree, and how to create object variants. Then, you discovered<a id="_idIndexMarker308"/> how to prevent data loss during class definition editing, avoiding risky operations on changing component types.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we learned about the concept of classes. In Pimcore, a class represents the definition of a concept, such as a product or a category. We can add both layout and data components to model our classes and integrate them at any time, along with adding or editing their properties.</p>
			<p>We learned that to define a class, it's not necessary to write any code or to create database tables, because Pimcore does all the magic updating the code and database every time you make a change on the class.</p>
			<p>We know it's possible to create a custom PHP class that can be extended by one or more classes; this could be useful to add class methods to be used in development. With the same principle, it's possible to define rules to provide default values for class fields or calculate values for particular kinds of components.</p>
			<p>We also learned how we can relate different classes, or link assets and documents to class objects using a particular kind of component, and how to define inheritance rules for classes. Then we learned about data entry and how it is made simple by the easy-to-use Pimcore interface; every change in the class definition is immediately reflected on the objects; you just need to refresh.</p>
			<p>In the next chapter, we will discover the DAM Pimcore feature, and how it helps us to manage multimedia contents and prepare them for distribution.</p>
		</div>
	</body></html>