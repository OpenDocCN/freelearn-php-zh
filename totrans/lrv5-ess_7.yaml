- en: Chapter 7. Authentication and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 认证和安全
- en: 'In this chapter, we will improve the application we built in [Chapter 3](ch03.html
    "Chapter 3. Your First Application"), *Your First Application*, by adding a simple
    authentication mechanism and addressing any security issues with the existing
    code base. In doing so, you will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加简单的认证机制和解决现有代码库中的任何安全问题来改进我们在[第3章](ch03.html "第3章. 你的第一个应用程序")中构建的应用程序，即*你的第一个应用程序*。通过这样做，你将了解：
- en: Configuring and using the authentication service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用认证服务
- en: Middleware and how to apply it to specific routes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件及其如何应用于特定路由
- en: Data validation and form requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证和表单请求
- en: The most common security vulnerabilities in web applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序中最常见的安全漏洞
- en: How Laravel can help you write more secure code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel如何帮助你编写更安全的代码
- en: Authenticating users
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证用户
- en: Allowing users to register and sign in is an extremely common feature in web
    applications. Yet, PHP does not dictate how it should be done, nor does it give
    you any helpers to implement it. This has led to the creation of disparate, and
    sometimes insecure, methods of authenticating users and restricting access to
    specific pages. In that respect, Laravel provides you with different tools to
    make these features more secure and easier to integrate. It does so with the help
    of its authentication service and functionality that we have not covered yet—**middleware**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户注册和登录是网络应用程序中极其常见的功能。然而，PHP并没有规定应该如何实现，也没有提供任何辅助函数来实现它。这导致了不同的、有时是不安全的用户认证方法和限制对特定页面的访问方法的产生。在这方面，Laravel为你提供了不同的工具来使这些功能更安全且更容易集成。它是通过其认证服务和尚未覆盖的功能——**中间件**来实现的。
- en: Creating the user model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: First of all, we need to define the model that will be used to represent the
    users of our application. Laravel already provides you with sensible defaults
    inside `config/auth.php`, where you can change the model or table that is used
    to store your user accounts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个模型来表示我们应用程序的用户。Laravel已经在`config/auth.php`中为你提供了合理的默认设置，你可以在那里更改用于存储用户账户的模型或表。
- en: 'It also comes with an existing `User` model inside `app/User.php`. For the
    purposes of this application, we are going to simplify it slightly, remove certain
    class variables, and add new methods so that it can interact with the `Cat` model
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含一个现有的`User`模型，位于`app/User.php`中。为了这个应用程序的目的，我们将对其进行轻微简化，删除某些类变量，并添加新方法，以便它可以与`Cat`模型交互如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to note is that this model implements the `Authenticable` interface.
    Remember that an interface does not give any implementation details. It is nothing
    more than a **contract** that specifies the names of the methods that a class
    should define when it implements the interface. In this case, the `Authenticable`
    interface mandates that the following methods be implemented:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个模型实现了`Authenticable`接口。记住，接口并不提供任何实现细节。它不过是一个**合同**，它指定了一个类在实现接口时应定义的方法名称。在这种情况下，`Authenticable`接口强制要求实现以下方法：
- en: '`getAuthIdentifier`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAuthIdentifier`'
- en: '`getAuthPassword`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAuthPassword`'
- en: '`getRememberToken`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRememberToken`'
- en: '`setRememberToken`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRememberToken`'
- en: '`getRememberTokenName`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRememberTokenName`'
- en: 'If you open the `app/User.php` file, you might wonder where these methods are.
    These methods are actually provided by the `Authenticable` trait. You can see
    the trait being included after the `User` class''s opening brace:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`app/User.php`文件，你可能会想知道这些方法在哪里。实际上，这些方法是由`Authenticable`特性提供的。你可以在`User`类的大括号后面看到这个特性被包含进来：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Traits allow the reuse of code within classes. This is to make up for a shortcoming
    of the PHP language, which does not allow **multiple inheritance** in classes.
    So, as a workaround, you can compose methods that may be dropped into multiple
    classes that might already be extending another base class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特性允许在类中重用代码。这是为了弥补PHP语言的一个不足，即不允许类中的**多重继承**。因此，作为一个解决方案，你可以组合可能被放入多个类中的方法，这些类可能已经扩展了另一个基类。
- en: In our `User` model, the `cats()` method simply defines the `hasMany` relationship
    with the `Cat` model. The last two methods will be used to check whether a given
    `Cat` instance is owned or is editable by the current `User` instance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`User`模型中，`cats()`方法简单地定义了与`Cat`模型的`hasMany`关系。最后两个方法将用于检查给定的`Cat`实例是否由当前`User`实例拥有或可编辑。
- en: 'Finally, let''s create a helper method on the `User` model that will allow
    us to check whether we have an administrator or not. This method will be suitably
    named `isAdministrator` as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在 `User` 模型上创建一个辅助方法，以便我们可以检查我们是否有管理员权限。这个方法将被命名为 `isAdministrator`，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If using MySQL, this will return a string of either `0` or `1` (as MySQL doesn''t
    have a native Boolean data type). We can, however, cast this model attribute to
    be a Boolean to make value checking a bit better. At the top of your model, add
    the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 MySQL，这将返回一个由 `0` 或 `1` 组成的字符串（因为 MySQL 没有原生的布尔数据类型）。然而，我们可以将这个模型属性转换为布尔类型，以便值检查更好。在你的模型顶部添加以下代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this array, we define the attribute and what data type we actually want.
    Then, when we retrieve an attribute from the model, it will be cast to the specified
    data type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数组中，我们定义了属性以及我们实际上想要的数据类型。然后，当我们从模型中检索属性时，它将被转换为指定的数据类型。
- en: 'Other data types that model attributes can be cast to are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可以转换为模型属性的 数据类型有如下：
- en: '`string`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`integer`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integer`'
- en: '`real`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`'
- en: '`float`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`array`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integer`'
- en: The `array` type can be used for columns that contain a serialized JSON string,
    which will de-serialize the data and present it as a plain PHP array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`array` 类型可用于包含序列化 JSON 字符串的列，它将反序列化数据并将其呈现为普通的 PHP 数组。'
- en: The `is_admin` attribute doesn't exist in our `users` table currently, so let's
    fix that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的 `users` 表中不存在 `is_admin` 属性，所以让我们修复这个问题。
- en: Creating the necessary database schema
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建必要的数据库模式
- en: 'As well as a `User` model, Laravel also comes pre-packaged with two migration
    files: one for creating the `users` table and the other to create the `password_resets`
    table.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `User` 模型外，Laravel 还预包装了两个迁移文件：一个用于创建 `users` 表，另一个用于创建 `password_resets`
    表。
- en: By default, the user's table migration creates a table with columns for each
    user's ID, name, password, remember token, as well as the created at and updated
    at timestamps. We need to extend that table by adding a new column designating
    whether each user is an administrator of our application or not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户表迁移创建了一个包含每个用户的 ID、名称、密码、记住令牌以及创建时间和更新时间的列的表。我们需要通过添加一个新列来扩展该表，指定每个用户是否是应用程序的管理员。
- en: To do this, we can create another migration. Migrations can be used to alter
    existing tables as well as creating entirely new ones. In this instance, we're
    going to create a migration to add a Boolean column named `is_admin` to the `users`
    table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以创建另一个迁移。迁移可以用来修改现有的表，也可以用来创建全新的表。在这个例子中，我们将创建一个迁移来向 `users` 表添加一个名为
    `is_admin` 的布尔列。
- en: 'Run the following command to create the migration file in `database/migrations`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以在 `database/migrations` 中创建迁移文件：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then change the `up` method as follows to contain the schema change:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `up` 方法更改为如下，以包含模式更改：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We set the default value to `false` so that we have to explicitly set it to
    `true` for any users we want to be administrators, rather than every new user
    (and any existing users in the database table) automatically being granted administrator
    privileges on creation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将默认值设置为 `false`，这样我们才必须显式地将任何我们希望成为管理员的用户设置为 `true`，而不是每个新用户（以及数据库表中的任何现有用户）在创建时自动获得管理员权限。
- en: 'As with any other migration, we also have to provide the `down` method to revert
    any changes. As we''ve created a column, we need to remove it if a user decides
    to roll back the migration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他迁移一样，我们也必须提供 `down` 方法来回滚任何更改。由于我们已经创建了一个列，如果用户决定回滚迁移，我们需要将其删除：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we also need to update the `cats` database table to add a column associating
    it with a user. By following the preceding steps, we create a new schema, as follows,
    describing the change:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要更新 `cats` 数据库表，添加一个与用户关联的列。通过遵循前面的步骤，我们创建了一个新的模式，如下所示，描述了更改：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then complete the methods as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们按照以下方式完成方法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the preceding code, we alter the `cats` table to have a `user_id` column
    that stores the `id` of the `Cat` owner. After creating the column, we create
    a **foreign key constraint** on the table so that a `user_id` value has to match
    the primary key of a record in the `users` table. Foreign keys help you to enforce
    the consistency of data (for example, you will not be able to assign `Cat` to
    a nonexistent user). Cascading deletes also means that when a user is deleted,
    their associated cat records will be deleted too; otherwise, the database will
    end up containing cats that no longer have any owners!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们修改 `cats` 表以包含一个 `user_id` 列，该列存储 `Cat` 拥有者的 `id`。在创建列之后，我们在表上创建一个
    **外键约束**，以确保 `user_id` 值必须匹配 `users` 表中记录的主键。外键有助于你强制数据的一致性（例如，你将无法将 `Cat` 分配给不存在的用户）。级联删除还意味着当用户被删除时，其关联的猫记录也将被删除；否则，数据库将包含不再有任何所有者的猫！
- en: 'The code to reverse this migration will simply remove the foreign key constraint
    and the column and then drop the `user_id` column:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 反转此迁移的代码将简单地删除外键约束和列，然后删除 `user_id` 列：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we prepare a database seeder to create two users for our application,
    one of which will be an administrator.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备一个数据库填充器来为我们的应用程序创建两个用户，其中一个将是管理员。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once you have saved this code inside a new file named `database/seeds/UsersTableSeeder.php`,
    do not forget to call it inside the main `DatabaseSeeder` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将此代码保存在一个名为 `database/seeds/UsersTableSeeder.php` 的新文件中，不要忘记在主 `DatabaseSeeder`
    类中调用它。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Laravel expects all passwords to be hashed with the `bcrypt` helper, which uses
    the **Bcrypt** algorithm to create a strong hash. You should never store passwords
    in *cleartext* or hash them with weak algorithms, such as `md5` or `sha1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 预期所有密码都使用 `bcrypt` 辅助函数进行散列，该函数使用 **Bcrypt** 算法创建强散列。你不应该在 *明文* 中存储密码或使用弱算法（如
    `md5` 或 `sha1`）对其进行散列。
- en: 'To run the migration and seed the database at the same time, enter the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时运行迁移和填充数据库，请输入以下命令：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Authentication routes and views
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证路由和视图
- en: 'We have mentioned earlier that PHP has no standard way to authenticate users,
    but this is not true of Laravel. Laravel realizes that the most modern web applications
    will require users to register and log in, so it comes with controllers, routes,
    and views to facilitate this from the get-go. You can find the main authentication
    controller at `app/Http/Controllers/Auth/AuthController.php`. If you open the
    file, you will see that all it contains is a constructor because like the `User`
    model, it uses a trait to provide functionality, in this case, `AuthenticatesAndRegistersUsers`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到 PHP 没有标准的用户认证方式，但 Laravel 并非如此。Laravel 认识到最现代的 Web 应用程序将需要用户注册和登录，因此它自带控制器、路由和视图，以便从一开始就方便地完成这些操作。你可以找到主要的认证控制器在
    `app/Http/Controllers/Auth/AuthController.php`。如果你打开该文件，你会看到它只包含一个构造函数，因为像 `User`
    模型一样，它使用一个特质来提供功能，在这种情况下，是 `AuthenticatesAndRegistersUsers`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `middleware` method will apply the guest middleware to all actions in the
    controller, except the `getLogout()` action. We'll look at middleware in more
    depth later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`middleware` 方法将应用访客中间件到控制器中的所有操作，除了 `getLogout()` 操作。我们将在本章的后面更深入地探讨中间件。'
- en: 'This controller (as well as the controller used for handling password resets)
    can be found in the application''s routes file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器（以及用于处理密码重置的控制器）可以在应用程序的路由文件中找到：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Laravel also includes two views, `login.blade.php` and `register.blade.php`,
    at `resources/views/auth`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 还在 `resources/views/auth` 中包含了两个视图，`login.blade.php` 和 `register.blade.php`。
- en: 'Let''s look at integrating Laravel''s `auth` views into our application. We
    will start by amending our master layout (`resources/views/layouts/master.blade.php`)
    to display the login link to guests and the logout link to users who are logged
    in. To check whether a visitor is logged in, we use the `Auth::check()` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 Laravel 的 `auth` 视图集成到我们的应用程序中。我们将首先修改我们的主布局（`resources/views/layouts/master.blade.php`）以显示登录链接给访客，以及显示注销链接给已登录的用户。为了检查访客是否已登录，我们使用
    `Auth::check()` 方法：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can replace the login view, inside `resources/views/auth/login.blade.php`,
    with a simpler form:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `resources/views/auth/login.blade.php` 内替换登录视图，使用一个更简单的表单：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the Blade syntax to get the raw value (`{!! $value !!}`) from the HTML
    and Form helpers because they return HTML mark-up, and if we were to use the default
    syntax (`{{ $value }}`) to render these, we'd instead get the HTML string printed
    to the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Blade语法从HTML和表单辅助函数中获取原始值（`{!! $value !!}`），因为它们返回HTML标记，如果我们使用默认语法（`{{
    $value }}`）来渲染这些，我们会在屏幕上打印HTML字符串。
- en: Middleware
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: 'If you refer back to the `AuthController`, you will notice the following line
    in the constructor method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下`AuthController`，你会在构造方法中注意到以下行：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Middleware includes classes that can be attached to requests coming into your
    application, and used to alter the results of those requests. Middleware are a
    replacement for **route filters** that were found in Laravel 4.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件包括可以附加到进入您应用程序的请求的类，并用于更改这些请求的结果。中间件是Laravel 4中发现的**路由过滤器**的替代品。
- en: Middleware can be registered either when defining routes, or in controllers
    as mentioned earlier. The preceding example attaches the `auth` middleware to
    all requests that will be handled by the `AuthController`, except for requests
    to the `getLogout` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以在定义路由时注册，或者在前面提到的控制器中注册。前面的例子将`auth`中间件附加到所有将由`AuthController`处理的请求上，除了对`getLogout`方法的请求。
- en: 'Middleware classes can be found in the `app/Http/Middleware` directory. In
    here, you can find the default `Authentication` middleware class, as well as two
    others: `RedirectIfAuthenticated`, and `VerifyCsrfToken`. We can inspect the `Authentication`
    class to see how a middleware class works:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件类可以在`app/Http/Middleware`目录中找到。在这里，你可以找到默认的`Authentication`中间件类，以及另外两个：`RedirectIfAuthenticated`和`VerifyCsrfToken`。我们可以检查`Authentication`类来了解中间件类是如何工作的：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are two methods: the `constructor` and the `handle` methods. In the preceding
    example, the class is checking whether the current user is authenticated (using
    the `guest()` method on the `Guard` class) and if they are a guest, returning
    a response if the request was made via AJAX, or redirecting the user to the login
    form. Because the response is returned then and there, the request will not be
    processed any further.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个方法：构造方法和`handle`方法。在先前的例子中，该类正在检查当前用户是否已认证（使用`Guard`类上的`guest()`方法），如果是访客，则如果请求是通过AJAX进行的，则返回响应，或者将用户重定向到登录表单。因为响应是在那里返回的，所以请求将不会进一步处理。
- en: 'We can use this approach to not only check if users have authenticated, but
    also to check whether they are administrators. We can use the in-built Artisan
    generator to create a new middleware class as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法来检查用户是否已认证，还可以检查他们是否是管理员。我们可以使用内置的Artisan生成器创建一个新的中间件类，如下所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will create a new file at `app/Http/Middleware/IsAdministrator.php`. Like
    the `Authentication` class, we need the `Guard` implementation, so add a constructor
    that type-hints the dependency so that the service container automatically injects
    it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`app/Http/Middleware/IsAdministrator.php`创建一个新文件。像`Authentication`类一样，我们需要`Guard`实现，所以添加一个构造函数，将依赖项的类型提示，以便服务容器自动注入它：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll also need to import the full namespace at the top of the file as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在文件顶部导入完整的命名空间，如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have a `Guard` instance and we assign it to a class property; we can
    now flesh out the `handle` method as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Guard`实例，并将其分配给一个类属性；我们现在可以完善`handle`方法，如下所示：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, we get the current user from the `Guard` (which will yield a `User`
    Eloquent model instance). We can then call any methods on this model. In the preceding
    example, we call our `isAdministrator()` method, which will return a Boolean value
    as to whether the user should be treated as an administrator or not. If not—like
    the `Authenticated` class—we return a simple string response (and the appropriate
    HTTP status code) if the request was made via AJAX; otherwise, we throw an `AccessDeniedHttpException`.
    This exception is actually part of the Symfony `HttpKernel` library, so we need
    to import the class''s full namespace at the top of the file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们从`Guard`中获取当前用户（这将产生一个`User` Eloquent模型实例）。然后我们可以调用这个模型上的任何方法。在先前的例子中，我们调用了我们的`isAdministrator()`方法，这将返回一个布尔值，表示用户是否应该被视为管理员。如果不是——就像`Authenticated`类一样——如果请求是通过AJAX进行的，我们返回一个简单的字符串响应（以及适当的HTTP状态码）；否则，我们抛出一个`AccessDeniedHttpException`。这个异常实际上是Symfony
    `HttpKernel`库的一部分，所以我们需要在文件顶部导入类的完整命名空间：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final step in creating a middleware is to tell the HTTP `Kernel` class
    about it. You can find this file at `app/Http/Kernel.php`. By opening the file,
    you will see two properties defined: `$middleware` and `$routeMiddleware`. Adding
    the class''s full namespace to the `$middleware` array would add the middleware
    to every request. We don''t want to do this because if we did, no one would be
    able to access the login page as they''d be unauthenticated at this point! Instead,
    we want to add an entry to the `$routeMiddleware` array as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建中间件的最后一步是告诉 HTTP `Kernel` 类关于它。你可以在这个文件中找到它：`app/Http/Kernel.php`。通过打开这个文件，你会看到定义了两个属性：`$middleware`
    和 `$routeMiddleware`。将类的完整命名空间添加到 `$middleware` 数组中会将中间件添加到每个请求中。我们不想这样做，因为如果我们这样做，就没有人能够访问登录页面了，因为他们在这个时候将不会被认证！相反，我们想要将一个条目添加到
    `$routeMiddleware` 数组中，如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key in the array is what we can then use on routes and in controllers, and
    the corresponding class will be applied when requesting the specified resource.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的键是我们可以在路由和控制器中使用的内容，并且当请求指定的资源时，将应用相应的类。
- en: 'The following is an example applying it to a route:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个将此应用于路由的示例：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, you can specify multiple middleware classes to apply to a single
    request. In the previous route example, first the `Authenticated` middleware class
    will be called; if all is good (and the user wasn't redirected to the login page),
    it will then be passed to the `IsAdministrator` middleware class, which will check
    whether the currently logged in user is an administrator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以指定多个中间件类来应用于单个请求。在先前的路由示例中，首先会调用 `Authenticated` 中间件类；如果一切顺利（并且用户没有被重定向到登录页面），它将被传递到
    `IsAdministrator` 中间件类，该类将检查当前登录的用户是否是管理员。
- en: Validating user input
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Our application still has a major flaw—it does not perform any validation on
    the data submitted by users. While you might end up with a series of conditions
    with regular expressions here and there if you were to do this in plain PHP, Laravel
    offers a far more straightforward and robust way to achieve this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序仍然有一个重大缺陷——它不对用户提交的数据进行任何验证。虽然如果你用纯 PHP 做这件事，可能会得到一系列带有正则表达式的条件，但 Laravel
    提供了一种更简单、更健壮的方式来实现这一点。
- en: 'Validation is performed by passing an array with the input data and an array
    with the validation rules to the `Validator::make($data, $rules)` method. In the
    case of our application, here are the rules we could write:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个包含输入数据的数组和一个包含验证规则的数组到 `Validator::make($data, $rules)` 方法来执行验证。在我们的应用程序中，以下是我们可以编写的规则：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Multiple validation rules can be separated by either pipes or passed as an
    array (examples of both are shown in the preceding code). Laravel provides over
    30 different validation rules, and they are all documented in here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过管道符号或作为数组传递来分隔多个验证规则（前述代码中展示了这两种示例）。Laravel 提供了超过 30 种不同的验证规则，它们都记录在这里：
- en: '[http://laravel.com/docs/validation#available-validation-rules](http://laravel.com/docs/validation#available-validation-rules)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://laravel.com/docs/validation#available-validation-rules](http://laravel.com/docs/validation#available-validation-rules)'
- en: 'Here is how we will check these rules with the data submitted in the form:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用表单提交的数据来检查这些规则：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can then make your application act based on the output of `$validator->fails()`.
    If this method call returns `true`, you will retrieve an object containing all
    error messages with `$validator->messages()`. If you were validating data in a
    controller action, you could attach this object to a redirection that sends the
    user back to the form:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以根据 `$validator->fails()` 的输出使你的应用程序做出响应。如果这个方法调用返回 `true`，你将使用 `$validator->messages()`
    获取包含所有错误信息的对象。如果你在一个控制器动作中验证数据，你可以将这个对象附加到重定向中，将用户送回表单：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since each field can have zero or more validation errors, you will use a condition
    and a loop with the following methods to display those messages:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个字段可以有零个或多个验证错误，你将使用条件语句和循环以及以下方法来显示这些消息：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You might also use a tool such as Ardent, which extends Eloquent and lets you
    to write validation rules directly inside the model. You can download Ardent from
    the following link:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用像 Ardent 这样的工具，它扩展了 Eloquent，并允许你直接在模型中编写验证规则。你可以从以下链接下载 Ardent：
- en: '[https://github.com/laravelbook/ardent](https://github.com/laravelbook/ardent)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/laravelbook/ardent](https://github.com/laravelbook/ardent)'
- en: Form requests
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单请求
- en: In Laravel 4, you were free to place validation anywhere you wanted. This led
    to developers implementing validation in a myriad of ways, including in the controller
    or as a validation service. In version 5, Laravel introduced a way of standardizing
    how validation was performed on submitted data, via **form requests**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laravel 4中，你可以自由地将验证放在任何你想放的地方。这导致开发者以无数种方式实现验证，包括在控制器中或作为验证服务。在版本5中，Laravel引入了一种标准化提交数据验证的方法，即通过**表单请求**。
- en: Form requests are classes that wrap the standard `Request` class in Laravel,
    but implements a trait named `ValidatesWhenResolved`. This trait contains a `Validator`
    instance, and uses rules you define in your form request class to validate the
    data in the request. If the validator passes, then the controller action it was
    applied to will be executed as normal. If the validator fails, then the user is
    redirected to the previous URL with the errors in the session. This means you
    don't need to define validation routines in your controller actions, and you can
    even re-use them across controller actions where the same data can be submitted
    but in different scenarios.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表单请求是封装Laravel标准`Request`类的类，但实现了名为`ValidatesWhenResolved`的特质。这个特质包含一个`Validator`实例，并使用你在表单请求类中定义的规则来验证请求中的数据。如果验证器通过，那么应用到的控制器动作将正常执行。如果验证器失败，则用户将被重定向到之前的URL，并在会话中显示错误。这意味着你不需要在控制器动作中定义验证流程，甚至可以在不同场景下提交相同数据但不同动作的控制器动作中重用它们。
- en: 'Let''s create a form request for saving a cat''s details. Again, Artisan comes
    with a generator to create a new form request class for us:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于保存猫的详细信息的表单请求。同样，Artisan为我们提供了一个生成器来创建一个新的表单请求类：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will create the file at `app/Http/Requests/SaveCatRequest.php`. Inside
    the file, you will find two methods: `authorize` and `rules`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`app/Http/Requests/SaveCatRequest.php`文件中创建文件。在文件中，你会找到两个方法：`authorize`和`rules`。
- en: Before validation is performed, the form request authorizes the current request.
    The implementation detail is up to you. You might want the current user to be
    logged in, or to be an administrator. You can define that logic in this method.
    By default, it simply returns `false`. This isn't ideal as it means *no one* would
    be able to perform this request. Since we're handling user authentication via
    middleware, we can simply switch this to return `true` instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行验证之前，表单请求授权当前请求。实现细节取决于你。你可能希望当前用户登录或成为管理员。你可以在该方法中定义这个逻辑。默认情况下，它简单地返回`false`。这并不理想，因为它意味着*没有人*能够执行此请求。由于我们通过中间件处理用户身份验证，我们可以简单地将其更改为返回`true`。
- en: 'The second method, `rules`, is where we supply the array of validation rules
    to be fed to the `Validator` instance. Taking the preceding `Validator` example,
    this can be changed to the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法，`rules`，是我们提供要馈送给`Validator`实例的验证规则数组的地方。以先前的`Validator`示例为例，这可以更改为以下代码：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The reason rules are defined in a method and not simply as a class property
    is to allow for conditional validation. There may be times when you only want
    to validate a certain field, for example, if a value is provided in another field.
    Imagine a checkout form in an e-commerce website that asks a user for a billing
    address and an optional shipping address if it''s different from the billing address.
    Most online stores will have a checkbox that when checked, will display the fields
    to enter the shipping address. If we were to create the validation for this scenario,
    then it may look something like the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 规则被定义在方法中而不是简单地作为类属性，是为了允许条件验证。可能有些时候你只想验证某个字段，例如，如果另一个字段提供了值。想象一下电子商务网站上的结账表单，它会要求用户提供一个账单地址，如果与账单地址不同，则可选的送货地址。大多数在线商店都会有一个复选框，当勾选时，将显示输入送货地址的字段。如果我们为这种场景创建验证，那么它可能看起来像以下代码：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding example checks whether a field with `shipping_address_different`
    (the checkbox) is present and, if so, appends a validation rule to specify that
    `shipping_address` is required. As you can see, this makes validation in form
    requests very powerful.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例检查是否存在带有`shipping_address_different`（复选框）字段的字段，如果存在，则附加一个验证规则来指定`shipping_address`是必需的。正如你所见，这使得表单请求中的验证非常强大。
- en: 'Form request classes are instantiated by specifying them as a parameter to
    the controller action you want them to apply. In our case of saving cats, this
    will apply to both the `create` and `update` methods in our `CatsController` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定控制器动作的参数来实例化表单请求类。在我们的保存猫的例子中，这将对我们的`CatsController`类中的`create`和`update`方法都适用：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, whenever either of these actions is requested, the `SaveCatRequest` class
    will first be called and checked to see whether the data is valid. This means
    our controller methods can stay lean, and only deal with the actual persisting
    of the new data to the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当请求这些动作中的任何一个时，`SaveCatRequest`类将被首先调用并检查数据是否有效。这意味着我们的控制器方法可以保持简洁，并且只处理将新数据持久化到数据库的实际操作。
- en: Securing your application
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的应用程序（Securing your application）
- en: Before you deploy your application in a hostile environment, full of merciless
    bots and malicious users, there are a number of security considerations that you
    must keep in mind. In this section, we are going to cover several common attack
    vectors for web applications and learn about how Laravel protects your application
    against them. Since a framework cannot protect you against everything, we will
    also look at the common pitfalls to avoid.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将应用程序部署到充满无情机器人和恶意用户的敌对环境之前，你必须牢记一些安全考虑因素。在本节中，我们将介绍几个常见的针对Web应用程序的攻击向量，并了解Laravel是如何保护你的应用程序免受这些攻击的。由于框架不能保护你免受所有攻击，我们还将探讨要避免的常见陷阱。
- en: Cross-site request forgery
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站请求伪造（Cross-site request forgery）
- en: '**Cross-site request forgery** (**CSRF**) attacks are conducted by targeting
    a URL that has side effects (that is, it is performing an action and not just
    displaying information). We have already partly mitigated CSRF attacks by avoiding
    the use of `GET` for routes that have permanent effects such as `DELETE/cats/1`,
    since it is not reachable from a simple link or embeddable in an `<iframe>` element.
    However, if an attacker is able to send his victim to a page that he controls,
    he can easily make the victim submit a form to the target domain. If the victim
    is already logged in on the target domain, the application would have no way of
    verifying the authenticity of the request.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）攻击是通过针对具有副作用（即执行操作而不是仅显示信息）的URL来进行的。我们已经通过避免对具有永久效果的路线（如`DELETE/cats/1`）使用`GET`来部分缓解了CSRF攻击，因为这些操作无法通过简单链接访问或嵌入到`<iframe>`元素中。然而，如果攻击者能够将他的受害者引导到一个他控制的页面，他可以轻易地让受害者向目标域提交表单。如果受害者已经在目标域登录，应用程序将无法验证请求的真实性。'
- en: The most efficient countermeasure is to issue a token whenever a form is displayed
    and then check that token when the form is submitted. `Form::open` and `Form::model`
    both automatically insert a hidden `_token` input element, and middleware is applied
    to check the supplied token on incoming requests to see whether it matches the
    expected value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的对策是在表单显示时发出一个令牌，然后在表单提交时检查该令牌。`Form::open`和`Form::model`都会自动插入一个隐藏的`_token`输入元素，并且中间件会应用于检查传入请求中提供的令牌是否与预期值匹配。
- en: Escaping content to prevent cross-site scripting (XSS)
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义内容以防止跨站脚本（XSS）
- en: '**Cross-site scripting** (**XSS**) attacks happen when attackers are able to
    place client-side JavaScript code in a page viewed by other users. In our application,
    assuming that the name of our cat is not escaped, if we enter the following snippet
    of code as the value for the name, every visitor will be greeted with an alert
    message everywhere the name of our cat is displayed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本**（**XSS**）攻击发生在攻击者能够在其他用户查看的页面上放置客户端JavaScript代码时。在我们的应用程序中，假设我们的猫的名字没有被转义，如果我们将以下代码片段作为名字的值输入，那么每个访问者都会在我们的猫名字显示的每个地方看到一个警告消息：'
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: While this is a rather harmless script, it would be very easy to insert a longer
    script or link to an external script that steals the session or cookie values.
    To avoid this kind of attack, you should never trust any user-submitted data or
    escape any dangerous characters. You should favor the double-brace syntax (`{{
    $value }}`) in your Blade templates, and only use the `{!! $value !!}` syntax,
    where you're certain the data is safe to display in its raw format.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相当无害的脚本，但很容易插入更长的脚本或链接到外部脚本，该脚本会窃取会话或cookie值。为了避免这种攻击，你不应该信任任何用户提交的数据或转义任何危险字符。你应该在Blade模板中优先使用双大括号语法（`{{
    $value }}`），并且只有在确定数据可以以原始格式安全显示时才使用`{!! $value !!}`语法。
- en: Avoiding SQL injection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免SQL注入
- en: An **SQL injection** vulnerability exists when an application inserts arbitrary
    and unfiltered user input in an SQL query. This user input can come from cookies,
    server variables, or, most frequently, through `GET` or `POST` input values. These
    attacks are conducted to access or modify data that is not normally available
    and sometimes to disturb the normal functioning of the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序在SQL查询中插入任意且未经筛选的用户输入时，就存在**SQL注入**漏洞。这种用户输入可能来自cookie、服务器变量，或者最常见的是通过`GET`或`POST`输入值。这些攻击的目的是访问或修改通常不可用的数据，有时还会干扰应用程序的正常运行。
- en: By default, Laravel will protect you against this type of attack since both
    the query builder and Eloquent use **PHP Data Objects** (**PDO**) class behind
    the scenes. PDO uses **prepared statements**, which allows you to safely pass
    any parameters without having to escape and sanitize them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Laravel会保护你免受此类攻击，因为查询构建器和Eloquent在幕后都使用**PHP数据对象**（**PDO**）类。PDO使用**预处理语句**，这允许你安全地传递任何参数，而无需对它们进行转义和清理。
- en: 'In some cases, you might want to write more complex or database-specific queries
    in SQL. This is possible using the `DB::raw` method. When using this method, you
    must be very careful not to create any vulnerable queries like the following one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想用SQL编写更复杂或数据库特定的查询。这可以通过使用`DB::raw`方法实现。当使用此方法时，你必须非常小心，不要创建任何像以下这样的易受攻击的查询：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To protect this query from SQL injection, you need to rewrite it by replacing
    the parameters with question marks in the query and then pass the values in an
    array as a second argument to the `raw` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护此查询免受SQL注入攻击，你需要通过在查询中用问号替换参数来重写它，然后将值作为一个数组作为`raw`方法的第二个参数传递：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding query is known as a **prepared statement**, as we define the query
    and what parameters are expected, and any harmful parameters that would alter
    the query or data in the database in an unintended way are sanitized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询被称为**预处理语句**，因为我们定义了查询和预期的参数，并且任何有害的参数都会被清理，以防止它们以未预期的方式更改查询或数据库中的数据。
- en: Using mass assignment with care
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨慎使用质量分配
- en: In [Chapter 3](ch03.html "Chapter 3. Your First Application"), *Your First Application*,
    we used mass assignment, a convenient feature that allows us to create a model
    based on the form input without having to assign each value individually.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。你的第一个应用")，*你的第一个应用*中，我们使用了质量分配，这是一个方便的特性，允许我们根据表单输入创建一个模型，而无需逐个分配每个值。
- en: 'This feature should, however, be used carefully. A malicious user could alter
    the form on the client side and add a new input to it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个特性应该谨慎使用。恶意用户可能会在客户端篡改表单并添加新的输入：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, when the form is submitted, we attempt to create a new model using the
    following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当表单提交时，我们尝试使用以下代码创建一个新的模型：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Thanks to the `$fillable` array, which defines a white list of fields that can
    be filled through mass assignment, this method call will throw a mass assignment
    exception.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`$fillable`数组定义了可以通过质量分配填充的字段白名单，因此此方法调用将抛出质量分配异常。
- en: It is also possible to do the opposite and define a blacklist with the `$guarded`
    property. However, this option can be potentially dangerous since you might forget
    to update it when adding new fields to the model.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以做相反的事情，使用`$guarded`属性定义一个黑名单。然而，这个选项可能具有潜在的危险性，因为你可能会忘记在向模型添加新字段时更新它。
- en: Cookies – secure by default
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookie – 默认安全
- en: Laravel makes it very easy to create, read, and expire cookies with its `Cookie`
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel通过其`Cookie`类使创建、读取和过期cookie变得非常容易。
- en: You will also be pleased to know that all cookies are automatically signed and
    encrypted. This means that if they are tampered with, Laravel will automatically
    discard them. This also means that you will not be able to read them from the
    client side using JavaScript.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会很高兴地知道，所有cookie都会自动签名和加密。这意味着如果它们被篡改，Laravel会自动丢弃它们。这也意味着你将无法使用JavaScript从客户端读取它们。
- en: Forcing HTTPS when exchanging sensitive data
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在交换敏感数据时强制使用HTTPS
- en: 'If you are serving your application over HTTP, you need to bear in mind that
    every bit of information that is exchanged, including passwords, is sent in *cleartext*.
    An attacker on the same network could therefore intercept private information,
    such as session variables, and log in as the victim. The only way we can prevent
    this is to use HTTPS. If you already have an SSL certificate installed on your
    web server, Laravel comes with a number of helpers to switch between `http://`
    and `https://` and restrict access to certain routes. You can, for instance, define
    an `https` filter that will redirect the visitor to the secure route as shown
    in the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过HTTP提供服务，您需要记住，交换的每一比特信息，包括密码，都是以明文形式发送的。因此，同一网络上的攻击者可以拦截私人信息，例如会话变量，并以受害者身份登录。我们唯一能防止这种情况的方法是使用HTTPS。如果您已经在您的Web服务器上安装了SSL证书，Laravel提供了一些助手来在`http://`和`https://`之间切换并限制对某些路由的访问。例如，您可以定义一个`https`过滤器，将访客重定向到安全的路由，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to make use of many of Laravel's tools to add
    authentication features to a website, validate data, and avoid common security
    problems. You should now have all the necessary information to create a Laravel
    application, test them, and secure them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用Laravel的许多工具为网站添加认证功能、验证数据和避免常见的安全问题。现在您应该拥有创建、测试和确保Laravel应用程序所需的所有必要信息。
- en: In the [Appendix](apa.html "Appendix A. An Arsenal of Tools"), *An Arsenal of
    Tools*, you will be presented with a handy reference for many of the other helpful
    features that Laravel offers out of the box.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录](apa.html "附录 A. An Arsenal of Tools")中，*An Arsenal of Tools*，您将获得Laravel提供的许多其他有用功能的便捷参考。
