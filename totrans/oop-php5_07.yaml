- en: Chapter 7. Database in an OOP Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides regular improvements in the OOP, PHP5 also introduces many new libraries
    to seamlessly work with database in an OOP way. These libraries provide you with
    improved performance, sometimes improved security features, and of course a whole
    lot of methods to interact with new features provided by the database server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will discuss MySQL improved API, which is known as MySQLi.
    Take a look at basic PDO (well, not detailed because PDO is so huge that it is
    possible to write a whole book just on it), ADOdb, and PEAR::MDB2\. In the mean
    time we will also take a look at Active Record pattern in PHP using ADOdb's active.
    One thing to note here is that we are not focusing on how to do general database
    manipulations. We will only focus on some specific topics which are interesting
    for PHP developers who are doing database programming in an OO way.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MySQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQLi is an improved extension introduced in PHP5 to work with advanced MySQL
    features like prepared statements and stored procedures. From a performance point
    of view, MySQLi is much better than a MySQL extension. Also this extension offers
    completely object oriented interfaces to work with a MySQL database which was
    not available before PHP5\. But keep in mind that if your MySQL version is at
    least 4.1.3 or above, you will get it working.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what are the major improvements? Let''s have a look first:'
  prefs: []
  type: TYPE_NORMAL
- en: Improved performance over MySQL extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible OO and Non OO interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantage over new MySQL objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to create compressed connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to connect over SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for Prepared Statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for Stored Procedure (SP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for better replication and transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look into some of these features in the following examples. But of course
    we are not going for anything introductory to MySQL, because that is out of scope
    for this book. We will just show you how to use OO interface using MySQLi and
    how to use some of these advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MySQL in an OO Way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember those old days when you had to use procedural function `call` to connect
    to MySQL, even from your objects. Those days are over. Now you can take advantage
    of complete OO interface of MySQLi to talk to MySQL (well, there are a few procedural
    methods, but overall it''s completely OO). Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the connection fails, you may get an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Selecting Data in an OO Way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how to select data from a table in an OO way using MySQLi API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that it is not good practice to store users' passwords in plain
    text in your database without encrypting them in some way. The best way is to
    store just the hash of their passwords using some hash routines like `md5()`
  prefs: []
  type: TYPE_NORMAL
- en: Updating Data in an OO Way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no special deal with it. You can update your data as you previously
    did with MySQL extension. But for the sake of OO style, we are showing an example
    of how you can do that with `mysqli_query()` function as shown in the above example.
    Instantiate an instance of MySQLi object and then run the query.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we are in a really interesting section which has been introduced for the
    first time in PHP OO using MySQLi extension. The prepared statements are introduced
    in MySQL 5.0 versions (dynamic SQL) for better security and flexibility. It has
    a great performance boost over the regular one.
  prefs: []
  type: TYPE_NORMAL
- en: So what is actually a prepared statement? A prepared statement is nothing but
    a regular query that is pre-compiled by the MySQL sever that could be invoked
    later. Prepared statements reduce the chances of SQL injection and offers greater
    performance over the general non-prepared queries, as it need not perform different
    compilation steps at the run time.(It is already compiled, remember?)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are advantages of using prepared statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Better Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevention of SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving memory while handling blobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But there are drawbacks too!
  prefs: []
  type: TYPE_NORMAL
- en: There is no performance boost if you use prepared statements for a single call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no query cache for using prepared statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chance of memory leak if statements are not closed explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all statements can be used as a prepared statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepared statements can accept parameters at run time in the same order you
    specify them whilst preparing the query. In this section we will learn about creating
    prepared statements, passing values to them, and fetching results.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Prepared Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s prepare a statement using PHP''s native MySQLi extension. In the following
    example we will make a prepared statement, execute it, and fetch the result from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So what did we actually do in the above example?
  prefs: []
  type: TYPE_NORMAL
- en: 'We prepared the statement using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we executed it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we bound two variables with it, as there are two variables in our query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally we fetched the result using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we called `fetch()`, the bound variables are populated with values.
    So we can now use them.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared Statements with Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The advantage of prepared statements is that you can use variables with queries.
    First you can prepare the query by placing a `?` sign at the appropriate place,
    and then you can pass the value after preparing it. Let''s have a look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we prepare the query `"select name, pass from users where name=?`" where
    the name is definitely a string type value. As we bind parameters in the previous
    example for the result using `bind_results()`, here we have to bind parameters
    using `bind_params()` function. Besides that, we need to supply the data type
    of the parameters bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL prepared statements support four types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`, means the corresponding variable has type integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`, means the corresponding variable has type double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`, means the corresponding variable has type string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`, means the corresponding variable is a blob and will be sent in packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As our parameter is a string, we used the following line to bind the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After binding the variable, now we set the value to `$name` and call the `execute()`
    function. After that we fetch the values as before.
  prefs: []
  type: TYPE_NORMAL
- en: Using BLOB with Prepared Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prepared statements support handling **BLOB** or **Binary Large Objects** efficiently.
    If you manage BLOB with prepared statements, it will save you from greater memory
    consumption by sending the data as packets. Let's see how we can store BLOB (in
    this case, an image file).
  prefs: []
  type: TYPE_NORMAL
- en: Prepared statements support sending data in chunks using the `send_long_data()`
    function. In the following example we will store the image using this function,
    though you can send them as usual, unless your data exceeds the limit defined
    by the `max_allowed_packet` MySQL configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our table schema is as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We choose medium BLOB as our data type because blob can store only 65KB of data,
    where as medium BLOB can store more than 16MB, and long blob can store more than
    4GB data in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will restore this BLOB data using the image again in prepared statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Executing Stored Procedure with MySQLi and PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stored procedure is another new addition to MySQL 5 which reduces the need
    for client‑side queries to a great extent. Using MySQLi extension, you can execute
    stored procedures in MySQL. We are not going to discuss stored procedures as that
    is out of scope for this book. There are several articles available in the Internet
    that will help you in writing stored procedures in MySQL. You can read this awesome
    one for getting a basic idea about advanced MySQL features: [http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf](http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small stored procedure and run it using PHP. This stored procedure
    can take an input and insert that record in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you run this stored procedure in your database (using MySQL query builder
    or anything) the `sp_create_user` procedure will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manually execute any stored, procedure from MySQL client using "Execute"
    command. For example to execute the above stored procedure you have to use `call
    sp_create_user('` *`username`*`')`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will run this stored procedure using PHP code. Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: PDO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new extension added in PHP 5.1 for managing databases is PDO (although
    PDO was available with PHP 5.0 as a PECL Extension). This comes with a set of
    drivers for working with different database engines. **PDO** stands for **PHP
    Data Objects**. It is developed to provide a lightweight interface for different
    database engines. And one of the very good features of PDO is that it works like
    a Data Access Layer so that you can use the same function names for all database
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: You can connect to different databases using DSN (Data Source Name) strings.
    In the following example we will connect to a MySQL databases and retrieve some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's fairly hassle free, right? It just connects to MySQL server with the
    DSN (here it connects to `test` database) and then executes the query. And Finally
    we display the result.
  prefs: []
  type: TYPE_NORMAL
- en: So what would this be like if we connected to a SQLite database?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See there is no change in the code except the DSN.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a SQLite database in memory and perform the operation there.
    Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We just changed the DSN here.
  prefs: []
  type: TYPE_NORMAL
- en: DSN Settings for Different Databases Engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us take a look at the DSN settings for different database engines to connect
    with PDO. Supported database drivers are as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: PDO_DBLIB for FreeTDS/Microsoft SQL Server/Sybase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_FIREBIRD for Firebird/Interbase 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_INFORMIX for IBM Informix Dynamic Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_MYSQL for MySQL 3.x/4.x/5.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_OCI for Oracle Call Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_ODBC for ODBC v3 (IBM DB2, unixODBC and win32 ODBC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_PGSQL for PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO_SQLITE for SQLite 3 and SQLite 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at these sample driver-specific DSN settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using Prepared Statements with PDO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using PDO you can run prepared statements against your database. The benefits
    are the same as before. It increases the performance for multiple calls by parsing
    and caching the server-side query and it also eliminates the chance of SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: PDO prepared statements can take named variables, unlike what we've seen in
    the examples of MySQLi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can also run the example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of calling `bindParam()`, you can use `bindValues()` like the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Calling Stored Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PDO provides an easy way to call stored procedures. All you have to do is run
    "CALL SPNAME(PARAMS)" via `exec()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Other Interesting Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several other interesting functions available in PDO. For example,
    take a look at the list below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchAll()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchColumn()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rowCount()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFetchMode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fetchAll()` function can fetch all records from a result set. Let''s have
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchColumn()` function helps to select data from any specific column
    after executing the statement. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`rowCount()` returns the number of affected rows after performing any `UPDATE`
    or `DELETE` query. But you must remember that it returns the number of affected
    rows by the latest executed query.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`setFetchMode()` helps you to set the fetch mode of PDO prepared statements.
    The available values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::FETCH_NUM`: Fetch results as a numerically indexed array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_ASSOC`: Fetch rows as index by column names as keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_BOTH`: Fetch as both of the above'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_OBJ`: Fetch the rows as objects where column names are set as properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Data Abstraction Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data Abstraction Layers** (**DALs**) are developed to provide unified interfaces
    to work with every database engine. It provides similar API to work with every
    database engine independently. As the function names are similar for all platforms,
    they are easier to work with, easier to remember, and of course make your code
    portable. To make you understand the necessity of DAL, let me explain a common
    scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose Team Y gets a big project. Their client says that they will use MySQL.
    So team Y develops the application and when the time comes to deliver, the client
    requests the team to give support for PostgreSQL. They will pay for this change
    but they require the change early.
  prefs: []
  type: TYPE_NORMAL
- en: Team Y had designed the application using all native MySQL functions. So what
    will Team Y do? Will they rewrite everything to give support for PostgreSQL? Well,
    that is the only way they have to. But what will happen if they need to give support
    for MSSQL in the near future? Another rewrite? Can you imagine the cost of refactoring
    each and every time?
  prefs: []
  type: TYPE_NORMAL
- en: To save from these disasters, here comes the need for DAL where the code will
    remain the same and it could be changed to support any DB at any time without
    any major change.
  prefs: []
  type: TYPE_NORMAL
- en: There are many popular libraries to implement DAL for PHP. To name some of those,
    ADOdb and PEAR::MDB2 are very popular. PEAR::DB was very popular but its development
    has been discontinued ([http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended](http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended)).
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will discuss PEAR::MDB2 and ADOdb. We will see the basic
    database operations using it and learn how to install these libraries for working
    around.
  prefs: []
  type: TYPE_NORMAL
- en: ADOdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADOdb is a nice and popular data abstraction layer developed by John Lim and
    released under LGPL. This is one of the very best data abstraction layers for
    PHP. You can get the latest version of ADOdb from [http://adodb.sourceforge.net](http://adodb.sourceforge.net).
  prefs: []
  type: TYPE_NORMAL
- en: Installing ADOdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no install of ADodb as such. It is a set of classes and regular scripts.
    So all you have to do is just extract the archive in a location from where you
    can include the script. Let''s take a look at the following image to understand
    the directory structure after extracting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing ADOdb](img/2561_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting to Different Databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like PDO, you can connect to different database drivers using ADOdb. DSN is
    different from PDO. Let's take a look at the supported database list and their
    DSN strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'ADOdb supports a common DSN format, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So what are the available drivers supported by ADOdb? Let''s take a look below.
    This is a list taken from the ADOdb manual for your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Tested | Database | Prerequisites | Operating Systems |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| access | B | Microsoft Access/Jet. You need to create an ODBC DSN. | ODBC
    | Windows only |'
  prefs: []
  type: TYPE_TB
- en: '| ado | B | Generic ADO, not tuned for specific databases. Allows DSN-less
    connections. For best performance, use an OLEDB provider. This is the base class
    for all ado drivers.You can set `$db->codePage` before connecting. | ADO or OLEDB
    provider | Windows only |'
  prefs: []
  type: TYPE_TB
- en: '| ado_access | B | Microsoft Access/Jet using ADO. Allows DSN‑less connections.
    For best performance, use an OLEDB provider. | ADO or OLEDB provider | Windows
    only |'
  prefs: []
  type: TYPE_TB
- en: '| ado_mssql | B | Microsoft SQL Server using ADO. Allows DSN-less connections.
    For best performance, use an OLEDB provider. | ADO or OLEDB provider | Windows
    only |'
  prefs: []
  type: TYPE_TB
- en: '| db2 | C | Uses PHP''s db2-specific extension for better performance. | DB2
    CLI/ODBC interface | Unix and Windows. Requires IBM DB2 Universal Database client
    |'
  prefs: []
  type: TYPE_TB
- en: '| odbc_db2 | C | Connects to DB2 using generic ODBC extension. | DB2 CLI/ODBC
    interface | Unix and Windows. Unix install hints. I have had reports that the
    `$host` and `$database` params have to be reversed in `Connect()` when using the
    CLI interface |'
  prefs: []
  type: TYPE_TB
- en: '| vfp | A | Microsoft Visual FoxPro. You need to create an ODBC DSN. | ODBC
    | Windows only |'
  prefs: []
  type: TYPE_TB
- en: '| fbsql | C | FrontBase. | ? | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| ibase | B | Interbase 6 or earlier. Some users report you might need to use
    this`$db->PConnect(''localhost:c:/ibase/employee.gdb'', "sysdba", "masterkey")`
    to connect. Lacks `Affected_Rows` currently.You can set `$db->role`, `$db->dialect`,
    `$db->buffers` and `$db->charSet` before connecting. | Interbase client | Unix
    and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| firebird | B | Firebird version of interbase. | Interbase client | Unix and
    Windows |'
  prefs: []
  type: TYPE_TB
- en: '| borland_ibase | C | Borland version of Interbase 6.5 or later. Very sad that
    the forks differ. | Interbase client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| informix | C | Generic informix driver. Use this if you are using Informix
    7.3 or later. | Informix client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| informix72 | C | Informix databases before Informix 7.3 that do no support
    `SELECT FIRST`. | Informix client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| ldap | C | LDAP driver. See this example for usage information. | LDAP extension
    | ? |'
  prefs: []
  type: TYPE_TB
- en: '| mssql | A | Microsoft SQL Server 7 and later. Works with Microsoft SQL Server
    2000 also. Note that date formating is problematic with this driver. For example,
    the PHP MSSQL extension does not return the seconds for datetime! | Mssql client
    | Unix and Windows. Unix install howto and another one. |'
  prefs: []
  type: TYPE_TB
- en: '| mssqlpo | A | Portable mssql driver. Identical to above mssql driver, except
    that ''&#124;&#124;'', the concatenation operator, is converted to ''+''. Useful
    for porting scripts from most other sql variants that use &#124;&#124;. | Mssql
    client | Unix and Windows. Unix install howto. |'
  prefs: []
  type: TYPE_TB
- en: '| mysql | A | MySQL without transaction support. You can also set `$db->clientFlags`
    before connecting. | MySQL client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| mysqli | B | Supports the newer PHP5 MySQL API. | MySQL 4.1+ client | Unix
    and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| mysqlt or maxsql | A | MySQL with transaction support. We recommend using
    &#124;&#124; as the concat operator for best portability. This can be done by
    running MySQL using: `mysqld --ansi or mysqld --sql-mode=PIPES_AS_CONCAT` | MySQL
    client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| oci8 | A | Oracle 8/9\. Has more functionality than oracle driver (eg. `Affected_Rows`).
    You might have to `putenv(''ORACLE_HOME=...'')` before Connect/PConnect.There
    are 2 ways of connecting: with server IP and service name: `PConnect(''serverip:1521'',''scott'',''tiger'',''service'')`or
    using an entry in TNSNAMES.ORA or ONAMES or HOSTNAMES: `PConnect(false, ''scott'',
    ''tiger'', $oraname)`.Since 2.31, we support Oracle REF cursor variables directly
    (see `ExecuteCursor`). | Oracle client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| oci805 | C | Supports reduced Oracle functionality for Oracle 8.0.5\. `SelectLimit`
    is not as efficient as in the oci8 or oci8po drivers. | Oracle client | Unix and
    Windows |'
  prefs: []
  type: TYPE_TB
- en: '| oci8po | A | Oracle 8/9 portable driver. This is nearly identical with the
    oci8 driver except (a) bind variables in `Prepare()` use the `?` convention, instead
    of `:bindvar`, (b) field names use the more common PHP convention of lowercase
    names.Use this driver if porting from other databases is important. Otherwise
    the oci8 driver offers better performance. | Oracle client | Unix and Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| odbc | A | Generic ODBC, not tuned for specific databases. To connect, use
    `PConnect(''DSN'',''user'',''pwd'')`. This is the base class for all ODBC derived
    drivers. | ODBC | Unix and Windows. Unix hints |'
  prefs: []
  type: TYPE_TB
- en: '| odbc_mssql | A | Uses ODBC to connect to MSSQL | ODBC | Unix and Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| odbc_oracle | C | Uses ODBC to connect to Oracle | ODBC | Unix and Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| odbtp | B | Generic odbtp driver. Odbtp is a software for accessing Windows
    ODBC data sources from other operating systems. | odbtp | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| odbtp_unicode | C | Odtbp with unicode support | odbtp | Unix and Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| oracle | C | Implements old Oracle 7 client API. Use oci8 driver if possible
    for better performance. | Oracle client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| netezza | C | Netezza driver. Netezza is based on PostGREs code-base. | ?
    | ? |'
  prefs: []
  type: TYPE_TB
- en: '| pdo | C | Generic PDO driver for PHP5\. | PDO extension and database specific
    drivers | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| postgres | A | Generic PostgreSQL driver. Currently identical to postgres7
    driver. | PostgreSQL client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| postgres64 | A | For PostgreSQL 6.4 and earlier which does not support LIMIT
    internally. | PostgreSQL client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| postgres7 | A | PostgreSQL which supports LIMIT and other version 7 functionality.
    | PostgreSQL client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| postgres8 | A | Currently identical to postgres7. | PostgreSQL client | Unix
    and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| sapdb | C | SAP DB. Should work reliably as based on ODBC driver. | SAP ODBC
    client | ? |'
  prefs: []
  type: TYPE_TB
- en: '| sqlanywhere | C | Sybase SQL Anywhere. Should work reliably as based on ODBC
    driver. | SQL Anywhere ODBC client | ? |'
  prefs: []
  type: TYPE_TB
- en: '| sqlite | B | SQLite. | - | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: '| sqlitepo | B | Portable SQLite driver. This is because assoc mode does not
    work like other drivers in SQLite. Namely, when selecting (joining) multiple tables,
    the table names are included in the assoc keys in the "sqlite" driver.In "sqlitepo"
    driver, the table names are stripped from the returned column names. When this
    results in a conflict, the first field get preference. | - | Unix and Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| sybase | C | Sybase. | Sybase client | Unix and Windows |'
  prefs: []
  type: TYPE_TB
- en: Basic Database Operations using ADOdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember the directory structure that saw minutes ago? Now we are going to
    make use of those scripts. In this section we will learn basic database operation
    using ADOdb. Let''s connect to MySQL and perform a basic operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an alternate connection example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Inserting, Deleting, and Updating Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can execute any SQL statement using `execute()` method of `ADONewConnection`
    or `ADOConnection` object. So nothing is new here. But let's see how can we insert/delete/update
    some records and track the success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, `Affected_Rows` gives you the result for these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Insert Id**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking to find the latest inserted ID, you can use the `Insert_Id()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Prepared Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ADOdb provides easy API to create and execute prepared statements. Let''s take
    a look at the following example to understand how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can retrieve records in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: MDB2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MDB2 is another popular data abstraction library developed under PEAR by combining
    the best features of PEAR::DB and Metabase. It provides very consistent API, improved
    performance, and solid development platform over DB and MDB. MDB2 comes with an
    excellent set of documentation. In this chapter we surely cannot cover all the
    features supported by MDB2 but we will go through the basic features to make you
    understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MDB2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing MDB2 requires a working version of PEAR. So to work with MDB2 you
    must have PEAR installed and functioning in your machine. If you don't have PEAR
    installed, the following tip will be helpful for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Installing PEAR**'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://pear.php.net/go-pear](http://pear.php.net/go-pear) and save the
    page as `go-pear.php` in your hard drive. Now apply the command `php /path/to/go-pear.php`
    in your shell or command prompt and follow the instructions there. If it asks
    whether you want to install MDB2, say 'Yes'. Also say Yes, if it wants to modify
    your `php.ini` file. Don't worry, it will just add entries to make PEAR available
    in your current include path, and all other settings will remain the same as before.
    So you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have PEAR I installed but not MDB2, then you can install it in a second.
    Open your shell or command prompt and apply the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `$driver` could be anything like SQLite, PgSQL, MySQL, MYSQLi, oci8,
    MSSQL, and ibase. So for example, to install MySQL driver you have to apply the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's it. You are done.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using MDB2 you can connect to different database engines. MDB2 also has a formatted
    DSN string to connect. The format of that DSN is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are some variations in this DSN. These are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported drivers (PHPtype) are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s connect to MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Executing Prepared Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can execute prepared statements using MDB2 easily. MDB2 provides flexible
    API for creating and executing prepared statements. In the following example we
    will execute two types of prepared statements. One which will just execute some
    insert/update/delete queries, and another which will return some data as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what if we want to insert in multiple fields? Well for example, if we have
    another field like "age" in our table, we need to pass data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can also insert multiple rows at once using `executeMultiple()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That's it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ActiveRecord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ActiveRecord is a design pattern created to solve the data accessing problem
    in a fairly readable manner. Using ActiveRecord design pattern you can manipulate
    data like a charm. In this section we will go through the basic features of an
    ActiveRecord implementation in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how ActiveRecord actually works. For this, we will use ADOdb's active
    record implementation. Adodb provides a class named `Adodb_Active_Record` devoted
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a table in our database with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Creating a New Record via ActiveRecord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will create a new user in this table. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ActiveRecord exposes a separate object for every table in your database by which
    you can perform different operations. Let's take a look at how we can select some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and Updating Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load and change any record using ActiveRecord easily. Let''s have a
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So that's fairly easy. When you call the `load()` method with any expression,
    the record will be loaded into the object itself. Then you can make any change
    and finally save it. ActiveRecord is extremely charming to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You finished reading a chapter devoted for total DB access using the OOP way.
    There are lot other interesting projects like Propel ([http://propel.phpdb.org/trac/](http://propel.phpdb.org/trac/))
    as Object Relational Mapping library for PHP developers, Creole ([http://creole.phpdb.org/trac/](http://creole.phpdb.org/trac/))
    as a DAL, ActiveRecord library from CodeIgniter framework ([http://www.codeigniter.com](http://www.codeigniter.com)),
    and many more. You have got a large number of resources available to manipulate
    database using PHP5 and OO style.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about using XML in PHP. You will be surprised
    to find that you can use plain XML files as a lightweight alternative of regular
    heavyweight database engines. Until then, happy coding.
  prefs: []
  type: TYPE_NORMAL
