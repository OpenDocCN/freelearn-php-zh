- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Bringing It All Together
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: So far, we have seen how to use controllers, views, and models in a somewhat
    detached manner. In the previous chapter (*Models, Databases, and Active Record*),
    we manipulated data on our database. However, we didn’t see how to interact with
    the database data from our controller, much less how to load that database data
    into our view. In this chapter, we are going to see how everything comes together
    – that is, we’ll load a model from the controller and pass the model data to our
    view so that the end user will see data on the browser. We will also do the reverse,
    which is getting data from the user into our database, starting from the view
    and ending on the model. Furthermore, we will also learn the Rails way to perform
    these actions, as they are quite different from the way we would do these tasks
    in PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何以某种分离的方式使用控制器、视图和模型。在上一章（*模型、数据库和 Active Record*）中，我们操作了数据库中的数据。然而，我们没有看到如何从控制器与数据库数据交互，更不用说如何将数据库数据加载到我们的视图中。在本章中，我们将看到一切是如何结合在一起的——也就是说，我们将从控制器加载一个模型并将模型数据传递给我们的视图，以便最终用户可以在浏览器上看到数据。我们还将做相反的操作，即将用户数据从视图传到我们的数据库，从视图开始到模型结束。此外，我们还将学习
    Rails 方式执行这些操作，因为它们与我们用 PHP 做这些任务的方式大不相同。
- en: 'With models, views, and controllers in mind, in this chapter, we will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到模型、视图和控制器，在本章中，我们将涵盖以下主题：
- en: Setting up our initial application with generators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器设置我们的初始应用程序
- en: Processing data the Rails way
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 Rails 方式处理数据
- en: Do not, I repeat, do not reinvent the wheel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要，我再重复一遍，不要重新发明轮子
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along this chapter, we will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章，我们需要以下内容：
- en: Any IDE to view/edit code (e.g., SublimeText, Visual Studio Code, Notepad++
    Vim, Emacs, etc.)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何用于查看/编辑代码的 IDE（例如，SublimeText、Visual Studio Code、Notepad++ Vim、Emacs 等）
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您还需要安装 Xcode 命令行工具
- en: Ruby version 3.1.1 or later installed and ready to use
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并准备好使用的 Ruby 版本 3.1.1 或更高版本
- en: A Git client installed on your local machine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地机器上安装的 Git 客户端
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在 [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)
    找到。
- en: Project preparation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目准备
- en: Prior to setting up our application, we are going to do some additional configuration,
    depending on the operating system. We will separate the configuration into two
    sections – Windows configuration and Linux-based systems (including macOS).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的应用程序之前，我们将根据操作系统进行一些额外的配置。我们将配置分为两个部分——Windows 配置和基于 Linux 的系统（包括 macOS）。
- en: Windows configuration
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 配置
- en: 'In [*Chapter 7*](B19230_07.xhtml#_idTextAnchor103), we configured our Windows
    environment to use **rbenv** to be able to use Ruby 2.6.10\. If you haven’t done
    so, please go back to the *Installing Ruby on Rails in Windows* section, as this
    is required for this chapter. For Rails 7 (which we will install in this chapter),
    we will require Ruby 3.1.1 installed and some dependencies that aren’t easily
    available for Windows. We will use the Git SDK’s bash shell (which we also installed
    in [*Chapter 7*](B19230_07.xhtml#_idTextAnchor103)) to solve this issue. So, let’s
    open a Windows PowerShell and type the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19230_07.xhtml#_idTextAnchor103)中，我们配置了我们的 Windows 环境使用 **rbenv**
    来使用 Ruby 2.6.10。如果您还没有这样做，请回到 *在 Windows 上安装 Ruby on Rails* 部分查看，因为这是本章所必需的。对于
    Rails 7（我们将在本章中安装），我们需要安装 Ruby 3.1.1 以及一些在 Windows 上不易获得的依赖项。我们将使用 Git SDK 的 bash
    shell（我们也在[*第7章*](B19230_07.xhtml#_idTextAnchor103)中安装了它）来解决这个问题。所以，让我们打开一个 Windows
    PowerShell 并输入以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will open a Git Bash console, which looks and behaves a lot like a Linux
    shell. Let’s confirm that we have Ruby available by typing the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个 Git Bash 控制台，它看起来和表现得很像 Linux shell。让我们通过输入以下命令来确认我们是否有 Ruby 可用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should output the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you’re not familiar with this version of Ruby, it’s because it comes with
    the Git SDK. Now, let’s install bundler for Ruby 3.1.3 with the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这个版本的 Ruby，那是因为它随 Git SDK 一起提供。现在，让我们使用以下命令安装 Ruby 3.1.3 的 bundler：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let’s update our system’s bundler with the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令更新我们的系统 bundler：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we are ready to set up our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好设置我们的应用程序。
- en: Linux-based system configuration
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 Linux 的系统配置
- en: 'For macOS and Linux-based systems (Ubuntu and Debian), we’re going to depend
    on rbenv to install Ruby 3.1.1\. If you haven’t installed rbenv, please refer
    to [*Chapter 7*](B19230_07.xhtml#_idTextAnchor103) to view the instructionson
    on how to install rbenv on Linux. With rbenv available, let’s install another
    version of Ruby with the following command on a shell:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 和基于 Linux 的系统（Ubuntu 和 Debian），我们将依赖 rbenv 来安装 Ruby 3.1.1。如果你还没有安装
    rbenv，请参阅 [*第 7 章*](B19230_07.xhtml#_idTextAnchor103) 以查看如何在 Linux 上安装 rbenv。rbenv
    可用后，让我们在 shell 中使用以下命令安装另一个版本的 Ruby：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that Ruby 3.1.1 has been installed, let’s set the default Ruby to Ruby
    3.1.1 with the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ruby 3.1.1已经安装，让我们使用以下命令将默认 Ruby 设置为 Ruby 3.1.1：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s confirm that the correct Ruby version has been activated by running the
    following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令来确认是否激活了正确的 Ruby 版本：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should output the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should install bundler for this version of Ruby with the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用以下命令为这个版本的 Ruby 安装 bundler：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we’re ready for our next Rails project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为我们的下一个 Rails 项目做好了准备。
- en: Setting up our application
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的应用程序
- en: 'For this exercise, we will have a hypothetical scenario in which we are Thomas
    A. Anderson, and we work for a respectable software company. We will play the
    part of a junior web developer in terms of our knowledge of Rails, and we will
    be assigned a simple task. The client has requested a simple address book structure
    where they can save their friends’ contact information – name, last name, email,
    and phone number. So, let’s get to work. Make sure you have Ruby version 3.1.1
    or above installed, or we might encounter issues with the project. We could download
    a template application that we already have or clone it from GitHub. In case you
    haven’t done so, open a terminal and type the following `git` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将有一个假设的场景，在这个场景中，我们是托马斯·A·安德森，我们在一家受人尊敬的软件公司工作。我们将扮演一个对 Rails 知识了解有限的初级网页开发者的角色，并且我们将被分配一个简单的任务。客户要求一个简单的地址簿结构，他们可以在其中保存朋友的联系信息——姓名、姓氏、电子邮件和电话号码。所以，让我们开始工作。确保你已经安装了
    Ruby 3.1.1 或更高版本，否则我们可能会遇到项目问题。我们可以下载一个我们已有的模板应用程序，或者从 GitHub 上克隆它。如果你还没有这样做，打开终端并输入以下
    `git` 命令：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you’ve already done so, just navigate into the `chapter09/rails7_original`
    folder inside our project with the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经这样做了，只需使用以下命令导航到我们项目中的 `chapter09/rails7_original` 文件夹：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For this small project, the client requested that we use Rails 7, as it’s the
    version they have used in other projects. It also gives us a chance to see Rails
    7 in action. Now, let’s install our project dependencies with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个小型项目，客户要求我们使用 Rails 7，因为这是他们在其他项目中使用的版本。这也给了我们一个机会来实际看看 Rails 7 的运行情况。现在，让我们使用以下命令安装我们的项目依赖项：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To confirm our setup was done correctly, let’s run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的设置正确无误，让我们运行以下命令：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should read something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And this is where our work as a Rails developer starts. We’re going to use
    some Rails magic to generate most of our code. Let’s generate a `friends` controller
    with all the methods that we are going to be calling – `index`, `new`, `edit`,
    `update`, `destroy`, and `create`. Let’s go to our shell and run the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 Rails 开发工作开始的地方。我们将使用一些 Rails 魔法来生成我们大部分的代码。让我们生成一个包含我们即将调用的所有方法的 `friends`
    控制器——`index`、`new`、`edit`、`update`、`destroy` 和 `create`。让我们进入我们的 shell 并运行以下命令：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should generate the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下输出：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Coming from the PHP world, and more specifically, Laravel, you may find the
    previous command slightly familiar. In Laravel, you’d generate an equivalent controller
    with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 PHP 世界，尤其是 Laravel，你可能会觉得之前的命令有些熟悉。在 Laravel 中，你会使用以下命令生成一个等效的控制台：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: They both generate similar functionality (the `friends` controller) and the
    `--resource` option at the end generates the correct HTTP verbs. In Rails, the
    `generator` command we just ran takes as its first argument the controller name
    (Friends) and the rest as controller methods. The command is also very verbose
    regarding what it actually generates. It not only created our controller but also
    a view for each of the methods we passed to the command. We can see this by opening
    the `app/views/friends/` folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都生成了类似的功能（`friends` 控制器）和最后的 `--resource` 选项生成了正确的HTTP动词。在Rails中，我们刚刚运行的 `generator`
    命令将其第一个参数作为控制器名称（Friends），其余作为控制器方法。该命令也非常详细地说明了它实际上生成了什么。它不仅创建了我们的控制器，还为命令传递的每个方法创建了一个视图。我们可以通过打开
    `app/views/friends/` 文件夹来查看这一点。
- en: '![Figure 9.1 – Generated views for the Friends controller](img/B19230_09_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Friends控制器生成的视图](img/B19230_09_01.jpg)'
- en: Figure 9.1 – Generated views for the Friends controller
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Friends控制器生成的视图
- en: 'Additionally, the controller generator modified our `routes.rb` file, which
    defines all the URLs for our actions inside the controller. If we open `config/routes.rb`,
    we see our newly created routes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，控制器生成器修改了我们的 `routes.rb` 文件，该文件定义了控制器内所有操作的URL。如果我们打开 `config/routes.rb`，我们会看到我们新创建的路由：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While this is fine and dandy, we can also do it the Rails way. Let’s delete
    all the routes and just leave two lines inside the `do` block, so our `routes.rb`
    file now looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样很好，但我们也可以用Rails的方式来做。让我们删除所有路由，只留下 `do` 块内的两行，所以我们的 `routes.rb` 文件现在看起来是这样的：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This looks a lot cleaner, though slightly cryptic, as we don’t know (yet) what
    this resource call does. The resource call generates RESTful routes for the following
    actions – `index`, `new`, `edit`, `create`, `update`, and `destroy`. This simply
    means that all these actions should be called using the correct HTTP verbs – `GET`,
    `POST`, `PATCH`, `PUT`, and `DELETE`. I don’t want to overwhelm you with too much
    information here, so to simplify this, we’ll just say we need some parameters
    through the URL, and some others to be “hidden” from the user. If you’re curious
    about RESTful and its uses, please take a look at the following links:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很整洁，但稍微有点晦涩，因为我们（目前）还不知道这个资源调用具体做什么。资源调用为以下操作生成RESTful路由 – `index`、`new`、`edit`、`create`、`update`
    和 `destroy`。这仅仅意味着所有这些操作都应该使用正确的HTTP动词来调用 – `GET`、`POST`、`PATCH`、`PUT` 和 `DELETE`。我不想在这里给你太多信息，所以为了简化，我们只需说我们需要通过URL传递一些参数，还有一些其他参数需要从用户那里“隐藏”。如果你对RESTful及其用途感兴趣，请查看以下链接：
- en: '[https://guides.rubyonrails.org/routing.html](https://guides.rubyonrails.org/routing.html)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://guides.rubyonrails.org/routing.html](https://guides.rubyonrails.org/routing.html)'
- en: '[https://www.redhat.com/en/topics/api/what-is-a-rest-api](https://www.redhat.com/en/topics/api/what-is-a-rest-api)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.redhat.com/en/topics/api/what-is-a-rest-api](https://www.redhat.com/en/topics/api/what-is-a-rest-api)'
- en: '[https://aws.amazon.com/what-is/restful-api/](https://aws.amazon.com/what-is/restful-api/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/what-is/restful-api/](https://aws.amazon.com/what-is/restful-api/)'
- en: '[https://www.ibm.com/topics/rest-apis](https://www.ibm.com/topics/rest-apis)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ibm.com/topics/rest-apis](https://www.ibm.com/topics/rest-apis)'
- en: 'Now, to the next step. Let’s generate a model that will represent our “friends”
    in the database. We’ll generate our model with the following command on the shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步。让我们生成一个模型，它将在数据库中代表我们的“朋友”。我们将在shell上使用以下命令生成我们的模型：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will generate the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The model generator created the migration to create a `friends` table. The
    table will have the `first_name`, `last_name`, `email`, and `phone` fields. From
    what we learned in the previous chapter, we know that we must run the migration
    to effectively generate our database structure. We’ll do that by running the following
    command on our shell:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模型生成器创建了一个迁移来创建一个 `friends` 表。该表将包含 `first_name`、`last_name`、`email` 和 `phone`
    字段。根据我们在上一章学到的知识，我们知道我们必须运行迁移来有效地生成我们的数据库结构。我们将在shell上运行以下命令来完成：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If this is not new to you, it might be because other PHP frameworks have similar
    tools. For Laravel, we would execute the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对您来说不是新内容，那可能是因为其他PHP框架有类似的工具。对于Laravel，我们会执行以下命令：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For Symfony, we would write the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Symfony，我们会写以下命令：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For CodeIgniter, we would write the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CodeIgniter，我们会写以下命令：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can infer from these examples in PHP frameworks that the migration tool has
    been in the web framework market for a while, and it’s here to stay.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从PHP框架中的这些示例中推断出，迁移工具已经在网络框架市场中存在了一段时间，并且它将保留下来。
- en: 'The last step to our setup is going to be something we didn’t cover in the
    previous chapter, and it is related to Rails models. As an additional help for
    developers to get a working environment as soon as possible, Rails integrated
    a tool called database seeds. Seeds allow us to generate test data based on our
    model structure. I confess I cheated a little bit by providing you with an already-working
    seed file. It’s in the `db/seeds.rb` file. Let’s look at one record in that file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的最后一步是之前章节中没有涉及的内容，它与Rails模型有关。为了帮助开发者尽快获得一个工作环境，Rails集成了一个名为database seeds的工具。种子允许我们根据我们的模型结构生成测试数据。我承认我有点作弊，因为我给你提供了一个已经可以工作的种子文件。它在`db/seeds.rb`文件中。让我们看看这个文件中的一个记录：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This piece of code is pretty self-explanatory. It creates a `Friend` entry
    with the first name (`rasmus`), the last name (`lerdorf`), the email address (`rasmus@email.com`),
    and a phone number (`+1(669)1111111`). Of course, this is all fake data, but it
    will be useful for us whenever we start using the database. The last step is to
    run this seed and add these records to our database. We do this with the following
    command on our shell:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直观。它创建了一个`Friend`条目，包含名字（`rasmus`）、姓氏（`lerdorf`）、电子邮件地址（`rasmus@email.com`）和电话号码（`+1(669)1111111`）。当然，这些都是虚假数据，但当我们开始使用数据库时，它们将对我们很有用。最后一步是运行这个种子文件并将这些记录添加到我们的数据库中。我们在shell上使用以下命令来完成这个操作：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command will generate the five records we find in the seeds file. This
    was all the setup we needed for our initial application. Now, it’s time to manage
    this data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将生成种子文件中找到的五条记录。这是我们初始应用程序所需的所有设置。现在，是时候管理这些数据了。
- en: Processing data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: Up until this point, we’ve manually modified data within the database. By manually,
    I mean all inside the Rails console. However, as our project requirement is to
    let the users handle the `friends` entries, we will do so by integrating our model
    with our controller and our view so that a user can see the `friends` entries
    in a friendly interface. We will be creating a **CRUD** interface. Yes, it sounds
    ugly, but it’s the acronym software engineers came up with. It stands for **CReate
    Update Delete**, which is exactly what we are going to build – an interface to
    create, update, and delete records.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在数据库中手动修改了数据。通过手动，我的意思是所有操作都在Rails控制台中完成。然而，由于我们的项目需求是让用户处理`friends`条目，我们将通过将我们的模型与控制器和视图集成来实现这一点，以便用户可以在一个友好的界面上查看`friends`条目。我们将创建一个**CRUD**界面。是的，听起来很丑，但这正是软件工程师们想出来的缩写。它代表**创建、更新、删除**，这正是我们即将构建的——一个创建、更新和删除记录的界面。
- en: Setting up the CRUD interface
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置CRUD界面
- en: 'The first step is to confirm that the data is, in fact, in our database. From
    our previous chapter, we know that we can call the Rails console for this, so
    let’s do that by running the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确认数据实际上在我们的数据库中。从我们之前的章节中，我们知道我们可以通过调用Rails控制台来做这件事，所以让我们通过运行以下命令来实现：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should change our shell to look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该改变我们的shell外观，如下所示：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s type the following command on this console:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在这个控制台中输入以下命令：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will show all of the friends entries on the database. It should show something
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示数据库中的所有朋友条目。它应该显示类似以下的内容：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The content has been truncated for brevity, but you should see five records
    that correspond to what’s on the seed file. This output confirms that the data
    is in the database. Now, let’s exit the Rails console by typing the following
    on the shell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，内容已被截断，但你应该能看到五条记录，这些记录与种子文件上的内容相对应。这个输出确认了数据已经在数据库中。现在，让我们在shell上输入以下命令来退出Rails控制台：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let’s start our Rails application with the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令启动我们的Rails应用程序：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This command should output the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该输出以下内容：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Lastly, open the browser of your choice and go to `http://127.0.0.1:3000/any`.
    This should show the following Rails error page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开你选择的浏览器并访问`http://127.0.0.1:3000/any`。这应该会显示以下Rails错误页面：
- en: '![Figure 9.2 – The Rails Routing Error page](img/B19230_09_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – Rails路由错误页面](img/B19230_09_02.jpg)'
- en: Figure 9.2 – The Rails Routing Error page
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – Rails路由错误页面
- en: 'I purposely mentioned opening a non-existing route to view this page. Whenever
    you open a route that is not registered on the `routes.rb` file, Rails shows this
    error page, which shows us all the defined routes for our application. As I mentioned
    earlier, the resource call generated a lot of routes for us that are related to
    our `friends` component. We’ll start with `root_path`. Let’s find the `root_path`
    entry on this error page. Once we find the entry, we can see that it corresponds
    to our application’s root URL (`/`), and whenever we go to this route on the browser,
    we execute the `index` method that is inside the `friends` controller, as shown
    in the last column (`friends#index`). This error page is basically a map of URL
    addresses and what action on the controller they will execute. From this page,
    we learned that we are going to need to modify the `index` method on our `friends`
    controller file in `app/controllers/friends_controller.rb`. We should see the
    following code inside this file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意提到打开一个不存在的路由来查看这个页面。每次你打开一个在 `routes.rb` 文件上未注册的路由时，Rails 都会显示这个错误页面，它显示了我们的应用程序中定义的所有路由。正如我之前提到的，资源调用为我们生成了许多与我们的
    `friends` 组件相关的路由。我们将从 `root_path` 开始。让我们在这个错误页面上找到 `root_path` 的条目。一旦我们找到条目，我们就可以看到它对应于我们应用程序的根
    URL (`/`)，每次我们通过浏览器访问这个路由时，都会执行 `friends` 控制器中的 `index` 方法，如最后列所示（`friends#index`）。这个错误页面基本上是
    URL 地址和它们将在控制器上执行的动作的映射。从这一页，我们了解到我们需要修改 `app/controllers/friends_controller.rb`
    文件中 `friends` 控制器的 `index` 方法。我们应该在这个文件中看到以下代码：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that all these actions were generated by the controller generator, so we
    don’t start from scratch. Also, these are all the actions that we’ll build to
    create our CRUD interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些操作都是由控制器生成器生成的，所以我们不是从零开始。此外，这些都是我们将构建以创建我们的 CRUD 界面的所有操作。
- en: Listing data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出数据
- en: 'Let’s focus on the `index` method. We want to show all our records on the `index`
    method, so we will now load the `Friend` model and select all of our entries in
    the database. With these changes in mind, the `index` method should now look like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于 `index` 方法。我们想在 `index` 方法中显示所有记录，所以现在我们将加载 `Friend` 模型并选择数据库中的所有条目。考虑到这些更改，`index`
    方法现在应该看起来像这样：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By adding the `@` symbol in front of our `friends` variable, we set the variable
    to be an instance variable. The way Rails works is that this instance variable
    is then passed to the view. Note that this is not the only way to pass data from
    the controller to the view, but it is a very simple way to do it. Now, let’s go
    back to the browser but change the URL to `http://127.0.0.1:9000/`. We should
    see the following screen:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `friends` 变量前添加 `@` 符号，我们将该变量设置为实例变量。Rails 的工作方式是，这个实例变量随后被传递到视图中。请注意，这不是传递数据从控制器到视图的唯一方法，但它是一种非常简单的方法。现在，让我们回到浏览器，但将
    URL 更改为 `http://127.0.0.1:9000/`。我们应该看到以下屏幕：
- en: '![Figure 9.3 – The Rails index page](img/B19230_09_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – Rails 索引页面](img/B19230_09_03.jpg)'
- en: Figure 9.3 – The Rails index page
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Rails 索引页面
- en: 'But wait! The data that we loaded is not being shown. This is because while
    we do have Rails magic, we don’t have Rails miracles. We still have to work on
    the view. So, let’s open the `app/views/friends/index.html.erb` view and add the
    data that we just fetched from the database, with the `Friend` model. Our view
    currently looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！我们加载的数据没有显示出来。这是因为虽然我们确实有 Rails 的魔法，但我们没有 Rails 的奇迹。我们仍然需要在视图中工作。所以，让我们打开
    `app/views/friends/index.html.erb` 视图，并添加我们从数据库中检索到的数据，使用 `Friend` 模型。我们的视图目前看起来像这样：
- en: '[PRE37]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s remove that code and add a table and a cycle to iterate inside the `@friends`
    variable. Our code in the view should now look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除这段代码，并在 `@friends` 变量内添加一个表格和一个循环。我们的视图代码现在应该看起来像这样：
- en: '[PRE38]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With this code, for every friend entry on the database (`@friends.each do |friend|`),
    we will rename each entry `friend`. Note the code tags (`<% %>`) on the first
    line of code. They are very much like the PHP tags we use to embed PHP code in
    a page (`<?php ?>`), and just like the PHP tags, anything inside these tags will
    be processed as Ruby code. Since the code is simply a cycle to fetch every DB
    entry, any code after line one will be repeated for every entry in the database
    until the Ruby cycle is closed on line three. On line two, we use a different
    set of tags (`<%= %>`). These tags will not only process whatever is inside them
    as Ruby code, but they will also output the result to the browser. They are exactly
    like the PHP tags (`<?= ?>`). It’s sort of like an `echo` statement but on the
    browser. Now, let’s refresh the browser, which should show a page like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，对于数据库中的每个朋友条目（`@friends.each do |friend|`），我们将每个条目重命名为`friend`。注意代码标签（`<%
    %>`）在代码的第一行。它们非常像我们用来在页面中嵌入PHP代码的PHP标签（`<?php ?>`），而且就像PHP标签一样，这些标签内的任何内容都将被处理为Ruby代码。由于代码只是一个循环来获取每个数据库条目，所以第一行之后的任何代码都将为数据库中的每个条目重复，直到Ruby循环在第三行关闭。在第二行，我们使用了一组不同的标签（`<%=
    %>`）。这些标签不仅将它们内部的内容作为Ruby代码处理，还将结果输出到浏览器。它们与PHP标签（`<?= ?>`）完全一样。这有点像`echo`语句，但是在浏览器上。现在，让我们刷新浏览器，应该会显示如下页面：
- en: '![Figure 9.4 – The Rails index page with data](img/B19230_09_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 带有数据的Rails索引页面](img/B19230_09_04.jpg)'
- en: Figure 9.4 – The Rails index page with data
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 带有数据的Rails索引页面
- en: 'Wow! We’ve done it. We’ve loaded data from the database to the controller and
    then to the view. I don’t know about you, but the first time I saw this I was
    really excited, not only because of the result but also because I understood what
    I was doing with the framework. I hope you do too now. Unfortunately, this was
    just a test to make sure our data was being loaded correctly into the view. A
    proper grid will have titles and more fields. Let’s remove the code we just added
    to the view and add the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们做到了。我们已经从数据库中加载数据到控制器，然后再到视图中。我不知道你怎么样，但第一次我看到这个的时候我真的很兴奋，不仅因为结果，还因为我理解了我是如何使用这个框架的。我希望你现在也做到了。不幸的是，这只是一个测试，以确保我们的数据被正确地加载到视图中。一个合适的网格将会有标题和更多的字段。让我们移除我们刚刚添加到视图中的代码，并添加以下代码：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this change, the first six lines of code build a table and the title rows.
    On line seven, we create the cycle to iterate between each database entry. Inside
    the cycle, we show the first and the last name. Lastly, we’ve added a link to
    the `edit` action. This is to work on our next view. If we refresh the browser,
    we should see the following page:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，前六行代码构建了一个表格和标题行。在第七行，我们创建了一个循环来迭代每个数据库条目。在循环内部，我们显示了名字和姓氏。最后，我们添加了一个链接到`edit`操作。这是为了处理我们的下一个视图。如果我们刷新浏览器，我们应该看到以下页面：
- en: '![ Figure 9.5 – A Rails index table with data](img/B19230_09_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 带有数据的Rails索引表](img/B19230_09_05.jpg)'
- en: Figure 9.5 – A Rails index table with data
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 带有数据的Rails索引表
- en: Now, let’s work on the update page of our CRUD web interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们着手我们的CRUD网络界面的更新页面。
- en: Updating data
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'To edit an entry, we first must select that entry. If we take a closer look
    at *Figure 9**.2*, we can see that the `edit_friend_path` route passes a parameter
    (`:id`). Unlike classic PHP, we do not explicitly pass parameters by the URL.
    Instead, we embed them inside the URL so that our route would be `http://localhost:3000/friends/2/edit`
    instead of `http://localhost:3000/friends?id=2`. In Rails, we seldom use explicit
    URL parameters (`?parameter_name=value`). With that in mind, as we already have
    the name of the parameter, we can use it to select a single entry. Let’s open
    our edit method on the `friends` controller in `app/controllers/friends_controller.rb`.
    The method is currently empty. It should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑一个条目，我们首先必须选择该条目。如果我们仔细看看**图9.2**，我们可以看到`edit_friend_path`路由传递了一个参数（`:id`）。与经典PHP不同，我们不是通过URL显式传递参数。相反，我们将它们嵌入到URL中，这样我们的路由就会是`http://localhost:3000/friends/2/edit`而不是`http://localhost:3000/friends?id=2`。在Rails中，我们很少使用显式的URL参数（`?parameter_name=value`）。考虑到我们已经有了参数的名称，我们可以使用它来选择单个条目。让我们打开`app/controllers/friends_controller.rb`中的`friends`控制器上的编辑方法。该方法目前为空。它应该看起来像这样：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let’s use our model to select a single user by its ID. Our code will now
    look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的模型通过ID选择单个用户。我们的代码现在看起来像这样：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we’ve selected the entry, let’s see some more Rails magic in action.
    Let’s open the edit view on `app/views/friends/edit.html.erb`. This should look
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了条目，让我们看看更多Rails魔法的实际应用。让我们打开`app/views/friends/edit.html.erb`上的编辑视图。它应该看起来像这样：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s delete the preceding HTML code and replace it with the following
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除前面的HTML代码，并用以下代码替换它：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Rails comes with another set of tools for tasks we do over and over. These tools
    are called *helpers*. Helpers are functions that we can call to generate a task
    for us. There are many types of helpers, but for now, we’ll use form helpers that
    assist us in building forms for data processing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rails为我们重复执行的任务提供了一套工具。这些工具被称为*辅助函数*。辅助函数是我们可以调用来为我们生成任务的函数。有许多类型的辅助函数，但就目前而言，我们将使用表单辅助函数，这些函数帮助我们构建用于数据处理的数据表单。
- en: 'If you’re interested in learning more on this topic of form helpers, please
    refer to the Ruby guides:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个表单辅助函数的主题感兴趣，请参考Ruby指南：
- en: '[https://guides.rubyonrails.org/form_helpers.html](https://guides.rubyonrails.org/form_helpers.html)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://guides.rubyonrails.org/form_helpers.html](https://guides.rubyonrails.org/form_helpers.html)'
- en: 'In the preceding code, we chose the `form_with` helper to generate a form to
    update the `Friend` entry. Then, inside the form, for each field that we have
    on the database (`first_name`, `last_name`, `email`, and `phone`), we generated
    a label and a field. Lastly, we added a submit button to send the data back to
    the controller for processing. Now, let’s open our browser and click on the first
    `DETAILS` link on the index page. This will take us to the `http://127.0.0.1:3000/friends/1/edit`
    URL, and it should show the following page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们选择了`form_with`辅助函数来生成一个用于更新`Friend`条目的表单。然后，在表单内部，对于我们在数据库中拥有的每个字段（`first_name`、`last_name`、`email`和`phone`），我们生成了一个标签和一个字段。最后，我们添加了一个提交按钮，以便将数据发送回控制器进行处理。现在，让我们打开我们的浏览器，点击首页上的第一个`DETAILS`链接。这将带我们到`http://127.0.0.1:3000/friends/1/edit`这个URL，并且应该显示以下页面：
- en: '![Figure 9.6 – A Rails edit form with data](img/B19230_09_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 带有数据的Rails编辑表单](img/B19230_09_06.jpg)'
- en: Figure 9.6 – A Rails edit form with data
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 带有数据的Rails编辑表单
- en: And voilà! With very little code, we’ve generated a form that shows the current
    field values and lets us modify these values. However, we’re still missing the
    code to modify any of these values on the database. So, let’s go back to the controller
    on `app/controllers/friends_controller.rb`, but now, we’ll add a method to help
    us process the form.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！用很少的代码，我们已经生成了一个显示当前字段值并允许我们修改这些值的表单。然而，我们仍然缺少修改数据库中任何这些值的代码。所以，让我们回到`app/controllers/friends_controller.rb`中的控制器，但现在，我们将添加一个方法来帮助我们处理表单。
- en: Creating data
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据
- en: 'Our last method (`create`) is at the end of our class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中的最后一个方法（`create`）在类的末尾：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s add a private method called `friend_params` right after our `create`
    method. Our code should look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`create`方法之后添加一个名为`friend_params`的私有方法。我们的代码应该看起来像这样：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this method, when called, we let Rails know that the data sent through
    a form should have a `friend` index, and inside this index, it may have the `first_name`
    field, `last_name` field, and so on. In PHP terms, this would be equivalent to
    sending data in the following array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，当被调用时，我们让Rails知道通过表单发送的数据应该有一个`friend`索引，并且在这个索引中，它可能包含`first_name`字段、`last_name`字段等。用PHP术语来说，这将相当于在以下数组中发送数据：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I’m oversimplifying this process, but in essence, the method requires and allows
    certain parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个过程的简化可能有些过分，但本质上，这个方法需要并允许某些参数。
- en: 'If you wish to learn more about parameters, do take a look at these pages:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于参数的信息，请查看以下页面：
- en: '[https://apidock.com/rails/ActionController/Parameters/require](https://apidock.com/rails/ActionController/Parameters/require)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://apidock.com/rails/ActionController/Parameters/require](https://apidock.com/rails/ActionController/Parameters/require)'
- en: '[https://apidock.com/rails/ActionController/Parameters/permit](https://apidock.com/rails/ActionController/Parameters/permit)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://apidock.com/rails/ActionController/Parameters/permit](https://apidock.com/rails/ActionController/Parameters/permit)'
- en: 'For now, let’s implement this `friend_params` method. Do keep in mind that
    to show the edit form, the method we call is `edit`, but to modify the data on
    the database, we’ll call the `update` method. Currently, the `update` method is
    empty. Let’s modify the method so that it will now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个`friend_params`方法。请记住，为了显示编辑表单，我们调用的方法是`edit`，但为了修改数据库中的数据，我们将调用`update`方法。目前，`update`方法是空的。让我们修改这个方法，使其现在看起来像这样：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the `@friend` variable, we again select the record that we are going to
    modify. Once this record is selected, we call the `update` method on this object,
    which is where the update on the database will happen. Lastly, we’ll use the `redirect_to`
    helper to send the user to the `friends` page on the browser. This code is very
    concise and almost reads like sentences – *find friend* and *if friend is updated
    with friend parameters, redirect to friends path*. This is Ruby at its finest.
    The only thing we haven’t analyzed from this snippet of code is the `friends_path`
    helper. However, it’s simple. We’ll refer again to *Figure 9**.2*, in which we
    see a table with all of our defined routes. As we find the `friends_path` helper
    on this page, we can determine that when we use that alias, we can send a user
    to the correct controller and method (`friends#index`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@friend`变量，我们再次选择将要修改的记录。一旦选择了这条记录，我们就调用这个对象上的`update`方法，数据库的更新就会在这里发生。最后，我们将使用`redirect_to`辅助函数将用户发送到浏览器上的`friends`页面。这段代码非常简洁，几乎就像句子一样——*查找朋友*和*如果朋友使用朋友参数更新，则重定向到朋友路径*。这是Ruby最精彩的地方。我们还没有分析这段代码片段中的`friends_path`辅助函数。然而，它很简单。我们再次参考*图9**.2*，其中我们看到一个包含所有定义的路由的表格。当我们在这个页面上找到`friends_path`辅助函数时，我们可以确定，当我们使用这个别名时，我们可以将用户发送到正确的控制器和方法（`friends#index`）。
- en: 'Now, let’s move on to creating a new `friend` entry. As with the edit page,
    let’s first generate our new entry page. In the `app/controllers/friends_controller.rb`
    file, let’s modify the empty `new` method. It should now look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建一个新的`friend`条目。就像编辑页面一样，让我们首先生成新的条目页面。在`app/controllers/friends_controller.rb`文件中，让我们修改空的`new`方法。它现在应该看起来像这样：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we are going to use the `form_for` helper, we need to pass an empty model
    object for the helper to be able to generate the form correctly. Let’s open the
    `new` view in `app/views/friends/new.html.erb`, which currently looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`form_for`辅助函数，我们需要传递一个空的模型对象，以便辅助函数能够正确地生成表单。让我们打开`app/views/friends/new.html.erb`中的`new`视图，它目前看起来像这样：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s delete the preceding content and replace it with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除前面的内容，并用以下代码替换它：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You might have noticed that this is the exact same view as the edit page. Most
    of the time, we should not repeat the exact same code, but since we are still
    learning Rails, we get a pass here. Now, let’s go back to the controller in `app/controllers/friends_controller.rb`
    and modify the `create` method. It’s empty, but we should add some code so that
    it looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这与编辑页面的视图完全相同。大多数时候，我们不应该重复相同的代码，但由于我们还在学习Rails，我们这次可以过关。现在，让我们回到`app/controllers/friends_controller.rb`中的控制器，并修改`create`方法。它是空的，但我们应该添加一些代码，使其看起来像这样：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Just like the `update` method, we call the `create` method with the `friend`
    params to create a new entry. Once the entry is created, we redirect the user
    to the `friends` index page. Now, let’s try it out on the browser. On the browser,
    open the `http://127.0.0.1:3000/friends/new` URL, which should show the same form
    as the edit page, but without any data:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`update`方法一样，我们使用`friend`参数调用`create`方法来创建一个新的条目。一旦条目创建完成，我们就将用户重定向到`friends`索引页面。现在，让我们在浏览器上试一试。在浏览器中打开`http://127.0.0.1:3000/friends/new`
    URL，它应该显示与编辑页面相同的表单，但没有任何数据：
- en: '![Figure 9.7 – The Rails new entry form](img/B19230_09_07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – Rails新条目表单](img/B19230_09_07.jpg)'
- en: Figure 9.7 – The Rails new entry form
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – Rails新条目表单
- en: 'Let’s fill the fields with new data, as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们填写字段，如图所示：
- en: '![Figure 9.8 – The Rails new entry form with data](img/B19230_09_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 带有数据的Rails新条目表单](img/B19230_09_08.jpg)'
- en: Figure 9.8 – The Rails new entry form with data
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 带有数据的Rails新条目表单
- en: 'When we click on the `friends` index page, which should show the newly created
    friend:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击`friends`索引页面时，它应该显示新创建的朋友：
- en: '![Figure 9.9 – The Rails index page with a new entry](img/B19230_09_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 带有新条目的Rails索引页面](img/B19230_09_09.jpg)'
- en: Figure 9.9 – The Rails index page with a new entry
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 带有新条目的Rails索引页面
- en: OK, we are almost there – just a few more lines of code. The only method left
    to cover is the `destroy` method, but it’s as easy as the other methods we’ve
    coded so far.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们几乎完成了——只需再写几行代码。剩下的唯一一个方法就是`destroy`方法，但它和其他我们已经编写的方法一样简单。
- en: Deleting data
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'Let’s open up our edit view on `app/views/friends/edit.html.erb` and add another
    form at the end of the file. Our form at the end of the file should look like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app/views/friends/edit.html.erb`的编辑视图中打开，并在文件末尾添加另一个表单。文件末尾的表单应该看起来像这样：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Beware of not modifying any of the code that was already in this `edit.html.erb`
    view at the beginning of the file. We should add the preceding code at the *end*
    of the file. This new form generates a delete button. Note how we are passing
    an additional parameter, `method:`, with the value of the `:delete` symbol. This
    will automatically make the form send the data to the appropriate `destroy` method.
    Now, let’s work on the `destroy` method on the controller in `app/controllers/friends_controller.rb`.
    As with the other methods we’ve covered so far, this method should be empty. Let’s
    add the following code to it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不要修改文件开头在 `edit.html.erb` 视图中已经存在的任何代码。我们应该在文件的 *末尾* 添加前面的代码。这个新表单生成一个删除按钮。注意我们传递了一个额外的参数
    `method:`，其值为 `:delete` 符号。这将自动使表单将数据发送到适当的 `destroy` 方法。现在，让我们在 `app/controllers/friends_controller.rb`
    控制器上工作 `destroy` 方法。与其他我们迄今为止覆盖的方法一样，此方法应该是空的。让我们向其中添加以下代码：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With this ominously looking code, we’re telling Rails to select a user by their
    ID, delete the record from the database, and finally, redirect the user to the
    `friends` index page. Now, let’s give it a try on the browser. Let’s open our
    browser and go to the `friends` index page: `http://127.0.0.1:3000/friends`. Click
    on the last link at the bottom, which should open the edit page that corresponds
    to Taylor Otwell:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个看起来不祥的代码，我们告诉 Rails 通过用户的 ID 选择一个用户，从数据库中删除记录，最后，将用户重定向到 `friends` 索引页面。现在，让我们在浏览器中尝试一下。让我们打开我们的浏览器并转到
    `friends` 索引页面：`http://127.0.0.1:3000/friends`。点击底部的最后一个链接，它应该打开与 Taylor Otwell
    对应的编辑页面：
- en: '![Figure 9.10 – A Rails edit page with the latest entry](img/B19230_09_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 包含最新条目的 Rails 编辑页面](img/B19230_09_10.jpg)'
- en: Figure 9.10 – A Rails edit page with the latest entry
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 包含最新条目的 Rails 编辑页面
- en: 'Note how we now have a **DELETE** button. Let’s click on it, and just as quickly
    as we created this entry, we now have deleted it. The table should now look like
    this (without the Taylor Otwell record):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在有一个 **删除** 按钮。让我们点击它，就像我们创建这个条目一样快，我们现在已经删除了它。表格现在应该看起来像这样（没有 Taylor Otwell
    记录）：
- en: '![Figure 9.11 – A Rails friends index page with one less entry](img/B19230_09_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 包含一个更少条目的 Rails 朋友索引页面](img/B19230_09_11.jpg)'
- en: Figure 9.11 – A Rails friends index page with one less entry
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 包含一个更少条目的 Rails 朋友索引页面
- en: 'And with that, my dear reader, we have successfully created our CRUD interface
    for our friend address book. We can now list the existing friends, create new
    ones, modify the existing ones, and lastly, delete any records we no longer need.
    Just so we don’t get confused as to what our controller in `app/controllers/friends_controller.rb`
    should look like at the end of this exercise, let me share the whole file again
    with all the changes we’ve made so far:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，亲爱的读者，我们已经成功地为我们的朋友地址簿创建了 CRUD 接口。我们现在可以列出现有的朋友，创建新的，修改现有的，最后，删除我们不再需要的任何记录。为了避免我们在完成练习后对
    `app/controllers/friends_controller.rb` 控制器的最终样子感到困惑，让我再次分享我们迄今为止所做的所有更改的整个文件：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'While our application can now handle records, it still has room for improvement,
    such as the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用程序现在可以处理记录，但它仍有改进的空间，例如以下内容：
- en: We could use a navigation bar or at least a link to the “new” page
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用导航栏或至少一个链接到“新”页面
- en: We should refactor the form views so that we use the same form to modify and
    add records
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该重构表单视图，以便我们使用相同的表单来修改和添加记录
- en: We should use validations
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该使用验证
- en: We should show errors if any of the actions fail
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何操作失败，我们应该显示错误
- en: 'I tried to over-simplify many of these concepts to focus more on a pragmatic
    approach. However, if you are interested in a more detailed set of examples, there
    are always the guides from Ruby on Rails: [https://guides.rubyonrails.org/getting_started.html](https://guides.rubyonrails.org/getting_started.html).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试将这些概念过度简化，以便更多地关注实用方法。然而，如果您对更详细的示例集感兴趣，Ruby on Rails 的指南始终可用：[https://guides.rubyonrails.org/getting_started.html](https://guides.rubyonrails.org/getting_started.html)。
- en: The examples in the preceding web page will cover a far more detailed version
    of what we saw in this chapter. You could make everyone proud and take on these
    improvements on your own.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前一网页中的示例将涵盖比本章中我们看到的内容更为详细的版本。您可以让每个人都感到自豪，并自行承担这些改进。
- en: Back to the task at hand – the hypothetical client accepted our simplified version
    of the CRUD interface. However, someone asked about security. They don’t want
    just anyone to be able to see their friend entries on the app. They want to at
    least protect the application with a login page. If you were thinking that we
    need to program this authentication component, think no more, as we have just
    the tool for this.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回到手头的任务——假设的客户接受了我们简化的 CRUD 接口版本。然而，有人提出了关于安全性的问题。他们不希望任何人都能看到他们在应用中的朋友条目。他们至少希望保护应用有一个登录页面。如果你在想我们需要编写这个认证组件，那就不要再想了，因为我们正好有这个工具。
- en: Do not, I repeat, do not repeat yourself
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要，我重复一遍，不要重复自己
- en: If you’ve worked with frameworks in the past, you may be familiar with the **Don’t
    Repeat Yourself** (**DRY**) principle, even though the principle is more focused
    on coding and coding style. If you’re not, or just need a reminder, the DRY principle
    simply states that you should not repeat yourself.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过框架，你可能对**不要重复自己**（**DRY**）原则很熟悉，尽管这个原则更多地关注于编码和编码风格。如果你不熟悉，或者只是需要提醒，DRY
    原则简单地说就是你不应该重复自己。
- en: 'You can find out more details here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多详细信息：
- en: '[https://docs.getdbt.com/terms/dry](https://docs.getdbt.com/terms/dry)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.getdbt.com/terms/dry](https://docs.getdbt.com/terms/dry)'
- en: 'As much as we possibly can, we should try not to repeat our code. As an example
    in this application, we repeated the code on the `edit` and `new` views. Using
    the DRY principle, we should refactor our code so that it uses the same form for
    both actions. In the same manner, instead of building everything on your own and
    from scratch, you should reuse functions, tools, and even libraries altogether.
    One task that we as developers have done over and over is to authenticate users.
    If you have an authentication code that works, you may have even copied it from
    a previous project. However, an open source tool can improve your code. One advantage
    of using an open source tool to handle your authentication is that it’s tested
    against many more scenarios than you could have ever imagined on your own. Another
    reason to use an open source tool is that it may be ready to use and simple to
    incorporate into our project. There are several gems for user authentication,
    but for now, we’ll use one that is very easy to use called Devise: [https://github.com/heartcombo/devise](https://github.com/heartcombo/devise).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能地尝试不重复我们的代码。以这个应用程序为例，我们在 `edit` 和 `new` 视图中重复了代码。使用 DRY 原则，我们应该重构我们的代码，使其对这两个动作使用相同的表单。同样地，而不是从头开始构建一切，你应该重用函数、工具，甚至整个库。作为开发者，我们反复做的一项任务是验证用户。如果你有一个有效的认证代码，你可能甚至是从以前的项目中复制过来的。然而，开源工具可以改进你的代码。使用开源工具处理认证的一个优点是它经过了比你自己能想象的更多场景的测试。使用开源工具的另一个原因是它可能已经准备好使用，并且很容易整合到我们的项目中。有几个用于用户认证的
    gem，但到目前为止，我们将使用一个非常容易使用的 gem，称为 Devise：[https://github.com/heartcombo/devise](https://github.com/heartcombo/devise)。
- en: 'Devise is a gem that, interestingly enough, generates several Rails components
    that we can use for our application. Devise will generate views, routes, and helpers
    to assist us with our user authentication. So, let’s incorporate a new gem into
    our application. The first step is going to be to stop the Rails application server.
    Open the shell where the application is currently running and press the *Ctrl*
    key and *C*. This should stop the Rails application and return the shell to normal.
    The next step is to include the Devise gem in our Gemfile. Let’s open our `./Gemfile`
    file at the root of our project (`chapter09/rails7_original/Gemfile`), and add
    the following code right after the Rails gem line. The Gemfile should now look
    like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Devise 是一个 gem，有趣的是，它为我们生成了一些 Rails 组件，我们可以用于我们的应用程序。Devise 将生成视图、路由和助手来帮助我们进行用户认证。所以，让我们将一个新的
    gem 纳入我们的应用程序。第一步是停止 Rails 应用程序服务器。打开当前运行应用程序的 shell 并按下 *Ctrl* 键和 *C*。这应该停止 Rails
    应用程序并将 shell 返回到正常状态。下一步是将 Devise gem 包含到我们的 Gemfile 中。让我们打开我们的 `./Gemfile` 文件，位于我们项目的根目录（`chapter09/rails7_original/Gemfile`），并在
    Rails gem 行之后添加以下代码。现在，Gemfile 应该看起来像这样：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let’s install our gem. Let’s go to our shell and run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装我们的 gem。让我们进入我们的 shell 并运行以下命令：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The command should output a message related to the devise gem:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该输出与 devise gem 相关的消息：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our gem has been installed, but it still needs to run additional tasks, and
    we still need to add some configuration to our app in order for us to be able
    to use Devise. Let’s run the `install` command on our shell:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的gem已经安装，但它仍然需要运行额外的任务，我们仍然需要在我们的应用程序中添加一些配置，以便我们能够使用Devise。让我们在我们的shell上运行`install`命令：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The outcome of this installation is a set of instructions that we must do before
    being able to use the gem in our project:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本安装的结果是一系列指令，我们必须在能够在我们项目中使用这个gem之前执行：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We must follow these post installation instructions for the gem to work properly.
    The first task refers to adding a line of configuration to our environment config
    file. Let’s do that. Let’s open `config/environment/development.rb` and add the
    following line to it. Our `config` file should now look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须遵循这些安装后指令，以便gem能够正常工作。第一个任务指的是在我们的环境配置文件中添加一行配置。让我们这样做。让我们打开`config/environment/development.rb`并添加以下行到其中。我们的`config`文件现在应该看起来像这样：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We’ve added a line to set the `config.action_mailer.default_url_options` flag
    after the `config.action_mailer.perform_caching` flag is set. In a production
    setting, the configuration line we just added would enable password recovery through
    email. As this will not work locally, we can ignore it, but the config still needs
    to be set in place for Devise to work. The second instruction refers to having
    a root route. We can also ignore this instruction, as our application already
    includes a root route. The third task requires that we modify our application
    layout to include an HTML placeholder for errors and messages. So, let’s do just
    that. Let’s open the `app/views/layouts/application.html.erb` file. This file
    controls how our application will look. Anytime you need to make a view change
    on a general level, this is the place to go. Let’s add those placeholders so that
    our application layout now looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`config.action_mailer.perform_caching`标志之后，我们添加了一行来设置`config.action_mailer.default_url_options`标志。在生产环境中，我们刚刚添加的配置行将启用通过电子邮件进行密码恢复。由于这在本地环境中不起作用，我们可以忽略它，但配置仍然需要设置以使Devise正常工作。第二个指令指的是有一个根路由。我们也可以忽略这个指令，因为我们的应用程序已经包含了一个根路由。第三个任务要求我们修改我们的应用程序布局以包含错误和消息的HTML占位符。所以，让我们这样做。让我们打开`app/views/layouts/application.html.erb`文件。这个文件控制着我们的应用程序的外观。任何需要在对应用程序进行一般级别的视图更改时，都应该去这个地方。让我们添加这些占位符，使我们的应用程序布局现在看起来像这样：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Whenever Devise alerts any messages regarding the login process, these placeholders
    will now show those messages (if any are present). From post installation instructions
    to get the devise gem to work correctly, we are at the last task (number 4) and
    this task can be ignored, as it refers to customizing our login views. We’re almost
    ready to use Devise, but as I mentioned before, this gem will need a database
    model to save our user data. So, let’s run the following command on our shell
    to do so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当Devise发出有关登录过程的任何消息时，这些占位符将现在显示这些消息（如果有）。从安装后指令到使devise gem正确工作，我们现在是最后一个任务（编号4），这个任务可以忽略，因为它指的是自定义我们的登录视图。我们几乎准备好使用Devise了，但如我之前提到的，这个gem需要一个数据库模型来保存我们的用户数据。所以，让我们在我们的shell上运行以下命令来做到这一点：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This should output the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'From analyzing this output, we can see that both a user model and a database
    migration have been created. This command also added the login routes to our application.
    Remember what we do after we create a database migration? We need to run the database
    migration so that the user structure is added to the database. Let’s do just that.
    Run the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从分析这个输出中，我们可以看到已经创建了一个用户模型和一个数据库迁移。这个命令还把登录路由添加到了我们的应用程序中。记住我们在创建数据库迁移后做了什么？我们需要运行数据库迁移，以便将用户结构添加到数据库中。让我们这样做。运行以下命令：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will output the changes made to the database:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出对数据库所做的更改：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Our gem is now ready to be used by our application. For now, let’s limit all
    access to our application so that no method on the controller can be viewed without
    signing in. The beginning of our `app/controllers/friends_controller.rb` file
    should now look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的gem现在已准备好被我们的应用程序使用。目前，让我们限制对应用程序的所有访问，以便没有登录就无法查看控制器上的任何方法。我们的`app/controllers/friends_controller.rb`文件的开始部分现在应该看起来像这样：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'By adding the second line of code, the `before_action` helper will perform
    the user authentication prior to executing any other action on the controller.
    Now, it’s time to try it out. Let’s go to our shell and start the Rails application
    server with the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加第二行代码，`before_action` 辅助函数将在控制器执行任何其他操作之前执行用户认证。现在，是时候尝试一下了。让我们进入我们的 shell，并使用以下命令启动
    Rails 应用程序服务器：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once our application is up and running, we should go back to the browser and
    open `http://127.0.0.1:3000/`, and you will be asked for an email address and
    a password:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序启动并运行，我们应该回到浏览器并打开 `http://127.0.0.1:3000/`，然后你会被要求输入一个电子邮件地址和一个密码：
- en: '![Figure 9.12 – The Devise login page](img/B19230_09_12.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – Devise 登录页面](img/B19230_09_12.jpg)'
- en: Figure 9.12 – The Devise login page
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – Devise 登录页面
- en: 'If you see this form, it means that the Devise gem is working. If you try to
    view any page (e.g., `http://127.0.0.1:3000/friends/1/edit` or any other existing
    route), you should be redirected to the login page. There are two ways to create
    users with the Devise gem in place. We can use our Rails console, or we can just
    sign up. Let’s use the sign-up method. Click on the **Sign up** link, and it should
    take you to the **Sign** **up** form:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个表单，这意味着 Devise 晶石正在工作。如果你尝试查看任何页面（例如，`http://127.0.0.1:3000/friends/1/edit`
    或任何其他现有路由），你应该会被重定向到登录页面。使用 Devise 晶石创建用户有两种方式。我们可以使用我们的 Rails 控制台，或者我们可以直接注册。让我们使用注册方法。点击
    **注册** 链接，它应该会带你到 **注册** 表单：
- en: '![Figure 9.13 – The Devise sign up page](img/B19230_09_13.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – Devise 注册页面](img/B19230_09_13.jpg)'
- en: Figure 9.13 – The Devise sign up page
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – Devise 注册页面
- en: 'Let’s add an email address, `admin@email.com`, and `123456` as the password.
    Then, when you click on the `http://127.0.0.1:3000/` – try it. You should be able
    to see the index page again:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个电子邮件地址，`admin@email.com`，以及 `123456` 作为密码。然后，当你点击 `http://127.0.0.1:3000/`
    – 尝试一下。你应该能够再次看到首页：
- en: '![Figure 9.14 – The authenticated index page](img/B19230_09_14.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 认证的首页](img/B19230_09_14.jpg)'
- en: Figure 9.14 – The authenticated index page
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 认证的首页
- en: 'As our pièce de resistance, let’s add a logout link, but only to our index
    page. Open the `app/views/friends/index.html.erb` file, and add this code to the
    end of the file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的压轴戏，让我们添加一个注销链接，但只添加到我们的首页。打开 `app/views/friends/index.html.erb` 文件，并在文件末尾添加以下代码：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, the form looks fairly familiar. Devise uses the same `form_with` helper
    to build a form to log out with. Let’s go back to our browser and refresh the
    index view. It will look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个表单看起来相当熟悉。Devise 使用相同的 `form_with` 辅助函数来构建一个用于注销的表单。让我们回到我们的浏览器并刷新首页视图。它看起来像这样：
- en: '![Figure 9.15 – The index page with a Sign out button](img/B19230_09_15.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 带有注销按钮的首页](img/B19230_09_15.jpg)'
- en: Figure 9.15 – The index page with a Sign out button
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 带有注销按钮的首页
- en: We now have a **Sign out** button. If we click it, our session ends, and we
    are redirected to the login page again. We can log in again using the credentials
    we created a few steps back.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 **注销** 按钮。如果我们点击它，我们的会话结束，我们再次被重定向到登录页面。我们可以使用之前创建的凭据再次登录。
- en: Congratulations! Our work here is done. As always, there is room for improvement
    and further learning. This gem is super handy and has helped me solve the authentication
    piece of an application many times. One thing (among so many) that you may have
    noticed is that even though this gem uses session values to handle the authentication,
    you never see these session values, and you never handle them directly. That is
    the Rails way of doing things. We always tend to hide the session layer of an
    application with helpers. Devise comes with some helpers that will help you within
    your code to show or hide components, depending on your authentication status.
    You may want to check the `user_signed_in?`, `current_user`, and `user_session`
    helpers on the Devise documentation page. Additionally, you can add several other
    customizations that you may want to add to your authentication mechanism. Be sure
    to play around with the gem, and learn on your own what other configurations might
    be useful to you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在这里我们的工作已经完成。和往常一样，总有改进和进一步学习的空间。这个钩子非常实用，它帮助我多次解决了应用程序的认证部分。你可能已经注意到的一件事（在众多事情中）是，尽管这个钩子使用会话值来处理认证，但你从未看到这些会话值，也从未直接处理它们。这就是
    Rails 的做事方式。我们总是倾向于使用辅助工具隐藏应用程序的会话层。Devise 随带一些辅助工具，可以帮助你在代码中根据你的认证状态显示或隐藏组件。你可能想查看
    Devise 文档页面上的 `user_signed_in?`、`current_user` 和 `user_session` 辅助工具。此外，你还可以添加其他一些你可能想要添加到你的认证机制中的自定义设置。确保玩转这个钩子，并自己学习哪些其他配置可能对你有用。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! We covered a lot of ground in this chapter. We learned how to load data
    from a model to a controller to finally show data on the view. We also learned
    how to interact with forms and impact the database with the MVC architecture of
    Rails. Last but not least, we learned how to integrate the Devise gem with our
    application to leverage our authentication mechanism, instead of building one
    from scratch.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！在这一章中，我们覆盖了大量的内容。我们学习了如何从模型加载数据到控制器，最终在视图中显示数据。我们还学习了如何通过 Rails 的 MVC 架构与表单交互并影响数据库。最后但同样重要的是，我们学习了如何将
    Devise 钩子集成到我们的应用程序中，以利用我们的认证机制，而不是从头开始构建。
- en: Now, we are ready for our last chapter, where we’ll explore some additional
    information regarding hosting our Rails application on a server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进入最后一章，我们将探讨一些关于在服务器上托管我们的 Rails 应用程序的相关附加信息。
