<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;A Command-line Companion Called Artisan"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. A Command-line Companion Called Artisan</h1></div></div></div><p>In the last few chapters, we have used Artisan for various tasks, such as running database migrations. However, as we will see in this chapter, Laravel's command-line utility has far more capabilities and can be used to run and automate all sorts of tasks. In the next pages, you will learn how Artisan can help you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inspect and interact with your application</li><li class="listitem" style="list-style-type: disc">Enhance the overall performance of your application</li><li class="listitem" style="list-style-type: disc">Write your own commands</li></ul></div><p>By the end of this tour of Artisan's capabilities, you will understand how it can become an indispensable companion in your projects.</p><div class="section" title="Keeping up with the latest changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Keeping up with the latest changes</h1></div></div></div><p>New features are <a id="id215" class="indexterm"/>constantly being added to Laravel. If a few days have passed since you first installed it, try running a <code class="literal">composer update</code> command from your terminal. You should see the latest versions of Laravel and its dependencies being downloaded. Since you are already in the terminal, finding out about the latest features is just one command away:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan changes</strong></span>
</pre></div><p>This saves you from going online to find a change log or reading through a long history of commits on GitHub. It can also help you learn about features that you were not aware of. You can also find out which version of Laravel you are running by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan --version</strong></span>
<span class="strong"><strong>Laravel Framework version 5.0.16</strong></span>
</pre></div><p>All Artisan commands have to be run from your project's root directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>With the help of a short script such as Artisan Anywhere, available at <a class="ulink" href="https://github.com/antonioribeiro/artisan-anywhere">https://github.com/antonioribeiro/artisan-anywhere</a>, it is also possible to <a id="id216" class="indexterm"/>run Artisan from any subfolder in your project.</p></div></div></div></div>
<div class="section" title="Inspecting and interacting with your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Inspecting and interacting with your application</h1></div></div></div><p>With the <code class="literal">route:list</code> command, you can see at a glance which URLs your application will <a id="id217" class="indexterm"/>respond to, what their names are, and if any middleware has <a id="id218" class="indexterm"/>been registered to handle requests. This is probably the quickest way to get acquainted with a Laravel application that someone else has built.</p><p>To display a table with all the routes, all you have to do is enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan route:list</strong></span>
</pre></div><p>For example, the following is what the application we built in <a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>, looks like:</p><div class="mediaobject"><img src="graphics/B04308_06_01.jpg" alt="Inspecting and interacting with your application"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>In some applications, you might see <code class="literal">/{v1}/{v2}/{v3}/{v4}/{v5}</code> appended to particular routes. This is because the developer has registered a controller with <a id="id219" class="indexterm"/>implicit routing, and Laravel will try to match <a id="id220" class="indexterm"/>and pass up to five parameters to the controller.</p></div></div><div class="section" title="Fiddling with the internals"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Fiddling with the internals</h2></div></div></div><p>When developing <a id="id221" class="indexterm"/>your application, you will sometimes need to run short, one-off commands to inspect the contents of your database, insert some data into it, or check the syntax and results of an Eloquent query. One way you could do this is by creating a temporary route with a closure that is going to trigger these actions. However, this is less than practical since it requires you to switch back and forth between your code editor and your web browser.</p><p>To make these small changes easier, Artisan provides a command called <code class="literal">tinker</code>, which boots up the application and lets you interact with it. Just enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan tinker</strong></span>
</pre></div><p>This will start a <a id="id222" class="indexterm"/>
<span class="strong"><strong>Read-Eval-Print Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) similar to what you get when running the <code class="literal">php -a</code> command, which starts an interactive shell. In this REPL, you can enter PHP commands in the context of the application and immediately see their output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; $cat = 'Garfield';</strong></span>
<span class="strong"><strong>&gt; App\Cat::create(['name' =&gt; $cat,'date_of_birth' =&gt; new DateTime]);</strong></span>
<span class="strong"><strong>&gt; echo App\Cat::whereName($cat)-&gt;get();</strong></span>
<span class="strong"><strong>[{"id":"4","name":"Garfield 2","date_of_birth":…}]</strong></span>
<span class="strong"><strong>&gt; dd(Config::get('database.default'));</strong></span>
</pre></div><p>Version 5 of Laravel leverages PsySH, a PHP-specific REPL that provides a more robust shell with support for keyboard shortcuts and history.</p></div><div class="section" title="Turning the engine off"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Turning the engine off</h2></div></div></div><p>Whether it is <a id="id223" class="indexterm"/>because you are upgrading a database or waiting to push a fix for a critical bug to production, you may want to manually put your application on hold to avoid serving a broken page to your visitors. You can do this by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan down</strong></span>
</pre></div><p>This will put your application into <span class="strong"><strong>maintenance</strong></span> mode. You can determine what to display to users when they visit your application in this mode by editing the template file at <code class="literal">resources/views/errors/503.blade.php</code> (since maintenance mode sends an HTTP status code of <code class="literal">503 Service Unavailable</code> to the client). To exit maintenance mode, simply run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan up</strong></span>
</pre></div></div><div class="section" title="Fine-tuning your application"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Fine-tuning your application</h2></div></div></div><p>For every incoming <a id="id224" class="indexterm"/>request, Laravel has to load many different classes and this can slow down your application, particularly if you are not using a PHP accelerator such as <span class="strong"><strong>APC</strong></span>, <span class="strong"><strong>eAccelerator</strong></span>, or <span class="strong"><strong>XCache</strong></span>. In order to reduce disk I/O and shave off precious milliseconds from each request, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan optimize</strong></span>
</pre></div><p>This will trim and merge many common classes into one file located inside <code class="literal">storage/framework/compiled.php</code>. The <code class="literal">optimize</code> command is something you could, for example, include in a deployment script.</p><p>By default, Laravel will <a id="id225" class="indexterm"/>not compile your classes if <code class="literal">app.debug</code> is set to <code class="literal">true</code>. You can override this by adding the <code class="literal">--force</code> flag to the command but bear in mind that this will make your error messages less readable.</p></div><div class="section" title="Caching routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Caching routes</h2></div></div></div><p>Apart from caching <a id="id226" class="indexterm"/>class maps to improve the response time of your application, you can also cache the routes of your application. This is something else you can include in your deployment process. The command? Simply enter the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan route:cache</strong></span>
</pre></div><p>The advantage of caching routes is that your application will get a little faster as its routes will have been pre-compiled, instead of evaluating the URL and any matches routes on each request. However, as the routing process now refers to a cache file, any new routes added will not be parsed. You will need to re-cache them by running the <code class="literal">route:cache</code> command again. Therefore, this is not suitable during development, where routes might be changing frequently.</p></div><div class="section" title="Generators"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Generators</h2></div></div></div><p>Laravel 5 ships with <a id="id227" class="indexterm"/>various commands to generate new files of different types. Throughout the book, we've already used a couple (that is, for generating new migration files), but there are others too. If you run <code class="literal">$ php artisan list</code> under the <code class="literal">make</code> namespace, you will find the following entries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">make:command</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:console</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:controller</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:event</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:middleware</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:migration</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:model</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:provider</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">make:request</code></li></ul></div><p>These commands create a stub file in the appropriate location in your Laravel application containing boilerplate code ready for you to get started with. This saves keystrokes, creating these files from scratch. All of these commands require a name to be specified, as shown in <a id="id228" class="indexterm"/>the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:model Cat</strong></span>
</pre></div><p>This will create an Eloquent model class called <code class="literal">Cat</code> at <code class="literal">app/Cat.php</code>, as well as a corresponding migration to create a <code class="literal">cats</code> table. If you do not need to create a migration when making a model (for example, if the table already exists), then you can pass the <code class="literal">--no-migration</code> option as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:model Cat --no-migration</strong></span>
</pre></div><p>A new model class will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;
use Illuminate\Database\Eloquent\Model;
class Cat extends Model {
  //
}</pre></div><p>From here, you can define your own properties and methods.</p><p>The other commands may have options. The best way to check is to append <code class="literal">--help</code> after the command name, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:command --help</strong></span>
</pre></div><p>You will see that this command has <code class="literal">--handler</code> and <code class="literal">--queued</code> options to modify the class stub that is created.</p></div></div>
<div class="section" title="Rolling out your own Artisan commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Rolling out your own Artisan commands</h1></div></div></div><p>At this stage you might be thinking about writing your own bespoke commands. As you will see, this is surprisingly easy to do with Artisan. If you have used Symfony's Console component, you will be pleased to know that an Artisan command is simply an extension of it with a slightly more <a id="id229" class="indexterm"/>expressive syntax. This means the various helpers will prompt for input, show a progress bar, or format a table, are all available from within Artisan.</p><p>The command that we are going to write depends on the application we built in <a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>. It will allow you to export all cat records present in the database as a CSV with or without a header line. If no output file is specified, the command will simply dump all records onto the screen in a formatted table.</p><div class="section" title="Creating the command"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Creating the command</h2></div></div></div><p>There are only <a id="id230" class="indexterm"/>two required steps to create a command. Firstly, you need to create the command itself, and then you need to register it manually.</p><p>We can make use of the following command to create a console command we have seen previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:console ExportCatsCommand</strong></span>
</pre></div><p>This will generate a class inside <code class="literal">app/Console/Commands</code>. We will then need to register this command with the console kernel, located at <code class="literal">app/Console/Kernel.php</code>:</p><div class="informalexample"><pre class="programlisting">protected $commands = ['<span class="strong"><strong>App\Console\Commands\ExportCatsCommand</strong></span>',];</pre></div><p>If you now run <code class="literal">php artisan</code>, you should see a new command called <code class="literal">command:name</code>. This command does not do anything yet. However, before we start writing the functionality, let's briefly look at how it works internally.</p></div><div class="section" title="The anatomy of a command"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>The anatomy of a command</h2></div></div></div><p>Inside the newly <a id="id231" class="indexterm"/>created command class, you will find some code that has been generated for you. We will walk through the different properties and methods and see what their purpose is.</p><p>The first two properties are the name and description of the command. Nothing exciting here, this is only the information that will be shown in the command line when you run Artisan. The colon is used to namespace the commands, as shown here:</p><div class="informalexample"><pre class="programlisting">protected $name = 'export:cats';

protected $description = 'Export all cats';</pre></div><p>Then you will find the <code class="literal">fire</code> method. This is the method that gets called when you run a particular command. From there, you can retrieve the arguments and options passed to the command, or run other methods.</p><div class="informalexample"><pre class="programlisting">public function fire()</pre></div><p>Lastly, there are two methods that are responsible for defining the list of arguments or options that are passed to the command:</p><div class="informalexample"><pre class="programlisting">protected function getArguments() { /* Array of arguments */ }
protected function getOptions() { /* Array of options */ }</pre></div><p>Each argument or option can have a name, a description, and a default value that can be mandatory or optional. Additionally, options can have a shortcut.</p><p>To understand the difference between arguments and options, consider the following command, where options are prefixed with two dashes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ command --option_one=value --option_two -v=1 argument_one argument_two</strong></span>
</pre></div><p>In this example, <code class="literal">option_two</code> does not have a value; it is only used as a flag. The <code class="literal">-v</code> flag only has one dash since it is a shortcut. In your console commands, you'll need to verify any option and argument <a id="id232" class="indexterm"/>values the user provides (for example, if you're expecting a number, to ensure the value passed is actually a numerical value).</p><p>Arguments can be retrieved with <code class="literal">$this-&gt;argument($arg)</code>, and options—you guessed it—with <code class="literal">$this-&gt;option($opt)</code>. If these methods do not receive any parameters, they simply return the full list of parameters. You refer to arguments and options via their names, that is, <code class="literal">$this-&gt;argument('argument_name');</code>.</p></div><div class="section" title="Writing the command"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Writing the command</h2></div></div></div><p>We are going to <a id="id233" class="indexterm"/>start by writing a method that retrieves all cats from the database and returns them as an array:</p><div class="informalexample"><pre class="programlisting">protected function getCatsData() {
  $cats = App\Cat::with('breed')-&gt;get();
  foreach ($cats as $cat) {
    $output[] = [
      $cat-&gt;name,
      $cat-&gt;date_of_birth,
      $cat-&gt;breed-&gt;name,
    ];
  }
  return $output;
}</pre></div><p>There should not be anything new here. We could have used the <code class="literal">toArray()</code> method, which turns an Eloquent collection into an array, but we would have had to flatten the array and exclude certain fields.</p><p>Then we need to define what arguments and options our command expects:</p><div class="informalexample"><pre class="programlisting">protected function getArguments() {
  return [
    ['file', InputArgument::OPTIONAL, 'The output file', null],
  ];
}</pre></div><p>To specify additional arguments, just add an additional element to the array with the same parameters:</p><div class="informalexample"><pre class="programlisting">return [
  ['arg_one', InputArgument::OPTIONAL, 'Argument 1', null],
  ['arg_two', InputArgument::OPTIONAL, 'Argument 2', null],
];
</pre></div><p>The options are defined in a similar way:</p><div class="informalexample"><pre class="programlisting">protected function getOptions() {
  return [
    ['headers', 'h', InputOption::VALUE_NONE, 'Display headers?',
    null],
  ];
}
</pre></div><p>The last parameter is the <a id="id234" class="indexterm"/>default value that the argument and option should have if it is not specified. In both the cases, we want it to be <code class="literal">null</code>.</p><p>Lastly, we write the logic for the <code class="literal">fire</code> method:</p><div class="informalexample"><pre class="programlisting">public function fire() {
  $output_path = $this-&gt;argument('file');

  $headers = ['Name', 'Date of Birth', 'Breed'];
  $rows = $this-&gt;getCatsData();

  if ($output_path) {
    $handle = fopen($output_path, 'w');
      if ($this-&gt;option('headers')) {
        fputcsv($handle, $headers);
      }
      foreach ($rows as $row) {
        fputcsv($handle, $row);
      }
      fclose($handle);

  } else {
        $table = $this-&gt;getHelperSet()-&gt;get('table');
        $table-&gt;setHeaders($headers)-&gt;setRows($rows);
        $table-&gt;render($this-&gt;getOutput());
    }
}</pre></div><p>While the bulk of this method is relatively straightforward, there are a few novelties. The first one is the use of the <code class="literal">$this-&gt;info()</code> method, which writes an informative message to the output. If you need to show an error message in a different color, you can use the <code class="literal">$this-&gt;error()</code> method.</p><p>Further down in the code, you will see some functions that are used to generate a table. As we mentioned <a id="id235" class="indexterm"/>previously, an Artisan command extends the Symfony console component and, therefore, inherits all of its helpers. These can be accessed with <code class="literal">$this-&gt;getHelperSet()</code>. Then it is only a matter of passing arrays for the header and rows of the table, and calling the <code class="literal">render</code> method.</p><p>To see the output of our command, we will run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan export:cats</strong></span>
<span class="strong"><strong>$ php artisan export:cats --headers file.csv</strong></span>
</pre></div></div></div>
<div class="section" title="Scheduling commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Scheduling commands</h1></div></div></div><p>Traditionally, if you <a id="id236" class="indexterm"/>wanted a command to run periodically (hourly, daily, weekly, and so on), then you would have to set up a Cron job in Linux-based environments, or a scheduled task in Windows environments. However, this comes <a id="id237" class="indexterm"/>with drawbacks. It requires the user to have server access and familiarity with creating such schedules. Also, in cloud-based environments, the application may not be hosted on a single machine, or the user might not have the privileges to create Cron jobs. The creators of Laravel saw this as something that could be improved, and have come up with an expressive way of scheduling Artisan tasks.</p><p>Your schedule is defined in <code class="literal">app/Console/Kernel.php</code>, and with your schedule being defined in this file, it has the added advantage of being present in source control.</p><p>If you open the Kernel class file, you will see a method named <code class="literal">schedule</code>. Laravel ships with one by default that serves as an example:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('inspire')-&gt;hourly();</pre></div><p>If you've set up a Cron job in the past, you will see that this is instantly more readable than the crontab equivalent:</p><div class="informalexample"><pre class="programlisting">0 * * * * /path/to/artisan inspire</pre></div><p>Specifying the task in code also means we can easily change the console command to be run without having to update the crontab entry.</p><p>By default, scheduled commands will not run. To do so, you need a single Cron job that runs the scheduler each and every minute:</p><div class="informalexample"><pre class="programlisting">* * * * * php /path/to/artisan schedule:run 1&gt;&gt; /dev/null 2&gt;&amp;1</pre></div><p>When the scheduler is run, it will check for any jobs whose schedules match and then runs them. If no schedules match, then no commands are run in that pass.</p><p>You are free to schedule as many commands as you wish, and there are various methods to schedule them that are expressive and descriptive:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;everyFiveMinutes();
$schedule-&gt;command('bar')-&gt;everyTenMinutes();
$schedule-&gt;command('baz')-&gt;everyThirtyMinutes();
$schedule-&gt;command('qux')-&gt;daily();</pre></div><p>You can also specify a <a id="id238" class="indexterm"/>time for a scheduled command to run:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;dailyAt('21:00');</pre></div><p>Alternatively, you can <a id="id239" class="indexterm"/>create less frequent scheduled commands:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;weekly();
$schedule-&gt;command('bar')-&gt;weeklyOn(1, '21:00');</pre></div><p>The first parameter in the second example is the day, with <code class="literal">0</code> representing Sunday, and <code class="literal">1</code> through <code class="literal">6</code> representing Monday through Saturday, and the second parameter is the time, again specified in 24-hour format. You can also explicitly specify the day on which to run a scheduled command:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;mondays();
$schedule-&gt;command('foo')-&gt;tuesdays();
$schedule-&gt;command('foo')-&gt;wednesdays();
// And so on
$schedule-&gt;command('foo')-&gt;weekdays();</pre></div><p>If you have a potentially long-running command, then you can prevent it from overlapping:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$schedule-&gt;command('foo')-&gt;everyFiveMinutes() -&gt;withoutOverlapping();</strong></span>
</pre></div><p>Along with the schedule, you can also specify the environment under which a scheduled command should run, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$schedule-&gt;command('foo')-&gt;weekly()-&gt;environments('production');</strong></span>
</pre></div><p>You could use this to run commands in a production environment, for example, archiving data or running a report periodically.</p><p>By default, scheduled commands won't execute if the maintenance mode is enabled. This behavior can be easily overridden:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;weekly()-&gt;evenInMaintenanceMode();</pre></div><div class="section" title="Viewing the output of scheduled commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Viewing the output of scheduled commands</h2></div></div></div><p>For some <a id="id240" class="indexterm"/>scheduled commands, you probably want to view the output somehow, whether that is via e-mail, logged to a file on disk, or sending a callback to a pre-defined URL. All of these scenarios are possible in Laravel.</p><p>To send the output of a job via e-mail by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$schedule-&gt;command('foo')-&gt;weekly()
         -&gt;emailOutputTo('someone@example.com');
</strong></span>
</pre></div><p>If you wish to write the output of a job to a file on disk, that is easy enough too:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$schedule-&gt;command('foo')-&gt;weekly()-&gt;sendOutputTo($filepath);</strong></span>
</pre></div><p>You can also ping a URL after a job is run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$schedule-&gt;command('foo')-&gt;weekly()-&gt;thenPing($url);</strong></span>
</pre></div><p>This will execute a <a id="id241" class="indexterm"/>
<code class="literal">GET</code> request to the specified URL, at which point you could send a message to your favorite chat client to notify you that the command has run.</p><p>Finally, you can chain the preceding command to send multiple notifications:</p><div class="informalexample"><pre class="programlisting">$schedule-&gt;command('foo')-&gt;weekly()
         -&gt;sendOutputTo($filepath)
         -&gt;emailOutputTo('someone@example.com');
</pre></div><p>However, note that you have to send the output to a file before it can be e-mailed if you wish to do both.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, you have learned the different ways in which Artisan can assist you in the development, debugging, and deployment process. We have also seen how easy it is to build a custom Artisan command and adapt it to your own needs.</p><p>If you are relatively new to the command line, you will have had a glimpse into the power of command-line utilities. If, on the other hand, you are a seasoned user of the command line and you have written scripts with other programming languages, you can surely appreciate the simplicity and expressiveness of Artisan.</p><p>In the next chapter, we will take a look at the features Laravel offers us to secure our application, as well as authenticating and authorizing users.</p></div></body></html>