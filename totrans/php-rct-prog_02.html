<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0;Reactive Programming with RxPHP"><div class="book" id="MSDG2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Reactive Programming with RxPHP</h1></div></div></div><p class="calibre8">In this chapter, we're going to have a better look at how we can use PHP's reactive extension library RxPHP. We'll mostly build on what we saw in the previous chapter, but going into greater detail.</p><p class="calibre8">In particular, we'll go through the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Various components of RxPHP that we'll use in this and all further chapters.</li><li class="listitem">We'll quickly have a look at how to read and understand the Rx documentation. In particular, we'll have a look at marble diagrams that explain the functionality of Rx operators.</li><li class="listitem">List a few basic operators that we'll use throughout the entire book and explain their functionality.</li><li class="listitem">Write custom operator that decodes JSON strings into their appropriate array representations while properly handling errors.</li><li class="listitem">Implement a simple script that downloads an HTML page via cURL. Then compare the same approach when utilizing RxPHP.</li><li class="listitem">How to write a custom Observable for our cURL example.</li><li class="listitem">We'll dig into RxPHP's source code and see what happens when we use built-in Observables and operators.</li></ul></div><p class="calibre8">Before we look into each part of RxPHP separately, we'll quickly mention some very common terms that we'll use when talking about various aspects of Reactive Extensions.</p></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Reactive Programming with RxPHP">
<div class="book" title="Basic principles of Reactive Extensions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec16" class="calibre1"/>Basic principles of Reactive Extensions</h1></div></div></div><p class="calibre8">Let's have a look at a very simple example of RxPHP, similar to what we did in the previous chapter, and use it to demonstrate some of the basic principles behind Reactive Extensions.</p><p class="calibre8">We won't bother with defining an observer right now and will focus only on Observables and operators:</p><pre class="programlisting">// rxphp_basics_01.php 
use Rx\Observable; 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
 
Observable::fromArray($fruits) // Observable 
    -&gt;map(function($value) { // operator 
        return strlen($value); 
    }) 
    -&gt;filter(function($len) { // operator 
        return $len &gt; 5; 
    }) 
    -&gt;subscribe($observer); // observer 
</pre><p class="calibre8">In this example, we have one Observable, two operators and one observer.</p><p class="calibre8">An Observable can be chained with operators. In this example, the operators are <code class="literal">map()</code> and <code class="literal">filter()</code>.</p><p class="calibre8">Observables have the <code class="literal">subscribe()</code> method that is used by observers to start receiving values at the end of the chain.</p><p class="calibre8">We can represent this chain by the following diagram:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Basic principles of Reactive Extensions" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Each arrow shows the direction of propagation of items and notifications</p><p class="calibre8">We should probably explain the difference between using Observables and just iterating the array.</p><p class="calibre8">Observables are like a push model, where a value is pushed down the operator chain when it's ready. This is very important because it's the Observable that decides when it should emit the next value. The internal logic of Observables can do whatever it needs to (for example, it can run some asynchronous task) and still remain completely hidden.</p><p class="calibre8">A similar concept to Observables are Promises. However, while a Promise represents a single value that will exist in the future, an Observable represents a stream of values.</p><p class="calibre8">On the other hand, iterating the array is like a pull model. We'd be pulling one item after another. The important consequence is that we'd have to have the array prepared beforehand (that's before we start iterating it).</p><p class="calibre8">Another important difference is that Observables behave like a data stream (or data flow). We talked about streams in <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">Chapter 1</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>. In practice, this means that an Observable knows when it has emitted all its items, or when an error has occurred and is able to send proper notification down the chain.</p><p class="calibre8">For this reason, Observables can call three different methods on their observers (we'll see how this is implemented later in this chapter when we write a custom operator and a custom Observable):</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">onNext</code>: This method is called when the next item is ready to be emitted. We typically say that "an Observable emits an item".</li><li class="listitem"><code class="literal">onError</code>: Notification called when an error has occurred. This could be any type of error represented by an instance of the <code class="literal">Exception</code> class.</li><li class="listitem"><code class="literal">onComplete</code>: Notification called when there're no more items to be emitted.</li></ul></div><p class="calibre8">Each Observable can emit zero or more items.</p><p class="calibre8">Each Observable can send one error, or one complete notification; but never both.</p><p class="calibre8">This is why the <code class="literal">CallbackObserver</code> class we used in <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">Chapter 1</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>, takes three callables as arguments. These callables are called when the observer receives a next item, on error notification or on complete notification, respectively. All three callables are optional parameters and we can decide to ignore any of them.</p><p class="calibre8">For example, we can make an observer like the following:</p><pre class="programlisting">use Rx\Observer\Callback\Observer; 
 
$observer = new CallbackObserver( 
    function($value) { 
        echo "Next: $value\n"; 
    }, 
    function(Exception $err) { 
        $msg = $err-&gt;getMessage(); 
        echo "Error: $msg\n"; 
    }, 
    function() { 
        echo "Complete\n"; 
    } 
); 
</pre><p class="calibre8">This observer defines all three callables. We can test it on the Observable we defined above and have a look at its output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_basics_01.php</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 9</strong></span>
<span class="strong"><strong class="calibre17">Complete</strong></span>
</pre><p class="calibre8">We can see that only three values passed the <code class="literal">filter()</code> operator, followed by a proper complete notification at the end.</p><p class="calibre8">In RxPHP, every operator that takes a callable as an argument wraps its call internally with <code class="literal">try…catch</code> block. If the callable throws <code class="literal">Exception</code>, then this <code class="literal">Exception</code> is sent as <code class="literal">onError</code> notification. Consider the following example:</p><pre class="programlisting">// rxphp_basics_02.php 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
Observable::fromArray($fruits) 
    -&gt;map(function($value) { 
        if ($value[0] == 'o') { 
            throw new Exception("It's broken."); 
        } 
        return strlen($value); 
    }) 
    -&gt;filter(function($len) { 
        return $len &gt; 5; 
    }) 
    -&gt;subscribe($observer); 
</pre><p class="calibre8">With the same observer that we defined previously, this example will have the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_basics_02.php</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Error: It's broken.</strong></span>
</pre><p class="calibre8">It's important to see that, when an error occurred, no more items were emitted, there's also no complete notification. This is because, when the observer received an error, it automatically unsubscribed.</p><p class="calibre8">We'll talk more about the process behind subscribing and unsubscribing in <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">Chapter 3</a>, <span class="strong"><em class="calibre18">Writing a Reddit Reader with RxPHP</em></span>, and in <a class="calibre1" title="Chapter 10. Using Advanced Operators and Techniques in RxPHP" href="part0070_split_000.html#22O7C1-bd355a22cf10407cb10df27e65585b8d">Chapter 10</a>, <span class="strong"><em class="calibre18">Using Advanced Operators and Techniques in RxPHP</em></span>.</p><p class="calibre8">In <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">Chapter 8</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>, we'll look more in-depth into what happens inside observers when they receive an error or complete notification.</p><p class="calibre8">One last thing before we move on. We said that Observables represent data streams. The great advantage of this is that we can easily combine or split streams, similar to what we saw in <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">Chapter 1</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>, when talking about the <code class="literal">gulp</code> build tool.</p><p class="calibre8">Let's have a look at a slightly more advanced example of merging two Observables:</p><pre class="programlisting">// rxphp_basics_03.php 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
$vegetables = ['potato', 'carrot']; 
 
Observable::fromArray($fruits) 
    -&gt;map(function($value) { 
        return strlen($value); 
    }) 
    -&gt;filter(function($len) { 
        return $len &gt; 5; 
    }) 
    -&gt;merge(Observable::fromArray($vegetables)) 
    -&gt;subscribe($observer); 
</pre><p class="calibre8">We used the <code class="literal">merge()</code> operator to combine the existing Observable with another Observable. Notice that we can add the operator anywhere we want. Since we added it after the <code class="literal">filter()</code> operator and before the <code class="literal">subscribe()</code> call, the items from the second Observable are going to be emitted right into the observer and will skip the preceding operator chain.</p><p class="calibre8">We can represent this chain by the following diagram:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Basic principles of Reactive Extensions" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">The output for this example looks like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_basics_03.php</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 9</strong></span>
<span class="strong"><strong class="calibre17">Next: potato</strong></span>
<span class="strong"><strong class="calibre17">Next: carrot</strong></span>
<span class="strong"><strong class="calibre17">Complete</strong></span>
</pre><p class="calibre8">These principles apply to all Rx implementations. Now, we should have a basic idea of what working with Observables, observers and operators in Rx looks like and we can talk more about each of them separately.</p></div></div>
<div class="book" title="Naming conventions in Reactive Extensions" id="NQU21-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Naming conventions in Reactive Extensions</h1></div></div></div><p class="calibre8">When talking about Observables, we use terms such as <span class="strong"><strong class="calibre17">emit/send value/item</strong></span>. Commonly, we say that <span class="strong"><strong class="calibre17">an Observable emits an item</strong></span>, but we understand the same from <span class="strong"><strong class="calibre17">an Observable sends a value</strong></span> as well.</p><p class="calibre8">By <span class="strong"><strong class="calibre17">emit/send</strong></span> we mean that an Observable is calling the <code class="literal">onNext</code> method on an observer.</p><p class="calibre8">When talking about Observables, we use terms such as <span class="strong"><strong class="calibre17">send error/complete notification/signal</strong></span>. We also often mention that <span class="strong"><strong class="calibre17">an Observable completes</strong></span>, which means that an Observable has sent a complete notification.</p><p class="calibre8">By <span class="strong"><strong class="calibre17">notification/signal</strong></span> we mean that an Observable is calling the <code class="literal">onError</code> or <code class="literal">onComplete</code> method on an observer.</p><p class="calibre8">In the preceding paragraph, we worked with a simple RxPHP demo that had one Observable, two operators and one observer.</p><p class="calibre8">This structure formed an <span class="strong"><strong class="calibre17">operator/Observable chain</strong></span>. We'll understand the same thing from both of the terms <span class="strong"><strong class="calibre17">operator chain</strong></span> and <span class="strong"><strong class="calibre17">Observable chain</strong></span> (sometimes also referred to as a <span class="strong"><strong class="calibre17">chain of Observable operators</strong></span>). This is because, from our perspective, we're chaining operators; but under the hood, each operator returns another instance of the <code class="literal">Observable</code> class, so, in fact, we're chaining Observables. In practice, this doesn't matter, so we'll just remember that these have the same meaning.</p><p class="calibre8">When talking about Observable chains, we sometimes use the term <span class="strong"><strong class="calibre17">source Observable</strong></span>. This is the source of items in the chain. In other words, it's the first Observable in the chain. In the preceding example, the source Observable was <code class="literal">Observable::fromArray($fruits)</code>.</p><p class="calibre8">When talking about operators, we use the term source Observable to also describe the Observable directly preceding this particular operator (because it's the source of items for this operator).</p><p class="calibre8">Sometimes instead of the <code class="literal">onNext</code>, <code class="literal">onError</code> and <code class="literal">onComplete</code> terms and method names, you'll encounter just <code class="literal">next</code>, <code class="literal">error</code> and <code class="literal">complete</code>. This comes from RxJS 5, which follows the ES7 Observable specification (<a class="calibre1" href="https://github.com/tc39/proposal-observable">
https://github.com/tc39/proposal-observable
</a>), but their meaning is exactly the same. Most Rx implementations use the names 
<code class="literal">onNext</code>, <code class="literal">onError</code> and <code class="literal">onComplete</code>.</p><p class="calibre8">All these terms are used in various literature and articles regarding Rx, so we'll tolerate all of them.</p></div>

<div class="book" title="Components of RxPHP"><div class="book" id="OPEK2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Components of RxPHP</h1></div></div></div><p class="calibre8">Since this chapter is going to be mostly about Observables, observers and operators, we're going to start with them.</p><p class="calibre8">We've already seen a sneak peak in this chapter, and now we'll go into more detail.</p></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Observables"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch02lvl2sec13" class="calibre1"/>Observables</h2></div></div></div><p class="calibre8">Observables emit items. In other words, Observables are sources of values. Observers can subscribe to Observables in order to be notified when the next item is ready, all items have been emitted, or an error has occurred.</p><p class="calibre8">The main difference between an Observable (in the sense of reactive programming) and the observer pattern is that an Observable can tell you when all of the data has been emitted and when an error occurs. All three types of events are consumed by observers.</p><p class="calibre8">RxPHP comes with several basic types of Observables for general usage. Here are a few that are easy to use:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">ArrayObservable</code>: This creates an Observable from an array and emits all values right after the first observer subscribes.</li><li class="listitem"><code class="literal">RangeObservable</code>: This generates a sequence of numbers from a predefined range.</li><li class="listitem"><code class="literal">IteratorObservable</code>: This iterates and emits each item in the iterable. This can be any array wrapped as Iterator. Consider the following example, where we iterate an array instead of using <code class="literal">ArrayObservable</code>:<pre class="programlisting">        $fruits = ['apple', 'banana', 'orange', 'raspberry']; 
        new IteratorObservable(new ArrayIterator($fruits)); 
</pre><p class="calibre23">Note that this also includes generators. Consider another example with an anonymous function and <code class="literal">yield</code> keyword.</p><pre class="programlisting">        $iterator = function() use ($fruits) { 
            foreach ($fruits as $fruit) { 
                yield $fruit; 
            } 
        }; 
        new IteratorObservable($iterator()) 
            -&gt;subscribe(new DebugSubject()); 
</pre></li></ul></div><p class="calibre8">Calling the <code class="literal">$iterator()</code>function returns an instance of a <code class="literal">Generator</code> class that implements the Iterator interface. However, these basic Observables are good mostly for demonstration purposes and are not very practical in real-world usage. In a PHP environment, we can't create Observables from mouse events as in JavaScript and RxJS, so we'll have to learn how to write custom Observables very soon in this chapter in order to create some real-world examples. In <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">Chapter 3</a>, <span class="strong"><em class="calibre18">Writing a Reddit Reader with RxPHP</em></span>, we'll learn about the <code class="literal">Observable::create()</code> static method to create Observables with some basic custom logic. But, more on that later.</p><p class="calibre8">Observables can be divided into two groups based on when they start emitting values:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Hot</strong></span>: In this group, values are emitted even when there are no observers subscribed. This is, for example, <code class="literal">Rx.Observable.fromEvent</code> from RxJS that we used in <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">
Chapter 1
</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>. This creates an Observable from any JavaScript event. Values are emitted immediately, so when you subscribe to this Observable some time later, you receive only new values and no previously emitted values.</li><li class="listitem"><span class="strong"><strong class="calibre17">Cold</strong></span>: In this group, values are emitted when at least one observer has been subscribed. This is, for example, RxPHP's <code class="literal">ArrayObservable</code>. It creates an Observable and, every time we subscribe, we receive all values passed as an input to the <code class="literal">fromArray()</code> method.</li></ul></div><p class="calibre8">All built-in Observables in RxPHP can be instantiated easily by calling static methods from the <code class="literal">Rx\Observable</code> namespace. The following list represents the three Observables mentioned above:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="literal">RxObservable::fromArray()</code> method returns <code class="literal">Rx\Observable\ArrayObservable</code></li><li class="listitem">The <code class="literal">RxObservable::range()</code> method returns <code class="literal">Rx\Observable\RangeObservable</code></li><li class="listitem">The <code class="literal">RxObservable::fromIterator()</code> method returns <code class="literal">Rx\Observable\IteratorObservable</code></li></ul></div><p class="calibre8">Don't be surprised that static method names don't necessarily match returned class names. Also, it's usually easier to use static calls than to instantiate Observables directly.</p></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Observers"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch02lvl2sec14" class="calibre1"/>Observers</h2></div></div></div><p class="calibre8">Observers are consumers of Observables. In other words, observers react to Observables. We've already seen the <code class="literal">CallbackObserver</code> class, which takes three optional arguments representing callables for each type of signal.</p><p class="calibre8">Consider a similar example that we used at the end of <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">
Chapter 1
</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>, where we defined our observer:</p><pre class="programlisting">$observer = new Rx\Observer\CallbackObserver(function($value) { 
    printf("%s\n", $value); 
}, function() { 
    print("onError\n"); 
}, function() { 
    print("onCompleted\n"); 
}); 
</pre><p class="calibre8">The <code class="literal">CallbackObserver</code> class lets us create a custom observer without necessarily extending the base class. Its constructor takes three optional arguments:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">onNext</code>: This callable is called when a new item from the source Observable is emitted. This is the most common callback we'll use.</li><li class="listitem"><code class="literal">onComplete</code>: This callable is called when there are no items left and the Observable is done emitting items. Some Observables produce an infinite number of items and this callback is never called.</li><li class="listitem"><code class="literal">onError</code>: This callable is called when an error has occurred somewhere in the chain.</li></ul></div><p class="calibre8">We can write the same example in a more reusable form to quickly test what's going on inside Observable chains:</p><pre class="programlisting">// rxphp_03.php 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
 
class PrintObserver extends Rx\Observer\AbstractObserver { 
    protected function completed() { 
        print("Completed\n"); 
    } 
    protected function next($item) { 
        printf("Next: %s\n", $item); 
    } 
    protected function error(Exception $err) { 
        $msg = $err-&gt;getMessage(); 
        printf("Error: %s\n", $msg); 
    } 
} 
 
$source = Rx\Observable::fromArray($fruits); 
$source-&gt;subscribe(new PrintObserver()); 
</pre><p class="calibre8">When extending <code class="literal">AbstractObserver</code>, the methods we need to implement are <code class="literal">completed()</code>, <code class="literal">next()</code>, and <code class="literal">error()</code>, with the same functionality as described previously.</p><p class="calibre8">We're using the <code class="literal">subscribe()</code> method to subscribe an observer to an Observable.</p><p class="calibre8">There's also the <code class="literal">subscribeCallback()</code> method that takes just three callables as arguments. Since RxPHP 2, the <code class="literal">subscribeCallback()</code> method is deprecated and its functionality has been merged with <code class="literal">subscribe()</code>.</p><p class="calibre8">This means that, in RxPHP 2, we can also write the following code:</p><pre class="programlisting">$source-&gt;subscribe(function($item) { 
    printf("Next: %sn", $item); 
}); 
</pre><p class="calibre8">We made a single callable instead of subscribing with an observer. This handles only <code class="literal">onNext</code> signals.</p></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Singles"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch02lvl2sec15" class="calibre1"/>Singles</h2></div></div></div><p class="calibre8">Singles are like Observables; the only difference is that they always emit just one value. In RxPHP, we don't distinguish any difference between Observables and Singles, so we can use the <code class="literal">Observable::just()</code> static method:</p><pre class="programlisting">// single_01.php/ 
require __DIR__ . '/PrintObserver.php'; 
 
RxObservable::just(42) 
    -&gt;subscribe(new PrintObserver()); 
</pre><p class="calibre8">This creates a new Observable that calls <code class="literal">onNext()</code> with the value <code class="literal">42</code>, and immediately after that <code class="literal">onComplete()</code>. The output for this very simple example is the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php single_01.php</strong></span>
<span class="strong"><strong class="calibre17">Next: 42</strong></span>
<span class="strong"><strong class="calibre17">Completed</strong></span>
</pre><p class="calibre8">Similar to the preceding explanation, calling <code class="literal">RxObservable::just()</code> static method returns an instance of <code class="literal">Rx\Observable\ReturnObservable</code>.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">The term "Single" was used mostly in RxJS 4. Since RxPHP was originally ported from RxJS 4, and later also took things from RxJS 5, you might encounter this term sometimes. If you're familiar only with RxJS 5, then you've probably never heard of it. Nonetheless, we'll always refer to all sources of values as Observables, even when they emit just a single, or no value at all.</p></div></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Subject"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch02lvl2sec16" class="calibre1"/>Subject</h2></div></div></div><p class="calibre8">The <code class="literal">Subject</code> is a class that acts as an Observable and observer at the same time. This means that it can subscribe to an Observable just like an observer, and also emit values like an Observable does. Eventually, it can also emit its own values independently of its source Observable.</p><p class="calibre8">In order to see how the <code class="literal">Subject</code> class can be used in different situations, we'll work through three examples based on the same example we used at the beginning of this chapter.</p><p class="calibre8">We can use a <code class="literal">Subject</code> class instead of an Observable. However, we need to emit items manually by calling <code class="literal">onNext()</code> on the <code class="literal">Subject</code> instance:</p><pre class="programlisting">// subject_01.php 
use Rx\Subject\Subject; 
 
$subject = new Subject(); 
$subject 
    -&gt;map(function($value) { 
        return strlen($value); 
    }) 
    -&gt;filter(function($len) { 
        return $len &gt; 5; 
    }) 
    -&gt;subscribe(new PrintObserver()); 
 
$subject-&gt;onNext('apple'); 
$subject-&gt;onNext('banana'); 
$subject-&gt;onNext('orange'); 
$subject-&gt;onNext('raspberry'); 
</pre><p class="calibre8">This code produces the same output as the original example with Observable:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php subject_01.php</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 9</strong></span>
</pre><p class="calibre8">Another use case could be using <code class="literal">Subject</code> to subscribe to an Observable. We'll reuse the <code class="literal">PrintObserver</code> class we made a moment ago to print all of the items and notifications that went through the <code class="literal">Subject</code> instance:</p><pre class="programlisting">// subject_02.php 
use Rx\Subject\Subject; 
use Rx\Observable; 
 
$subject = new Subject(); 
$subject-&gt;subscribe(new PrintObserver()); 
 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
Observable::fromArray($fruits) 
    -&gt;map(function($value) { 
        return strlen($value); 
    }) 
    -&gt;filter(function($len) { 
        return $len &gt; 5; 
    }) 
    -&gt;subscribe($subject); 
</pre><p class="calibre8">Notice that we subscribed <code class="literal">PrintObserver</code> to the <code class="literal">Subject</code> and then subscribed the <code class="literal">Subject</code> at the end of the operator chain. As we can see, by default the <code class="literal">Subject</code> class just passes through both items and notifications. The output is the same as in the previous example.</p><p class="calibre8">The final situation we want to demonstrate is using an instance of Subject in the middle of an operator chain:</p><pre class="programlisting">// subject_03.php  
use Rx\Subject\Subject; 
use Rx\Observable; 
 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
 
$subject = new Subject(); 
$subject 
    -&gt;filter(function($len) { 
        return $len &gt; 5; 
    }) 
    -&gt;subscribe(new PrintObserver()); 
 
Observable::fromArray($fruits) 
    -&gt;map(function($value) { 
        return strlen($value); 
    }) 
    -&gt;subscribe($subject); 
</pre><p class="calibre8">Yet again, the console output is the same.</p><p class="calibre8">Later in this chapter, we'll write the <code class="literal">DebugSubject</code> class, that we'll use many times throughout this book, to quickly see what's going on in our Observable chains.</p></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Disposable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_5"><a id="ch02lvl2sec17" class="calibre1"/>Disposable</h2></div></div></div><p class="calibre8">All Rx implementations internally use the Dispose pattern. This design decision has two reasons:</p><div class="book"><ul class="itemizedlist"><li class="listitem">To be able to unsubscribe from an Observable</li><li class="listitem">To be able to release all data used by that Observable</li></ul></div><p class="calibre8">For example, if we had an Observable that downloads a large file from the Internet and saves it to a temporary location until it's completely downloaded, we'd like to remove the temporary file if its observer unsubscribed, or any error occurred.</p><p class="calibre8">There're already a couple of classes available out-of-the-box with RxPHP, each with a different purpose. We don't need to worry about Disposables right now. We'll have a look at how they are used inside built-in Observables and operators in the next <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">Chapter 3</a>, <span class="strong"><em class="calibre18">Writing a Reddit Reader with RxPHP</em></span>.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">You can read more about the dispose pattern on Wikipedia <a class="calibre1" href="https://en.wikipedia.org/wiki/Dispose_pattern">
https://en.wikipedia.org/wiki/Dispose_pattern
</a> or, more specifically, why it's used in reactive extensions on StackOverflow <a class="calibre1" href="http://stackoverflow.com/a/7707768/310726">
http://stackoverflow.com/a/7707768/310726
</a>.</p></div><p class="calibre8">However, it's good to know that something like releasing resources in Rx is important and we need to aware of it.</p></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Scheduler"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_6"><a id="ch02lvl2sec18" class="calibre1"/>Scheduler</h2></div></div></div><p class="calibre8">Observables and operators usually don't execute their work directly, but use an instance of the <code class="literal">Scheduler</code> class to decide how and when it should be executed.</p><p class="calibre8">In practice, a <code class="literal">Scheduler</code> receives an action as an anonymous function and schedules its execution according to its internal logic. This is particularly relevant to all Observables and operators that need to work with time. For example, all delayed or periodical emissions need to schedule via a Scheduler.</p><p class="calibre8">In languages such as JavaScript, this is relatively simple with, for example, the
 <code class="literal">setTimeout()</code> function and the event-based nature of JavaScript interpreters. However, in PHP, where all code is executed strictly sequentially, we'll have to use an event loop.</p><p class="calibre8">In most situations in RxPHP, we don't have to even worry about Schedulers because, if not set differently, all Observables and operators internally use the <code class="literal">ImmediateScheduler</code> class, which executes all actions immediately without any further logic.</p><p class="calibre8">We'll encounter Schedulers once more at the end of this chapter, when talking about event loops.</p><p class="calibre8">In <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, we'll go into much more detail about event loops in PHP. We'll also talk about the Event Loop Interopability specification (<a class="calibre1" href="https://github.com/async-interop/event-loop">https://github.com/async-interop/event-loop</a>) and how it's related to RxPHP.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">In RxPHP 2, using Schedulers has been significantly simplified and, most of the time, we don't need to worry about event loops at all, as we'll see in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>.</p></div></div></div>

<div class="book" title="Components of RxPHP">
<div class="book" title="Operators"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_7"><a id="ch02lvl2sec19" class="calibre1"/>Operators</h2></div></div></div><p class="calibre8">We've used operators already without any further explanation, but now that we know how to use Observables, observers, and Subjects, it's time to see how operators glue this all together.</p><p class="calibre8">The core principle of Rx is using various operators to modify data flow. Typically, an operator returns another Observable and therefore allows the chaining of operator calls.</p><p class="calibre8">In Rx, there are tons of operators, and in RxPHP in particular, there are about 40 already. Other implementations such as RxJS have even more. Those include all we saw in the previous chapter when talking about functional programming, such as <code class="literal">map()</code>, <code class="literal">filter()</code>, and a lot more. This also includes operators for very specific use cases, such as <code class="literal">merge()</code>, <code class="literal">buffer()</code>, or <code class="literal">retry()</code>, just to name a few.</p><p class="calibre8">The process of creating operator chains is a little more complicated under the hood than it seems. We don't need to worry about it for now because we'll talk about it again in <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">Chapter 3</a>, <span class="strong"><em class="calibre18">Writing a Reddit Reader with RxPHP</em></span>. Before we start using more advanced operators in practice, we should have a look at how each operator is described in the documentation. This is mostly because some functionality isn't obvious at first sight and, when it comes to asynchronous events, it's sometimes hard to understand what each operator does.</p><div class="book" title="Understanding the operator diagrams"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch02lvl3sec5" class="calibre1"/>Understanding the operator diagrams</h3></div></div></div><p class="calibre8">Each operator is described in the documentation using a diagram called the <span class="strong"><strong class="calibre17">marble diagram</strong></span>, where each marble represents an emitted value.</p><div class="book" title="The filter() operator"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch02lvl4sec0" class="calibre1"/>The filter() operator</h4></div></div></div><p class="calibre8">First, we'll have a look at how the <code class="literal">filter()</code> operator is defined. We used the PHP function <code class="literal">array_filter()</code> in the previous chapter, so we know that it takes values and a predicate function as input. Then it evaluates each value with the predicate and, based on whether it returns true or false, it adds or skips the value in its response array. The behavior of the <code class="literal">filter()</code> operator is the same, it just works with data flows instead of arrays. This means it receives items from its source (the preceding Observable) and propagates them to its consequent observer (or chained operator).</p><p class="calibre8">Using a marble diagram, it will look like the following figure:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="The filter() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Marble diagram representing the filter() Operator from http://reactivex.io/documentation/operators/filter.html</p><p class="calibre8">Let's exaplain this diagram in more detail:</p><div class="book"><ul class="itemizedlist"><li class="listitem">At the top and bottom, we have two timelines that represent Observables. The arrow in the top right corner suggests that time goes from left to right.</li><li class="listitem">We can think of everything above the rectangle as input Observable and everything below the rectangle as output Observable. There're usually one or more input and only one output.</li><li class="listitem">Each circle (marble) represents a single value in time emitted by its respective Observable. The number inside each circle stands for its value. All values are ordered by the time they were emitted, which goes from left to right. Different colors are used to make it obvious that values at the top and bottom are the same (for example the blue "30" at the top is the same value as the bottom "30").</li><li class="listitem">The rectangle in the middle represents the transformation between the top and bottom Observables. Its functionality is usually described in words or pseudocode. In this case, we have an expression that looks like ES6 syntax, which says that it returns <code class="literal">true</code> if <code class="literal">x</code> is greater than <code class="literal">10</code>. Rewritten to PHP, it's equal to the following:</li></ul></div><pre class="programlisting">        function($x) { 
            return $x &gt; 10; 
        } 
</pre><div class="book"><ul class="itemizedlist"><li class="listitem">The bottom line, therefore, only contains circles with a value greater than <code class="literal">10</code>.</li><li class="listitem">Vertical lines on the right side of each line mark the point where these Observables complete. This means they have emitted all values and sent an <code class="literal">onComplete</code> notification. The <code class="literal">filter()</code> operator has no effect on the <code class="literal">onComplete</code> notification, so both Observables end at the same time.</li></ul></div><p class="calibre8">This was pretty simple. Marble diagrams are a very comfortable way of representing data flows without worrying about implementation details (this reminds us of declarative programming, as we defined it in the first chapter, doesn't it?).</p><p class="calibre8">In some diagrams, you can also see a cross sign on the timeline, which represents an error (an <code class="literal">onError</code> notification to be precise). We'll see further on in this chapter that we can work with <code class="literal">onComplete</code> and <code class="literal">onError</code> notifications just as with <code class="literal">onNext</code>.</p></div><div class="book" title="The debounceTime() operator"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch02lvl4sec1" class="calibre1"/>The debounceTime() operator</h4></div></div></div><p class="calibre8">Let's have a look at another diagram. This time we have a <code class="literal">debounceTime()</code> operator from RxJS 5, which we saw in the first chapter, in the <span class="strong"><em class="calibre18">Autocomplete with RxJS</em></span> example:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="The debounceTime() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Marble diagram representing the debounceTime() operator from http://reactivex.io/documentation/operators/debounce.html</p><p class="calibre8">In the rectangle in the middle, we don't have any pseudocode this time; just a single expression <code class="literal">debounceTime(20)</code>. Well, in order to figure out what it does, we need to look at the documentation, or try to analyze the diagram.</p><p class="calibre8">When the <code class="literal">debounceTime()</code> operator receives a value, it waits a certain interval before reemitting it. If any other values arrive before the interval expires, the original value is discarded and the later value is used instead; the interval is restarted as well. This can go on for an infinite number of values.</p><p class="calibre8">The diagram exactly describes the previous paragraph:</p><div class="book"><ul class="itemizedlist"><li class="listitem">First, value <span class="strong"><strong class="calibre17">a</strong></span> arrives. The transformation function waits until 20ms interval expires, and after that, the operator reemits the value further. The interval is represented by shifting the bottom values on the timeline slightly to the right. As we said previously, the horizontal lines represent values in time. When the bottom circle, labeled <span class="strong"><strong class="calibre17">a</strong></span>, is shifted to the right, it means this event happened after the top <span class="strong"><strong class="calibre17">a</strong></span> circle.</li><li class="listitem">Then, two more values arrive, both of them in a very short time. The first one is discarded, but after the second one, there's another longer time gap, so only the second value gets reemitted.</li><li class="listitem">The process with the last value <span class="strong"><strong class="calibre17">d</strong></span> is analogous to the first one.</li></ul></div><p class="calibre8">This operator is useful when we know we can ignore some events that occur quickly after one another. A prime example is using <code class="literal">debounceTime()</code> for autocomplete features when we want to start searching after a user has stopped typing a keyword.</p></div><div class="book" title="The concat operator"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch02lvl4sec2" class="calibre1"/>The concat operator</h4></div></div></div><p class="calibre8">Now we can have a look at a slightly more complicated operator, which is <code class="literal">concat()</code>. Look at the following diagram and try to guess what it does:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="The concat operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Marble diagram representing the concat() operator from http://reactivex.io/documentation/operators/concat.html</p><p class="calibre8">Let's analyze this together before looking to the documentation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">At the top, we have two Observables as inputs to the operator.</li><li class="listitem">Both Observables should emit a value at the same time, but only the value from the first Observable is passed through. The same applies for the second and third values as well.</li><li class="listitem">Then the first Observable reaches the end and sends an <code class="literal">onComplete</code> notification.</li><li class="listitem">Right after that, the operator starts emitting values from the second Observable.</li></ul></div><p class="calibre8">The <code class="literal">concat()</code> operator merges multiple Observables into one. It internally subscribes to each input Observable in order, one after another. This means that, when the first Observable completes, it subscribes to the next one. It's important to know that there's only ever one source Observable subscribed at a time (we'll work with <code class="literal">concat()</code> and a similar <code class="literal">merge()</code> operator in <a class="calibre1" title="Chapter 4. Reactive versus a Typical Event-Driven Approach" href="part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d">Chapter 4</a>, <span class="strong"><em class="calibre18">Reactive versus a typical Event-Driven Approach</em></span>).</p><p class="calibre8">In other words, the <code class="literal">concat()</code> operator concatenates multiple data streams into a single stream.</p><p class="calibre8">In the first chapter, we talked about functional programming and how most principles are the same in reactive programming. Implementing such a feature would be rather complicated because there's no built-in PHP function designed to deal with such a use case.</p><p class="calibre8">If we go back to the first chapter once more, we said that one key concept of reactive programming is to "express data flows with ease". This operator shows what that means in action.</p></div></div><div class="book" title="Other common operators"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch02lvl3sec6" class="calibre1"/>Other common operators</h3></div></div></div><p class="calibre8">These were only three operators out of more than 40 available in RxPHP. Apart from very simple ones like <code class="literal">filter()</code> and <code class="literal">map()</code>, there're also more sophisticated ones. We've seen <code class="literal">concat()</code> already, but here are a few interesting ones that we'll use in further chapters:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">buffer()</code>: This operator has multiple variants, but all of them collect received values and reemits them in groups of a predefined size. For example, we can create groups of three items as follows:<pre class="programlisting">        Rx\Observable::range(1, 4) 
            -&gt;bufferWithCount(3) 
            -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre23">Which prints the following output:</p><pre class="programlisting">        <span class="strong"><strong class="calibre17">13:58:13 [] onNext: [1, 2, 3] (array)</strong></span>
        <span class="strong"><strong class="calibre17">13:58:13 [] onNext: [4] (array)</strong></span>
        <span class="strong"><strong class="calibre17">13:58:13 onCompleted</strong></span>
</pre><div class="note" title="Note"><h3 class="title1"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">Note that the last array contains just one value because the Observable sent an <code class="literal">onComplete</code> notification.</p></div></li><li class="listitem"><code class="literal">merge()</code>: This operator merges all input Observables into a single output Observable, reemitting all values immediately (in contrast to <code class="literal">concat()</code>).</li><li class="listitem"><code class="literal">distinct()</code>: This operator reemits only those values that haven't passed this operator before.</li><li class="listitem"><code class="literal">take()</code>: This operator reemits only a set number of values that arrive to the operator first, then sends an <code class="literal">onComplete</code> notification.</li><li class="listitem"><code class="literal">retry()</code>: When source Observable sends <code class="literal">onError</code>, this operator tries to resubscribe automatically. You can also tell it to retry only a limited number of times until signaling <code class="literal">onError</code> (we'll use this operator in <a class="calibre1" title="Chapter 4. Reactive versus a Typical Event-Driven Approach" href="part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d">Chapter 4</a>, <span class="strong"><em class="calibre18">Reactive versus a Typical Event-Driven Approach</em></span>).</li><li class="listitem"><code class="literal">catchError()</code>: This operator lets us continue by subscribing to another Observable returned from its callback when an <code class="literal">onError</code> notification occurs.</li><li class="listitem"><code class="literal">toArray()</code>: This operator collects all items from its source Observable and reemits them as a single array when the source Observable completes.</li><li class="listitem"><code class="literal">timeout()</code>: This operator sends an <code class="literal">onError</code> notification if no values arrived within a certain time span.</li></ul></div><p class="calibre8">Enough theory; let's start writing our first custom class, which we'll utilize a few times throughout this book.</p></div></div></div>
<div class="book" title="Writing the DebugSubject class" id="PNV61-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Writing the DebugSubject class</h1></div></div></div><p class="calibre8">One common use case for <code class="literal">Subject</code> class is proxying all values and notifications from its source Observable.</p><p class="calibre8">In one of the preceding paragraphs, we wrote the <code class="literal">PrintObserver</code> class, which prints all values it receives. However, a more common situation is where we want to output values from an Observable while being able to chain it with another operator or observer. The <code class="literal">Subject</code> class exactly fits this use case, so we'll rewrite the preceding <code class="literal">PrintObserver</code> class and inherit <code class="literal">Subject</code> instead of <code class="literal">AbstractObserver</code>:</p><pre class="programlisting">class DebugSubject extends Rx\Subject\Subject { 
  public function __construct($identifier=null, $maxLen=64){ 
    $this-&gt;identifier = $identifier; 
    $this-&gt;maxLen = $maxLen; 
  } 
  public function onCompleted() { 
    printf("%s%s onCompleted\n", $this-&gt;getTime(), $this-&gt;id());
    parent::onCompleted(); 
  }  
  public function onNext($val) { 
    $type = is_object($val) ? get_class($val) : gettype($val); 
 
    if (is_object($val) &amp;&amp; method_exists($val, '__toString')) { 
      $str = (string)$val; 
    } elseif (is_object($val)) { 
      $str = get_class($val); 
    } elseif (is_array($val)) { 
      $str = json_encode($val); 
    } else { 
      $str = $val; 
    } 
 
    if (is_string($str) &amp;&amp; strlen($str) &gt; $this-&gt;maxLen) { 
      $str = substr($str, 0, $this-&gt;maxLen) . '...'; 
    } 
    printf("%s%s onNext: %s (%s)\n", 
        $this-&gt;getTime(), $this-&gt;id(), $str, $type); 
    parent::onNext($value); 
  } 
  public function onError(Exception $error) { 
    $msg = $error-&gt;getMessage(); 
    printf("%s%s onError (%s): %s\n", $this-&gt;getTime(),$this-&gt; 
        $this-&gt;id(), get_class($error), $msg); 
    parent::onError($error); 
  } 
  private function getTime() { 
    return date('H:i:s'); 
  } 
  private function id() { 
    return ' [' . $this-&gt;identifier . ']'; 
  } 
} 
</pre><p class="calibre8">This <code class="literal">DebugSubject</code> class prints all values, their types, and the time they were received by the <code class="literal">DebugSubject</code>. It also allows us to set a unique identifier for each <code class="literal">DebugSubject</code> instance to be able to distinguish their output. We're going to use this class a couple of times throughout this book to quickly see what's going on inside our Observable chains.</p><p class="calibre8">Then, using this class is just like using any other observer:</p><pre class="programlisting">// rxphp_04.php 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
$observer = Rx\Observable::fromArray($fruits) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">The output in the console is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_04.php</strong></span>
<span class="strong"><strong class="calibre17">17:15:21 [] onNext: apple (string)</strong></span>
<span class="strong"><strong class="calibre17">17:15:21 [] onNext: banana (string)</strong></span>
<span class="strong"><strong class="calibre17">17:15:21 [] onNext: orange (string)</strong></span>
<span class="strong"><strong class="calibre17">17:15:21 [] onNext: raspberry (string)</strong></span>
<span class="strong"><strong class="calibre17">17:15:21 [] onCompleted</strong></span>
</pre><p class="calibre8">Chaining Subjects and operators works just as with Observables:</p><pre class="programlisting">// rxphp_05.php 
$subject = new DebugSubject(1); 
$subject 
    -&gt;map(function($item) { 
        return strlen($item); 
    }) 
    -&gt;subscribe(new DebugSubject(2)); 
 
$observable = Rx\Observable::fromArray($fruits); 
$observable-&gt;subscribe($subject); 
</pre><p class="calibre8">In this example, we first created an instance of <code class="literal">DebugSubject</code>, then we chained it with the <code class="literal">map()</code> operator, which returns the lengths of each item. Finally, we subscribed another <code class="literal">DebugSubject</code> that will print only numbers because it's placed after <code class="literal">map()</code>. Then we created an Observable from an array (we've seen this static method previously), which is going to be the source emitting all items. The result is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">17:33:36 [1] onNext: apple (string)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [2] onNext: 5 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [1] onNext: banana (string)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [2] onNext: 6 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [1] onNext: orange (string)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [2] onNext: 6 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [1] onNext: raspberry (string)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [2] onNext: 9 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">17:33:36 [2] onCompleted</strong></span>
</pre><p class="calibre8">Note that the order of messages matches our assumption that the source Observable emits one value at a time, which is propagated through the entire chain.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">There's one important side effect of using Subjects as we did that isn't very obvious. Since we subscribe it to the preceding Observable, it turns it from "cold" into "hot", which might be unwanted in some use cases.</p></div><p class="calibre8">RxPHP provides a series of operators all starting with the "doOn" prefix that are intended to be placed inside the operator chain to execute side effects without subscribing to an Observable. We'll have a better look at them in <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">Chapter 5</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>.</p></div>

<div class="book" title="Writing JSONDecodeOperator"><div class="book" id="QMFO2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Writing JSONDecodeOperator</h1></div></div></div><p class="calibre8">We're going to work with calls to remote API's a few times throughout this book, so it would be very handy to have an operator that transforms JSON string responses into their PHP array representations.</p><p class="calibre8">This example looks like something that could be easily done with just the <code class="literal">map()</code> operator:</p><pre class="programlisting">// rxphp_06.php  
Rx\Observable::just('{"value":42}') 
    -&gt;map(function($value) { 
        return json_decode($value, true); 
    }) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This prints the correct result for sure, as we can see in the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_06.php</strong></span>
<span class="strong"><strong class="calibre17">16:39:50 [] onNext: {"value": 42} (array)</strong></span>
<span class="strong"><strong class="calibre17">16:39:50 [] onCompleted</strong></span>
</pre><p class="calibre8">Well, but what about malformed JSON strings? What happens if we try to decode the following:</p><pre class="programlisting">Rx\Observable::just('NA') 
    -&gt;map(function($value) { 
        return json_decode($value, true); 
    }) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">The function <code class="literal">json_decode()</code> doesn't throw an exception when trying to process an invalid JSON string; it just returns <code class="literal">null</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">15:51:06 [] onNext:  (NULL)</strong></span>
</pre><p class="calibre8">This is probably not what we want. If the JSON string is invalid, then something is wrong because this situation should never happen and we want to send an <code class="literal">onError</code> notification.</p><p class="calibre8">If we wanted to know any further information about which error occurred, we'd have to call <code class="literal">json_last_error()</code>. So, this is a perfect opportunity to write a custom operator that decodes JSON strings that, if any error occurs, will send an <code class="literal">onError</code>.</p><p class="calibre8">All operators implement the <code class="literal">OperatorInterface</code> and <code class="literal">__invoke()</code> method. This so-called "magic" method is supported from PHP 5.3+ and allows the use of objects as functions:</p><pre class="programlisting">// __invoke.php 
class InvokeExampleClass { 
    public function __invoke($x) { 
        echo strlen($x); 
    } 
} 
$obj = new InvokeExampleClass(); 
$obj('apple'); 
var_dump(is_callable($obj)); 
</pre><p class="calibre8">When class implements <code class="literal">__invoke()</code>, it's automatically considered as callable as well:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php __invoke.php</strong></span>
<span class="strong"><strong class="calibre17">int(5)</strong></span>
<span class="strong"><strong class="calibre17">bool(true)</strong></span>
</pre><p class="calibre8">Writing operators is very similar. A stub for our class will look like the following:</p><pre class="programlisting">// JSONDecodeOperator.php 
use Rx\ObservableInterface as ObservableI; 
use Rx\ObserverInterface as ObserverI; 
use Rx\SchedulerInterface as SchedulerI; 
use Rx\Operator\OperatorInterface as OperatorI; 
 
class JSONDecodeOperator implements OperatorI { 
    public function __invoke(ObservableI $observable, 
            ObserverI $observer, SchedulerI $scheduler = null) { 
        // ... 
    } 
} 
</pre><p class="calibre8">Method <code class="literal">__invoke()</code> takes three arguments and returns a Disposable object. Right now, we'll use just the first two and not worry about the <code class="literal">$scheduler</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">ObservableInterface $observable</code>: This is our input Observable that we'll subscribe to</li><li class="listitem"><code class="literal">ObserverInterface $observer</code>: This is where we'll emit all output values from this operator</li></ul></div><p class="calibre8">We'll follow almost the same principle as when writing a custom <code class="literal">Subject</code> class. We're going to use <code class="literal">CallbackObserver</code> to subscribe to the Observable and perform all of our logic:</p><pre class="programlisting">class JSONDecodeOperator implements OperatorI { 
  public function __invoke(ObservableI $observable, 
      ObserverI $observer, SchedulerI $scheduler = null) { 
 
    $obs = new CallbackObserver( 
      function ($value) use ($observer) { 
        $decoded = json_decode($value, true); 
        if (json_last_error() == JSON_ERROR_NONE) { 
          $observer-&gt;onNext($decoded); 
        } else { 
          $msg = json_last_error_msg(); 
          $e = new InvalidArgumentException($msg); 
          $observer-&gt;onError($e); 
        } 
      }, 
      function ($error) use ($observer) { 
        $observer-&gt;onError($error); 
      }, 
      function () use ($observer) { 
        $observer-&gt;onCompleted(); 
      } 
    ); 
 
    return $observable-&gt;subscribe($obs, $scheduler); 
  } 
} 
</pre><p class="calibre8">There're a few interesting things to notice:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When <code class="literal">onError</code> or <code class="literal">onComplete</code> notifications occur, we just pass them along without any further logic.</li><li class="listitem">The operator can send any signal any time it wants. Inside <code class="literal">CallbackObserver</code> class's <code class="literal">onNext</code> closure, we check whether any error occurred while decoding the input JSON string coming from the source Observable using <code class="literal">json_last_error()</code>.</li><li class="listitem">The operator has full access to the source Observable.</li><li class="listitem">The operator can emit values independently on values from the source Observable.</li></ul></div><p class="calibre8">In order to use our operator, we have to use the <code class="literal">Observable::lift()</code>, method which takes a Closure as an argument that needs to return an instance of an operator (this function is a so-called operator factory):</p><pre class="programlisting">// rxphp_07.php 
Rx\Observable::just('{"value":42}') 
    -&gt;lift(function() { 
        return new JSONDecodeOperator(); 
    }) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">Using custom operators was significantly simplified in RxPHP 2, but using the <code class="literal">lift()</code> method is universal and works in both versions of RxPHP.</p><p class="calibre8">Valid JSON string is decoded as expected:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_07.php</strong></span>
<span class="strong"><strong class="calibre17">17:58:49 [] onNext: {"value": 42} (array)</strong></span>
<span class="strong"><strong class="calibre17">17:58:49 [] onCompleted</strong></span>
</pre><p class="calibre8">On the other hand, the same invalid JSON string that we used above doesn't call <code class="literal">onNext</code>, but <code class="literal">onError</code> instead. It sends this notification with an instance of <code class="literal">InvalidArgumentException</code> class and the error message from <code class="literal">json_last_error_msg()</code>, as shown in the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">17:59:25 onError (InvalidArgumentException): Syntax error</strong></span>
</pre><p class="calibre8">As usual, we're going to reuse this class throughout this book. The next chapter is going to work with remote APIs a lot, so this operator is going to be very handy.</p></div>

<div class="book" title="Writing JSONDecodeOperator">
<div class="book" title="Simplifying propagation of notifications"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch02lvl2sec20" class="calibre1"/>Simplifying propagation of notifications</h2></div></div></div><p class="calibre8">In the <code class="literal">JSONDecodeOperator</code> class, we didn't want to modify either <code class="literal">onError</code> nor <code class="literal">onComplete</code> notifications and we just passed them along. However, there's an easier way to do this thanks to how PHP works with callables. A valid callable is also an array with two items: an object and a method name.</p><p class="calibre8">This means we can rewrite the above <code class="literal">CallbackObserver</code> instantiation as follows:</p><pre class="programlisting">$callbackObserver = new CallbackObserver( 
    function ($value) use ($observer) { 
        // ... 
    }, 
    [$observer, 'onError'], 
    [$observer, 'onCompleted'] 
); 
</pre><p class="calibre8">The functionality is exactly the same. Instead of creating an anonymous function for each notification, we can just pass the callable directly.</p></div></div>

<div class="book" title="Writing JSONDecodeOperator">
<div class="book" title="Using custom operators in RxPHP 2"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch02lvl2sec21" class="calibre1"/>Using custom operators in RxPHP 2</h2></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">Chapter 1</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>, we mentioned a magic <code class="literal">__call()</code> method. RxPHP 2 uses this method to allow the use of custom operators by auto-discovering them in two namespace formats.</p><p class="calibre8">The first option is defining our operator class in the <code class="literal">Rx\Operator</code> namespace:</p><pre class="programlisting">// JSONDecodeOperator.php 
namespace Rx\Operator; 
 
use Rx\ObservableInterface as ObservableI; 
use Rx\ObserverInterface as ObserverI; 
use Rx\Operator\OperatorInterface as OperatorI; 
use Rx\DisposableInterface as DisposableI; 
 
class JSONDecodeOperator implements OperatorI { 
  public function __invoke(ObservableI $observable, 
      ObserverI $observer): DisposableI { 
 
   return $observable-&gt;subscribe( 
     function ($value) use ($observer) { 
       $decoded = json_decode($value, true); 
       if (json_last_error() == JSON_ERROR_NONE) { 
         $observer-&gt;onNext($decoded); 
       } else { 
         $msg = json_last_error_msg(); 
         $e = new InvalidArgumentException($msg); 
         $observer-&gt;onError($e); 
       } 
     }, 
     [$observer, 'onError'], 
     [$observer, 'onCompleted'] 
   ); 
  } 
} 
</pre><p class="calibre8">It's the same <code class="literal">JSONDecodeOperator</code> class, just updated for RxPHP 2. Using this operator is, then, very simple:</p><pre class="programlisting">Observable::just('{"value":42}') 
    -&gt;JSONDecode() 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">Since our operator resides under the <code class="literal">Rx\Operator</code> namespace, it's expanded by the <code class="literal">__call()</code> method to <code class="literal">Rx\Operator\JSONDecodeOperator</code>. This means we don't need to use the <code class="literal">lift()</code> method at all.</p><p class="calibre8">Another way is to prefix the operator name and namespace with underscores <code class="literal">_</code> which are then merged into a full class name. This means we can put all application specific operators under a custom namespace:</p><pre class="programlisting">// JSONDecodeOperator.php 
namespace MyApp\Rx\Operator; 
... 
class JSONDecodeOperator implements OperatorI { ... } 
</pre><p class="calibre8">Now we can use the operator as follows:</p><pre class="programlisting">Observable::just('{"value":42}') 
    -&gt;_MyApp_JSONDecode() 
    -&gt;subscribe(new DebugSubject()); 
</pre></div></div>

<div class="book" title="Writing CURLObservable"><div class="book" id="RL0A2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Writing CURLObservable</h1></div></div></div><p class="calibre8">As we said, we're going to work with API calls and, for this reason, we need a comfortable way of creating HTTP requests. It's probably no surprise that we'll write a custom Observable that downloads a URL and passes it's response to its observers, where we'll decode it from JSON using the operator we created just a couple of lines above.</p><p class="calibre8">We're going to use PHP's cURL module, which is a wrapper around libcurl (<a class="calibre1" href="https://curl.haxx.se/libcurl/">
https://curl.haxx.se/libcurl/
</a>) - a C library for transferring data via any protocols imaginable.</p><p class="calibre8">We'll start by using plain simple cURL in PHP and we'll see that it supports some sort of asynchronous approach out-of-the-box.</p></div>

<div class="book" title="Writing CURLObservable">
<div class="book" title="Imperative approach and cURL"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch02lvl2sec22" class="calibre1"/>Imperative approach and cURL</h2></div></div></div><p class="calibre8">If we just wanted to download a single URL, we wouldn't need anything special. However, we want to make this, and all future applications of <code class="literal">CURLObservable</code> class, more interactive, so we'll also keep track of the downloading progress.</p><p class="calibre8">A plain and simple approach could look like this:</p><pre class="programlisting">// curl_01.php 
$ch = curl_init(); 
curl_setopt($ch, CURLOPT_URL, "http://google.com"); 
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); 
curl_setopt($ch, CURLOPT_PROGRESSFUNCTION, 'progress'); 
curl_setopt($ch, CURLOPT_NOPROGRESS, false); 
curl_setopt($ch, CURLOPT_HEADER, 0); 
$html = curl_exec($ch); 
curl_close($ch); 
 
function progress($res, $downtotal, $down, $uptotal, $up) { 
    if ($download_size &gt; 0) { 
        printf("%.2f\n", $down / $downtotal * 100); 
    } 
    ob_flush(); 
    usleep(100 * 1000); 
} 
</pre><p class="calibre8">We're using <code class="literal">CURLOPT_PROGRESSFUNCTION</code> option to set a callback function which is invoked internally by the cURL module. It takes four arguments that help us keep track of how much of the page's total size already has been downloaded.</p><p class="calibre8">We probably don't need to show its output because it's pretty obvious.</p><p class="calibre8">There's also a small subset of cURL functions that work with multiple cURL handles simultaneously. These are all prefixed with <code class="literal">curl_multi_</code> and are executed by calling <code class="literal">curl_multi_exec()</code>. Nonetheless, the <code class="literal">curl_multi_exec()</code> function is blocking and the interpreter needs to wait until it finishes.</p></div></div>

<div class="book" title="Writing CURLObservable">
<div class="book" title="Implementing cURL into a custom Observable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch02lvl2sec23" class="calibre1"/>Implementing cURL into a custom Observable</h2></div></div></div><p class="calibre8">We've already seen how to write a custom observer, Subject and operator. Now is the right time to write an Observable as well. We want the Observable to emit values when downloading the URL and, at the end, return a complete response. We can distinguish between the two types of messages by checking their type. Progress will always be a double, while response will always be a string.</p><p class="calibre8">Let's start with our class synopsis to see how it's going to work and then implement each method separately with a short description:</p><pre class="programlisting">use Rx\Observable; 
use Rx\ObserverInterface as ObserverI; 
 
class CURLObservable extends Observable { 
    public function __construct($url) {} 
    public function subscribe(ObserverI $obsr, $sched = null) {} 
    private function startDownload() {} 
    private function progress($r, $downtot, $down, $uptot, $up) {} 
} 
</pre><p class="calibre8">Every time we write an Observable, we'll extend the base <code class="literal">Rx\Observable</code> class. We could theoretically just implement <code class="literal">Rx\ObservableInterface</code>, but, most of the time, we also want to inherit all its internal logic and all existing operators.</p><p class="calibre8">The constructor and method <code class="literal">startDownload()</code> are going to be very simple. In <code class="literal">startDownload()</code>, we start downloading the URL while monitoring its progress.</p><p class="calibre8">Please note that this code goes inside the <code class="literal">CURLObservable</code> class; we're just trying to keep the code short and easy to read, so we have omitted indentation and class definition in this example:</p><pre class="programlisting">public function __construct($url) { 
    $this-&gt;url = $url; 
} 
 
private function startDownload() { 
    $ch = curl_init(); 
    curl_setopt($ch, CURLOPT_URL, $this-&gt;url); 
    curl_setopt($ch, CURLOPT_PROGRESSFUNCTION,[$this,'progress']); 
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); 
    curl_setopt($ch, CURLOPT_NOPROGRESS, false); 
    curl_setopt($ch, CURLOPT_HEADER, 0); 
    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 ...'); 
    // Disable gzip compression 
    curl_setopt($ch, CURLOPT_ENCODING, 'gzip;q=0,deflate,sdch'); 
    $response = curl_exec($ch); 
    curl_close($ch); 
 
    return $response; 
} 
</pre><p class="calibre8">This is mostly the same as the example using an imperative approach. The only interesting difference is that we're using a callable <code class="literal">[$this,'progress']</code> instead of just a function name, as we did earlier.</p><p class="calibre8">The actual emission of values happens inside the <code class="literal">progress()</code> method:</p><pre class="programlisting">private function progress($res, $downtotal, $down, $uptotal, $up){ 
    if ($downtotal &gt; 0) { 
        $percentage = sprintf("%.2f", $down / $downtotal * 100); 
        foreach ($this-&gt;observers as $observer) { 
            /** @var ObserverI $observer */ 
            $observer-&gt;onNext(floatval($percentage)); 
        } 
    } 
} 
</pre><p class="calibre8">Since we inherited the original Observable, we can make use of its protected property <code class="literal">$observers</code> that holds all subscribed observers, as its name suggests. To emit a value to all of them, we can simply iterate the array and call <code class="literal">onNext</code> on each observer.</p><p class="calibre8">The only method we haven't seen so far is <code class="literal">subscribe()</code>:</p><pre class="programlisting">public function subscribe(ObserverI $obsr, $sched = null) { 
    $disp1 = parent::subscribe($obsr, $sched); 
 
    if (null === $sched) { 
        $sched = new ImmediateScheduler(); 
    } 
 
    $disp2 = $sched-&gt;schedule(function() use ($obsr, $started) { 
        $response = $this-&gt;startDownload(); 
        if ($response) { 
            $obsr-&gt;onNext($response); 
            $obsr-&gt;onCompleted(); 
        } else { 
            $msg = 'Unable to download ' . $this-&gt;url); 
            $obsr-&gt;onError(new Exception($msg)); 
        } 
    }); 
 
    return new CompositeDisposable([$disp1, $disp2]); 
} 
</pre><p class="calibre8">This method combines many of the things we've seen in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We definitely want to keep the original functionality of the Observable, so we'll call its parent implementation. This adds the observer to the array of observers, as mentioned a moment ago.</li><li class="listitem">The <code class="literal">parent::subscribe()</code> method returns a disposable. That's the object we can use to unsubscribe the observer from this Observable.</li><li class="listitem">If we don't specify what Scheduler this Observable should use, it'll fall back to <code class="literal">ImmediateScheduler</code>. We've already mentioned <code class="literal">ImmediateScheduler</code> when we were talking about Schedulers in general. In RxPHP 2, we'd use <code class="literal">Scheduler::getImmediate()</code> instead of directly using the class name.</li><li class="listitem">Right after that, we schedule the work (in terms of Schedulers, it's usually referred to as "action") to be executed by the Scheduler. Note that the action itself is a closure.</li><li class="listitem">Then, we start downloading the URL. If we subscribe another observer to the same Observable, it'll re-download the same URL again. Download progress is then emitted with frequency according to cURL's internals. We'll talk more about the subscription process in the next chapter.</li><li class="listitem">When downloading finishes, we emit the response or an error.</li><li class="listitem">At the end of this method, it returns another disposable. This time, it's <code class="literal">CompositeDisposable</code> that is used to wrap other disposables. When calling its <code class="literal">dispose()</code> method, these wrapped ones are properly disposed as well.</li></ul></div><p class="calibre8">So, that's it. Now we can test our Observable and see what its output is. We can try to grab a list of the most recent questions on <a class="calibre1" href="http://www.stackoverflow.com">
www.stackoverflow.com
</a> tagged with <span class="strong"><em class="calibre18">functional-programming</em></span>":</p><pre class="programlisting">$url = 'https://api.stack...&amp;tagged=functional-programming'; 
$observable = new CurlObservable($url); 
$observable-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This prints a couple of numbers and then the response JSON string:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">16:17:52 onNext: 21.39 (double)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onNext: 49.19 (double)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onNext: 49.19 (double)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onNext: 76.99 (double)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onNext: 100 (double)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onNext: {"items":[{"tags":["javascript","... (string)</strong></span>
<span class="strong"><strong class="calibre17">16:17:52 onCompleted</strong></span>
</pre><p class="calibre8">You can see that one value was emitted twice. This is because of the timing and network latency when cURL evaluates the callback, which is nothing unusual. If we didn't want to see repeated values, we could use the <code class="literal">distinct()</code> operator that we saw when talking about "marble diagrams".</p><p class="calibre8">Now let's combine it with our <code class="literal">JSONDecodeOperator</code>. Since we're now interested only in the string response and want to ignore all progress emissions, we'll also use the <code class="literal">filter()</code> operator:</p><pre class="programlisting">// rxphp_curl.php 
$observable 
    -&gt;filter(function($value) { 
        return is_string($value); 
    }) 
    -&gt;lift(function() { 
        return new JSONDecodeOperator(); 
    }) 
    -&gt;subscribe(new DebugSubject(null, 128)); 
</pre><p class="calibre8">This returns part of the response array (for demonstration purposes, we added indentation and made the output a little longer):</p><pre class="programlisting">$ php rxphp_curl.php 
16:23:55 [] onNext: { 
    "items": [ 
        { 
            "tags": [ 
                "javascript", 
                "functional-programming", 
       ... (array) 
16:23:55 [] onCompleted 
</pre><p class="calibre8">When we used the <code class="literal">filter()</code> operator, you might notice that we called it <code class="literal">Observable::filter()</code> without necessarily using the <code class="literal">lift()</code> method. This is because almost all operators are, in fact, just <code class="literal">lift()</code> calls with predefined Closures that return an appropriate operator class. A good question is whether we can write our own shorthand for <code class="literal">JSONDecodeOperator</code> when we're already extending the base Observable class. Maybe something like <code class="literal">Observable::jsonDecode()</code>?</p><p class="calibre8">The answer is yes, we can. However, in RxPHP 1.x, it wouldn't help us a lot. When we chain operators, they return other instances of Observables that aren't under our control. We could theoretically use <code class="literal">Observable::jsonDecode()</code> right after creating <code class="literal">CurlObservable</code> because we'd know that it's going to be an instance of this class, but chaining it with <code class="literal">filter()</code> brings us back to the original Observable that doesn't know any <code class="literal">jsonDecode()</code> methods. In particular, the <code class="literal">filter()</code> operator returns an instance of <code class="literal">Rx\Observable\AnonymousObservable</code>.</p><div class="book" title="Running multiple requests asynchronously"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch02lvl3sec7" class="calibre1"/>Running multiple requests asynchronously</h3></div></div></div><p class="calibre8">An interesting use case could be to start multiple requests asynchronously. All calls to <code class="literal">curl_exec()</code> are blocking, which means that they block the execution context until they're finished.</p><p class="calibre8">Unfortunately, this is a very tricky problem that's hard to solve without using any extra PHP modules, such as <span class="strong"><strong class="calibre17">pthreads</strong></span>, as we'll see much later in <a class="calibre1" title="Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman" href="part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d">Chapter 9</a>, <span class="strong"><em class="calibre18">Multithreaded and Distributed Computing with pthreads and Gearman</em></span>.</p><p class="calibre8">We can, however, make use of PHP's standard <code class="literal">proc_open()</code> to spawn non-blocking subprocesses that can run in parallel and then just ask for their output.</p></div></div></div>
<div class="book" title="The proc_open() and non-blocking fread()" id="SJGS1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>The proc_open() and non-blocking fread()</h1></div></div></div><p class="calibre8">Our goal is to have the means to start various subprocesses asynchronously. In this example, we'll use a simple PHP script that'll just sleep for a couple of seconds and represent our asynchronous task:</p><pre class="programlisting">// sleep.php 
$name = $argv[1]; 
$time = intval($argv[2]); 
$elapsed = 0; 
 
while ($elapsed &lt; $time) { 
    sleep(1); 
    $elapsed++; 
    printf("$name: $elapsed\n"); 
} 
</pre><p class="calibre8">This script takes two arguments. The first one is an identifier of our choice that we'll use to distinguish between multiple processes. The second one is the number of seconds this script will run while printing its name and the elapsed time every second. For example, we can run:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ sleep.php proc1 3</strong></span>
<span class="strong"><strong class="calibre17">proc1: 1</strong></span>
<span class="strong"><strong class="calibre17">proc1: 2</strong></span>
<span class="strong"><strong class="calibre17">proc1: 3</strong></span>
</pre><p class="calibre8">Now, we'll write another PHP script that uses <code class="literal">proc_open()</code> to spawn a subprocess. Also, as we said, we need the script to be non-blocking. This means that we need to be able to read output from the subprocess as it is printed using <code class="literal">printf()</code> above, while being able to spawn more subprocess, if needed:</p><pre class="programlisting">// proc_01.php 
$proc = proc_open('php sleep.php proc1 3', [ 
    0 =&gt; ['pipe', 'r'], // stdin 
    1 =&gt; ['pipe', 'w'], // stdout 
    2 =&gt; ['file', '/dev/null', 'a'] // stderr 
], $pipes); 
 
stream_set_blocking($pipes[1], 0); 
 
while (proc_get_status($proc)['running']) { 
    usleep(100 * 1000); 
    $str = fread($pipes[1], 1024); 
    if ($str) { 
        printf($str); 
    } else { 
        printf("tickn"); 
    } 
} 
fclose($pipes[1]); 
proc_close($proc); 
</pre><p class="calibre8">We spawn a subprocess <code class="literal">php sleep.php proc1 3</code> and then go into a loop. With a 100ms delay, we check whether there's any new output from the subprocess using <code class="literal">fread()</code>. If there is, we print it; otherwise, just write the word "tick". The loop will end when the subprocess terminates (that's the condition with the <code class="literal">proc_get_status()</code> function).</p><p class="calibre8">The most important thing in this example is calling the <code class="literal">stream_set_blocking()</code> function, which makes operations with this stream non-blocking.</p></div>
<div class="book" title="Event loop and RxPHP" id="TI1E1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Event loop and RxPHP</h1></div></div></div><p class="calibre8">Applying event loop to Observables would work in a similar way. We'd create Observables, start an event loop and periodically check their progress. Luckily for us, RxPHP is prepared for this. In combination with the ReactPHP library (<a class="calibre1" href="https://github.com/reactphp/react">
https://github.com/reactphp/react
</a>), we can use a Scheduler that's designed exactly for what we need.</p><p class="calibre8">As an example, we can have a look at <code class="literal">IntervalObservable</code> that periodically emits values:</p><pre class="programlisting">// rxphp_eventloop.php 
$loop = new ReactEventLoopStreamSelectLoop(); 
$scheduler = new RxSchedulerEventLoopScheduler($loop); 
 
RxObservable::interval(1000, $scheduler) 
    -&gt;take(3) 
    -&gt;subscribe(new DebugSubject()); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">This prints three values with 1s delays:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_eventloop.php</strong></span>
<span class="strong"><strong class="calibre17">23:12:44 [] onNext: 0 (integer)</strong></span>
<span class="strong"><strong class="calibre17">23:12:45 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">23:12:46 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">23:12:46 [] onCompleted</strong></span>
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">In RxPHP 2, using event loops has been simplified and, most of the time, we don't even need to worry about starting the loop ourselves. We'll talk about differences between RxPHP 1.x and RxPHP 2 regarding event loops in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>.</p></div></div>
<div class="book" title="Summary" id="UGI01-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we had a closer look at all the components of RxPHP.</p><p class="calibre8">In particular, we've seen all three types of notifications used in Rx, Observables, observers, Subjects, Singles and operators. On practical examples, we have designed our custom observer, Subject, Observable and an operator. We'll use all these in the upcoming chapters.</p><p class="calibre8">We saw that documentation regarding Rx operators is very often described in the form of "marble diagrams".</p><p class="calibre8">The next chapter is going to utilize all we did in this chapter. We're going to create a CLI Reddit reader using RxPHP and Symfony Console component. We'll also talk in more depth about the subscription process in Observable chains.</p></div></body></html>