<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">JavaScript and the Ajax API</h1>
                </header>
            
            <article>
                
<p>So far in this book, we've only talked about topics that can be considered to relate to backend development. This means heavy PHP working with the APIs and the database, and so on. This is because this book is oriented toward module developers rather than "themers". Also, the author of this book is admittedly not a JavaScript, or any kind of frontend, developer.</p>
<p>Nevertheless, in this chapter we'll switch gears and talk a bit about <em>frontend development</em>, namely, how to work with JavaScript in a Drupal 8 application. This is because there are many things developers can and should be doing in their modules that require frontend technologies. There are a few approaches and techniques specific to Drupal when it comes to adding and using JavaScript files and we will talk about those here. Moreover, we will also prove how powerful Drupal 8 is in allowing us to do quite a bit of JavaScript work without actually writing a single line of JavaScript code.</p>
<p>So, there are a few things we will cover in this chapter.</p>
<p>First, we will talk about the approach of writing JavaScript in Drupal. You already learned in <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, how you can create libraries and attach them to render arrays, elements, or pages. Basically, using libraries, we can get our JavaScript files loaded when we need. I recommend you check out the <em>Assets and libraries</em> <span>section </span>from <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, if you don't remember exactly how libraries work. Because in this chapter, we will continue from there and talk a bit about what actually goes inside those JavaScript files.</p>
<div class="packt_tip">A good resource to keep handy is the documentation page (<span class="MsoHyperlink"><a href="https://www.drupal.org/node/172169">https://www.drupal.org/node/172169</a></span>) which lists the coding standards for JavaScript in Drupal 8 that we should abide by.</div>
<p>We won't actually write a lot of JavaScript code in the first part<span><span>—</span></span>just enough to get you started though. In the second part, we will not write any at all. Instead, we will talk about the robust Ajax API that comes with Drupal and that allows us to build some very dynamic functionalities that rely on JavaScript. To demonstrate how things work, we will revisit our importer functionality that we started in <a href="392cdb70-e52a-42d1-b782-28d6eb726810.xhtml"><span class="MsoHyperlink">Chapter 7</span></a>, <em>Your Own Custom Entity and Plugin Types</em>, and improve it using Ajax.</p>
<p>Finally, we will also talk about the States system of the Form API, which allows us to make our form elements dynamic and dependent on others in a declarative way. Again, we won't even have to know any JavaScript to do what is actually quite complex client-side behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript in Drupal</h1>
                </header>
            
            <article>
                
<p>Drupal 8 relies on a number of JavaScript libraries and plugins to perform some of its frontend tasks. For example, the use of <em>Backbone.js</em> is another example of advancement from previous versions of Drupal when it comes to adopting established libraries rather than reinventing new ones. Of course, as we've already seen, the ubiquitous <em>jQuery</em> library continues to be used in Drupal 8 as well. But of course, there are others.</p>
<p>Another thing I have already mentioned, but which is helpful to bring up again, is the fact that Drupal no longer loads things such as jQuery or its Ajax framework on all pages needlessly. For example, many pages serving anonymous users that do not require jQuery won't even load it. This can greatly improve performance. But it also means that when we define our libraries to include our own JavaScript files, we must always declare these as dependencies (if we need them). For example, jQuery is something you'll often depend on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal behaviors</h1>
                </header>
            
            <article>
                
<p>One of the most important things you need to know when writing JavaScript files in Drupal is the concept of behaviors. But in order to understand that, let's get a bit of context.</p>
<p>When writing JavaScript code using jQuery, it's often standard to wrap our code inside a <kbd>ready()</kbd> method statement as follows:</p>
<pre>$(document).ready(function () { 
  // Essentially the entirety of your javascript code. 
}); </pre>
<p>This ensures that your code runs only after the entire <strong>Document Object Model</strong> (<strong>DOM</strong>) has been loaded by the browser. Moreover, the use of jQuery for this helps a great deal with cross-browser compatibility and also allows us to place this code wherever we want on the page (header or footer).</p>
<p>In Drupal, however, we have a different solution which is better in the context of writing JavaScript that works with Drupal as well (not just with the DOM). That comes in the form of Drupal behaviors. In a nutshell, behaviors are methods we declare that get called when the DOM loads fully, that is, when the document is ready. However, on top of that, they also get called by the Ajax framework when new data is loaded onto the page. Even when using BigPipe and placeholder replacements are streamed.</p>
<p>Any Drupal site has a global <kbd>Drupal</kbd> object that is used for many things we won't go into right now. However, the <kbd>Drupal.behaviours</kbd> object is where we declare behaviors, and typically any JavaScript code that we want to run should go inside a behavior. So, let's see an example, as it will be much easier to understand.</p>
<p>What we want is to show a little dynamic JavaScript clock next to the <span class="packt_screen">Hello World</span> salutation, if the message is not coming from the configuration but is dependent on the time of day. While writing the code for our functionality, we'll talk about Drupal behaviors and how they are used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our library</h1>
                </header>
            
            <article>
                
<p>In order to get our JavaScript file loaded, it needs to be in a library and attached to <em>something</em>. As you learned in <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, the libraries file has the name <kbd>hello_world.libraries.yml</kbd> and is located in the root folder of our module:</p>
<pre>hello_world_clock: 
  version: 1.x 
  js: 
    js/hello_world_clock.js: {} 
  dependencies: 
    - core/jquery 
    - core/drupal 
    - core/jquery.once  </pre>
<p>We only have a single JavaScript file that is needed for our purpose, located in the <kbd>js</kbd> directory of our module. But we do have some dependencies. First, we want jQuery loaded because we will use it. Second, we want to have the general Drupal JavaScript library which handles a bunch of things, including behaviors. The last dependency we will talk about soon and it will make a bit more sense then.</p>
<p>Without these dependencies declared, in some cases (especially for anonymous users), Drupal would not have them loaded on the page and our JavaScript functionality would not work.</p>
<p>Now, let's attach this library to our salutation component found inside the <kbd>HelloWorldSalutation</kbd> service<span><span>.</span></span></p>
<p>Right after these two lines:</p>
<pre>$time = new \DateTime(); 
$render['#target'] = $this-&gt;t('world');  </pre>
<p>We can add the following:</p>
<pre>$render['#attached'] = [ 
  'library' =&gt; [ 
    'hello_world/hello_world_clock' 
  ] 
];  </pre>
<p>This is nothing new for us but the point is that we are only attaching the library if the component is showing the dynamic salutation message that depends on the time of day. If this message has been overridden, we don't even want to load these libraries, and that is pretty much it. We can dive in and create our <kbd>hello_world_clock.js</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JavaScript</h1>
                </header>
            
            <article>
                
<p>The first thing we need to do inside the JavaScript file is to wrap the entire code we write in the file into an <strong>Immediately Invoked Function Expression</strong> (<strong>IIFE</strong>). In doing this, we protect the scope of what we write from the global one and even use global variables with more commonly associated variable names inside our own scope. This is how this looks:</p>
<pre><span>(</span><span>function </span><span>(Drupal</span><span>, </span><span>$) {<br/></span><span><br/></span><span>  </span><span>"use strict"</span><span>;<br/></span><span><br/></span><span>  </span><span>// Our code here. <br/></span><span><br/></span><span>}) (</span><span>Drupal</span><span>, </span><span>jQuery</span><span>)</span><span>;</span></pre>
<p>The most important thing here is that inside this function we can now use the dollar sign (<kbd>$</kbd>) as a reference to the global jQuery object without interfering with other libraries that might use the same variable name. Also, we added the <kbd>use strict</kbd> declaration to ensure we write semantically correct code (and it's also part of the JavaScript coding standards for Drupal 8).</p>
<p>Let's now add the meat of our functionality and explain how it works:</p>
<pre><span>Drupal</span><span>.</span><span>behaviors</span><span>.</span><span>helloWorldClock </span><span>= {<br/></span><span>  attach: </span><span>function </span><span>(context</span><span>, </span><span>settings) {<br/></span><span>    </span><span>function </span><span>ticker</span><span>() {<br/></span><span>      </span><span>var </span><span>date </span><span>= </span><span>new </span><span>Date()</span><span>;<br/></span><span>      </span><span>$(</span><span>context</span><span>).find(</span><span>'.clock'</span><span>).html(</span><span>date</span><span>.toLocaleTimeString())</span><span>;<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>var </span><span>clock </span><span>= </span><span>'&lt;div&gt;The time is &lt;span class="clock"&gt;&lt;/span&gt;&lt;/div&gt;'</span><span>;<br/></span><span><br/></span><span>    </span><span>$(</span><span>document</span><span>).find(</span><span>'.salutation'</span><span>).append(</span><span>clock</span><span>)</span><span>;<br/></span><span><br/></span><span>    </span><span>setInterval(</span><span>function</span><span>() {<br/></span><span>      ticker()</span><span>;<br/></span><span>    </span><span>}</span><span>, </span><span>1000</span><span>)</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span><span>;  </span></pre>
<p>First of all, we are defining a new behavior, which is an object on the <kbd>Drupal.behaviours</kbd> object and needs to have a unique name. You can look at a single behavior as one piece of functionality. We only need one function on this object called <kbd>attach</kbd>, which receives two parameters: <kbd>context</kbd> (the page or part of the page that is being loaded) and <kbd>settings</kbd> (the variable containing data passed from PHP).</p>
<p>This function gets invoked by Drupal whenever behaviors need to be attached—<kbd>Drupal.attachBehaviors()</kbd>. This happens when the page gets loaded for the first time (in which case <kbd>context</kbd> is the entire DOM) or after an Ajax request or BigPipe replacement (in which case <kbd>context</kbd> contains only the newly loaded parts of the page). Therefore, using the <kbd>context</kbd> instead of the entire document for looking up elements is sometimes more performant (especially after an Ajax request) and prevents other side effects.</p>
<p>Inside the <kbd>attach</kbd> function, we have our logic for creating a clock. First, we define a simple function that looks for the element with the <kbd>.clock</kbd> class and puts the current time into it. You'll notice that we used <kbd>context</kbd> to look for the element. Next, we create this element ourselves and append it to our salutation message element. Lastly, we set an interval every second to keep calling our <kbd>ticker()</kbd> function, essentially updating the time every second, giving the illusion of a clock. This is all pretty standard.</p>
<div class="packt_infobox">Be aware that the strings we are printing to the user via JavaScript are not run through the translation system and that is not good practice (even if the site is not multilingual). In a later chapter, we will see how we need to handle it instead.</div>
<p>Clearing the cache and navigating to our <kbd>/hello</kbd> page, we can already see the new clock appearing (if we don't have the salutation message overridden). So we're done, right? Well, not really.</p>
<p>If we open up the browser's developer tools, namely the console, and try to attach the behaviors again:</p>
<pre>Drupal.attachBehaviors();  </pre>
<p>We notice that our clock element gets appended again (it has been duplicated). Well, that's not right because if we have an Ajax request we run the risk of having this happen. This is where <kbd>jQuery.once</kbd> comes in.</p>
<p>The <kbd>jQuery.once</kbd> library is a plugin for jQuery that allows us to track and make sure we are performing something only once. It's actually very simple to use. All we have to do is replace this line:</p>
<pre>$(context).find('.salutation').append(clock);  </pre>
<p>With this:</p>
<pre>$(context).find('.salutation').once('helloWorldClock').append(clock);  </pre>
<p>So basically, before doing the actual thing, we call the <kbd>.once()</kbd> method with an ID to use for tracking. This will ensure that whatever comes next in the chain is only applied to the elements to which it has not been already applied. And now you also see why we wanted our library to depend on <kbd>core/jquery.once</kbd>.</p>
<p>And with this, our clock is ready.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal settings</h1>
                </header>
            
            <article>
                
<p>Another powerful thing we can do (and something we often need to do) is pass values from our PHP code to the JavaScript layer. In custom PHP applications, this can get messy, but Drupal has a robust API that transforms PHP arrays into JavaScript objects. These can be found inside the <kbd>settings</kbd> object passed to the behavior's <kbd>attach()</kbd> function.</p>
<p>Again, the easiest way to understand this is through an example. So let's say we want to print an extra message after the salutation if it is the afternoon. Of course, we can use JavaScript to determine that as well, but so far it has been the responsibility of our PHP code, so let's keep it that way. So then we need a way to tell our JavaScript that it is afternoon, and we can do this by setting a flag if that is the case, as follows:</p>
<pre><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>12 </span><span>&amp;&amp; (int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &lt; </span><span>18</span><span>) {<br/></span><span>  </span><span>$render</span><span>[</span><span>'#salutation'</span><span>][</span><span>'#markup'</span><span>] = </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good afternoon'</span><span>)</span><span>;<br/></span><span>  </span><span>$render</span><span>[</span><span>'#attached'</span><span>][</span><span>'drupalSettings'</span><span>][</span><span>'hello_world'</span><span>][</span><span>'hello_world_clock'</span><span>][</span><span>'afternoon'</span><span>] = </span><span>TRUE</span><span>;<br/></span><span>  </span><span>return </span><span>$render</span><span>;<br/></span><span>}<br/></span></pre>
<p>New here is the second line from within the <em>if conditional</em>, namely the one where we attach something to the render array. In this case, though, it's not a library but <kbd>drupalSettings</kbd> in a big multidimensional array. The best practice is to <em>namespace</em> our settings hierarchically like so: our module name -&gt; the functionality the setting belongs to -&gt; the setting name. In JavaScript, this array will be transformed into an object.</p>
<div class="packt_infobox">To get the <kbd>drupalSettings</kbd> to work, we need to make sure the <kbd>core/drupalSettings</kbd> library is loaded. In our case, this happens because the <kbd>core/drupal</kbd> library lists it as a dependency.</div>
<p>Now that we pass this flag (which could be much more complex if needed), we can make use of it in JavaScript:</p>
<pre>var clock = '&lt;div&gt;The time is &lt;span class="clock"&gt;&lt;/span&gt;&lt;/div&gt;'; 
if (settings.hello_world != undefined &amp;&amp; settings.hello_world.hello_world_clock.afternoon != undefined) { 
  clock += 'Are you having a nice day?'; 
}  </pre>
<p>That is pretty much it. We managed to easily pass values from PHP into JavaScript and use them in client-side logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Ajax API</h1>
                </header>
            
            <article>
                
<p>Now that you are on your way and ready to write whatever JavaScript you need for your application, and you are able to integrate this with the Drupal backend APIs, let's take a look at the Ajax framework. There's a lot we can do on the client side without having to write a single line of JavaScript code.</p>
<p>The Drupal Ajax API is a robust system that allows us to define client-side interactions via PHP. We most commonly use Ajax when we interact with forms—triggering certain actions that change the DOM without having to reload the page. We will demonstrate how all this works by expanding a bit more on the importer functionality we built in <a href="392cdb70-e52a-42d1-b782-28d6eb726810.xhtml"><span class="MsoHyperlink">Chapter 7</span></a>, <em>Your Own Custom Entity and Plugin Types</em>. Before, though, let's take a quick look at the simpler use case of Ajax in Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ajax links</h1>
                </header>
            
            <article>
                
<p>The simplest way to interact with Drupal's Ajax API is to add the <kbd>use-ajax</kbd> <span>class </span>to any link. This will cause the link to make an Ajax request to the path of the link rather than moving the browser to it. A similar thing can be done with the submit button of a form using the <kbd>use-ajax-submit</kbd><span> class.</span> This makes the form submit via Ajax to the path defined in the form's action.</p>
<p>The most important thing, however, is what we do on the other end of the process. Clicking a link that triggers an Ajax request won't do anything if we don't handle that request accordingly. What we have to do is return an <kbd>AjaxResponse</kbd> object with some jQuery <em>commands</em> that instruct the browser on the changes it needs to make to the DOM. So, let's see an example.</p>
<p>Remember in <a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml"><span class="MsoHyperlink">Chapter 2</span></a>, <em>Creating Your First Module</em>, when we created our first block which simply rendered the salutation message from the service? It didn't use the theme hook we created in <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, but simply delegated to the <kbd>getSalutation()</kbd> method of the <kbd>HelloWorldSalutation</kbd> service. Let's say we want to add a link after the message that we can click on, and that hides the block entirely. There are a few easy steps we need to take to achieve this.</p>
<p>First, we need to alter the <kbd>build()</kbd> method of the block to get something like this:</p>
<pre>/** 
* {@inheritdoc} 
*/ 
public function build() { 
$build = []; 
 
$build[] = [ 
  '#theme' =&gt; 'container', 
  '#children' =&gt; [ 
    '#markup' =&gt; $this-&gt;salutation-&gt;getSalutation(), 
  ] 
]; 
 
$url = Url::fromRoute('hello_world.hide_block'); 
$url-&gt;setOption('attributes', ['class' =&gt; 'use-ajax']); 
$build[] = [ 
  '#type' =&gt; 'link', 
  '#url' =&gt; $url, 
  '#title' =&gt; $this-&gt;t('Remove'), 
]; 
 
return $build; 
}  </pre>
<p>And the new <em>use</em> statement:</p>
<pre>use Drupal\Core\Url;</pre>
<p>The first thing we do is wrap our original simple <kbd>#markup</kbd>-based array into a Drupal core <kbd>container</kbd> theme hook, just so it wraps it with some divs and we don't have to create our own theme hook. After all, we are doing proof-of-concept work here. Next, below the message, we print a link to a new route we have to define. And as we talked about, to that link we add the <kbd>use-ajax</kbd> class. You'll notice that we can add attributes (refer back to <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, for more info on those) straight to the <kbd>Url</kbd> object, and they will be added to the rendered link element.</p>
<p>Second, we need to define this new route. Nothing could be simpler:</p>
<pre>hello_world.hide_block: 
  path: '/hide-block' 
  defaults: 
    _controller: '\Drupal\hello_world\Controller\HelloWorldController::hideBlock' 
  requirements: 
    _permission: 'access content'  </pre>
<p>We map it to a new method on the same Controller class we've been using and allow all users access to it.</p>
<p>Third (and last), we need to define the Controller method:</p>
<pre>/** 
 * Route callback for hiding the Salutation block. 
 * Only works for Ajax calls. 
 * 
 * @param \Symfony\Component\HttpFoundation\Request $request 
 * 
 * @return \Drupal\Core\Ajax\AjaxResponse 
 */ 
public function hideBlock(Request $request) { 
  if (!$request-&gt;isXmlHttpRequest()) { 
    throw new NotFoundHttpException(); 
  } 
 
  $response = new AjaxResponse(); 
  $command = new RemoveCommand('.block-hello-world'); 
  $response-&gt;addCommand($command); 
  return $response; 
}  </pre>
<p>And the new <em>use</em> statements at the top:</p>
<pre>use Drupal\Core\Ajax\AjaxResponse; 
use Drupal\Core\Ajax\RemoveCommand; 
use Symfony\Component\HttpFoundation\Request; 
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;  </pre>
<p>The first thing you'll notice is the <kbd>$request</kbd> parameter <span><span>of</span></span> this method, and you may be wondering where it's coming from. Drupal passes the current request object to any Controller method which simply type hints a parameter with that class. So, we don't have to inject it into our Controller. The reason we need it is so that we can check whether the request to this route was made via Ajax. Because if not, we don't want to handle it. That is, we throw a <kbd>NotFoundHttpException</kbd> which results in a regular 404.</p>
<p>Then comes the fun stuff relating to the Ajax API, namely, the building of an <kbd>AjaxResponse</kbd> full of commands back to the browser. In our example, there is only one command which instructs it to run the jQuery <kbd>remove()</kbd> method on the elements that match the selector that is passed to it. In our case, this is the class of the block wrapper. And with this, our functionality is in place. We can clear our cache and the block should now print a link that removes the block via Ajax.</p>
<p>You may be thinking: why do we need a trip back to the server for a job that can be done on the client-side alone? And the answer is—we actually don't. However, it serves as a good example of how Ajax responses work. And I encourage you to check out the documentation page (<span class="MsoHyperlink"><a href="https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x">https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/8.6.x</a></span> ) for the Ajax API, where you can find a list of all the available commands. For example, we could have used the <kbd>ReplaceCommand</kbd> to replace the block with something else that comes back from the server, or the <kbd>HtmlCommand</kbd> to insert some data into an element on the page, or even an <kbd>AlertCommand</kbd> to trigger a JavaScript alert with some data coming from the server. The cool thing is that the response can process multiple commands so we are not restricted to only using one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ajax in forms</h1>
                </header>
            
            <article>
                
<p>The most common use of Ajax in Drupal is through the Form API, where we can create dynamic interactions between the server and client with ease. To demonstrate how this works, we will go through an example. This will be a rework of the Importer configuration entity form we created in <a href="392cdb70-e52a-42d1-b782-28d6eb726810.xhtml"><span class="MsoHyperlink">Chapter 7</span></a>, <em>Your Own Custom Entity and Plugin Types</em>.</p>
<p>If you remember, we said that tying certain configuration values to the generic entity does not make sense, as importer plugins might be different. The first Importer we wrote loads a JSON file from a remote URL. So, it stands to reason that the configuration value for the URL is tied to the plugin and not the configuration entity (even if the latter actually stores it). Because if we want to create a CSV importer, for example, we don't need the URL. So, let's refactor our work to make this happen.</p>
<p>Here is an outline of the steps we need to take for this refactoring:</p>
<ol>
<li>Importer plugins need to provide their own configuration form elements.</li>
<li>The Importer configuration form needs to read these elements depending on which plugin is selected (this is where the Ajax API comes into play).</li>
<li>We need to alter the storage and configuration schema of the values that are specific to plugins.</li>
</ol>
<p>Let's start by giving the <kbd>ImporterInterface</kbd> <span>plugin type </span>a new method:</p>
<pre><span>/**<br/></span><span> * Returns the form array for configuring this plugin.<br/></span><span> *<br/></span><span> * </span><span>@param </span><span>\Drupal\products\Entity\ImporterInterface $importer<br/></span><span> *<br/></span><span> * </span><span>@return </span><span>array<br/></span><span> */<br/></span><span>public function </span><span>getConfigurationForm(\Drupal\products\Entity\ImporterInterface </span><span>$importer</span><span>)</span><span>;</span></pre>
<p>This is responsible for getting the form elements needed for this plugin. As an argument, it receives the Importer configuration entity, which can be inspected for default values.</p>
<p>Next, on the <kbd>ImporterInterface</kbd> of the configuration entity, we need to remove the <kbd>getUrl()</kbd> method (since that is specific to the <kbd>JsonImporter</kbd> plugin) and replace it with a generic method for retrieving all the configuration values pertaining to the plugin selected for the entity:</p>
<pre>/** 
 * Returns the configuration specific to the chosen plugin. 
 * 
 * @return array 
 */ 
public function getPluginConfiguration();  </pre>
<p>And of course, in the importer entity class, we reflect this change as well (by replacing the <kbd>$url</kbd> property):</p>
<pre>/** 
 * The configuration specific to the plugin. 
 * 
 * @var array 
 */ 
protected $plugin_configuration; </pre>
<p>And the actual getter method, in line with the interface:</p>
<pre>/** 
 * {@inheritdoc} 
 */ 
public function getPluginConfiguration() { 
  return $this-&gt;plugin_configuration; 
}  </pre>
<p>So far so good, nothing complicated going on. We are replacing the plugin-specific configuration values with a generic one in which values specific to the selected plugin will be stored. However, since our entity type no longer has the <kbd>$url</kbd> field but a <kbd>$plugin_configuration</kbd> one instead, we need to also adjust the <kbd>config_export</kbd> key in the annotation to reflect this change:</p>
<pre>*   config_export = { 
*     "id", 
*     "label", 
*     "plugin", 
*     "update_existing", 
*     "source", 
*     "bundle", 
*     "plugin_configuration" 
*   } </pre>
<p>Now, let's turn to the <kbd>ImporterForm</kbd> and make all the adjustments there. But before we do that, let's move the form element for the <kbd>url</kbd> field into the <kbd>JsonImporter</kbd>, where we have to implement the new <kbd>getConfigurationForm()</kbd> method:</p>
<pre>/** 
 * {@inheritdoc} 
 */ 
public function getConfigurationForm(\Drupal\products\Entity\ImporterInterface $importer) { 
  $form = []; 
  $config = $importer-&gt;getPluginConfiguration(); 
  $form['url'] = [ 
    '#type' =&gt; 'url', 
    '#default_value' =&gt; isset($config['url']) ? $config['url'] : '', 
    '#title' =&gt; $this-&gt;t('Url'), 
    '#description' =&gt; $this-&gt;t('The URL to the import resource'), 
    '#required' =&gt; TRUE, 
  ]; 
  return $form; 
}  </pre>
<p>You'll notice some differences in getting the default value. Instead of calling the now-removed <kbd>getUrl()</kbd> method on the configuration entity, we use the new <kbd>getPluginConfiguration()</kbd> method and check inside the resulting array. Also, since we use the <kbd>$this-&gt;t()</kbd> method to ensure the translation of the strings, we should use the <kbd>StringTranslationTrait</kbd> as well (which can go inside the parent base class as it is a trait):</p>
<pre>use StringTranslationTrait; </pre>
<p>Let's not forget that we are actually using the URL in the import, so we need to make some adjustments to the <kbd>getData()</kbd> method as well:</p>
<pre><span>/**<br/></span><span> * Loads the product data from the remote URL.<br/></span><span> *<br/></span><span> * </span><span>@return </span><span>\stdClass<br/></span><span> */<br/></span><span>private function </span><span>getData</span><span>() {<br/></span><span>  </span><span>/** </span><span>@var </span><span>ImporterInterface $importer_config */<br/></span><span>  </span><span>$importer_config </span><span>= </span><span>$this</span><span>-&gt;</span><span>configuration</span><span>[</span><span>'config'</span><span>]</span><span>;<br/></span><span>  </span><span>$config </span><span>= </span><span>$importer_config</span><span>-&gt;</span><span>getPluginConfiguration</span><span>()</span><span>;<br/></span><span>  </span><span>$url </span><span>= </span><span>isset</span><span>(</span><span>$config</span><span>[</span><span>'url'</span><span>]) ? </span><span>$config</span><span>[</span><span>'url'</span><span>] : </span><span>NULL</span><span>;<br/></span><span>  </span><span>if </span><span>(!</span><span>$url</span><span>) {<br/></span><span>    </span><span>return NULL</span><span>;<br/></span><span>  </span><span>}<br/></span><span>  </span><span>$request </span><span>= </span><span>$this</span><span>-&gt;</span><span>httpClient</span><span>-&gt;</span><span>get</span><span>(</span><span>$url</span><span>)</span><span>;<br/></span><span>  </span><span>$string </span><span>= </span><span>$request</span><span>-&gt;</span><span>getBody</span><span>()</span><span>;<br/></span><span>  </span><span>return </span><span>json_decode(</span><span>$string</span><span>)</span><span>;<br/></span><span>}</span></pre>
<p>With this in place, we can go ahead and adjust our <kbd>ImporterForm</kbd> (where we no longer have the form element for the URL field).</p>
<p>There are two main things we need to do:</p>
<ul>
<li>Expose the plugin selection element to Ajax, that is, trigger an Ajax request when the user makes a selection</li>
<li>Add the extra elements to the form depending on the chosen plugin</li>
</ul>
<p>This is what the new <kbd>plugin</kbd> element looks like:</p>
<pre>$form['plugin'] = [ 
  '#type' =&gt; 'select', 
  '#title' =&gt; $this-&gt;t('Plugin'), 
  '#default_value' =&gt; $importer-&gt;getPluginId(), 
  '#options' =&gt; $options, 
  '#description' =&gt; $this-&gt;t('The plugin to be used with this importer.'), 
  '#required' =&gt; TRUE, 
  '#empty_option' =&gt; $this-&gt;t('Please select a plugin'), 
  '#ajax' =&gt; array( 
    'callback' =&gt; [$this, 'pluginConfigAjaxCallback'], 
    'wrapper' =&gt; 'plugin-configuration-wrapper' 
  ), 
];  </pre>
<p>There are two noticeable changes: we've added an <kbd>#empty_option</kbd> key (to be used as the option shown if the user has not made a choice) and the <kbd>#ajax</kbd> key (which we will discuss in a bit more detail).</p>
<p>What we did is pretty simple. We declared a callback method to be triggered when a user makes a change to this form element, and we declared the HTML ID of the element that should be replaced with the result of the Ajax callback. And in the latter (which is a simple method on the same class), all we have to do is this:</p>
<pre>/** 
 * Ajax callback for the plugin configuration form elements. 
 * 
 * @param $form 
 * @param \Drupal\Core\Form\FormStateInterface $form_state 
 * 
 * @return array 
 */ 
public function pluginConfigAjaxCallback($form, FormStateInterface $form_state) { 
  return $form['plugin_configuration']; 
}  </pre>
<p>We return a form element (which we still have to define). An important lesson here is that Ajax responses in forms can return content as well (in the form of render arrays or even strings), which will be used to replace the HTML found by the ID specified in the <kbd>wrapper</kbd> key of the Ajax declaration. Alternatively, an <kbd>AjaxResponse</kbd> full of commands can also be returned to do more complex things, as we saw in the previous section.</p>
<p>Before we look at this new <kbd>plugin_configuration</kbd> form element, let's look at some of the other options that can be used inside the <kbd>#ajax</kbd> array:</p>
<ul>
<li><kbd>method</kbd>: This indicates the jQuery method to use when interacting with the <kbd>wrapper</kbd> element (if specified). The default is <kbd>replaceWith()</kbd>, but you can also use <kbd>append()</kbd>, <kbd>html()</kbd>, and others.</li>
<li><kbd>event</kbd>: This shows which event should be used to trigger the Ajax call. By default, the form element in question decides that. For example, when selecting an option in a select element or when typing something into a textfield.</li>
<li><kbd>progress</kbd>: This defines the indicator to be used while the Ajax request is taking place.</li>
<li><kbd>url</kbd>: A URL to trigger the Ajax request in case the <kbd>callback</kbd> was not specified. Typically, using the latter is more powerful as the entire <kbd>$form</kbd> and <kbd>$form_state</kbd> are passed as parameters and can be used in processing.</li>
</ul>
<p>I recommend you check out the documentation page (<span class="MsoHyperlink"><a href="https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x">https://api.drupal.org/api/drupal/core%21core.api.php/group/ajax/8.7.x</a></span>) for the Ajax API for more information about these options and the other ones that are available.</p>
<p>With that out of the way, we can go back to our form definition and add our missing parts, right after the <kbd>plugin</kbd> element:</p>
<pre>$form['plugin_configuration'] = [ 
  '#type' =&gt; 'hidden', 
  '#prefix' =&gt; '&lt;div id="plugin-configuration-wrapper"&gt;', 
  '#suffix' =&gt; '&lt;/div&gt;', 
]; 
 
$plugin_id = NULL; 
if ($importer-&gt;getPluginId()) { 
  $plugin_id = $importer-&gt;getPluginId(); 
} 
if ($form_state-&gt;getValue('plugin') &amp;&amp; $plugin_id !== $form_state-&gt;getValue('plugin')) { 
  $plugin_id = $form_state-&gt;getValue('plugin'); 
} 
 
if ($plugin_id) { 
  /** @var \Drupal\products\Plugin\ImporterInterface $plugin */ 
  $plugin = $this-&gt;importerManager-&gt;createInstance($plugin_id, ['config' =&gt; $importer]); 
  $form['plugin_configuration']['#type'] = 'details'; 
  $form['plugin_configuration']['#tree'] = TRUE; 
  $form['plugin_configuration']['#open'] = TRUE; 
  $form['plugin_configuration']['#title'] = $this-&gt;t('Plugin configuration for &lt;em&gt;@plugin&lt;/em&gt;', ['@plugin' =&gt; $plugin-&gt;getPluginDefinition()['label']]); 
  $form['plugin_configuration']['plugin'] = $plugin-&gt;getConfigurationForm($importer); 
}  </pre>
<p>First, we define the <kbd>plugin_configuration</kbd> form element as a <kbd>hidden</kbd> type. This means it will not be visible to users when the page loads for the first time. However, we do use the <kbd>#prefix</kbd> and <kbd>#suffix</kbd> options (common practice with the Drupal Form API) to wrap this element with a div that has the ID we indicated as the <kbd>wrapper</kbd> of our Ajax declaration. So, the goal is to have this element replaced each time an Ajax request is made, that is, each time a plugin is selected.</p>
<p>Next, we try to get the ID of the chosen plugin. First, we load it from the configuration entity in case we are looking at an edit form. However, we also check in the form state to see if one has been selected (and is different from the one in the entity). And if you are wondering how we can have the plugin in the form state, the answer is that after an Ajax call is made (triggered by the user selecting a plugin), the form gets rebuilt. Now, we can see what's in the form state and retrieve the plugin ID that was chosen.</p>
<p>Even more than that, if we get our hands on a plugin ID, we can completely change the <kbd>plugin_configuration</kbd> element, which in turn then gets returned by the Ajax callback to be used to replace our wrapper. So to sum up:</p>
<ol>
<li>The page loads for the first time (on a new form). The element is hidden.</li>
<li>The user selects a plugin and an Ajax request is triggered, which rebuilds the form.</li>
<li>As the form is rebuilt, we check for the selected plugin and alter the <kbd>plugin_configuration</kbd> element to reflect the selected plugin.</li>
<li>The Ajax response replaces the old element with the new, potentially changed, one.</li>
</ol>
<p>The new <kbd>plugin_configuration</kbd> element becomes a <kbd>details</kbd> one (a collapsible container for multiple elements), open by default, and which has one key, called <kbd>plugin</kbd>, onto which we add all the elements coming from the plugin. Moreover, we use the <kbd>#tree</kbd> property to indicate that when the form is submitted, the values of the elements are sent and stored in a tree that reflects the form element (a multidimensional array, basically). Otherwise, the form state values that are submitted get flattened and we lose their connection to the <kbd>plugin_configuration</kbd> element (which is also the Importer configuration entity field name we want to store the data under).</p>
<p>We are almost there. We can already go and create an importer entity, and when we select the JSON Importer, the new fieldset containing the URL field should show up below. But we still have one problem. If we save the form, the URL value will be stored inside an array keyed by <kbd>plugin</kbd>, inside the <kbd>plugin_configuration</kbd> field. So we need to clean things up a bit and we can do so inside the <kbd>save()</kbd> method.</p>
<p>Right before saving the entity, we can do this:</p>
<pre>$importer-&gt;set('plugin_configuration', $importer-&gt;getPluginConfiguration()['plugin']); </pre>
<p>So, we basically move the values one array up, removing the superfluous <kbd>plugin</kbd> level in the array (which was only needed to neatly organi<span><span>z</span></span>e the form tree).</p>
<p>With this, we are done. Well, not really, as we still need to handle the configuration schema aspect. Yes, remember those from <a href="77cab458-5612-468c-8010-12385708eb81.xhtml"><span class="MsoHyperlink">Chapter 6</span></a>, <em>Data Modeling and Storage</em>, and <a href="392cdb70-e52a-42d1-b782-28d6eb726810.xhtml"><span class="MsoHyperlink">Chapter 7</span></a>, <em>Your Own Custom Entity and Plugin Types</em>? We are now going to see how we can work with our own dynamic configuration schema, similar to how we did with the ones needed for the field plugins in <a href="f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml"><span class="MsoHyperlink">Chapter 9</span></a>, <em>Custom Fields</em>. But why do we need a dynamic configuration schema?</p>
<p>Before this refactoring, we knew the exact fields of the importer configuration entity and we could declare the schema for each easily (as we did). However, now plugins can come with their own individual fields, so we need to make sure they can provide their own schema definitions for the respective data. So how can we do this?</p>
<p>First, inside our <kbd>importer.schema.yml</kbd> file, we need to remove the <kbd>url</kbd> field schema definition as it no longer exists. We replace it, however, with one for the new field we created, namely the <kbd>plugin_configuration</kbd> array of values that came from the plugin:</p>
<pre>plugin_configuration: 
  type: products.importer.plugin.[%parent.plugin] </pre>
<p>Here is where things become interesting. We don't know what fields there will be inside, so we instead reference another type (our own). Moreover, the name of the type is dynamic. We have a prefix (<kbd>products.importer.plugin.</kbd>) followed by a variable name given by the value of the plugin field of the parent <em>(</em>the main configuration entity<em>)</em>. So basically, if a given configuration entity uses the <kbd>json</kbd> plugin, the type of schema definition will be <kbd>products.importer.plugin.json</kbd>. So now, it's the responsibility of whoever creates new plugins to also provide their own schema definitions for their own fields (like we did in <a href="f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml"><span class="MsoHyperlink">Chapter 9</span></a>, <em>Custom Fields,</em> when we defined field plugins).</p>
<p>But before that can happen, we need to define this new type we created:</p>
<pre>products.importer.plugin.*: 
  type: mapping 
  label: 'Plugin configuration' </pre>
<p>So essentially our new type extends from <kbd>mapping</kbd> and has a simple label. Of course, it applies to all that start with that name (hence the wildcard we encountered before).</p>
<p>Now, we can add the schema definition for our single <kbd>json</kbd> Importer plugin:</p>
<pre>products.importer.plugin.json: 
  type: mapping 
  label: Plugin configuration for the Json importer plugin 
  mapping: 
    url: 
      type: uri 
      label: Uri  </pre>
<p>As you can see, we now have our first instance of the <kbd>products.importer.plugin</kbd> type, which contains the <kbd>url</kbd> field and which is inside the <kbd>plugin_configuration</kbd> field of the configuration entity—reflecting a simple array hierarchy.</p>
<p>But the point of this dynamic declaration is that other modules that define new plugins can now also define their own instances of the <kbd>products.importer.plugin.*</kbd> schema definitions to map their own fields. It is no longer the responsibility of the configuration entity (schema) to "guess" what field types are being used on each plugin.</p>
<p>With this, our refactoring is complete. Drupal is well aware of the type of data the configuration entity is saving, even if it is in part relating to external input (the selected plugin). So that means we can create (if we want) another importer plugin that uses a CSV file for the product data. But we'll see how to do that in a later chapter when we talk about file handling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">States (Form) system</h1>
                </header>
            
            <article>
                
<p>The last thing we are going to look at in this chapter is the States system of the Form API (not to be confused with the State API we covered in <a href="77cab458-5612-468c-8010-12385708eb81.xhtml"><span class="MsoHyperlink">Chapter 6</span></a>, <em>Data Modeling and Storage</em>). This allows us to define our form elements to behave somewhat dynamically based on the user interaction with the form. It doesn't use Ajax but relies on JavaScript to handle the manipulations. This is another great example of client-side behavior where we don't have to write a single line of JavaScript. So, let's see what this is.</p>
<p>The <kbd>#states</kbd> are simple properties we can add to form elements, which have the role of changing them depending on the <em>state</em> of other elements. The best way to understand this is through some examples. Imagine these two form elements:</p>
<pre>$form['kids'] = [ 
  '#type' =&gt; 'checkbox', 
  '#title' =&gt; $this-&gt;t('Do you have kids?'), 
]; 
 
$form['kid_number'] = [ 
  '#type' =&gt; 'textfield', 
  '#title' =&gt; $this-&gt;t('How many kids do you have?'), 
]; </pre>
<p>In the first, we ask the user if they have kids (using a simple checkbox), while in the second ,we ask them how many kids they have. But why should the user actually see the second element if they don't have kids? This is where the <kbd>#states</kbd> property comes into play, and its role is to manipulate an element depending on the <em>state</em> of another. So instead, we can have this:</p>
<pre>$form['kid_number'] = [ 
  '#type' =&gt; 'textfield', 
  '#title' =&gt; $this-&gt;t('How many kids do you have?'), 
  '#states' =&gt; [ 
    'visible' =&gt; [ 
      'input[name="kids"]' =&gt; ['checked' =&gt; TRUE], 
    ], 
  ], 
]; </pre>
<p>Now, the element for specifying the number of kids is only going to be visible if the <em>state</em> of the <kbd>kid</kbd> element is checked.</p>
<p>The <kbd>#states</kbd> property is an array whose key is the actual <em>state</em> that needs to be applied to the current element if the conditions inside are met. And the conditions can vary, but they all depend on a CSS selector (in our case <kbd>input[name="kids"]</kbd> matching another element).</p>
<p>Our example can also be written with this reverse logic:</p>
<pre>'#states' =&gt; array( 
  'invisible' =&gt; array( 
    'input[name="kids"]' =&gt; array('checked' =&gt; FALSE), 
  ), 
),  </pre>
<p>Apart from <kbd>visible</kbd> and <kbd>invisible</kbd>, the following <em>states</em> can be also applied to form elements: <kbd>enabled</kbd>, <kbd>disabled</kbd>, <kbd>required</kbd>, <kbd>optional</kbd>, <kbd>checked</kbd>, <kbd>unchecked</kbd>, <kbd>expanded</kbd> and <kbd>collapsed</kbd>. As for the conditions that can "trigger" these <em>states</em>, we can have the following (apart from <kbd>checked</kbd>, which we already saw): <kbd>empty</kbd>, <kbd>filled</kbd>, <kbd>unchecked</kbd>, <kbd>expanded</kbd>, <kbd>collapsed</kbd> and <kbd>value</kbd>.</p>
<p>So, for example, we can even control the <em>state</em> of an element depending on the value the user selected on another. Combining these possibilities can greatly improve our forms when it comes to user experience, decluttering, and even building logical form trees.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took on the client-side and talked about JavaScript and client-side capabilities in Drupal 8. We started with the approach we need to take when writing JavaScript in a Drupal context. We learned about behaviors, why they are important, and how to use them. We also saw how we can pass around data from the server (Drupal) to the client-side and make use of it in JavaScript.</p>
<p>Funnily enough, we then switched to a no-JavaScript-allowed policy for the rest of the chapter. We did this to prove how powerful the Drupal Ajax API is, with which we can perform complex server-to-client interactions even if we are not frontend developers that can write JavaScript code. And to demonstrate the API, we first looked at how simple links can be turned into Ajax requests. We followed that up with an important refactor <span><span>of</span></span> our earlier product importer functionality which relied on Ajax to make the Importer configuration entity form dynamic (dependent on the selected plugin). Let's not forget another nugget of information—dynamic configuration schema—which allows us to decouple the configuration entity data definitions from that of their selected plugins.</p>
<p>Finally, we finished by looking at the States system of the Form API which allows us to declaratively code client-side manipulations onto our form elements, essentially making them dependent on the user's interaction with the form.</p>
<p>In the next chapter, we are going to talk about internationalization and translations to make sure our applications can be used anywhere around the globe.</p>


            </article>

            
        </section>
    </body></html>