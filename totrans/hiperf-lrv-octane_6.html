<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.2.1">Using Queues to Apply the Asynchronous Approach in Your Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we saw how delegating some tasks to external functions in the controller while creating the HTTP request can have a positive impact from a performance perspective. </span><span class="koboSpan" id="kobo.3.2">However, the case analyzed in the previous chapter was limited to a scoped topic: querying the database and populating the cache. </span><span class="koboSpan" id="kobo.3.3">This strategy is also</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.4.1"> known as the </span><em class="italic"><span class="koboSpan" id="kobo.5.1">cache-only strategy</span></em><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">The process only needs the data to be retrieved from </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This type of approach works in a case where information needs to be retrieved from a data source. </span><span class="koboSpan" id="kobo.8.2">Typically, applications are more complex than this, such as when executing specific tasks that need to modify and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">process data.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Think about a scenario where there is a request that starts a backup process. </span><span class="koboSpan" id="kobo.10.2">Typically, a backup process takes time to be completed. </span><span class="koboSpan" id="kobo.10.3">Implementing a synchronous approach means that the controller (who serves the request) keeps the client (the web page) on hold until the process is completed. </span><span class="koboSpan" id="kobo.10.4">Two bad things about this solution are that the user sees a long waiting loader in the browser, and the solution could fall into the </span><em class="italic"><span class="koboSpan" id="kobo.11.1">request </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.12.1">time-out</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1"> scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">For asynchronous implementation, an additional tool is typically used to manage the list of task execution requests. </span><span class="koboSpan" id="kobo.14.2">To allow asynchronous implementation, we need a mechanism that works as a queue where we have a producer that needs the job to be executed (the producer produces jobs requests and feeds the queue) and a consumer that extracts the job requests from the queue and performs the job, one at a time. </span><span class="koboSpan" id="kobo.14.3">Typically, a queue system adds some features to monitor the queues, manage the queues (empty the queues), manage prioritization, and manage multiple channels </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">or queues.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Laravel provides a mechanism to implement all the queue logic management, such as putting a task in the queue, extracting a job from a queue, managing failed tasks, and notifying the user </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">about executions.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">To store the list of tasks, Laravel allows the developer to select one of the queue backends available: the database, Redis, Amazon SQS, </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">or beanstalkd.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">This chapter aims to help you understand what a queuing mechanism is, how it can be used with Laravel, and how it is configured – because an asynchronous approach with queues not only reduces the response time but also implements a different user experience, especially when time-consuming tasks have to </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">be handled.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Introducing the queue mechanism </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">in Laravel</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Installing and configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the queue</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Managing </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the queues</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Managing queues with Redis and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">monitoring them</span></span></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.32.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.33.1">Thanks to the previous chapters, we assume you have your basic Laravel application installed with Laravel Octane. </span><span class="koboSpan" id="kobo.33.2">For the current chapter, you can use Octane with Swoole, Open Swoole, </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">or RoadRunner.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The source code for the example described in the current chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">here: </span></span><a href="https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch06"><span class="No-Break"><span class="koboSpan" id="kobo.37.1">https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.38.1">.</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.39.1">Introducing the queue mechanism in Laravel</span></h1>
<p><span class="koboSpan" id="kobo.40.1">We will implement</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.41.1"> a simple use case in order to shed light on the asynchronous aspects and how much a queuing mechanism can improve the user experience for the</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.42.1"> end users of our </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">For every request, a time-consuming task will be executed. </span><span class="koboSpan" id="kobo.44.2">To simulate the time-consuming task, we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">sleep()</span></strong><span class="koboSpan" id="kobo.46.1"> to last 3 seconds. </span><span class="koboSpan" id="kobo.46.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">sleep()</span></strong><span class="koboSpan" id="kobo.48.1"> function, which suspends execution for a certain number of seconds, is intended to simulate the execution of a task that may take some time to implement. </span><span class="koboSpan" id="kobo.48.2">In a real case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">sleep()</span></strong><span class="koboSpan" id="kobo.50.1"> function is replaced with complex business logic that could take a certain amount of time </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">to complete.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">With the synchronous approach, the request will hold the response to the browser for 3 seconds. </span><span class="koboSpan" id="kobo.52.2">As a user, you will request the page, wait for 3 seconds, and then the page will be shown. </span><span class="koboSpan" id="kobo.52.3">The page will </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.53.1">contain the message that the operation is completed – so you are safe and sure that the process is correctly executed in 3 seconds, but you have to wait for </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the answer.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">With the asynchronous approach, the routing mechanism takes charge of the request; a job is created in the </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.56.1">queue to call the logic, which includes a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">sleep(3)</span></strong><span class="koboSpan" id="kobo.58.1"> function to simulate a time-consuming operation, provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">ProcessSomething::handle()</span></strong><span class="koboSpan" id="kobo.60.1"> function. </span><span class="koboSpan" id="kobo.60.2">After the job is created in the queue, the response is generated and sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">The user will receive a response in a few milliseconds without waiting for the task to be completed. </span><span class="koboSpan" id="kobo.62.2">You know that the task has been pushed into the queue, and some workers will execute </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the job.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">To carry out the asynchronous approach, we</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.65.1"> are going to do </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.67.1">Install the queue mechanism, creating a table in the database to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">job queued.</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">Create the class for implementing the logic of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the job.</span></span></li>
<li><span class="koboSpan" id="kobo.71.1">Implement a time-consuming logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">handle()</span></strong><span class="koboSpan" id="kobo.73.1"> method of the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">job class.</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">Create a route for calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">handle()</span></strong><span class="koboSpan" id="kobo.77.1"> method in the classical </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">synchronous way.</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">Create another route for asynchronously calling the job through the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">queue mechanism.</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Analyze the result of calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">two routes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.83.1">First, we will create the data structure that will allow the queue mechanism to store the list of jobs. </span><span class="koboSpan" id="kobo.83.2">We can use a MySQL database or Redis. </span><span class="koboSpan" id="kobo.83.3">To simplify understanding, we will initially use the MySQL database-based queuing mechanism (because it is more basic and simpler). </span><span class="koboSpan" id="kobo.83.4">Subsequently, we will use the more advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">Redis-based system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.85.1">Redis</span></p>
<p class="callout"><span class="koboSpan" id="kobo.86.1">Redis is an open source data store used for storing data, caching values, and queuing data/messages. </span><span class="koboSpan" id="kobo.86.2">Working mainly in memory, one of its main features </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">is speed.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Now, we are going to </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.89.1">configure the database-based queuing mechanism in </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.90.1">a </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">Laravel application.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.92.1">Installing and configuring the queue</span></h1>
<p><span class="koboSpan" id="kobo.93.1">To create the data </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.94.1">structure to store the jobs in the queue, we can execute the command in the terminal in our Laravel </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">project directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
php artisan queue:table</span></pre>
<p><span class="koboSpan" id="kobo.97.1">The command is provided by Laravel without the need to install </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">additional packages.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">queue:table</span></strong><span class="koboSpan" id="kobo.101.1"> command creates a new migration file for creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">jobs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1"> table.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The file is created in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">database/migrations/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> directory.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.107.1"><img alt="Figure 6.1: The migration file for creating the jobs table" src="image/Figure_6.01_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.108.1">Figure 6.1: The migration file for creating the jobs table</span></p>
<p><span class="koboSpan" id="kobo.109.1">The migration will </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.110.1">create </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.112.1">A new table </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">'jobs'</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">'id'</span></strong><span class="koboSpan" id="kobo.116.1">: For the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">unique identifier</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">'queue'</span></strong><span class="koboSpan" id="kobo.119.1">: The queue name, helpful for controlling the queue via the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">command line</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">'payload'</span></strong><span class="koboSpan" id="kobo.122.1">: The data in JSON format that contains information to manage and launch the task by the consumer of </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">'attempts'</span></strong><span class="koboSpan" id="kobo.125.1">: The number of attempts to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the jobs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">'reserved_at'</span></strong><span class="koboSpan" id="kobo.128.1">: The timestamp when the task is taken in charge by </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the consumer</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">'available_at'</span></strong><span class="koboSpan" id="kobo.131.1">: When the task is available to </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">be consumed</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">'created_at'</span></strong><span class="koboSpan" id="kobo.134.1">: When the job is created in </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">the queue</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.136.1">An example of the JSON </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.137.1">payload (in the payload field) is </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
{
  "displayName" : "App\\Jobs\\ProcessSomething",
  "failOnTimeout" : false,
  "retryUntil" : null,
  "data" : {
    "command" :
      "O:25:\"App\\Jobs\\ProcessSomething\":0:{}",
    "commandName" : "App\\Jobs\\ProcessSomething"
  },
  "maxExceptions" : null,
  "maxTries" : null,
  "uuid" : "e8b0c6c7-29ce-4108-a74c-08c70bb679a6",
  "timeout" : null,
  "backoff" : null,
  "job" : "Illuminate\\Queue\\CallQueuedHandler@call"
}</span></pre>
<p><span class="koboSpan" id="kobo.140.1">The JSON payload has </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">some attributes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">failOnTimeout</span></strong><span class="koboSpan" id="kobo.143.1">: The Boolean field indicating whether the job should fail when it </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">times out</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">retryUntil</span></strong><span class="koboSpan" id="kobo.146.1">: The timestamp (integer field) indicating when the job should </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">time out</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">maxExceptions</span></strong><span class="koboSpan" id="kobo.149.1">: The number (integer field) of times to attempt a job after </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">an exception</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">maxTries</span></strong><span class="koboSpan" id="kobo.152.1">: The number (integer field) of times to attempt </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">a job</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">uuid</span></strong><span class="koboSpan" id="kobo.155.1">: The UUID (string field) of </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the job</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">timeout</span></strong><span class="koboSpan" id="kobo.158.1">: The number (integer field) of seconds the job </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">can run</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">backoff</span></strong><span class="koboSpan" id="kobo.161.1">: The number of seconds to wait before retrying a job that encountered an uncaught exception – can be an array of integers to track the seconds for each attempt (a job could be attempted more than once because </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">of errors)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">job</span></strong><span class="koboSpan" id="kobo.164.1">: The name (string field) of the queued </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">job class</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.166.1">Once we have created the</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.167.1"> schema definition for the table with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">php artisan queue:table</span></strong><span class="koboSpan" id="kobo.169.1"> command, we can create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">jobs</span></strong><span class="koboSpan" id="kobo.171.1"> table in the database via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">migrate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">For creating the table in the database, you can launch the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">migrate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
php artisan migrate</span></pre>
<p><span class="koboSpan" id="kobo.178.1">To check that the correct table has been created, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">db:table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
php artisan db:table jobs</span></pre>
<p><span class="koboSpan" id="kobo.182.1">Now that all the data structure is in place, we have to create the files to implement the logic of </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">our jobs.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.184.1">Managing the queues</span></h1>
<p><span class="koboSpan" id="kobo.185.1">For managing</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.186.1"> the jobs, in Laravel, by convention, we have one class for each job. </span><span class="koboSpan" id="kobo.186.2">The job class has to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">handle()</span></strong><span class="koboSpan" id="kobo.188.1"> method. </span><span class="koboSpan" id="kobo.188.2">The method </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">handle()</span></strong><span class="koboSpan" id="kobo.190.1"> is invoked by the framework when the job has to </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">be executed.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">For creating the class to manage the jobs, see </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
php artisan make:job ProcessSomething</span></pre>
<p><span class="koboSpan" id="kobo.195.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">make:job</span></strong><span class="koboSpan" id="kobo.197.1"> command, a new file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">app/Jobs/ProcessSomething.php</span></strong><span class="koboSpan" id="kobo.199.1">, that includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ProcessSomething</span></strong><span class="koboSpan" id="kobo.201.1"> class with some methods ready to be filled with the logic is created. </span><span class="koboSpan" id="kobo.201.2">The primary methods are the constructor and the method invoked for managing the job, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">handle()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">We will implement</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.205.1"> the logic into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">handle()</span></strong><span class="koboSpan" id="kobo.207.1"> method. </span><span class="koboSpan" id="kobo.207.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">app/Jobs/ProcessSomething.php</span></strong><span class="koboSpan" id="kobo.209.1"> file, insert </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
public function handle()
{
    Log::info('Job processed START');
    sleep(3);
    Log::info('Job processed   END');
}</span></pre>
<p><span class="koboSpan" id="kobo.212.1">As an example of a time-consuming operation, we are going to pause the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">handle()</span></strong><span class="koboSpan" id="kobo.214.1"> method for 3 seconds via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">sleep()</span></strong><span class="koboSpan" id="kobo.216.1"> function. </span><span class="koboSpan" id="kobo.216.2">This means that the thread will be suspended for 3 seconds. </span><span class="koboSpan" id="kobo.216.3">We will log the method execution’s start and end to track more information. </span><span class="koboSpan" id="kobo.216.4">You can find the logs in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">storage/logs/laravel.log</span></strong><span class="koboSpan" id="kobo.218.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">default configuration.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.220.1">The classical synchronous approach</span></h2>
<p><span class="koboSpan" id="kobo.221.1">Typically, with a </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.222.1">synchronous approach, if you call the method, the response takes </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">3 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">routes/web.php</span></strong><span class="koboSpan" id="kobo.226.1"> file, we are going to add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">/time</span></strong><span class="koboSpan" id="kobo.228.1"> route for dispatching (requesting the execution of) the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">job synchronously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
Route::get('/time-consuming-request-sync', function () {
    $start = hrtime(true);
    ProcessSomething::dispatchSync();
    $time = hrtime(true) - $start;
    return view('result', [
        'title' =&gt; url()-&gt;current(),
        'description' =&gt; 'the task has been complete with
                          dispatchSync()',
        'time' =&gt; $time,
    ]);
});</span></pre>
<p><span class="koboSpan" id="kobo.231.1">Calling the static </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">dispatchSync()</span></strong><span class="koboSpan" id="kobo.233.1"> method allows you to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">handle()</span></strong><span class="koboSpan" id="kobo.235.1"> method (through the queue mechanism) synchronously. </span><span class="koboSpan" id="kobo.235.2">This is the classic scenario we have in PHP when we call </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">a method.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">To render the view, we </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.238.1">have to implement the </span><em class="italic"><span class="koboSpan" id="kobo.239.1">result</span></em><span class="koboSpan" id="kobo.240.1"> view, a basic blade template to render the title, description, and time set in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">view()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">resources/views/result.blade.php</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.245.1">blade file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
&lt;!DOCTYPE html&gt;
&lt;html lang="{{ str_replace('_', '-', app()-&gt;getLocale()) }}"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width,
    initial-scale=1"&gt;
  &lt;title&gt;Laravel&lt;/title&gt;
&lt;/head&gt;
&lt;body class="antialiased"&gt;
  &lt;div class="relative flex items-top justify-center
    min-h-screen bg-gray-100 dark:bg-gray-900
    sm:items-center py-4 sm:pt-0"&gt;
    &lt;div class="max-w-6xl mx-auto sm:px-6 lg:px-8"&gt;
      &lt;div class="mt-8 bg-white dark:bg-gray-800
        overflow-hidden shadow sm:rounded-lg"&gt;
        &lt;div class="grid grid-cols-1"&gt;
          &lt;div class="p-6"&gt;
            &lt;div class="flex items-center"&gt;
              &lt;div class="ml-4 text-lg leading-7
                font-semibold"&gt;{{ $title}}&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="ml-12"&gt;
              &lt;div class="mt-2 text-gray-900
                dark:text-gray-900 text-2xl"&gt;
                {{ $description }}
              &lt;/div&gt;
              &lt;div class="mt-2 text-gray-900
                dark:text-gray-900 text-2xl"&gt;
                {{ $time / 1_000_000 }} milliseconds
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</span></pre>
<p><span class="koboSpan" id="kobo.247.1">The blade file will show the result on the page displaying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">$description</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">$time</span></strong><span class="koboSpan" id="kobo.251.1"> parameters. </span><span class="koboSpan" id="kobo.251.2">If you request the page via your web browser at </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">http://localhost:8000/time-consuming-request-sync</span></strong><span class="koboSpan" id="kobo.253.1">, you must wait at least 3 seconds </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.254.1">before the page is fully rendered. </span><span class="koboSpan" id="kobo.254.2">This figure shows that the time value is slightly more than </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">3,000 milliseconds:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.256.1"><img alt="Figure 6.2: The synchronous job execution" src="image/Figure_6.02_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Figure 6.2: The synchronous job execution</span></p>
<p><span class="koboSpan" id="kobo.258.1">This means your job takes 3 seconds, and Laravel waits to send the response until the job </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">This is probably nothing special because, as PHP developers, we are used to managing synchronous jobs. </span><span class="koboSpan" id="kobo.260.2">Even if we are not managing queues, the PHP engine synchronously drives the methods and functions. </span><span class="koboSpan" id="kobo.260.3">Some other languages have the async call for functions – so now, let’s see how to dispatch the execution to another process that can asynchronously execute </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the job.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.262.1">The asynchronous approach</span></h2>
<p><span class="koboSpan" id="kobo.263.1">Instead of using the</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.264.1"> sync method, we will dispatch the jobs through </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">To extract the jobs from the queue, it is necessary to start a specific process for the consumer to take over the various tasks. </span><span class="koboSpan" id="kobo.266.2">To begin the process, you can execute the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">artisan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
php artisan queue:work</span></pre>
<p><span class="koboSpan" id="kobo.270.1">The command checks whether any jobs are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">jobs</span></strong><span class="koboSpan" id="kobo.272.1"> table and </span><em class="italic"><span class="koboSpan" id="kobo.273.1">consumes</span></em><span class="koboSpan" id="kobo.274.1"> the queue by deleting the row after the job </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">From the </span><em class="italic"><span class="koboSpan" id="kobo.277.1">producer</span></em><span class="koboSpan" id="kobo.278.1"> side, in the router logic, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">dispatch()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.280.1">functions available:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
Route::get('/time-consuming-request-async', function () {
    $start = hrtime(true);
    dispatch(new ProcessSomething());
// OR you can use ProcessSomething::dispatch();
    $time = hrtime(true) - $start;
    return view('result', [
        'title' =&gt; url()-&gt;current(),
        'description' =&gt; 'the task has been queued',
        'time' =&gt; $time,
    ]);
});</span></pre>
<p><span class="koboSpan" id="kobo.282.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">dispatch()</span></strong><span class="koboSpan" id="kobo.284.1"> functions need the instance of the job class as a parameter. </span><span class="koboSpan" id="kobo.284.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">dispatch()</span></strong><span class="koboSpan" id="kobo.286.1"> function will </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.287.1">send the job instance to the queue and release the control to the caller, with no need to wait for the complete execution of the job. </span><span class="koboSpan" id="kobo.287.2">In the end, the response is created immediately without waiting for the job to be completed, instead of the typical behavior where the response is created once the job </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">We are just sending an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">ProcessSomething</span></strong><span class="koboSpan" id="kobo.291.1"> class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">dispatch()</span></strong><span class="koboSpan" id="kobo.293.1"> method. </span><span class="koboSpan" id="kobo.293.2">The convention is that the </span><em class="italic"><span class="koboSpan" id="kobo.294.1">consumer</span></em><span class="koboSpan" id="kobo.295.1"> will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">handle()</span></strong><span class="koboSpan" id="kobo.297.1"> method when taking care of </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the job.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Now, you can open the browser and call the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">URL, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">http://localhost:8000/time-consuming-request-async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.303.1"><img alt="Figure 6.3: The asynchronous execution" src="image/Figure_6.03_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.304.1">Figure 6.3: The asynchronous execution</span></p>
<p><span class="koboSpan" id="kobo.305.1">To allow the browser to receive the response, we have to be sure that we launched </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">two commands:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">php artisan octane:start</span></strong><span class="koboSpan" id="kobo.308.1">: For launching the Octane server, listening on </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">8000</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">php artisan queue:work</span></strong><span class="koboSpan" id="kobo.312.1">: For launching the </span><em class="italic"><span class="koboSpan" id="kobo.313.1">consumer</span></em><span class="koboSpan" id="kobo.314.1"> service, for executing </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the jobs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.316.1">If you want to see the status</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.317.1"> of the queue, you can execute it via the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">command line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
php artisan queue:monitor default</span></pre>
<p><span class="koboSpan" id="kobo.320.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">queue:monitor</span></strong><span class="koboSpan" id="kobo.322.1"> command will show the status of the queues and the jobs in the queue for </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">each queue:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 6.4: The queue monitor tool" src="image/Figure_6.04_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 6.4: The queue monitor tool</span></p>
<p><span class="koboSpan" id="kobo.326.1">If you have pending jobs in the queue, you will see the number of waiting jobs in the </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">square brackets:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.328.1"><img alt="Figure 6.5: The queue with some waiting jobs" src="image/Figure_6.05_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.329.1">Figure 6.5: The queue with some waiting jobs</span></p>
<p><span class="koboSpan" id="kobo.330.1">In the example, we have 76 jobs in </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">If you use a database as a backend for managing queues, I suggest increasing your confidence directly by </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.333.1">querying the jobs table </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">with SQL.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">You can access the database with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">artisan </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">db</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
php artisan db</span></pre>
<p><span class="koboSpan" id="kobo.340.1">Then, you can execute SQL queries; for example, you could count how many rows each </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">queue has:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
select count(id) as jobs_count, queue
from jobs
group by queue;</span></pre>
<p><span class="koboSpan" id="kobo.343.1">The SQL command counts the number of identifiers (the count) from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">jobs</span></strong><span class="koboSpan" id="kobo.345.1"> table, grouping the rows by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">queue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1"> field.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.348.1"><img alt="Figure 6.6: Executing queries on the jobs table" src="image/Figure_6.06_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.349.1">Figure 6.6: Executing queries on the jobs table</span></p>
<p><span class="koboSpan" id="kobo.350.1">If you have more than one job in the queue, please be sure that you are running </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">the consumer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
php artisan queue:work</span></pre>
<p><span class="koboSpan" id="kobo.353.1">If you want to have more than one consumer that executes your jobs in parallel, you can launch </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">queue:work</span></strong><span class="koboSpan" id="kobo.355.1"> more than once. </span><span class="koboSpan" id="kobo.355.2">If you launch </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">queue:work</span></strong><span class="koboSpan" id="kobo.357.1"> twice, you will have two consumers that extract the jobs from </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">If you have to manage</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.360.1"> time-consuming tasks, using a queue is not just implementing an asynchronous approach to manage tasks. </span><span class="koboSpan" id="kobo.360.2">It is a way to control the level of parallelism and contain the number of concurrent time-consuming tasks that your architecture can take charge of or handle. </span><span class="koboSpan" id="kobo.360.3">By managing time-consuming tasks synchronously, if there were a high number of requests, you could reach a high number of concurrent requests on the web server, and your system could collapse due to the high </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">resource usage.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Delegating tasks to specific workers means that you keep the load on the workers used for serving the requests lighter, and you can launch the consumer processes on a dedicated instance or virtual machine. </span><span class="koboSpan" id="kobo.362.2">You can also increase the number of processes for </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the consumers.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.364.1">Managing multiple queues</span></h2>
<p><span class="koboSpan" id="kobo.365.1">You can use </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.366.1">more than one queue – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">first</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.368.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">second</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">When you have to assign the job to a queue, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">onQueue()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
ProcessSomething::dispatch()-&gt;onQueue("first");</span></pre>
<p><span class="koboSpan" id="kobo.375.1">You can control </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">both queues:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
php artisan queue:monitor first,second</span></pre>
<p><span class="koboSpan" id="kobo.378.1">Then, you can launch the consumer for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">first"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1"> queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
php artisan queue:work --queue=first</span></pre>
<p><span class="koboSpan" id="kobo.383.1">And then for the queue </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">"second"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
php artisan queue:work --queue=second</span></pre>
<p><span class="koboSpan" id="kobo.388.1">You can, for example, launch two consumers for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">"first"</span></strong><span class="koboSpan" id="kobo.390.1"> queue and only one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">"second"</span></strong><span class="koboSpan" id="kobo.392.1"> queue, giving more priority to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">"first"</span></strong><span class="koboSpan" id="kobo.394.1"> queue (because it has two dedicated consumers instead of one). </span><span class="koboSpan" id="kobo.394.2">To achieve this, in different shell environments, you can launch </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
php artisan queue:work --queue=first
php artisan queue:work --queue=first
php artisan queue:work --queue=second</span></pre>
<p><span class="koboSpan" id="kobo.397.1">If you need to clear the queue and delete all pending tasks, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">queue:clear</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
php artisan queue:clear database --queue=first</span></pre>
<p><span class="koboSpan" id="kobo.401.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">database</span></strong><span class="koboSpan" id="kobo.403.1"> is the name of the connection (we are using the database now; in the next section, we will use another type of connection), and we can also define the queue via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">--queue</span></strong><span class="koboSpan" id="kobo.405.1"> parameter. </span><span class="koboSpan" id="kobo.405.2">You can also specify more than </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">one queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
php artisan queue:clear database --queue=first,second</span></pre>
<p><span class="koboSpan" id="kobo.408.1">The connection is optional; if we don’t specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">database</span></strong><span class="koboSpan" id="kobo.410.1"> (the connection) on the command line, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">QUEUE_CONNECTION</span></strong><span class="koboSpan" id="kobo.412.1"> environment parameter (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">.env</span></strong><span class="koboSpan" id="kobo.414.1"> file) will </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Now we have seen how to create and manage queues with the database as the backend, let’s try to configure </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.417.1">Redis as </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the backend.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.419.1">Managing queues with Redis and monitoring them</span></h1>
<p><span class="koboSpan" id="kobo.420.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">database</span></strong><span class="koboSpan" id="kobo.422.1"> as the connection is convenient for people who start using the queue and have already had the database set up for storing application data, for example. </span><span class="koboSpan" id="kobo.422.2">Why use Redis instead of a</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.423.1"> database? </span><span class="koboSpan" id="kobo.423.2">Because Redis has more optimization for managing queues than a database, and you can use Laravel Horizon to monitor the queue. </span><span class="koboSpan" id="kobo.423.3">Laravel </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.424.1">Horizon provides a web dashboard for monitoring your queues and the metrics about the usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">the queues.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">As the first step of managing queues with Redis, first, let’s install the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">Redis service.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.428.1">Installing Redis</span></h2>
<p><span class="koboSpan" id="kobo.429.1">Installing Redis means that </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.430.1">you have added software and service to your stack. </span><span class="koboSpan" id="kobo.430.2">If you are a </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.431.1">macOS user, you can install it </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">via </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.433.1">Homebrew</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
brew install redis
brew services start redis</span></pre>
<p><span class="koboSpan" id="kobo.436.1">The first command installs the software; the second one starts </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">You can use your package manager if you have a GNU/Linux distribution; Redis is included in most </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">GNU/Linux distributions.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Alternatively, you can use Sail (as shown previously in </span><a href="B17728_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.441.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.442.1">, </span><em class="italic"><span class="koboSpan" id="kobo.443.1">Configuring the Swoole Application Server</span></em><span class="koboSpan" id="kobo.444.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.445.1">Setting up Laravel Sail</span></em><span class="koboSpan" id="kobo.446.1"> section, during the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">of Swoole).</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">Execute the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">sail:install</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
php artisan sail:install</span></pre>
<p><span class="koboSpan" id="kobo.452.1">Be sure you also select the Redis service (option </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">number </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.456.1"><img alt="Figure 6.7: The Laravel Sail configuration for Redis" src="image/Figure_6.07_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.457.1">Figure 6.7: The Laravel Sail configuration for Redis</span></p>
<p><span class="koboSpan" id="kobo.458.1">In the case that you need</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.459.1"> more than one service (for example, both MySQL and Redis), you </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.460.1">can select </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">0,3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1"> (comma-separated).</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Once the Redis service runs, we can start configuring the queue mechanism to use Redis as </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">the connection.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.465.1">Configuring Redis</span></h2>
<p><span class="koboSpan" id="kobo.466.1">In the environment</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.467.1"> configuration file placed in the Laravel project directory (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">.env</span></strong><span class="koboSpan" id="kobo.469.1"> file), we have to adjust </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">some parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
QUEUE_CONNECTION=redis
REDIS_CLIENT=predis
REDIS_HOST=localhost
REDIS_PASSWORD=null
REDIS_PORT=6379</span></pre>
<p><span class="koboSpan" id="kobo.472.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">QUEUE_CONNECTION</span></strong><span class="koboSpan" id="kobo.474.1">, you define the connection to be </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">used (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">redis</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">REDIS_CLIENT</span></strong><span class="koboSpan" id="kobo.480.1">, you can define the client to be used by Laravel to connect to the Redis service. </span><span class="koboSpan" id="kobo.480.2">The default is </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">phpredis</span></strong><span class="koboSpan" id="kobo.482.1"> (which uses the PECL module), or you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">predis</span></strong><span class="koboSpan" id="kobo.484.1">, which uses the PHP package: </span><a href="https://github.com/predis/predis"><span class="koboSpan" id="kobo.485.1">https://github.com/predis/predis</span></a><span class="koboSpan" id="kobo.486.1">. </span><span class="koboSpan" id="kobo.486.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">phpredis</span></strong><span class="koboSpan" id="kobo.488.1"> module is written in C, so could be faster than a </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">predis</span></strong><span class="koboSpan" id="kobo.490.1"> implementation (which is pure PHP). </span><span class="koboSpan" id="kobo.490.2">On the other hand, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">predis</span></strong><span class="koboSpan" id="kobo.492.1"> implementation has a lot of features and the community and the development team are </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">really supportive.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">If you want to change the name of the default queue (typically, “</span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">default</span></strong><span class="koboSpan" id="kobo.496.1">”), you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">REDIS_QUEUE</span></strong><span class="koboSpan" id="kobo.498.1"> parameter into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">env</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.501.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
REDIS_QUEUE=yourdefaultqueue</span></pre>
<p><span class="koboSpan" id="kobo.503.1">About the connection </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.504.1">between Laravel and Redis service, if you are not familiar with Redis, my suggestion is to start by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">predis</span></strong><span class="koboSpan" id="kobo.506.1"> package just because it requires adding </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">a package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
composer require predis/predis</span></pre>
<p><span class="koboSpan" id="kobo.509.1">If you are installing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">predis/predis</span></strong><span class="koboSpan" id="kobo.511.1"> package, you have to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">REDIS_CLIENT</span></strong><span class="koboSpan" id="kobo.513.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">predis</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
REDIS_CLIENT=predis</span></pre>
<p><span class="koboSpan" id="kobo.518.1">All of these configurations are related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">env</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">If you are using the Predis package to complete the configuration correctly, you must set an alias in the Laravel bootstrap configuration. </span><span class="koboSpan" id="kobo.522.2">To do that, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">config/app.php</span></strong><span class="koboSpan" id="kobo.524.1"> file, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">'aliases'</span></strong><span class="koboSpan" id="kobo.526.1"> section, add a specific entry </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">for Redis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
'aliases' =&gt; Facade::defaultAliases()-&gt;merge([
    // 'ExampleClass' =&gt; App\Example\ExampleClass::class,
    'Redis' =&gt; Illuminate\Support\Facades\Redis::class,
])-&gt;toArray(),</span></pre>
<p><span class="koboSpan" id="kobo.529.1">Setting the alias is useful for Laravel to access the Redis object correctly and helps Laravel to correctly resolve the reference to the Redis object because we could have a name conflict with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">Redis</span></strong><span class="koboSpan" id="kobo.531.1"> object provided by the Predis package and with the Redis object provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">phpredis</span></strong><span class="koboSpan" id="kobo.533.1"> module. </span><span class="koboSpan" id="kobo.533.2">If you forget to set this configuration, you will not receive an error in executing the Laravel application, but you could face some unexpected application behavior. </span><span class="koboSpan" id="kobo.533.3">For example, when you want to clear the queue on a specific connection, the queue selected is </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">not removed.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">If you switch the connection, for example, from the database to Redis, you don’t have to change anything in your application code. </span><span class="koboSpan" id="kobo.535.2">The Laravel queue mechanism provides an abstraction layer that hides all the different implementations specific to each connection (under the </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.536.1">hood, managing a database connection uses other implementations than a </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">Redis connection).</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">If you are using the code (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">routes/web.php</span></strong><span class="koboSpan" id="kobo.540.1"> file), see </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
Route::get('/time-consuming-request-async', function () {
    $start = hrtime(true);
    ProcessSomething::dispatch()-&gt;onQueue("first");
    $time = hrtime(true) - $start;
    return view('result', [
        'title' =&gt; url()-&gt;current(),
        'description' =&gt; 'the task has been queued',
        'time' =&gt; $time,
    ]);
});</span></pre>
<p><span class="koboSpan" id="kobo.543.1">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">"first"</span></strong><span class="koboSpan" id="kobo.545.1"> queue on the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">configured connection.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">To see the configured connection, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">about</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
php artisan about --only=drivers</span></pre>
<p><span class="koboSpan" id="kobo.551.1">The command displays the information on the drivers used by your Laravel application for </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">the queue:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.553.1"><img alt="Figure 6.8: The driver configuration" src="image/Figure_6.08_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.554.1">Figure 6.8: The driver configuration</span></p>
<p><span class="koboSpan" id="kobo.555.1">The command shows that</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.556.1"> for the queue, we are using Redis as the backend connection </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">for queues.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Now, opening the page at </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">http://127.0.0.1:8000/time-consuming-request-async</span></strong><span class="koboSpan" id="kobo.560.1">, you will see that deferring the task to a Redis queue is faster than a database. </span><span class="koboSpan" id="kobo.560.2">For example, the dispatch method takes less than a millisecond on my local machine. </span><span class="koboSpan" id="kobo.560.3">With the database connection in our example, the same code takes </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">7 milliseconds:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.562.1"><img alt="Figure 6.9: Dispatching a job on the Redis queue" src="image/Figure_6.09_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.563.1">Figure 6.9: Dispatching a job on the Redis queue</span></p>
<p><span class="koboSpan" id="kobo.564.1">With the queue mechanism, we improved the </span><em class="italic"><span class="koboSpan" id="kobo.565.1">responsiveness</span></em><span class="koboSpan" id="kobo.566.1"> of the application, allowing the user to receive an immediate response about the task. </span><span class="koboSpan" id="kobo.566.2">Then, with the Redis connection, we reduced</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.567.1"> the time taken to queue </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">the job.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Thanks to the Redis connection, we can also use Laravel Horizon for monitoring </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the queues.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.571.1">Monitoring queues with Laravel Horizon</span></h2>
<p><span class="koboSpan" id="kobo.572.1">We are going to add Horizon to our </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.573.1">application. </span><span class="koboSpan" id="kobo.573.2">This means that you can access the Horizon </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.574.1">dashboard using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">/horizon</span></strong><span class="koboSpan" id="kobo.576.1"> path at </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">the end.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">To install Laravel</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.579.1"> Horizon, you have to install </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
composer require laravel/horizon</span></pre>
<p><span class="koboSpan" id="kobo.582.1">Then ,you need to publish the files needed by Horizon: the configuration file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">config/horizon.php</span></strong><span class="koboSpan" id="kobo.584.1">), the assets (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">public/vendor/horizon</span></strong><span class="koboSpan" id="kobo.586.1">/ directory), and the service provider (in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">app/Providers/HorizonServiceProvider.php</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1"> file):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
php artisan horizon:install</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">horizon:install</span></strong><span class="koboSpan" id="kobo.591.1"> will copy all needed files into the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">correct directories.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Launch Laravel Octane with </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
php artisan octane:start</span></pre>
<p><span class="koboSpan" id="kobo.596.1">With the default Horizon configuration, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">access </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">http://127.0.0.1:8000/horizon</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.600.1"><img alt="Figure 6.10: The Laravel Horizon dashboard" src="image/Figure_6.10_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.601.1">Figure 6.10: The Laravel Horizon dashboard</span></p>
<p><span class="koboSpan" id="kobo.602.1">The status indicates </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.603.1">whether the supervisor of Horizon processes is up and running. </span><span class="koboSpan" id="kobo.603.2">To collect all the metrics correctly, launch </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">the</span></span><span class="No-Break"><a id="_idIndexMarker360"/></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1"> supervisor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
php artisan horizon</span></pre>
<p><span class="koboSpan" id="kobo.607.1">Then, if you load the page </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">http://127.0.0.1:8000/time-consuming-request-async</span></strong><span class="koboSpan" id="kobo.609.1"> multiple times, multiple jobs are created in the queue. </span><span class="koboSpan" id="kobo.609.2">Launch </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">the consumer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
php artisan queue:work --queue=first</span></pre>
<p><span class="koboSpan" id="kobo.612.1">You will have a consumer up and running, ready to execute jobs from </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">So, you have Octane, Horizon, and the queue worker up and running. </span><span class="koboSpan" id="kobo.614.2">Load the page multiple times, and then go to the dashboard at </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">http://127.0.0.1:8000/horizon/dashboard</span></strong><span class="koboSpan" id="kobo.616.1">. </span><span class="koboSpan" id="kobo.616.2">You will see the dashboard page filled with </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">the metrics:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 6.11: The Horizon Dashboard page elaborating on the metrics" src="image/Figure_6.11_B17728.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 6.11: The Horizon Dashboard page elaborating on the metrics</span></p>
<p><span class="koboSpan" id="kobo.620.1">The metrics are retrieved and calculated in </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">near real-time</span></strong><span class="koboSpan" id="kobo.622.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.623.1">NRT</span></strong><span class="koboSpan" id="kobo.624.1">), which means that under the hood, there is a process that</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.625.1"> continuously (every 3 seconds) performs HTTP calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">/horizon/api/stats</span></strong><span class="koboSpan" id="kobo.627.1"> endpoint implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">by Horizon.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">If you look at the API’s response, you </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.630.1">could programmatically </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.631.1">retrieve the same information you can see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">dashboard UI.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.633.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.634.1">In a scenario such as this one, where you have the UI that calls multiple endpoints (APIs) via polling (every 3 seconds), if you have the APIs served by Octane, you can inherit all the benefits that come from using Octane. </span><span class="koboSpan" id="kobo.634.2">Octane reduces latency thanks to all </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">its optimization.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">For the statistics API, the JSON response has </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">this structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
{
    "failedJobs": 0,
    "jobsPerMinute": 1,
    "pausedMasters": 0,
    "periods": {
        "failedJobs": 10080,
        "recentJobs": 60
    },
    "processes": 1,
    "queueWithMaxRuntime": "first",
    "queueWithMaxThroughput": "first",
    "recentJobs": 0,
    "status": "running",
    "wait": {
        "redis:default": 0
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.639.1">Here, you can retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.641.1">The count of recently failed </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">jobs, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">"failedJobs"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.645.1">The jobs processed per minute since the last </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">snapshot, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">"jobsPerMinute"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.649.1">The number of</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.650.1"> master supervisors that are currently </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">paused, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">"pausedMasters"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.654.1">The configuration</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.655.1"> for how long (in minutes) Horizon has managed the recent and failed jobs. </span><span class="koboSpan" id="kobo.655.2">The values are expressed in seconds, and the configuration is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">config/horizon.php</span></strong><span class="koboSpan" id="kobo.657.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">trim</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.660.1">The process </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">count, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">"processes"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.664.1">The name of the queue that has the most extended </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">runtime, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">"queueWithMaxRuntime"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.668.1">The name of the queue that has the highest </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">throughput, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">"queueWithMaxThroughput"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.672.1">The count of recent </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">jobs, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">"recentJobs"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.676.1">The status of the supervisor (the supervisor is the process run via </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">php artisan </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">horizon</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">), </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">"status"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.682.1">The time to clear per queue, </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">"wait" </span></strong><span class="koboSpan" id="kobo.684.1">(</span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">in seconds).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.686.1">The Horizon dashboard is a convenient way to monitor the status and statistics of all running queues. </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.687.1">Via Horizon, you can’t control the </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.688.1">queues; for managing the queues, you can use the commands </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">explained here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">queue:monitor</span></strong><span class="koboSpan" id="kobo.691.1">: For monitoring the status of the queue and the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">waiting jobs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">queue:clear</span></strong><span class="koboSpan" id="kobo.694.1">: For deleting all the jobs in a connection </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">or queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">queue:flush</span></strong><span class="koboSpan" id="kobo.697.1">: For deleting all </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">failed jobs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">queue:forget</span></strong><span class="koboSpan" id="kobo.700.1">: For deleting a specific failed job (to avoid retrying the execution of a </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">failed job)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">queue:retry</span></strong><span class="koboSpan" id="kobo.703.1">: Retrying the execution of a previously </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">failed job</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">queue:work</span></strong><span class="koboSpan" id="kobo.706.1">: Processing the queue (or the queues specified via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">–</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">queue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1"> parameter)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.710.1">Thanks to all these commands, you can control the queue’s status </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">and health.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">With Horizon, you can monitor the queues’ execution </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">and status.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">So now, we have an architecture for running and monitoring queues with Redis as </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">the backend.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.716.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.717.1">With an asynchronous approach, we can defer the execution of some tasks and be more responsive to the user’s request. </span><span class="koboSpan" id="kobo.717.2">In other words, the job is queued, and it will be taken care of later. </span><span class="koboSpan" id="kobo.717.3">The behavior is different from the classic approach where the job is executed immediately, but the benefit is that control of the application’s UI is consistently available to the user. </span><span class="koboSpan" id="kobo.717.4">The user experience of your application is smoother, so the user, in the meantime, can do other things with your application. </span><span class="koboSpan" id="kobo.717.5">Besides improving the user experience, the asynchronous approach is more scalable because you can control the processes that will take charge of the jobs in a granular way. </span><span class="koboSpan" id="kobo.717.6">You also can execute more than one worker via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">php artisan queue:work</span></strong><span class="koboSpan" id="kobo.719.1"> command – and if your hardware architecture has more virtual machines for running backend processes, you can run the consumer processes across multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">virtual machines.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">To achieve asynchronous architecture in the current chapter, we introduced the queue mechanism; we have shown </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.723.1">How to install and set up the queue in Laravel first with a database as the backend connection, then with a more powerful backend </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">with Redis</span></span></li>
<li><span class="koboSpan" id="kobo.725.1">The differences between executing a job in a synchronous way and in an </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">asynchronous way</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">The benefit of using the queues in terms of the responsiveness of the system and the impact on the </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">user experience</span></span></li>
<li><span class="koboSpan" id="kobo.729.1">Installing Horizon to monitor the </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">queue usage</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.731.1">In the next chapter, we will see how to prepare the application and how to set up the tools to deploy a Laravel Octane application in a </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">production environment.</span></span></p>
</div>
<div>
<div class="Content" id="_idContainer059">
</div>
</div>
</body></html>