- en: Chapter 14. Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You have now made it to the final chapter of this book. After
    having gone through most of the technologies used in both classical and modern
    web development, we are now going to discuss the basics of what I would like to
    call the *avant-garde*, excuse my French, of web development: node.js and friends.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In everything we discussed so far, we used what is often referred to as the
    **LAMP** (or **MAMP** or **WAMP**, depending on the OS on your server) stack:
    **Linux** **Apache MySQL PHP**. Even when we swap out MySQL for **MongoDB**, the
    acronym still stands. Or we could call it **LANP** with the N of **NoSQL**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we had to learn all these languages: JavaScript on the client side, to be
    interpreted by the browser; PHP, to be interpreted by the Apache web server; and
    many more. Just imagine you could swap out everything, even things you would not
    think of—the web server— in favor of JavaScript? That is what node.js does for
    you. As I, being of a somewhat older generation, see it, node.js did to web development
    what Schoenberg and Webern did to classical music, Picasso and Braque to painting,
    and oh well, why not, Venice Beach rappers to pop music.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is good news and bad news here. The bad news is that we are at risk of
    having to start everything over again and have learned a lot of things in vain,
    but the good news is that node.js based solutions *perform* well, *scale* well,
    and, for those that come after us, only require the knowledge of a single programming
    language: JavaScript. Acronyms for this are still up for grabs: **LJMJ** or **LNMJ**
    (J for **JavaScript** or N for **node.js** respectively) or **MEN** (**MongoDB**,
    **Express**, **node.js**)? One that is already used a lot is **MEAN**. Over time
    people will agree on one. Who invented the word *cubism*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will make an attempt to repeat everything you have learned
    so far while doing things the node.js way. So we already know in which language
    our code will be written: JavaScript. What we are going to write may come as a
    surprise to you.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recapitulate a bit; in [Chapter 1](ch01.html "Chapter 1. The World Wide
    Web"), *The World Wide Web*, you learned about the World Wide Web and how all
    these millions of pages are accessed by people using a browser that sends requests
    to a web server using the HTTP protocol. Well, people will still use browsers
    that send HTTP requests, but we just tossed the web server, now what do we do?
    We write one. Scary? No, it will be a lot of fun. Writing low-level code is not
    your thing? No sweat, somebody already did it for you. There is a whole community
    writing code for node.js that everybody else can use. That code is made available
    as what is referred to as **modules**, and of course there is a HTTP module available
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing the web server did for us was to actually analyze the URL the
    user typed and explore the **file system** to see whether there is a physical
    file, for example, an `hello.html` file, and serve it up back to the client. We
    will have to write that too. This is cool because it will give us full control
    over what exactly our web server should be able to handle and what it shouldn't.
    As expected, there are `url` and `fs` modules for node.js as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a database but, we already know one that we like: MongoDB. Can
    we use it with node.js? Yes we can. There is a module or driver for it to access
    the existing MongoDB server from node.js. As MongoDB is a document database and
    documents are really JSON objects, this is a perfect fit in an all-JavaScript
    ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Little by little we are beginning to realize, before even having written one,
    whether a node application is actually going to be a web server that contains
    application-specific code or an application that contains a web server; take your
    pick.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as I walk you through our first examples, you will realize that we never
    before had a need to write so much code for a simple `Hello, World` program. Imagine
    having to write a fully-featured single page web application with so much low-level
    code? This is where *Express* fits in. It is a framework for node.js that will
    help us write cleaner, more compact code. This is our jQuery on the server side.
    As soon as our examples become too boringly long, we will switch to Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another thing we tossed: Apache as an **Application Server**, the
    part that gave us PHP as a language on the server. We have been generating HTML
    dynamically on the server using PHP and, by the time the browser read it, it had
    become all HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: The nice part of using PHP was that we could embed PHP code inside plain HTML
    in between `<?php` and `?>`. Stuffing an HTML file with `<script>` tags to include
    JavaScript code is not very appealing. We will look at a solution for that as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Installing node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s not delay any further and install node on your computer. How to install
    it will be different depending on the OS you are running. Go to [http://nodejs.org/](http://nodejs.org/)
    and get the proper download. The result is the same everywhere: it gives us two
    programs: **node** and **npm**.'
  prefs: []
  type: TYPE_NORMAL
- en: npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'npm, the **node packaging manager**, is the tool that you use to look for and
    install modules. Each time you write code that needs a module, you specify this
    by putting something like the following in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It will have to be installed if it is not yet present, using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The latter will attempt to install the module globally, the former command in
    the directory where the command is issued. It will typically install the module
    in a folder called **node_modules**.
  prefs: []
  type: TYPE_NORMAL
- en: node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `node` command is the command to use to start your node.js program, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Node will start and interpret your code. Type *Ctrl* + *C* to stop node. Let's
    get to our first programs right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our inevitable `Hello, world` example is the smallest possible web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `hello.js`, or get it from the Packt Publishing website and,
    in a terminal window, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will run the program using `node`. In the terminal window, which
    becomes your console, you will see the text `Server running`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, when you start a browser and type in `http://localhost:8080` as the URL,
    something that looks like a web page, containing the famous two-word sentence
    `Hello World`, will appear. As a matter of fact, if you go to `http://localhost:8080/it/does/not/matterwhat`,
    the same thing will appear. Not very useful maybe, but it is a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Adding HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a slightly different version where we explicitly specify that we send
    HTML instead of plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Serving up static content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not used to the same thing popping up no matter what path we give as
    an URL. URLs typically point to a file (or a folder, in which case the server
    looks for an `index.html` file), `foo.html` or `bar.php`, and, when present, it
    is served up to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what if we want to do this with node.js? We need a module. There are several
    ways to do the job. We use `node-static` in our example. First we need to install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can typically find documentation on methods and properties on Github and
    other cool places. In our app, we create not only a web server but a `fileserver`
    as well. It will serve all the files in the local directory `public`. It is good
    to have all so called `static content` together in a separate folder. This is
    basically all the files that will be served up to and interpreted by the client.
    As we will now end up with a mix of client code and server code, it is good practice
    to separate them. When you use the Express framework, it will create these things
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project folder we create `hello.js`, our node.js app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in a subfolder `public`, we create `hello.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create the background with `hello.css` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So if we now visit `http://localhost:8080/hello.html`, we will see our by now
    too familiar `Hello World` message with some basic styling, proving that our file
    server also delivered the CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will take it one step further by actually adding JavaScript to our html
    file (`hellobutton.html` (body only)). We will reuse the previous CSS file, create
    a slightly different HTML file, and add a JavaScript file. I assume you have a
    copy of jQuery around somewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add the button, let''s create `hellobutton.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So when we go to `http://localhost:8080/hellobutton.html`, we see a web page
    with a button; when we click on it, its text changes into `Hello World`. This
    means our client-side jQuery and JavaScript works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `public` folder, create a file `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we go to `http://localhost:8080`, we see *It Works !* Just like when we hit
    the document root of the Apache Web Server. This is because our `node-static`
    module has that file configured as the default.
  prefs: []
  type: TYPE_NORMAL
- en: But there are other things that do not work the way we are used to. If we type
    `hellobutton` instead of `hellobutton.html`, nothing will happen, as we did not
    program our web server to look for `hellobutton.something`. Don't even think of
    wanting to process `hello.html?key=value`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you put a picture file, for example, `baywatchstation.jpg`,
    in `./public` and type `http://localhost:8080/baywatchstation.jpg`, you will see
    the picture in your browser. All this is done with very few lines of code and
    two cool node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: A tale of two (JavaScript) cities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have reached an important stage here: we have two different JavaScript files,
    they are both located on our server, but one is interpreted by node.js and the
    other one is served up by node.js and interpreted by the browser, in other words
    the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this: `http://localhost:8080/js/hellobutton.js`. You will see the code
    of your JavaScript file in a browser. Now insert `alert("Here''s Johnny!");` and
    put `<script>` tags around it, save it, and refresh your browser. `Johnny` pops
    up and then JavaScript continues with doing nothing without giving you any error
    message.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we configured `public` (well `node-static` did) as our document root
    of our mini web server, we cannot even reach `hello.js`, rescuing us from potentially
    greater confusion. I am confident that by now you understand the difference between
    a JavaScript file and a JavaScript file. That is why some developers have developed
    a habit of using different extensions (for example `.njs` for server-side JS files).
    I believe it is a lot clearer to place the different kinds of files in different
    folders as we have started doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, so far, in such a short time, and just a few lines of code, we are capable
    of doing almost anything we discussed in this book up until now, the node.js way:
    we can handle HTML, CSS, JavaScript, and jQuery. We tossed PHP and we are replacing
    MySQL with MongoDB. This leaves us just with the latter and Ajax and then we will
    have, in a way, rewritten our book the node.js way.'
  prefs: []
  type: TYPE_NORMAL
- en: node.js and MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.html "Chapter 11. MongoDB"), *MongoDB*, we introduced
    MongoDB, a document database, and you learned how to access it from the command
    line as well as from within a PHP program. Doing so in node.js is even easier.
    First of all, let''s not forget to start the MongoDB server inside a separate
    terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need, of course, a node.js module, `mongodb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here follows a simple program that connects to the MongoDB server, the `california`
    database to be precise, and looks up a document in the `people` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Déjà vu … once more
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As I went through my first steps with node.js, I had a déjà vu experience.
    To paraphrase the Grace Jones song based on *Libertango* by Astor Piazolla: *Strange,
    I have seen that happen before*.'
  prefs: []
  type: TYPE_NORMAL
- en: With node.js, you only add what you need, so it does not include the kitchen
    sink by default. This can only mean you will benefit from that as far as performance
    goes.
  prefs: []
  type: TYPE_NORMAL
- en: I am a UNIX person but this story goes back to when Linus had not yet rewritten
    it as Linux, Mac OS X did not exist yet, and so on. Memory and disk space were
    expensive, so was UNIX, as manufacturers had to pay royalties.
  prefs: []
  type: TYPE_NORMAL
- en: I was a proud product manager of a PC UNIX product and one of our coolest value-added
    things was a tool called **kconfig**, which would allow people to customize what
    was inside the UNIX kernel, so it would only contain what was needed. This is
    what node.js reminds me of. And it is written in C, just like UNIX. *Déjà vu*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool as it was then, it would not be cool today, because so much more has been
    added to UNIX: it would not be manageable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true if we wanted to mimic everything the Apache web server can
    handle with pure node.js. Just look at the output of the PHP `phpinfo()` function.
    It shows all the modules that are loaded into Apache. If we wanted to support
    all these with with only node.js, we would need too many modules and would end
    up with unreadable code. The movie Amadeus comes to mind, where the emperor''s
    sidekicks agree on one thing about Mozart''s *Le Nozze di Figaro* (I don''t):
    Too many notes!'
  prefs: []
  type: TYPE_NORMAL
- en: Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good way to get the job done with fewer notes is by using the Express framework.
    On the [expressjs.com](http://expressjs.com) website, it is called a *minimal
    and flexible node.js web application framework, providing a robust set of features
    for building web applications*.
  prefs: []
  type: TYPE_NORMAL
- en: There probably is no better way to describe what Express can do for you. It
    is minimal so there is little overhead for the framework itself. It is flexible,
    so you can add just what you need. As it gives a robust set of features, this
    means you do not have to create them yourselves and they have been tested by an
    ever-growing community.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, Express is also a node module, so we install it as such. At the
    time of writing, we used **Express 4**. In your project directory for your application,
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you specify the `—save` option, `npm` will update the `package.json` file.
    You will notice that a folder called `express` will be created inside `node_modules`
    and inside that one there is another collection of node-modules. These are examples
    of what is called **middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: In the few examples that follow, we assume app.js as the name for your node.js
    application and `app` for the variable that you will use in that file for your
    instance of Express. This is for the sake of brevity. It would be better to use
    a string that matches your project name.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Express app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, we are going to do more `Hello, World` examples. Here is our first
    Express app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Well, compared to our second node.js example, it is about the same number of
    lines. But it looks a lot cleaner and it does more for us. You no longer need
    to explicitly include the HTTP module, you no longer have to specify which header
    to send, and, when you specify a different URL, you will not get `Hello, World`
    but a reasonable error message. We use `app.set` and `app.get` for the port. When
    the environment variable `PORT` is set, the port will be set to its value.
  prefs: []
  type: TYPE_NORMAL
- en: The other line containing `app.get` tells us what we want to happen when the
    server is presented with a URL in the `GET` mode. Like in node.js, there is a
    function with the `request` and `respond` objects as an argument. In `express`,
    they have been extended; there are more creative things you can do with them as
    there are more methods available to you.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you have access to `req.body`, which will contain an object of
    all the values that were sent using the `POST` method in a form (using `app.post`).
  prefs: []
  type: TYPE_NORMAL
- en: An example with middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now use Express to rewrite the `hello button` example. All static resources
    in the `public` directory can remain untouched. The only change is in the node
    `app` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses so-called middleware (`static`) that is included with `express`.
    There is a lot more available from third parties. In the `req.body` referenced
    earlier, there is middleware available to parse that form data (`body-parse`).
    You can also write your own middleware. In its simplest form, it is a function
    with `req` and `res` as its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is your minimal 404 handler to give people something meaningful to read
    on their screen when they type in the wrong URL. You place that in your app.js
    file after the code that represents the successful scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Templating and handlebars.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one more `Hello, world` example to go! Throughout the book, we have
    been using PHP most of the time. We have used it to dynamically generate web pages,
    or portions thereof. So PHP code, often embedded inside HTML code in a file with
    `.php` as an extension, is executed on the server and what is rendered by the
    browser is pure HTML. You also learned how to generate HTML from a separate PHP
    file or even JavaScript on the client side, using data that comes from the server,
    and then inject it into a portion of a web page (Ajax).
  prefs: []
  type: TYPE_NORMAL
- en: Combining PHP and HTML and even a small chunk of client-side JavaScript inside
    a single file was made possible thanks to the `<script>` tag and by putting PHP
    code in between `<?php` and `?>`. That is why they sometimes call PHP a *templating*
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine an all-JavaScript ecosystem. Yes, we could still put our client
    JavaScript code in between `<script>` tags, but what about the server JavaScript
    code? There is no such thing as `<?javascript ?>` because this is not how node.js
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and Express support several templating languages that allow you to separate
    layout and content and have the template system do the work to go fetch the content
    and inject it into the HTML. As we no longer want to learn yet another language,
    we decided to go with **handlebars.js**, as it uses plain HTML to define your
    layout, that you already learned some 12 chapters ago. The default templating
    language for Express appears to be **Jade**, which uses its own, albeit more compact,
    because there are no tags, format. Another advantage of using handlebars.js is
    that is also available to do client-side templating.
  prefs: []
  type: TYPE_NORMAL
- en: We conclude this chapter with an example of how you could use handlebars.js.
  prefs: []
  type: TYPE_NORMAL
- en: Our examples in this chapter are all node.js examples, for which we need modules.
    To use handlebars in node and Express, there are several modules available. I
    like the one with the easy to remember name **express-handlebars**. If you search
    the web for handlebars.js, you will find the library to do client-side templating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `handlebars` module for Express using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your project folder that contains `public`, create a folder `views`,
    with a subdirectory `layouts`. Copy other static content you may have from `public`
    to `views`. Inside the `layouts` subfolder, create a file called `main.handlebars`.
    This is your default layout. Think of it as a common layout for almost all of
    your pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `{{{body}}}` part. This token will be replaced by HTML. Create,
    in the `views` folder, a file called `hello.handlebars` with the following content.
    This will be one (of many) example of the HTML, and it will be replaced by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our last Hello, World example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now create a file `lasthello.js` in the project folder. For convenience, we
    added the relevant code to the previous Express example. Everything that worked
    before still works but if you type `http://localhost:3000/`, you will see a page
    with the layout from the layout file and `{{{body}}}` replaced by(you guessed
    it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we gave an overview of node.js and Express. Thanks to
    node.js, you can use JavaScript across the board, on both the client and server
    side. You can even write your own web server with just a few lines of code. As
    you only include the things you really need, you can obtain far better performance
    with this *avant-garde* way of doing web development.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you combine the web server and the server application in your code, there
    may be more code to write than you wish for. That is where Express comes to the
    rescue: a lightweight framework that results in more compact, yet robust code.'
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, we touched on the tip of the templating iceberg by introducing
    handlebars.js. This is a better way to separate layout from dynamic content and
    have the framework combine the two, so the browser can render it as a view. For
    that purpose, we concluded the chapter by writing a layout in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This reminds me of Anna Russell''s rendition of Wagner''s *Der Ring des Nibelungen*,
    which she does in 20 minutes (normally the Ring is 16 hours) concluding that the
    story ends the way it started. It goes a little bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is the Rhine, in the river there are the Rhinemaidens and at the bottom
    there is ... gold …*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, after 14 chapters that took us through many aspects of web development
    we ended where it all started: HTML. I hope you enjoyed reading it as much as
    I did writing it.'
  prefs: []
  type: TYPE_NORMAL
