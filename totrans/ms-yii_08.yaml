- en: Chapter 8. Routing, Responses, and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many modern web frameworks, Yii2 is built with a powerful router component,
    which we can utilize to handle a variety of URIs coming from both our end users
    and application. This functionality is further enhanced by Yii2's powerful request
    and response handlers, which we can use to manipulate request and response bodies.
    In this chapter, we'll cover the basics of how to manipulate Yii2's URL Manager
    to adjust routes, explore how to configure Yii2 to respond in different ways,
    and learn how to send and listen to events within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in previous chapters, routing within Yii2 is managed by the UrlManager
    component defined in our application configuration. The router in Yii2 is responsible
    for determining where Yii2 routes external URI requests to internal controllers
    and actions. In [Chapter 5](part0035_split_000.html#11C3M2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 5. Modules, Widgets, and Helpers"), *Modules, Widgets, and Helpers*,
    we covered the basics of how to create and manipulate URL routes with the `yii\helpers\Url`
    helper. In this section, we'll cover how Yii2 routes these requests inside our
    application by exploring Yii2's UrlManager in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Yii2 can be broken down into two basic steps. The first of these
    steps is to parse the incoming request and query parameters (which are stored
    in the `GET` parameters of our request with the `r` parameter by default but can
    be retrieved from the request URI if we have pretty URLs enabled). The second
    step is to create an instance of the corresponding controller action, which will
    ultimately handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Yii2 will break the route down in the forward slashes of the URL
    to map it to the appropriate module, controller, and action pair. For instance,
    the site/login route will match the `site` controller and the action named `login`
    in the default module of the application instance. Internally, Yii2 will take
    the following steps to route the request:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Yii2 will set the current module as the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the controller map of the application to see whether it contains the
    current route. If so, a controller instance will be created according to the controller
    map defined within the module, at which point, the action will be created according
    to the action map defined in step *4*. By default, Yii2 will create a controller
    map based upon the controllers found within the `@app/controllers` folder, but
    this may be customized within the module (or UrlManager):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the controller map of the application module is found not within the application
    module, Yii2 will iterate through the module list in the `module` property of
    the application module to see if a route matches there. If a module is found,
    Yii2 will instantiate the module using the provided configuration and then create
    the controller using the details outlined in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yii2 will then look for the action within the action map defined in the module's
    configuration. If found, it will create an action according to that configuration;
    otherwise, it will attempt to create an inline action defined in the `action`
    method corresponding to the given action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an error occurs at any point during this process, Yii2 will throw `yii\web\NotFoundHttpException`.
  prefs: []
  type: TYPE_NORMAL
- en: Default and catch all routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Yii2 receives a request that is parsed into an empty route, the default
    route will be used instead. The default route is set to `site/index`, which references
    the `index` action of the `site` controller. This behavior can be changed by setting
    the `defaultRoute` property of the `application` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, Yii2 can be configured to forward all requests to a single route
    by setting the `catchAll` property of `yii\web\application`. This can be beneficial
    when you need to perform application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Custom routes and URL rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than relying upon the default controller/action routes Yii2 internally
    generates, custom URL rules can be written to define our own URL routes. URL routes
    in Yii2 are implemented by an instance of `yii\web\UrlRule`, and they consist
    of a pattern used to patch the path information and query parameters of a given
    route. When using custom URL rules, Yii2 will route a request to the first matching
    rule for the accompanying request. Moreover, the matching rule determines how
    the request parameters are split up. Additionally, using the `yii\helpers\Url`
    helper will also rely upon the list rules to internally route requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'URL rules in Yii2 can be defined in our application configuration by setting
    the `yii\web\UrlManager:$rules` property as an array, with a key containing the
    URL pattern to be matched and the value being the corresponding route. For example,
    supposing we had a controller to manage published content, we could write custom
    rules, as follows, to route `posts` and `post` to our content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when navigating to the `/posts` endpoint of our application, the content/index
    controller action pair will be triggered. As shown in the previous example, URL
    rules can extend beyond simple strings and can contain complex regular expressions,
    which we can use to conditionally route rules. In the previous example, a route
    to the `/post` endpoint followed by an integer ID will route to the content/view
    controller action pair. Moreover, Yii2 will automatically pass the `$id` parameter
    to the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions can only be specified for parameters. However, as we'll
    see later in this section, we can parameterize our routes to make the controller
    and action more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: These regular expressions can be further customized to include more complex
    routes. For instance, adding the following to our URL routes would enable us to
    pass additional information to our content/index action, such as the year, month,
    and the day we want to show published entries for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may expect from the expression, this route will only match four-digit
    years and two-digit months and days. Moreover, as mentioned previously, by adding
    this information to our URL rules, the `yii\helper\Url` helper will understand
    any URL created with this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'URL routes can also be defined to route domain names and schemes. For instance,
    the following routes can be written to ensure that different domain names route
    to different parts of the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is beneficial when handling multiple frontend applications within the same
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to named parameters, as described in the previous section, parameters
    can also be embedded within the URL rule itself. This approach enables Yii2 to
    match a single rule to multiple routes, which can greatly reduce the number of
    URL rules and, consequently, the performance of your router. Take, for instance,
    the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This route will match both the content and comment controller with a given
    ID for the create, list, and delete actions and pass it to the appropriate action.
    In order for a route to match, however, all named parameters must be defined.
    If a given route does not contain the given parameters, Yii2 will fail to match
    the route, which will most likely result in the route hitting a 404 error. One
    way to get around this limitation is to provide default parameters for the routes,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `page` will default to `1`, and `name` will default to `NULL`.
    This URL rule can match multiple routes. In this specific instance, several routes
    will be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/content, page=1, name=NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/content/215, page=215, name=NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/content/215/foo, page=215, name=foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/content/foo, page=1, name=foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL suffixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to declaring a key-value pair for a URL route, routes can
    be defined as an array of key-value pairs containing the pattern, route, and even
    a custom URL suffix to specifically respond to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These routes can be used to configure your application to respond to certain
    types of requests in different formats.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, rules created this way will be created as an instance of `yii\web\UrlRule`,
    but they can be changed by defining the `class` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP method-specific URL rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At times, you may find it beneficial to route different types of HTTP methods
    to the same route but handle them in different actions. In Yii2, this can be achieved
    by prefixing the method types before the route key, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From an API perspective, all requests will ultimately route to `users/<id>`,
    but depending upon the HTTP method, a different action will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: URL rules with specified HTTP methods will only be used for routing purposes,
    and they won't be used to create URLs such as when using `yii\helper\Url`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom URL rule classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `yii\web\Url` is extremely flexible, and it should cover the majority
    of use cases you need for a URL rule, often there are times when a custom URL
    may be required. For instance, a publisher may want to support a format to represent
    authors and books, such as `/Author/Book`, where both `Author` and `Book` are
    data retrieved from the database. Custom URL rules in Yii2 can be created to solve
    this problem by extending `yii\base\Object` and implementing `yii\web\UrlRuleInterface`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom rule can then be implemented within our `yii\web\UrlManager::$rules`
    section by declaring our desire to use that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic rule generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rules can be programmatically and dynamically added to your application in
    several different ways. Dynamic rule generation can take the form of a custom
    URL rule class, as outlined in the previous section, or a custom URL manager.
    The simplest way to add new URL rules dynamically, however, is to use the `addRules()`
    method of the URL Manager. For rules to take effect, they need to occur early
    in the bootstrapping process of the application. For modules to dynamically add
    new rules, they should implement `yii\base\BootstrapInterface` and add the custom
    URL rules in the `bootstrap()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In complex web applications, it's important to monitor how many URL rules you
    have. Adding many different rules can seriously degrade the performance of your
    application as Yii2 needs to iterate over each rule until it finds the first matching
    rule. Parameterized routes and reducing the number of URL rules can significantly
    improve the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After handling where we want our request to go, we will often need to write
    specific logic to handle the details of our HTTP request. To help facilitate this,
    Yii2 represents the HTTP request within the `yii\web\Request` object, which can
    provide a variety of information about the HTTP request, such as the request body,
    `GET` and `POST` parameters, and headers. Each request in Yii2 can be accessed
    easily through the request application component, which is represented by `Yii::$app->request`
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving request parameters and data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common task we''ll perform when working with the request object is
    retrieving `GET` and `POST` parameters, which are implemented by `yii\web\Request::get()`
    and `yii\web\Request::post()` respectively. These methods enable us to consistently
    and safely access the `$_GET` and `$_POST` parameters of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the native `$_GET` and `$_POST` PHP global variables, however, Yii2''s
    request object allows us to safely access named parameters, as shown in the next
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameters are not defined, Yii2 will return `NULL` by default. This
    behavior can be modified by setting the second parameter of both `yii\web\Request::get()`
    and `yii\web\Request::post()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to providing safe access to the `$_GET` and `$_POST` data, the request
    object can also be easily mocked when running tests. We'll cover how to work with
    tests and mocking data in [Chapter 10](part0060_split_000.html#1P71O1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 10. Testing with Codeception"), *Testing with Codeception*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an added convenience, Yii2 provides us with the ability to determine the
    type of request we''re working with, such as a `GET`, `POST`, or `PUT` request.
    The easiest way to determine the request type is to query `\Yii::$app->request->method`,
    which will return the HTTP method type (such as `GET`, `PUT`, `POST`, `DELETE`,
    and so on). Alternatively, we can conditionally check the request by querying
    one of the request objects of many Boolean options, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isAjax` | If the request is an AJAX (`XMLHTTPRequest`)
    request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isConsoleRequest` | If the request is being made from
    the console |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isDelete` | If the request is an `HTTP DELETE` request
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isFlash` | If the request originated from Adobe Flex or
    Adobe Flash. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isGet` | If the request is an `HTTP GET` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isHead` | If the request is an `HTTP HEAD` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isOptions` | If the request is an `HTTP OPTIONS` request
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isPatch` | If the request is an `HTTP PATCH` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isPjax` | If the request is an `HTTP PJAX` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isPost` | If the request is an `HTTP POST` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isPut` | If the request is an `HTTP PUT` request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$isSecureConnection` | If the request was made over a secure
    (HTTPS) connection |'
  prefs: []
  type: TYPE_TB
- en: 'Unlike `GET` and `POST` requests sent as forms, many of these requests submit
    data directly in the request body. To access this data, we can use `yii\web\Request::getBodyParam()`
    and `yii\web\Request::getBodyParams()`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Request headers and cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the request body, Yii2''s request object can also retrieve header
    and cookie information sent along with the request. The headers sent along with
    our request are ultimately represented by `yii\web\HeaderCollection`, which provides
    several methods used to work with headers, namely `yii\web\HeaderCollection::get()`
    and `yii\web\HeaderCollection::has()`. In the following example, we''re checking
    whether the `X-Auth-Token` header is set and then assigning it to the `$authToken`
    variable if it is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a parameter is not provided to the `yii\web\HeaderCollection::get()` method,
    an array of all headers will be returned. More details on `yii\web\HeaderCollection`
    can be found at [http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html](http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The request object has several built-in defaults to access some commonly queried
    headers, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yii\web\Request::$userAgent` retrieves the user agent sent by the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yii\web\Request::$contentType` can be used to determine the appropriate response
    type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yii\web\Request::$acceptableContentTypes` returns all the acceptable content
    types that the client will accept'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yii\web\Request::$acceptableLanguages` can be used if our application is configured
    to support multiple languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request object can also tell us what the preferred language of the client
    is through `yii\web\Request::getPreferedLanguage()`. We'll work more with this
    variable and general translation and localization in [Chapter 11](part0068_split_000.html#20R681-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 11. Internationalization and Localization"), *Internationalization and
    Localization*.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside our header information, we can also retrieve the cookie data sent
    with our request by querying `Yii::$app->request->cookies`, which will return
    an instance of `yii\web\CookieCollection`, which, as you may suspect, contains
    many of the same types of methods that `yii\web\HeaderCollection` provides, such
    as `get()` and `has()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Yii2 API documentation provides a complete set of methods for `yii\web\CookieCollection`
    at [http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html](http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving client and URL information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to information about the request, the Yii2 request object can also
    be used to retrieve information about the client and our application state. For
    instance, client information such as their hostname or IP address can be accessed
    using `yii\web\Request::$userHost` and `yii\web\Request::$userIP`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user's IP address may not be accurate if your request is being forwarded
    through a proxy or load balancer. Ensure that your web server is properly configured
    to pass along the original data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data about the application state can be inspected by referencing a variety
    of methods, which are more convenient than querying the `$_SERVER` global variable.
    A few of the most common properties are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$absoluteUrl` | This is the absolute URL, including the
    hostname and all the `GET` parameters (for example, `https://www.example.com/controller/action/?name=foo`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$baseUrl` | This is the base URL used before the entry
    script. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$hostInfo` | These are the host details (for example, `https://www.example.com`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$pathInfo` | This is the full path after the entry script
    (for example, `/controller/action`) |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$queryString` | This is the `GET` query string (for example,
    `name=foo`) |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$scriptUrl` | This is the URL without the path and query
    string (for example, `/index.php`) |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$serverName` | This is the server name (for example, `example.com`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$serverPort` | This is the port the server is running on
    (usually 80 or 443 for TLS connections) |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\Request::$url` | This is the complete URL sans the host and scheme
    information (for example, `controller/action/?name=foo`). |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request object is capable of representing nearly every aspect of the HTTP
    request and the data that may be stored in the `$_SERVER` global variable. For
    more information on the request object refer to the Yii2 API documentation at
    [http://www.yiiframework.com/doc-2.0/yii-web-request.html](http://www.yiiframework.com/doc-2.0/yii-web-request.html).
  prefs: []
  type: TYPE_NORMAL
- en: Responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After finishing the processing of the request object, Yii2 then generates a
    response object, which is sent back to the client. The response contains a myriad
    of information, such as the HTTP status code, response body, and headers. In Yii2,
    the response object is implemented by `yii\web\Response`, which is represented
    by the `response` application component. In this section, we'll explore how to
    work with responses.
  prefs: []
  type: TYPE_NORMAL
- en: Setting status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, Yii2 is perfectly capable of setting the appropriate response
    code back to the end user; however, there may be situations that require us to
    explicitly define the HTTP response code for our application. To modify the HTTP
    status code within our application, we simply need to set `yii\web\Response::$statusCode`
    to a valid HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Web exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Yii2 will return an HTTP 200 status code for any successful request.
    If we want to adjust the status code without interrupting our flow of logic, we
    can simply define a new status code for `yii\web\Response::$statusCode`. In other
    cases, it may be better to throw an exception to cause a short circuit in our
    application flow to prevent additional logic from being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, web exceptions can be thrown by calling `yii\web\HttpException`
    with a valid HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, Yii2 provides several specific methods for a few different
    types of requests, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Exception | Status Code | HTTP Error |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\BadRequestHttpException` | 400 | Bad request |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\UnauthorizedHtpException` | 401 | Unauthorized |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\ForbiddenHttpException` | 403 | Forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\NotFoundHttpException` | 404 | Not found |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\MethodNotAllowedException` | 405 | Method not allowed |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\NotAcceptableHttpException` | 406 | Not acceptable |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\ConflictHttpException` | 409 | Conflict |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\GoneHttpException` | 410 | Gone |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\UnsupportedMediaTypeHttpException` | 415 | Unsupported media type
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\TooManyRequestsHttpException` | 429 | Too many requests |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\web\ServerErrorHttpException` | 500 | Sever error |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to throwing an empty `yii\web\HttpException` with a given
    status code, you can also extend `yii\web\HttpException` to implement your own
    `HttpException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Setting response headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the `yii\web\Request object`, we can manipulate the HTTP headers of
    our response using the `add()` and `remove()` methods from `yii\web\HeaderCollection`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding new headers will override any previously set headers with the same name.
    Moreover, all headers set through `yii\web\HeaderCollection` are case insensitive.
    Removing a header will remove any header with the name that is currently sent.
  prefs: []
  type: TYPE_NORMAL
- en: Headers can be manipulated at any time during the response up until `yii\web\Response::send()`
    is called, which, by default, is called right before the response body is sent
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The response body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, the response body will be represented by an instance of `yii\web\View`,
    which is usually displayed to the end user by returning a rendered view inside
    a controller action, as shown here. By default, Yii2 will return the response
    with a MIME type of text/HTML and will format the response using `yii\web\HtmlResponseFormatter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be situations, however, where a different response type may be required,
    such as when displaying JSON or XML data. Within our controller action, we can
    change the output format from the default by setting the `yii\web\Response::$format`
    property and returning either an array or a string representing the data we want
    formatted, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example will output the following JSON data to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to JSON formatting, `yii\web\Response::$format` can also be set
    to JSONP, HTML, RAW, and XML using the details outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Formatter class | Format value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HTML | `yii\web\HtmlResponseFormat` | `FORMAT_HTML` |'
  prefs: []
  type: TYPE_TB
- en: '| RAW |   | `FORMAT_RAW` |'
  prefs: []
  type: TYPE_TB
- en: '| XML | `yii\web\XmlResponseFormatter` | `FORMAT_XML` |'
  prefs: []
  type: TYPE_TB
- en: '| JSON | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
  prefs: []
  type: TYPE_TB
- en: '| JSONp | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RAW data will be submitted to the client as is without any additional formatting
    being applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to working with the default response object, in Yii2, you can also
    create new response objects to be sent to the end user, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any custom configuration set for the response application component will not
    be applied to any custom response objects that you instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'While controller actions are the primary place where you will find yourself
    editing the response body, the response body can be modified from anywhere in
    Yii by directly manipulating `\Yii::$app->response`. Any data that has been already
    formatted can be assigned directly to the response object by setting the `yii\web\Response::$content`
    property. Moreover, if you want to have the data being passed through a response
    formatted before being sent to the user, you can set `yii\web\Response::$content`
    and then set `yii\web\Response::$data` with the data you want formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to redirect a browser to a new page, the special header location must
    be set by the response. Yii2 provides special support for this through the `yii\web\Response::redirect()`
    method, which can be called from within a controller action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Yii2 will return a 302 status code, indicating that the redirect
    should be temporary. To notify the browser to permanently redirect the request,
    you can set the second parameter of `yii\web\Response::redirect()` to 301, which
    is the HTTP status code for a permanent redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside a controller action, a redirect can be called by calling the `redirect()`
    method and then immediately sending the response, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The file output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to browser redirection, outputting a file to the client requests several
    custom headers to be set. To facilitate the transfer of files to the browser,
    Yii2 provides three distinct methods to output files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yii\web\Response::sendFile()` should be used when sending an existing file
    located on the disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yii\web\Response::sendContentAsFile()` sends a string of data as a file (such
    as a CSV file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yii\web\Response::sendStreamAsFile()` should be used for large files (typically,
    files larger than 100 MB), and it should be sent to the browser as it is more
    memory efficient. Within a controller, these methods can be called directly to
    send a file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to redirecting a browser, these methods can be called outside a controller
    action by manipulating the response object directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the response object can be found in the Yii2 documentation
    at [http://www.yiiframework.com/doc-2.0/yii-web-response.html](http://www.yiiframework.com/doc-2.0/yii-web-response.html).
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often when working with complex code bases, we may implement hooks and handlers
    so that our application can call custom code outside our main application flow.
    In Yii2, these handlers are called events, which can be automatically executed
    when a given event is triggered. For example, in a blogging platform, we may create
    an event to indicate that a post was published, which will trigger some custom
    code to send out an email to users in a specific mailing list. In this section,
    we'll cover how to create event handlers, trigger events, and write our own custom
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events in Yii2 are implemented within the `yii\base\Component` base class, which
    nearly every class in Yii2 extends from. By extending from this class, we can
    bind an event to nearly anywhere in our codebase. To begin working with events,
    we first need to create an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event handlers in Yii2 can be bound by calling the `yii\base\Component::on()`
    method, and they specify a callback that should be executed when the event is
    triggered. These callbacks can take several different forms, ranging from a global
    PHP function specified as a string to an anonymous function written inline on
    the event. For instance, if we want to call a global PHP function (such as the
    one we defined or a built-in function such as `trim`), we can bind our event,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Events handlers can also be called on any PHP object: either the one that we
    already have an instance variable for or a namespaced class within our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, event handlers can be written as an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional data can be passed to event handlers by passing any data as the
    third parameter to the `yii\base\Component::on()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, multiple event handlers can be bound to a single event. When a
    given event is triggered, each event will execute in the order in which it was
    bound to the event. If an event handler needs to stop the execution of the other
    events that follow, it can set the `yii\base\Event::$handled` property of the
    `$event` object to `true`, which will prevent all the event handlers bound to
    the event from not executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the event handler in Yii2 is bound in the order in which it is
    called, which means that the last event handler bound to a given event will be
    called last. To prepend an event handler to the beginning of the event handler
    queue, you can set the `$append` parameter of `yii\base\Component::on()` to `false`,
    which will override the default behavior and cause the event handler to be triggered
    first when the event is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Event handlers can also be unbound from the event they''re listening to by
    calling `yii\base\Component::off()` using the same syntax used to attach the event
    listener to the event. Alternatively, all events handlers can be unbound from
    an event by calling `yii\base\Component::off()` without any additional parameters,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Triggering events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events in Yii2 are triggered by calling the `yii\base\Component::trigger()`
    method, which takes the event name as the second parameter, and an optional instance
    of `yii\base\Event` as the second parameter. For example, we can call `Thing::EVENT_NAME`
    within our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This event was previously bound with the following event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `app\components\Thing::doThing()` method will be triggered. This code
    may look as follows for our imaginary component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii2 considers it a best practice to store event names as constants within classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional information can be sent to our event handlers by extending `yii\base\Event`
    and passing it as the second parameter of our trigger call, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Due to the single-threaded nature of PHP, Yii2's events will occur synchronously
    rather than asynchronously, which will block all other application flows from
    occurring until all the events in the event handler queue are complete. Consequently,
    you should be careful when using many events as they may cause detrimental application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to use implemented asynchronous events (such as sending an email newsletter
    from a CMS) is to have your event handlers pass off the event to a third-party
    messaging queue, such as Gearman, Sidekiq, or Resque, and immediately return the
    event. The event can then be handled in a separate processing thread, which can
    be a Yii2 console command configured to read events from the messaging queue and
    process them separately from the main application.
  prefs: []
  type: TYPE_NORMAL
- en: Class-level events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The events described previously were bound at an instance level. In Yii2, events
    can be bound to every instance of a class rather than a specific instance, and
    they can also be bound to Yii2's global event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class-level events can be bound by attaching the event handler directly through
    `yii\base\Event::on()`. For instance, Active Record will trigger an `EVENT_AFTER_DELETE`
    event whenever a record is deleted from the database. We can log this information
    for every Active Record instance, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a trigger occurs, it will first call instance-level event handlers,
    then it will call class-level event handlers, and then it will call global event
    handlers. Class-level events can be explicitly called by calling `yii\base\Event::trigger()`
    directly. Additionally, class-level event handlers can be removed through `yii\base\Event::off()`.
  prefs: []
  type: TYPE_NORMAL
- en: Global events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global events are supported in Yii2 by binding event handlers to the application
    singleton instance itself, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using global events, be cautious as to not override Yii2's built-in global
    events. Any global event that you use should include some sort of prefix in order
    to avoid collision with Yii2's built-in events.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of how requests and responses are handled
    in Yii2\. We first explored how Yii2 handles the routing of URL routes, and we
    learned how to manipulate and create our own custom URL rules. We then explored
    the `yii\web\Request` and `yii\web\Response` objects and gained a better understanding
    of how we can use these objects to manipulate the requests and responses coming
    to and from our application. Finally, we learned how events work in Yii2, and
    we also learned how to create our own events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take the knowledge we've gained in this chapter to
    the next level by exploring how to implement RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
