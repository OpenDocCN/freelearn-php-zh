- en: 3\. Control Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 控制语句
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to describe Boolean expressions;
    leverage logical operators to compose Boolean expressions; choose the right comparison
    operators within a control statement; describe branching and different looping
    techniques in PHP; apply branching with `if`…`else`, `switch` case, `break`, and
    `continue` statements; differentiate between bounded and unbounded loops; implement
    loops such as while, `do`…`while`, `for`, and `foreach`; and write a PHP script
    to create a movie listing application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述布尔表达式；利用逻辑运算符来组合布尔表达式；在控制语句中选择正确的比较运算符；描述PHP中的分支和不同的循环技术；使用`if`…`else`、`switch`情况、`break`和`continue`语句进行分支；区分有界和无界循环；实现while、`do`…`while`、`for`和`foreach`循环；并编写一个PHP脚本来创建电影列表应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Since PHP is a dynamically typed language where types are associated with data
    instead of variables, it's essential to understand the role that types play in
    the data operations landscape. In the previous chapter, we learned about the available
    data types in PHP, their usage with variables and typecasting. We also practiced
    adding and removing items from an array and went through type conversion and alternative
    approaches to assigning string data to a variable with `heredoc` and `nowdoc`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP是一种动态类型语言，其中类型与数据相关联而不是与变量相关联，因此理解类型在数据操作领域中的作用至关重要。在前一章中，我们学习了PHP中可用的数据类型、它们与变量的使用以及类型转换。我们还练习了向数组中添加和删除项目，并了解了类型转换以及将字符串数据分配给变量的`heredoc`和`nowdoc`的替代方法。
- en: In this chapter, we will discuss **control statements** and why they are essential,
    and we'll explore what PHP has to offer in this area. Control statements are the
    most important feature of any programming language. In simple terms, they help
    to control the flow of a program. **Branching** and **looping** are the main types
    of control structures that help to decide program flow. They also help to craft
    recursive loops for complex program flows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**控制语句**及其重要性，并探讨PHP在这一领域所能提供的功能。控制语句是任何编程语言最重要的特性。简单来说，它们有助于控制程序的流程。**分支**和**循环**是帮助决定程序流程的主要控制结构类型。它们还有助于构建用于复杂程序流程的递归循环。
- en: Branching allows us to follow the correct path among multiple conditions based
    on a certain logic. For example, say that we want to make contact with a person.
    The person might have an email address or a cell number and we might want to either
    email or SMS the person. A branching structure will help us to determine whether
    there is an email address associated with that contact information and email the
    person based on that logic. And if an email address is not available, then we
    can opt for an alternative communication approach, such as SMS.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 分支使我们能够根据一定的逻辑在多个条件中遵循正确的路径。例如，假设我们想要与某个人取得联系。这个人可能有一个电子邮件地址或手机号码，我们可能想要通过电子邮件或短信与这个人联系。分支结构将帮助我们确定是否与该联系信息相关联有电子邮件地址，并根据该逻辑给这个人发送电子邮件。如果没有电子邮件地址可用，那么我们可以选择替代的通信方式，例如短信。
- en: 'The logic that helps branching can be composed of one or more conditions; for
    example, checking whether the email address is available and checking whether
    the email address is valid. Normally, each branch of code groups a set of statements
    to execute; for example, if the email address is available, then email the contact,
    log the email delivery in the history, update the sender that the email has been
    sent successfully, and so on. PHP supports `if…else` and `switch` control statements
    for branching. The idea of branching is all about deciding on and executing the
    correct plan:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助分支的逻辑可以由一个或多个条件组成；例如，检查电子邮件地址是否可用以及检查电子邮件地址是否有效。通常，每个代码分支都会分组一组要执行的语句；例如，如果电子邮件地址可用，则发送联系人的电子邮件，记录电子邮件投递的历史记录，更新发件人电子邮件已成功发送，等等。PHP支持`if…else`和`switch`控制语句进行分支。分支的想法完全是关于决定并执行正确的计划：
- en: '![Figure 3.1: Branching diagram'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：分支图'
- en: '](img/C14196_03_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_03_01.jpg)'
- en: 'Figure 3.1: Branching diagram'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：分支图
- en: 'Looping allows us to perform repetitive tasks or execute program statements
    repetitively as long as a certain logic has been fulfilled. For example, we need
    to send emails to all the persons in a given list who have a valid email address.
    The looping structure allows us to iterate through the list of persons and send
    them emails one by one – if the given email addresses are valid, the loop will
    continue until the end of the list. `while`, `do…while`, `for`, and `foreach`
    are the different looping techniques available in PHP:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许我们在满足一定逻辑的情况下执行重复的任务或重复执行程序语句。例如，我们需要给给定列表中所有具有有效电子邮件地址的人员发送电子邮件。循环结构允许我们遍历人员列表并逐个发送他们的电子邮件——如果给定的电子邮件地址是有效的，循环将继续到列表的末尾。`while`、`do…while`、`for`和`foreach`是PHP中可用的不同循环技术：
- en: '![Figure 3.2: Looping diagram'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2：循环图]'
- en: '](img/C14196_03_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_03_02.jpg](img/C14196_03_02.jpg)'
- en: 'Figure 3.2: Looping diagram'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：循环图
- en: Boolean Expressions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔表达式
- en: Branching and looping structures evaluate the logic to execute a branch or execute
    a loop. That logic could test a certain value, could be a comparison of values,
    or could test a logical relationship, and it can be written as an expression.
    The expression is evaluated as a Boolean value; that is, `true` or `false` by
    the branching and looping structures. For branching, the expression serves as
    an entry check for that branch so that we can decide whether to choose that branch
    of code or not. For looping, the expression might serve as an entry or exit check
    for that loop so that we can decide how many times the loop should iterate. For
    example, to email a list of persons, we can write an expression to determine the
    size of the list so that we set how many times we do the emailing task and write
    another expression that checks the email address validity to send the email.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和循环结构评估逻辑以执行分支或循环。这个逻辑可以测试某个值，可以是值的比较，也可以是测试逻辑关系，并且它可以写成表达式。表达式被评估为布尔值；即，由分支和循环结构评估为`true`或`false`。对于分支，表达式作为该分支的入口检查，这样我们就可以决定是否选择该代码分支。对于循环，表达式可能作为该循环的入口或退出检查，这样我们就可以决定循环应该迭代多少次。例如，要给一个人员列表中的所有人发送电子邮件，我们可以编写一个表达式来确定列表的大小，这样我们就可以设置发送电子邮件任务多少次，并编写另一个表达式来检查电子邮件地址的有效性以发送电子邮件。
- en: 'A `not`, `and`, and `or` to check the truthiness or untruthiness or the falseness
    of any statement. Consider a fruit analogy: "*I love apples*". The expression
    is `true` if apple is a fruit. What about "*I love both apples and oranges*"?
    The expression is `true` if both "*I love apples*" and "*I love oranges*" are
    `true`. Comparison operators also play a role in a Boolean expression when we
    need to compare two values to identify whether they are equal, or one is greater
    or less than the other. Comparison is not only limited to values but also extends
    into data types.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`not`、`and`和`or`来检查任何陈述的真实性或非真实性或错误性。考虑一个水果类比：“*我喜欢苹果*”。如果苹果是水果，这个表达就是`true`。那么，“*我喜欢苹果和橙子*”呢？如果“*我喜欢苹果*”和“*我喜欢橙子*”都是`true`，那么这个表达就是`true`。比较运算符在布尔表达式中也扮演着角色，当我们需要比较两个值以确定它们是否相等，或者一个是否大于或小于另一个时。比较不仅限于值，还扩展到数据类型。
- en: In the next section, we will discuss Boolean constants and learn how to write
    a Boolean expression using operators, and, throughout the chapter, we will apply
    logical expression evaluations as a Boolean value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论布尔常量，并学习如何使用运算符编写布尔表达式，在整个章节中，我们将应用逻辑表达式评估作为布尔值。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples in this chapter follow the styling recommendations in the PSR
    standards coding style guide, which is available at [https://packt.live/2VtVsUZ](https://packt.live/2VtVsUZ).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都遵循PSR标准编码风格指南中的样式建议，该指南可在[https://packt.live/2VtVsUZ](https://packt.live/2VtVsUZ)找到。
- en: Boolean Constants
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔常量
- en: '`true` and `false` are the only two Boolean values treated as constants. A
    simple Boolean value can be a simple expression like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`和`false`是唯一两个被视为常量的布尔值。一个简单的布尔值可以是一个简单的表达式，如下所示：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the statement within parentheses results in `true`, then the `true` block
    should be executed; otherwise, the `false` block should.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果括号内的陈述结果是`true`，那么应该执行`true`块；否则，应该执行`false`块。
- en: 'Alternatively, we could write the following expression:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写出以下表达式：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both approaches output `I love programming.`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会输出`我喜欢编程`。
- en: In the preceding examples, we used the `if…else` control statement, which we
    are going to discuss a little later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`if…else`控制语句，我们将在本章稍后讨论。
- en: Logical Operators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: '`true` if *the fruit is not an apple*. Hence, to negate a statement, we use
    the `true` if either of the "*I love apples*" or "*I love oranges*" statements
    is true. Hence, we use or to result in boolean `true` if any condition is `true`
    and we use `true`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*水果不是苹果*，则为`true`。因此，要否定一个陈述，我们使用如果"*我爱苹果*"或"*我爱橙子*"中的任何一个语句是`true`，则使用`true`。因此，我们使用或来在任一条件为`true`时产生布尔`true`，并使用`true`。
- en: Logical operators can be used to compose multiple expressions into one complex
    expression. For example, the statement "*I love either apples or oranges but not
    watermelon*" can be broken into smaller statements, such as "*I love apples*,"
    or "*I love oranges*," and "*I don't love watermelon*." The expression is `true`
    if *the fruit is not watermelon* and if either of the statements "*I love apples*"
    or "*I love oranges*" is `true`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符可以用来将多个表达式组合成一个复杂的表达式。例如，语句"*我爱苹果或橙子但不是西瓜*"可以分解成更小的语句，例如"*我爱苹果*"，或"*我爱橙子*"，以及"*我不爱西瓜*"。如果*水果不是西瓜*，并且"*我爱苹果*"或"*我爱橙子*"中的任何一个语句是`true`，则表达式是`true`。
- en: The not Operator
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非运算符
- en: 'The `true` if the variable value is not `true`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量的值不是`true`，则为`true`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The and Operator
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: and 运算符
- en: 'The `and` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`运算符用于将多个变量或表达式连接起来以产生一个新的布尔值——`true`或`false`：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code outputs `true` if both `$a` and `$b` variables are `true`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在`$a`和`$b`变量都为`true`时输出`true`。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are two different variations of the `and` operator here and they work
    on a different order of precedence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`and`运算符有两种不同的变体，并且它们按照不同的优先级顺序工作。
- en: The order in which an operation is performed first in an expression is decided
    by the precedence. The precedence of the `and` operator is lower than that of
    the `&&` operator.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中操作执行的顺序由优先级决定。`and`运算符的优先级低于`&&`运算符。
- en: The or Operator
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: or 运算符
- en: 'The `or` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符用于将多个变量或表达式连接起来以产生一个新的布尔值——`true`或`false`：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code outputs `true` if either variable `$a` or `$b` is `true`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在变量`$a`或`$b`中的任何一个为`true`时输出`true`。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are two different variations of the `or` operator here and they work on
    a different order of precedence.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`or`运算符有两种不同的变体，并且它们按照不同的优先级顺序工作。
- en: The xor Operator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xor 运算符
- en: 'The `xor` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`运算符用于将多个变量或表达式连接起来以产生一个新的布尔值——`true`或`false`：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code outputs `true` if `$a` or `$b` is not `true` at once. Consider
    a fruit analogy again: the statement "*I love mango or lemons but not both*" is
    `false` when both "*I love mango*" and "*I love lemons*" are `true` at the same
    time.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在`$a`或`$b`不是`true`时输出`true`。再次考虑一个水果的类比：当同时`*我爱芒果*`和`*我爱柠檬*`都是`true`时，语句"*我爱芒果或柠檬但不是两者都爱*"是`false`。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP, there are two different variations of `and` and `or` which operate in
    a different order of precedence. See the operator precedence table at [https://packt.live/2IFwFYR](https://packt.live/2IFwFYR).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，`and`和`or`有两种不同的变体，它们按照不同的优先级顺序工作。请参阅[https://packt.live/2IFwFYR](https://packt.live/2IFwFYR)中的运算符优先级表。
- en: Short-Circuit Evaluation and Operator Precedence
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路评估和运算符优先级
- en: '`and` operation is `false`, then the overall evaluation must produce `false`
    and you don''t necessarily need to evaluate the second condition. The same goes
    for the `or` operator: if the first condition is `true`, then the overall evaluation
    must produce `true`, no matter if the second condition is `false`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`and`操作是`false`，则整体评估必须产生`false`，并且不一定需要评估第二个条件。对于`or`运算符也是如此：如果第一个条件是`true`，则整体评估必须产生`true`，无论第二个条件是否为`false`。
- en: 'Short-circuit evaluation will do the minimum number of comparisons possible
    to evaluate conditions. Here are some examples of short circuit logical operators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 短路评估将进行尽可能少的比较来评估条件。以下是一些短路逻辑运算符的示例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding `foo()` function will never be called as the first part of the
    expression gives the logical conclusion. As with `and`, if the first argument
    is `false`, you don''t need to evaluate the rest as the `and` operation is `false`
    if at least one argument is `false`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `foo()` 函数永远不会被调用，因为表达式的第一部分给出了逻辑结论。与 `and` 一样，如果第一个参数是 `false`，则不需要评估其余部分，因为
    `and` 操作只要至少有一个参数是 `false` 就是 `false`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `foo()` function will never get called as the first part of the expression
    gives the logical conclusion. As with `or`, if the first argument is `true`, you
    don't need to evaluate the rest as the `or` operation is `true` if at least one
    argument is `true`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()` 函数永远不会被调用，因为表达式的第一部分给出了逻辑结论。与 `or` 一样，如果第一个参数是 `true`，则不需要评估其余部分，因为
    `or` 操作只要至少有一个参数是 `true` 就是 `true`。'
- en: 'To look at another example, short-circuit evaluation is useful for conditions
    like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要看看另一个例子，短路评估对于以下条件很有用：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `$todayIsSunday` is `false`, then the whole expression is evaluated as `false`
    and there is no chance of playing games at home.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$todayIsSunday` 是 `false`，则整个表达式将被评估为 `false`，并且没有在家玩游戏的机会。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The evaluation of logical expressions ceases once the result is known.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道结果，逻辑表达式的评估就会停止。
- en: The Precedence of Logical Operators
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符的优先级
- en: We need to be aware of the precedence of the same logical operators in an assignment
    statement so that the Boolean values don't run into the assignment before evaluating
    the result. The following examples show you how the precedence of the same logical
    operator (`||` / `or`) might ruin the evaluation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到赋值语句中相同逻辑运算符的优先级，以便布尔值在评估结果之前不会遇到赋值。以下示例显示了相同逻辑运算符（`||` / `or`）的优先级如何可能破坏评估。
- en: '|| versus or'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`||` 与 `or` 的比较'
- en: 'Consider the following example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of the `(false || true)` expression has been assigned to `$a` and
    evaluated like `($a=(false||true))` since `||` has higher precedence than `=`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`(false || true)` 表达式的结果已经被分配给 `$a`，并像 `($a=(false||true))` 一样进行评估，因为 `||`
    的优先级高于 `=`：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `false` constant is assigned to `$a` before the `or` operation and evaluates
    like `(($a = false) or true)` since `or` has lower precedence than `=`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `or` 操作之前，将 `false` 常量分配给 `$a`，并像 `(($a = false) or true)` 一样进行评估，因为 `or`
    的优先级低于 `=`。
- en: '&& versus and'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`&&` 与 `and` 的比较'
- en: 'Consider the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of the `(true && false)` expression has been assigned to `$a` and
    evaluated like `($a = (true && false))` since `&&` has a higher priority than
    `=`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`(true && false)` 表达式的结果已经被分配给 `$a`，并像 `($a = (true && false))` 一样进行评估，因为 `&&`
    的优先级高于 `=`：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `true` constant has been assigned to `$a` before the `and` operation occurs
    and evaluated like `(($a = true) and false)` since `and` has a lower priority
    than `=`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `and` 操作发生之前，将 `true` 常量分配给 `$a`，并像 `(($a = true) and false)` 一样进行评估，因为 `and`
    的优先级低于 `=`。
- en: 'Consider the following use case, where we need to grant access if the user
    has both a username and password. In the example, we can see that the user doesn''t
    have a password, so access should not be granted:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例，其中我们需要在用户同时拥有用户名和密码的情况下授予访问权限。在示例中，我们可以看到用户没有密码，因此不应授予访问权限：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, since `$hasPassword` is `false`, `$access` should not be granted or should
    be `false`. Instead, `$access` becomes `true` as the statement evaluated like
    `(($access = $hasUsername) and $hasPassword)` and the user is granted access without
    a password.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，由于 `$hasPassword` 是 `false`，因此不应授予 `$access` 或应将其设置为 `false`。相反，由于语句被评估为
    `(($access = $hasUsername) and $hasPassword)`，`$access` 变为 `true`，并且用户在没有密码的情况下被授予访问权限。
- en: Therefore, to avoid such a bad evaluation of an expression, it is recommended
    practice to use parentheses to evaluate expressions as a unit within the parentheses.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了避免这种表达式的不良评估，建议使用括号将表达式作为一个单元在括号内进行评估。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`and` and `or` have lower precedence than `=` but `||` and `&&` have higher
    priority.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 和 `or` 的优先级低于 `=`，但 `||` 和 `&&` 的优先级更高。'
- en: Comparison Operators
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: We often need to compare values to decide the program flow. For example, we
    may want to ride in a four-seater car and we need to make sure that the number
    of passengers doesn't exceed the car's capacity. So, in programming, to examine
    such conditions, we often utilize **comparison operators**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要比较值以决定程序流程。例如，我们可能想乘坐四座车，我们需要确保乘客数量不超过车的容量。因此，在编程中，为了检查此类条件，我们经常利用**比较运算符**。
- en: Comparison operators compare two values and return `true` or `false` based on
    the given comparison. A comparison involves checking whether two values are equal
    or not equal, equal and of the same data type or not, less than, greater than,
    and so on. Alternatively, you can have mixed comparisons such as less than or
    equal to, greater than or equal to, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符比较两个值，并根据给定的比较返回`true`或`false`。比较涉及检查两个值是否相等，是否为相同的数据类型，是否小于、大于等。或者，您还可以有混合比较，如小于等于、大于等于等。
- en: PHP introduces a whole new type of comparison operator – the spaceship operator,
    `<=>`, which checks the equality of two numbers and allows us to know which number
    is the greater of the two.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PHP引入了一种全新的比较运算符——太空船运算符`<=>`，它可以检查两个数字的相等性，并允许我们知道哪个数字更大。
- en: 'Let''s check out the comparison operators and their behaviors:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看比较运算符及其行为：
- en: '![Figure 3.3: Operators and their descriptions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3：运算符及其描述'
- en: '](img/C14196_03_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_03_03.jpg](img/C14196_03_03.jpg)'
- en: 'Figure 3.3: Operators and their descriptions'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：运算符及其描述
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Type conversion takes place when we compare two different types of values, such
    as an integer and a string. The string will be converted to a number for numeric
    comparison; that is, `1 == "01"` is equivalent to `1 == 1`. For `===` and `!==`,
    which compares the type along with the value, type conversion is not applicable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较不同类型的值时，例如整数和字符串，会发生类型转换。字符串将被转换为数字以进行数值比较；也就是说，`1 == "01"`等价于`1 == 1`。对于`===`和`!==`，它们比较类型和值，类型转换不适用。
- en: For various type comparisons, see *Comparison with various types*, which is
    available at [https://packt.live/2Vsk4NZ](https://packt.live/2Vsk4NZ).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于各种类型比较，请参阅*与各种类型的比较*，可在[https://packt.live/2Vsk4NZ](https://packt.live/2Vsk4NZ)找到。
- en: 'Check out some interesting examples of comparison operators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一些比较运算符的有趣示例：
- en: '![Figure 3.4: Table of comparison operators'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4：比较运算符表'
- en: '](img/C14196_03_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_03_04.jpg](img/C14196_03_04.jpg)'
- en: 'Figure 3.4: Table of comparison operators'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：比较运算符表
- en: With the preceding different types of examples, hopefully, we should have a
    clear picture of comparison operators and behind-the-scenes type juggling.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的不同类型示例，我们希望对比较运算符及其背后的类型转换有一个清晰的了解。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: During the evaluation of expressions, the precedence of comparison operators
    is higher than Boolean operators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式的评估过程中，比较运算符的优先级高于布尔运算符。
- en: For example, in this multiple expression, `($smallNumber > 2 && $smallNumber
    < 5)`, the comparisons are performed before the Boolean operation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个多表达式`($smallNumber > 2 && $smallNumber < 5)`中，比较是在布尔运算之前执行的。
- en: Branching
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支
- en: As we discussed earlier, determining the correct path or choosing one block
    of code to execute among multiple blocks of code can be described as `true` or
    `false`. Hence, following this concept, we get to choose our desired statement
    or groups of statements to execute based on an outcome of a Boolean expression.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，确定正确的路径或从多个代码块中选择一个代码块来执行可以描述为`true`或`false`。因此，根据布尔表达式的结果，我们可以选择执行所需的语句或语句组。
- en: The `if` and `switch` statements are the two main branching control structures.
    `if` is the most commonly used conditional structure within any programming language.
    `switch` can be used in certain situations where multiple branches can be chosen
    by a single value or expression, or where a series of `if` statements would be
    inconvenient.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`和`switch`语句是两种主要的分支控制结构。`if`是任何编程语言中最常用的条件结构。`switch`可以在某些情况下使用，例如可以通过单个值或表达式选择多个分支，或者当一系列`if`语句不方便时。'
- en: The if Statement
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: 'The syntax of `if` is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`的语法如下：'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, `if (expression)` is the control structure, and `statement` is a single-line
    statement terminated with a semicolon or multiple statements enclosed in a pair
    of curly braces, like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`if (expression)`是控制结构，而`statement`是一个以分号结束的单行语句，或者是一对大括号内包含的多条语句，如下所示：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, if the result of the expression evaluates to `true`, the next statement
    or block of statements should be executed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果表达式的结果评估为`true`，则应执行下一个语句或语句块。
- en: 'Let''s look at an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding expression produces Boolean `true` so it executes the `true` branch.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式产生布尔`true`，因此执行`true`分支。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A control structure body might contain a single statement, an enclosed block
    of statements, or another conditional structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构体可能包含一个单独的语句、一个封闭的语句块或另一个条件结构。
- en: The if…else Statement
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if…else语句
- en: With the `if` control structure evaluated as `true`, we can execute the block
    of statements that immediately follow, but what if the evaluation produces `false`
    within the control expression? We can add an optional `else` block to execute
    the statements in it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当`if`控制结构评估为`true`时，我们可以执行紧随其后的语句块，但如果控制表达式中的评估产生`false`，怎么办？我们可以在其中添加一个可选的`else`块来执行其中的语句。
- en: 'Let''s see the syntax of the `if…else` statement:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`if…else`语句的语法：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `else` is the fallback if the condition is `false`. With the `else` block,
    we can execute statements based on a conditional expression evaluation of `false`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`else`是当条件为`false`时的后备选项。使用`else`块，我们可以根据条件表达式评估为`false`来执行语句：
- en: '![Figure 3.5: The if…else statement'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：if…else语句](#)'
- en: '](img/C14196_03_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_03_05.jpg](img/C14196_03_05.jpg)'
- en: 'Figure 3.5: The if…else statement'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：if…else语句
- en: 'Let''s look at another example of the `if..else` control structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`if..else`控制结构的另一个例子：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have seen the basic implementation of the `if` and `if…else` statements,
    let's create a few basic scripts in the next two exercises to implement them and
    observe how branching occurs in actual programs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`if`和`if…else`语句的基本实现，让我们在接下来的两个练习中创建一些基本的脚本来实现它们，并观察实际程序中分支是如何发生的。
- en: 'Exercise 3.1: Creating a Basic Script to Implement the if...else Test Case'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.1：创建一个基本的脚本以实现if...else测试用例
- en: 'In the following exercise, you will learn to acquire the day using PHP''s built-in
    `date()` function. You will be using an `if...else` test case to check whether
    today is Sunday, and then print `Get rest` or `Get ready and go to the office`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将学习如何使用PHP的内置`date()`函数获取日期。你将使用`if...else`测试用例来检查今天是否是星期日，然后打印`Get
    rest`或`Get ready and go to the office`：
- en: 'Create a PHP file named `test-sunday.php` and insert the following content:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test-sunday.php`的PHP文件，并插入以下内容：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we have used a built-in `date` function with a date format flag, `l` (lowercase
    L), which returns a textual representation of the current day of the week; that
    is, *Sunday through Saturday*. Note that *uppercase* is used for the first character
    in the day string; that is, Sunday since the function returns that way.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个带有日期格式标志的内置`date`函数，即`l`（小写L），它返回当前星期的文本表示；即从*星期日到星期六*。请注意，*大写*用于日期字符串中的第一个字符；即星期日，因为函数以这种方式返回。
- en: The `if` conditional expression, `("Sunday" === date("l"))`, matches the returned
    day name with "*Sunday*". If today is Sunday, then `("Sunday" === "Sunday")` identically
    matches and yields `true` and prints "`Get rest`"; otherwise, it prints "`Get
    ready and go to the office`".
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if`条件表达式`("Sunday" === date("l"))`将返回的星期名称与"*Sunday*"匹配。如果今天是星期日，那么`("Sunday"
    === "Sunday")`将完全匹配并产生`true`，并打印"`Get rest`"；否则，它将打印"`Get ready and go to the
    office`"。'
- en: 'Run the PHP file from a Terminal or console, like the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端或控制台运行PHP文件，如下命令所示：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The script prints `Get rest` if today is Sunday; otherwise, it prints `Get ready
    and go to the office`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果今天是星期日，脚本将打印`Get rest`；否则，它将打印`Get ready and go to the office`。
- en: '![Figure 3.6: The if…else script output'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6：if…else脚本输出](#)'
- en: '](img/C14196_03_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_03_06.jpg](img/C14196_03_06.jpg)'
- en: 'Figure 3.6: The if…else script output'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：if…else脚本输出
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the PHP `date` function at [https://packt.live/35mGNzC](https://packt.live/35mGNzC).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/35mGNzC](https://packt.live/35mGNzC)找到更多关于PHP `date`函数的信息。
- en: 'Exercise 3.2: Implementing the Nested if...else Structure'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.2：实现嵌套的if...else结构
- en: In the following exercise, we will practice using a nested `if...else` structure
    with a different sort of expression within the control statement. We will create
    a script that will print the difference between two given numbers based on the
    fact that one number is greater than the other one and the numbers are not equal.
    Here, both numbers are positive integers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将练习使用嵌套的`if...else`结构，并在控制语句中使用不同类型的表达式。我们将创建一个脚本，该脚本将根据一个数大于另一个数且这两个数不相等的事实来打印两个给定数字之间的差异。在这里，这两个数都是正整数。
- en: 'With the help of a nested `if...else` structure, we will be testing whether
    the numbers are equal or not. If they''re not equal, then we''ll determine which
    number is greater and subtract the other number from it to print the difference:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套的`if...else`结构，我们将测试数字是否相等。如果不相等，我们将确定哪个数字更大，并从另一个数字中减去以打印差值：
- en: Create a PHP file named `test-difference.php`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test-difference.php`的PHP文件。
- en: 'Declare two variables, `$a` and `$b`, and assign them values of `5` and `3`
    respectively, like the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个变量，`$a`和`$b`，并分别将它们的值设置为`5`和`3`，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Insert an `if…else` structure, like the following content:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个`if…else`结构，如下所示的内容：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we already know, the result of the expression ID evaluates to `true` or `false`,
    and for a non-Boolean result should be typecast to Boolean. The example expression
    `($a - $b)` depends on the fact that `0` is considered as `false`, so *if the
    difference is zero*, then the expression will be evaluated as `false`, hence "`The
    numbers are equal`" will be printed.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所知，表达式ID的结果评估为`true`或`false`，对于非布尔结果应转换为布尔类型。示例表达式`($a - $b)`取决于`0`被视为`false`的事实，所以*如果差值为零*，则表达式将被评估为`false`，因此将打印"`数字相等`"。
- en: 'Add another `if…else` structure inside the `if` case body to deal with numbers
    with a difference, like the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`情况体内添加另一个`if…else`结构来处理差值数字，如下所示：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, the inner `if...else` determines which number is greater
    and subtracts the other from it to print the difference.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的例子中，内部`if...else`确定哪个数字更大，并从另一个数字中减去以打印差值。
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从终端或控制台运行PHP文件：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The script prints "`The difference is 2`" if the numbers are not equal; otherwise,
    it prints "`The numbers are equal`" as there is no difference:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果数字不相等，脚本将打印"`差值是2`"；否则，由于没有差值，将打印"`数字相等`"：
- en: '![Figure 3.7: The nested if…else script output'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.7：嵌套的if…else脚本输出'
- en: '](img/C14196_03_07.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_03_07.jpg)'
- en: 'Figure 3.7: The nested if…else script output'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7：嵌套的if…else脚本输出
- en: Tweak the values of `$a` and `$b` and rerun the script for different results.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`$a`和`$b`的值，并重新运行脚本以获得不同的结果。
- en: '*Our goal is to achieve different conditional coverage*, developing the `if…else`
    control structure. The `if...else` construct executes the `true` branch with the
    condition evaluated as `true`; otherwise, it executes the `false` branch.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*我们的目标是实现不同的条件覆盖率*，开发`if…else`控制结构。`if...else`结构在条件评估为`true`时执行`true`分支；否则，执行`false`分支。'
- en: The Ternary Operator
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'The ternary operator can be considered as a shorthand `if..else` statement
    with the following syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将三元运算符视为具有以下语法的简写`if..else`语句：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, if `expression1` evaluates to `true`, `expression2` should be executed;
    otherwise, `expression3` executes a `false` evaluation of `expression1`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`expression1`评估为`true`，则执行`expression2`；否则，`expression3`执行`expression1`的`false`评估。
- en: 'Ternary operators can be used for assigning default values, like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符可以用于分配默认值，如下所示：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, if today is Sunday, then it will print "`Get rest`";
    otherwise, it will print `Get ready and go to the office`, and we can evaluate
    the condition to return a value on a single line. Ternary operators are suitable
    for some cases, especially assigning default values, being used in a `return`
    statement to evaluate and return a value, or being used in between a dynamic string
    to parse and print the output.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果今天是星期日，则将打印"`休息`"；否则，将打印`Get ready and go to the office`，并且我们可以评估条件以在单行上返回一个值。三元运算符适用于某些情况，特别是用于分配默认值，在`return`语句中用于评估和返回一个值，或者用于动态字符串中解析和打印输出。
- en: 'It is also possible to write a ternary operator in the following way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以用以下方式编写三元运算符：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will print the value of the `$msg` variable if it is not empty; otherwise,
    it will print `"Get ready and go to the office`".
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$msg`变量不为空，则将打印其值；否则，将打印`"Get ready and go to the office"`。
- en: The if…elseif…else Statement
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if…elseif…else语句
- en: Consider an example where you need to evaluate a set of conditions. Say, you
    want to display a letter grade for an exam based on a range of GPA numbers (out
    of 4 points); that is, 3.80 to 4 gets grade A+, 3.75 to below 3.80 gets grade
    A, and so on. So, we need to start from the top condition if the GPA is greater
    or equal to 3.80, then we can define the GPA as A+; otherwise, if the GPA is greater
    than or equal to 3.75, then it's an A grade as we have already fallen back from
    the top condition. If the GPA is greater than or equal to 3.50, then the grade
    would be A-, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个需要评估一系列条件的例子。比如说，你想要根据GPA（满分4分）的范围显示考试的成绩等级；也就是说，3.80到4分得到A+等级，3.75到3.80以下得到A等级，依此类推。因此，如果GPA大于或等于3.80，我们需要从最高条件开始，然后我们可以将GPA定义为A+；否则，如果GPA大于或等于3.75，那么它就是A等级，因为我们已经从最高条件回退了。如果GPA大于或等于3.50，那么成绩将是A-，依此类推。
- en: Consider an article publishing application, where we need to allocate different
    actions based on the type of user role. Say, if the user is an editor, then the
    user can create, read, edit, publish, and delete articles. If the user is an author,
    they can only create, read, and edit articles. If the user is a reader, they can
    only read and comment on articles, and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个文章发布应用程序，其中我们需要根据用户角色的类型分配不同的操作。比如说，如果用户是编辑，则用户可以创建、阅读、编辑、发布和删除文章。如果用户是作者，他们只能创建、阅读和编辑文章。如果用户是读者，他们只能阅读和评论文章，等等。
- en: 'Therefore, we might want to evaluate a set of expressions like in the preceding
    example in order to cover more scenarios. This is where a cascading sequence of
    expressions should be evaluated, like the following nested `if…elseif…else` statement
    syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能想要评估一系列表达式，如前例所示，以覆盖更多场景。这就是需要评估级联表达式序列的地方，如下嵌套的`if…elseif…else`语句语法：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `if…elseif…else` syntax is just the same as the `if…else if…else` statement,
    as in the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if…elseif…else`语法与`if…else if…else`语句相同，如下所示：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, more expressions can be evaluated by cascading the `if...else` statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，可以通过级联`if...else`语句来评估更多的表达式。
- en: 'With such a control structure, we can evaluate whether a number is positive,
    negative, or zero. Check out the following simple example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的控制结构，我们可以评估一个数字是正数、负数还是零。查看以下简单示例：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have tried to determine the characteristics of an integer number in
    `$n` and we have covered three simple scenarios; that is, checking whether the
    number is positive, checking whether the number is negative, and finally, we can
    fall back to the decision that the number is zero. You can add more expressions
    to be evaluated with `elseif` statements like this. The structure of the `if…else`
    statement supports multiple branching and allows you to execute only a single
    branch of statements that has a successful Boolean evaluation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们尝试确定整数`$n`的特性，并涵盖了三个简单场景；即检查数字是否为正数，检查数字是否为负数，最后，我们可以回退到数字为零的决策。你可以添加更多使用`elseif`语句评估的表达式，就像这样。`if…else`语句的结构支持多分支，并允许你只执行具有成功布尔评估的单个语句分支。
- en: 'Exercise 3.3: Creating a Script Using the if... elseif... else Statement'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.3：使用if...elseif...else语句创建脚本
- en: In the following exercise, you will learn how to utilize the `if...elseif...else`
    control structure to determine an age range. We will create a script that has
    a variable named `$age` with a number representing the age. If the age value is
    equal to or greater than 18, then print "`young`"; otherwise, if the age value
    is less than 18 and greater than 10, print "`teenager`". If the age is less than
    10, then print "`child`".
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将学习如何利用`if...elseif...else`控制结构来确定年龄范围。我们将创建一个脚本，其中包含一个名为`$age`的变量，该变量包含一个代表年龄的数字。如果年龄值等于或大于18，则打印"`young`"；否则，如果年龄值小于18且大于10，则打印"`teenager`"。如果年龄小于10，则打印"`child`"。
- en: 'We will determine the age range from the value given in the `$age` variable
    and print the age category accordingly:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据`$age`变量中给出的值确定年龄范围，并相应地打印年龄类别：
- en: Create a PHP file named `test-age.php`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test-age.php`的PHP文件。
- en: 'Declare the `$age` variable as in the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`$age`变量如下：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Insert the following `if…elseif…else` structure:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下`if…elseif…else`结构：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have used comparison operators, which were discussed in previous sections.
    The `($age >= 18)` statement determines whether the age is greater than or equal
    to 18\. If the age is neither greater nor equal to 18, then the execution falls
    to the next test expression, `($age > 10)` to check whether the age is greater
    than 10 as the age is already less than 18\. Again, if the `($age > 10)` expression
    doesn't return `true`, the age will be considered to be less than 10, hence, categorized
    as "`Child`".
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了之前章节中讨论的比较运算符。`($age >= 18)`语句确定年龄是否大于或等于18。如果年龄既不大于也不等于18，则执行将跳转到下一个测试表达式，`($age
    > 10)`检查年龄是否大于10，因为年龄已经小于18。再次，如果`($age > 10)`表达式不返回`true`，则年龄将被认为是小于10，因此被归类为"`Child`"。
- en: 'Run the PHP file from a Terminal or console, as in the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端或控制台运行PHP文件，如下命令所示：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The script prints "`Young`", "`Teenager`", and "`Child`" based on different
    age ranges:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本根据不同的年龄范围打印出"`Young`"，"`Teenager`"和"`Child`"：
- en: '![Figure 3.8: The if…elseif…else script output'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.8：if…elseif…else脚本输出'
- en: '](img/C14196_03_08.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_03_08.jpg)'
- en: 'Figure 3.8: The if…elseif…else script output'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.8：if…elseif…else脚本输出
- en: 'You might also want to add more test expressions to cover another age range,
    as in the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想添加更多的测试表达式来覆盖另一个年龄范围，如下所示：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we have added `($age > 25)` as another test expression to show the cascaded
    `if…else` structure.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们添加了`($age > 25)`作为另一个测试表达式来展示级联的`if…else`结构。
- en: Note
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The tested age ranges and printed age categories are just for a learning demo.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试的年龄范围和打印的年龄类别仅用于学习演示。
- en: The switch Case
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch Case
- en: A `switch` statement provides `if` statements on the same expression and having
    a default block like the final `else` statement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句提供了与同一表达式上的`if`语句，并具有默认块，就像最后的`else`语句。'
- en: 'According to the yielded value of the expression, the proper case with an appropriate
    value is picked for execution. The expression can be any kind of expression or
    a variable that gives a value such as a number or a string:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表达式的返回值，选择适当的带有适当值的case进行执行。表达式可以是任何类型的表达式或变量，它给出一个值，如数字或字符串：
- en: '![Figure 3.9: A switch diagram'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：switch图'
- en: '](img/C14196_03_09.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_03_09.jpg)'
- en: 'Figure 3.9: A switch diagram'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：switch图
- en: 'The syntax of the `switch` case is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的语法如下：'
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is what is happening in the preceding code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码中发生的情况：
- en: '`switch(…){…}` is the control structure.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch(…){…}`是控制结构。'
- en: '`expression` is the expression that produces a value to be matched in the different
    cases.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression`是产生要匹配的不同情况的值的表达式。'
- en: '`case value:…` is the block of statements to be executed. In order to execute
    the block, the case value should be similar to the expression''s yielded value.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case value:…`是要执行的语句块。为了执行该块，case值应该与表达式的返回值相似。'
- en: '`default:` is the default block of statements to be executed if the `switch`
    expression''s yielded value doesn''t match any cases, just like `else`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default:`是当`switch`表达式的返回值不匹配任何case时要执行的语句块，就像`else`一样。'
- en: Note
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A `switch` case does a loose comparison. A loose comparison means it won't check
    the type. The value evaluated from a `switch` expression should be equal to the
    matching case value without checking the type. Say, the `switch` expression evaluated
    to number 1 can be matched or is equal to the case values, such as string "1",
    float 1.00, or Boolean true.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`switch`case进行松散比较。松散比较意味着它不会检查类型。从`switch`表达式评估的值应该等于匹配的case值，而无需检查类型。比如说，`switch`表达式评估为数字1可以匹配或等于case值，如字符串"1"，浮点数1.00或布尔值true。'
- en: 'Here is an example `switch` statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`switch`语句的示例：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding `switch` statement executes the `$fruit` expression, which is
    a variable with a value in it, so the value should be matched with the case values
    and the corresponding case statements should be executed until the `break;` statement
    occurs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`switch`语句执行`$fruit`表达式，这是一个包含值的变量，因此应该将值与case值匹配，并执行相应的case语句，直到出现`break;`语句。
- en: 'We need to be careful with `switch` statement usage and the use of `break;`.
    Just as in the following example, PHP will continue executing the statements without
    a break:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用`switch`语句和`break;`时需要小心。就像以下示例一样，PHP将继续执行没有`break`的语句：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For `$n` is `0`, the preceding example will print "`the number is 0 the number
    is 1 the number is 2`". For `$n` is `1`, it will output "`the number is 1 the
    number is 2`", so we need to add a `break;` statement at the end of each case.
    We will discuss the `break;` statement in our next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `$n` 为 `0`，前面的示例将打印 "`the number is 0 the number is 1 the number is 2`"。对于
    `$n` 为 `1`，它将输出 "`the number is 1 the number is 2`"，因此我们需要在每个情况的末尾添加一个 `break;`
    语句。我们将在下一节讨论 `break;` 语句。
- en: In a `switch` statement, the given condition is evaluated to match the resultant
    value with the value of each case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 语句中，给定的条件被评估以匹配结果值与每个情况的值。
- en: 'Also, multiple cases within the same block of statements can be written as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，同一块语句中的多个情况可以写成如下形式：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With a `default` case, we can extend the preceding example as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `default` 情况，我们可以扩展前面的示例如下：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `switch` cases support alternative syntax for a control structure. For more
    information, check out [https://packt.live/2M0IMli](https://packt.live/2M0IMli).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 情况支持控制结构的替代语法。更多信息，请查看[https://packt.live/2M0IMli](https://packt.live/2M0IMli)。'
- en: Now, we will detect data types with a `switch` case in order to print the data
    types in an exercise.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检测数据类型，并在练习中使用 `switch` 情况来打印数据类型。
- en: 'Exercise 3.4: Creating a Script to Implement a Switch Case'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.4：创建一个实现 Switch Case 的脚本
- en: In the following exercise, we will create a script that will get the type of
    a variable using the built-in `gettype()` function in a `switch` test case and
    print custom messages for different data types.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将创建一个脚本，该脚本将使用内置的 `gettype()` 函数在 `switch` 测试情况中获取变量的类型，并为不同的数据类型打印自定义消息。
- en: 'For the `integer` and `double` data types, we will print "`The data type is
    Number.`". Print "`The data type is Boolean`", "`The data type is String`", and
    "`The data type is Array`" for the `boolean`, `string`, and `array` types, respectively.
    Also, print "`The data type is unknown`" for unknown data types and the rest of
    the data types:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `integer` 和 `double` 数据类型，我们将打印 "`The data type is Number.`"。对于 `boolean`，`string`
    和 `array` 类型，分别打印 "`The data type is Boolean`"，"`The data type is String`" 和 "`The
    data type is Array`"。对于未知数据类型和其他数据类型，打印 "`The data type is unknown`"。
- en: Create a PHP file named `test-datatype.php`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test-datatype.php` 的 PHP 文件。
- en: 'Declare the `$data` variable like the following:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `$data` 变量如下：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we have declared a variable that contains a numeric value of type `double`.
    We could have added other types of data as well.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个包含 `double` 类型数值的变量。我们还可以添加其他类型的数据。
- en: 'So, in order to get the type of the `$data` variable and match the appropriate
    case, let''s insert the following `switch` structure:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了获取 `$data` 变量的类型并匹配适当的情况，让我们插入以下 `switch` 结构：
- en: '[PRE41]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we have used the built-in `gettype()` function, which returns the type
    of `$data`, such as "`boolean`", "`integer`", "`double`", "`string`", "`array`",
    "`object`", "`resource`", "`NULL`", and "`unknown` `type`".
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了内置的 `gettype()` 函数，它返回 `$data` 的类型，例如 "`boolean`"，"`integer`"，"`double`"，"`string`"，"`array`"，"`object`"，"`resource`"，"`NULL`"，以及
    "`unknown` `type`"。
- en: We already know that to execute the same statements for multiple cases, we can
    combine the cases. For "`integer`" and "`double`" strings returned by the `switch`
    expression, since the requirement is to print the same message for both, as the
    type is a number, we kept both cases together. Also, for other data types, we
    have dealt with matching `case` statements, and the rest of the types, and even
    unknown types, have been addressed by the `default` case.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经知道，为了对多个情况进行相同的语句执行，我们可以合并这些情况。对于由 `switch` 表达式返回的 "`integer`" 和 "`double`"
    字符串，由于要求对两者打印相同的信息，因为类型是数字，所以我们把这两个情况放在一起。另外，对于其他数据类型，我们已经处理了匹配的 `case` 语句，其余的类型，甚至是未知类型，都由
    `default` 情况处理。
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从终端或控制台运行 PHP 文件：
- en: '[PRE42]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The script prints different messages for different data types:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本为不同的数据类型打印不同的消息：
- en: '![Figure 3.10: The switch case output'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.10：switch 情况输出'
- en: '](img/C14196_03_10.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_03_10.jpg)'
- en: 'Figure 3.10: The switch case output'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.10：switch 情况输出
- en: Tweak the value of `$data` with different types of data and rerun the script
    for different outputs.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同类型的数据调整 `$data` 的值，并重新运行脚本以获得不同的输出。
- en: Looping
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: A loop is a block of statements written once but executed several times. The
    code within a loop or the body of a loop is executed a finite number of times,
    determined by whether certain conditions are met or they may be infinite!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一块只写一次但执行多次的语句块。循环体内的代码或循环体执行有限次数，这取决于是否满足某些条件，或者它们可能是无限的！
- en: In this chapter, we will be discussing `for`, `foreach`, `while`, and `do…while`
    loops with their structures and examples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论`for`、`foreach`、`while`和`do…while`循环及其结构和示例。
- en: Bounded Loops versus Unbounded Loops
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有界循环与无界循环
- en: A **bounded** loop has a loop iteration limit and hence executes till that boundary
    is met. To restrict it to that finite number of iterations, the number of iterations
    is easily visible in the loop condition or in loop statements and the language
    constructs assure that it won't loop beyond that.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**有界**循环有一个循环迭代限制，因此它执行到达到那个边界。为了将其限制在有限的迭代次数内，迭代次数在循环条件或循环语句中很容易看到，并且语言结构确保它不会超出那个范围。
- en: Again, an **unbounded** loop iterates until a certain condition is met and the
    condition can be controlled from inside the loop. *Bounded loops are also called
    count-controlled loops* as you can control the iteration count with the help of
    language constructs; similarly, *unbounded loops are condition-controlled loops*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一个**无界**循环会一直迭代，直到满足某个条件，并且可以从循环内部控制条件。*有界循环也称为计数控制循环*，因为您可以使用语言结构来控制迭代次数；同样，*无界循环是条件控制循环*。
- en: In PHP, `while`, `do…while`, and `for` are all unbounded loops and, regardless
    of the loop control portion (entry controlled or exit controlled), they are almost
    the same. We will look at examples of these looping techniques and their application
    in different use cases.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，`while`、`do…while`和`for`都是无界循环，无论循环控制部分是入口控制还是出口控制，它们几乎都是相同的。我们将查看这些循环技术的示例及其在不同用例中的应用。
- en: The while Loop
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'The `while` loop is one of the simplest looping constructs. The syntax is as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是最简单的循环结构之一。其语法如下：'
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `while (expression) {…}` is the control structure that checks the possibility
    of executing the loop in the `expression` condition, followed by a single statement,
    or multiple statements can be enclosed in by a pair of curly braces:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`while (expression) {…}`是检查在`expression`条件中执行循环可能性的控制结构，后跟一个单条语句，或者可以由一对花括号括起来的多条语句：
- en: '![Figure 3.11: A while loop diagram'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11：while循环图解'
- en: '](img/C14196_03_11.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_03_11.jpg)'
- en: 'Figure 3.11: A while loop diagram'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：while循环图解
- en: In a `while` loop, the condition expression is evaluated as a Boolean. For the
    first iteration, the expression should be evaluated to `true` in order to execute
    the statement(s). Then, it checks for the condition again to proceed with the
    next iteration. If the condition produces `false`, the loop terminates without
    proceeding further.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，条件表达式被评估为布尔值。为了执行第一条语句，表达式应该评估为`true`。然后，它再次检查条件以进行下一次迭代。如果条件产生`false`，则循环终止，不会进一步执行。
- en: 'For example, the following loop will never be executed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下循环将永远不会执行：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Again, the following loop might execute forever:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，以下循环可能会永远执行：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, `PHP_EOL` holds the end of line character, and was used at the end of
    the string to print the next string on a new line.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PHP_EOL`包含行结束字符，并在字符串末尾使用，以便在新的行上打印下一个字符串。
- en: 'You can set how many times a loop will iterate with a given condition, as in
    the following loop, which executes exactly seven times:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用给定的条件设置循环迭代的次数，如下面的循环，它将正好执行七次：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `$count` starts with value `1` and gets incremented by 1 with the `$count++`
    statement. The loop will print 7 lines, and at iteration number 8, the `$count`
    will contain 8, so the `($count <= 7)` condition becomes `false`, and printing
    is terminated. So, with the `count` control, we can bound the `while` loop to
    execute a certain number of times.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$count`从值`1`开始，通过`$count++`语句增加1。循环将打印7行，在第8次迭代时，`$count`将包含8，因此`($count
    <= 7)`条件变为`false`，打印终止。因此，通过`count`控制，我们可以将`while`循环限制在执行特定次数。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The condition was evaluated at the beginning of the loop; that's why the `while`
    loop is an entry-controlled loop.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是在循环开始时评估的；这就是为什么`while`循环是入口控制循环。
- en: 'Exercise 3.5: Printing the Numbers 1 to 10 Using a while Loop'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.5：使用while循环打印数字1到10
- en: 'In this exercise, we will simply iterate through a `while` loop to print numbers
    1 through 10 and will apply a condition expression to check the numbers are within
    a range of 1 to 10 as we will be incrementing the number by 1:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将简单地通过`while`循环迭代以打印数字1到10，并将应用一个条件表达式来检查数字是否在1到10的范围内，因为我们将会每次增加数字1：
- en: Create a PHP file named `print-numbers-while.php`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print-numbers-while.php`的PHP文件。
- en: Declare a `$number` variable and initialize it to `1`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`$number`变量并将其初始化为`1`。
- en: 'Insert a `while` loop to print numbers 1 to 10:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个`while`循环以打印数字1到10：
- en: '[PRE47]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have initialized the number as `1` in the `$number` variable. With
    the `($number <= 10)` condition expression, we can guarantee that the loop will
    not execute or it will not print if the number is greater than 10.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将数字初始化为`1`存储在`$number`变量中。通过`($number <= 10)`条件表达式，我们可以保证如果数字大于10，循环将不会执行或打印。
- en: At the end, we produced the next number by incrementing the `$number++;` variable.
    Here, we used an empty string, `" "`, as a number separator.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们通过增加`$number++;`变量来产生下一个数字。在这里，我们使用空字符串`" "`作为数字分隔符。
- en: So, Boolean expressions allow us to write test cases with limits or boundaries.
    Plus, a looping technique can execute a set of statements within those limits
    or boundaries.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，布尔表达式允许我们编写带有限制或边界的测试用例。此外，循环技术可以在这些限制或边界内执行一系列语句。
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从终端或控制台运行PHP文件：
- en: '[PRE48]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The script prints 1 through 10:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本打印1到10：
- en: '![Figure 3.12: The while loop output'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.12：while循环输出'
- en: '](img/C14196_03_12.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_03_12.jpg)'
- en: 'Figure 3.12: The while loop output'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.12：while循环输出
- en: Tweak the script with different conditional expressions and rerun it to see
    the new outputs.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的条件表达式调整脚本并重新运行，以查看新的输出。
- en: The do…while Loop
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do…while循环
- en: In contrast with the `while` loop, the `do…while` loop comes with the expression
    evaluation at the end. This means that the loop will iterate through once to execute
    the code within the loop before the condition is ever evaluated.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环相比，`do…while`循环在表达式评估结束时进行。这意味着循环将先执行一次，在条件评估之前执行循环内的代码。
- en: 'The syntax of such an exit-controlled loop is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退出控制的循环的语法如下：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, `do {…} while (expression)` is the control structure and the expression
    is the conditional expression, which gives a Boolean result:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`do {…} while (expression)`是控制结构，表达式是条件表达式，它给出一个布尔结果：
- en: '![Figure 3.13: The do…while loop diagram'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：do…while循环图'
- en: '](img/C14196_03_13.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_03_13.jpg)'
- en: 'Figure 3.13: The do…while loop diagram'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：do…while循环图
- en: 'For example, the following loop will be executed once regardless of whether
    the condition evaluates to `false`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下循环将只执行一次，无论条件评估结果为`false`与否：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the first iteration of the `do...while` loop will execute as the expression
    evaluation comes at the end. If the condition is `true`, then the second iteration
    takes place; otherwise, with `false`, it prevents further looping.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`do...while`循环的第一次迭代将在表达式评估结束时执行。如果条件为`true`，则进行第二次迭代；否则，如果为`false`，则防止进一步的循环。
- en: So, we can make use of `while` or `do...while` looping based on the fact that
    one is entry controlled and the other is an exit controlled loop.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以根据一个是入口控制循环而另一个是退出控制循环的事实来使用`while`或`do...while`循环。
- en: 'You can see how many times a loop can iterate with an end condition. The following
    loop executes exactly seven times:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个结束条件来查看循环可以迭代多少次。以下循环将正好执行七次：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, `$count` starts with value `1` and gets incremented by 1 with the `$count++`
    statement. The loop will print 7 lines and at iteration number 7, the `$count`
    will contain 8, so the `($count <= 7)` condition becomes `false`, hence, further
    printing is terminated. So, with the `count` control, we can bound the `do…while`
    loop to execute a certain number of times.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$count`的初始值为`1`，通过`$count++`语句每次增加1。循环将打印7行，在第7次迭代时，`$count`将包含8，因此`($count
    <= 7)`条件变为`false`，因此进一步的打印被终止。所以，通过`count`控制，我们可以将`do…while`循环限制为执行一定次数。
- en: 'Exercise 3.6: Converting a while Loop to a do...while Loop'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.6：将while循环转换为do...while循环
- en: 'In this exercise, we will tweak the previous exercise, replace `while` with
    a `do…while` loop, and rerun the statements to see the outputs:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将调整之前的练习，将`while`循环替换为`do…while`循环，并重新运行语句以查看输出：
- en: Open the `print-numbers-while.php` file and copy the contents into a new file
    named `print-numbers-do-while.php`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `while` loop with `do...while`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have replaced the previous `while` loop with a `do...while` control
    structure.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difference with the previous looping technique is that condition testing
    has been placed at the end of the structure as `do...while` is an exit controlled
    loop. The loop should execute at least once regardless of the condition. If the
    end expression evaluates to `true`, we proceed with the next iteration. All looping
    techniques use a conditional expression to check the eligibility of the next iteration
    in order to guarantee finite looping.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The script prints 1 through 10 with the replaced `do...while` loop:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.14: The do…while loop output'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_14.jpg)'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.14: The do…while loop output'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the script with different conditional expressions and rerun the script
    to see the new outputs.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The for Loop
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections, we discussed `while` and `do…while` loop structures and
    saw the way they iterate based on entry and exit conditions. We also looked at
    the use of a counter or a number initiated from `0` or `1` that gets incremented
    in each iteration using the post-increment `++` operator and checked that the
    counter or number doesn't exceed the limit. In practice, `while` and `do…while`
    loops use a loop step value declared before the loop and the step value incremented
    or decremented inside the loop. This loop step value is used to check the limit
    of the loop condition. Hence, we need to arrange our way of controlling loop iterations
    in the case of `while` and `do…while`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: To observe such common practice, the `for` loop can be used, with the structure
    itself providing expressions for initiating the loop step variable, the step value
    checking condition, and the step increment/decrement statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the syntax of a `for` loop:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, `for (expression1; expression2; expression3) {…}` is the control structure
    and `expression2` is the conditional expression evaluated as a Boolean.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The first expression, `expression1`, is an unconditional expression that is
    evaluated at the very start of the loop and is considered as a loop initiation
    statement. Prior to each iteration, `expression2` is evaluated as a Boolean expression
    to `true`. The loop body executes in each round. `expression3` is evaluated at
    the end of each iteration.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The empty `expression2` means the loop will run infinitely.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Working of the for loop can be represented as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: A for loop diagram'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_15.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.15: A for loop diagram'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example prints numbers 1 through 10:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding `for` loop executes 10 times and prints 1 through 10\. Here, the
    `$index` variable is initiated to `1` in the first expression. The second expression
    checks whether the value of `$index` is less than or equal to 10 so that the loop
    iteration can be limited to 10 times, and `$index++` increments the value of `$index`
    by 1 after each iteration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is similar to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can terminate the loop execution with a `break` statement, preventing further
    execution within the block.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that an empty `for` loop can be considered as iterating infinitely:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is equivalent to:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Exercise 3.7: Using a for Loop to Print the Days of the Week'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will iterate through an array created to store the days
    of the week using a `for` loop and print the days. We will restrict the loop iterations
    so that the loop doesn''t go beyond the array elements present:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `print-days-for.php`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `$days` array with the names of the seven days of the week, as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add a `for` loop with the three expressions, as in the following code:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the `$totalDays` is the variable that holds the count of the days. The
    number of iterations can be controlled by the `$i < $totalDays` expression since
    `$i` has been started with `0`, which is the first index of the array, so that
    the loop executes exactly the number of elements (days) available in the `$days`
    array. With the completion of each iteration, the index value in `$i` is incremented
    by the `$i++` statement so that we can access the next value within the array.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The script prints the names of the seven days of the week from the given array:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.16: The for loop output'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_16.jpg)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.16: The for loop output'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the script with different loop expressions and rerun it to see the new
    outputs.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The foreach Loop
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've seen how a `for` loop can leverage a loop step variable as an
    index to access an array, but the approach is not feasible for iterating through
    an associative array where you want to use the index or the key as meaningful
    data. Consider a person's information array or an object example, where a person's
    attributes, such as first name, last name, age, email, and so on, have been stored
    against the same attribute names as the keys, so that each key defines what type
    of information has been stored against that index.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, to iterate through an object or an array, we need a specialized
    looping construct – a `foreach` loop.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: With a `foreach` loop, *PHP supports implicit looping through all elements of
    an array or an object*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a `foreach` loop is as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`array_expression` provides an array to iterate over. With each iteration,
    the value of the current element assigned to `$value` and the array pointer is
    incremented by one.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foreach` loop can also be written in the following form:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this form, with each iteration, the current element value is assigned to
    the `$value` variable, and its corresponding key is assigned to the `$key` variable.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: In a `foreach` loop, rather than the Boolean evaluated conditions, the size
    of the array controls how many times a loop executes.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.8: Using a foreach Loop to Print the Days of the Week'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will iterate through an array of the names of the days
    of the week, using a `for` loop and print the days. We will restrict the loop
    iterations so that the loop doesn''t go beyond the array elements present:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Open the `print-days-for.php` PHP script and copy the contents into a new file
    named `print-days-foreach.php`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `for` loop with a `foreach` loop:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding example, the size of the array controls how many times the
    `foreach` loop executes. So, for each element in the array, starting from the
    first, the looping control statement assigns the element value to a variable and
    iterates to execute the statements in the enclosed block.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The script prints the names of the seven days from the given array:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17: The foreach loop output'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_17.png)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.17: The foreach loop output'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Loops
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With increasing program complexity, you may find yourself in a position where
    a single loop may not be able to achieve your program's objectives. In such cases,
    we can use loops within loops; in other words, nested loops.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: To achieve nesting, one loop can be used inside the enclosure of another loop.
    With the first iteration of the outer loop, the inner loop is executed to run
    through the given number of iterations. Again, with the next outer iteration,
    the inner loop is triggered and it completes all its iterations. An inner loop
    structure can be considered as another statement among enclosed statements. Obviously,
    we can use `break` and `continue` (which will be discussed in the next section)
    statements to interrupt the flow of the iteration.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `for` loop can be used as a nested form, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will output the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, you can see that two `for` loops have been used to iterate through the
    two-dimensional array and we have used `$i` & `$j` to generate the indexes to
    access their corresponding values.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of a `for` loop, we could have used two `foreach` loops, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will output the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that the `foreach` loop eliminates the use of an index to access an element
    of an array, so the `foreach` loop is useful for iterating such arrays.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.9: Using Nested foreach Loops'
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will practice loop nesting and will demonstrate how inner
    and outer loops work. We will loop through an array of different professions and
    print each profession. By using a condition, if the profession is equal to "`Teacher`",
    then we'll loop through another array of subjects and print out the subjects as
    well.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the inner loop iterate based on a precondition; that is, *when
    the profession is teacher*. We will enclose the inner loop that prints the subject
    name from the subjects'' array in an `if` control structure:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP script named `print-professions-subjects.php`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the professions in an array, as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Declare the subjects in an array, as follows:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add a `foreach` loop to iterate through the `$professions` array, as follows:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the following inner `foreach` loop to print the subjects if the profession
    is `teacher`, as follows:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is as follows:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we have two different arrays. The `professions` array contains the profession
    names, while the `$subjects` array holds the subject name that is to be printed
    if the profession name matches the "`teacher`" string. We have used a `foreach`
    loop to iterate through the `$professions` array. The first `foreach` loop should
    be considered an outer loop.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The outer loop prints the profession name, and then tests the condition, which
    matches the profession name, `Teacher`. If the profession matches `Teacher`, then
    execute the inner `foreach` loop. The inner loop iterates through the `$subjects`
    array to print the subject's name.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The script prints the profession name from the given array and if the profession
    is `Teacher`, then it prints the subject''s name from the given `$subjects` array:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.18: The nested foreach loop output'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_18.jpg)'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.18: The nested foreach loop output'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the inner loop has been triggered based on a precondition, meaning
    we have used a looping and a branching technique here. We will achieve both by
    using a `for` loop in the next step.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `print-professions-subjects.php` and replace the inner loop as follows:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, the second expression in the `for` loop supports the condition expression,
    so we have composed the expression with two conditions: one that checks whether
    the profession is `Teacher` and another that checks that the array index doesn''t
    exceed the size of the `$subjects` array. The `sizeof()` function is used to determine
    the number of elements in the array.'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The script prints just the same as in *step 6*.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, we can implement the inner loop with any looping techniques, such
    as `while` or `do…while` and rerun the PHP file to see the output.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The break Statement
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at several loops and their implementations so far. However, you
    may come across situations where breaking a loop is necessary. For example, in
    addition to a loop conditional expression, we might want to terminate the loop
    from iterating further based on a condition checked inside the loop. In such cases,
    `break` is quite useful to terminate the innermost loop, providing another control
    for such looping structures.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '*An early exit from the loop is possible using the* `break;` *statement.* `break`
    immediately terminates the execution of any running loop.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement supports an optional argument that determines the execution
    of how many enclosed structures are to be broken out. With a default argument
    of `1`, an immediate enclosing looping structure can be broken out. To break out
    multiple enclosed looping structures, we need to supply a numeric argument; for
    example, `break 2`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the following example:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Check out the following example, which breaks two enclosed loopings:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Both `for` loops should iterate for an infinite time, and to escape them both
    we need to provide a `break` argument of 2\. We can safeguard a `break` statement
    like this with an `if` control structure so that we don't exit the loop without
    a condition.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.10: Using a break Statement to Terminate a Loop''s Execution'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will take the previous exercise of the `while` loop to check whether the
    number is equal to 8, then print `ends the execution of loop`, and then end the
    loop using a `break` statement:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents from the `print-numbers-while.php` file and create a PHP filename,
    `print-numbers-break.php`, with the copied contents.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a conditional `break` statement in the `while` loop''s body, as follows:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we have checked that `$number` is equal to `8` with a conditional expression,
    then printed the given message and terminated the execution. The `break` statement
    has been placed inside the loop, meaning when the `break;` expression is executed,
    the loop can be terminated regardless of whether the looping condition says that
    the loop still has two more iterations.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'After printing `8`, the loop prints the `ends the execution of loop.` message
    and terminates the subsequent iterations with a break:'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.19: The break output'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_19.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.19: The break output'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: The continue Statement
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any loop, we might want to skip any specific iteration based on a certain
    condition. For example, printing the numbers 1 through 10, we might want to skip
    the odd numbers and print the even numbers only. To continue with the next iteration
    and skip the rest of the execution within the enclosed structure, the `continue`
    statement can be used.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` statement supports an optional numeric argument such as the `break`
    statement, which specifies how many levels of enclosing loops it should skip to
    the end of the current iteration(s). The default value, `1`, skips to the end
    of the current iteration and continues with the rest of the iterations.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.11: Using continue to Skip an Item in a List'
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier looping examples, we created a script to print numbers 1 through
    10\. In this exercise, we will take the previous exercises on loop techniques
    to check whether a number is equal to 8, then skip printing the number and continue
    printing the rest:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `print-numbers-continue.php`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `for` loop like the following to print numbers 1 through 10:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Add the following `continue` statement if the number is equal to `8`:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we checked whether `$i` is equal to `8` with a conditional expression,
    then we executed the `continue;` statement. So, from that particular point, the
    iteration skips the rest of the execution and goes for the next iteration. Hence,
    the `print` command for the number 8 can be skipped and it can continue printing
    9 and 10.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'After printing `7`, the loop skips printing `8` and continues printing the
    rest of the numbers:'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.20: The break script output'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_20.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.20: The break script output'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: To exit a loop, a common practice is to use a conditional statement that evaluates
    to `false`, else keep iterating. The `break` and `continue` statements can be
    used as a special way of getting out of a loop or skipping the rest of the execution
    in the current execution.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Control Syntaxes
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP supports an alternative way of writing control structures. As per the alternate
    syntax, we will replace the initial brace with a colon and the closing brace with
    a structure ending statement such as `endif`, `endswitch`, `endfor` or `endwhile`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `if...else` becomes the following:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Or, the `if…elseif…else` syntax with the structure ending statement looks as
    follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `while` loop becomes the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The same goes for the `for` loop:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: So, it is up to us which syntax we follow. *The alternative syntax is supported
    for users of the earlier versions of PHP*. Generally, this book follows the standard
    syntax throughout the book.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP alternative syntaxes can be found at this link: [https://packt.live/2M0IMli](https://packt.live/2M0IMli).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Using System Variables
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command-line arguments can be obtained using the `$argv` system variable. We
    will use `$argv[1]` and `$argv[2]` to obtain the second and third arguments.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '`$argv[0]` is the script name in this case.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line arguments can be passed as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, the `??` the null coalescing operator is used so that if `$argv[1]` or
    `$argv[2]` does not exist or is `NULL` then, we can assign a default number, 5,
    to the `$varA` and `$varB` limit variables.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.1: Creating a Movie Listing Script to Print Movies per Director'
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will practice nested looping and apply conditions to restrict
    the iterations of inner and outer loops. We will have a multi-dimensional associative
    array where the director's name acts as the key to hold an array of movie names.
    So, each element of the associative array contains a director's name as a key
    and the movie names array as a value. We will introduce an outer loop to loop
    through the associative array elements and print the director's name, used as
    a key. Another inner loop should loop through the movie names array of that director
    – that is the key. The arguments act as loop iteration steps to maintain where
    the first argument defines how many times a director's name should be printed
    and the second argument defines how many movie names should be printed from the
    given director.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: The multi-dimensional array contains five directors.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to be performed are as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `activity-movies.php` script file, which takes two arguments, both
    numerical: the first argument will be used for the number of directors, and the
    second one will be used for the number of movies.'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a nested array containing a list with five directors, each entry containing
    a list of five movie titles.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By running the script, print the list of directors and the movie titles, as
    required by the input arguments.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input arguments are not passed, then consider the default value of 5
    for both.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s some sample output of running the `php activity-movies.php 3 2` script:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 506.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tips for Control Structures
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices while working with control structures:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: If you need multiple `if` or `elseif` statements, you might consider replacing
    them with a `switch` case as a `switch` statement is faster.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid deeply nested control structures such as `if { if { if { ... }}}` or `for(;;)
    { for(;;){ for (;;){ … } } }` as deep nesting ties one condition to another and
    when we need to make a modification to our tied conditions, we might spend a big
    chunk of time on code maintenance.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a common mistake to put duplicate code under different branches, hence
    those branches become the same, so consider refactoring the code; the goal of
    each branch should be different.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foreach` is a better choice for associative arrays or objects.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to identify whether you need bounded or unbounded loops.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when using unbounded loops that are controlled by a condition, so
    that they don't run to infinity.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control statements are at the heart of computer programming. They are all about
    evaluating conditions to perform a certain block of code once or in a loop. To
    craft Boolean expressions, we have applied Boolean constants, Boolean values in
    variables, and logical operators. Also, logical and relational comparison can
    be applied to expressions that are to be used as a precondition for a branch of
    code.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: To deal with complex scenarios, we learned how easily we can compose nested
    control structures and how we can conditionally break out of a branch or skip
    a certain loop iteration. We also learned to avoid deep nesting to reduce the
    amount of time spent on future code maintenance. We need to carefully decide which
    branching or looping technique is suitable for a specific scenario and we need
    to be certain that our loops do not run to infinity.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Finally, having reached the end of this chapter, we should be able to write
    smaller sized scripts to perform operations that involve condition evaluations,
    array or object iterations, applying a condition to terminate an execution flow,
    comparisons among data to classify or categorize items, doing repetitive tasks,
    and much more.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will group a block of code as a unit named function
    to reuse these functions wherever we need to execute that block of code. For example,
    we might need to validate a data type associated with a variable at multiple places
    in our code. Instead of writing the data type validation code multiple times,
    we can shift the validation code into a function and use or call that function
    whenever we need that data type validation. So, the next chapter will introduce
    you to how to reuse code and how to write code in units.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
