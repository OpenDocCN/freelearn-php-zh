- en: 3\. Control Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe Boolean expressions;
    leverage logical operators to compose Boolean expressions; choose the right comparison
    operators within a control statement; describe branching and different looping
    techniques in PHP; apply branching with `if`…`else`, `switch` case, `break`, and
    `continue` statements; differentiate between bounded and unbounded loops; implement
    loops such as while, `do`…`while`, `for`, and `foreach`; and write a PHP script
    to create a movie listing application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since PHP is a dynamically typed language where types are associated with data
    instead of variables, it's essential to understand the role that types play in
    the data operations landscape. In the previous chapter, we learned about the available
    data types in PHP, their usage with variables and typecasting. We also practiced
    adding and removing items from an array and went through type conversion and alternative
    approaches to assigning string data to a variable with `heredoc` and `nowdoc`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss **control statements** and why they are essential,
    and we'll explore what PHP has to offer in this area. Control statements are the
    most important feature of any programming language. In simple terms, they help
    to control the flow of a program. **Branching** and **looping** are the main types
    of control structures that help to decide program flow. They also help to craft
    recursive loops for complex program flows.
  prefs: []
  type: TYPE_NORMAL
- en: Branching allows us to follow the correct path among multiple conditions based
    on a certain logic. For example, say that we want to make contact with a person.
    The person might have an email address or a cell number and we might want to either
    email or SMS the person. A branching structure will help us to determine whether
    there is an email address associated with that contact information and email the
    person based on that logic. And if an email address is not available, then we
    can opt for an alternative communication approach, such as SMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic that helps branching can be composed of one or more conditions; for
    example, checking whether the email address is available and checking whether
    the email address is valid. Normally, each branch of code groups a set of statements
    to execute; for example, if the email address is available, then email the contact,
    log the email delivery in the history, update the sender that the email has been
    sent successfully, and so on. PHP supports `if…else` and `switch` control statements
    for branching. The idea of branching is all about deciding on and executing the
    correct plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Branching diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Branching diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looping allows us to perform repetitive tasks or execute program statements
    repetitively as long as a certain logic has been fulfilled. For example, we need
    to send emails to all the persons in a given list who have a valid email address.
    The looping structure allows us to iterate through the list of persons and send
    them emails one by one – if the given email addresses are valid, the loop will
    continue until the end of the list. `while`, `do…while`, `for`, and `foreach`
    are the different looping techniques available in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Looping diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2: Looping diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Branching and looping structures evaluate the logic to execute a branch or execute
    a loop. That logic could test a certain value, could be a comparison of values,
    or could test a logical relationship, and it can be written as an expression.
    The expression is evaluated as a Boolean value; that is, `true` or `false` by
    the branching and looping structures. For branching, the expression serves as
    an entry check for that branch so that we can decide whether to choose that branch
    of code or not. For looping, the expression might serve as an entry or exit check
    for that loop so that we can decide how many times the loop should iterate. For
    example, to email a list of persons, we can write an expression to determine the
    size of the list so that we set how many times we do the emailing task and write
    another expression that checks the email address validity to send the email.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `not`, `and`, and `or` to check the truthiness or untruthiness or the falseness
    of any statement. Consider a fruit analogy: "*I love apples*". The expression
    is `true` if apple is a fruit. What about "*I love both apples and oranges*"?
    The expression is `true` if both "*I love apples*" and "*I love oranges*" are
    `true`. Comparison operators also play a role in a Boolean expression when we
    need to compare two values to identify whether they are equal, or one is greater
    or less than the other. Comparison is not only limited to values but also extends
    into data types.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss Boolean constants and learn how to write
    a Boolean expression using operators, and, throughout the chapter, we will apply
    logical expression evaluations as a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this chapter follow the styling recommendations in the PSR
    standards coding style guide, which is available at [https://packt.live/2VtVsUZ](https://packt.live/2VtVsUZ).
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`true` and `false` are the only two Boolean values treated as constants. A
    simple Boolean value can be a simple expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the statement within parentheses results in `true`, then the `true` block
    should be executed; otherwise, the `false` block should.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could write the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches output `I love programming.`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, we used the `if…else` control statement, which we
    are going to discuss a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`true` if *the fruit is not an apple*. Hence, to negate a statement, we use
    the `true` if either of the "*I love apples*" or "*I love oranges*" statements
    is true. Hence, we use or to result in boolean `true` if any condition is `true`
    and we use `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators can be used to compose multiple expressions into one complex
    expression. For example, the statement "*I love either apples or oranges but not
    watermelon*" can be broken into smaller statements, such as "*I love apples*,"
    or "*I love oranges*," and "*I don't love watermelon*." The expression is `true`
    if *the fruit is not watermelon* and if either of the statements "*I love apples*"
    or "*I love oranges*" is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The not Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `true` if the variable value is not `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The and Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `and` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code outputs `true` if both `$a` and `$b` variables are `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two different variations of the `and` operator here and they work
    on a different order of precedence.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which an operation is performed first in an expression is decided
    by the precedence. The precedence of the `and` operator is lower than that of
    the `&&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The or Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `or` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code outputs `true` if either variable `$a` or `$b` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two different variations of the `or` operator here and they work on
    a different order of precedence.
  prefs: []
  type: TYPE_NORMAL
- en: The xor Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `xor` operator is used to conjunct multiple variables or expressions to
    produce a new Boolean value – `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs `true` if `$a` or `$b` is not `true` at once. Consider
    a fruit analogy again: the statement "*I love mango or lemons but not both*" is
    `false` when both "*I love mango*" and "*I love lemons*" are `true` at the same
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, there are two different variations of `and` and `or` which operate in
    a different order of precedence. See the operator precedence table at [https://packt.live/2IFwFYR](https://packt.live/2IFwFYR).
  prefs: []
  type: TYPE_NORMAL
- en: Short-Circuit Evaluation and Operator Precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`and` operation is `false`, then the overall evaluation must produce `false`
    and you don''t necessarily need to evaluate the second condition. The same goes
    for the `or` operator: if the first condition is `true`, then the overall evaluation
    must produce `true`, no matter if the second condition is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Short-circuit evaluation will do the minimum number of comparisons possible
    to evaluate conditions. Here are some examples of short circuit logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `foo()` function will never be called as the first part of the
    expression gives the logical conclusion. As with `and`, if the first argument
    is `false`, you don''t need to evaluate the rest as the `and` operation is `false`
    if at least one argument is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `foo()` function will never get called as the first part of the expression
    gives the logical conclusion. As with `or`, if the first argument is `true`, you
    don't need to evaluate the rest as the `or` operation is `true` if at least one
    argument is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at another example, short-circuit evaluation is useful for conditions
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If `$todayIsSunday` is `false`, then the whole expression is evaluated as `false`
    and there is no chance of playing games at home.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The evaluation of logical expressions ceases once the result is known.
  prefs: []
  type: TYPE_NORMAL
- en: The Precedence of Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to be aware of the precedence of the same logical operators in an assignment
    statement so that the Boolean values don't run into the assignment before evaluating
    the result. The following examples show you how the precedence of the same logical
    operator (`||` / `or`) might ruin the evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: '|| versus or'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `(false || true)` expression has been assigned to `$a` and
    evaluated like `($a=(false||true))` since `||` has higher precedence than `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `false` constant is assigned to `$a` before the `or` operation and evaluates
    like `(($a = false) or true)` since `or` has lower precedence than `=`.
  prefs: []
  type: TYPE_NORMAL
- en: '&& versus and'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `(true && false)` expression has been assigned to `$a` and
    evaluated like `($a = (true && false))` since `&&` has a higher priority than
    `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `true` constant has been assigned to `$a` before the `and` operation occurs
    and evaluated like `(($a = true) and false)` since `and` has a lower priority
    than `=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following use case, where we need to grant access if the user
    has both a username and password. In the example, we can see that the user doesn''t
    have a password, so access should not be granted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, since `$hasPassword` is `false`, `$access` should not be granted or should
    be `false`. Instead, `$access` becomes `true` as the statement evaluated like
    `(($access = $hasUsername) and $hasPassword)` and the user is granted access without
    a password.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to avoid such a bad evaluation of an expression, it is recommended
    practice to use parentheses to evaluate expressions as a unit within the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`and` and `or` have lower precedence than `=` but `||` and `&&` have higher
    priority.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often need to compare values to decide the program flow. For example, we
    may want to ride in a four-seater car and we need to make sure that the number
    of passengers doesn't exceed the car's capacity. So, in programming, to examine
    such conditions, we often utilize **comparison operators**.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators compare two values and return `true` or `false` based on
    the given comparison. A comparison involves checking whether two values are equal
    or not equal, equal and of the same data type or not, less than, greater than,
    and so on. Alternatively, you can have mixed comparisons such as less than or
    equal to, greater than or equal to, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: PHP introduces a whole new type of comparison operator – the spaceship operator,
    `<=>`, which checks the equality of two numbers and allows us to know which number
    is the greater of the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the comparison operators and their behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Operators and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion takes place when we compare two different types of values, such
    as an integer and a string. The string will be converted to a number for numeric
    comparison; that is, `1 == "01"` is equivalent to `1 == 1`. For `===` and `!==`,
    which compares the type along with the value, type conversion is not applicable.
  prefs: []
  type: TYPE_NORMAL
- en: For various type comparisons, see *Comparison with various types*, which is
    available at [https://packt.live/2Vsk4NZ](https://packt.live/2Vsk4NZ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out some interesting examples of comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Table of comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Table of comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding different types of examples, hopefully, we should have a
    clear picture of comparison operators and behind-the-scenes type juggling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: During the evaluation of expressions, the precedence of comparison operators
    is higher than Boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in this multiple expression, `($smallNumber > 2 && $smallNumber
    < 5)`, the comparisons are performed before the Boolean operation.
  prefs: []
  type: TYPE_NORMAL
- en: Branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, determining the correct path or choosing one block
    of code to execute among multiple blocks of code can be described as `true` or
    `false`. Hence, following this concept, we get to choose our desired statement
    or groups of statements to execute based on an outcome of a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` and `switch` statements are the two main branching control structures.
    `if` is the most commonly used conditional structure within any programming language.
    `switch` can be used in certain situations where multiple branches can be chosen
    by a single value or expression, or where a series of `if` statements would be
    inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of `if` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `if (expression)` is the control structure, and `statement` is a single-line
    statement terminated with a semicolon or multiple statements enclosed in a pair
    of curly braces, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, if the result of the expression evaluates to `true`, the next statement
    or block of statements should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression produces Boolean `true` so it executes the `true` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A control structure body might contain a single statement, an enclosed block
    of statements, or another conditional structure.
  prefs: []
  type: TYPE_NORMAL
- en: The if…else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `if` control structure evaluated as `true`, we can execute the block
    of statements that immediately follow, but what if the evaluation produces `false`
    within the control expression? We can add an optional `else` block to execute
    the statements in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the syntax of the `if…else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `else` is the fallback if the condition is `false`. With the `else` block,
    we can execute statements based on a conditional expression evaluation of `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The if…else statement'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: The if…else statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example of the `if..else` control structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen the basic implementation of the `if` and `if…else` statements,
    let's create a few basic scripts in the next two exercises to implement them and
    observe how branching occurs in actual programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.1: Creating a Basic Script to Implement the if...else Test Case'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will learn to acquire the day using PHP''s built-in
    `date()` function. You will be using an `if...else` test case to check whether
    today is Sunday, and then print `Get rest` or `Get ready and go to the office`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a PHP file named `test-sunday.php` and insert the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used a built-in `date` function with a date format flag, `l` (lowercase
    L), which returns a textual representation of the current day of the week; that
    is, *Sunday through Saturday*. Note that *uppercase* is used for the first character
    in the day string; that is, Sunday since the function returns that way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `if` conditional expression, `("Sunday" === date("l"))`, matches the returned
    day name with "*Sunday*". If today is Sunday, then `("Sunday" === "Sunday")` identically
    matches and yields `true` and prints "`Get rest`"; otherwise, it prints "`Get
    ready and go to the office`".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console, like the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script prints `Get rest` if today is Sunday; otherwise, it prints `Get ready
    and go to the office`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.6: The if…else script output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: The if…else script output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the PHP `date` function at [https://packt.live/35mGNzC](https://packt.live/35mGNzC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.2: Implementing the Nested if...else Structure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, we will practice using a nested `if...else` structure
    with a different sort of expression within the control statement. We will create
    a script that will print the difference between two given numbers based on the
    fact that one number is greater than the other one and the numbers are not equal.
    Here, both numbers are positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of a nested `if...else` structure, we will be testing whether
    the numbers are equal or not. If they''re not equal, then we''ll determine which
    number is greater and subtract the other number from it to print the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `test-difference.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare two variables, `$a` and `$b`, and assign them values of `5` and `3`
    respectively, like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert an `if…else` structure, like the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we already know, the result of the expression ID evaluates to `true` or `false`,
    and for a non-Boolean result should be typecast to Boolean. The example expression
    `($a - $b)` depends on the fact that `0` is considered as `false`, so *if the
    difference is zero*, then the expression will be evaluated as `false`, hence "`The
    numbers are equal`" will be printed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add another `if…else` structure inside the `if` case body to deal with numbers
    with a difference, like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the inner `if...else` determines which number is greater
    and subtracts the other from it to print the difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints "`The difference is 2`" if the numbers are not equal; otherwise,
    it prints "`The numbers are equal`" as there is no difference:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.7: The nested if…else script output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.7: The nested if…else script output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the values of `$a` and `$b` and rerun the script for different results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Our goal is to achieve different conditional coverage*, developing the `if…else`
    control structure. The `if...else` construct executes the `true` branch with the
    condition evaluated as `true`; otherwise, it executes the `false` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ternary Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ternary operator can be considered as a shorthand `if..else` statement
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, if `expression1` evaluates to `true`, `expression2` should be executed;
    otherwise, `expression3` executes a `false` evaluation of `expression1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ternary operators can be used for assigning default values, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if today is Sunday, then it will print "`Get rest`";
    otherwise, it will print `Get ready and go to the office`, and we can evaluate
    the condition to return a value on a single line. Ternary operators are suitable
    for some cases, especially assigning default values, being used in a `return`
    statement to evaluate and return a value, or being used in between a dynamic string
    to parse and print the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to write a ternary operator in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will print the value of the `$msg` variable if it is not empty; otherwise,
    it will print `"Get ready and go to the office`".
  prefs: []
  type: TYPE_NORMAL
- en: The if…elseif…else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider an example where you need to evaluate a set of conditions. Say, you
    want to display a letter grade for an exam based on a range of GPA numbers (out
    of 4 points); that is, 3.80 to 4 gets grade A+, 3.75 to below 3.80 gets grade
    A, and so on. So, we need to start from the top condition if the GPA is greater
    or equal to 3.80, then we can define the GPA as A+; otherwise, if the GPA is greater
    than or equal to 3.75, then it's an A grade as we have already fallen back from
    the top condition. If the GPA is greater than or equal to 3.50, then the grade
    would be A-, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an article publishing application, where we need to allocate different
    actions based on the type of user role. Say, if the user is an editor, then the
    user can create, read, edit, publish, and delete articles. If the user is an author,
    they can only create, read, and edit articles. If the user is a reader, they can
    only read and comment on articles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we might want to evaluate a set of expressions like in the preceding
    example in order to cover more scenarios. This is where a cascading sequence of
    expressions should be evaluated, like the following nested `if…elseif…else` statement
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This `if…elseif…else` syntax is just the same as the `if…else if…else` statement,
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, more expressions can be evaluated by cascading the `if...else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'With such a control structure, we can evaluate whether a number is positive,
    negative, or zero. Check out the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have tried to determine the characteristics of an integer number in
    `$n` and we have covered three simple scenarios; that is, checking whether the
    number is positive, checking whether the number is negative, and finally, we can
    fall back to the decision that the number is zero. You can add more expressions
    to be evaluated with `elseif` statements like this. The structure of the `if…else`
    statement supports multiple branching and allows you to execute only a single
    branch of statements that has a successful Boolean evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.3: Creating a Script Using the if... elseif... else Statement'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, you will learn how to utilize the `if...elseif...else`
    control structure to determine an age range. We will create a script that has
    a variable named `$age` with a number representing the age. If the age value is
    equal to or greater than 18, then print "`young`"; otherwise, if the age value
    is less than 18 and greater than 10, print "`teenager`". If the age is less than
    10, then print "`child`".
  prefs: []
  type: TYPE_NORMAL
- en: 'We will determine the age range from the value given in the `$age` variable
    and print the age category accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `test-age.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `$age` variable as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the following `if…elseif…else` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used comparison operators, which were discussed in previous sections.
    The `($age >= 18)` statement determines whether the age is greater than or equal
    to 18\. If the age is neither greater nor equal to 18, then the execution falls
    to the next test expression, `($age > 10)` to check whether the age is greater
    than 10 as the age is already less than 18\. Again, if the `($age > 10)` expression
    doesn't return `true`, the age will be considered to be less than 10, hence, categorized
    as "`Child`".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console, as in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints "`Young`", "`Teenager`", and "`Child`" based on different
    age ranges:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.8: The if…elseif…else script output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.8: The if…elseif…else script output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You might also want to add more test expressions to cover another age range,
    as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have added `($age > 25)` as another test expression to show the cascaded
    `if…else` structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The tested age ranges and printed age categories are just for a learning demo.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The switch Case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `switch` statement provides `if` statements on the same expression and having
    a default block like the final `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the yielded value of the expression, the proper case with an appropriate
    value is picked for execution. The expression can be any kind of expression or
    a variable that gives a value such as a number or a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: A switch diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: A switch diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `switch` case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what is happening in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch(…){…}` is the control structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expression` is the expression that produces a value to be matched in the different
    cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case value:…` is the block of statements to be executed. In order to execute
    the block, the case value should be similar to the expression''s yielded value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default:` is the default block of statements to be executed if the `switch`
    expression''s yielded value doesn''t match any cases, just like `else`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A `switch` case does a loose comparison. A loose comparison means it won't check
    the type. The value evaluated from a `switch` expression should be equal to the
    matching case value without checking the type. Say, the `switch` expression evaluated
    to number 1 can be matched or is equal to the case values, such as string "1",
    float 1.00, or Boolean true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `switch` statement executes the `$fruit` expression, which is
    a variable with a value in it, so the value should be matched with the case values
    and the corresponding case statements should be executed until the `break;` statement
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be careful with `switch` statement usage and the use of `break;`.
    Just as in the following example, PHP will continue executing the statements without
    a break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For `$n` is `0`, the preceding example will print "`the number is 0 the number
    is 1 the number is 2`". For `$n` is `1`, it will output "`the number is 1 the
    number is 2`", so we need to add a `break;` statement at the end of each case.
    We will discuss the `break;` statement in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: In a `switch` statement, the given condition is evaluated to match the resultant
    value with the value of each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, multiple cases within the same block of statements can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With a `default` case, we can extend the preceding example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` cases support alternative syntax for a control structure. For more
    information, check out [https://packt.live/2M0IMli](https://packt.live/2M0IMli).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will detect data types with a `switch` case in order to print the data
    types in an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.4: Creating a Script to Implement a Switch Case'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, we will create a script that will get the type of
    a variable using the built-in `gettype()` function in a `switch` test case and
    print custom messages for different data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `integer` and `double` data types, we will print "`The data type is
    Number.`". Print "`The data type is Boolean`", "`The data type is String`", and
    "`The data type is Array`" for the `boolean`, `string`, and `array` types, respectively.
    Also, print "`The data type is unknown`" for unknown data types and the rest of
    the data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `test-datatype.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `$data` variable like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have declared a variable that contains a numeric value of type `double`.
    We could have added other types of data as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, in order to get the type of the `$data` variable and match the appropriate
    case, let''s insert the following `switch` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used the built-in `gettype()` function, which returns the type
    of `$data`, such as "`boolean`", "`integer`", "`double`", "`string`", "`array`",
    "`object`", "`resource`", "`NULL`", and "`unknown` `type`".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We already know that to execute the same statements for multiple cases, we can
    combine the cases. For "`integer`" and "`double`" strings returned by the `switch`
    expression, since the requirement is to print the same message for both, as the
    type is a number, we kept both cases together. Also, for other data types, we
    have dealt with matching `case` statements, and the rest of the types, and even
    unknown types, have been addressed by the `default` case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints different messages for different data types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10: The switch case output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.10: The switch case output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the value of `$data` with different types of data and rerun the script
    for different outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A loop is a block of statements written once but executed several times. The
    code within a loop or the body of a loop is executed a finite number of times,
    determined by whether certain conditions are met or they may be infinite!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing `for`, `foreach`, `while`, and `do…while`
    loops with their structures and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded Loops versus Unbounded Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **bounded** loop has a loop iteration limit and hence executes till that boundary
    is met. To restrict it to that finite number of iterations, the number of iterations
    is easily visible in the loop condition or in loop statements and the language
    constructs assure that it won't loop beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: Again, an **unbounded** loop iterates until a certain condition is met and the
    condition can be controlled from inside the loop. *Bounded loops are also called
    count-controlled loops* as you can control the iteration count with the help of
    language constructs; similarly, *unbounded loops are condition-controlled loops*.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, `while`, `do…while`, and `for` are all unbounded loops and, regardless
    of the loop control portion (entry controlled or exit controlled), they are almost
    the same. We will look at examples of these looping techniques and their application
    in different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop is one of the simplest looping constructs. The syntax is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `while (expression) {…}` is the control structure that checks the possibility
    of executing the loop in the `expression` condition, followed by a single statement,
    or multiple statements can be enclosed in by a pair of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: A while loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: A while loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In a `while` loop, the condition expression is evaluated as a Boolean. For the
    first iteration, the expression should be evaluated to `true` in order to execute
    the statement(s). Then, it checks for the condition again to proceed with the
    next iteration. If the condition produces `false`, the loop terminates without
    proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following loop will never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the following loop might execute forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, `PHP_EOL` holds the end of line character, and was used at the end of
    the string to print the next string on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set how many times a loop will iterate with a given condition, as in
    the following loop, which executes exactly seven times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$count` starts with value `1` and gets incremented by 1 with the `$count++`
    statement. The loop will print 7 lines, and at iteration number 8, the `$count`
    will contain 8, so the `($count <= 7)` condition becomes `false`, and printing
    is terminated. So, with the `count` control, we can bound the `while` loop to
    execute a certain number of times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The condition was evaluated at the beginning of the loop; that's why the `while`
    loop is an entry-controlled loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.5: Printing the Numbers 1 to 10 Using a while Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will simply iterate through a `while` loop to print numbers
    1 through 10 and will apply a condition expression to check the numbers are within
    a range of 1 to 10 as we will be incrementing the number by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `print-numbers-while.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a `$number` variable and initialize it to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a `while` loop to print numbers 1 to 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have initialized the number as `1` in the `$number` variable. With
    the `($number <= 10)` condition expression, we can guarantee that the loop will
    not execute or it will not print if the number is greater than 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the end, we produced the next number by incrementing the `$number++;` variable.
    Here, we used an empty string, `" "`, as a number separator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, Boolean expressions allow us to write test cases with limits or boundaries.
    Plus, a looping technique can execute a set of statements within those limits
    or boundaries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints 1 through 10:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12: The while loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.12: The while loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the script with different conditional expressions and rerun it to see
    the new outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The do…while Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast with the `while` loop, the `do…while` loop comes with the expression
    evaluation at the end. This means that the loop will iterate through once to execute
    the code within the loop before the condition is ever evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of such an exit-controlled loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `do {…} while (expression)` is the control structure and the expression
    is the conditional expression, which gives a Boolean result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: The do…while loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: The do…while loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following loop will be executed once regardless of whether
    the condition evaluates to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first iteration of the `do...while` loop will execute as the expression
    evaluation comes at the end. If the condition is `true`, then the second iteration
    takes place; otherwise, with `false`, it prevents further looping.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can make use of `while` or `do...while` looping based on the fact that
    one is entry controlled and the other is an exit controlled loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how many times a loop can iterate with an end condition. The following
    loop executes exactly seven times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$count` starts with value `1` and gets incremented by 1 with the `$count++`
    statement. The loop will print 7 lines and at iteration number 7, the `$count`
    will contain 8, so the `($count <= 7)` condition becomes `false`, hence, further
    printing is terminated. So, with the `count` control, we can bound the `do…while`
    loop to execute a certain number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.6: Converting a while Loop to a do...while Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will tweak the previous exercise, replace `while` with
    a `do…while` loop, and rerun the statements to see the outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `print-numbers-while.php` file and copy the contents into a new file
    named `print-numbers-do-while.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `while` loop with `do...while`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have replaced the previous `while` loop with a `do...while` control
    structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difference with the previous looping technique is that condition testing
    has been placed at the end of the structure as `do...while` is an exit controlled
    loop. The loop should execute at least once regardless of the condition. If the
    end expression evaluates to `true`, we proceed with the next iteration. All looping
    techniques use a conditional expression to check the eligibility of the next iteration
    in order to guarantee finite looping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints 1 through 10 with the replaced `do...while` loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.14: The do…while loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.14: The do…while loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the script with different conditional expressions and rerun the script
    to see the new outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The for Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections, we discussed `while` and `do…while` loop structures and
    saw the way they iterate based on entry and exit conditions. We also looked at
    the use of a counter or a number initiated from `0` or `1` that gets incremented
    in each iteration using the post-increment `++` operator and checked that the
    counter or number doesn't exceed the limit. In practice, `while` and `do…while`
    loops use a loop step value declared before the loop and the step value incremented
    or decremented inside the loop. This loop step value is used to check the limit
    of the loop condition. Hence, we need to arrange our way of controlling loop iterations
    in the case of `while` and `do…while`.
  prefs: []
  type: TYPE_NORMAL
- en: To observe such common practice, the `for` loop can be used, with the structure
    itself providing expressions for initiating the loop step variable, the step value
    checking condition, and the step increment/decrement statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the syntax of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, `for (expression1; expression2; expression3) {…}` is the control structure
    and `expression2` is the conditional expression evaluated as a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: The first expression, `expression1`, is an unconditional expression that is
    evaluated at the very start of the loop and is considered as a loop initiation
    statement. Prior to each iteration, `expression2` is evaluated as a Boolean expression
    to `true`. The loop body executes in each round. `expression3` is evaluated at
    the end of each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The empty `expression2` means the loop will run infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working of the for loop can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: A for loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.15: A for loop diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example prints numbers 1 through 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `for` loop executes 10 times and prints 1 through 10\. Here, the
    `$index` variable is initiated to `1` in the first expression. The second expression
    checks whether the value of `$index` is less than or equal to 10 so that the loop
    iteration can be limited to 10 times, and `$index++` increments the value of `$index`
    by 1 after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can terminate the loop execution with a `break` statement, preventing further
    execution within the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that an empty `for` loop can be considered as iterating infinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 3.7: Using a for Loop to Print the Days of the Week'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will iterate through an array created to store the days
    of the week using a `for` loop and print the days. We will restrict the loop iterations
    so that the loop doesn''t go beyond the array elements present:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `print-days-for.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `$days` array with the names of the seven days of the week, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `for` loop with the three expressions, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `$totalDays` is the variable that holds the count of the days. The
    number of iterations can be controlled by the `$i < $totalDays` expression since
    `$i` has been started with `0`, which is the first index of the array, so that
    the loop executes exactly the number of elements (days) available in the `$days`
    array. With the completion of each iteration, the index value in `$i` is incremented
    by the `$i++` statement so that we can access the next value within the array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints the names of the seven days of the week from the given array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.16: The for loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.16: The for loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweak the script with different loop expressions and rerun it to see the new
    outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The foreach Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've seen how a `for` loop can leverage a loop step variable as an
    index to access an array, but the approach is not feasible for iterating through
    an associative array where you want to use the index or the key as meaningful
    data. Consider a person's information array or an object example, where a person's
    attributes, such as first name, last name, age, email, and so on, have been stored
    against the same attribute names as the keys, so that each key defines what type
    of information has been stored against that index.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, to iterate through an object or an array, we need a specialized
    looping construct – a `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: With a `foreach` loop, *PHP supports implicit looping through all elements of
    an array or an object*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a `foreach` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`array_expression` provides an array to iterate over. With each iteration,
    the value of the current element assigned to `$value` and the array pointer is
    incremented by one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foreach` loop can also be written in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this form, with each iteration, the current element value is assigned to
    the `$value` variable, and its corresponding key is assigned to the `$key` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In a `foreach` loop, rather than the Boolean evaluated conditions, the size
    of the array controls how many times a loop executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.8: Using a foreach Loop to Print the Days of the Week'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will iterate through an array of the names of the days
    of the week, using a `for` loop and print the days. We will restrict the loop
    iterations so that the loop doesn''t go beyond the array elements present:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `print-days-for.php` PHP script and copy the contents into a new file
    named `print-days-foreach.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `for` loop with a `foreach` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the size of the array controls how many times the
    `foreach` loop executes. So, for each element in the array, starting from the
    first, the looping control statement assigns the element value to a variable and
    iterates to execute the statements in the enclosed block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints the names of the seven days from the given array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17: The foreach loop output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_17.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.17: The foreach loop output'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With increasing program complexity, you may find yourself in a position where
    a single loop may not be able to achieve your program's objectives. In such cases,
    we can use loops within loops; in other words, nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve nesting, one loop can be used inside the enclosure of another loop.
    With the first iteration of the outer loop, the inner loop is executed to run
    through the given number of iterations. Again, with the next outer iteration,
    the inner loop is triggered and it completes all its iterations. An inner loop
    structure can be considered as another statement among enclosed statements. Obviously,
    we can use `break` and `continue` (which will be discussed in the next section)
    statements to interrupt the flow of the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `for` loop can be used as a nested form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that two `for` loops have been used to iterate through the
    two-dimensional array and we have used `$i` & `$j` to generate the indexes to
    access their corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of a `for` loop, we could have used two `foreach` loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `foreach` loop eliminates the use of an index to access an element
    of an array, so the `foreach` loop is useful for iterating such arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.9: Using Nested foreach Loops'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will practice loop nesting and will demonstrate how inner
    and outer loops work. We will loop through an array of different professions and
    print each profession. By using a condition, if the profession is equal to "`Teacher`",
    then we'll loop through another array of subjects and print out the subjects as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the inner loop iterate based on a precondition; that is, *when
    the profession is teacher*. We will enclose the inner loop that prints the subject
    name from the subjects'' array in an `if` control structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP script named `print-professions-subjects.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the professions in an array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the subjects in an array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `foreach` loop to iterate through the `$professions` array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following inner `foreach` loop to print the subjects if the profession
    is `teacher`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have two different arrays. The `professions` array contains the profession
    names, while the `$subjects` array holds the subject name that is to be printed
    if the profession name matches the "`teacher`" string. We have used a `foreach`
    loop to iterate through the `$professions` array. The first `foreach` loop should
    be considered an outer loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The outer loop prints the profession name, and then tests the condition, which
    matches the profession name, `Teacher`. If the profession matches `Teacher`, then
    execute the inner `foreach` loop. The inner loop iterates through the `$subjects`
    array to print the subject's name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script prints the profession name from the given array and if the profession
    is `Teacher`, then it prints the subject''s name from the given `$subjects` array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.18: The nested foreach loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_03_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.18: The nested foreach loop output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the inner loop has been triggered based on a precondition, meaning
    we have used a looping and a branching technique here. We will achieve both by
    using a `for` loop in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `print-professions-subjects.php` and replace the inner loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the second expression in the `for` loop supports the condition expression,
    so we have composed the expression with two conditions: one that checks whether
    the profession is `Teacher` and another that checks that the array index doesn''t
    exceed the size of the `$subjects` array. The `sizeof()` function is used to determine
    the number of elements in the array.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script prints just the same as in *step 6*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, we can implement the inner loop with any looping techniques, such
    as `while` or `do…while` and rerun the PHP file to see the output.
  prefs: []
  type: TYPE_NORMAL
- en: The break Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at several loops and their implementations so far. However, you
    may come across situations where breaking a loop is necessary. For example, in
    addition to a loop conditional expression, we might want to terminate the loop
    from iterating further based on a condition checked inside the loop. In such cases,
    `break` is quite useful to terminate the innermost loop, providing another control
    for such looping structures.
  prefs: []
  type: TYPE_NORMAL
- en: '*An early exit from the loop is possible using the* `break;` *statement.* `break`
    immediately terminates the execution of any running loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement supports an optional argument that determines the execution
    of how many enclosed structures are to be broken out. With a default argument
    of `1`, an immediate enclosing looping structure can be broken out. To break out
    multiple enclosed looping structures, we need to supply a numeric argument; for
    example, `break 2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the following example, which breaks two enclosed loopings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Both `for` loops should iterate for an infinite time, and to escape them both
    we need to provide a `break` argument of 2\. We can safeguard a `break` statement
    like this with an `if` control structure so that we don't exit the loop without
    a condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.10: Using a break Statement to Terminate a Loop''s Execution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will take the previous exercise of the `while` loop to check whether the
    number is equal to 8, then print `ends the execution of loop`, and then end the
    loop using a `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents from the `print-numbers-while.php` file and create a PHP filename,
    `print-numbers-break.php`, with the copied contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a conditional `break` statement in the `while` loop''s body, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have checked that `$number` is equal to `8` with a conditional expression,
    then printed the given message and terminated the execution. The `break` statement
    has been placed inside the loop, meaning when the `break;` expression is executed,
    the loop can be terminated regardless of whether the looping condition says that
    the loop still has two more iterations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After printing `8`, the loop prints the `ends the execution of loop.` message
    and terminates the subsequent iterations with a break:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.19: The break output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.19: The break output'
  prefs: []
  type: TYPE_NORMAL
- en: The continue Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any loop, we might want to skip any specific iteration based on a certain
    condition. For example, printing the numbers 1 through 10, we might want to skip
    the odd numbers and print the even numbers only. To continue with the next iteration
    and skip the rest of the execution within the enclosed structure, the `continue`
    statement can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` statement supports an optional numeric argument such as the `break`
    statement, which specifies how many levels of enclosing loops it should skip to
    the end of the current iteration(s). The default value, `1`, skips to the end
    of the current iteration and continues with the rest of the iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.11: Using continue to Skip an Item in a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier looping examples, we created a script to print numbers 1 through
    10\. In this exercise, we will take the previous exercises on loop techniques
    to check whether a number is equal to 8, then skip printing the number and continue
    printing the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PHP file named `print-numbers-continue.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `for` loop like the following to print numbers 1 through 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `continue` statement if the number is equal to `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we checked whether `$i` is equal to `8` with a conditional expression,
    then we executed the `continue;` statement. So, from that particular point, the
    iteration skips the rest of the execution and goes for the next iteration. Hence,
    the `print` command for the number 8 can be skipped and it can continue printing
    9 and 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the PHP file from a Terminal or console with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After printing `7`, the loop skips printing `8` and continues printing the
    rest of the numbers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.20: The break script output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_03_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.20: The break script output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To exit a loop, a common practice is to use a conditional statement that evaluates
    to `false`, else keep iterating. The `break` and `continue` statements can be
    used as a special way of getting out of a loop or skipping the rest of the execution
    in the current execution.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Control Syntaxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP supports an alternative way of writing control structures. As per the alternate
    syntax, we will replace the initial brace with a colon and the closing brace with
    a structure ending statement such as `endif`, `endswitch`, `endfor` or `endwhile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `if...else` becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the `if…elseif…else` syntax with the structure ending statement looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: So, it is up to us which syntax we follow. *The alternative syntax is supported
    for users of the earlier versions of PHP*. Generally, this book follows the standard
    syntax throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP alternative syntaxes can be found at this link: [https://packt.live/2M0IMli](https://packt.live/2M0IMli).'
  prefs: []
  type: TYPE_NORMAL
- en: Using System Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command-line arguments can be obtained using the `$argv` system variable. We
    will use `$argv[1]` and `$argv[2]` to obtain the second and third arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`$argv[0]` is the script name in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line arguments can be passed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `??` the null coalescing operator is used so that if `$argv[1]` or
    `$argv[2]` does not exist or is `NULL` then, we can assign a default number, 5,
    to the `$varA` and `$varB` limit variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.1: Creating a Movie Listing Script to Print Movies per Director'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will practice nested looping and apply conditions to restrict
    the iterations of inner and outer loops. We will have a multi-dimensional associative
    array where the director's name acts as the key to hold an array of movie names.
    So, each element of the associative array contains a director's name as a key
    and the movie names array as a value. We will introduce an outer loop to loop
    through the associative array elements and print the director's name, used as
    a key. Another inner loop should loop through the movie names array of that director
    – that is the key. The arguments act as loop iteration steps to maintain where
    the first argument defines how many times a director's name should be printed
    and the second argument defines how many movie names should be printed from the
    given director.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-dimensional array contains five directors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to be performed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `activity-movies.php` script file, which takes two arguments, both
    numerical: the first argument will be used for the number of directors, and the
    second one will be used for the number of movies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a nested array containing a list with five directors, each entry containing
    a list of five movie titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By running the script, print the list of directors and the movie titles, as
    required by the input arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input arguments are not passed, then consider the default value of 5
    for both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s some sample output of running the `php activity-movies.php 3 2` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 506.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tips for Control Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices while working with control structures:'
  prefs: []
  type: TYPE_NORMAL
- en: If you need multiple `if` or `elseif` statements, you might consider replacing
    them with a `switch` case as a `switch` statement is faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid deeply nested control structures such as `if { if { if { ... }}}` or `for(;;)
    { for(;;){ for (;;){ … } } }` as deep nesting ties one condition to another and
    when we need to make a modification to our tied conditions, we might spend a big
    chunk of time on code maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a common mistake to put duplicate code under different branches, hence
    those branches become the same, so consider refactoring the code; the goal of
    each branch should be different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foreach` is a better choice for associative arrays or objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to identify whether you need bounded or unbounded loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when using unbounded loops that are controlled by a condition, so
    that they don't run to infinity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control statements are at the heart of computer programming. They are all about
    evaluating conditions to perform a certain block of code once or in a loop. To
    craft Boolean expressions, we have applied Boolean constants, Boolean values in
    variables, and logical operators. Also, logical and relational comparison can
    be applied to expressions that are to be used as a precondition for a branch of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with complex scenarios, we learned how easily we can compose nested
    control structures and how we can conditionally break out of a branch or skip
    a certain loop iteration. We also learned to avoid deep nesting to reduce the
    amount of time spent on future code maintenance. We need to carefully decide which
    branching or looping technique is suitable for a specific scenario and we need
    to be certain that our loops do not run to infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, having reached the end of this chapter, we should be able to write
    smaller sized scripts to perform operations that involve condition evaluations,
    array or object iterations, applying a condition to terminate an execution flow,
    comparisons among data to classify or categorize items, doing repetitive tasks,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will group a block of code as a unit named function
    to reuse these functions wherever we need to execute that block of code. For example,
    we might need to validate a data type associated with a variable at multiple places
    in our code. Instead of writing the data type validation code multiple times,
    we can shift the validation code into a function and use or call that function
    whenever we need that data type validation. So, the next chapter will introduce
    you to how to reuse code and how to write code in units.
  prefs: []
  type: TYPE_NORMAL
