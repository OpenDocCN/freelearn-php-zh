<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Datasources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Datasources</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Improving the SQL datasource query log</li><li class="listitem" style="list-style-type: disc">Parsing CSV files with a datasource</li><li class="listitem" style="list-style-type: disc">Consuming RSS feeds with a datasource</li><li class="listitem" style="list-style-type: disc">Building a Twitter datasource</li><li class="listitem" style="list-style-type: disc">Adding transaction and locking support to the MySQL datasource</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Introduction</h1></div></div></div><p>Datasources are the backbone of almost all model operations. They provide an abstraction between model logic and the underlying data layer, allowing a more flexible approach to data manipulation. Through this abstraction, CakePHP applications are able to manipulate data without knowing the specifics of how it's stored or fetched.<a id="id144" class="indexterm"/>
</p><p>This chapter shows how to get information from existing datasources, use pre-built datasources to deal with non-relational data, and teaches us how to create a full-featured Twitter datasource.<a id="id145" class="indexterm"/>
</p></div></div>
<div class="section" title="Improving the SQL datasource query log"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Improving the SQL datasource query log</h1></div></div></div><p>This recipe shows how to create a component that will offer extended logging of all queries executed on any SQL-based datasource that supports the<code class="literal"> EXPLAIN</code> command (this recipe is designed to work with MySQL, but can be adapted to other SQL based datasources), and show that information when the appropriate debug setting is set.<a id="id146" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a sample table to work with. Create a table named<code class="literal"> accounts</code>, using the following SQL statement:<a id="id147" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `accounts`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`email` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div><p>Create a table named<code class="literal"> profiles</code>, using the following SQL statement:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `profiles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`account_id` INT UNSIGNED NOT NULL,
`name` VARCHAR(255) default NULL,
PRIMARY KEY(`id`),
KEY `account_id`(`account_id`),
FOREIGN KEY `profiles__accounts`(`account_id`) REFERENCES `accounts`(`id`)
);
</pre></div><p>Add some sample data, using the following SQL statements:</p><div class="informalexample"><pre class="programlisting">INSERT INTO `accounts`(`id`, `email`) VALUES
(1, 'john.doe@example.com'),
(2, 'jane.doe@example.com');
INSERT INTO `profiles`(`id`, `account_id`, `name`) VALUES
(1, 1, 'John Doe'),
(2, 2, 'Jane Doe');
</pre></div><p>We proceed now to create the required model. Create the model<code class="literal"> Profile</code> in a file named<code class="literal"> profile.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Profile extends AppModel {
public $belongsTo = array(
'Account' =&gt; array('type' =&gt; 'INNER')
);
}
?&gt;
</pre></div><p>Create its appropriate controller<code class="literal"> ProfilesController</code> in a file named<code class="literal"> profiles_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class ProfilesController extends AppController {
public function index() {
$profiles = $this-&gt;Profile-&gt;find('all');
$this-&gt;set(compact('profiles'));
}
}
?&gt;
</pre></div><p>Create a folder named<code class="literal"> profiles</code> in your<code class="literal"> app/views</code> folder, and then create the view in a file named<code class="literal"> index.ctp</code> and place it in your<code class="literal"> app/views/profiles</code> folder with the following contents:<a id="id148" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;ul&gt;
&lt;?php foreach($profiles as $profile) { ?&gt;
&lt;li&gt;#&lt;?php echo $profile['Profile']['id']; ?&gt;:
&lt;?php echo $this-&gt;Html-&gt;link($profile['Profile']['name'], 'mailto:' . $profile['Account']['email']); ?&gt;&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
</pre></div><p>If you don't have a layout, copy the layout file named<code class="literal"> default.ctp</code> from your<code class="literal"> cake/libs/view/layouts</code> folder to your application<code class="literal"> app/views/layouts</code> folder. If you do have a layout, make sure it includes the standard SQL view element where you want the SQL logging placed:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;element('sql_dump'); ?&gt;
</pre></div><p>Finally, set your debug level to<code class="literal"> 2</code> by editing your<code class="literal"> app/config/core.php</code> file and changing the<code class="literal"> Configure::write('debug')</code> line to:</p><div class="informalexample"><pre class="programlisting">Configure::write('debug', 2);
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file named<code class="literal"> query_log.php</code> and place it in your<code class="literal"> app/controllers/components</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class QueryLogComponent extends Object {
public $minimumTime = 10;
public $explain = 'EXPLAIN %s';
public function initialize($controller, $settings = array()) {
$this-&gt;_set($settings);
if (!is_bool($this-&gt;enabled)) {
$this-&gt;enabled = Configure::read('debug') &gt;= 2;
}
}
}
?&gt;
</pre></div></li><li class="listitem">While still editing the<code class="literal"> query_log.php</code> file, add the following method to the<code class="literal"> QueryLogComponent</code>:<a id="id149" class="indexterm"/><div class="informalexample"><pre class="programlisting">class:public function beforeRender($controller)
{
if ($this-&gt;enabled)
{
$queryLog = array();
$datasources = ConnectionManager::sourceList();
foreach($datasources as $name)
{
$datasource = ConnectionManager::getDataSource($name);
if ($datasource-&gt;isInterfaceSupported('getLog'))
{
$log = $datasource-&gt;getLog();
foreach($log['log'] as $i =&gt; $line)
{
if (empty($line['error']) &amp;&amp; $line['took'] &gt;= $this-&gt;minimumTime &amp;&amp; stripos(trim($line['query']), 'SELECT') === 0)
{
$explain = $datasource-&gt;query(sprint ($this-&gt;explain, $line['query']
));
if (!empty($explain))
{
foreach($explain as $j =&gt; $explainLine)
{
$explain[$j] = array_combine (array_map('strtolower', array_keys($explainLine[0])), $explainLine[0]);
}
$log['log'][$i]['explain'] = $explain;
}
}
}
if (!empty($log['log']))
{
$queryLog[$name] = $log;
}
}
}
if (!empty($queryLog))
{
$controller-&gt;set(compact('queryLog'));
}
}
}
</pre></div></li><li class="listitem">Add the<code class="literal"> QueryLog</code> component to all your controllers. Create a file named<code class="literal"> app_controller.php</code> and place it in your<code class="literal"> app/</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class AppController extends Controller
{
public $components = array( 'QueryLog' =&gt; array( 'minimumTime' =&gt; 0 )
);
}
?&gt;
</pre></div><p>If you already have an <code class="literal">app_controller.php</code> file, make sure your <code class="literal">components</code> property includes the <code class="literal">QueryLog</code> component as shown previously.
<a id="id150" class="indexterm"/>
</p></li><li class="listitem">Create a file named<code class="literal"> query_log.ctp</code> and place it in your<code class="literal"> app/views/elements</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
if (empty($queryLog))
{
echo $this-&gt;element('sql_dump');
return;
}
foreach($queryLog as $datasource =&gt; $log)
{
?&gt;
&lt;table class="cake-sql-log"&gt;
&lt;caption&gt;
Datasource &lt;strong&gt;&lt;?php echo $datasource; ?&gt;&lt;/strong&gt;:
&lt;?php echo number_format($log['count']) . ' queries (' . $log['time'] . ' ms. total time)'; ?&gt;
&lt;/caption&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;Query&lt;/th&gt;
&lt;th&gt;Error&lt;/th&gt;
&lt;th&gt;Affected&lt;/th&gt;
&lt;th&gt;Num. rows&lt;/th&gt;
&lt;th&gt;Took&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php foreach($log['log'] as $line) { ?&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;?php echo $line['query']; ?&gt;
&lt;?php if (!empty($line['explain'])) { ?&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;table class="cake-sql-log-explain"&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Select Type&lt;/th&gt;
&lt;th&gt;Table&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Possible Keys&lt;/th&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Ref&lt;/th&gt;
&lt;th&gt;Rows&lt;/th&gt;
&lt;th&gt;Extra&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php foreach($line['explain'] as $explainLine) { ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $explainLine['id']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['select_type']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['table']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['type']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['possible_keys']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php
echo $explainLine['key'];
if (!empty($explainLine['key_len'])) {
echo ' (' . number_format($explainLine['key_len']) . ' )';
}
?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['ref']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo number_format($explainLine['rows']); ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $explainLine['extra']; ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php } ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;?php } ?&gt;
&lt;/td&gt;
&lt;td&gt;&lt;?php echo $line['error']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo number_format($line['affected']); ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo number_format($line['numRows']); ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo number_format($line['took']) . ' ms.'; ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php } ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;?php } ?&gt;
</pre></div></li><li class="listitem">Finally, edit your<code class="literal"> app/views/layouts/default.ctp</code> file and replace the line that reads <code class="literal">&lt;?php echo $this-&gt;element('sql_dump'); ?&gt;</code> with the following:<a id="id151" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;element('query_log'); ?&gt;
</pre></div></li></ol></div><p>If we now browse to <code class="literal">http://localhost/profiles</code>, we should see the improved query log that includes the explanation of<code class="literal"> SELECT</code> queries, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1926_05_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>How it works...</h2></div></div></div><p>The SQL command<code class="literal"> EXPLAIN</code> is used to obtain the execution plan for a<code class="literal"> SELECT</code> query. When using<code class="literal"> EXPLAIN</code>, MySQL includes information such as which tables are joined in the query, in which order they are joined, and what keys (if any) are used to optimize the query. This information can be used to optimize queries and considerably reduce their execution time.<a id="id152" class="indexterm"/>
</p><p>The<code class="literal"> QueryLog</code> component checks the<code class="literal"> debug</code> setting to determine if it should process the query log, and uses the<code class="literal"> minimumTime</code> setting to add more information about those queries that took a certain number of milliseconds, or more. In our example, we set this value to<code class="literal"> 0</code> when we added the component to<code class="literal"> AppController</code> to make sure all<code class="literal"> SELECT</code> queries are properly explained.</p><p>The component uses the<code class="literal"> beforeRender</code> callback to perform its processing right before a view is to be rendered. It starts by using the<code class="literal"> ConnectionManager::sourceList()</code> method to obtain a list of all available datasources (that is, the name of all connections defined in the<code class="literal"> app/config/database.php</code> file). For each of those connection names, it gets the actual datasource object using the<code class="literal"> ConnectionManager::getDataSource()</code> method. As we will see in other recipes in this chapter, a datasource may not implement all methods, so the component then uses the<code class="literal"> isInterfaceSupported()</code> method, available in all datasources, to see if that particular source implements the<code class="literal"> getLog()</code> method.</p><p>Using the<code class="literal"> getLog()</code> method, the component obtains the list of queries issued on a particular source, and filters those to check for only<code class="literal"> SELECT</code> queries that run for the minimum time specified in the<code class="literal"> minimumTime</code> setting. Once it has the list of<code class="literal"> SELECT</code> queries that need to be explained, it issues an<code class="literal"> EXPLAIN</code> SQL statement, and processes the result into a more readable format, ensuring that all fields obtained are lower case.<a id="id153" class="indexterm"/>
</p><p>Finally, and now that the query log is properly processed, it sets the appropriate view variable, which is utilized by the<code class="literal"> query_log.ctp</code> element to show the log.</p></div></div>
<div class="section" title="Parsing CSV files with a datasource"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Parsing CSV files with a datasource</h1></div></div></div><p>This recipe shows how to parse <span class="strong"><strong> comma-separated values</strong></span> (<span class="strong"><strong>CSV</strong></span>) files using a datasource, showing a clean approach to CSV processing.<a id="id154" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>Getting ready</h2></div></div></div><p>We start by installing CakePHP's datasources plugin. Download the latest release from <a class="ulink" href="http://github.com/mariano/datasources/downloads">http://github.com/mariano/datasources/downloads</a> and uncompress the downloaded file into your<code class="literal"> app/plugins</code> folder. You should now have a directory named<code class="literal"> datasources</code> inside<code class="literal"> app/plugins</code>.<a id="id155" class="indexterm"/>
</p><p>The datasources plugin, located at <a class="ulink" href="http://github.com/cakephp/datasources">http://github.com/cakephp/datasources</a>, is an official CakePHP plugin that offers several community-provided datasources, such as XML-RPC and SOAP. This and other recipes use a customized version of the plugin, modified for the purpose of this book.</p><p>We need some sample data to work with. Create a file named<code class="literal"> contacts.csv</code> and place it in a folder of your choice (such as<code class="literal"> /home/mariano</code>), with contents similar to the ones shown below. This example includes only two rows of data, but the file used in this recipe uses several more rows, and should include the starting header row:</p><div class="informalexample"><pre class="programlisting">name,email,country,gender,age
"John Doe","john.doe@email.com","United States of America","Male",34
"Jane Doe","jane.doe@email.com","United Kingdom","Female",25
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating a connection to use the CSV datasource. Open your<code class="literal"> app/config/database.php</code> file and add the following connection:<a id="id156" class="indexterm"/><div class="informalexample"><pre class="programlisting">public $csv = array(
'datasource' =&gt; 'datasources.CsvSource',
'path' =&gt; '/home/mariano/',
'readonly' =&gt; true
);
</pre></div></li><li class="listitem">Create a model named<code class="literal"> Contact</code> in a file named<code class="literal"> contact.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class Contact extends AppModel
{
public $useDbConfig = 'csv';
}
?&gt;
</pre></div></li><li class="listitem">Create its controller in a file named<code class="literal"> contacts_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class ContactsController extends AppController
{
public function index()
{
$this-&gt;set('contacts', $this-&gt;paginate());
}
}
?&gt;
</pre></div></li><li class="listitem">Finally, we need to create the view. Create a folder named<code class="literal"> contacts</code> in your<code class="literal"> app/views</code> folder, and in that folder create a file named<code class="literal"> index.ctp</code> with the following contents:<div class="informalexample"><pre class="programlisting">&lt;p&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Email&lt;/th&gt;
&lt;th&gt;Country&lt;/th&gt;
&lt;th&gt;Gender&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php foreach($contacts as $contact) { ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $contact['id']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $contact['name']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $contact['email']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $contact['country']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $contact['gender']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $contact['age']; ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php } ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
<a id="id157" class="indexterm"/>
</pre></div><p>If we now browse to <code class="literal">http://localhost/contacts</code>, we should see a paginated list, as shown in the following screenshot:
</p><div class="mediaobject"><img src="graphics/1926_05_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>How it works...</h2></div></div></div><p>We start by creating a new connection named<code class="literal"> csv</code>, specifying<code class="literal"> datasources.CsvSource</code> as its type, that is, a datasource named<code class="literal"> CsvSource</code> that is a part of a plugin named<code class="literal"> datasources</code>. We set the path to our CSV files to CakePHP's temporary directory using the<code class="literal"> path</code> setting, and we specify that we don't want that path to be created if it doesn't exist, by setting<code class="literal"> readonly</code> to true.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"/>Note</h3><p>The fork we are using in this recipe adds a feature to the original plugin: allowing one to change the CSV file used via the model property<code class="literal"> table</code>
</p></div><p>We then create the<code class="literal"> Contact</code> model, specifying its underlying connection to be<code class="literal"> csv</code> through the<code class="literal"> useDbConfig</code> property. The CSV data source will then use the respective table name as the name of the file, attaching the<code class="literal"> csv</code> extension to it. In this case, the CSV data source will use contacts for the<code class="literal"> Contact</code> model, which can be changed through the model property table.</p><p>Using that file name, it will look for it in the path that was defined in the connection settings. If the file cannot be loaded, or if the path does not exist, it will throw a missing table error, just as any model with a missing table would.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"/>Note</h3><p>The default<code class="literal"> csv</code> extension can be changed by specifying the<code class="literal"> extension</code> setting in the connection.</p></div><p>Once the file is properly loaded, the datasource allows us to fetch records by issuing simple<code class="literal"> find()</code> calls. It supports some of the most common find settings:<code class="literal"> limit, page, fields</code>, and includes basic support for defining the setting<code class="literal"> conditions</code> to limit the obtained records (see the<span class="emphasis"><em> There's more</em></span> section below).</p><p>The rest of the recipe shows how we use our<code class="literal"> Contact</code> model just as we would use any model, exemplifying this flexibility with a paginated list of parsed CSV records.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>There's more...</h2></div></div></div><p>Other than being able to define which page to obtain (through the<code class="literal"> page</code> find setting) and how many records to obtain (using the<code class="literal"> limit</code> find setting), the CSV datasource allows for some basic filtering, by means of the handy<code class="literal"> Set::matches()</code> method. For example, we can modify our paginated list to obtain contacts whose ages are over 30, by adding the following<code class="literal"> conditions</code> setting to our<code class="literal"> index()</code> method:</p><div class="informalexample"><pre class="programlisting">public function index()
{
<span class="strong"><strong>$this-&gt;paginate = array(
'conditions' =&gt; array('age &gt;' =&gt; 30)
);</strong></span>
$this-&gt;set('contacts', $this-&gt;paginate());
}
</pre></div><div class="section" title="Dynamic loading of CSV files"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Dynamic loading of CSV files</h3></div></div></div><p>The example used in this recipe is bound to the file<code class="literal"> contacts.csv</code> by means of the default table named for the<code class="literal"> Contact</code> model, but what would be required if we needed to process several CSV files and we don't want to create a model for each of those files?<a id="id158" class="indexterm"/>
</p><p>Using the<code class="literal"> table</code> model property, we can dynamically change the underlying CSV file a model is importing from, and execute our<code class="literal"> find</code> operations just as if we would've created a model specifically for this file. We start by creating a model that uses the<code class="literal"> csv</code> connection, but that is not tied to any file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Csv extends AppModel
{
public $useDbConfig = 'csv';
public $useTable = false;
}
?&gt;
</pre></div><p>Setting<code class="literal"> useTable</code> to<code class="literal"> false</code> allows us to avoid any file loading. We can then use the<code class="literal"> listSources()</code> datasource method to obtain a list of all CSV files available for importing, and then dynamically change the<code class="literal"> table</code> model property for each of those files, and fetch the actual records. We do this in the following<code class="literal"> controller</code> method:<a id="id159" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">public function import()
{
$this-&gt;loadModel('Csv');
$sources = array_flip($this-&gt;Csv-&gt;getDataSource()-&gt;listSources());
foreach($sources as $source =&gt; $null)
{
$this-&gt;Csv-&gt;table = $source;
$sources[$source] = $this-&gt;Csv-&gt;find('all');
}
debug($sources);
exit;
}
</pre></div><p>The list of files obtained through the<code class="literal"> listSources()</code> method is fetched from the<code class="literal"> path</code> setting specified in the datasource configuration, as defined in<code class="literal"> app/config/database.php</code>. This path can be changed by first cleaning up the current connection, which releases the handle to the previously configured path, by using the datasource<code class="literal"> setConfig()</code> method to change the<code class="literal"> path</code> setting, and then calling it's<code class="literal"> connect()</code> method to load the path:</p><div class="informalexample"><pre class="programlisting">$dataSource = $this-&gt;Csv-&gt;getDataSource();
$dataSource-&gt;close();
$dataSource-&gt;setConfig(array('path' =&gt; '/home/john/'));
$dataSource-&gt;connect();
</pre></div></div></div></div>
<div class="section" title="Consuming RSS feeds with a datasource"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Consuming RSS feeds with a datasource</h1></div></div></div><p>This recipe shows how to get content from remote RSS feeds using a datasource.<a id="id160" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>Getting ready</h2></div></div></div><p>We start by installing the fork of CakePHP's datasources plugin. Download the latest release from <a class="ulink" href="http://github.com/mariano/datasources/downloads">http://github.com/mariano/datasources/downloads</a> and uncompress the downloaded file into your<code class="literal"> app/plugins</code> folder. You should now have a directory named<code class="literal"> datasources</code>. The fork used in this recipe uses a refactored version of the RSS datasource developed by Donatas Kairys, member of Loadsys Consulting. This modified version improves the datasource performance, and adds the possibility of changing the feed URL through a find setting. More information about the original datasource can be obtained at <a class="ulink" href="http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource">http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource</a>.<a id="id161" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec09"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating a connection to use the RSS datasource. Open your<code class="literal"> app/config/database.php</code> file and add the following connection:<div class="informalexample"><pre class="programlisting">public $feed = array(
'datasource' =&gt; 'datasources.RssSource',
'url' =&gt; 'http://marianoiglesias.com.ar/category/cakephp/feed/'
);
</pre></div></li><li class="listitem">Create a model named<code class="literal"> Post</code> in a file named<code class="literal"> post.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
public $useDbConfig = 'feed';
}
?&gt;
</pre></div></li><li class="listitem">Create its controller in a file named<code class="literal"> posts_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class PostsController extends AppController
{
public $helpers = array('Time');
public function index()
{
$this-&gt;paginate = array(
'order' =&gt; array('pubDate' =&gt; 'desc'),
'limit' =&gt; 9
);
$this-&gt;set('posts', $this-&gt;paginate());
}
}
?&gt;
</pre></div></li><li class="listitem">Finally, we need to create the view. Create a folder named<code class="literal"> posts</code> in your<code class="literal"> app/views</code> folder, and in that folder create a file named<code class="literal"> index.ctp</code> with the following contents:<div class="informalexample"><pre class="programlisting">&lt;p&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Title&lt;/th&gt;&lt;th&gt;Published&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php foreach($posts as $post) { ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $this-&gt;Html-&gt;link($post['Post']['title'], $post['Post']['link']); ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $this-&gt;Time-&gt;nice($post['Post']['pubDate']); ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php } ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</pre></div></li></ol></div><p>If we now browse to <code class="literal">http://localhost/posts</code>, we should see a paginated list of posts, as shown in the following screenshot:<a id="id162" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926_05_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>How it works...</h2></div></div></div><p>We start by creating a new connection named<code class="literal"> feed</code>, specifying<code class="literal"> datasources.FeedSource</code> as its type. We use the setting<code class="literal"> url</code> to specify the address of the feed source. Among other available connection settings we have:<a id="id163" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">encoding</code>: Sets the character encoding to use. Defaults to the CakePHP<code class="literal"> App.encoding</code> configuration setting.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cache</code>: If set to<code class="literal"> false</code>, no caching will be done. Otherwise this is the cache configuration name to use. Defaults to the configuration named<code class="literal"> default</code>.</li></ul></div><p>We then create the<code class="literal"> Post</code> model, specifying its underlying connection to be<code class="literal"> feed</code> through the<code class="literal"> useDbConfig</code> property. We then proceed to setup a paginated list of posts sorting by publication date (pubDate field) in descending order, and limiting to nine posts per page.</p><p>Just as with the CSV datasource shown in the recipe,<span class="emphasis"><em> Parsing CSV files with a datasource</em></span>, the RSS datasource allows some basic filtering. For example, to only show posts that were created in the year 2009 or later, we would add the following<code class="literal"> conditions</code> setting to our<code class="literal"> index()</code> method:</p><div class="informalexample"><pre class="programlisting">public function index()
{
$this-&gt;paginate = array(
<span class="strong"><strong>'conditions' =&gt; array('pubDate &gt;=' =&gt; '2009-01-01'),</strong></span>
'order' =&gt; array('pubDate' =&gt; 'desc'),
'limit' =&gt; 9
);
$this-&gt;set('posts', $this-&gt;paginate());
}
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec11"/>There's more...</h2></div></div></div><p>There are cases where we might not be able to define the feed URL in a configuration file, for example, if the URL comes from a dynamic data source. Fortunately, for these cases we have the option to define the feed address through a custom find setting.<a id="id164" class="indexterm"/>
</p><p>In the above example, we could remove the feed URL from the connection settings, and specify it as a find setting named<code class="literal"> url</code>:
</p><div class="informalexample"><pre class="programlisting">$this-&gt;paginate = array(
<span class="strong"><strong>'url' =&gt; 'http://marianoiglesias.com.ar/category/cakephp/feed/',</strong></span>
'order' =&gt; array('pubDate' =&gt; 'desc'),
'limit' =&gt; 9
);
$this-&gt;set('posts', $this-&gt;paginate());
</pre></div><div class="section" title="Changing connection settings at runtime"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Changing connection settings at runtime</h3></div></div></div><p>We've seen how we can change the feed URL by using a custom find setting. However, we could also change this address by modifying the connection settings. Using the method<code class="literal"> setConfig()</code>, available in all datasources, we can make changes to any connection setting. For example, instead of using the<code class="literal"> url</code> custom find setting, we'll change the feed URL by changing the connection:<a id="id165" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$this-&gt;Post-&gt;getDataSource()-&gt;setConfig(array(
'url' =&gt; 'http://marianoiglesias.com.ar/category/cakephp/feed/'
));</strong></span>
$this-&gt;paginate = array(
'order' =&gt; array('pubDate' =&gt; 'desc'),
'limit' =&gt; 9
);
$this-&gt;set('posts', $this-&gt;paginate());
</pre></div></div></div></div>
<div class="section" title="Building a Twitter datasource"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Building a Twitter datasource</h1></div></div></div><p>In this recipe we will learn how to implement our own datasource by providing a way to read from and post messages to a Twitter account.<a id="id166" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec12"/>Getting ready</h2></div></div></div><p>We will integrate this datasource with OAuth, which is an authentication mechanism supported by Twitter. To do so, we will use a class named<code class="literal"> HttpSocketOauth</code> developed by Neil Crookes, which is an extension to CakePHP's own<code class="literal"> HttpSocket</code> class that adds OAuth support in a clean and elegant way. Download the file named<code class="literal"> http_socket_oauth.php</code> from the URL <a class="ulink" href="http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php">http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php</a> and place it in your<code class="literal"> app/vendors</code> folder.<a id="id167" class="indexterm"/>
</p><p>There are other ways to communicate with an<code class="literal"> OAuth</code> provider such as Twitter, most noticeably using the<span class="strong"><strong> PHP OAuth library</strong></span> available at <a class="ulink" href="http://code.google.com/p/oauth-php">http://code.google.com/p/oauth-php</a>. This recipe uses Neil's approach for its simplicity.<a id="id168" class="indexterm"/>
</p><p>Let us continue by creating the<code class="literal"> Tweet</code> model. Create a file named<code class="literal"> tweet.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<a id="id169" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Tweet extends AppModel {
public $useDbConfig = 'twitter';
}
?&gt;
</pre></div><p>Create its controller in a file named<code class="literal"> tweets_controller.php</code> and place it in your<code class="literal"> app/controllers</code> with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class TweetsController extends AppController {
public function index($twitter) {
$tweets = $this-&gt;Tweet-&gt;find('all', array(
'conditions' =&gt; array('username' =&gt; $twitter)
));
$this-&gt;set(compact('tweets', 'twitter'));
}
public function add($twitter) {
if (!empty($this-&gt;data)) {
$this-&gt;Tweet-&gt;create();
if ($this-&gt;Tweet-&gt;save($this-&gt;data)) {
$this-&gt;Session-&gt;setFlash('Succeeded');
} else {
$this-&gt;Session-&gt;setFlash('Failed');
}
}
$this-&gt;redirect(array('action'=&gt;'index', $twitter));
}
}
?&gt;
</pre></div><p>We now need the appropriate view. Create a folder named<code class="literal"> tweets</code> in your<code class="literal"> app/views</code> folder, and inside it, create a file named<code class="literal"> index.ctp</code> with the following contents:<a id="id170" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo $this-&gt;Form-&gt;create(array('url' =&gt; array('action'=&gt;'add', $twitter)));
echo $this-&gt;Form-&gt;inputs(array(
'status' =&gt; array('label'=&gt;false)
));
echo $this-&gt;Form-&gt;end('Tweet this');
?&gt;
&lt;?php foreach($tweets as $tweet) { ?&gt;
&lt;p&gt;&lt;?php echo $tweet['Tweet']['text']; ?&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;
&lt;?php echo $this-&gt;Html-&gt;link(
date('F d, Y', strtotime($tweet['Tweet']['created_at'])),
'http://www.twitter.com/' . $tweet['User']['screen_name'] . '/status/' . $tweet['Tweet']['id']
); ?&gt;
with &lt;?php echo $tweet['Tweet']['source']; ?&gt;
&lt;/small&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;?php } ?&gt;
</pre></div><p>Next, we will need to register our application on Twitter. Go to the URL <a class="ulink" href="http://twitter.com/apps/new">http://twitter.com/apps/new</a> and fill in the form (an example is shown in the following figure.) Make sure you specify a domain different than<code class="literal"> localhost</code> when asked for your<span class="strong"><strong> Application Website</strong></span>, and that you select<span class="strong"><strong> Read &amp; Write</strong></span> when asked for the<span class="strong"><strong> Default Access Type</strong></span>. You will also need to specify<span class="strong"><strong> Browser</strong></span> as the<span class="strong"><strong> Application Type</strong></span>, and <code class="literal">http://localhost/tweets</code> as the<span class="strong"><strong> Callback URL</strong></span>, replacing <code class="literal">localhost</code> with your own host. This callback won't actually be utilized, as we will define it at runtime, but it is mandatory, so we need to fill it in.<a id="id171" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926_05_04.jpg" alt="Getting ready"/></div><p>When you successfully submit this form, Twitter will give you some information regarding your newly registered application. In that screen, make sure to grab what is shown as<span class="strong"><strong> Consumer key</strong></span> and<span class="strong"><strong> Consumer secret</strong></span>, as we will need it when going through this recipe.</p><p>Add a new connection named<code class="literal"> $twitter</code> to your<code class="literal"> app/config/database.php</code>, by using the following contents and replacing<code class="literal"> KEY</code> with your<span class="strong"><strong> Consumer key</strong></span> and<code class="literal"> SECRET_KEY</code> with the<span class="strong"><strong> Consumer secret</strong></span> you obtained above:</p><div class="informalexample"><pre class="programlisting">public $twitter = array(
'datasource' =&gt; 'twitter',
'key' =&gt; 'KEY',
'secret' =&gt; 'SECRET_KEY'
);
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec13"/>How to do it...</h2></div></div></div><p>We start by fully implementing the datasource. Create a file named<code class="literal"> twitter_source.php</code> and place it in your<code class="literal"> app/models/datasources</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
App::import('Vendor', 'HttpSocketOauth');
class TwitterSource extends DataSource {
public $_baseConfig = array(
'key' =&gt; null,
'secret' =&gt; null
);
protected $_schema = array(
'tweets' =&gt; array(
'id' =&gt; array(
'type' =&gt; 'integer',
'null' =&gt; true,
'key' =&gt; 'primary',
'length' =&gt; 11,
),
'text' =&gt; array(
'type' =&gt; 'string',
'null' =&gt; true,
'key' =&gt; 'primary',
'length' =&gt; 140
),
'status' =&gt; array(
'type' =&gt; 'string',
'null' =&gt; true,
'key' =&gt; 'primary',
'length' =&gt; 140
),
)
);
public function __construct($config = null, $autoConnect = true) {
parent::__construct($config, $autoConnect);
if ($autoConnect) {
$this-&gt;connect();
}
}
public function listSources() {
return array('tweets');
}
public function describe($model) {
return $this-&gt;_schema['tweets'];
}
public function connect() {
$this-&gt;connected = true;
$this-&gt;connection = new HttpSocketOauth();
return $this-&gt;connected;
}
public function close() {
if ($this-&gt;connected) {
unset($this-&gt;connection);
$this-&gt;connected = false;
}
}
}
</pre></div><p>Now that we have the basic datasource skeleton, we need to add the ability for our datasorce to connect to Twitter, using OAuth. Add the following methods to the<code class="literal"> TwitterSource</code>:
<a id="id172" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class created before:public function token($callback = null) {
$response = $this-&gt;connection-&gt;request(array(
'method' =&gt; 'GET',
'uri' =&gt; array(
'host' =&gt; 'api.twitter.com',
'path' =&gt; '/oauth/request_token'
),
'auth' =&gt; array(
'method' =&gt; 'OAuth',
'oauth_callback' =&gt; $callback,
'oauth_consumer_key' =&gt; $this-&gt;config['key'],
'oauth_consumer_secret' =&gt; $this-&gt;config['secret']
)
));
if (!empty($response)) {
parse_str($response, $response);
if (empty($response['oauth_token']) &amp;&amp; count($response) == 1 &amp;&amp; current($response) == '') {
trigger_error(key($response), E_USER_WARNING);
} elseif (!empty($response['oauth_token'])) {
return $response['oauth_token'];
}
}
return false;
}
public function authorize($token, $verifier) {
$return = false;
$response = $this-&gt;connection-&gt;request(array(
'method' =&gt; 'GET',
'uri' =&gt; array(
'host' =&gt; 'api.twitter.com',
'path' =&gt; '/oauth/access_token'
),
'auth' =&gt; array(
'method' =&gt; 'OAuth',
'oauth_consumer_key' =&gt; $this-&gt;config['key'],
'oauth_consumer_secret' =&gt; $this-&gt;config['secret'],
'oauth_token' =&gt; $token,
'oauth_verifier' =&gt; $verifier
)
));
if (!empty($response)) {
parse_str($response, $response);
if (count($response) == 1 &amp;&amp; current($response) == '') {
trigger_error(key($response), E_USER_WARNING);
} else {
$return = $response;
}
}
return $return;
}
<a id="id173" class="indexterm"/>
</pre></div><p>Our datasource is now able to connect by requesting the proper authorization from Twitter. The next step is adding support to fetch tweets by implementing the datasource<code class="literal"> read()</code> method. Add the following method to the<code class="literal"> TwitterSource</code>:
</p><div class="informalexample"><pre class="programlisting">class:public function read($model, $queryData = array()) {
if (
empty($queryData['conditions']['username']) ||
empty($this-&gt;config['authorize'])
) {
return false;
}
$response = $this-&gt;connection-&gt;request(array(
'method' =&gt; 'GET',
'uri' =&gt; array(
'host' =&gt; 'api.twitter.com',
'path' =&gt; '1/statuses/user_timeline/' . $queryData['conditions']['username'] . '.json'
),
'auth' =&gt; array_merge(array(
'method' =&gt; 'OAuth',
'oauth_consumer_key' =&gt; $this-&gt;config['key'],
'oauth_consumer_secret' =&gt; $this-&gt;config['secret']
), $this-&gt;config['authorize'])
));
if (empty($response)) {
return false;
}
$response = json_decode($response, true);
if (!empty($response['error'])) {
trigger_error($response['error'], E_USER_ERROR);
}
$results = array();
foreach ($response as $record) {
$record = array('Tweet' =&gt; $record);
$record['User'] = $record['Tweet']['user'];
unset($record['Tweet']['user']);
$results[] = $record;
}
return $results;
}
<a id="id174" class="indexterm"/>
</pre></div><p>The job would not be complete if we are unable to post new tweets with our datasource. To finish our implementation, add the following method to the<code class="literal"> TwitterSource</code>:
</p><div class="informalexample"><pre class="programlisting">class:public function create($model, $fields = array(), $values = array()) {
if (empty($this-&gt;config['authorize'])) {
return false;
}
$response = $this-&gt;connection-&gt;request(array(
'method' =&gt; 'POST',
'uri' =&gt; array(
'host' =&gt; 'api.twitter.com',
'path' =&gt; '1/statuses/update.json'
),
'auth' =&gt; array(
'method' =&gt; 'OAuth',
'oauth_token' =&gt; $this-&gt;config['authorize']['oauth_token'],
'oauth_token_secret' =&gt; $this-&gt;config['authorize']['oauth_token_secret'],
'oauth_consumer_key' =&gt; $this-&gt;config['key'],
'oauth_consumer_secret' =&gt; $this-&gt;config['secret']
),
'body' =&gt; array_combine($fields, $values)
));
if (empty($response)) {
return false;
}
$response = json_decode($response, true);
if (!empty($response['error'])) {
trigger_error($response['error'], E_USER_ERROR);
}
if (!empty($response['id'])) {
$model-&gt;setInsertId($response['id']);
return true;
}
return false;
}
</pre></div><p>For the datasource to work, we will have to get OAuth authorization on all our requests to Twitter. To do so, we implement a method that will talk with the datasource to get the authorization keys, and handle the authorization callbacks Twitter will issue. Edit your<code class="literal"> app/controllers/tweets_controller.php</code> and add the following contents at the beginning of the<code class="literal"> TweetsController</code> class:</p><div class="informalexample"><pre class="programlisting">public function beforeFilter() {
parent::beforeFilter();
if (!$this-&gt;_authorize()) {
$this-&gt;redirect(null, 403);
}
}
protected function _authorize() {
$authorize = $this-&gt;Session-&gt;read('authorize');
if (empty($authorize)) {
$source = $this-&gt;Tweet-&gt;getDataSource();
$url = Router::url(null, true);
if (
!empty($this-&gt;params['url']['oauth_token']) &amp;&amp;
!empty($this-&gt;params['url']['oauth_verifier'])
) {
$authorize = $source-&gt;authorize(
$this-&gt;params['url']['oauth_token'],
$this-&gt;params['url']['oauth_verifier']
);
$this-&gt;Session-&gt;write('authorize', $authorize);
} elseif (!empty($this-&gt;params['url']['denied'])) {
return false;
} else {
$token = $source-&gt;token($url);
$this-&gt;redirect('http://api.twitter.com/oauth/authorize?oauth_token=' . $token);
}
}
if (!empty($authorize)) {
$this-&gt;Tweet-&gt;getDataSource()-&gt;setConfig(compact('authorize'));
}
return $authorize;
}
</pre></div><p>Assuming your twitter account name is<span class="strong"><strong> cookbook5</strong></span>, we now browse to <code class="literal">http://localhost/tweets/index/cookbook5</code>, and should see a paginated list of our tweets as shown in the following figure:<a id="id175" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926_05_05.jpg" alt="How to do it..."/></div><p>Using the form to post new tweets should submit our text to Twitter, and show us our new tweet in the listing.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>How it works...</h2></div></div></div><p>The Twitter datasource starts by specifying two new connection settings:<a id="id176" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">key</code>: A Twitter application consumer key</li><li class="listitem" style="list-style-type: disc"><code class="literal">secret</code>: A Twitter application consumer secret key</li></ul></div><p>It then defines a static schema, through the<code class="literal"> _schema</code> property and the<code class="literal"> listSources()</code> and<code class="literal"> describe()</code> method implementations, to describe how a tweet post is built. This is done purely to add support for a Twitter based model to work with CakePHP's<code class="literal"> FormHelper</code>. Doing so allows the<code class="literal"> FormHelper</code> to determine what type of field to use when rendering a form for a Twitter-based model.</p><p>The<code class="literal"> connect()</code> and<code class="literal"> close()</code> methods simply instantiate and erase respectively an instance of the<code class="literal"> HttpSocketOauth</code> class, which is our handler to communicate with the Twitter API.<a id="id177" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"/>Note</h3><p>OAuth is a complicated process, and understanding it may prove to be a challenge. If you wish to obtain more detailed information about this protocol, there is probably no better resource than the<span class="emphasis"><em> Beginner's Guide to OAuth</em></span>, available at <a class="ulink" href="http://hueniverse.com/oauth">http://hueniverse.com/oauth</a>.</p></div><p>The<code class="literal"> token()</code> method uses the connection to request a token from Twitter, which is needed for our requests to be successful. When one is obtained, we take the user to a specific Twitter URL using this token (the redirection takes place in the controller's<code class="literal"> _authorize()</code> method), which is then used by Twitter to request the user for authorization.</p><p>If the user allows the access to his/her Twitter account, the Twitter API will redirect the browser to the URL specified in the<code class="literal"> callback</code> argument of the datasource<code class="literal"> token()</code> method. This callback was set in<code class="literal"> _authorize()</code> as the current URL.</p><p>After the user is brought back to our application, the<code class="literal"> _authorize()</code> method will check for the existence of two parameters sent by Twitter:<code class="literal"> oauth_token</code> and<code class="literal"> oauth_verifier</code>. These parameters are passed as arguments to the datasource<code class="literal"> authorize()</code> method, which talks back to the Twitter API for the final stage in the OAuth authorization procedure. This stage ends with Twitter giving back a valid token, and a token secret key. They are saved in the controller as a session variable, to avoid doing this on every request.</p><p>Once we have the authorization information, we set it as a connection setting by using the<code class="literal"> setConfig()</code> method available in all datasources, and setting this information in a setting named<code class="literal"> authorize</code>, because we won't be able to read from or post to our Twitter account without this authorization.</p><p>The datasource<code class="literal"> read()</code> method is the implementation of all read procedures on our datasource. In our case, we only allow find operations that contain a condition on the field<code class="literal"> username</code>. This condition tells us from which user account we want to obtain tweets. Using this account name and the authorization information, we make a request to the Twitter API to obtain the user timeline. Because the request was made using JSON, which can be identified from the request URL), we use PHP's<code class="literal"> json_decode()</code> function to parse the response. We then browse through the resulting items (if no error was thrown) and change them into a more friendly format.</p><p>The datasource<code class="literal"> write()</code> method is the implementation of save operations, that is, the creating of new tweets (modification of existing tweets is not supported in this implementation). Similarly to the<code class="literal"> read()</code> method, we use the authorization information to make a POST request to the Twitter API, specifying as the tweet data whatever fields were sent to the method (combination of the<code class="literal"> fields</code> and<code class="literal"> values</code> arguments).<a id="id178" class="indexterm"/>
</p></div></div>
<div class="section" title="Adding transaction and locking support to the MySQL datasource"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Adding transaction and locking support to the MySQL datasource</h1></div></div></div><p>CakePHP's built-in MySQL datasource provides some basic transaction support by sending all unknown method calls directly to the datasource. However, this only enables us to use some basic transaction commands, and any locking would have to be performed through manual SQL queries.<a id="id179" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"/>Note</h3><p>Table locking is a mechanism to effectively manage concurrent access to table contents by different client sessions. More information about locking in MySQL is available at <a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html">http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html</a>.</p></div><p>This recipe shows how to modify an existing datasource by implementing better transaction support to the MySQL driver, adding locking operations, and finally allowing a recovery procedure for locked queries.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"/>Note</h3><p>More information about transaction support in MySQL databases is available at <a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/commit.html">http://dev.mysql.com/doc/refman/5.5/en/commit.html</a>.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a sample table to work with. Create a table named<code class="literal"> profiles</code> using the following SQL statement:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `profiles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`name` VARCHAR(255) default NULL,
PRIMARY KEY(`id`)
) ENGINE=InnoDb;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"/>Note</h3><p>The above query includes the specification of the MySQL database engine. Even when MyISAM (another available engine) can handle table level locking, row level locking is only possible on InnoDb tables. Furthermore, transactions are only supported on InnoDb. More information about the different engines and their supported features is available at <a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html">http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html</a>.</p></div><p>Add some sample data using the following SQL statements:<a id="id180" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">INSERT INTO `profiles`(`id`, `name`) VALUES
(1, 'John Doe'),
(2, 'Jane Doe');
</pre></div><p>We proceed now to create the required model. Create the model<code class="literal"> Profile</code> in a file named<code class="literal"> profile.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Profile extends AppModel {
}
?&gt;
</pre></div><p>Create its appropriate controller<code class="literal"> ProfilesController</code> in a file named<code class="literal"> profiles_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class ProfilesController extends AppController {
public function index() {
}
}
?&gt;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec16"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating the skeleton of our datasource. Create a folder named<code class="literal"> dbo</code> inside your<code class="literal"> app/models/datasources</code> folder. In the<code class="literal"> dbo</code> folder, create a file named<code class="literal"> dbo_mysql_transaction.php</code> with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
App::import('Core', 'DboMysql');
class DboMysqlTransaction extends DboMysql {
protected $backAutoCommit;
protected $lockTimeoutErrorCode = 1205;
public function __construct($config = null, $autoConnect = true) {
$this-&gt;_baseConfig = Set::merge(array(
'lock' =&gt; array(
'log' =&gt; LOGS . 'locks.log',
'recover' =&gt; true,
'retries' =&gt; 1
),
'autoCommit' =&gt; null
), $this-&gt;_baseConfig);
$this-&gt;_commands = array_merge(array(
'lock' =&gt; 'LOCK TABLES {$table} {$operation}',
'unlock' =&gt; 'UNLOCK TABLES',
'setAutoCommit' =&gt; 'SET @@autoCommit={$autoCommit}'
), $this-&gt;_commands);
parent::__construct($config, $autoConnect);
if (
!is_null($this-&gt;config['autoCommit']) &amp;&amp;
!$this-&gt;setAutoCommit($this-&gt;config['autoCommit'])
) {
trigger_error('Could not set autoCommit', E_USER_WARNING);
}
}
}
?&gt;
</pre></div></li><li class="listitem">We continue by adding methods to lock and unlock tables. Edit your<code class="literal"> app/models/datasources/dbo/dbo_mysql_transaction.php</code> file and add the following methods to the<code class="literal"> DboMysqlTransaction</code> class:<div class="informalexample"><pre class="programlisting">public function lock($model = null, $options = array()) {
if (!is_object($model) &amp;&amp; empty($options)) {
$options = $model;
$model = null;
}
if (empty($options) &amp;&amp; !isset($model)) {
trigger_error('Nothing to lock', E_USER_WARNING);
return false;
} elseif (!is_array($options)) {
$options = array('table' =&gt; $options);
} elseif (Set::numeric(array_keys($options))) {
if (count($options) &gt; 1) {
$options = array('table' =&gt; $options[0], 'operation' =&gt; $options[1]);
} else {
if (!empty($options[0]) &amp;&amp; is_array($options[0])) {
$options = $options[0];
} else {
$options = array('table' =&gt; $options[0]);
}
}
}
if (empty($options['table']) &amp;&amp; isset($model)) {
$options = array_merge(array(
'table' =&gt; $model-&gt;table,
'alias' =&gt; $model-&gt;alias
), $options);
if (!empty($options['operation']) &amp;&amp; $options['operation'] == 'read') {
unset($options['alias']);
}
}
$options = array_merge(array('alias'=&gt;null, 'operation'=&gt;'read', 'local'=&gt;false, 'low'=&gt;false), $options);
if (!in_array(strtolower($options['operation']), array('read', 'write'))) {
trigger_error(sprintf('Invalid operation %s for locking', $options['operation']), E_USER_WARNING);
return false;
}
$table = $this-&gt;fullTableName($options['table']);
if (!empty($options['alias'])) {
$table .= ' AS ' . $this-&gt;name($options['alias']);
}
$operation = strtoupper($options['operation']);
if ($options['operation'] == 'read' &amp;&amp; $options['local']) {
$operation .= ' LOCAL';
} elseif ($options['operation'] == 'write' &amp;&amp; $options['low']) {
$operation = 'LOW_PRIORITY ' . $operation;
}
$sql = strtr($this-&gt;_commands['lock'], array(
'{$table}' =&gt; $table,
'{$operation}' =&gt; $operation
));
return ($this-&gt;query($sql) !== false);
}
public function unlock($model = null, $options = array()) {
return ($this-&gt;query($this-&gt;_commands['unlock']) !== false);
}
While still editing the DboMysqlTransaction class, add the following methods to allow us to get and change the auto commit status:public function getAutoCommit($model = null) {
if (is_null($this-&gt;config['autoCommit'])) {
if (!$this-&gt;isConnected() &amp;&amp; !$this-&gt;connect()) {
trigger_error('Could not connect to database', E_USER_WARNING);
return false;
}
$result = $this-&gt;query('SELECT @@autocommit AS ' . $this-&gt;name('autocommit'));
if (empty($result)) {
trigger_error('Could not fetch autoCommit status from database', E_USER_WARNING);
return false;
}
$this-&gt;config['autoCommit'] = !empty($result[0][0]['autocommit']);
}
return $this-&gt;config['autoCommit'];
}
public function setAutoCommit($model, $autoCommit = null) {
if (!$this-&gt;isConnected() &amp;&amp; !$this-&gt;connect()) {
trigger_error('Could not connect to database', E_USER_WARNING);
return false;
}
if (is_bool($model)) {
$autoCommit = $model;
$model = null;
} elseif (is_array($autoCommit)) {
list($autoCommit) = $autoCommit;
}
$this-&gt;config['autoCommit'] = !empty($autoCommit);
$sql = strtr($this-&gt;_commands['setAutoCommit'], array(
'{$autoCommit}' =&gt; ($this-&gt;config['autoCommit'] ? '1' : '0')
));
return ($this-&gt;query($sql) !== false);
}
</pre></div></li><li class="listitem">We will now add our basic transaction commands. Edit your<code class="literal"> app/models/datasources/dbo/dbo_mysql_transaction.php</code> file and add the following methods to the<code class="literal"> DboMysqlTransaction</code> class:<a id="id181" class="indexterm"/><div class="informalexample"><pre class="programlisting">public function begin($model) {
$this-&gt;_startTransaction();
return parent::begin($model);
}
public function commit($model) {
$result = parent::commit($model);
$this-&gt;_endTransaction();
return $result;
}
public function rollback($model) {
$result = parent::rollback($model);
$this-&gt;_endTransaction();
return $result;
}
protected function _startTransaction() {
if ($this-&gt;getAutoCommit()) {
$this-&gt;backAutoCommit = $this-&gt;getAutoCommit();
$this-&gt;setAutoCommit(false);
}
}
protected function _endTransaction() {
if (isset($this-&gt;backAutoCommit)) {
$this-&gt;setAutoCommit($this-&gt;backAutoCommit);
$this-&gt;backAutoCommit = null;
}
}
public function query() {
$args = func_get_args();
if (!empty($args) &amp;&amp; count($args) &gt; 2 &amp;&amp; in_array($args[0], array_keys($this-&gt;_commands))) {
list($command, $params, $model) = $args;
if ($this-&gt;isInterfaceSupported($command)) {
return $this-&gt;{$command}($model, $params);
}
}
return call_user_func_array(array('parent', 'query'), $args);
}
</pre></div></li><li class="listitem">We end by adding methods to recover from a locked query, and to log those locks. Once again, edit your<code class="literal"> app/models/datasources/dbo/dbo_mysql_transaction.php</code> file and add the following methods to the<code class="literal"> DboMysqlTransaction</code> class:<div class="informalexample"><pre class="programlisting">public function _execute($sql, $retry = 0) {
$result = parent::_execute($sql);
$error = $this-&gt;lastError();
if (
!empty($error) &amp;&amp;
$this-&gt;config['lock']['recover'] &amp;&amp;
preg_match('/^\b' . preg_quote($this-&gt;lockTimeoutErrorCode) . '\b/', $error)
) {
if ($retry == 0) {
$message = 'Got lock on query [' . $sql . ']';
$queries = array_reverse(Set::extract($this-&gt;_queriesLog, '/query'));
if (!empty($queries)) {
$message .= " Query trace (newest to oldest): \n\t";
$message .= implode("\n\t", array_slice($queries, 0, 5));
}
$this-&gt;lockLog($message);
}
if ($retry &lt; $this-&gt;config['lock']['retries']) {
$result = $this-&gt;_execute($sql, $retry + 1);
} elseif (!empty($this-&gt;config['lock']['log'])) {
$this-&gt;lockLog('Failed after ' . number_format($retry) . ' retries');
}
} elseif (empty($error) &amp;&amp; $retry &gt; 0 &amp;&amp; !empty($this-&gt;config['lock']['log'])) {
$this-&gt;lockLog('Succeeded after ' . number_format($retry) . ' retries');
}
if (empty($error) &amp;&amp; !$this-&gt;fullDebug &amp;&amp; !empty($this-&gt;config['lock']['log'])) {
$this-&gt;logQuery($sql);
}
return $result;
}
protected function lockLog($message) {
$message = '['.date('d/m/Y H:i:s') . '] ' . $message . "\n";
$handle = fopen($this-&gt;config['lock']['log'], 'a');
if (!is_resource($handle)) {
trigger_error(sprintf('Could not open log file %s', $this-&gt;config['lock']['log']), E_USER_WARNING);
return false;
}
fwrite($handle, $message);
fclose($handle);
return true;
}
</pre></div></li><li class="listitem">To test what happens when you reach a lock, edit your<code class="literal"> app/controllers/profiles_controller.php</code> file and add the following method to the<code class="literal"> ProfilesController</code> class:<div class="informalexample"><pre class="programlisting">public function index() {
$this-&gt;Profile-&gt;setAutoCommit(false);
if ($this-&gt;Profile-&gt;lock()) {
$profile = $this-&gt;Profile-&gt;find('all');
debug($profile);
$this-&gt;Profile-&gt;unlock();
}
exit;
}
</pre></div></li><li class="listitem">Open your MySQL client and issue the following SQL commands (don't close the client after you issue these commands as you may want to release the lock as shown later):<a id="id182" class="indexterm"/><div class="informalexample"><pre class="programlisting">SET @@autocommit=0;
LOCK TABLE `profiles` WRITE;
</pre></div></li><li class="listitem">If we now browse to <code class="literal">http://localhost/profiles</code> we should get an SQL error message that reads<span class="strong"><strong> SQL Error: 1205: Lock wait timeout exceeded; try restarting transaction</strong></span>. A file named<code class="literal"> locks.log</code> should have been created in your<code class="literal"> app/tmp/logs</code> folder with the following contents (the database name<code class="literal"> cookbook_chapter5_transaction</code> should change to the name of the database you are using):<div class="informalexample"><pre class="programlisting">[23/06/2010 09:14:11] Got lock on query [LOCK TABLES `profiles` AS `Profile` READ] Query trace (newest to oldest):
SET @@autocommit=0
DESCRIBE `profiles`
SHOW TABLES FROM `cookbook_chapter5_transaction`;
[23/06/2010 09:14:17] Failed after 1 retries
</pre></div></li><li class="listitem">To test the recovery of locked queries, we could release the lock in our MySQL client by issuing the following command:<div class="informalexample"><pre class="programlisting">UNLOCK TABLES;
</pre></div><p>and do so somewhere between the first failed transaction and the next recovery attempt. To change how much time MySQL waits to see if a lock can be obtained, access MySQL documentation for the server setting <code class="literal">innodb_lock_wait_timeout</code>.
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>How it works...</h2></div></div></div><p>As we are extending a DBO based datasource, we name our class using the<code class="literal"> Dbo</code> prefix (DboMysqlTransaction), and place it in the<code class="literal"> dbo</code> folder which is itself in our<code class="literal"> app/models/datasources</code> folder.<a id="id183" class="indexterm"/>
</p><p>The initial implementation includes two class properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">backAutoCommit:Utilized</code> by the helper methods<code class="literal"> _startTransaction()</code> and<code class="literal"> _endTransaction()</code>, is used to temporarily change the auto commit setting.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lockTimeoutErrorCode</code>: Specifies MySQL's code number for identifying deadlock time expired errors.</li></ul></div><p>Our first method is the class constructor, which is overridden to add our own connection settings, and the actual SQL commands to lock and unlock tables and to change the auto commit setting. The connection settings we added are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lock</code>: It is a set of settings that specify what to do when dealing with locked queries. Its subset of settings are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">log</code>: It is path to the file where to store logging information. If set to<code class="literal"> false</code>, logging will be disabled. Defaults to a file named<code class="literal"> locks.log</code> that is created in the<code class="literal"> app/tmp/logs</code> directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">recover</code>: It decides whether to try to recover from locked queries. If set to<code class="literal"> false</code>, no recovery will be attempted. Defaults to<code class="literal"> true</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retries</code>: It decides if<code class="literal"> recover</code> is set to<code class="literal"> true</code>, how many attempts to rerun the failed (locked) query. Defaults to<code class="literal"> 1</code>.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">autoCommit</code>: It gives the initial autocommit value (true for enabled,<code class="literal"> false</code> for disabled). If set to<code class="literal"> null</code>, it will get its value from the database server.</li></ul></div><p>We then implement the<code class="literal"> lock()</code> and<code class="literal"> unlock()</code> methods. The<code class="literal"> lock()</code> method allows us to lock a table for a certain operation. We can use it directly from a model to lock its underlying table for a<code class="literal"> read</code> operation:</p><div class="informalexample"><pre class="programlisting">$this-&gt;Profile-&gt;lock();
</pre></div><p>We can change the locking operation to be<code class="literal"> write</code>:
</p><div class="informalexample"><pre class="programlisting">$this-&gt;Profile-&gt;lock(array('operation'=&gt;'write'))
</pre></div><p>We can also use it to lock a specific table, using either the<code class="literal"> lock()</code> method available on all models using this datasource, or directly invoking the method in the datasource:</p><div class="informalexample"><pre class="programlisting">$this-&gt;Profile-&gt;getDataSource()-&gt;lock(array(
'table' =&gt; 'profiles',
'operation'=&gt;'write'
));
</pre></div><p>The<code class="literal"> unlock()</code> method is used similarly, either through the model, or directly using the datasource) and unlocks all locked tables.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"/>Note</h3><p>When you do lock table, make sure you disable auto commit, by using the<code class="literal"> setAutoCommit()</code> method, like so:<code class="literal"> $this-&gt;Profile-&gt;setAutoCommit(false)</code>;</p></div><p>In the next block of code, we add the implementation for starting, committing and rolling back transactions. There is not much detail needed for these methods except that they take care of disabling auto-commit upon starting a transaction, and reset its status after a transaction is finished.</p><p>The<code class="literal"> query()</code> method is overridden to allow executing some of our datasource methods directly from our models. That is the case for the three methods we added:<code class="literal"> lock(), unlock()</code>, and<code class="literal"> setAutoCommit().</code>
</p><p>Finally, we override the<code class="literal"> _execute()</code> method to detect when a lock wait timeout error is thrown. In these cases, we use the<code class="literal"> lockLog()</code> method to LOG the situation, and we proceed to retry the query if we were told to do so.</p></div></div></body></html>