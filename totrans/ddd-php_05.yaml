- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve already seen what Entities and Value Objects are. As basic building
    blocks, they should contain most of the business logic of any application. However,
    there are some scenarios where Entities and Value Objects aren''t the best solutions.
    Let''s take a look at what Eric Evans has to say about this in his book, [Domain-Driven
    Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215):'
  prefs: []
  type: TYPE_NORMAL
- en: When a significant process or transformation in the domain is not a natural
    responsibility of an Entity or Value Object, add an operation to the model as
    standalone interface declared as a Service. Define the interface in terms of the
    language of the model and make sure the operation name is part of the Ubiquitous
    Language. Make the Service stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when there are operations that need to be represented, but Entities and
    Value Objects aren''t the best place, you should consider modeling these operations
    as Services. In Domain-Driven Design, there are typically three different types
    of Services you''ll encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Services**: Operate on scalar types, transforming them into Domain
    types. A scalar type can be considered any type that''s unknown to the Domain
    Model. This includes primitive types and types that don''t belong to the Domain.
    We''ll provide an overview in this chapter, but for a deeper look at this topic,
    check out the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Services**: Operate only on types belonging to the Domain. They contain
    meaningful concepts that can be found within the Ubiquitous Language. They hold
    operations that don''t fit well into Value Objects or Entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure Services**: Are operations that fulfill infrastructure concerns,
    such as sending emails and logging meaningful data. In terms of Hexagonal Architecture,
    they live outside the Domain boundary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Services are the middleware between the outside world and the Domain
    logic. The purpose of such a mechanism is to transform commands from the outside
    world into meaningful Domain instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the *User signs up to our platform* use case. Starting with
    an outside-in approach: from the delivery mechanism, we need to compose the input
    request for our Domain operation. Using a framework like Symfony as the delivery
    mechanism, the code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create a new instance of our Application Services, passing
    all dependencies needed — in this case, a `UserRepository`. `UserRepository` is
    an interface that can be implemented with any specific technology (Example: MySQL,
    Redis, Elasticsearch). Then, we build a request object for our Application Service
    in order to abstract the delivery mechanism — in this example, a web request —
    from the business logic. Last, we execute the Application Service, get the response,
    and use that response for rendering the result. On the Domain side, let''s check
    a possible implementation for the Application Service that coordinates the logic
    that fulfills the *User signs up* use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything in the code is about the Domain problem we want to solve, and not
    about the specific technology we''re using to solve it. With this approach, we
    can decouple the high-level policies from the low-level implementation details.
    The communication between the delivery mechanism and the Domain is carried by
    data structures called DTOs, which we introduced in the [Chapter 2](d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml), *Architectural
    Styles*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different strategies for returning content, but for now, consider
    that we shouldn''t return our Entities so that they can''t be modified from outside
    our Application Services. That''s why it''s common to return another DTO with
    information, rather than the whole Entity. Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For creating your responses, you can use getters or public instance variables.
    Application Services should take care with transaction scopes and security. However,
    you'll delve into more detail about these and other things related to Application
    Services in the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout conversations with Domain Experts, you''ll come across concepts
    in the Ubiquitous Language that can''t be neatly represented as either an Entity
    or a Value Object, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Users being able to sign into systems by themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shopping cart being able to become an order by itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding example are two concrete concepts, neither of which can naturally
    be bound to either an Entity or a Value Object. Further highlighting this oddity,
    we can attempt to model the behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the first implementation, we're not able to know that the given
    username and password relate to the invoked-upon user instance. Clearly, this
    operation doesn't suit this Entity; instead, it should be extracted out into a
    separate class, making its intention explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we could create a Domain Service with the sole responsibility
    of authenticating users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, as in the case of the second example, we could create a Domain Service
    specialized in creating orders from a supplied cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A Domain Service can be defined as an operation that fulfills a Domain task
    and naturally doesn't fit into either an Entity or a Value Object. As concepts
    that represent operations in the Domain, Domain Services should be used by clients
    regardless of their run history. Domain Services don't hold any kind of state
    by themselves, so Domain Services are stateless operations.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Services and Infrastructure Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s common to encounter infrastructural dependencies when modeling a Domain
    Service  — for example, in the case where an authentication mechanism that handles
    password hashing is required. In this instance, you could use a [Separated Interface](http://martinfowler.com/eaaCatalog/separatedInterface.html),
    which allows for multiple hashing mechanisms to be defined. Using this pattern
    still provides you with a clear Separation of Concerns between the Domain and
    the Infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding interface found in the Domain, we could create an implementation
    in the Infrastructure layer, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another implementation based instead on the MD5 algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Opting for this choice allows us to have multiple implementations of the Domain
    Service interface at the Infrastructure layer. In other words, we end up with
    several Infrastructure Domain Services. Each Infrastructure service will be responsible
    for handling a different hash mechanism. Depending on the implementation, the
    use can easily be managed through a Dependency Injection container — for example,
    through Symfony''s Dependency Injection component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If, in the future, we wish to handle a new type of hashing, we can simply start
    by implementing the Domain Service interface. Then it's a matter of declaring
    the service in the Dependency Injection container and replacing the service alias
    dependency with the newly created one.
  prefs: []
  type: TYPE_NORMAL
- en: An Issue of Code Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the implementation described previously clearly defines the Separation
    of Concerns, we''re required to repeat the password verification algorithm every
    time we wish to implement a new hashing mechanism. An alternative for solving
    this problem, which improves code reuse, is by separating out these two responsibilities.
    We could instead extract the password hashing logic out into a specialized class,
    using the [Strategy Pattern](http://en.wikipedia.org/wiki/Strategy_pattern) for
    all defined hashing algorithms. This leaves the design open for extension and
    closed for modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining different hashing strategies is as easy as implementing the `PasswordHashing`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing Domain Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the user authentication example from multiple Domain Service implementations,
    it''s extremely beneficial to be able to easily test the service. Typically, however,
    testing the Template Method implementations can be tricky. As a result, we''ll
    be using a plain password hashing implementation for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test all cases in the Domain Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Anemic Domain Models Vs Rich Domain Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must be cautious not to overuse Domain Service abstractions within your
    system. Following this path can lead to Entities and Value Objects being stripped
    of all behavior and becoming mere data containers. This is contrary to the goal
    of Object-Oriented Programming, which can be thought of as the gathering of both
    data and behavior into semantic units called objects, with the intent of expressing
    real-world concepts and problems. Domain Service overuse can be considered an
    anti-pattern and is referred to as the Anemic Domain Model.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when starting a new project or feature, it's easy to fall into the
    trap of modeling the data first. This commonly includes thinking that each database
    table has a direct one-to-one object form representation. However, this thinking
    may or may not be the exact case all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we''re tasked with modeling an order processing system. If we start
    by modeling the data first, we could end up with an SQL script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, it''s relatively easy to create an `Order` class representation.
    This representation includes the required accessor methods, which are used to
    set or get data to and from the underlying orders database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An example use case for this implementation could be to update the order status
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With regard to code reuse, this code has a problem similar to the initial user
    authentication solution. To resolve this issue, defenders of such a practice suggest
    the use of a [Service layer](http://martinfowler.com/eaaCatalog/serviceLayer.html),
    thereby making the operations explicit and reusable. This preceding implementation
    could now instead be encapsulated into a separate class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in the case of updating an order amount, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code would be drastically reduced following a clearly intentioned
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implementing this approach can result in a large degree of code reusability.
    Someone who wishes to update the order amount simply has to retrieve an instance
    of `UpdateOrderAmountService` and invoke the execute method with the appropriate
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: However, choosing this path breaks the discussed Object-Oriented Design principles
    and incurs the costs of building a Domain Model without taking advantage of any
    of the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Anemic Domain Model Breaks Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we revisit the code used to define the services within our Service layer,
    we can see that as a client making use of the Order Entity, we're required to
    know every detail of its internal representation. This finding goes against the
    fundamental rule of Object-Oriented Programming, which is combining data with
    subsequent behavior
  prefs: []
  type: TYPE_NORMAL
- en: Anemic Domain Model Brings a False Sense of Code Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say there''s an instance where a client bypasses `UpdateOrderAmountService`
    and instead fetches, updates, and persists directly to `OrderRepository`. Then,
    all the extra business logic that the `UpdateOrderAmountService` service might
    have won''t be executed. This could lead to the order being stored in an inconsistent
    state. As such, invariants should be correctly guarded, and the best way to do
    this is to let the true Domain Model handle it. In the case of this example, the
    Order Entity would be the best place to ensure this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that by pushing this action down into the Entity and naming it in terms
    of the Ubiquitous Language, the system achieves great code reuse. Anyone who now
    wishes to change the amount of the order has to invoke the `Order::changeAmount`
    method directly.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to far richer classes, where behavior is the goal for code reuse.
    This is commonly referred to as a Rich Domain Model.
  prefs: []
  type: TYPE_NORMAL
- en: How to Avoid Anemic Domain Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way to avoid falling into an Anemic Domain Model is to, when starting a
    new project or feature, think of the behavior first. Databases, ORMs, and so on
    are just implementation details, and we should strive to push the decision to
    use these tools as late in the development process as we can. In doing so, we
    can focus on the one true attribute that matters: the behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as is the case with Entities, Domain Services can also fire [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*.
    However, when events are mostly fired by Domain Services and not Entities, it's
    again an indicator that you may be creating an Anemic Domain Model.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, Services represent operations inside our system, and we can
    differentiate between three versions of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Services**: Help coordinate requests from the outside world into
    the Domain. These Services should not contain Domain logic. Transactions are handled
    in the application level; wrapping your services inside transnational decorators
    will make your code transaction agnostic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Services**: Operate with Domain concepts only, which are expressed
    by the Ubiquitous Language. Remember to postpone implementation details and think
    of behavior first, as abuse of Domain Services will lead to Anemic Domain Models
    and bad Object-Oriented Design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure Services**: Operate over Infrastructure, doing things like
    sending emails or logging information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our most important recommendation is that you should consider all your options
    before deciding on creating a Domain Service. First try to move your business
    logic inside an Entity or Value. Check with some workmates. Review again. If,
    after different approaches, the best option is creating a Domain Service, go for
    it.
  prefs: []
  type: TYPE_NORMAL
