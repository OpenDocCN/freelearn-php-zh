- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Is Test-Driven Development and Why Use It in PHP?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是测试驱动开发以及为什么在PHP中使用它？
- en: Developing web applications is fun and productive when using the PHP programming
    language. The learning curve to get started with PHP is relatively shallow, which
    is a very important trait of a programming language. There are a lot of open source
    learning materials, frameworks, packages, and full-blown extendable products backed
    by a very large open source community available for PHP developers. PHP is an
    enterprise-ready programming language and is widely used as a web-based solution
    to solve different business problems. Businesses and developers can quickly develop
    and deploy web applications with PHP. Once these businesses start to succeed and
    grow, they’ll need more features, bug fixes, and improvements to be released on
    top of the original solution. This is where it starts to get interesting. Maintenance
    of commercially successful software can be one of the biggest contributing factors
    to the cost of the software, especially when it’s not built to be easily maintainable
    or testable from the beginning. Implementing **test-driven development** (**TDD**)
    will improve the maintainability of the software and will help reduce the cost
    and time to market for a feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP编程语言开发Web应用程序既有趣又高效。开始学习PHP的曲线相对较浅，这是编程语言的一个重要特性。对于PHP开发者来说，有许多开源的学习材料、框架、包和完整的可扩展产品，这些都得到了一个非常庞大的开源社区的支撑。PHP是一种企业级编程语言，被广泛用作基于Web的解决方案来解决不同的商业问题。企业和开发者可以快速使用PHP开发和部署Web应用程序。一旦这些企业开始成功并增长，他们就需要更多的功能、错误修复和改进来发布在原始解决方案之上。这正是事情变得有趣的地方。维护商业成功的软件可能是软件成本的最大贡献因素之一，尤其是当它不是从开始就易于维护或测试的时候。实施**测试驱动开发**（**TDD**）将提高软件的可维护性，并有助于减少功能上市的成本和时间。
- en: 'There’s a problem that most of us developers might have already experienced
    or observed: a feature or a bug fix has been released and it has caused more problems,
    regressions, or unintended software behavior. If you are coming from a development
    environment where most or all the **quality assurance** (**QA**) tests are done
    manually post-, pre-, or even mid-development, then you might have experienced
    the issues that I have mentioned. This is where implementing TDD can really help.
    TDD not only helps in implementing automated tests but also guides or even forces
    us in a way to develop cleaner and more loosely coupled codes. TDD helps developers
    write and build tests before even writing a single feature code – this helps ensure
    that whenever a feature or solution code is being written, there will be a corresponding
    test already written for it. It also helps us developers stop saying “*I’ll add
    my unit* *tests later*.”'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的大多数开发者可能已经经历过或观察到一个问题：一个功能或错误修复已经发布，但它导致了更多的问题、回归或意外的软件行为。如果你来自一个大多数或所有**质量保证**（**QA**）测试都是在开发后、前或甚至在开发过程中手动完成的开发环境，那么你可能已经体验到了我提到的问题。这就是实施TDD真正能帮助的地方。TDD不仅有助于实施自动化测试，而且以某种方式引导或甚至强迫我们开发更干净、更松散耦合的代码。TDD帮助开发者甚至在编写单个功能代码之前就编写和构建测试——这有助于确保每当编写功能或解决方案代码时，已经为其编写了相应的测试。它还帮助我们开发者停止说“*我稍后会添加我的单元*
    *测试*。”
- en: Before writing any codes, it’s very important to understand what TDD is, and
    what it is not. There are some common misconceptions about TDD that we need to
    clear up to help us stay focused on what TDD really is. In this chapter, we will
    also try to use a very simple analogy and try to emphasize why we would want to
    implement TDD as a part of a software project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，理解TDD是什么以及它不是什么非常重要。关于TDD存在一些常见的误解，我们需要澄清这些误解，以便我们能够专注于TDD的真正含义。在本章中，我们还将尝试使用一个非常简单的类比，并强调为什么我们想要将TDD作为软件开发项目的一部分来实施。
- en: 'In this chapter, we will be covering the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: What is TDD?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是TDD？
- en: Common misconceptions about TDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于TDD的常见误解
- en: Why should we even consider TDD?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要考虑TDD？
- en: What are we planning to achieve in this book?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这本书中计划实现什么？
- en: What is TDD?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是TDD？
- en: TDD is a simple way of developing software where we think about and define *what*
    needs to be the outcome of our programs before we start writing the actual codes
    that solve a problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种简单的软件开发方式，我们在开始编写解决问题的实际代码之前，先思考并定义程序需要达到的**结果**。
- en: TDD is a software development process where test cases are developed first before
    writing the actual code that solves a problem. The test cases will be written
    as PHP code that will use or call the solution code that developers will be building.
    The test case code that you build will trigger the development of the solution
    code that you will write to solve a problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种软件开发过程，其中在编写解决实际问题的实际代码之前，先开发测试用例。这些测试用例将以PHP代码的形式编写，将使用或调用开发者将要构建的解决方案代码。你构建的测试用例代码将触发你将要编写的解决实际问题的解决方案代码的开发。
- en: From what I’ve seen, this literal description is what demotivates a lot of developers
    from applying this process. TDD is a process, and it’s a way of thinking. It’s
    not simply about writing unit tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从我所见到的来看，这种字面上的描述让很多开发者失去了应用这一过程的动力。TDD是一个过程，它是一种思维方式。它不仅仅是关于编写单元测试。
- en: The test program you write should always fail the first time you run it because
    you haven’t built the programs the test needs to pass yet. Then, you will basically
    have to build the solution codes that the test program will use until the test
    program itself gets the expected results from your solution codes. Literally,
    the failing test will drive you to write the codes to pass the test – hence the
    term TDD. Maybe you can even call it failing-TDD. It’s like saying “*I wrote a
    test to fail my code, now I need to* *fix it*.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的测试程序在第一次运行时应该总是失败，因为你还没有构建测试需要通过的程序。然后，你基本上必须构建测试程序将使用的解决方案代码，直到测试程序本身从你的解决方案代码中获得预期的结果。实际上，失败的测试将驱使你编写通过测试的代码——这就是TDD（测试驱动开发）这个术语的由来。甚至你可以称之为“失败的TDD”。这就像说“我编写了一个测试来让我的代码失败，现在我需要*修复它*。”
- en: In TDD, I can see four main reasons why it’s important to write a failing test
    first. First, you will write a failing test and make sure your test framework
    application can recognize it. This ensures that your development environment is
    properly configured and you can run your test programs. Second, your failing test
    will help you define what solution or feature code you’d like to write, and what
    is expected for that test to pass. This will help you as a developer, in setting
    or focusing your mindset on the purpose of the feature code you are writing. Third,
    the failing tests you write will serve as reminders to know what other programs
    you need to complete. Fourth, writing your tests first will help ensure that your
    solution code is covered by automated tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，我可以看到四个主要的原因说明为什么先编写一个失败的测试很重要。首先，你会编写一个失败的测试并确保你的测试框架应用能够识别它。这确保了你的开发环境配置得当，你可以运行你的测试程序。其次，你的失败的测试将帮助你定义你想要编写的解决方案或功能代码，以及该测试通过时预期的内容。这将帮助你作为开发者，在设置或集中你的思维在你要编写的功能代码的目的上。第三，你编写的失败的测试将作为提醒，让你知道还需要完成哪些其他程序。第四，先编写测试将有助于确保你的解决方案代码被自动化测试覆盖。
- en: By trying to make your solution code unit-testable, you are sometimes inadvertently
    making your codes less coupled – it’s like a cycle. As you continue to write loosely
    coupled codes, you will notice that your codes will start to look more organized
    and less of a tangled mess. As you continue writing solution code following the
    TDD process, it will continuously help you spot where tight couplings are in your
    product, sometimes encouraging you to refactor and decouple your code just to
    make it unit-testable. There are software development principles that will help
    you further improve your codes, such as the Single-Responsibility Principle, which
    will be discussed more in [*Chapter 8*](B18318_08.xhtml#_idTextAnchor121), *Using
    TDD with* *SOLID Principles*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试使你的解决方案代码可单元测试，你有时无意中使你的代码耦合度降低——就像一个循环。随着你继续编写松散耦合的代码，你会发现你的代码开始看起来更有组织，不那么混乱。随着你继续按照TDD过程编写解决方案代码，它将不断地帮助你发现产品中紧密耦合的地方，有时甚至鼓励你重构和解除耦合代码，以便使其可单元测试。有一些软件开发原则可以帮助你进一步提高你的代码，例如单一职责原则，这将在[*第8章*](B18318_08.xhtml#_idTextAnchor121)“使用TDD与SOLID原则”中进一步讨论。
- en: Now that we have defined and have a brief understanding of what TDD is, let’s
    go through some of the common misconceptions associated with it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了TDD，并对它有一个简要的了解，让我们来看看与TDD相关的常见误解。
- en: Common misconceptions about TDD
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于TDD的常见误解
- en: In this section, we’ll look at some of the misconceptions that I have personally
    observed that developers have about TDD. Time and time again, I’ve encountered
    people who have a poor understanding of TDD. When I talk to some of them about
    why they’re not a fan of TDD, they sometimes tell me reasons that are not even
    related to TDD.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些我亲自观察到的开发者对 TDD 的误解。一次又一次，我遇到了对 TDD 理解很差的人。当我与他们谈论为什么不喜欢 TDD 时，他们有时会告诉我一些甚至与
    TDD 无关的原因。
- en: Testing software is not my job as a developer; therefore, I don’t need TDD
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试软件不是我的工作，因此我不需要 TDD
- en: I have said this myself. I used to think that I just needed to churn out solution
    code as fast as possible, test a little bit manually, and let the testing department
    ensure that everything is built correctly. This is probably the worst misconception
    I’ve ever had about TDD. As software developers, we develop software as solutions
    to problems. If we developers are the ones causing more problems, then we are
    not doing our jobs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己也曾说过这句话。我曾经认为，我只需要尽可能快地生成解决方案代码，手动测试一点，然后让测试部门确保一切构建正确。这可能是我对 TDD 最大的误解。作为软件开发者，我们开发软件是为了解决问题。如果我们开发者是造成更多问题的原因，那么我们就没有做好我们的工作。
- en: Developing with TDD is unnecessarily slow
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TDD 进行开发是不必要的缓慢
- en: I would be surprised if this were the first time you are hearing this. I first
    heard this from a client who had a technical background, not from a developer.
    I wasn’t a fan of TDD myself and willingly agreed with my client back then. Sure,
    it’s slower to write test codes and solution codes together; I would have to type
    more characters on my keyboard, after all!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次听到这个观点，我会感到惊讶。我第一次是从一个有技术背景的客户那里听到的，而不是从开发者那里。我自己也不是 TDD 的粉丝，当时很乐意同意客户的观点。当然，编写测试代码和解决方案代码确实会更慢；毕竟，我需要在键盘上多打一些字符！
- en: When working on enterprise projects, from what I have experienced, TDD is what
    saved us from months of bugs and regressions. Writing tests and having good test
    coverage, which is discussed in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070),
    *Unit Testing*, will help ensure that the next time someone else touches the code
    or adds new features, no regressions will be introduced. TDD will help you build
    a lot of automated tests, and running these tests is cheaper and quicker than
    handing over your untested solution code to a testing team or testing company
    for manual testing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理企业项目时，根据我的经验，TDD 是我们避免了几个月的时间来修复错误和回归问题的关键。编写测试并拥有良好的测试覆盖率，如第 [*第5章*](B18318_05.xhtml#_idTextAnchor070)
    中讨论的 *单元测试*，将有助于确保下次有人触摸代码或添加新功能时，不会引入回归。TDD 将帮助你构建大量的自动化测试，运行这些测试比将未经测试的解决方案代码交给测试团队或测试公司进行手动测试更便宜、更快。
- en: Writing automated or unit tests is TDD
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自动化或单元测试是 TDD
- en: TDD is not about writing automated tests or unit tests for existing functionalities.
    TDD is not about getting your QA department or getting a third-party company to
    write automated tests for existing software. This is the exact opposite of TDD.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 并非关于为现有功能编写自动化测试或单元测试。TDD 也不是指让 QA 部门或第三方公司为现有软件编写自动化测试。这与 TDD 完全相反。
- en: The most common misconception I have observed is that some developers and testers
    assume that TDD has something to do with testers writing automated tests for the
    codes that the developers build. I believe that this is a very bad misconception.
    It’s no different from developing a program and sending it to the QA department
    for manual testing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我观察到的最常见的误解是，一些开发者和测试人员认为 TDD 与测试人员为开发者构建的代码编写自动化测试有关。我认为这是一个非常错误的误解。这和开发一个程序然后将其发送到
    QA 部门进行手动测试没有区别。
- en: Getting testers to write automated functional tests is a very good thing, especially
    for existing functionalities that do not have automated tests, but this should
    only be thought of as supplementary test coverage for software and not be confused
    with TDD.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让测试人员编写自动化功能测试是非常好的事情，特别是对于没有自动化测试的现有功能来说，但这应该只被视为软件的补充测试覆盖率，不应与 TDD 混淆。
- en: TDD is a silver bullet
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD 是一个银弹
- en: The last misconception that I have encountered is assuming that if we developers
    have built excellent test coverage by following TDD, we will no longer need input
    from the software development department and QA department or team. Time and time
    again, I’ve proven myself wrong, believing that code that’s written via the TDD
    methodology is bulletproof. I am very fortunate to work with knowledgeable and
    skilled software engineers and test engineers. Code reviews are critical; always
    get your codes and test scenarios peer-reviewed. Edge-case tests and functional
    scenarios that the developers might have overlooked will cause problems – and
    in my experience, they have caused big problems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的最后一个误解是，如果我们开发者通过遵循TDD构建了优秀的测试覆盖率，我们就不再需要来自软件开发部门和QA部门或团队的输入。一次又一次，我证明了自己是错的，认为通过TDD方法编写的代码是坚不可摧的。我很幸运能与知识渊博和技能娴熟的软件工程师和测试工程师一起工作。代码审查是至关重要的；始终让你的代码和测试场景得到同行评审。开发者可能忽略的边缘情况测试和功能场景会导致问题——在我的经验中，它们已经导致了大问题。
- en: 'It is very important for the development and testing teams to properly understand
    the functional and acceptance test cases so that all imaginable scenarios are
    covered: the different types of tests will be covered in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070),
    *Unit Testing*. This is where **behavioral-driven development** (**BDD**) will
    start to make sense; BDD will be discussed in more detail in [*Chapter 6*](B18318_06.xhtml#_idTextAnchor094),
    *Applying Behaviour-Driven Development*. I have worked with test engineers and
    QA personnel who can come up with edge cases that I couldn’t have imagined.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发和测试团队来说，正确理解功能测试和验收测试用例非常重要，以便涵盖所有可想象的情况：不同类型的测试将在[*第5章*](B18318_05.xhtml#_idTextAnchor070)，*单元测试*中涵盖。这就是行为驱动开发（BDD）开始变得有意义的地方；BDD将在[*第6章*](B18318_06.xhtml#_idTextAnchor094)，*应用行为驱动开发*中更详细地讨论。我和能够想出我无法想象的边缘情况的测试工程师和QA人员一起工作过。
- en: We have gone through some common misconceptions I have encountered about TDD.
    Now let’s try to make a case for why we’d want to consider using TDD in our development
    process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些关于TDD的常见误解。现在让我们尝试说明为什么我们想要考虑在我们的开发过程中使用TDD。
- en: Why should we even consider TDD?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么要考虑TDD呢？
- en: Why would I want my codes to be driven by tests? I want my codes to be driven
    by requirements and happy clients! You may have heard about the term TDD and felt
    uncomfortable with it. When I first heard about the term TDD, I was a bit uncomfortable
    with it too. Why would you want to waste time writing test code to test solution
    code that doesn’t exist yet? Seriously, I need to write the actual code that solves
    the business problem, and you want me to write tests first? As a matter of fact,
    some developers I have trained and worked with have had this same question too
    – and it’s the exact same question that was stopping them from getting interested
    in TDD!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要让我的代码由测试驱动呢？我希望我的代码是由需求和满意的客户驱动的！你可能听说过TDD这个术语，并且对此感到不舒服。当我第一次听到TDD这个术语时，我也有些不舒服。为什么要浪费时间编写测试代码来测试尚未存在的解决方案代码呢？说真的，我需要编写解决业务问题的实际代码，而你却想让我先写测试代码？实际上，我培训过的一些开发人员和我一起工作时也有过同样的疑问——这正是阻止他们对TDD产生兴趣的问题！
- en: When I started my software development career, I was working for a small company
    where we were required to deliver results as soon as possible, in very few iterations.
    Just thinking about writing automated tests for my super-quickly written codes
    was a big waste of time! Therefore, when I read about TDD for the first time,
    I was not interested. I ignored my meatball spaghetti codes; all I cared about
    was making sure that the client got the intended business results in the shortest
    amount of time. Solving the regressions that would be caused by the bad codes
    as a problem for later. I needed to make the client happy as soon as possible
    – that is, right now. This is probably one of the most short-sighted mistakes
    I made in my professional career. Most of the time, my colleagues and I had to
    add features and maintain our own bowl of spaghetti mess. Time and time again,
    we would hate our past selves when we saw the mess we had made. Early in our careers
    as software developers, we have a lot of mistakes, inefficiencies, and short-sightedness.
    Thankfully, we are not the first ones to encounter these problems. There are processes
    that we can follow to help us improve the quality of the software we produce,
    and one of them is TDD.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始我的软件开发生涯时，我在一家小公司工作，我们被要求尽快交付结果，在非常少的迭代中完成。仅仅想到为我的快速编写的代码编写自动化测试就是一大浪费！因此，当我第一次读到TDD时，我没有兴趣。我忽视了那些肉丸意大利面式的代码；我所关心的是确保客户在最短的时间内得到预期的业务结果。将由糟糕的代码引起的回归问题留到以后解决。我需要尽快让客户满意——那就是，现在。这可能是我在职业生涯中犯过的最短视的错误之一。大多数时候，我和我的同事不得不添加功能并维护我们自己的意大利面式混乱。一次又一次，当我们看到我们造成的混乱时，我们都会讨厌过去的自己。作为软件开发者，我们职业生涯的早期有很多错误、低效和短视。幸运的是，我们不是第一个遇到这些问题的。有一些流程我们可以遵循，以帮助我们提高我们生产的软件质量，其中之一就是TDD。
- en: Now, after making so many mistakes, so many failures, and after working on hundreds
    of business-critical software projects, I can’t even imagine living a day without
    writing tests by following TDD. When working on a project, I don’t think I can
    even sleep properly at night without knowing whether my automated tests have passed
    or failed; at least I have the tests!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过这么多错误、这么多失败，以及参与数百个业务关键软件项目后，我甚至无法想象没有遵循TDD（测试驱动开发）来编写测试就能过一天。当我在一个项目上工作时，我不知道我的自动化测试是否通过或失败，我就无法好好睡觉；至少我有测试！
- en: 'Imagine creating a *clean my home* to-do list on your phone: you only have
    one item on it and it’s *clean the coffee machine*. You write that item down,
    get distracted and forget about it, and go on with your day. When you check your
    list again, you will realize that you have not cleaned the coffee machine yet!
    You then go ahead and clean the machine, and mark the item as completed.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在你的手机上创建一个“清洁我的家”待办事项清单：上面只有一个项目，那就是“清洁咖啡机”。你写下这个项目，然后分心忘记了，继续你的一天。当你再次查看你的清单时，你会意识到你还没有清洁咖啡机！然后你继续清洁机器，并将该项目标记为已完成。
- en: Well, that’s a bit like how TDD works. You write a failing test, then you write
    the codes to pass the test – and with the to-do list, you write out “*clean the
    coffee machine*”; then after you clean the actual coffee machine, you cross it
    out from your list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有点像TDD的工作方式。你先写一个失败的测试，然后编写代码来通过这个测试——然后，在你的待办事项清单上，你写下“清洁咖啡机”；然后在你实际清洁咖啡机后，你从清单上划掉它。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before anything else, I mean right now, you need to understand that it is very
    normal for a test to fail in the beginning and you need to be very comfortable
    with it and accept it. It’s like writing the coffee machine checklist item on
    your phone. Once you add that to your to-do list, the to-do list is failing you
    until you pass it by marking the to-do item as complete. You need to write the
    failing test first before writing any program to pass that test. This is a part
    of the **Red, Green, Refactor** (**RGR**) concept, which will be discussed further
    in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution Code with
    BDD* *and TDD*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他事情之前，我现在要告诉你，测试一开始就失败是很正常的，你需要非常舒适地接受它。这就像在你的手机上写下咖啡机清单项一样。一旦你把它添加到待办事项清单中，待办事项清单就会失败，直到你通过标记待办事项为完成来通过它。在编写任何通过测试的程序之前，你需要先编写失败的测试。这是**红、绿、重构**（**RGR**）概念的一部分，这将在[*第7章*](B18318_07.xhtml#_idTextAnchor108)“使用BDD和TDD构建解决方案代码”中进一步讨论。
- en: 'Going back to your phone, you add more items to that list: *clean the kitchen*,
    *clean the bedroom*, *clean the bathroom*… You then go to the gym and get distracted.
    You remember your list and want to know whether you have actually cleaned your
    home before going out, so you view your to-do list. You realize you only completed
    one item on the list; you will have to go back and finish the other tasks to fully
    satisfy the *clean my home* to-do list. When you return home, you can continue
    cleaning your home and ticking off your to-do list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Incomplete to-do list](img/Figure_1.1_B18318.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Incomplete to-do list
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the incomplete items on your to-do list as failing tests.
    The action of cleaning something is writing the codes to satisfy the failing to-do
    list item. You, finishing the task of cleaning the bedroom or bathroom, is akin
    to passing a test. Now imagine you have completed all the cleanings and so on,
    and you’ve marked all the items as checked on your *clean my home* list on your
    phone: you’re done!'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Completed to-do list](img/Figure_1.2_B18318.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Completed to-do list
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Now you can imagine your *clean my home* list as a test as well. Your test is
    satisfied by the overall completeness of the codes that were built to satisfy
    your smaller unit and integration tests (the types of tests will be discussed
    in detail in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108)*, Building Solution
    Code with BDD* *and TDD*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'We can consider the *clean my home* list as a test. This test runs through
    all the processes of cleaning a home. Some objects inside it involve cleaning
    the bathroom, some the kitchen, and so on. Just as we did when writing the to-do
    list, you write the failing test that represents the bigger picture first and
    not the smaller, more detailed tests:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After writing the failing *clean my home* test, which can only be satisfied
    by building the programs to clean each part of the house, we can start writing
    the failing tests for the smaller parts of the solution:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now imagine after cleaning your home, you ended up making a mess of the bedroom
    and you have unchecked the *clean my bedroom* item on your list. Technically speaking,
    your *clean my home* to-do list is now incomplete again. The same thing happens
    when after you have passed all the tests and someone in your team or you modifies
    the code and changes the expected behavior. If you then run your `testCanCleanMyHome()`
    test, it will fail. If we then run these automated tests before we deploy our
    codes to production, we will be able to catch regressions early on! It will be
    easier to catch code changes that break expected behaviors!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This is an oversimplification, but you will realize as we go along that this
    is what TDD is like. It’s not a bad, time-wasting exercise after all!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We are humans and we tend to make mistakes – at least that’s what I believe.
    Although if you think you don’t make mistakes, you might as well just pry the
    *Delete* key out of your keyboard as you don’t need it. I’ve made so many mistakes,
    and to help build confidence in my code, I ensure to pass all the tests and get
    the code peer-reviewed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是人类，我们倾向于犯错误——至少我认为是这样。尽管如果你认为你没有犯错误，你不妨把键盘上的*删除*键撬下来，因为你不需要它。我犯过很多错误，为了增强我对代码的信心，我确保通过所有测试并获得代码同行评审。
- en: Implementing TDD and having a lot of test coverage for your software is a great
    way of helping you and your team spot mistakes before they cause harm in production.
    Having all these different types of tests running before deployment helps me sleep
    better at night.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为软件实现TDD和拥有大量的测试覆盖率，是帮助你和你的团队在它们在生产中造成损害之前发现错误的好方法。在部署前运行所有这些不同类型的测试，有助于我晚上睡得更香。
- en: What are we planning to achieve in this book?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在这本书中计划实现什么？
- en: Well, obviously, we want to get a better understanding of TDD – not just with
    theories but with actual usable and applicable understanding. We want to help
    ourselves write better codes that will benefit other developers who will work
    on your own codes as well. We want to be able to lay a foundation for how to write
    software that will be robust and sturdy, self-diagnosing, and more extensible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，显然，我们想要更好地理解TDD——不仅仅是理论上的，而是实际可用和可应用的理解。我们想要帮助自己编写更好的代码，这将使其他开发者在编写你的代码时也能受益。我们想要能够为编写健壮、坚固、自我诊断和更具可扩展性的软件打下基础。
- en: We used a very simple analogy earlier using the *clean my home* to-do list to
    try to explain what TDD is and how it is done – but this will not be very exciting
    if it’s all just theory. In this book, we will try to implement TDD for real using
    an example project!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用了一个非常简单的类比，即使用“清洁我的家”待办事项列表来尝试解释TDD是什么以及它是如何进行的——但如果只是理论的话，这不会很有趣。在这本书中，我们将尝试使用一个示例项目来真正实现TDD！
- en: 'We will be building an example project that will help us do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个示例项目，这将帮助我们做到以下几件事：
- en: Identify what a client or a business wants to achieve
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定客户或企业想要实现的目标
- en: Translate those requirements into actual tickets
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将那些需求翻译成实际的工单
- en: Learn how to implement TDD and BDD
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现TDD和BDD（行为驱动开发）
- en: Write clean codes following design patterns and best practices
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照设计模式和最佳实践编写干净的代码
- en: Automatically run all tests using continuous integration
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用持续集成自动运行所有测试
- en: Automatically deploy our codes using continuous deployment
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用持续部署自动部署我们的代码
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have defined what TDD is and what it is not. We tried to
    relate TDD to simple everyday tasks such as cleaning certain parts of your home.
    By trying to clear up common misconceptions about TDD, hopefully, we will have
    a clearer understanding of what TDD is. TDD is a process; it’s not solely about
    writing unit tests and automated tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了TDD是什么以及它不是什么。我们试图将TDD与简单的日常任务，如清洁你家的某些部分联系起来。通过尝试澄清关于TDD的常见误解，我们希望对TDD有一个更清晰的理解。TDD是一个过程；它不仅仅是编写单元测试和自动化测试。
- en: We also covered why we would want to use TDD when developing PHP applications.
    TDD helps us develop cleaner, decoupled, maintainable codes, and it helps us be
    more confident that we won’t introduce regressions whenever we release codes,
    thanks to the automated test coverage that is inherently built by following TDD.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了为什么在开发PHP应用程序时我们会想要使用TDD（测试驱动开发）。TDD帮助我们开发更干净、解耦、可维护的代码，并且它使我们更有信心，在发布代码时不会引入回归，这要归功于遵循TDD时固有的自动化测试覆盖率。
- en: In the next chapter, we will start building the example project by coming up
    with a simple hypothetical business challenge first and making sense of what needs
    to be built to solve the problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过提出一个简单的假设商业挑战来开始构建示例项目，并弄清楚需要构建什么来解决该问题。
