# 开始使用领域驱动设计

那么，所有的喧嚣都是关于什么的呢？如果你已经阅读了 Vaughn Vernon 和 Eric Evans 关于这个主题的书籍，你可能对我们即将说的内容很熟悉，因为我们大量借鉴了他们的定义和解释。**领域驱动设计（DDD**），是一种帮助我们成功理解和构建软件模型设计的途径。它为我们提供了**战略**和**战术**建模工具，以帮助设计符合我们商业目标的优质软件。

本书的主要目标是向您展示领域驱动设计战术模式的 PHP 代码示例。如果您想了解更多关于战略模式和主要领域驱动设计的内容，您应该阅读*Vaughn Vernon*的[《领域驱动设计精粹》](https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420)或*Eric Evans*的[《领域驱动设计参考：定义和模式摘要》](https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-Summaries/dp/1457501198)。

更重要的是，**领域驱动设计不是关于技术的**。相反，它是关于围绕业务发展知识，并使用技术提供价值。只有当你能够理解公司所在业务时，你才能参与软件模型发现过程，以产生通用语言。

# 为什么领域驱动设计很重要

软件不仅仅是代码。如果你仔细想想，代码很少是我们职业的最终目标。代码只是解决商业问题的媒介。那么为什么它必须使用不同的语言呢？领域驱动设计强调确保商业和软件使用相同的语言。一旦打破了障碍，就无需翻译或繁琐的同步，信息不会丢失。每个人都在发现业务领域，而不仅仅是程序员。由此产生的软件是通用语言的唯一真理。

领域驱动设计还提供了一个战略和战术设计的框架——战略的是基于商业价值确定最重要的开发领域，战术的是构建经过实战检验的构建块和模式的可工作的领域模型。

# 领域驱动设计的三个支柱

领域驱动设计是一种交付软件的方法，它专注于三个支柱：

1.  **通用语言**：领域专家和软件开发者一起为正在开发的业务领域构建一个共同的语言。没有“我们与他们”；总是“我们”。开发软件是一种商业投资，而不仅仅是成本。构建通用语言的努力有助于在所有团队成员中传播深入的领域洞察。

1.  **战略设计**：领域驱动设计关注的是业务方向的策略，而不仅仅是技术方面。它有助于定义内部关系和早期预警反馈系统。在技术方面，战略设计通过提供如何实现面向服务的架构的动机来保护每个业务服务。

1.  **战术设计**：领域驱动设计提供了迭代软件交付的工具和构建块。战术设计工具产生的软件不仅正确，而且可测试且错误率较低。

# 通用语言

除了第十二章[整合**边界上下文**]，**通用语言**是领域驱动设计的主要优势之一。

在上下文方面

目前，考虑一个**边界上下文**是一个系统周围的概念边界。边界内的通用语言具有特定的上下文意义。此上下文之外的概念可以有不同的含义。

因此，如何找到、探索和捕捉这种非常特殊的语言，以下要点将突出同样的事情：

+   识别关键业务流程、它们的输入和输出

+   创建术语表和定义

+   使用某种形式的文档捕捉重要的软件概念

+   与团队中的其他成员（开发人员和领域专家）分享和扩展收集到的知识

自从领域驱动设计诞生以来，出现了许多改进构建通用语言过程的技巧。其中最重要的一个，现在经常使用，就是事件风暴。

# 事件风暴

阿尔贝托·布兰多利尼在一篇[博客文章](http://ziobrando.blogspot.com.es/2013/11/introducing-event-storming.html)中解释了事件风暴及其优势，他比我们更简洁地做了这件事。事件风暴是一种快速探索复杂业务领域的研讨会格式：

+   它是**强大的**：它使我以及许多从业者能够在数小时内而不是数周内构建出一个完整的业务流程的综合模型。

+   它是**吸引人的**：整个想法是将有疑问的人和知道答案的人放在同一个房间里，共同构建一个模型。

+   它是**高效的**：生成的模型与领域驱动设计实现风格（尤其是适合事件源方法）完美对齐，并允许快速确定上下文和聚合边界。

+   它是**简单的**：符号非常简单。没有可能让参与者脱离讨论核心的复杂 UML。

+   它是**有趣的**：我总是很享受领导研讨会，人们充满活力，交付的成果超过了他们的预期。正确的问题出现了，气氛恰到好处。

如果你想了解更多关于事件风暴的信息，请查看布兰多利尼的书籍，[介绍事件风暴](https://leanpub.com/introducing_eventstorming)。

# 考虑领域驱动设计

领域驱动设计不是万能的；就像软件中的所有事物一样，它取决于上下文。作为一个经验法则，使用它来简化你的领域，但永远不要增加更多的复杂性。

如果你的应用程序以数据为中心，你的用例主要是操作数据库中的行并执行 CRUD 操作——即创建、读取、更新和删除——那么你不需要领域驱动设计。相反，你的公司只需要在数据库前面有一个花哨的界面。

如果你的应用程序用例少于 30 个，使用像 Symfony 或 Laravel 这样的框架来处理业务逻辑可能更简单。

然而，如果你的应用程序用例超过 30 个，你的系统可能正在走向令人恐惧的[大泥球](https://en.wikipedia.org/wiki/Big_ball_of_mud)。如果你确信你的系统将增长复杂性，你应该考虑使用领域驱动设计来对抗这种复杂性。

如果你知道你的应用程序将会增长并且很可能会经常变化，领域驱动设计肯定有助于管理复杂性和随着时间的推移重构你的模型。

如果你因为该领域是新的，之前没有人投资解决方案，而对该领域不理解，这可能意味着它足够复杂，可以开始应用领域驱动设计。在这种情况下，你需要与领域专家紧密合作，以确保模型正确。

# 困难的部分

应用领域驱动设计并不容易。它需要时间精力来理解业务领域、术语、研究和与领域专家的合作，而不是编码术语。你还需要领域专家的承诺来参与这个过程。这需要开放和健康的持续对话，将他们的口头语言转化为软件。此外，我们还需要努力避免技术思维，首先要认真思考对象的行为和通用语言。

# 战略概述

为了提供一个关于领域驱动设计战略方面的概述，我们将使用来自*吉米·尼尔森*的书籍《应用领域驱动设计和模式》中的方法，[应用领域驱动设计和模式](https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202)。考虑两个不同的空间：问题空间和解决方案空间。

在问题空间中，领域驱动设计使用领域和子领域来分组和组织公司想要解决的问题。以**在线旅行社**（**OTA**）为例，问题在于处理诸如机票和酒店预订等问题。这样的领域可以组织成不同的子领域，如定价、库存、用户管理等。

在解决方案空间中，领域驱动设计提供了两种模式：边界上下文和上下文图。目标是定义如何通过定义它们的交互和交互的细节来为所有已识别的子域提供实现。继续使用 OTA 示例，每个子域都将通过边界上下文实现来解决——例如，考虑一个团队为定价管理子域开发的定制 Web 应用程序，以及为用户管理子域提供的现成解决方案。上下文图将显示每个边界上下文如何相互关联。在上下文图中，我们可以看到两个边界上下文之间有什么类型的关联（例如：客户-供应商，合作伙伴）。理想的方法是每个子域都由一个边界上下文实现，但这并不总是可能的。在实施方面，遵循领域驱动设计时，你最终会得到分布式架构。正如你可能已经知道的，分布式架构比单体架构更复杂，那么这种方法为什么有趣，尤其是对于大型和复杂公司？这真的值得吗？嗯，是的。

分布式架构已被证明可以增加整体公司生产力，因为它们为你的产品定义了由专注的团队开发的边界。

如果你的领域——你需要解决的问题——并不复杂，应用领域驱动设计的战略部分可能会增加不必要的开销并减慢你的开发速度。

如果你想了解更多关于领域驱动设计战略部分的信息，你应该看看*Vaughn Vernon*的书的头三章，[实施领域驱动设计](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon-ebook/dp/B00BCLEBN8)，或者*埃里克·埃文斯*的书籍[领域驱动设计：软件核心的复杂性处理](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)，这两本书都专门关注这个方面。

# 相关运动：微服务和自包含系统

有其他运动推广遵循与领域驱动设计相同原则的架构。微服务和自包含系统是这方面的良好例子。*詹姆斯·刘易斯*和*马丁·福勒*在[微服务资源指南](http://martinfowler.com/microservices/)中定义了微服务：

微服务架构风格是一种将单个应用程序作为一系列小型服务开发的方法，每个服务都在自己的进程中运行，并通过轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务围绕业务能力构建，并且可以使用完全自动化的机器独立部署。对这些服务的集中式管理最少，这些服务可能用不同的编程语言编写，也可能使用不同的数据存储技术。

如果你想了解更多关于微服务的知识，他们的指南是一个很好的起点。这与领域驱动设计（Domain-Driven Design）有何关系？正如*山姆·纽曼*（Sam Newman）的书中所解释的，[构建微服务](http://www.amazon.com/Building-Microservices-Sam-Newman/dp/1491950358)，微服务是领域驱动设计边界上下文的实现。

除了微服务（Microservices）之外，另一个相关的运动是**自包含系统**（**SCS**）。根据[自包含系统](http://scs-architecture.org)网站：

自包含系统（Self-contained System）方法是一种关注将功能分离成许多独立系统的架构，使完整的逻辑系统成为许多较小软件系统的协作。这避免了大型单体不断增长最终变得难以维护的问题。在过去的几年中，我们在许多中型和大型项目中看到了它的好处。这个想法是将一个大型系统分解成几个较小的自包含系统，或 SCS，它们遵循某些规则。

该网站还列出了 SCS 的七个特点：

每个 SCS 都是一个自主的 Web 应用程序。对于 SCS 的域，所有数据、处理这些数据的逻辑以及渲染 Web 界面的所有代码都包含在 SCS 内部。SCS 可以独立完成其主要用例，无需依赖其他系统可用。

每个 SCS 由一个团队拥有。这并不一定意味着只有一支团队可能会更改代码，但拥有团队对代码库中包含的内容有最终决定权，例如通过合并 pull-requests。

与其他 SCS 或第三方系统的通信尽可能异步。具体来说，其他 SCS 或外部系统不应在 SCS 自己的请求/响应周期内同步访问。这解耦了系统，减少了故障的影响，从而支持了自主性。目标是关于时间解耦：即使其他 SCS 暂时离线，SCS 也应能正常工作。即使技术层面的通信是同步的，例如通过复制数据或缓冲请求，这也是可以实现的。

SCS 可以有一个可选的服务 API。因为 SCS 有自己的 Web UI，它可以与用户交互——无需通过 UI 服务。然而，为移动客户端或其他 SCS 提供的 API 可能仍然有用。

每个 SCS 必须包含数据和逻辑。要真正实现任何有意义的特性，两者都是必需的。SCS 应自行实现功能，因此必须包含两者。

SCS 应该通过其自己的 UI 使其功能对最终用户可用。因此，SCS 不应与其他 SCS 共享任何 UI。SCS 之间可能仍然存在链接。然而，异步集成意味着即使另一个 SCS 的 UI 不可用，SCS 仍然应该工作。为了避免紧密耦合，SCS 不应与其他 SCS 共享任何业务代码。可能创建一个 SCS 的 pull-request 或使用公共库是可行的，例如数据库驱动程序或 oAuth 客户端。

练习

与你的同事讨论这种分布式架构的优缺点。考虑使用不同的语言、部署流程、基础设施责任等等。

# 总结

在本章中，你学到了：

+   领域驱动设计并非关于技术；实际上，它是通过关注模型，在您工作的领域提供价值。每个人都参与发现领域的过程，开发者和领域专家通过共享相同的语言，即通用语言，共同构建知识库。

+   领域驱动设计提供了战术和战略建模工具来设计高质量的软件。战略设计针对业务方向，有助于定义内部关系，并通过定义强大的边界在技术上保护每个业务服务。战术设计提供了迭代设计的有用构建块。

+   领域驱动设计仅在特定情境下才有意义。它并非解决软件中所有问题的万能钥匙，因此是否使用它高度取决于你处理复杂性的程度。

+   领域驱动设计是一项长期投资；它需要积极的努力。领域专家需要与开发者紧密合作，开发者也必须从商业角度思考。最终，必须让业务客户满意。

实施领域驱动设计需要努力。如果它很容易，那么每个人都会编写高质量的代码。准备好吧，因为你很快就会学到如何编写代码，当阅读时，它将完美地描述你公司运营的业务。享受这段旅程吧！
