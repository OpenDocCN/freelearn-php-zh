# 第九章。历史 API – 不要忘记我们身在何处

在上一章中，我们介绍了 Ajax，这是一组用于在 Web 应用程序中更新屏幕部分的技术，无需创建指向物理不同页面的链接，无需浏览器从服务器请求新页面并加载它。现代网站到处都在使用这项技术，它们的开发者也是如此；Ajax 是一种常见的做法，几乎是一种商品。

然而，这个概念对于你必须与之合作的营销人员和你的网站的访客来说都很难理解。你的营销人员不是经常要求你向网站添加一个页面，然后想知道 URL 是什么吗？亲爱的，它是**index.php**，它总是这样。通过菜单导航的你的网站访客，当他们点击浏览器的后退按钮时，会期望看到他们刚刚离开的屏幕。相反，他们会被带回到他们之前访问的网站，除非你使用本章中我们将教授你的技术。

我们首先将描述我们试图解决的问题；接下来，我们将解释在 HTML5 以及 HTML4 国家中，解决方案是什么。

# 我们试图解决的问题

想象一个水平导航菜单，访客点击菜单项，就像我们在上一章中使用的例子一样。在一个经典网站上，浏览器会将访客带到另一个页面，例如，`galleries.php`，浏览器的 URL 会显示出来。然而，基于 Ajax 的网站将简单地更新屏幕的一部分，每次访客点击菜单项时，都不会对 URL 栏做任何事情。无论他们选择多少项，一旦他们点击浏览器的*后退*按钮，他们就会发现自己回到了之前的页面，这将是之前的真实页面，通常是一个不同的网站，而这并不是他们期望的地方。

我们将通过一种将网站恢复到其先前状态的技术来解决此问题，因为我们不能将其带到上一页。在我们深入了解细节之前，让我们讨论一下关于**推送**和**弹出**状态的一些事情。

# 自助餐厅

描述我们即将学习的技术最好的方法是将它们与你在任何自助餐厅都能找到的东西进行比较。在这样的餐厅里，你首先拿起一个托盘，吃完饭后，你把它放回去。现在想象一个稍微不同的情况。你打算在放回托盘之前清洗它，这样你就可以把它放回你取它的同一个堆叠上。你必须想象的其他不同之处在于，不是有多个托盘，它们都同样无聊，因为它们看起来都一模一样，每个托盘上都会有一张不同的图片。

因此，所有这些托盘都是单个堆栈的一部分。当你接近堆栈时，你只能看到顶部托盘上的图片。如果你向堆栈中添加一个托盘，那个图片就会消失，因为它被我们放在顶部的托盘上的图片所取代。我们称之为**推送**。一些老式的堆栈有内置的弹簧，所以你必须真的把托盘推到底部，直到它保持在原位。

当你从堆栈中取出托盘时，情况正好相反。第二个托盘的图片变得可见，整个托盘堆栈略微弹出。这就是我们称之为**弹出**或**弹出**的原因。如果没有自助餐厅，可能就没有计算机科学，因为这个想法激励了许多计算机科学家在形式语法领域创建了弹出和下推自动机的理论。我写了我毕业的必读书，关于这样一个主题（不，我们那里没有自助餐厅）。

# HTML5 历史 API 和历史对象

浏览器使用一个类似的堆栈，称为`history`堆栈。在 JavaScript 中，你可以通过`history`对象访问它，该对象有几个可用方法。历史对象是窗口对象的一部分，通过`window.history`属性访问。它已经存在多年了。

通常，当用户导航到新页面时，浏览器会将新 URL 推送到其历史堆栈中，并下载和绘制新页面。当用户按下后退按钮时，浏览器从其历史堆栈中弹出一张页面并重新绘制上一个页面。

但如果我们使用 Ajax 调用更新屏幕的部分内容而不需要加载新页面呢？那么，浏览器将不会向那个堆栈中推送任何内容。嗯，这是真的，除非我们自己这样做。使这成为可能的关键是`popstate`事件和`history.pushState()`函数。

## pushState()

每次我们编写代码来更新屏幕的一部分，就像我们在上一章的示例中所做的那样，我们应该使用`pushState()`函数将一些相关信息推送到历史堆栈中，并且如果我们想的话，改变浏览器显示的 URL 字符串。`pushState()`接受三个参数：

```php
history.pushState(data, title, url);
```

第一个参数应该是某种结构化数据，例如一个尽可能有意义的键/值对数组。数据应包含足够的信息，使我们能够恢复我们在发出`pushState()`时页面的形状。

第二个参数的目的是显示在浏览器历史记录的下拉列表中的某种标题。在撰写本文时，没有单个浏览器实现了这一点。

最后一个参数用于传递一个字符串，这个字符串将成为我们在此页面状态下的替代 URL。它将由浏览器显示，因此，访问者会认为他已着陆在不同的页面上。这个 URL 字符串还有一个第二目的，我们将在本章末尾看到。因此，与一些示例相关的可能的`pushState()`语句可能是：

```php
url ="?anchor=agenda&key=" + nav;
updateAgendaContent(nav);  // this updates part of the screen
history.pushState({key:nav, anchor:"agenda"}, "", url);
```

因此，我们刚刚推到浏览器自助餐厅栈顶的盘子将有一个带有变量`nav`值的键图片，以及一个标记为`agenda`的锚点图片。URL 将与之前相同，并且附加了一个包含这两个键/值对的查询字符串。

### popstate 事件

在您使用`history.pushState()`函数将伪 URL 推送到浏览器的历史栈之后，当用户按下返回按钮时，浏览器将在`window`对象上触发一个`popstate`事件。这是我们创造一种错觉的机会，即实际上有不同页面，并且我们将访问者带回到他们认为的上一页。

为了这个目的，我们创建了一个事件处理程序，每次发生`popstate`事件时执行一些代码。我们已经有的大部分代码，因为我们使用了一个函数来绘制屏幕的一部分。我们可以简单地重用它。

```php
window.addEventListener('popstate', function(event) {
if (event.state){
switch (event.state.anchor) {

case "agenda":
  updateAgendaContent(event.state.key);
 break;
..
}

}
else
{
restoreHomePage();
}
});
```

因此，在前面的代码中，我们通过查看我们的栈来对每个`popstate`事件进行操作。如果它不为空但有一个标记为`agenda`的锚点图片，我们就查找`key`的值并调用带有`key`作为参数的函数`updateAgendaContent()`，以将屏幕上我们总是更新的部分恢复到其之前的状态。当然，这次我们不会调用`pushState()`。如果我们这样做，后续的返回键推送将不会有可见的效果。

还有一种特殊情况，当栈为空时，我们已经用完了托盘。然后，我们需要可能尚未编写的代码。在示例中，我使用了一个名为`restoreHomePage()`的占位符函数。这个函数应该做什么？它应该用我们页面首次加载时拥有的初始内容替换屏幕的变量部分。

### popstate 和不同浏览器

在撰写本文时，一些浏览器的行为与其他浏览器不同。当前版本的 Safari 在初始页面加载时将触发一个`popstate`事件，这可能会非常令人困惑。这也意味着，在 Safari 中，`restoreHomePage`函数将在初始页面加载后立即被调用。如果您的函数编写正确，这将用屏幕上已有的确切内容替换变量部分。这不是很愚蠢吗？如果网络速度慢，这可能会导致轻微的延迟，也许会有一些闪烁。

# 历史插件

`popstate`事件和`pushState`方法是所谓的**历史 API**的一部分，该 API 是在 HTML5 中引入的。这意味着我们的魔法只有在使用 HTML5 兼容的浏览器时才会起作用。当然，这还不够好。仍然有很多人使用 HTML4 兼容的浏览器访问你的网站，所以我们该怎么办？

幸运的是，有几个 jQuery 插件允许你使用相同的或类似的 API，并且让你的代码在两种类型的浏览器中都能工作。其中一个甚至有一个名字会让你再次想起自助餐厅（*BBQ*），但我一直在使用所谓的`jQuery history`插件。在撰写本文时，该插件可以在[`github.com/browserstate/history.js`](https://github.com/browserstate/history.js)找到。

# 书签

让我们从自助餐厅回到我们的市场营销人员，他们想知道他们可以使用哪个 URL 将文档中的链接放入页面，以便人们可以快速访问网站上的信息。也许他们还想了解如果访客使用浏览器的书签功能保存（在我们的案例中，是虚拟）页面的 URL 以便稍后重访，应该怎么做。我们可以通过在`pushState`代码中使用的 URL 部分来支持这一点。

在我们的示例中，我们确保在历史堆栈上推送的状态中存储了足够关于我们更新页面的信息，并且你学习了如何使用这些信息将我们的页面恢复到其之前的状态。在我们的`pushState`代码中，我们在 URL 上附加了一个查询字符串，它基本上包含了相同的信息。我们可以使用浏览器的`location`对象及其`href`属性来检索这些信息。以下是如果使用带有查询字符串的 URL，将使我们的单页网站进入预期状态的代码：

```php
$(document).ready(function(){
var url = location.href;
  if (url) {
  var urlData = url.QueryStringToJSON();
    if (urlData.anchor) {
      var anchor = urlData.anchor;
      var topic = urlData.key;
      switch (anchor) {
      case "agenda":
       updateAgendaContent(topic);
       history.pushState({key:topic, anchor:anchor}, topic, url);
       break;
      }
     }
  }
});
```

注意，我们已经走得很远了。在几章之前，我们可能会猜测这只能在包含 GET 变量的大量 PHP 代码中实现，以获取我们的键/值对，但现在这完全是使用 JavaScript 和 Ajax 编写的。

在前面的例子中，使用了一个名为`QueryStringToJSON()`的函数。这不是一个标准的 JavaScript 函数。这是你可以自己编写的，或者像我一样，从网上抓取的。它分解查询字符串并将键/值对存储到 JSON 对象中。是的，JSON！关于 JSON 的内容你将在下一章学习。

# 摘要

在本章中，我们讨论了使用 Ajax 的主要缺点之一。你学习了如何使用 HTML5 历史 API 在访客按下浏览器后退键或将他们之前书签的 URL 拖入浏览器地址栏时创建预期的行为。尽管这个 API 是为 HTML5 兼容的浏览器设计的，但你学习了有 jQuery 插件可以支持 HTML4 兼容的浏览器中的这种魔法。

在最后几章中，我们开始更频繁地使用 Ajax 来仅更新屏幕的一部分，并保持在同一页面上而不是加载新的一页。因此，我们在客户端和服务器之间交换的是更小但更频繁的数据块。到目前为止的示例中，我们数据的形式是 HTML，并且所有内容都是在服务器上生成的。在下一章中，你将学习两种新的数据交换格式：**XML**和**JSON**。
