

# 第六章：PHP 正在发展——弃用和革命

我们做得很好。PHP 社区做得很好；我们很幸运。的确，PHP 在过去的几年里一直在非常强烈地发展。但这种强烈的演变并不是一直存在的。这主要是因为 PHP 6 开发期间的问题，这也是为什么这个版本从未发布的原因。这也解释了为什么许多项目（现在仍然如此）卡在 PHP 5 上。

PHP 7 彻底清除了旧账，为这门语言带来了真正的复兴。此外，它就像一股清新的空气，将语言推向了新的境界。

PHP 从几乎是一门死去的语言发展成为一个正在迎头赶上并面向未来的语言。在本章的最后，我们将专注于以下内容，这是专门针对清洁代码理论的：

+   PHP 与其过去版本的不同之处

+   这些变化将如何帮助你成为一个更加严谨和更好的开发者，而不仅仅是 PHP 开发者

+   PHP 最新版本中的主要新特性是什么

# 旧 PHP 与新 PHP

多年来，PHP 可能已经帮助你成为一个更加严谨的开发者。如果在 PHP 存在的最初几十年里，PHP 允许你按照自己的意愿编写代码，而不对你进行任何限制，并且只带来（非常）少的优势，那么从后视镜来看，这主要是提供了尽可能多的编写代码的方式，就像有尽可能多的开发者一样（这很少能产生卓越的结果），这使得它变得流行。正如我们现在所知道的那样，这可能是无穷无尽的和地狱般的调试 bug 的源头。幸运的是，在过去的几年里，语言的演变已经修复了许多这些 bug，这对我们的应用程序来说是一大好处。

## 严格类型

首先，让我们看看从 7.4 版本开始的新版 PHP 中最重要的一些特性之一——属性的严格类型。

曾经，你可以随意将任何数据传递给任何变量，并且可以随意将变量转换为任何类型，而没有真正和原生的方式来阻止这种行为——例如将数组变量转换为字符串，将字符串转换为整数等。这可能会非常令人困惑，并且可能是许多问题的源头。例如，如果你将一个字符串乘以一个整数，会发生什么？嗯，结果是完全出乎意料的。这不像 Python 那样管理得很好，在 Python 中，这类操作是允许的，但受到很好的控制。如果你的 PHP 代码依赖于弱类型的能力，那么你的代码架构可能存在问题，你必须绝对审查需要这种弱类型的部分。

PHP 现在允许在某些情况下严格类型化变量。从 PHP 8.1 开始，如果变量不是类属性或方法参数，则不能对其进行类型化。话虽如此，你应该对所有类属性和方法参数进行类型化——这样可以减少混淆，增加严谨性。你可能需要重新思考代码的一些部分，但你会得到更干净、更易于理解的代码的好处。由于意外的类型转换，运行时不会出现任何意外。如果你真的需要将任何类型的数据传递给方法，你仍然可以依赖 `mixed` 关键字，它告诉 PHP 这个变量可以是任何类型的数据，或者方法可以返回任何类型的数据。当然，如果你能避免这种情况，就避免使用它，并且只在非常精确的情况下使用它（例如接口方法定义，其中接口的实现可以返回几种类型的数据）。

## 错误报告

PHP 8 默认显示弃用和更严格的错误。在 PHP 的早期版本中，错误报告级别较低。随着这一变化，你将能够更容易地看到需要关注弃用的地方，例如。当你需要操作 PHP 版本升级时，你会感谢这一变化。如果你在弃用出现时立即着手修复它们，升级到另一个版本的 PHP 将会变得容易。此外，几乎总是有一个来自弃用的消息，告诉你如何精确地修复它。尽早处理这些错误，特别是弃用，绝对是一个明智的选择，并使你养成干净代码的思维模式。

## 属性

源代码中的注释是为了更好地理解复杂的代码部分而发明的。这意味着如果我们从源代码中移除所有注释，它应该也能完美运行，因为编译器和解释器不应该考虑注释。这就是源代码注释被发明的主要原因和*第一个原因*。

然后，创建了注解。逻辑和机制被引入到注释部分。请别误会——注解非常实用。你可以在需要的地方和需要的时候获得有关元素的所有信息和元数据。但当你这么想的时候，它似乎是一种异常。而且记住我们在前面的章节中说过的话：如果你编写干净的代码，那么你几乎永远不需要写一行注释，或者最多只有几行（编写复杂的代码部分是无法避免的，即使是最好的干净代码编写者也不例外）。

属性自 PHP 8.0 版本以来一直是 PHP 语言的一部分。简单来说，属性与注解具有相同的作用：为不同的元素添加元数据，包括类、属性和方法。不同之处在于它们使用另一种语法，这不是用于注释的类型。除了更好的可读性之外，注释将回归其最初用途：提供*信息*。在实例中，你可以立即区分元数据（用属性描述）和注释，以更好地理解你正在工作的代码部分。

让我们看看属性的样子：

```php
<?php
namespace App\Controller;
class ExampleController
{
    public function home(#[CurrentUser] User $user)
    {
        // ...
    }
}
```

很明显，当前登录的用户很可能会被注入到 `$user` 变量中。代码看起来很锐利，我们有了所有需要的信息来一眼看出正在发生的事情。如果我们需要在 `home()` 方法上面的注释部分添加信息，我们也有一个完美的空白空间。你现在可以清楚地看到属性如何帮助你更加严谨——移除所有注释块，在添加新的注释之前三思。

从版本 8.0 开始，PHP 的最新版本中显然还有很多事情在发生。以下是一个非详尽的列表：

+   联合类型

+   匹配语法

+   命名参数

+   枚举

+   JIT 编译器

+   纤程

+   数字分隔符

让我们在下一节中看看其中的一些。

# 第 8 版革命

正如我们所见，PHP 在过去几年中经历了非凡的势头。虽然我们认为版本 7 是语言的真正重生，但版本 8 证明这只是开始。以下是一些主要的新特性，这些特性将帮助你编写清晰简洁的代码，并帮助你进一步推动我们在这些章节中看到的清洁代码原则。

## 匹配语法

匹配语法是经典 `switch/case` 的简略版本。它不应该到处使用，因为它可以很快变得难以阅读。然而，如果你选择谨慎使用它的地方，你的代码可以立即变得更加清晰。以下是一个匹配语法的示例：

```php
$foo = match($var) {
    ‹value 1› => Bar::myMethod1(),
    ‹value 2› => Bar::myMethod2(),
};
```

它的工作方式与 switch 一样。然而，请注意代码长度和可读性提高的差异。你还可以立即看到这种语法的局限性：如果每个案例有多个要执行的语句，它根本不适应，你面临的结果可能是难以阅读的。因此，坚持更经典的 `switch/case` 块是更好的选择。

## 命名参数

如果你习惯于经常使用其他语言，你可能熟悉 PHP 的这种演变。从版本 8.0 开始，你可以按照你想要的顺序传递参数给方法。这是通过在参数值之前指定参数名称来完成的。

```php
$this->myMethodCall(needle: 'Bar', enabled: true);
```

我们可以快速看到两种情况下这很有用：

+   首先，我们有时会遇到具有很多可选参数的方法，这些参数已经定义了默认值。有时，我们想要更改列表中可能是第 5 个或第 11 个的参数的值。这随后是一个漫长的过程，需要重写所有参数的默认值。这显然不是理想的，但这是一个可以通过使用命名参数解决的问题。你只需指定你想要提供的参数的名称及其值，然后你就完成了。

+   第二种情况是，即使方法没有可选参数，你也可以通过添加清晰度来改进方法调用。如果你的方法有很多参数，你可能想考虑使用命名参数来明确显示你发送给方法的参数。然而，如果情况如此，真正使代码更易读的解决方案是对代码进行重构，这样你就不需要向方法传递这么多参数。这可以通过将方法拆分成几个方法，或者通过创建**值对象**（**VOs**）来实现。这些对象只包含简单的属性，没有其他方法或逻辑，用于在代码中将数据从一个点传输到另一个点。这避免了无休止的参数担忧，并且它还通过强类型属性添加了一层验证，并为携带的数据添加了一些上下文。

## 只读类和属性

这里有一个小谜题来介绍只读类和属性。在一个 PHP 类中，你如何确保一个属性只会被分配一次——也就是说，它只能分配一次值，所有未来的尝试分配它都会失败？请注意，这也适用于类内部的赋值。这意味着在调用中抛出异常的修改器无法工作，因为我们不能 100%确定开发者会在类作用域内通过修改器。

实际上，答案很简单：这是不可能的。如果你使用的是 PHP 8.0 或更早版本，这根本不可能。PHP 8.1 为我们带来了一个原生解决方案来解决这个问题：只读属性。通过使用`readonly`关键字声明类属性，变量只能被赋值一次，无论上下文如何。这特别有用，当定义和使用 DTOs 和 VOs 时。通过限制对这些属性的修改访问，使用它们的开发者将不得不仔细思考对象的使用。如果他们想要进行更改，他们将不得不创建一个新的对象。原始对象不能被修改，这可以保证代码有更好的稳定性和健壮性。以下是声明只读属性的方法：

```php
<?php
namespace App\Model;
class MyValueObject
{
    protected readonly string $foo;
    public function __construct(string $foo)
    {
        $this->foo = $foo; // First assignment, all good
        // Any further assignment of $this->foo will result
          in a fatal error
    }
}
```

自 PHP 8.2 以来，甚至可以通过在 `class` 关键字之前放置此修饰符来声明整个类为 `readonly`，这样你就不必在类包含的每个属性上使用该关键字。这也给你带来了很大的优势：声明为 `readonly` 的类将无法动态地声明新属性。尽管这种行为已被弃用，并且应该不惜一切代价避免（在调试、稳定性和代码复杂性方面，动态声明类属性是一个噩梦），但在 PHP 9.0 版本中仍然可以这样做，如果发生这种行为，将触发致命错误。如果你不使用 PHP 9.0，将你的类声明为 `readonly` 将保护你免受这种行为的影响。

这对于 PHP 开发者来说是一个巨大的进步。确实，多亏了这个特性，我们再次需要越来越严格地对待我们与对象及其属性交互的方式。

## 将资源迁移到适当的类中

根据你在 PHP 中的开发经验长短，你应该或多或少熟悉我们所说的资源。资源是一种特殊类型的变量，它代表了对外部资源的引用。这听起来可能有些模糊，但实际上相当简单。资源可以是以下内容，例如：

+   打开的文件

+   数据库连接

+   cURL 调用

+   连接到 LDAP 目录（通常是一种在公司中管理用户账户的方式）

+   用于 GD 图像操作扩展的字体

这已经很好地工作了数十年，但我们理解，术语 *资源* 由于过于通用，尤其是现在在现代代码中类和对象占主导地位，已经不再适用了。为什么这些资源不能像任何其他对象一样简单呢？好吧，至少目前没有特别的理由来证明这一点。这就是为什么 PHP 8.0 开始了一个漫长但必要的迁移过程，将旧资源转换为完整的类。这样做更有意义。

资源的使用很复杂。它们难以调试，并且理解它们的工作方式和内部状态也很复杂。它们只能通过处理资源的特殊函数来调用。这对于将会有更多控制和更多工具来提高开发严谨性和代码健壮性的开发者来说是一个巨大的进步。

随着新版本的 PHP 发布，这种变化被实现。例如，PHP 8.0 内嵌了以下资源的迁移：

+   GD，用于图像操作

+   `cURL`

+   OpenSSL

+   XML

+   Sockets

相反，PHP 8.1 内嵌了以下资源的迁移：

+   GD 字体

+   FTP

+   IMAP

+   finfo，用于文件管理

+   Pspell，用于拼写检查

+   LDAP

+   PostgreSQL

以下版本的 PHP 继续执行相同的任务——最终移除标准 PHP 库中资源的使用。此外，自 PHP 8.1 以来，核心 PHP 开发者决定在命名空间下创建一些这些类。我们可以看到，经过长时间的滞后，这种行动和开发使得语言努力恢复其声誉。PHP 清楚地表明：这种语言将长期存在。

## 保护你的敏感参数不被泄露

如果你已经用 PHP 开发了一段时间，你肯定知道有很多种方法可以显示变量或函数参数的内容。特别是你可以想到`var_dump`和`print_r`。还有其他场合可以显示参数及其值：当显示堆栈跟踪（或调用堆栈）时。这可能是通过手动调用`debug_print_backtrace`等方法，也可能是抛出异常时，这种情况很常见。无论如何，如果变量或调用堆栈中的方法调用参数包含敏感信息，这可能会成为问题。你可能认为这种情况只发生在开发环境中，但这是一种错误。你很可能在服务器（们）上的某个地方编写了异常消息到错误日志中。这可能导致敏感信息显示在你的日志中。这显然是不推荐的。敏感信息不应在任何地方以明文形式写入。此外，尽管这是一个错误，但应用程序日志的安全性通常不如数据库，例如。此外，项目中的许多开发者（如果不是所有开发者）都可能有权访问这些日志以调试应用程序。威胁并不总是来自外部。

幸运的是，PHP 8.2 包含了一个新的属性来解决这个问题。确实可以在任何函数参数之前指定`#[SensitiveParameter]`属性。这将告诉 PHP 不要在`var_dump`、堆栈跟踪等中显示参数值。如果巧妙地放置，你就可以确保不会在错误消息中泄露敏感值，例如。实际上，网站直接在前端显示服务器错误并不罕见。显然，这应该尽快被禁止，但至少它有助于限制损害。让我们看看这个新属性如何使用：

```php
<?php
namespace App\Controller;
class SecurityController
{
    public function authenticate(string $username,
      #[SensitiveParameter] string $password)
    {
        // In case of any exception occurring or var_dump
          being called in here, the value of $password will
          be hidden in the different outputs
    }
}
```

在 PHP 的内部工作原理中，此属性将用类型为`SensitiveParameterValue`的对象替换参数，这将隐藏参数的真实值。参数将在输出中显示和存在，但其值将被隐藏。将此属性添加到你的敏感方法参数中是一种聪明且受欢迎的方法，可以增加代码的严谨性并使其更具抗攻击性。

# 摘要

无论如何强调都不为过：PHP 正在以最美好的方式发展，并在网络世界中迎头赶上其竞争对手。该语言通过提供社区和开发者需要的工具，以最可行的方式解决现代问题，倾听他们的声音。

我们已经从一个允许一切、对当今网络应用挑战非常（过于）宽松的语言走了很长的路。尽管前端框架和技术爆炸式增长，旨在用面向前端的语言（如 Node.js 和 JavaScript）取代服务器端语言，但 PHP 没有任何可耻之处。它令人印象深刻的性能、其快速的发展速度以及多年来建立的名誉都表明，它面前还有光明的未来。

尽管如我们所见，干净的代码是一种心态，在某种程度上是一种哲学，但语言本身的原生解决方案正在大量涌现，帮助我们尽可能好地应用它们。更好的是，这些引入 PHP 的新特性使我们能够看到一些我们最初可能没有想到的新可能性，以使我们的代码更加健壮、可维护和长期可行。只需想想命名参数、只读类和属性、严格类型，或者简单地回顾一下本章最后讨论的主题：保护敏感参数不会泄露到应用程序日志和异常消息中。

话虽如此，现在是时候开始着手工作了。我们将从查看能够快速、定量地概述您代码质量的工具开始。这类指标的拥有使您能够看到您将如何改进代码，或者是否真的到了采取行动的时候，因为随着您的发展，质量正在下降。那么，让我们进入下一章，本章将重点介绍针对 PHP 语言的代码质量工具。

# 第二部分 – 维护代码质量

第二部分的目标是让您能够不断改进您的项目，并最终保持代码质量的一致高水平。它将为您提供使用最先进工具和技术方面的指导，这将有助于减少实现这一目标所需的努力。最后，我们将介绍一些最佳实践，这将帮助您与其他开发者一起在干净且可维护的代码库上协作。

本节包括以下章节：

+   *第七章*, *代码质量工具*

+   *第八章*, *代码质量指标*

+   *第九章*, *组织 PHP 质量工具*

+   *第十章*, *自动化测试*

+   *第十一章*, *持续集成*

+   *第十二章*, *团队合作*

+   *第十三章*, *创建有效的文档*
