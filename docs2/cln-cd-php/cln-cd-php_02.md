

# 谁有权决定“良好实践”是什么？

良好的实践固然很好，但了解谁决定它们以及它们从何而来则更为重要。当你完全理解自己在做什么时，你会立刻感到更好、更自在，这一点同样适用于良好的实践。你为何要无条件的相信那些你并不了解且从未与你合作过的人所决定的这些原则呢？

你可能会说，制定这些原则的人比你有更多经验，并且比你更了解这个世界。两点。首先，也许有一天你的经验会比他们多。也许你会做得更好。也许你已经做到了。其次，多年的经验并非一切。我们经常看到有 20 年或 30 年经验的开发者，他们完全过时或有着上个世纪的习惯。多年的经验可以是一个论据，但不是唯一的论据。计算机发展速度极快，而网络世界更是受到这种影响。

在本章中，我们将一起探讨最佳实践的起源：它们真的是由一个精确的小组发明和决定的吗？你现在就可以应用到你的项目中的不同现有清洁代码原则有哪些？一旦你了解了它们，你的思维方式可能会改变。

本章我们将涵盖的主要主题如下：

+   谁来决定这些事情呢？

+   最佳实践——它们真正从何而来？

+   保持情境意识

+   保持一致性——更快地获得结果

# 谁来决定这些事情呢？

我们将要看到的一点是，你应该始终质疑“良好实践”，永远不要将它们视为一个你必须尊重而不理解其为何的普遍真理。当你不同意某人的评审或观点时，询问是一个提升自己的极好方式。开发者们非常迷人，因为他们可以找到无限种解决同一个问题的方法——为同一个结果提供无限种解决方案。即使这有时可能看起来有点累人，但了解为什么开发者想要以与你不同的方式解决问题总是很有趣的。这有几个目标，如下所示：

+   **你会提高你的沟通技巧**：如果你想进行沟通并被理解，你必须清楚地解释你的问题。

+   **你可能会学习到做事的新方法**：我们都在使用同一种语言，但我们每个人都有不同的使用经验。这些不同的职业和生活道路可以为会议带来极好的想法。

+   你正在加强与这位开发者的关系，这将使得未来讨论更多主题变得更加容易。

+   你正在提高你的团队合作技能，并且对话中的所有参与者都在相应地提高他们的技能。

这确实是一个相当长的列表。许多软技能仅仅通过与其他开发者讨论解决特定问题的方法就能得到提升。能够清楚地解释一个情况比看起来要困难得多。

这也是为什么你应该总是在你不同意某人的观点时要求进一步解释的原因。首先，可能存在对暴露问题的误解。这是一个常见的多方面意见不一致的情况：问题一开始并不明确。每个方面都在试图证明他们理解的内容。你可以很容易地想象这会带来多大的混乱。

成为一名优秀的开发者（也）意味着能够证明和解释你所有的选择。不再有：“我们总是这样做；没有其他理由这样做。”当你决定或告诉某人遵循某些指南时，你必须始终能够清楚地证明和解释为什么你的方式对你来说是最好的。这可能不是客观上做这件事的最佳方式，但如果你能够解释为什么它最适合你，这将使你看起来更加开放。

话虽如此，你现在可能已经明白我们想要表达的意思了：没有人掌握绝对的真理。如果有人足够自信地说出这一点，你应该始终保持警惕。

# 最佳实践——它们真正来自哪里？

当我们谈论“最佳实践”时，我们可以区分三种情况，如下所示：

+   **经过几十年证明有效的原则，这些原则也源于常识**：在这个类别中，例如我们可以找到设计模式。简而言之，如果你不知道它们，这些是解决重复编程问题的工具。它们已经存在了几十年，并且被数百万开发者所熟知。

+   **因为我们不得不做出的选择**：在这里，我们可以找到诸如代码风格、命名约定等等。从技术上讲，如果你想要使用*camelCase*或*snake_case*来命名你的文件，这并不重要。但如果每个人都遵循相同的规则，那么每个人理解彼此会更容易。

+   `get`、`set`、`is`等等。如果每个人都对命名访问器和修改器有自己的规则，你可以确信总有一天，没有任何警告，事情会失控。

## 设计模式原则

设计模式案例描述了解决问题的客观解决方案。你可能不喜欢它们以及它们如何组织代码，但你不能说它们在客观上是不好的。因为你的想法并不重要，它们是有效的。

讨论了几十年一直存在的原则，我们可以突出四个著名的：**DRY**、**KISS**、**YAGNI**和**SOLID**。

### DRY

**DRY**代表**不要重复自己**。这个原则简单地说，你永远不应该在你的应用程序中有两个权限做完全相同的事情。这听起来可能很显然，但应用这个原则可能并不总是本能的，尤其是当你刚开始应用编程时。在代码的两个不同地方有相同的责任意味着每次你修复某事时都要维护这两个地方。这意味着每次更改时都必须考虑这两个地方（而且肯定有一天你会忘记其中一个）。此外，如果两件事有相同的责任，任何开发者如何维护你的源代码才能知道该使用哪一个呢？

### KISS

**KISS**代表**保持简单，傻瓜**。有时，我们会使自己的生活复杂化。我们可以看到有两个主要原因，如下：

+   首先，我们试图用我们的代码做复杂的事情，但这些花招并没有带来任何有价值的东西，反而使代码复杂化。我们将在本书的后面详细说明为什么我们绝对需要避免这样做。

+   第二个原因是缺乏对我们所做的事情的视角。我们花费了很多小时试图解决问题，我们太“投入”了。一些休息是必要的，以获得这种视角，有时甚至需要从头开始。

这两种情况都是常见的，阻止我们直接切入要点并保持简单。当你觉得你“走得太远”时，想想这个缩写词，以便回到正轨。

### YAGNI

**YAGNI**代表**你不需要它**。在某种程度上，它与 KISS 原则相辅相成。想要通过考虑未来来找到问题的解决方案是很常见的（不用说，这是开发者日常生活的部分），我们经常有这样的想法：“如果明天我需要做这样或那样的事情，至少这已经准备好了。”现实是，总的来说——不会——我们永远不会需要我们想要预见的需求。然后，试图提前完成一个可能永远不存在的任务，并且其功能约束是未知的，不仅浪费时间，而且通过过于前瞻性的思考使我们的生活复杂化。我们偏离了最初的目标，即找到快速、可行和健壮的解决方案。

我们不是先知，无法预知预测的任务会出现所有问题。你很快就会意识到，如果你保持简单，不添加任何多余的代码来试图领先于明天的需求，你将拥有一个健康、无装饰的代码库。这意味着更快地理解代码，更容易在其中导航，并在真正需要时进行更改。此外，你可能会节省很多错误。如果因为你在源代码中开发并花费时间在未要求的事情上而造成错误，那么总是很复杂（如果不是不可能的话）来证明这个错误。如果你的工作作为开发者需要你直接与客户合作，你应该知道客户不会为你没有要求的事情付钱。你将免费工作，这从来不是理想的情况。

**注意**：显然，我们必须根据每个案例来处理。我们可以以*魔法数字*为例。魔法数字是常量值，主要是数字，硬编码且没有任何解释其含义。

**结论**：两周后，每个人都忘记了这个数字代表什么。然后我们会考虑使用命名良好的代码常量。然而，有很大可能性这个代码常量的值永远不会改变，因为需求已经发生了变化。乍一看，想要声明一个常量并在所有地方使用它似乎很奇怪。代码常量的目的是为固定值添加语义，并允许我们轻松地在代码中任何使用该值的地方一次性更改它。这在某种程度上与 YAGNI 原则相悖（因为这些值可能永远不会改变）。

然而，我们可以看到使用常量的价值。无论应用了哪些清洁代码原则，视角和反思总是必要的。

### SOLID

最后，可能是最著名的一个，**SOLID**。让我们看看这些字母代表什么：

+   **S** 代表 **单一职责原则**（通常缩写为 **SRP**）。非常简单地说，这意味着你的代码中的类必须只响应一个任务。显然，这个任务的大小是这里的关键点。我们不是在谈论创建一个只有一个可用方法的类。而是在谈论创建一个逻辑分解。一个非常具体的例子是 **模型-视图-控制器**（**MVC**）架构。重要的是要记住，你必须避免有万能的类，将数据库操作、**超文本标记语言**（**HTML**）渲染、业务逻辑等组合在一起。分解必须是逻辑的。分解的一个例子可以是用于生成 HTML 的类，用于特定对象的数据库交互的类，等等。

+   `if`和`else`语句。确实，如果你使用条件分支，你将修改类，如果你有超过两个情况，这可能会很快变得难以管理。通过扩展类并重载你感兴趣的方法，你可以得到简洁的代码，很好地分割，并且没有数百行的分支。

+   如果`foo`方法和另一个实现返回一个对象，这将变得复杂）。幸运的是，返回值的类型在 PHP 的最新版本中存在，限制了违反此原则的可能性。

+   `null`值。当你这样表达时，你会意识到这听起来并不像非常“干净的代码”。

+   最后是`MailerInterface`接口。这样，你将为每种邮件服务有一个实现。通过使用接口的参数，该方法能够接收任何实现，并为你当前的情况使用正确的电子邮件服务。

我们可以很快地意识到这些原则之间有着非常紧密的联系。它们共同工作，并在你编写代码时考虑到这些原则，允许有强大的解耦、责任分离和流畅的思维。记住这些原则可能非常有帮助；至少，了解它们的存在是一个特别好的事情。除了 SOLID 原则外，你还可以看到 KISS、DRY 和 YAGNI 都是非常直观和逻辑的。时不时地记住它们可能有益，并有助于我们在稍微偏离轨道时设置障碍。

### 奖励 - 指导员原则

还可以添加的是，这也是一个常识性原则，即“指导员原则”。我们都知道那些有善意的年轻人和青少年群体，他们表现出极大的利他主义。指导员在树林里露营，生火，并在那里过夜。一旦他们早上起床，他们可能会熄灭火焰并收拾东西，但最重要的是，他们会清理这个地方，使其比他们到来之前更干净（至少，在理论上）。

作为一名开发者，情况也是一样的。成为一名指导员。在探索和浏览代码时，如果时间和环境允许，清理你看到的一些技术债务通常是一个特别聪明的想法。如果你正在遍历代码库中的地方，并想“这真的很糟糕”，这可能是一个机会使其更易于管理和更干净。如果每个人都参与进来，项目的源代码质量可以迅速提高。

当然，这个“童子军原则”必须符合你的项目约束、时间约束和客户需求。此外，这相当有风险，你必须知道何时停止。当你将你的更改发送给团队进行审查时，你所做的更改和清理必须保持一致。你不想每次发现一点小问题就重写一半的应用程序，这会导致另一个问题，然后又是另一个，以此类推。这更多的是关于清理与你所做事情相关的事情。保持专注并固定在你的环境中可能会非常复杂。关于“何时停止”没有真正的答案；这将很大程度上取决于你拥有的时间和你的任务。然而，没有什么可以阻止你写下你想要回来但不幸地与你的工作无关的事情，这些事情似乎太耗费精力和时间，或者需要与团队进行进一步的反思。

相反，代码风格、命名约定和类似的事情都是主观的，取决于个人品味和习惯。每个人都有自己的品味和习惯，所以需要做出决定。正如我们之前讨论的，当我们都遵循相同的规则时，一起讨论要容易得多。

那么，谁决定团队或组织中的最佳实践呢？嗯，通常情况下，这是在项目开始时关于该主题长时间讨论后的共识。因为是的——“最佳实践”并不是你可以在任何地方都适用的东西，你应该意识到这一点。你应该意识到你所处的环境。

# 保持情境意识

在我们讨论清洁代码时，这里是我们进入最重要的部分之一。如果我们只能记住一件事，那就会是这件事。我们可能会经常谈论其他开发者定义的规则、面向对象原则和清洁代码原则，但没有什么会比我们即将讨论的内容更好：这是关于意识到你的情境。许多关于清洁代码的书籍和文章中缺少的是这种感觉，即它与日常生活相关。开发者的生活由意外事件、技术约束、无法完成某些事情或被迫做某些其他事情组成。

做事情的方式和项目一样多。每个项目都有其自己的历史、技术决策和约束。因此，我们最终得到了许多理论原则，这些原则可能不适用，或者会破坏项目的连贯性。良好的实践可能会指导你如何命名变量、如何命名你的类和方法、如何命名你的文件，或者如何构建你的项目树结构。然而，如果这与项目中的设置相矛盾怎么办？这是一个非常常见的问题，尤其是在所谓的“遗留”项目中。

答案既简单又复杂。它之所以简单，是因为可以总结为一句话：与你的团队和其他参与项目的人讨论。这也是答案可能变得复杂的地方，因为它很可能会在团队中引发辩论（有时是热烈的），这是很正常的。但重要的是：你不仅要找到一个大家都会尊重的共识以保持与项目的连贯性，还要找到对你和你的团队最有效的方法。

这可能是所有这些讨论的基础：你可能有一些良好实践和清洁代码原则，但也许有些规则值得调整，因为它们对你和你的团队来说效果更好。这是偏离某些原则（当然不是所有原则，否则就是完全的无政府状态）的一个完全合理的理由。有时，找不到共识，这时最佳实践和其他原则可以占上风，制定出每个人都必须遵守的规则，如果不是对每个人都适用的规则。

这时，我们回到了之前提到的一个观点。在开发者团队中拥有共同规则有助于使项目更容易理解。在项目中的导航，以及文件中的导航都变得更简单。通过使用相同的语言，我们更好地理解彼此。无论是帮助他人还是被他人帮助，总是同一个故事。如果遵守了共同的命名和缩进规则，你不仅可以避免那些会分散你注意力、远离最初目标的枯燥辩论，而且如果你觉得你的队友编写的代码就像你自己的代码一样，那将是一个双赢的局面。

我们可以这样总结决定采用良好实践和“经典”清洁代码原则的选择：

你的情况在项目过去是否已经出现过？

+   *是的*。它是否遵循了你使用的工具（如 *Symfony* 的良好实践）所规定的清洁代码原则和良好实践？

    +   *是的*。在这种情况下，你只需要遵循过去处理这种情况的方式。

    +   *不*。你应该与你的团队交谈，找出原因。可能由于功能和/或技术限制存在历史原因，或者可能根本没有任何原因。在这种情况下，如果你同意，你可以遵循良好的实践（如果你有修改相关代码部分的可能性，并且有时间，可以尊重我们之前讨论的“童子军原则”），。

+   *不*。是否可以应用良好实践和清洁代码原则？

    +   *是的*。太完美了！你只需要尽你所能将它们应用到团队和项目中现有的其他实践之中。

    +   *不*。在这种情况下，你应该与你的团队讨论，也许还应该与项目外有类似经验的人讨论。再次，这些讨论可能需要相当长的时间，而且答案不会总是立即找到。辩论将会被提出，这将是件好事。一旦你找到了共识或进行了深入的讨论，你既可以重新思考清洁代码原则和良好实践的应用，也可以应用团队为这种情况设定的规则。

在这里，我们再次非常清楚地看到，成功的关键将是沟通和辩论。每个人都有自己的观点和解决问题的方法，所以事情永远不会是全黑或全白。但请记住一点：你应该避免就一个可能被辩论的实践单独做出决定。避免单独做出决定并不意味着你不应该做出决定。相反，我们这里的含义是思考选项，权衡每个选项的利弊。再次，*能够为每个你提出的建议提供合理的依据*给项目中的其他人。如果你提供几个解决方案，并很好地解释为什么这些解决方案是合适的，同时也解释了这些解决方案所涉及的风险，你将很快意识到这项工作单独做可能会很复杂，因此与团队讨论其重要性。每个大脑都有其独特的工作方式。

顺便说一下，这一切不仅适用于 IT、清洁代码和 PHP。这就是为什么在上一章中提到，清洁代码不仅仅是一套规则：它是一种生活方式——它是一种思维方式。

# 保持一致性——更快地获得结果

在你所做的事情上保持完美的一致性将迫使你理解你在做什么。然后，一切都将变成习惯。如果你有这些良好的习惯，以至于它们对你来说已经变得自然，那么在以下两种具体情况下，结果将会更快地到来，如下所述：

+   正如我们从一开始就能看到的，你将能够更快地在团队内部相互理解——开发者将拥有相同的习惯。更少的情况下，但这种情况可能发生：你有时可能需要与项目中的非技术人员讨论代码或展示事物。尽管这些人——例如产品负责人——可能有一些基本的技术知识，但最好假设你需要回到最基本的基本知识。如果你在工作中的事情简单、干净、毫不犹豫，你将更容易向非技术人员解释复杂和技术的主题。

+   第二种情况是在自动化检查期间。自动化检查是已经与团队设置和讨论过的任务，每次你想提出更改时都会执行。这些检查可以在多个地方进行。它可能是在你编写代码的软件中（如 NetBeans、PhpStorm 或**Visual Studio Code**（**VS Code**）），通过**持续集成**（**CI**）工具（GitHub Actions、GitLab CI/CD）等。

自动审计任务可以包括你想要的任何任务。我们将在本书的*第七章*（*代码质量工具*部分）中详细介绍如何执行这些任务（第七章*,* *代码质量工具*），但这里是最常见的几个：

+   检查代码样式和缩进

+   运行测试套件（单元测试、功能测试…）

+   对你的代码进行静态分析，以确保你使用的变量定义良好，使用正确的类型等

+   通过选择一个渠道（如电子邮件、即时消息如 Slack 等）设置警报，以通知你任务的成功或失败

+   将代码部署到测试环境

+   安装依赖和供应商

+   将文件复制到服务器并进行一些远程操作

+   无论你想要什么！

你明白了。这些工具允许你执行你想要和需要的任务。实际上，它们只是执行你定义的命令的协调者。就这么简单。之后，如果你的命令很复杂，那就另当别论了。但你意识到这些自动化检查可以无限扩展。

## 关于源代码分析工具

通过养成良好的代码习惯，你肯定会加快这个过程。也许最具体和有说服力的例子是样式代码检查。如果你不知道如何在你的团队中编写代码，并且你的团队对你想要更改的每一项内容都设置了自动检查，你可能会花几个小时来找出一个地方缺少了一个空格，另一个地方缺少了一个换行符，等等。不用担心——大多数工具都提供自动纠正这些错误的选择。

然而，静态分析工具的情况并非如此，例如我们将在关于静态分析工具的章节中设置的工具，第七章*代码质量工具*。实际上，静态分析将审查你的代码，并确保不会犯最常见的错误。我们不是在检查你的制表符中的空格数量，而是在真正解析 PHP 代码，试图理解它并确保一切井然有序。这些工具有时可能会过于严格，正确理解它们可能需要花费大量时间。此外，这些工具并不完美，静态分析工具可能无法理解你的意图。尽管这是一个单独的问题，但如果你在源头处理它，你会省去很多麻烦：培养良好的编码习惯。要彻底，不要留下任何侥幸心理。PHP 是一种非常宽松的语言，允许你用变量做几乎所有的事情——例如，允许你在不皱眉的情况下进行类型转换。正如我们所知，这类操作的结果可能是随机的，甚至非常令人惊讶，看起来完全不合逻辑。无论如何，PHP 就是 PHP。尽管静态分析工具大多数时候可以识别这些风险案例，但你可能需要花费数小时来纠正这些可能迅速增加到数十的小问题。

此外（这可能听起来很傻），通过实施清洁代码实践和随之而来的内容，你的代码越干净，你实现的错误就越少。通过自信，你可以避免很多惊吓。此外，你还允许未来的开发者在你代码上工作时不会受到欺骗，并使他们的工作更容易。如果你足够幸运（或者如果你已经应用了清洁代码及其相关原则！），你将拥有确保应用程序正确运行的测试。也许你对测试不太熟悉，所以让我们一起来了解一下。

## 关于测试及其多种形式

测试主要是开发者编写的代码行。这些测试确保对于某些输入数据，会返回特定的输出。这些**输入和输出**（**I/Os**）可以是各种类型和大小。它可以是一个整数，也可以是一个生成的 HTML 页面，甚至是一张图片。为了使事情更容易，并简化概念，自动化测试通常被分为三个主要类别，如下所示：

+   单元测试，这是粒度最细的测试。它们通常评估代码中方法的返回值，而忽略它们周围的一切。重要的是函数返回的结果，仅此而已。

+   功能测试具有中等粒度。它们将评估完整的功能，其中可能涉及多个参与方和方法。最明显的例子是对**应用程序编程接口**（**API**）的测试：我们检查如果我们用特定的参数调用一个特定的**统一资源定位符**（**URL**），API 是否会返回预期的结果。

+   **端到端**（**E2E**）测试是最难维护的。这些测试通常会模拟一个网络浏览器，并由自动控制。一个经典的例子是登录表单的测试。机器人会自动填写字段，点击按钮，确保我们被重定向并且 HTML 页面上有成功消息，等等。

所有这些测试都存在一个特定的原因：非回归。

没有疑问，非回归测试是能保住你在公司中作为开发者的位置的事情。好吧——这可能有点夸张。然而，我们不能统计有多少应用程序得益于它。当你的测试覆盖率足够高（被一个或多个测试覆盖的代码行和特性的比例）时，你几乎可以修改任何东西，并且如果测试总是*绿色*的，你就可以确信永远不会破坏任何东西。确实，你可以打破特性以用不同的方式重写它们并测试新的做事方式。只要测试是绿色的，你就可以确信应用程序的行为是正确的，就像你修改之前一样。当然，还有其他一些因素需要考虑。

首先，测试必须测试某些东西。这听起来可能有些奇怪，但实际上，你最终会得到很多实际上并没有评估任何东西的测试。最典型的例子是一个类中设置器和获取器的单元测试。当你为这些编写测试时，你是在评估一个变量赋值是否完成以及一个方法调用是否完成。你是在测试... PHP！而 PHP 已经有了自己的测试。编写相关的测试本身就是一本大书，并且是一种可以在多年中掌握和精炼的艺术。为此，没有什么比反复练习更好的了。

当你修改应用程序时，需要考虑的第二件事是，你设置的测试已经不再是最新的，必须进行修改。有时，可能很难理解一个测试是自愿失败（即，它与你的更改不兼容）还是无意中失败（因为当它应该以与之前相同的方式表现时，应用程序没有这样做）。这完全取决于你的情况。记住一件事：如果你的应用程序被正确测试，你可以在任何时候，毫不犹豫地更改任何代码行并部署你的应用程序，即使闭上眼睛也可以。这很令人感兴趣，不是吗？

现在你已经看到了测试在你应用程序中的好处，我们可以讨论一个在清洁代码实践中相当常见的做法。你可能已经听说过它：TDD（测试驱动开发）。

**TDD**代表**测试驱动开发**。这是一种在编写其余代码之前先编写测试的方法。一开始，它非常令人困惑。理解它是如何发生的，甚至是否可能，都很复杂。它涉及到逆向思考和质疑我们的思维习惯，尽管原则本身相当简单。首先，我们考虑测试——也就是说，我们将要发送的数据（到单元测试中的方法，到功能测试中的 API 端点等），以及我们想要的输出（单元测试中的精确对象或值；例如，在 API 功能测试中的精确**JavaScript 对象表示法**（**JSON**）返回值）。显然，因为你还没有编写其余的代码，所以所有测试都会失败。这是故意的。现在的目标是让这些测试一个接一个地变为绿色。

如果你尝试这种实践，你会意识到一种魔法般的事情在不经意间发生了。你会以你最初绝不会这样做的方式组织你的代码。它将被切割成清晰而精确的方式，以便你的测试可以尽可能快、尽可能容易地通过。除了将带来的非凡的智力满足感之外，你最终会得到更易于阅读和更干净的代码。而且（与普遍的信念和直觉相反），开发速度会更快。确实有一个适应期，让它变得相当自然，你可能会觉得一开始进展非常缓慢。然而，正因为如此，你的代码更简单，因此编写、理解、适应和扩展的速度更快。你必须尝试它来体验这一点，因为它听起来可能有点神奇。实际上，它确实在某些方面是神奇的。

此外，随着你的开发，代码覆盖率会越来越广泛。这直接影响了你应用程序的维护，正如我们之前所说的：你将更有信心修改你的代码，以及所有将不得不阅读和修改它的人。测试将保护你。作为额外的好处，阅读测试对于理解复杂代码非常有价值。通过阅读测试，你可以从给定的 I/O 中了解编写测试的开发者想要去哪里。在大多数应用程序中，尤其是遗留应用程序中，这是无价的。此外，许多开发者在审查你的代码时首先查看测试。当你进入某个代码库的更改时，这是一个惊人的切入点。把你的测试看作是证明你刚刚所做事情真正工作的唯一方式。这是一个现实：大多数对干净代码敏感的开发者认为测试是证明你的更改工作的唯一有价值的证据。

例如，可以注意到，对于大多数（如果不是所有）像 PHP 这样的开源项目，在做出更改时你必须添加测试。无论是添加新功能还是修复问题，测试将是强制性的，你的更改在没有测试的情况下永远不会被批准。这些测试将再次成为你新功能行为或你确实修复了所讨论的 bug 的不可辩驳的证据。所有这些工作都是很多，但有了这些，代码覆盖率变得巨大，你完全为软件的稳定性做出了贡献。

测试对于你代码的质量和获得结果的快速速度都是无价的。多亏了它，你将保持一致性，并且会更快地得到结果。

# 摘要

我们刚刚一起学到了很多新知识。如果你理解了它们，你可以确信你已经比上一章的你自己成为一个更好的开发者了。

了解 SOLID 原则在专业领域和工业级项目中是一项真正的资产。即使每个案例都不同，每个项目都有其特殊性，但这些原则的优势在于几乎适用于任何地方，至少是受到了极大的启发。

记住 KISS、DRY 和 YAGNI 原则将帮助你保持脚踏实地，在接下来的开发中不要过于分散精力。它们强调思考当下，以帮助为未来做准备，而不是试图适应当下而思考未来。你绝对应该记住这一点。我们不知道未来将对我们施加的技术或功能限制，因此考虑如何使处理这些限制更容易更有意义，而不是猜测它们。因为说实话：我们几乎没有击中靶心的机会。

如果你有机会和可能性，在 TDD 策略中实施“童子军原则”可以带来更多的好处，并且始终是一个极好的主意。如果你从未实践过 TDD，尽管本章提供了解释，但对其有用性和——尤其是——其有效性感到完全怀疑是很正常的。这是正常的，我们都有过这样的经历。然而，结果就在那里，关于这个主题所进行的各种案例研究都证明了这一点。可能是时候尝试这种做事方式了，这种方式得到了清洁代码资深人士的高度认可和赞赏！

尽管如此，我们必须记住，干净代码也关乎适应其环境。这并不是一个完全重写应用程序并改变开发团队所有习惯的问题，理由是项目外的人决定这样做。你必须意识到你的环境，并处理你的环境。你必须能够适应需求和周围的环境。这就是让你成为一个优秀的“干净程序员”的关键。记住，当感知到习惯的改变时，尽可能与你的团队沟通，并能够证明你所有选择。如果可能的话，始终提出几个解决方案，以及每个方案的优缺点。

在所有这些理论之后，我们可以继续进入一个稍微更实用的部分。编写干净代码的方法有哪些？代码的目的是什么？尽管我们已经看到了一些高级原则，但我们不应忘记基础知识，同时也应该质疑我们已知的内容。
