

# 组织 PHP 质量工具

在最后两个章节中，你学到了很多关于质量指标及其测量方法的知识。你肯定会在未来的工作环境中使用一些工具，并且这些工具如果无缝集成，你甚至不需要再考虑使用它们。

因此，在本章中，我们将向您展示如何以最有效和最有帮助的方式组织这些工具，以便在您的日常工作中使用。这包括以下主题：

+   使用 **Composer** 安装代码质量工具

+   将代码质量工具作为 `phar` 文件安装

+   使用 **PHAR 安装和验证环境**（**Phive**）管理 `phar` 文件

# 技术要求

如果你遵循了前两个章节中的示例，你不需要安装任何其他东西。如果没有，请回到那些章节，首先安装所有必要的工具。

所有代码示例都可以在我们的 GitHub 仓库中找到：[`github.com/PacktPublishing/Clean-Code-in-PHP`](https://github.com/PacktPublishing/Clean-Code-in-PHP)。

# 使用 Composer 安装代码质量工具

大多数 `require()` 或 `require_once()`。如果包版本之间存在冲突，你必须自己解决这些问题。

Composer 通过解决这些问题极大地简化了这些工作。它引入了一个名为 `require()` 的中央仓库，仅用于导入 Composer 的自动加载器。

所有这些特性帮助 PHP 与其他网络语言（如 Python 或 Ruby）竞争，如果没有它，PHP 可能不再是今天在 **万维网**（**WWW**）上最广泛使用的语言了。因此，我们想在本书中给 Composer 应得的篇幅。在本节中，我们将向您展示最常用的安装方法。此外，我们还将探讨在项目中使用 Composer 的另一种不太为人所知的方法。

## 使用 require-dev 安装代码质量工具

在过去的章节中，我们已经多次使用 Composer 安装工具，所以到现在，你应该已经熟悉了最常见的用例：将依赖项添加到你的项目中。**依赖项**是由其他开发者编写的代码包，可以快速集成到你的项目中。

回顾一下，这是通过使用 `require` 关键字和包名称来完成的。例如，如果你想添加 PhpMetrics，你可以通过运行以下命令来实现：

```php
$ composer require phpmetrics/phpmetrics --dev
```

通常，包通过开发者（所谓的 *vendor*）的名称来识别，并且通过斜杠与包名称分隔。在上面的例子中，供应商和包名称是相同的，但这并不总是如此。

让我们更详细地看看 `--dev` 选项。当我们使用 `composer require` 命令并带上这个选项时，Composer 会将包添加到 `composer.json` 文件的另一个部分，称为 `require-dev`。在这里，你可以看到典型的 `composer.json` 文件的摘录：

```php
{
  "name": "vendor/package",
  ...
  "require": {
    "doctrine/dbal": "².10",
    "monolog/monolog": "².2",
    ...
  },
  "require-dev": {
    "phpunit/phpunit": "⁹.5",
    "phpmetrics/phpmetrics": "².8",
    ...
  },
  ...
}
```

`require-dev`部分背后的想法是，这个部分中的所有包对于在生产环境中运行应用程序不是必需的。在本地环境或构建过程中，你肯定会需要 PHPUnit 和所有我们珍视的代码质量工具；在生产环境中，它们不再需要。

实际上，你应该努力在生产环境中使用尽可能少的包。这主要是两个原因，如下所述：

1.  你添加的每个包都将包含在 Composer 的自动加载机制中，这会在每个请求上消耗性能。内部，Composer 构建了一个所谓的*类映射*，它是一个简单的数组，将类名映射到相应的文件位置。如果你对此感兴趣，可以查看例如`vendor/composer/autoload_classmap.php`文件。根据你的项目使用的包的数量，这个文件可能会变得非常大，从而减慢你的应用程序。

1.  每增加一个包都可能引入安全问题。代码越少，攻击向量就越少。

默认情况下，Composer 将安装所有依赖项。因此，请确保使用`--no-dev`选项运行它，以排除`require-dev`中的包在生产构建中被安装。然而，在你的本地环境中，你在这个阶段不需要担心其他任何事情。

之前描述的安装方法是一个很好的起点，也是你遇到最多的方法，原因有很多：它不需要任何额外的工具，并且在生产环境中安装时只有一个额外的选项需要使用。这使得它成为一个完美的起点，对于小型项目来说通常已经足够。另一种值得了解的方法是 Composer 的全局安装，我们将在下一节中讨论。

## 全局安装

如果你正在本地系统上同时处理多个项目，你可以选择全局安装 Composer 和包，这意味着它们不会安装在任何项目的`root`文件夹中，因此也不会添加到任何`composer.json`文件中。相反，Composer 和包都将安装在一个单独的文件夹中，通常是`~/.composer`。在这个文件夹中，你将找到另一个`composer.json`文件，它跟踪全局安装的包，以及另一个`vendor`文件夹，其中安装了它们的代码。

全局安装包只需添加`global`修饰符，如下所示：

```php
$ composer global require phpmetrics/phpmetrics
```

同样，更新所有全局包也非常简单，如下所示：

```php
$ composer global update
```

在全局安装后，工具如**PHP 编码标准修复器**（**PHP-CS-Fixer**）可以简单地执行，无需指定路径，如下所示：

```php
$ php-cs-fixer fix src
```

然而，为了使这种方法生效，你需要将这个全局文件夹添加到执行路径中。请参阅 Composer 文档（[`getcomposer.org/`](https://getcomposer.org/)），以获取有关如何为使用的操作系统执行此操作的更多详细信息。

只有在你单独工作在项目上且不使用任何构建管道的情况下，才应选择使用全局安装功能。如果你在一个团队中工作并且/或者使用 **持续集成**（**CI**）管道，你应该为每个项目单独安装它。

根据如 **Twelve-Factor App** 原则（[`12factor.net`](https://12factor.net)）等常见最佳实践，所有依赖项都应明确声明，不应依赖任何全局依赖项，因为你永远无法确定将安装哪个版本。尽管代码质量工具包不是实际程序代码的一部分，但它们仍然是构建过程的一部分。安装版本之间的小差异可能导致不可预见的行为，并且在错误无法在本地重现时会产生混淆。

此外，你希望使项目的初始安装尽可能简单。让你的队友手动安装所有必需的工具是一个耗时且容易出错的过程，可能会导致挫败感。

由于上述原因，我们不鼓励使用全局安装方法。

## Composer 脚本

一旦你决定了一种安装 Composer 的可能方法，并使用它下载了你想要的工具，你希望以最直接的方式开始使用它们。在*第十一章*“持续集成”，我们将讨论 CI，我们还将向你展示如何在构建过程中自动运行这些工具。然而，现在我们想向你展示 Composer 如何在需要时手动运行它们。

让我们考虑以下示例：作为第一步，我们希望运行 PHP-CS-Fixer 以自动修复 `src` 文件夹中的代码。之后，我们希望对代码运行 PHPStan，级别为 `1`。你当然可以单独运行这两个步骤，但我们希望增加一些便利，一次执行这两个工具。

为了实现这一点，我们可以利用 `composer.json` 文件中的 `scripts` 部分在项目根目录下。在那里，我们必须添加我们想要执行的工具体现在一个简洁的命令名下，例如 `analyze`。以下示例显示了这可能看起来像什么：

```php
{
  ...
  "scripts": {
    "analyze": [
      "vendor/bin/php-cs-fixer fix src",
      "vendor/bin/phpstan analyse --level 1 src"
    ]
  }
}
```

我们在这里使用了 **JavaScript 对象表示法**（**JSON**）数组表示法，将每个命令单独放在一行中，这使得它比在一行中写完所有内容更容易阅读和维护。

如果你想要分享这些 Composer 命令，你可能还想添加一段简短的描述文本，当你在执行 `composer list` 以查看可用命令时，这段文本会被显示。为此，你需要将 `script-descriptions` 部分添加到你的 `composer.json` 文件中。对于之前介绍的 `analyze` 命令，它可能看起来像这样：

```php
{
  ...
    "scripts": {
        ...
    },
    "scripts-descriptions": {
        "analyze": "Perform code cleanup and analysis"
    }
}
```

通过在子目录中安装工具，我们发现了一种在不干扰我们的应用程序依赖关系的情况下组织我们的代码质量工具的合适方法。但是，如果出于任何原因，您在项目中没有使用 Composer，或者您不喜欢在您的存储库中有两个`composer.json`文件的事实？在下一节中，我们将介绍一种不使用 Composer 的替代方法。

# 将代码质量工具作为 phar 文件安装

Composer 并不是添加代码质量工具到您项目的唯一可能方式。在本节中，我们将向您展示如何将工具作为`phar`文件添加。

我们无需关心 Composer 或依赖关系，就能立即遇到`phar`文件。此外，`phar`文件被所有现代 PHP 版本支持。

这样使得`phar`文件的使用变得非常方便，您可以像处理二进制文件一样处理它们。通常，您可以直接将我们之前介绍给您的许多 PHP 工具作为`phar`文件下载，并将它们放置在您想要的任何目录中。然而，这些文件没有统一的提供方式，因此请参考每个工具的官方文档。

让我们看看如何为我们在*第七章**，* *代码质量工具*中介绍的`phploc`工具这样做。根据其 GitHub 仓库，您可以直接从*PHPUnit*网站下载它，因为它们都来自同一作者。以下代码片段显示了您如何这样做：

```php
$ wget https://phar.phpunit.de/phploc.phar -O phploc
```

注意，我们以`phploc`的名称安装工具，而不是`phploc.phar`。`-O`选项允许您指定与下载的文件名不同的文件名。`.phar`扩展名不是执行工具所必需的，因此您可以节省一些输入努力。

Phar 和校验和

从互联网下载和执行文件始终存在它们可能被损坏和感染恶意代码的风险。这就是为什么工具的作者通常会生成下载的校验和（例如，通过如**安全哈希算法 256**（**SHA256**）之类的哈希算法），并在他们的网站上发布它们，以便您可以使用它们来验证下载的完整性。请检查您打算使用的工具的官方网站，以了解它们是否提供校验和以及如何验证它们。

当然，您可以使用您喜欢的任何方法下载它，无论是使用`curl`还是通过浏览器。一旦下载，您就可以立即使用您本地的 PHP 安装运行它，如下所示：

```php
$ php phploc src
```

如果您不想每次都输入`php`，您需要使`phar`文件可执行，例如在 Linux 上，它会看起来像这样：

```php
$ chmod +x phploc 
```

之后，您只需运行以下命令来执行`phploc`：

```php
$ ./phploc src
```

## 保持您的 phar 文件组织有序

现在，我们不仅想要下载 `phar` 文件，还希望在我们项目中将它们组织起来，这样任何其他开发者在使用它们之前都不需要做任何手动工作。最明显的选择是将这些文件添加到你的仓库中，这正是我们现在要探讨的。在下面的示例中，我们将使用 Git，但这种方法也可以适用于任何其他 **版本控制系统**（**VCS**）。

通常不建议在 Git 中存储大文件，因为它们可能会对性能产生负面影响。例如，GitHub 会阻止大于 100 个 `phar` 文件，我们使用的 `phar` 文件通常只有几兆大小，所以添加它们不应该有任何负面影响。

Git 大文件存储（Git LFS）

如果你需要在 Git 中存储大文件，请考虑使用 Git LFS，它正是为此类用途而设计的。但就我们的需求而言，我们不必使用它。

你可以自由选择在哪里添加 `phar` 文件到你的项目中。一个常见的地方是 `root` 文件夹；然而，由于随着时间的推移这会变得相当拥挤，我们建议使用一个单独的文件夹来存储它们。一个不错的选择是再次使用 `tools` 文件夹，就像我们在上一节中使用的那样。你不需要考虑其他任何事情；只需像添加任何其他文件一样将它们添加到仓库中。

假设你已将 `phploc` 文件复制到 `tools` 文件夹，并按照之前描述的方式使其可执行。然后，你只需按照以下方式执行：

```php
$ tools/phploc src
```

使用 `phar` 文件既简单又不会干扰你的应用程序依赖。然而，它们并不完美：如果你想更新它们，你需要查找下载的 `phar` 文件，并且每次都要手动验证其校验和——针对每个工具。在下一节中，我们将向您展示如何通过引入另一个依赖管理工具：Phive 来简化这个过程。

# 使用 Phive 管理 phar 文件

在上一节中，我们学习了使用 `phar` 文件而不是使用 Composer 来安装我们的代码质量工具。这种方法很好，但如果你想要更新它们，它确实需要做一些额外的工作。

**Phive** 是一个可以接管额外工作的工具。让我们立即安装它。

自然地，Phive 本身也可以作为 `phar` 下载。以下命令将按 `phive` 的名称下载它并使其可执行：

```php
$ wget https://github.com/phar-io/phive/releases/download/0.15.1/phive-0.15.1.phar -O phive
$ chmod +x phive
```

请注意，这种安装方法并不非常安全。请检查工具的网站（https://phar.io）了解如何安全安装以及如何使其全局可用。

为了演示目的，简单的下载就足够了。一旦文件下载并设置为可执行，你就可以直接开始使用 Phive 来安装第一个工具。让我们使用我们在上一章中介绍的 `phploc` 来演示它是如何工作的，如下所示：

```php
$ ./phive install phploc
```

下载验证

Phive 不仅负责下载的*安装*，还负责*验证*。这是在安装过程中自动完成的。然而，这需要供应商提供校验和，这也是为什么不是所有工具都可以通过 Phive 管理的最主要原因。

如你之前所见，安装一个工具只需使用`install`命令。现在已经发生了以下四个步骤：

1.  Phive 下载了`phploc`的最新版本并验证了其校验和。

1.  `phar`文件被存储在一个共享文件夹中（通常位于你的家目录下，命名为`.phive`）。

1.  然后，Phive 创建了一个指向该共享文件夹的符号链接。符号链接是文件系统中的一个引用，使得一个文件或目录可以出现在多个目录中，尽管它只存储在一个地方。默认情况下，这个符号链接存储在`tools`文件夹中，如果不存在，将会生成。

1.  在你的项目根目录中创建了一个另一个`.phive`文件夹，用于存储有关已下载工具的信息。

符号链接在你的目录中看起来就像“真实”的可执行文件一样，而原始文件仍然只存储在一个位置。如果你不想使用符号链接，可以使用`--copy`选项安装文件副本。

安装后，执行`phploc`非常简单，正如我们在这里看到的：

```php
$ tools/phploc src
```

Phive 提供了更多有用的命令。只需运行以下代码（不输入任何命令）即可获取它们的列表：

```php
$ ./phive
```

在这里，我们介绍最重要的几个：

+   `list`——列出所有可以通过 Phive 管理的工具

+   `update`——如果可用，更新所有已安装的`phar`文件

+   `selfupdate`——更新`phive`可执行文件本身

+   `outdated`——告诉你哪些`phar`文件可以更新

+   `status`——列出所有已安装工具的概览

## 将 Phive 添加到你的项目中

如果你在一个团队中工作，你不仅想要在本地安装`phar`文件。Phive 在这里也为你提供了支持。将 Phive 正确添加到你的项目中需要以下两个步骤：

1.  将项目根目录下的`.phive`文件夹添加到你的仓库中。其中的`phars.xml`文件包含所有必要的信息（例如`composer.lock`文件）。

1.  确保工具文件夹不在版本控制之下（例如，通过使用`.gitignore`文件）。你明确不希望将`phar`文件本身添加到你的仓库中。

一旦完成，下次从仓库检出项目时，可以通过执行以下命令来安装工具：

```php
$ ./phive install 
```

这个命令可以轻松集成到其他工作流程中——例如，作为`composer.json`文件中的附加`post-install-cmd`脚本。

这就是你需要了解的所有关于 Phive 的信息，以便开始使用它。像往常一样，我们建议你阅读官方文档，因为我们无法在这本书中涵盖它提供的所有功能。

# 概述

Composer 是当今 PHP 世界中不可或缺的一部分。通常情况下，向你的项目添加代码质量工具的方法是将它们添加到依赖项的 `require-dev` 部分，这在许多情况下都运行得很好。

然而，Composer 并非唯一的途径。因此，在本章中，我们介绍了另外两种管理你的代码质量工具的选项：通过手动将 `phar` 文件添加到你的项目中，或者通过利用 Phive 来管理 `phar` 文件。

你可能现在急于将所学到的所有知识应用到你的代码中。然而，不懈的重构可能会带来更多的伤害而不是好处，而且每次更改后都要点击应用程序的所有部分来检查是否有什么东西坏了，这会花费你很多时间，并且可能会非常令人沮丧。因此，在下一章中，我们将向你展示自动化测试如何在这里帮助你。
