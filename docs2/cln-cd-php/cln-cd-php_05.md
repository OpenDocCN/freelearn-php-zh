

# 优化您的时间和分离责任

在经历了所有这些理论之后，是时候进行一点实践了！我们已经一起看到了很多：关于编写清洁代码的高级原则、如何为您的应用程序选择正确的外部库，以及如何在不过度风险的情况下利用这些库的最新补丁。但我们不应忘记，“清洁代码”中的“代码”一词（显然）。因此，在本章中，我们将更专注于您应用程序的源代码，并探讨以下要点：

+   文件和文件夹的命名规范和组织

+   为什么将责任分离以尊重 SOLID 原则中的“S”很重要？这对您有什么好处？

+   我们将发现一种优雅的方式来通过事件系统管理责任分离

+   我们将以一些多态性结束——即抽象类和接口：为什么、如何以及何时使用它们？

# 命名和组织规范

我们必须首先声明，本章中给出的命名规范和组织思想并非绝对真理。正如我们之前所看到的，最重要的是尊重您项目中的现有规范，并与您的团队保持一致。如果觉得有必要，可以对这些规则进行适应以满足您的需求。再次强调，重要的是要使用常识和逻辑，并尽可能清晰。

让我们先谈谈源文件的命名。显然，命名规范因技术而异（例如，根据您是否使用某个框架或另一个框架，良好的实践可能会改变）。尽管如此，我们仍可以注意一些几乎在所有地方都可以找到的规范。

## 类文件和接口文件

`Foo` 类应该在 `Foo.php` 文件中定义。这种命名技术不仅仅是一种规范，它还具有真正的技术意义。确实，PHP 的自动加载机制将假设您的文件定义了一个与文件名相同的类。自动加载允许 PHP 自动发现您应用程序中定义的类，特别是由于命名空间（我们将在稍后回到这一点，因为它们与您项目中的文件组织直接相关）。如果您为文件和它们定义的类使用不同的名称，自动加载可能会失败并抛出错误。在各个语言和全球开发者社区中，命名类的最常见风格是 `MySuperServiceClass`，如果我们使用 PascalCase。还有其他命名风格——我们将看到其中一些，以及它们适用的场景。

## 可执行文件

PHP 文件作为可执行命令行脚本，有很强的趋势使用小写命名。`apt-get`、`docker-compose`和`git cherry-pick`是完美的使者。没有任何东西阻止你以其他方式命名你的可执行文件，一切都会正常工作。然而，通过这种方式命名用 PHP 编写的命令行应用程序，你为大多数命令提供了一个统一的**命令行界面**（**CLI**）体验。这正是我们在 PHP 中开发命令行应用程序时想要的：让它与传统系统命令融为一体。

## 网络资源和资产

还有一种情况使用 kebab-case 风格，这主要用于公共网络资源，尤其是 JavaScript，例如`/contact-us`，与`/contactus`或`/ContactUs`这样的命名方式相比。这在你必须处理前端文件时尤其重要。

## 命名类、接口和方法

正如我们在前面的章节中看到的，缩写应该从你的代码中禁止。例如，`Abstract`（例如，`AbstractMailer`）以及你的接口应该以`Interface`后缀结尾（例如，`MailerInterface`）。这使得名称略微变长，但在使用上没有混淆。它们的目的清晰、定义明确且一目了然。如果为了理解它们的必要性，不要害怕给你的类起长名字。`AbstractWebDeveloperConsoleStreamWrapperExtension`对于一个类名来说可能非常长，但在项目上下文中，它立即清楚其用途，无需过多提问。再次强调，利用你 IDE 的自动完成功能，你只需输入前几个字母，就能在几秒钟内使用它。同样适用于你的属性和方法名称。要明确。

讨论属性和方法命名时，我们倾向于喜欢`myGreatMethod`这样的命名。一些语言使用 PascalCase 来命名方法，例如 C#。让我们说实话——这并没有真正的理由或论据，两种命名风格实际上是一样的。一次，这真的是一种约定——一种特定语言的习惯。

## 命名文件夹

文件夹的命名约定与文件类似。PascalCase 主要用于文件夹。也可以为公开的文件夹使用其他命名风格，例如网络资源。你不应该犹豫创建一个大的树状结构并赋予其意义。因此，简单地命名为 `Manager`、`Service` 或 `Wrapper` 的文件夹应避免使用。这些术语过于通用，不能轻易理解它们所定义的内容。我们更喜欢更明确的变体，如 `Mail` 及其子文件夹 `Provider`、`Logger` 等。这些子文件夹可以具有更通用的名称，因为它们包含在一个命名上下文的文件夹中：一个领域。一种巧妙的方法是使用文件夹将源代码分离到不同的领域。你的应用程序将更好地切片，架构更清晰。关于同一主题的内容将位于同一位置。随着这种习惯变得自然，你会更加高效。许多开源项目和库都使用这种方式来分割它们的源代码。因此，你将能够浏览自己的代码，也能浏览他人的代码。有时找到一个合适的元素名称，无论是类、文件、变量还是其他任何东西，都可能是极其复杂和耗时的工作。然而，这一步尤其重要，不应被忽视。注意不要对自己说：“我给出一个不一定非常清晰的名称，但我稍后会更改它。” 很可能你会忘记它，而且在你甚至没有意识到的情况下，技术债务就会产生。

# 分离职责

让我们看看代码中职责分离的组成部分，使其更干净、易于理解、可维护和可扩展。这是 SOLID 原则的第一点。在第二章中，我们这样定义了单一职责原则：“*这意味着你的代码中的类必须只响应一个任务。*”

作为提醒，SOLID 是一组已知的清洁代码规则，当一起应用时，会使你的代码更加清晰和准确。与其试图逐字遵循每个 SOLID 原则所描述的五个原则，不如在编码时全局考虑这一点。

尊重这一点的第一步实际上是……命名，就像我们刚才看到的！确实，通过恰当地、清晰地、最重要的是精确地命名一个类，你已经在确保它不会变成一个混乱的地方，你可以把所有能想到的东西都放进去。正是出于这个原因，我们有必要不要用像`Manager`和`Service`这样过于通用的术语来命名方法。这会导致一个大问题：如果我们最终得到一个名为`EmailManager`的类，我们显然都会首先想到添加所有处理电子邮件管理的方法。这就是混乱开始的原因。这就是为什么我们更愿意创建像`EmailFactory`、`AbstractEmailSender`等类，以绝对避免有包含数百个不同方法的类。

我们开始更好地理解单一职责原则。让我们再重复一遍：目标不是创建只包含一个方法的类。这样做没有意义。你必须智能地将其拆分。拆分类的没有通用规则。正确拆分类的方法会随着经验自然出现，并且会自然而然地出现。如果你有帮助，你可以把文件夹看作是领域，而文件看作是子领域。使用接下来的例子，我们有一个名为`Email`的领域（或文件夹），以及专门针对特定任务的子领域：创建电子邮件，定义一个基类以使用特定的电子邮件提供商发送电子邮件，等等。我们甚至可以在职责分离上更进一步。确实，存在一些工具可以帮助我们轻松地解决这个问题。我们将发现（或重新发现！）事件分发。

## 事件分发

事件分发通常是通过观察者（Observer）和中介者（Mediator）设计模式实现的，就像在 Symfony 的`EventDispatcher`组件中那样。这些信息只是为了一般了解。确实，设计模式一开始可能会显得晦涩，甚至令人恐惧。此外，解释它们需要一本自己的书。所以，我们将不谈论设计模式，而将这一切通俗化。此外，我们不会实现一个事件分发器：这是关于理解它如何帮助我们的问题。

非常简单地说，事件分发的原则是在特定实体状态发生变化时，通知所有对此感兴趣的各方。各方将通过以下方式通知中央调解者：“我对知道这个特定事件何时发生感兴趣；当它发生时通知我，因为如果发生，我有一些事情要做。”调解者将保留这些信息。当所述事件发生时，调解者将遍历对此感兴趣的各方列表，并说：“事件刚刚发生；做你需要做的事情。”更进一步，如果必要，感兴趣的各方甚至可以声明一个优先级，以便在其他所有人之前执行。请注意——我们谈论的是同步事件，也就是说，对事件感兴趣的各方将依次执行，跟随他人，而不是并行执行。异步事件管理是另一回事。

事件分发就是这样简单。但是，它如何帮助我们强化单一责任原则呢？让我们看看一个具体的例子：用户从你的应用程序中删除他们的账户。然后你需要执行两个任务，如下所示：

+   从数据库中删除账户

+   给用户发送最后一封电子邮件，说一声悲伤的再见

因此，我们自然会创建一个名为`UserRemover`的服务，它将依次执行这两个任务。它工作得很好。`UserRemover`是一个明确的名称，定义了一个非常精确的任务。到目前为止没有问题。然后，有一天，你的应用程序变得流行起来。你想要给管理员发送一封电子邮件，通知他们用户已经离开。我们的`UserRemover`类最终删除数据并发送了两封电子邮件，内容非常具体，收件人也非常明确。

之后，你想要给用户删除账户的可能性，以尊重实际上不删除任何内容、发送电子邮件以及可能执行许多其他任务的`UserRemover`服务。我们遇到了一个真正的问题：这个类没有做它应该做的事情，并且它现在可能已经有一千多行代码，有几十个方法。

如果你从一开始就使用事件分发，情况将会大不相同。以下是一个解决方案的例子。当用户想要离开你的应用程序时，你将分发一个名为`UserRemovalRequestEvent`的事件。然后，随着你的应用程序的增长，你将创建对此事件感兴趣的各方：事件监听器。我们将为每个任务创建一个，如下所示：

+   一个用于从数据库中删除数据的监听器

+   一个用于发送给用户的告别邮件监听器

+   一个用于发送给管理员的邮件监听器

关于匿名化？这很简单：我们也将为这个任务创建一个监听器，并将删除数据的监听器“断开连接”。因此，每个任务都有一个类。每个类都有其独特的责任（向管理员发送电子邮件、匿名化数据等等）。如果在将来你需要添加一个任务，你将创建一个新的类（或监听器）来执行特定的任务，而无需触及其他类。这样代码就变得干净且极具可扩展性。类名保持清晰且简洁。如果一个任务已经过时，你可以简单地将其从对相关事件的感兴趣方列表中移除。单一责任原则得到了尊重。

如果你想要使用现成的事件分发器，我们推荐使用`symfony/event-dispatcher`包。这正是框架用于其操作所使用的组件。它非常健壮和高效，并且已经经过了几年的验证。

# 多态性的揭秘——接口和抽象类

就责任分离而言，事件分发是一个已经相当高级的概念。如果你知道这个机制，理解它，并且有机会使用它，那么你可以认为你在干净代码的世界中的水平已经大大提高。所有这些显然都需要一些设置。要么你自己实现这个系统，要么使用外部库。在后一种情况下，显然有一个完整的学习阶段需要包括。无论如何，这显然不是提高你责任分离的唯一方法。有一种方法是 PHP 的本地方法，可以用来提高这种分离，有时没有得到足够的利用，有时被误解，并且经常被低估。我们在这里谈论的是多态性，或者通俗地说：抽象类和接口。

首先，为什么是“多态性”这个词？*Poly*来自希腊语，意思是“许多”，而*morphism*意味着“形式”或“形状”。抽象类和接口只是实现代码中多态性的一种方式，以及面向对象编程（**OOP**）。为了简化问题，让我们只考虑接口的情况。

## 接口

接口为后来实现它们的类定义了一个通用的形式/形状。它们确定了每个实现应该为其情况定义的方法。实现必须必然定义其接口（或接口）的所有方法。这通常是我们听到以下声明的原因：“接口是一种契约”。我们可以这样理解：如果你实现了一个接口，你承诺实现它定义的方法。你没有其他选择。

这就是多态的强大之处所在。在你的代码中，你可以告诉 PHP，一个方法的一个参数必然是实现了精确接口的对象的实例。你可以操作这个接口的不同方法并调用它们。你不必担心它在被使用时如何实现：我们对此不感兴趣。举个例子，一张图片胜过千言万语，让我们以我们的邮件系统为例。

你有`MailerInterface`，它只定义了一个方法：一个发送邮件的方法。我们之前可以将其命名为`sendEmail`。当用户在你的应用程序中被删除时，发送告别邮件的事件监听器被调用。在这种情况下，你感兴趣的是邮件简单地被发送，而不是发送的内部工作原理。顺便说一句，这些内部工作原理是否可能根据某些条件而不同？你不必找太远就能找到一个例子：你的主要电子邮件提供商可能不可用，但你绝对需要发送你的消息。然后你必须使用另一个电子邮件提供商，它有不同的**应用程序编程接口**（**API**）、不同的选项等等。没有多态，事情可能会很快变得极其复杂。

解决方案是创建两个`MailerInterface`的实现，每个实现根据所使用的电子邮件提供商定义`sendEmail`方法。但结果是相同的：邮件被发送。当用户删除他们的账户时，你执行检查以确保你的主要电子邮件提供商是可用的并实例化其实现。如果它不可用，你实例化备份电子邮件提供商的实现。另一方面，在电子邮件发送事件监听器中，你只需不断调用在`MailerInterface`中定义的`sendEmail`方法，无需担心其他问题。代码干净、清晰；责任分离；你节省了时间。而且更重要的是，它已经变得对失败具有弹性。

如果你愿意，你可以用 10、15 或 20 个电子邮件提供商来做这件事。优势在于，如果某个提供商的 API 发生变化或你在你的实现中找到一个错误，你只需修改有问题的那个实现。其他所有实现都不会移动，就像调用接口时的那样。你大大降低了错误的风险，你的代码也更容易测试：你可以为每个实现编写特定的测试。这比那些试图评估所有可能情况的通用、无休止的测试要稳健得多！节省的时间是异常的，无价的。

## 抽象类

那么抽象类在这个体系中是如何定位的呢？我们可以将其视为接口及其实现之间的一个中间层。虽然显然抽象类不一定要实现接口，但通常在抽象类之上创建一个接口是一个明智的想法。确实，抽象类比接口更宽容：你可以部分定义声明的方法，声明属性，并决定类的方法和属性的可见性（接口只允许`public`可见性，不允许`private`或`protected`）。使用接口，你有一个干净的合同，没有任何“以防万一”的信息，并且只有当你尊重 SOLID 原则中的“I”（接口的隔离）时，才包含最基本的信息。作为一个提醒，简单来说，这个原则表明接口不应该包含“以防万一”声明的方

抽象类允许我们为扩展它们的类定义共同的行为，这些类希望利用多态性的力量。特别是，这避免了代码冗余、错误来源和无休止的复制粘贴。确实，在我们的上一个例子中，`MailerInterface`的不同实现很可能有共同的行为，例如创建与电子邮件提供商 API 通信的 HTTP 客户端或创建一个在实现内部操作中使用的通用`Message`对象。

在这种情况下，我们会声明实现`MailerInterface`的`AbstractMailer`并定义不同实现中的共同行为。然后，不同的实现会扩展`AbstractMailer`以享受你刚刚定义的共同行为。

请注意——这并不意味着在所有地方、所有时候和所有情况下都必须创建接口和抽象类。我们不应该忽视这对比单一类对代码复杂性的影响。此外，仅仅因为你还没有为某个情况创建接口，并不意味着它是不可变的和固定不变的。很多时候，我们发现自己在重构代码，创建接口和抽象类，并调整现有类以实现和扩展它们。正如我们所看到的，我们最初需要保持代码的简单性（尊重*YAGNI*和*KISS*原则）。我们无法预测未来，业务约束在不断发展。

如果在创建类的时候，没有迹象表明需要不同的实现，这并不是一个需要担心的问题。这是一个以后会完成的任务。另一方面，如果在开发过程中，你发现自己正在从一边复制代码到另一边，并且感觉到强烈的冗余，那么考虑多态性将是一个极好的反应。

# 摘要

我们刚刚覆盖了这本书理论部分的最高级内容。我们现在拥有了知识，可以在保持代码可维护和可扩展的同时，为未来的开发者编写干净的代码。它也将通过强烈地开放扩展和封闭修改（如*SOLID*原则之一所述）为未来做好准备。

我们已经回顾了许多你可能在开发 PHP 应用程序时遇到的关于文件、类和方法命名的案例。此外，我们还看到文件夹必须有特定的名称，并且可以用来将你的应用程序划分为不同的域。

职责分离也是一个重要的话题。理解为什么这种分离在项目中是有用的，甚至是至关重要的，尤为重要。这是构建一个易于导航的、良好架构项目的真正关键。正如我们所看到的，事件分发是实现这一目标的绝佳方式。事件分发是某些关键 Web 项目（如 Symfony 框架）的基石之一。这个框架在很大程度上依赖于这种机制，使其成为一个以稳健性、效率和——尤其是——灵活性著称的工具。这也归功于其内部的泛型和不同接口的声明。你可以通过这种方式重新声明框架的几乎所有部分，并将其适应到你的最高级需求。

并非总是容易理解何时创建一个接口或抽象类。这需要实践和经验。很快，这就会显得很自然。如果有疑问，不妨和你的同行交流一下！

我们将在下一章以一个轻松的部分结束这本书的理论部分，这部分将讨论 PHP 的新特性。这些特性使我们更加严谨，成为更好的开发者，尤其是在过去几年里。
