# 3

# 代码，不要玩杂技

清洁代码的高级原则实际上会帮助你成为一个易于理解的开发者，能够编写更干净的代码。它们教你保持选择的一致性，考虑其他开发者和你的团队，并将沟通作为我们工作的主要工具。甚至在源代码之前。

事实是：虽然源代码在开发者的工作中占据了主导地位，但我们不应将其作为我们存在的首要理由。这是一个现实：开发者的工作不是编写代码。它关于在适应会阻碍我们的限制条件的同时，找到解决给定问题的方法。这是我们工作的基础，我们必须绝对牢记。尽管我们在上一章中看到的原理，如 SOLID，似乎与代码紧密相关，但我们必须尝试对所有这些事物有一个更“元”的视角，跳出思维定式，退后一步。这些提到的原理，从客观上来说，是允许我们以高效和直接的方式解决问题的工具。

我们可以问自己以下问题：源代码的真正目的是什么？它的目的是什么，我们是否可以允许自己在语言的最基本事物上做任何事情？ 

本章我们将涵盖以下主题：

+   理解代码

+   被理解，而不是聪明

+   关于可维护性的说明

# 理解代码

让我们先问问自己代码的重要性。对于我们开发者来说，它在我们的日常生活中真正的重要性是什么？为了回答这个问题，让我们回顾一下过去。

## 一点历史

计算机编程实际上是一个电流通过或不过的晶体管。因此，我们得到了一个二进制系统，如果电流不通过晶体管，则值为`0`，如果电流通过，则值为`1`。如果你将这个晶体管的数量乘以数十亿，你最终得到今天的处理器。它工作得非常好，我们的世界已经由这个系统统治了几十年。然而，有一个明显的局限性：仅用 0 和 1 来理解和创建应用是不可能的。因此，我们必须找到一种新的编写这些程序的方法，使它们变得对人类来说是可能的并且可管理的。

我们接下来转向第一个人类可读的源代码：**汇编语言**（通常缩写为**ASM**）。这种语言在 20 世纪 40 年代末开始流行，它终于使得人们能够用一种与我们的自然语言或多或少相似的语言来读取文件，尽管汇编语言是一个非常低级的语言（这意味着它与机器语言——即二进制语言——非常接近）。一环扣一环，更高级的语言随之出现——其中 C 语言最为知名，它在 1972 年首次发布了官方版本。其原理很简单：能够用越来越自然的人类语言来编写计算机程序。然后，一个工具会自动将这种高级语言翻译成机器可以解释的汇编语言和二进制语言。

C 语言是编程语言的有用性和主要目的的一个绝佳例子。确实，这种由 Dennis Ritchie 和 Brian Kernighan 创建的语言最初被用来开发 Unix 操作系统。关键在于，用 C 语言编写 Unix 操作系统比用当时的工具——即汇编器（即使 Unix 操作系统的某些部分是用汇编语言编写的，但绝大多数源代码是用 C 语言编写的）编写操作系统要容易得多。接下来，我们将探讨编程语言和代码的实际目的。

## 代码的目的

正是这里，一切都有了意义。编程语言的存在是为了帮助我们尽可能容易地将我们的想法记录下来，并且它们可以被机器理解。但编程语言不仅仅局限于将我们的想法转录给机器——它们的目的是让其他人通过阅读我们的代码就能理解我们的想法，而无需我们亲自解释。编程语言是一种微妙混合体，它既具有被人类理解的可能性，又给我们提供了与机器通信的自由度，以及利用其全部潜力的可能性。这就是当我们谈论高级语言和低级语言时，定义编程语言水平的原因：光标的位置在“易用性和理解性”与“语言提供的性能和可能性”之间。在启动新项目时选择最合适的编程语言时，需要做出必要的权衡。一个完美的例子是**PHP：Hypertext Preprocessor**（**PHP**）语言中捆绑的所有工具，用于处理**Hypertext Transfer Protocol**（**HTTP**）请求和响应，这使得它成为创建网络应用的绝佳选择。大多数你需要的功能都已经内置，无需安装任何东西就可以处理最基本的一些相当高级的网络应用功能。

PHP 是用 C 语言编写的；它是一种比 C 语言更高级的语言。因此，它更容易理解，更宽容，但与 C 语言相比，它提供的性能扩展更少，可能性也更少。如果你需要在 PHP 中编写一些汇编代码来与某些定制硬件通信，例如，声明很简单：你不能。你必须编写一个 PHP 扩展，这个扩展将用 C 语言编写（这然后允许你在汇编语言中编写源代码部分）。这是一个超级高级的案例，当然，但你的观点已经明确了。

让我们进一步比较 PHP 和**超文本标记语言**（**HTML**）。尽管 HTML 不是一种编程语言而是一种描述性语言，但它与 PHP 仍有相似之处：这两种语言都用于表达人类思想，这些思想可以被机器解释。关键是简单的：对于一个真正不了解技术和编程语言的人来说，你当然能够解释 HTML 文件的内容，它代表什么，它的语义以及它的目的。在 PHP 中，情况就不同了。实际上，在文件分割、类分割、**面向对象编程**（**OOP**）以及所有这些其他概念之间，你肯定需要更多的时间来让你的非技术对话者理解所有这些的目的。然而，尽管 HTML 不允许 OOP，它也不允许条件分支、写入文件、管理发送到服务器的请求等等。因此，我们最终得到一种对人类来说更容易理解的语言，因为它非常接近我们的自然语言，但可能性却少得多。

尽管存在这些差异，我们必须记住以下事情——这些语言的主要目标完全相同：被尽可能多的人和计算机理解。编写代码意味着要易于理解。这是要表达思想。就像在日常生活中当你表达你的思想时，你越简单、越直接，就越多人能够理解你。

# 被理解，而不是聪明

在面对技术挑战，尤其是在源代码面前，我们常常想要以一种精致、漂亮，甚至“性感”的方式做事，正如有些人所说。这是完全正常的——因为代码是我们作为开发者生活的重要组成部分，我们有时想展示我们能力的极限。虽然有时可以证明这是合理的，但想要完全展示这些才能通常是极其糟糕的想法。显然，我们的自尊心会受到打击——我们有时必须克制自己。你刚刚学习了新的做事方式，新的编码方式，以及你坚信的新原则。你花了一个周末学习这种新的代码和项目组织方式，你把它体验为一种启示，你确信这一点：你必须向你的同事和团队展示这个新发现；它将彻底改变项目，只会带来好事。此外，你将因这个新事物而获得赞誉，你将成为它的标杆。然而，这根本不是正确的做法。

不要误解。每天学习，无论是在自己的时间还是不在，都是一件非凡的事情。如果你有机会这样做，你会变得更好。顺便说一句：这绝对不是强制性的！没有任何事情应该强迫你在业余时间编码。继续为工作编码和编程是完全正常的。

与同行分享你的发现和经验是正常的——甚至更甚，这是健康的。通过分享知识来提升你爱的人是最好不过的事情，而解释某件事是自我学习最好的方式。错误在于想要立即、无处不在地应用它。每种方法都有其优点和缺点。绝对有必要意识到它带来的缺点。一般来说，最常见的是在当前项目中应用，以及来自项目其他参与者的变化抵抗。只需以著名的 SOLID 原则为例：尽管它们的有效性得到了证明，但新来者可能难以接触。

对变化的抵抗对所有人来说都是正常且自然的。我们的大脑喜欢规律性——它喜欢周期性，不喜欢意外。这一点在工作环境中表现得尤为明显，但在生活的各个方面：饮食、锻炼和睡眠中也是如此。对于代码和我们的工作习惯来说，情况完全相同。再次强调，一致性和规律性是关键。

如果你将你的新发现带入项目，你将不得不考虑现有人员的培训。如果现有的习惯是合适的并且已经满足需求，他们可能并不想改变习惯。新习惯也意味着培训所有不知道这些做事方式的人。这需要个人投入，在某些情况下甚至需要大量的投入。这变成了个人时间或工作时间中的学习小时数，因此这些小时数将是生产力降低的小时数，这是不可否认的。有时这是必要的，有时甚至是一个有希望的想法。但那时，你必须能够向每个人证明这一点，包括项目中的非技术方，这显然是一个关键部分，尤其是如果你时间紧迫。

此外，一些编程实践可以产生奇迹，被证明是有效的，并使生活变得更加容易。然而，它们有一个巨大的缺点：项目的入职时间。以“无 if 编程”的实践为例。这种编程方法建议绝对不要在代码中使用`if`和条件分支。这要求大量和纯粹地使用**面向对象编程**（**OOP**）。从纸面上看，这看起来很好，这种技术的智力满足感必须非常特别。一旦掌握，其效率非常明显。一切都会变得更智能，代码也会变得明显清晰。简而言之，一切都在为你的下一个项目从开始就采用无 if 编程做好准备。

然而，当有人来到你的项目来帮助你并试图理解你所做的一切（甚至与你一起维护和演进项目）时，观察结果将会是压倒性的：如果这个人不了解这种编程技术（这是一种远非普遍性的技术），引入项目的整个过程将会很痛苦。除了需要培训这个人在项目功能限制方面的知识外，他们还需要接受一种新的编程技术的培训，他们可能并不熟悉。这意味着理解项目、理解风险、改变习惯、改变做事和工作方式，以及重塑思维方式。我们很快就能理解这种操作的代价。它可以被证明是合理的，但你必须非常确信自己，并且事先了解所有风险。

我们在这里讨论的是无 if 编程，但同样的情况也适用于其他不是一般规则的做事方式。**测试驱动开发**（**TDD**）就是其中之一！将 TDD 整合到项目中可能会很痛苦且复杂，正如我们之前所看到的。然而，TDD 主要影响做事的顺序，而不是学习一种完整的编码方式。这取决于你根据自己的环境和限制，判断这些风险是否值得承担。

在任何情况下，如果你选择了一种可以描述为异国情调的新编程技术，你可能会拥有典范性的代码，既干净又高效，且易于维护。问题是没有人能够理解它。记住前一个章节中提到的内容：代码是用来表达和传达思想的。它是用来被机器和，尤其是人类理解的。牺牲第二点将会是一件遗憾的事情，这也是为什么高级编程语言被发明出来的原因。

# 关于可维护性的说明

而这正是事情变得复杂的地方。你的代码已经准备好了——它运行正常。你已经遵循了一种新的编程方法，项目的初步开发已经顺利进行了几个月。很明显：可能没有为你的项目打下基础；你很幸运地从一张白纸开始。然而，可维护性的问题很快就会出现。无论你选择哪种编程技术，无论谁在从事这项工作，错误总是会出现。你可能需要新的人来修复所有这些问题（并且因此教会他们你的工作方法）。你确定你已经足够熟练地掌握了你的新方法，以确保应用程序在几年内的后续维护吗？这是完全可能的，但你必须意识到这一点，并且知道如果你在应用程序的维护上遇到困难时应该怎么做。

本章的目的并不是要阻止创新和测试新的工作方法。更多的是要充分意识到选择新工作方法的风险，尤其是在长期来看。我们稍后会看到，我们必须对一夜之间可能消失的最新趋势格外小心。

同样适用于那些乍一看似乎很优雅但实际上却难以维护的编程语法。在这些做法中，我们可以找到一些被突出显示的，以下是一些非详尽的例子。

## 使用二进制运算符和八进制、十六进制和二进制表示法

通常，在整数上使用二进制运算符进行操作（左移和右移、逻辑 AND、逻辑 OR、位反转等）比其他任何东西都更无意义。它们的罕见性使它们成为执行某些操作的语法看起来很优雅。然而，事实并非如此，掌握二进制操作不应是理解 PHP 代码的先决条件。

在某些情况下，使用八进制、十六进制和二进制表示法是有道理的。例如，当你想玩弄文件权限时，可以使用八进制表示法。如果你想在你方法中使用标志，以及使用二进制表示法，可以使用十六进制。但总的来说，除了使你的代码难以阅读之外，并没有太多其他的作用。

## 赋值变量和使用 goto 语句

变量可以在测试其值的同时被赋值。以下是一个例子：

```php
if null === ($var = method()))
```

最多只能节省一行代码。但自从我们关心应用程序源文件的大小以来已经很久了，这些文件最终由 PHP 解释器在运行时优化。在测试之前分配变量没有成本，而且你的代码会立即变得更加易读。

`goto` 指令允许你跳过代码的整个部分，甚至“向上”跳转。尽管在某些极其特定的情况下可能有用，但它绝对不应该在大多数情况下使用。多年来，在大多数编程语言中，`goto` 语句的使用一直受到谴责。确实，它们给代码流程的理解带来了极大的复杂性。当`goto`的使用过多时，有一个专门的名称：意大利面代码。

## 过度使用注释

有时，我们会看到注释的滥用，有时甚至有几百行来解释所有变量的类型、它们的用途、函数引发的所有异常、详细的返回值等等。我们甚至可以找到注释比代码还多的源文件。大多数情况下，通过清晰命名你的方法和变量，这些细节都可以省略。此外，PHP 最新版本中变量的类型、参数和函数返回值的类型也解决了这个问题。然而，使用注释生成文档是完全合理的，并且在可能的情况下应该使用。没有人会抱怨“文档太多”。自由地写几十行关于类、接口、方法等等是什么，以及更普遍的关于它的派生、技术性和/或功能性选择等等。当我们谈论“注释的滥用”时，我们指的是解释代码中发生什么的注释。

## 使用三元比较

这里是一个三元比较的例子：

```php
$var === null ? 'is null' : 'is not null' 
```

虽然三元比较可以使代码更加简洁，并将条件包含在例如函数参数传递中，但它们不应该被滥用，尤其是嵌套的三元比较，一旦嵌套到第一层，就会变得难以阅读，令人头疼。你可以在以下例子中看到这一点的证明：

```php
$var === null ? 'is null' : is_int($var) ? 'is int' : 'is not null'
```

这不是一条非常清晰或易于阅读的代码行，当条件不是基本且简单的时候，例如在第一个例子中，三元条件就会变得难以阅读。

## 使用缩写

这里可能是最常见且应被劝阻的做法：到处使用缩写。再次强调，在上个世纪的末尾，我们可能有一些使用缩写的理由：空间和存储比今天要有限得多，而且代码编辑器没有我们今天所拥有的所有自动完成功能那么智能。因此，将变量命名为`$userPasswordRequest`而不是`$usr`会让每个人的生活变得更轻松：既包括你，也包括将来回到你的代码的开发者，他们不需要问你这些缩写代表什么。再次强调，有了我们今天所拥有的自动完成工具，这样命名我们的变量是没有意义的。

## 将微优化引入你的代码

微优化是对代码进行的非常小的更改，可能会损害其可读性，但这是为了优化代码，从而使其执行速度更快。问题是这通常并不有用，首先是因为你不需要优化指令到纳秒级别（因为现在的处理器很强大），而且因为很多优化都是由语言解释器和编译器完成的。所以，你牺牲了代码的一部分可读性，为了那些不实用且会被自动执行的事情。此外，这通常会引起无谓的争论，其中没有人比任何人更有道理。在这些针对 PHP 的特定微优化争论中，我们发现特别是关于增量运算符（`++`）和减量运算符（`--`）在变量之前或之后的位置、在**标准 PHP 库**（**SPL**）的方法前使用反斜杠，或者匿名函数的静态声明或不声明的问题。再次强调，答案是：考虑与代码其他部分的连贯性，并保持实用主义。你当然不需要通过优化节省的 10 纳秒，这可能会在某些情况下节省，但可能会在开发团队中引发一场热烈的争论。

## 重新编码 SPL 的方法

我们对一个非常广泛的标准库语言有很多用途。标准库是 PHP 每个安装提供的类和方法集合。不幸的是，我们很快就会意识到它相当不为人知，并且提供了比你想象的更多可能性。因此，我们经常发现自己项目中使用了 SPL 方法，因为相关的开发者不知道标准方法的存在。这非常不幸，在某些情况下，这确实是一个真正的问题，原因如下：

+   SPL 方法无处不在。无需担心它们是否在某个安装或设置中可用。

+   这些方法是由 PHP 解释器的开发者测试的，而你的方法则不一定如此。

+   如果这些方法中的任何一个可以被优化或加强，这将得益于语言的数千名贡献者和研究人员。

+   这些方法被认为是尽可能高效的，由那些工作就是创建尽可能高效算法的人所构思和概念化。

+   SPL 方法可以直接用 C 语言编写。这意味着无论你在 PHP 中做什么，它们的性能都将无与伦比。不利用这一显著的好处将是遗憾的，尤其是在执行时间可能至关重要的应用中频繁使用的方法。此外，由于它们是用 C 编写的，C 编译器可以对这些方法提供非常底层的优化，直接使用汇编代码。你无法通过在 PHP 中编写方法来实现这一点。

随意查看官方 PHP 文档；一些方法，如 `natsort()`，可能会让你感到惊讶，并为你节省数小时的开发时间！

列举可以继续下去，但重点是，虽然你可能喜欢使用这些工具，但你将是唯一会感到满足的人。一个初级开发者可能会在这些实践面前完全迷失，而一个资深开发者则不会理解在更清晰、更简单的方法可用时使用这些实践的价值。你的代码必须尽可能被更多的人理解。通过为看似过于复杂的问题编写一些简单、琐碎且易于阅读的代码，来展示你的技能、知识和熟练程度。

# 摘要

你理解“建立在我们已知的基础上”是什么意思吗？我们稍作回顾后意识到，这又是一种常识和利他主义，考虑到未来会阅读我们代码的开发者。在这里，没有关于侦察兵、SOLID、**简单至上，傻瓜也明白**（**KISS**）或其他原则的问题。这是关于重新思考我们编写代码的方法。

我们必须记住，基础的东西可以（并且应该）被质疑，不应被视为一成不变。自信是一种美好的东西，如果你能够结合这种持续改进的习惯，你就能走上成为优秀开发者的正确道路，能够自然地编写干净的代码，并带领你的合作者一起实践。

积极主动是一件了不起的事情；了解风险并在你的环境中评估它们是追求完美的关键。这样，你才能知道这是否真的值得，同时也能向项目管理者证明你的选择是合理的。再次强调，当我们谈到干净代码时，我们回到能够证明我们所有选择和行动的能力。干净的代码不仅仅是避免使用二进制运算符或十六进制表示法。这意味着要考虑我们的项目环境、约束和周围环境。干净的代码不仅仅是关于代码。幸运的是，这正是我们将在下一章中看到的。
