

# 第十二章：团队合作

这本书的主要目标是让你能够编写可以被你和其他人理解、维护和扩展的代码。大多数时候，成为一名 PHP 开发者意味着你不会单独在一个项目或工具上工作。即使你开始独自编写代码，也很可能最终会有其他开发者加入你——无论是商业产品，还是你的开源包，其他开发者开始添加新功能或修复错误。

在软件开发中，总会有多种执行任务的方法。这就是当你想要一起编写*干净代码*时，团队合作变得更加具有挑战性的原因。在本章中，你将找到关于如何设置*编码标准*和*编码指南*的几个技巧和最佳实践。我们还将讨论*代码审查*如何改进代码并确保遵循指南。

我们还将在本章末尾更详细地探讨*设计模式*这一主题。这些模式可以帮助你的团队解决典型的软件开发问题，因为它们提供了经过充分测试的解决方案。

本章将包括以下部分：

+   编码标准

+   编码指南

+   代码审查

+   设计模式

# 技术要求

如果你跟随着前面的章节，你不需要进行任何额外的设置。

本章的代码示例可以在我们的 GitHub 仓库中找到：[`github.com/PacktPublishing/Clean-Code-in-PHP`](https://github.com/PacktPublishing/Clean-Code-in-PHP)。

# 编码标准

在前面的章节中，你学到了很多关于编写高质量代码的知识。然而，如果你只是自己这样做，那就不够了。当你在一个团队中工作时，你很可能会遇到其他开发者对质量有不同的理解，并且他们的技能水平与你不同。

这对你的代码是有害的，因为它可能会导致懒惰的妥协，其中涉及的各方同意一种方式，只是为了保持和平。因此，如果你想在一个团队中有效地工作，你希望尽可能标准化你的工作。

从低垂的果实开始是有意义的：代码格式化。这涉及到最基本的，比如同意使用多少空格来缩进行，或者大括号应该放在哪里。但为什么这甚至很重要呢？

我们已经在*第五章**，优化你的时间和分离责任*中简要地提到了这个话题。然而，我们想在这里进一步展开。拥有共同的**编码标准**（也称为*编码风格*）的主要优势是减少阅读代码时的*认知摩擦*。

认知摩擦

认知摩擦基本上描述了我们的大脑处理信息所需的精神努力。想象一下，例如，你读一本书，其中每隔一段文字就使用了不同的字体、大小或行间距。你仍然能够阅读它，但很快就会变得令人烦恼或疲劳。同样的情况也适用于阅读代码。

将编码规范引入项目相对容易，多亏了我们在本书前面介绍给你的工具。另一方面，与他人就共同标准达成一致则需要更多的工作。这就是为什么在本节中，我们想向你展示如何轻松地就共同编码标准达成一致。

## 遵循现有标准

与他人一起制定标准可能是一个漫长而痛苦的过程。然而，如今，你不再争论纸张的大小了。在欧洲国家，*DIN A4*标准被广泛接受，而在其他国家，如美国，你会使用*US Letter Size*而无需询问原因。大多数人接受这些措施，遵循这些标准使生活变得稍微容易一些——少了一件需要担心的事情。

同样适用于编码规范，它定义了你的代码应该如何格式化。当然，你可以和你的队友争论几个小时，关于是否应该使用*制表符*或*空格*进行缩进。双方都会提出有效的论据，但你永远不会找到正确答案，因为这里根本就没有对错之分。一旦你解决了关于缩进的疑问，下一个讨论的话题可能是括号的放置。它们应该出现在同一行，还是下一行？

我们不一定需要同意标准的每一个细节，但无疑，使用现有的规范可以节省时间和精力。在 PHP 生态系统中，已经存在一些你可以利用的*编码规范*。这样做的一个巨大额外好处是，代码嗅探器为这些标准内置了规则集。在下一节中，我们将讨论 PHP 最著名的*编码规范*。

### PHP-FIG 和 PSR

PHP 本身没有官方的*编码规范*。从历史上看，每个曾经存在或至今仍存在的重大 PHP 框架都引入了一些标准，因为开发者很快意识到使用它们有其好处。

然而，由于每个项目都使用自己的标准，PHP 世界最终形成了一种不同格式标准的混合。回想起 2009 年，当**PHP-FIG**（**PHP 框架互操作性**组（**PHP-FIG**））成立时，该组织由当时所有重要 PHP 项目和框架的成员组成，他们想要解决的就是这类问题。

当时，Composer 变得越来越重要，引入了可以在不同框架之间轻松使用的包。为了保持代码的某种一致性，达成了一种共同编写代码的方式：**PHP 标准建议**（**PSRs**）应运而生。

为了使 Composer 的自动加载器工作，有必要就如何命名类和目录达成一致。这是通过第一个标准建议*PSR-0*（是的，极客们从 0 开始计数）实现的，它最终被*PSR-4*取代。

第一个*编码标准*建议是在*PSR-1*和*PSR-2*中引入的。*PSR-2*后来被*PSR-12*取代，其中包含了针对新 PHP 版本语言特性的规则。

虽然 PSR-12 解决了代码风格问题，但它没有涵盖命名约定或如何组织代码。这通常仍然由你使用的框架预先定义。例如，*Symfony*框架有自己的基于上述*PSR-4*和*PSR-12*的*编码标准*，并添加了进一步的指导，例如命名或文档约定。即使你根本不使用框架，只是选择单个组件来构建应用程序，你也可以考虑使用这些在*Symfony*网站上可以找到的指南：[`symfony.com/doc/current/contributing/code/standards.html`](https://symfony.com/doc/current/contributing/code/standards.html)。

PER 编码风格

*PSR-12*于 2019 年发布，因此不再涵盖最新的 PHP 特性。因此，在撰写本书时，PHP-FIG 发布了*PER 编码风格 1.0.0*（**PER**代表**PHP 扩展建议**）。它基于*PSR-12*，并对其进行了某些补充。未来，PHP-FIG 不再计划发布任何与 PSR 相关的新的*编码标准*，除非需要，才会发布新的 PER 版本。我们很有可能会在本书中介绍的**代码质量**工具很快就会采用新的 PER。你可以在以下链接中找到更多关于它的信息：[`www.php-fig.org/per/coding-style`](https://www.php-fig.org/per/coding-style)。

随着时间的推移，PHP-FIG 已经引入了十多个建议，并且还有更多正在制作中。它们涵盖了如何集成日志记录、缓存和 HTTP 客户端等主题。你可以在官方网站上找到完整的列表：[`www.php-fig.org`](https://www.php-fig.org)。

PHP-FIG 和 PSR 的问题

PHP-FIG 不应被视为官方的 PHP 权威机构，任何 PSR 也不应被视为无可争议。事实上，许多重要的框架，如*Symfony*或*Laravel*，已经不再属于 PHP-FIG，因为推荐的标准对它们的内部结构干扰过多。看看今天可用的所有 PSR，你甚至可以将它们视为它们自己的元框架。但这并不是要贬低许多建议的相关性——我们只是希望你们不要盲目地接受它们为既定事实。

### 在你的 IDE 中强制执行编码标准

有几种方式可以强制执行编码规范。在上一章*第十一章*“持续集成”中，我们解释了如何确保没有错误格式的代码会破坏代码库。这效果很好，但即使我们让我们的工具自动修复代码格式，也需要额外的步骤，因为我们需要再次提交这些更改过的文件。所以，如果我们的代码编辑器或 IDE 在编写代码时帮助我们格式化代码，这实际上不是很有用吗？

现代代码编辑器通常具有内置功能，可以帮助你遵守你偏好的编码规范，如果你进行了配置的话。如果没有内置，这种功能至少可以通过插件提供。

你的编辑器可以支持你的两种基本方式：

+   **突出显示编码规范违规**：IDE 会标记出需要修正的源代码部分。尽管如此，它不会主动更改代码。

+   `PHP_CS_Fixer`。这可以在手动请求时进行，或者每次保存文件时进行。

在文件保存时重新格式化代码是一种非常方便的方式来确保你的代码符合编码规范。如何设置这取决于你使用的 IDE，因此我们不会在本书中进一步详细说明。

我们仍然建议使用**Git 钩子**和**持续集成**作为检查的第二层，以确保没有格式错误的代码被推送到项目仓库。你永远不能确定团队成员是否意外或故意禁用了自动重新格式化，或者是否没有关注代码中突出显示的部分。

*编码规范*主要涉及如何一致地格式化代码。但在团队工作中，你还需要就其他方面达成一致——在下一节中，我们将向你展示哪些其他方面值得达成共识。

# 编码指南

在上一节中，我们讨论了为什么你应该引入*编码规范*。一旦完成这项工作，你应该考虑设置**编码指南**。这两个话题听起来非常熟悉，确实如此。然而，尽管*编码规范*通常关注如何格式化代码，编码指南则定义了如何编写代码。这当然包括定义要使用哪个*编码规范*，但涵盖的内容远不止这些，你将在本节中了解到。

“如何编写代码”究竟意味着什么？在编写软件时，通常有多种方式可以实现目标。以广为人知的**模型-视图-控制器**（**MVC**）模式为例。它用于将应用程序逻辑划分为三种相互关联的元素——模型、视图和控制器。尽管它没有明确定义将**业务逻辑**放在哪里。是应该放在控制器内部，还是更合适地放在模型内部？

对于这个问题，没有明确的正确或错误答案。然而，我们的建议是采用*胖模型，瘦控制器*的方法：业务逻辑不应该在控制器中编写，因为它们是视图和特定问题代码之间的绑定元素。此外，控制器通常包含大量的框架特定代码，尽可能地将这些代码排除在业务逻辑之外是良好的实践。

不论我们的推荐如何，你的项目编码规范中应该定义你如何看待你的团队处理这个问题。否则，你很可能会在你的代码库中同时采用这两种方法。

通常，编码规范涵盖了如何命名方法、函数和属性等问题。正如你可能从那句著名的引语中得知：“*计算机科学中只有两件难事：缓存失效和命名事物*”，找到合适的名称确实不是一个简单的问题。因此，在这个问题上至少有一些约定可以减少开发者尝试想出合适名称的时间。此外，它们与*编码标准*一样，有助于减少认知摩擦。

编码规范有助于你团队中经验较少的开发者，或者那些刚开始的人，能够手头上有解决方案，否则他们可能需要在代码或互联网上搜索。它还有助于通过避免我们已经在*第三章**，*代码，不要做特技*中讨论的坏习惯，来编写可维护的代码。为了帮助你开始设置第一套规则，我们将在下一节给出一些示例。

## 编码规范示例

从一张空白（虚拟）纸开始是困难的，因此在这一节中，我们收集了一些现实世界的例子，这些例子可能是你编码规范的一部分。请注意，尽管这些规则基于最佳实践，但它们并不是完美的或唯一的真理。我们更希望为你提供一个良好的起点，用于讨论和示例，哪些主题应该通过编码规范来明确。

### 命名约定

通过使用**命名约定**，我们确保我们的代码中某些元素以统一和可理解的方式进行命名。这减少了认知摩擦，并使新团队成员的入职更容易。

#### 服务、存储库和模型

使用*大驼峰命名法*。使用类型作为后缀。

这里有一些示例：

+   `UserService`

+   `ProductRepository`

+   `OrderModel`

#### 事件

使用*大驼峰命名法*。使用正确的时态来表示事件是在实际事件之前还是之后触发的。

这里有一些示例：

+   `DeletingUser`是删除事件之前

+   `DeleteUser`是实际事件

+   `UserDeleted`是删除事件之后

#### 属性、变量和方法

使用*小驼峰命名法*。

这里有一些示例：

+   `$someProperty`

+   `$longerVariableName`

+   `$myMethod`

#### 测试

使用*小驼峰命名法*。使用单词*test*作为前缀。

这里有一些例子：

+   `testClassCanDoSomething()`

#### 特性

使用*UpperCamelCase*格式编写。使用形容词来描述特性用途。

这里有一些例子：

+   `Loggable`

+   `Injectable`

#### 接口

使用*UpperCamelCase*格式编写。使用单词*Interface*作为后缀。

这里有一些例子：

+   `WriterInterface`

+   `LoggerInterface`

### 一般 PHP 约定

即使你已经使用了*编码标准*如*PSR-12*，也有一些方面它们没有涵盖。我们将在本节中介绍其中的一些。

#### 注释和 DocBlocks

如果可能，避免使用注释，因为它们往往会过时，从而造成比帮助更大的困惑。仅保留那些不能被自解释的名称或简化代码所替代的注释，这样更容易理解，并且不再需要注释。

只有当 DocBlocks 提供信息时才添加，例如代码质量工具的注释。尤其是从 PHP 8 开始，大多数 DocBlocks 都可以被类型提示所替代，所有现代 IDE 都会理解。如果你使用类型提示，大多数 DocBlocks 都可以删除：

```php
// Redundant DocBlock
/**
 * @param int $property
 * @return void 
 */
public function setProperty(int $property): void { 
    // ... 
}
```

通常，IDE 会自动生成 DocBlocks。如果它们没有更新，它们至多是无用的，甚至可能是明显错误的：

```php
// Useless DocBlock
/**
 * @param $property
 */
public function setProperty(int $property): void { 
    // ... 
}
// Wrong DocBlock
/**
 * @param string $property
 */
public function setProperty(int $property): void { 
    // ... 
}
```

DocBlocks 仍然应该用于现在 PHP 语言特性无法提供的信息，例如指定数组内容，或标记函数为已弃用：

```php
// Useful DocBlock
/**
 * @return string[]
 */
public function getList(): array { 
    return [
       ‘foo’,
       ‘bar’,
    ]; 
}
/**
 * @deprecated use function fooBar() instead
 */
public function foo(): bool { 
    // ... 
}
```

关于 DocBlocks

DocBlocks 被引入，部分是为了弥补 PHP 早期版本中弱类型不足的缺点。这个事实上的标准是由`phpDocumentor`项目引入的([`www.phpdoc.org/`](https://www.phpdoc.org/))，因此得到了许多工具的支持，如 IDE 和静态代码分析器。尽管使用严格类型通常不再需要 DocBlocks，除非你希望在项目中使用`phpDocumentor`。

#### 三元运算符

每部分应单独一行编写以提高可读性。对于非常简短的语句可以例外：

```php
// Example for short statement
$isFoo ? ‘foo’ : ‘bar’;
// Usual notation
$isLongerVariable
    ? ‘longerFoo’
    : ‘longerBar’;
```

避免使用嵌套的三元运算符，因为它们难以阅读和调试：

```php
// Example for nested operators
$number > 0 ? ‘Positive’ : ($number < 0 ? ‘Negative’ :
‘Zero’);
```

#### 构造函数

对于 PHP 8+，使用**构造函数属性提升**来缩短类，如果工作在 PHP 8+上。在最后一个属性后保留尾随逗号，因为这将使得添加或注释行更容易：

```php
// Before PHP 8+
class ExampleDTO
{
    public string $name;
    public function __construct(
        string $name
    ) {
        $this->name = $name;
    }
}
// Since PHP 8+
class ExampleDTO
{
    public function __construct(
        public string $name, 
    ) {}
}
```

#### 数组

总是使用短数组表示法，并在最后一个条目后保留逗号（参见前面的*构造函数*部分，以获取解释）：

```php
// Old notation
$myArray = array(
    ‘first entry’,
    ‘second entry’
);
// Short array notation
$myArray = [
    ‘first entry’,
    ‘second entry’,
];
```

#### 控制结构

即使是一行代码也要使用括号。这减少了认知摩擦，并使得以后添加更多代码行更容易：

```php
// Bad
if ($statement === true)
    do_something();
// Good
if ($statement === true) {
    do_something();
}
```

避免使用`else`语句和尽早返回，因为这更易于阅读并减少了代码的复杂性：

```php
// Bad
if ($statement) {
    // Statement was successful
    return;
} else {
    // Statement was not successful
    return;
}
// Good
if (!$statement) {
    // Statement was not successful
    return;
}
// Statement was successful
return;
```

#### 异常处理

应避免使用空的`catch`块，因为它们会静默地吞咽错误信息，从而使得查找错误变得困难。相反，记录错误信息或至少写一个注释来解释为什么可以忽略异常：

```php
// Bad
try {
    $this->someUnstableCode();
} catch (Exception $exception) {}
// Good
try {
    someUnstableCode();
} catch (Exception $exception) {
    $this->logError($exception->getMessage());
}
```

### 架构模式

编码指南不仅限于如何格式化代码或命名元素。它们还可以帮助您从架构角度控制代码的编写。

#### 肥胖模型，苗条控制器

如果使用 MVC 模式，业务逻辑应该位于**模型**或类似的类中，例如**服务**或**仓库**。**控制器**应该包含尽可能少的代码，以接收或传输视图和模型之间的数据。

与框架无关的代码

在*肥胖模型，苗条控制器*方法中，您可能会遇到*框架无关的业务逻辑*这个术语。这意味着包含您的业务规则的代码应尽可能少地使用底层框架的功能。这使得框架更新或甚至迁移到其他框架变得更加容易。

#### 单一职责原则

类和方法应该只有一个职责。参见*第二章**，谁有权决定“良好实践”是什么？*，了解更多关于这个原则的信息。

### 框架指南

在这本书中，我们希望专注于编写 PHP 的干净代码。然而，通常您会与框架一起工作，尽管将它们包含在指南中也是必要的，但我们不想在这里过多地深入细节。

然而，接下来，您将找到一份问题列表，这将帮助您了解在指南中应包含哪些框架相关主题：

+   如何访问数据库

+   如何配置路由

+   如何注册新服务

+   在您的项目中如何处理身份验证？

+   应该如何记录错误或其他调试信息？

+   如何创建和组织视图文件

+   如何处理翻译

由于这些问题的答案高度依赖于所使用的框架，我们在这里不能给您提供推荐。您需要与您的团队一起制定指南。在下一节中，我们将为您提供一些关于如何做到这一点的想法。

## 设置指南

设置编码指南的过程需要时间，通常需要几个研讨会来讨论规则。这需要调解，例如，由技术负责人来执行；否则，您可能会陷入无休止的讨论中。

虽然您可能无法立即就所有主题达成一致，但请不要担心。提醒自己，您的团队成员有不同的背景、经验和技能水平——没有人会直接放弃他们个人的编码方式，仅仅因为突然出现了他们不理解或不接受的规则。

确保设置一个定期检查指南是否需要更新的流程。也许随着时间的推移，某些规则会过时，或者必须包含新的语言特性。在定期举行的团队会议中的行动点将是一个很好的机会来做这件事。

指南应以书面形式轻松获取，例如在维基或公司的内部知识库中，它应该能够跟踪版本历史。每个团队成员都应该能够对其发表评论，以便尽快处理问题或问题。最后，所有团队成员都应该自动收到关于新更改的通知。

一旦你的团队就一套规则达成一致，确保利用你在前面章节中学到的代码质量工具自动检查这些规则是否得到遵守。例如，你可以使用 *PHPStan* 来检测空的 `catch` 块，或者使用 *PHPMD* 来强制执行 `if` 而不使用 `else`。

我们如何确保我们的编码规范得到应用？显然，我们应该尽可能使用我们的代码质量工具。但如果这些工具不包括我们想要强制执行的规则呢？通过一点互联网研究，你可能会找到它们的第三方实现。或者，如果你找不到任何东西，你也可以自己编写自定义规则，因为所有静态代码分析器都是可扩展的。

对于太复杂而无法自动检查的规则，我们必须手动检查它们是否被正确使用。这可以在代码审查中发生，我们认为它们如此重要，以至于它们值得在这一章中拥有自己的部分。

如果你不能确保它们得到遵守，仅仅设置编码规范将只是浪费时间。我们可以自动化检查所有与编码风格相关的规则，以及相当数量的编码规范。但到目前为止，对于那些针对框架规范或架构方面的规则，自动化不再可能，我们必须人类介入，接管检查。在这个时候，代码审查就派上用场了。让我们在下节中更详细地探讨。

# 代码审查

手动检查其他开发者的代码的过程称为 **代码审查**。这包括所有更改，即不仅包括新功能，还包括错误修复甚至简单的配置更改。

审查通常由至少一位同行开发者完成，并且通常发生在 `main` 分支的上下文中；只有当审查者批准更改时，它们才会成为实际应用程序的一部分。

在本节中，我们将讨论你在代码审查中应该寻找什么，为什么它们如此重要，以及它们应该如何进行，以便使它们成为你工具箱中的成功工具。

## 为什么你应该进行代码审查

这可能听起来有点明显，因为这正是整本书的主题。然而，这一点不能被强调得足够——代码审查将提高你代码的质量。让我们更仔细地考察一下为什么：

+   **易于引入**：引入代码审查通常没有额外的成本（除了所需的时间）。所有主要的 Git 代码库服务，如 **Bitbucket**、**GitLab** 或 **GitHub**，都内置了内置的审查功能，你可以立即使用。

+   **快速影响**：代码审查不仅易于引入，而且一旦引入，它们很快就会显示出其有用性。

+   **知识分享**：由于代码审查经常导致开发者之间的讨论，因此它们是传播团队中最佳实践知识的一个很好的工具。当然，初级开发者尤其是会从指导中受益匪浅，但即使是经验丰富的开发者有时也会学到新东西。

+   **持续改进**：定期的讨论将导致编码指南的改进，因为它们会不断受到挑战和更新，如果需要的话。

+   **尽早避免问题**：代码审查在流程的早期阶段进行（参见*第十一章*，*持续集成*），因此很可能会在代码甚至达到测试环境之前就发现错误、安全问题或架构问题。

如果你还没有确信代码审查的好处，请查看下一节，我们将更详细地讨论代码审查应涵盖的内容——以及不应涵盖的内容。

## 代码审查应涵盖哪些内容

在进行代码审查时，我们应该检查哪些方面？

+   **代码设计**：代码是否设计良好且与应用程序的其他部分保持一致？它是否遵循通用的最佳实践，例如可重用性、设计模式（参见下一节）或**SOLID**设计原则（参见*第二章**，谁有权决定“良好实践”是什么？）？

+   **功能性**：代码是否执行了它应该执行的操作，或者是否有任何副作用？

+   **可读性**：代码是否易于理解，还是过于复杂？注释是否必要？通过重命名函数或变量，或者将代码提取到具有有意义名称的函数中，是否可以提高可读性？

+   **安全性**：代码是否引入了潜在的攻击向量？所有输出是否都已转义以防止 XSS 攻击？数据库输入是否已清理以避免 SQL 注入？

+   **测试覆盖率**：新代码是否被自动化测试覆盖？它们是否测试了正确的事情？是否需要更多的测试用例？

+   **编码标准和指南**：代码是否遵循团队商定的*编码标准*和编码指南？

你的团队还应考虑是否应该在本地开发环境中测试代码是否是审查过程的一部分。然而，对此并没有明确的建议。

## 代码审查的最佳实践

尽管代码审查有许多好处并且可以相当容易地实施，但还有一些陷阱你应该注意，以及一些使审查更加成功的既定最佳实践。

### 谁应该审查代码？

首先，谁应该理想地做 *代码审查*？当然，这也取决于你的设置。如果你与另一位 PHP 开发者一起工作，那么这个人应该是第一个被询问的人。这样，你可以建立起共享的领域知识；尽管你的同事没有直接处理你的工单，但他们至少能了解你做了什么。

然而，时不时地联系其他团队（如果有）的成员可以避免陷入孤立，并促进知识共享。如果你对某些主题不确定，可以向领域专家寻求帮助。这通常包括性能、架构或安全相关的更改。

### 自动化

代码审查不应该涵盖的是是否遵守了 *编码标准*。在*第七章**，代码质量工具*中，我们介绍了自动执行此操作的必要工具，而在*第十一章**，持续集成*中，我们将它们集成到了**持续集成管道**中。

确保只有那些所有检查（例如 *代码嗅探器、代码分析器和自动化测试*）都通过了的拉取请求才被审查。否则，你将花费大量时间在甚至不应该讨论的话题上。

### 避免长时间的代码审查

需要审查的代码更改应该有多少行？研究表明，200 到 400 行应该是最大值，因为随着时间的推移，审查者的注意力会逐渐下降。因此，尽量保持单个更改相对较小。对于长串的差异，审查者找到时间审查较小的更改的可能性也更大。

代码审查，即使是较小的，也会占用审查者无法编写代码的时间。但应该花多少时间？同样，这取决于你的设置。一个合理的估计是，最多 60 分钟，以避免审查者的疲劳。为审查者提供足够的空间逐行审查代码。审查应该被视为你日常工作的一部分，否则它们会迅速变成负担，所以没有人应该匆忙完成它们。

### 保持人性

如何制定反馈对于使审查成功至关重要。注意你的语气，并尽量避免像“*这是错的*！”或绝对不行的“*这是愚蠢的*。”这样的指责。开发者，尤其是经验较少的开发者，不应该急于让他们的代码被审查。

记住，有人会阅读你的评论。如果你从“我”的角度来写，通常效果很好，例如，“*我不理解这一行，你能解释一下吗？*”或“*我认为我们也可以这样做...”*

不要忘记利用审查来表扬做得好的部分。一个快速的“*好主意！*”或“*我真的很喜欢你的方法*”或“*感谢代码清理*”表明你对其他开发者工作的赞赏，并增加了他们的动力。

通常，代码审查是通过在您使用的 Git 平台上写评论来完成的。但当然，你也可以面对面地进行。一些开发者更欣赏直接的反馈，而不是仅仅的评论，因为书面文本缺乏很多元信息，如语气或面部表情。

### 不要过度，但也不要粗心大意

记住**帕累托原则**，不要过度行事。也许代码中还有一些小部分你可能想要更改，但它们并不是明显错误的，因为它们遵循了所有团队标准。编程仍然是一个个人风格的问题，在代码审查中无休止的讨论将导致挫败感而没有任何进一步的好处。

但是，不要接受会降低整体系统健康度的更改。如果你确信某个更改是有害的或违反了编码指南，你必须不批准这些更改。如果有疑问，请让另一位开发者参与。

### 拥抱变化

最后，如果你觉得在审查中讨论的问题应该包含在指南中，记下来并在下次团队会议上提出，不要直接提及其他开发者。也许你是对的，指南将会被修改以避免未来出现类似问题。

但你也有可能错了，而团队的其他成员并不认为这是一个问题。如果你无法提出令人信服的论据和例子，你必须接受这些决定。

## 确保代码审查得到执行

在紧张的工作日中，面对高优先级的错误修复和紧迫的截止日期，很容易忘记进行代码审查。幸运的是，所有 Git 服务提供商都提供了一些功能来帮助你：

+   如果他们至少获得了一个批准，则启用`main`分支。你绝对应该启用此功能。

+   **轮换审查**：如果你的团队规模较大，尝试不要总是从同一个人那里请求审查。一些工具甚至允许随机为你选择审查者。

+   **使用检查清单**：检查清单已被证明是有用的，因此你也应该使用它们。为代码审查中需要检查的所有方面设置一个检查清单。在下一节中，我们将展示如何确保它得到使用。

## 完成定义

如果你使用**敏捷方法**工作，你可能已经听说过**完成定义**这个术语。在这里，团队同意在任务完成前应该执行的一系列行动。

典型的**完成定义**包含检查，例如是否编写了测试或更新了文档。你可以利用这一点来进行代码审查。

再次强调，我们的 Git 工具通过提供拉取请求（也称为**合并请求**）模板来帮助我们。这些文本将被用来自动预填充拉取请求的描述。

这具体如何操作取决于你使用的软件，所以我们在这里无法提供确切的操作指南。然而，以下文本展示了它可能的样子：

```php
# Definition of Done
## Reviewer 
[ ] Code changes reviewed
    1\. Coding Guidelines kept
    2\. Functionality considered
    3\. Code is well-designed
    4\. Readability and Complexity considered
    5\. No Security issues found
    6\. Coding standard and guidelines kept
[ ] Change tested manually
## Developer 
[ ] Acceptance Criteria met
[ ] Automated Tests written or updated
[ ] Documentation written or updated
```

检查清单中包含的内容由你和你的团队决定。如果用作模板，这些项目将默认出现在拉取请求描述中。它的目的是供审阅者和开发者使用，以便在批准拉取请求并将其合并到`main`分支之前不会忘记需要完成的事情。

一些工具，如 GitHub，使用**Markdown**风格的标记语言来处理这些模板。它们将在浏览器中将复选框（每个项目前的两个方括号）显示为可点击的复选框，并跟踪它们是否被点击。哇！无需太多工作，你就已经设置了一个易于使用且有用的检查清单！

## 代码审查总结

我们希望这一节能让你对代码审查如何对你的团队和你自己有益有更深的理解。由于它们可以轻松引入，所以值得一试。本节中的最佳实践将帮助你避免代码审查可能带来的某些问题。

但是，就像往常一样，它们也有一些缺点：审查需要花费大量时间，并且可能导致团队成员之间的冲突。我们坚信，所花费的时间是值得的，因为积极方面远远超过了消极方面。冲突很可能会发生，而审查只是释放压力的一种方式。如果你在团队中工作，这无法完全避免，但应该尽早与你的经理讨论。这是他们的工作，处理这类问题。

在本章的最后部分，我们将更详细地探讨设计模式。它们可以作为解决软件开发中一般问题的指南。

# 设计模式

**设计模式**是软件开发中经常出现的问题的常用解决方案。作为一名开发者，你迟早会遇到这个术语，即使你之前还没有——这并非没有原因，因为这些模式基于最佳实践，并且已经证明了它们的实用性。

在本节中，我们将告诉你更多关于不同类型的设计模式以及为什么它们如此重要，以至于成为本书的一部分。此外，我们还将介绍一些在 PHP 中广泛使用的常见设计模式。

## 理解设计模式

让我们更深入地了解设计模式。它们可以被视为解决特定问题的模板，并且根据它们提供的解决方案命名。例如，在本章中，你将了解**观察者模式**，这可以帮助你实现观察对象变化的方式。这在编写代码时非常有用，同样在与其他开发者设计软件时也很方便。使用简短的名字来命名一个概念，而不是每次都要解释它，要容易得多。

尽管如此，不要将设计模式与算法混淆。算法定义了需要遵循的明确步骤来解决一个问题，而设计模式描述了如何在更高层次上实现解决方案。它们不受任何编程语言的限制。

你也不能像添加 Composer 包那样将设计模式添加到你的代码中。你必须自己实现模式，并且你在实现方式上有一定的自由度。

然而，设计模式并非解决所有问题的唯一方案，它们也不声称提供最有效的解决方案。始终对这些模式持保留态度——通常，开发者只是因为知道某个模式而想要实现它。或者，正如俗话所说：“*如果你只有一把锤子，那么一切看起来都像钉子。”*

通常，设计模式被分为三个类别：

+   **创建型模式**处理如何高效地创建对象，同时提供减少代码重复的解决方案

+   **结构型模式**帮助你在灵活且高效的结构中组织实体（即类和对象）之间的关系

+   **行为型模式**在保持高灵活性度的同时安排实体之间的通信

在接下来的页面中，我们将查看一些示例实现来解释*设计模式*背后的理念。

## PHP 中的常见设计模式

现在，我们想介绍 PHP 世界中一些最广泛使用的模式。我们从三个类别**创建型**、**结构型**和**行为型**中各选择了一个模式，这些模式我们在上一节中讨论过。

### 工厂方法

想象以下问题：你需要编写一个应用程序，该应用程序应该能够使用不同的格式将数据写入文件。在我们的例子中，我们希望支持**CSV**和**JSON**，但未来也可能支持其他格式。在数据写入之前，我们希望应用一些过滤，这应该始终发生，无论选择哪种输出格式。

解决这个问题的适用模式将是**工厂方法**。它是一个创建型模式，因为它涉及对象的创建。

这个模式的主要思想是子类可以实现不同的方式来实现目标。需要注意的是，我们在父类中没有使用`new`运算符来实例化任何子类，如下面的类所示：

```php
abstract class AbstractWriter
{
    public function write(array $data): void
    {
        $encoder = $this->createEncoder();
        // Apply some filtering which should always happen, 
        // regardless of the output format.
        array_walk(
            $data,
            function (&$value) {
                $value = str_replace(‘data’, ‘’, $value);
            }
        );
        // For demonstration purposes, we echo the result
        // here, instead of writing it into a file
        echo $encoder->encode($data);
    }
    abstract protected function createEncoder(): Encoder;
}
```

注意`createEncoder`方法——这是赋予模式名称的工厂方法，因为它在某种程度上充当了新实例的工厂。它被定义为抽象函数，因此需要由一个或多个子类实现。

为了足够灵活以适应未来的格式，我们打算为每种格式使用单独的`Encoder`类。但首先，我们为这些类定义一个接口，以便它们可以轻松交换：

```php
interface Encoder
{
    public function encode(array $data): string;
}
```

然后，我们为每种格式创建一个实现`Encoder`接口的`Encoder`类；首先，我们创建`JsonEncoder`：

```php
class JsonEncoder implements Encoder
{
    public function encode(array $data): string
    {
        // the actual encoding happens here
        // ...
        return $encodedString;
    }
}
```

然后我们创建 `CsvEncoder`：

```php
class CsvEncoder implements Encoder
{
    public function encode(array $data): string
    {
        // the actual encoding happens here
        // ...
        return $encodedString;
    }
}
```

现在，我们需要为每个我们想要支持的格式创建一个 `AbstractWriter` 类的子类。在我们的例子中，首先是 `CsvWriter`：

```php
class CsvWriter extends AbstractWriter
{
    public function createEncoder(): Encoder
    {
        $encoder = new CsvEncoder();
        // here, more configuration work would take place
        // e.g. setting the delimiter
        return $encoder;
    }
}
```

其次是 `JsonWriter`：

```php
class JsonWriter extends AbstractWriter
{
    public function createEncoder(): Encoder
    {
        return new JsonEncoder();
    }
}
```

请注意，这两个子类只重写了工厂方法 `createEncoder`。`new` 操作符只出现在子类中。`write` 方法保持不变，因为它是从 `AbstractWriter` 继承而来的。

最后，让我们将这些内容组合到一个示例脚本中：

```php
function factoryMethodExample(AbstractWriter $writer)
{
    $exampleData = [
        ‘set1’ => [‘data1’, ‘data2’],
        ‘set2’ => [‘data3’, ‘data4’],
    ];
    $writer->write($exampleData);
}
echo "Output using the CsvWriter: ";
factoryMethodExample(new CsvWriter());
echo "Output using the JsonWriter: ";
factoryMethodExample(new JsonWriter());
```

`factoryMethodExample` 函数首先接收 `CsvWriter` 参数，在第二次运行时接收 `JsonWriter` 参数。输出将如下所示：

```php
Output using the CsvWriter:
3,4
1,2

Output using the JsonWriter:
[["3","4"],["1","2"]]
```

工厂方法模式使我们能够将 `Encoder` 类的实例化从 `AbstractWriter` 父类移动到子类中。通过这样做，我们避免了 `Writer` 和 `Encoder` 之间的紧密耦合，获得了更大的灵活性。作为缺点，代码变得更加复杂，因为我们必须引入接口和子类来实现这个模式。

### 依赖注入

我们接下来要介绍的模式是一个名为 **依赖注入**（**DI**）的结构模式。它通过在构造时将依赖项插入到类中，而不是在类内部实例化它们，帮助我们实现松散耦合的架构。

以下代码展示了如何在构造函数中实例化一个依赖项，在这个例子中是一个经典的 **Logger**：

```php
class InstantiationExample
{
    private Logger $logger;
    public function __construct()
    {
        $this->logger = new FileLogger();
    }
}
```

代码本身运行得很好，但问题出现在你想要用不同的类替换 `FileLogger` 时。尽管我们已经在 `$logger` 属性中使用了 `Logger` 接口，理论上这使得它容易与另一个实现交换，但我们已经在构造函数中硬编码了 `FileLogger`。现在，想象一下你几乎在每一个类中都使用了那个日志记录器；用不同的 `Logger` 实现替换它需要一些努力，因为你必须触及使用它的每一个文件。

无法替换 `FileLogger` 也使得为该类编写 **单元测试** 更加困难。你不能用模拟对象替换它，但在测试运行期间你也不想将信息写入实际的日志。如果你想测试日志是否正确工作，你必须将一些工作区间的代码构建到你的生产代码中。

依赖注入（DI）迫使我们思考在类中应该使用哪些依赖项，以及使用多少。当构造函数接受的依赖项参数数量明显超过三个或四个时，这被认为是一种 **代码异味**（即，表示代码结构不良的指标），因为它表明该类违反了 **单一职责原则**（SOLID 中的“**S**”）。这也被称为 **范围蔓延**：类的范围随着时间的推移逐渐但稳步增大。

让我们看看依赖注入如何解决之前提到的问题：

```php
class ConstructorInjection
{
    private Logger $logger;
    public function __construct(Logger $logger)
    {
        $this->logger = $logger;
    }
}
```

构造函数属性提升

请注意，我们在这里故意没有使用构造函数属性提升，以获得更好的可视化效果。

与之前的代码相比，差异似乎并不大。我们只是将`Logger`实例作为参数传递给构造函数，而不是直接在那里实例化。然而，好处是巨大的：我们现在可以更改要注入的实例（如果它实现了`Logger`接口），而无需触及实际类。

假设你不再希望类将日志记录到文件系统，而是记录到`GraylogLogger`，它也实现了`Logger`接口，但将日志写入该系统而不是写入文件。然后，你只需将`GraylogLogger`注入到所有应该使用它的类中即可——恭喜你，你刚刚改变了应用程序记录信息的方式，而无需触及实际类。

同样，我们可以在单元测试中轻松地用一个模拟对象替换依赖。这在可测试性方面是一个巨大的改进。

然而，无论你选择哪种实现方式，`Logger`的实例化仍然需要在其他地方发生。我们只是将其从`InjectionExample`类中移出。依赖注入发生在类实例化时：

```php
$constructorInjection = new ConstructorInjection(
     new FileLogger()
);
```

通常，你会在`Factory`类中找到这种类型的实例化。这是一个实现例如**简单工厂**模式的类，其唯一任务是创建特定类的实例，并带有所有必要的依赖项。

简单工厂模式

我们在这本书中不会更详细地讨论这个模式，因为它真的很简单。你可以在这里找到更多关于它的信息：[`designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html`](https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html)。

注入不一定要通过构造函数进行。另一种可能的方法是所谓的**setter 注入**：

```php
class SetterInjection
{
    private Logger $logger;
    public function __construct()
    {
        // ....
    }
    public function setLogger(Logger $logger): void
    {
        $this->logger = $logger;
    }
}
```

依赖注入将通过`setLogger`方法进行。与`Factory`类相同。

以下是一个这样的**工厂**可能的样子：

```php
class SetterInjectionFactory
{
    public function createInstance(): SetterInjection
    {
        $setterInjection = new SetterInjection();
        $setterInjection->setLogger(new FileLogger());
        return $setterInjection;
    }
}
```

#### 依赖注入容器

你可能已经想知道如何管理所有必要的工厂，尤其是在一个较大的项目中。为此，发明了**DI 容器**。它不是 DI 模式的一部分，但与之密切相关，因此我们在这里介绍它。

DI 容器充当所有通过 DI 模式引入其目标类的对象的中央存储库。它还包含实例化对象所需的所有必要信息。

它还可以存储创建的实例，因此不需要重复实例化。例如，你不会为每个使用它的类创建一个`FileLogger`实例，因为这会导致大量相同的实例。你更希望只创建一次，然后通过引用传递给目标类。

DI 容器

展示现代 DI 容器所有功能会超出本书的范围。如果你对了解这个概念感兴趣，我们建议你查看`phpleague/container`包：[`container.thephpleague.com`](https://container.thephpleague.com)。它体积小但功能丰富，拥有优秀的文档，可以介绍你更多令人兴奋的概念，如服务提供者或屈折词。

现今，DI（依赖注入）容器的概念已被所有主要的 PHP 框架所采用，因此你很可能已经使用过这样的容器了。你可能没有注意到它，因为通常它隐藏在你的应用程序的深处，有时也被称为**服务容器**。

PSR-11 – 容器接口

DI 容器对 PHP 生态系统来说非常重要，以至于它拥有自己的 PSR：[`www.php-fig.org/psr/psr-11`](https://www.php-fig.org/psr/psr-11)。

### 观察者

本书要介绍的最后一个模式是**观察者模式**。作为一种**行为模式**，其主要目的是允许对象之间进行高效的通信。一个常见的实现任务是，当一个对象的状态发生变化时，在另一个对象上触发某个动作。状态变化可能只是类属性值的改变这么简单。

让我们再举一个例子：每当客户取消订阅时，你必须向销售团队发送一封电子邮件，以便他们得到通知并采取措施留住客户。

你最好怎么做？例如，你可以设置一个定期任务，在特定的时间间隔内（例如，每 5 分钟）检查是否有任何取消操作。这会起作用，但根据你的客户群规模，这个任务可能大部分时间都不会返回任何结果。另一方面，如果两次检查之间的间隔太长，你可能会错过宝贵的时间直到下一次检查。

现在，销售可能不是世界上最重要的事情（销售人员通常不同意这一点），但你应该明白了。如果我们能在客户取消订阅时立即发送电子邮件，那不是很好吗？所以，而不是定期检查变化，我们只在变化发生时得到通知？

代码可能看起来像这个简化的例子：

```php
class CustomerAccount
{
    public function __construct(
        private MailService $mailService
    ) {}
    public function cancelSubscription(): void
    {
        // Required code for the actual cancellation
        // ...
        $this->mailService->sendEmail(
            ‘sales@example.com’,
            ‘Account xy has cancelled the subscription’
        );
    }
}
```

简化示例

这个例子已经被简化了。例如，你不应该硬编码电子邮件地址。

这种方法当然会起作用，但它有一个缺点：`MailService`的调用被直接编码到类中，因此与它紧密耦合。现在，`CustomerAccount`类必须关心另一个依赖项，这增加了维护工作量，例如，测试必须扩展。如果我们以后不想再发送这封电子邮件，甚至要发送给其他部门的额外电子邮件，`CustomerAccount`类又必须再次更改。

使用松耦合的方法，`CustomerAccount`对象将只存储一个列表，该列表包含在发生更改时应通知的其他对象。这个列表不是硬编码的，需要得到通知的对象必须在引导阶段附加到该列表。

我们想要观察的对象（在前面的例子中是`CustomerAccount`），被称为**主题**。主题负责通知**观察者**。在主题上添加或删除观察者不需要任何代码更改，所以这种方法非常灵活。

以下代码显示了`CustomerAccount`类如何实现**观察者**模式的示例：

```php
use SplSubject;
use SplObjectStorage;
use SplObserver;
class CustomerAccount implements SplSubject
{
    private SplObjectStorage $observers;
    public function __construct()
    {
        $this->observers = new SplObjectStorage();
    }
    public function attach(SplObserver $observer): void
    {
        $this->observers->attach($observer);
    }
    public function detach(SplObserver $observer): void
    {
        $this->observers->detach($observer);
    }
    public function notify(): void
    {
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }
    public function cancelSubscription(): void
    {
        // Required code for the actual cancellation
        // ...
        $this->notify();
    }
}
```

在这里发生了很多事情，所以让我们一点一点地过一遍。首先值得注意的是，这个班级使用了`SplSubject`和`SplObserver`接口，以及`SplObjectStorage`类。由于`CustomerAccount`类实现了`SplSubject`接口，它必须提供`attach`、`detach`和`notify`方法。

我们还使用构造函数来初始化`$observers`属性为`SplObjectStorage`，这将存储`CustomerAccount`类的所有观察者。幸运的是，SPL 已经提供了这个存储的实现，所以我们不需要自己来做。

标准 PHP 库

我们在*第三章**，代码质量指标*中已经讨论了**标准 PHP 库**（**SPL**）。SPL 包括这些实体表明了观察者模式的重要性以及这个库的有用性。

`attach`和`detach`方法是由`SplSubject`接口要求的。它们用于添加或删除观察者。它们的实现很简单——我们只需要在两种情况下将`SplObserver`对象转发到`SplObjectStorage`，它就会为我们完成必要的工作。

`notify`方法必须调用存储在`SplObjectStorage`中的所有`SplObserver`对象的`update`方法。这就像使用`foreach`循环遍历所有`SplObserver`条目并调用它们的`update`方法，传递一个引用到主题使用`$this`。

以下代码显示了这样一个观察者可能的样子：

```php
class CustomerAccountObserver implements SplObserver
{
    public function __construct(
        private MailService $mailService
    ) {}
    public function update(CustomerAccount|SplSubject
      $splSubject): void
    {
        $this->mailService->sendEmail(
            ‘sales@example.com’,
            ‘Account ‘ . $splSubject->id . ‘ has cancelled
              the subscription’
        );
    }
}
```

毫不奇怪，观察者实现了`SplObserver`接口。唯一需要的方法是`update`，它会在`notify`方法中被主题调用。由于接口要求使用`$splSubject`参数来实现`SplSubject`接口，我们必须使用该参数类型提示。否则会导致 PHP 错误。

由于我们知道在这种情况下，对象实际上是一个`CustomerAccount`对象，我们还可以添加这个类型提示。这将使我们的 IDE 能够帮助我们完成正确的代码补全；尽管如此，添加它并不是必需的。

如您所见，现在所有关于发送电子邮件的逻辑都已经移动到了`CustomerAccountObserver`中。换句话说，我们成功地消除了`CustomerAccount`和`MailService`之间的紧密耦合。

我们最后需要做的是附加`CustomerAccountObserver`：

```php
$mailService = new MailService();
$observer = new CustomerAccountObserver($mailService);
$customerAccount = new CustomerAccount();
$customerAccount->attach($observer);
```

同样，这个代码示例被简化了。在实际应用中，所有三个对象都会在专门的工厂中实例化，并通过 DI 容器组合在一起。

观察者模式可以帮助你通过相对较少的工作量解耦对象。尽管如此，它也有一些缺点。观察者更新的顺序无法控制；因此，你不能用它来实现顺序至关重要的功能。其次，通过解耦类，仅通过查看代码就不再明显知道哪些观察者被附加到它上。

总结一下设计模式的话题，我们将看看那些至今仍然相当常见但已经证明有太多显著缺点而不被推荐的模式。帷幕拉开，反模式登场！

## 反模式

并非每个设计模式都经得起时间的考验。一切都在发展，软件开发和 PHP 也是如此。一些在过去取得成功的模式已经被更新和/或更好的版本所取代。

几年前解决某个问题的标准方法可能现在已经不再是正确的解决方案了。PHP 社区一直在学习和改进，但这种知识尚未均匀分布。因此，为了更明显地指出哪些模式应该避免，它们通常被称为反模式——这显然听起来像是你不希望出现在代码中的东西，对吧？

这样的反模式是什么样的呢？让我们看看第一个例子。

### 单例

在依赖注入（DI）在 PHP 世界中变得越来越流行之前，我们早已必须处理如何有效地创建实例以及如何使它们在其他类的范围内可用的问题。单例模式提供了一个快速且简单的解决方案，通常看起来是这样的：

```php
$instance = Singleton::getInstance();
```

静态的`getInstance`方法非常简单：

```php
class Singleton
{
    private static ?Singleton $instance = null;
    public static function getInstance(): Singleton
    {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }
}
```

如果方法被执行，会检查该类的实例是否已经被创建。如果是，它将被返回；如果不是，它将事先创建。这种方法也被称为**延迟初始化**。在这里，懒惰是个好事，因为它只有在需要时才会初始化，所以节省了资源。

该方法还将在静态的`$instance`属性中存储新的实例。这一点很引人注目，因为这种方法的实现仅因为静态属性可以在没有要求类实例的情况下具有值。换句话说，我们可以在其自己的类定义中存储类的实例。此外，在 PHP 中，所有对象都是通过引用传递的，即指向内存中对象的指针。这两个特性帮助我们确保总是返回相同的实例。

单例模式实际上相当优雅；因为它也使用静态方法，所以不需要`Singleton`类的实例。这样，它可以在你的代码的任何地方直接执行，而不需要任何进一步的准备。

易用性是单例最终成为反模式的主要原因之一，因为它会导致**范围蔓延**。我们在关于依赖注入的部分中解释了这个问题。

另一个问题在于可测试性：用模拟对象替换实例非常困难，因此为使用单例模式的代码编写单元测试变得更加复杂。

现在，您应该使用依赖注入与依赖注入容器一起使用。它不如单例模式容易使用，但反过来这又帮助我们三思而后行，在类中使用另一个依赖项之前。

然而，这并不意味着单例模式根本不能使用。可能存在有效的理由来实现它，或者至少在遗留项目中保留它。只是要意识到风险。

### 服务定位器

可能被认为有问题的第二个模式是**服务定位器**：

```php
class ServiceLocatorExample
{
    public function __construct(
        private ServiceLocator $serviceLocator
    ) {}
    public function fooBar(): void
    {
        $someService = $this->serviceLocator
          ->get(SomeService::class);
        $someService->doSomething();
    }
}
```

在这个示例类中，我们在对象的构造时注入`ServiceLocator`。然后在整个类中使用它来获取所需的依赖项。在这方面，依赖注入和服务定位器都是**依赖倒置**原则（**SOLID**中的“**D**”）的实现：它们将控制其依赖项的范围移出类作用域，帮助我们实现松散耦合的架构。

但是，如果我们只需要注入一个依赖项而不是多个，这不是一个好主意吗？嗯，服务定位器模式的缺点是它将类的依赖项隐藏在`ServiceLocator`实例后面。而使用依赖注入时，您可以通过查看构造函数清楚地看到使用了哪些依赖项，但在仅注入`ServiceLocator`时您无法做到这一点。

与依赖注入不同，它不会强迫我们质疑一个类中应该使用哪些依赖项，因为对于较大的类，您很快就会失去对类中使用了哪些依赖项的总体了解。这基本上是我们为单例模式识别出的主要缺点之一。

再次强调，我们不想在*服务定位器*模式的使用上过于教条。可能存在一些情况下使用它是合适的——只是要小心处理。

# 摘要

在本章中，我们讨论了标准和规范的重要性。编码规范帮助您与同行开发者就代码的格式达成一致，并且您了解了值得采用的一些现有标准。

编码规范有助于您的团队就如何编写软件达成一致。尽管这些规范对每个团队来说都非常个性化，但我们为您提供了一套良好的示例和最佳实践，以构建您团队的规范。通过代码审查，您也知道如何保持质量。

最后，我们向您介绍了设计模式的世界。我们相信，至少了解这些模式的大部分内容将帮助您与团队成员一起设计和编写高质量的代码。关于这个主题还有更多可以探索的，您将在本章末尾找到一些优秀资源的链接。

这几乎结束了我们关于 PHP 中清洁代码多方面内容的激动人心的旅程。我们确信你现在迫不及待地想要尽快将所有新知识应用到日常工作中。然而，在你这样做之前，请耐心等待最后一章，我们将讨论文档的重要性。

# 进一步阅读

+   [`google.github.io/eng-practices/review`](https://google.github.io/eng-practices/review) 提供了更多关于谷歌的 *代码审查* 流程的信息

+   关于 PHP 中 *设计模式* 的有用资源：

    +   [`refactoring.guru/design-patterns/adapter/php/example`](https://refactoring.guru/design-patterns/adapter/php/example)

    +   [`sourcemaking.com/design_patterns/adapter/php`](https://sourcemaking.com/design_patterns/adapter/php)

    +   [`designpatternsphp.readthedocs.io/en/latest/README.html`](https://designpatternsphp.readthedocs.io/en/latest/README.html)
