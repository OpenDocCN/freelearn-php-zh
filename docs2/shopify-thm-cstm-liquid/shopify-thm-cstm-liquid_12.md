# 第九章：评估

# *第一章*，Shopify 入门

# 问题 1

合作伙伴计划是什么？

# 答案

合作伙伴计划是由 Shopify 创建的一个平台，汇集了来自世界各地的人们。通过这个平台，我们可以为店主构建新的电子商务商店，设计主题，开发应用程序，向 Shopify 推荐新客户，最重要的是，为我们自己创建一个用于练习的开发商店。我们可以在“如何开始？”主题中提醒自己这一点。

# 问题 2

我们如何禁用开发类型商店的密码保护？

# 答案

我们可以通过点击位于“主题”部分横幅中的**查看存储密码**按钮，或者在“在线商店”部分下选择**在线商店**并随后点击展开下拉菜单中的**偏好设置**来禁用我们的密码保护存储。一旦进入，我们可以轻松地移除常规商店的密码保护。然而，由于我们的商店处于开发模式，此选项目前已被禁用。我们可以在“理解主题结构”主题下的**侧边栏**子主题中提醒自己这一点。

# 问题 3

布局和模板目录文件有什么区别？

# 答案

**布局**目录是我们主题的主要目录。它包含基本文件，并且是所有其他文件（包括模板文件）将渲染的地方。模板文件是一组文件，允许我们一次性轻松创建和管理多个页面的外观。我们可以在“理解主题结构”主题下的**侧边栏**子主题中提醒自己这一点。

# 问题 4

在什么情况下，新的模板文件将在你页面的管理员部分可见？

# 答案

考虑到 Shopify 的管理端只能从当前发布的主题中读取值，我们必须满足两个条件。除了创建一个新的模板文件外，我们还需要确保相同的模板文件存在于当前正在运行的主题中，或者发布我们的副本主题。我们可以在“理解主题结构”主题下的**模板**子主题中提醒自己这一点。

# 问题 5

什么类型的文件以及在什么条件下允许我们访问父文件作用域内的变量？

# 答案

**片段**文件允许我们通过引用它们的名称在**模板**/**部分**中重用重复的代码片段。除了允许我们重用代码的部分外，**片段**还将使我们能够访问作为参数传递给片段的变量所在的父元素内的变量。

# *第二章*，Liquid 的基本流程

# 问题 1

如果我们期望输出结果，我们应该使用哪种分隔符？

# 答案

如果我们期望从 Liquid 代码中获取输出，我们应该使用双括号分隔符，因为我们只有在执行特定逻辑时才应该使用带百分比的括号。我们可以在“*理解 Liquid 及其分隔符*”部分提醒自己。

# 问题 2

以下条件语句的结果是什么，为什么？

```php
{% if collection.all_products_count > "20" %}
  The number of products in a collection is greater 
   than 20!
{% endif %}
```

# 答案

考虑到`collection.all_products_count`默认返回一个数字作为其值，而我们比较的值是一个字符串，因为它被括号封装。由于我们不能比较不同类型的数据，条件语句将返回`false`，我们的消息将不会显示。我们可以在“*学习比较运算符*”部分提醒自己。

# 问题 3

访问数组内部元素有两种方法是什么？

# 答案

我们可以使用两种方法来访问数组内部的元素。第一种方法允许我们使用一个项目的索引位置来恢复我们正在寻找的确切项目，而第二种方法允许我们遍历数组中的所有项目。我们可以在“*Array*子节”中提醒自己，在“*理解数据类型*”部分。

# 问题 4

使用句柄访问对象的方法是什么？

# 答案

我们可以通过将我们要访问的对象的名字复数化，然后跟一个方括号（`[]`）或点（`.`）表示法来通过其句柄访问对象。这两种访问对象的方法都是正确的。然而，它们各自有其用途。我们可以在“*EmptyDrop*子节”中提醒自己，在“*理解数据类型*”部分。

# 问题 5

以下代码块中存在两个问题是什么？

```php
{% if customer != nil %}
  Welcome {{- customer.name -}} !
{% endif %}
```

# 答案

由于 nil 是一个特殊的数据类型，它返回一个空值，因此它没有可视化的表示，这是第一个问题。我们可以在“*Nil*子节”中提醒自己，在“*理解数据类型*”部分。第二个问题是我们在`customer.name`输出的两侧都添加了一个连字符。虽然输出右侧的连字符会清除感叹号前的多余空格，但我们也在左侧添加了一个连字符，移除了“Welcome”这个词和我们的客户名字之间的空格。我们可以在“*控制空格*”部分提醒自己。

# *第三章*，深入 Liquid 核心与标签

# 问题 1

如果我们想在循环中显示最多七次迭代，同时跳过前三次迭代，我们应该在`for`循环中使用哪些参数？

# 答案

如果我们想要创建一个循环，跳过前三次迭代并输出最多七次迭代，我们应该使用 `offset` 和 `limit` 参数的组合。`offset` 标签将允许我们跳过任何数量的迭代，具体取决于我们分配给它的值。`limit` 参数将允许我们限制标签应执行的迭代次数。我们可以通过重新查看 *Iterations tags* 部分的 *for parameters* 子部分来提醒自己这一点。

# 问题 2

我们可以使用 `capture` 标签创建的变量分配哪些类型的数据？

# 答案

我们可以将任何类型的数据分配给使用 `capture` 标签创建的变量。然而，使用 `capture` 标签创建的变量将始终返回字符串数据作为结果。我们可以通过重新查看 *Variable tags* 部分的 *capture* 子部分来提醒自己这一点。

# 问题 3

在以下代码块中存在两个问题是什么？

```php
liquid for product in collections["outdoor"].products
  if product.price > 10000
    continue
  else
    product.title
  endif
endfor
```

# 答案

虽然使用 `liquid` 标签允许我们在代码块中消除花括号分隔符，但我们不应该从 `liquid` 标签中移除它们。我们应该在 `liquid` 标签的左侧放置一个带有百分号的开括号分隔符。我们代码的第二个问题是我们在 `product.title` 前缺少一个 `echo` 标签，它替换了双大括号分隔符。我们可以通过重新查看 *Theme tags* 部分的 *The liquid and echo tags* 子部分来提醒自己这一点。

# 问题 4

我们应该采取什么方法来修改由 HTML 生成的产品表单，通过替换现有的类属性为一个字符串和变量的组合？

# 答案

考虑到 `form` 标签不接受字符串和变量的组合作为其参数，我们应该首先使用 `capture` 标签将这些值分配给一个变量，然后将其传递给 `form` 标签。我们可以通过重新查看 *Theme tags* 部分的 *form* 子部分来提醒自己这一点。

# 问题 5

如果我们想从父元素传递一个对象，我们应该使用哪个参数？

# 答案

唯一允许我们从父元素传递对象的标签是 `render` 标签，即使如此，我们也只能通过使用 `with` 和 `as` 参数来实现。我们应该将 `with` 参数的值设置为我们要传递的对象，而 `as` 参数的值应该是我们在片段文件中将使用的变量名。我们可以通过重新查看 *Theme tags* 部分的 *render* 子部分来提醒自己这一点。

# *第四章*，使用对象深入液态核心

# 问题 1

在以下代码块中，我们缺少什么来使 `form` 功能化？

```php
{% form "product", product %}
  <input type="hidden" value="{{ 
   product.first_available_variant.id }}" />
    <input type="submit" value="Add to Cart"/>
{% endform %}
```

# 答案

虽然我们已经介绍了必要的 `id` 变体来创建一个工作的产品表单，但我们没有使用 `name` 属性，其值为 `id`。我们可以通过回到 *自定义集合* 子主题，在 *与全局对象一起工作* 部分来提醒自己这是如何工作的。

# 第二个问题

我们如何通过在管理导航中定义的链接来获取访问 `product` 对象的权限？

# 答案

要通过导航菜单访问 `product` 对象，我们需要使用一个 `for` 标签来遍历导航菜单。一旦我们找到了哪个菜单项是 `product_type`，我们就可以使用那个菜单项，然后是 `object` 属性，来访问那个特定的 `product` 对象。我们可以通过回到 *自定义导航* 子主题，在 *与全局对象一起工作* 部分来提醒自己这是如何工作的。

# 第三个问题

访问单个和多个 `metafield` 对象的两种方法是什么？

# 答案

我们可以通过访问我们想要恢复 `metafield` 的页面对象，然后是 `metafields` 对象，然后是 `namespace`，最后是 `key` 来访问单个 `metafield` 对象。如果我们想要恢复多个 `metafields` 对象，我们需要使用一个 `for` 标签来遍历所有具有其命名空间的元字段。我们可以通过回到 *使用元字段改进工作流程* 部分来提醒自己这是如何工作的。

# 第四个问题

如果我们想要捕获 `line_item` 值并在结账页面上隐藏它，我们需要对输入元素进行什么调整？

```php
<input type="text" name="properties[Your Name]" placeholder="Your Name"/>
```

# 答案

如果我们想要捕获 `line_item` 值，我们需要在方括号内引入一个下划线作为第一个字符。通过在 `line_item` 输入中引入这个下划线，我们将自动隐藏特定的 `line_item`，使其不在结账页面上显示。然而，这不会在购物车页面上隐藏它。购物车页面需要一些手动调整。我们可以通过回到 *自定义导航* 子主题，在 *与全局对象一起工作* 部分来提醒自己这是如何工作的。

# *第五章*，使用过滤器深入液态核心

# 第一个问题

假设我们有一个名为 `product_handles` 的数组，包含 30 个产品的句柄。以下代码中哪个问题会阻止我们成功输出所有 30 个产品的图片？

```php
{% for handle in product_handles %}
  {% assign product_object = all_products[handle] %}
  {% for image_item in product_object.images %}
    <img src="img/{{ image_item | img_url }}"/>
  {% endfor %}
{% endfor %}
```

# 答案

由于我们想要输出超过 20 个产品，在这种情况下，30 个产品，我们不能使用 `all_products` 对象，因为 `all_products` 对象有一个限制，我们只能在单页上调用它 20 次。如果我们想要从超过 20 个产品中恢复数据，我们需要将它们分配到一个集合中，然后对这些产品进行循环。我们可以通过访问 *使用 HTML 和 URL 过滤器一起工作* 部分来提醒自己 `all_products` 对象。

# 第二个问题

为什么在创建产品媒体库时不推荐仅使用 `model_viewer_tag` 标签？

```php
{% for media in product_object.media %}
  {% case media.media_type %}
    {{ media | model_viewer_tag }}
  {% endcase %}
{% endfor %}
```

# 答案

虽然`model_viewer_tag`将正确输出每种媒体类型的必要 HTML 媒体标签，但我们应仅在所有其他媒体标签无法渲染正确标签时才使用`model_viewer_tag`作为后备。使用`model_viewer_tag`将阻止我们包括每个`media`标签的任何特定参数。我们可以通过回顾本章中我们完成的一个先前项目，增强产品媒体库，来提醒自己`media`对象。

# 问题 3

如果我们想要在数组中访问特定位置的项，我们可以使用哪个过滤器？

# 答案

如果我们想要访问特定位置的项，我们需要使用一个名为`index`的数组类型过滤器。使用`index`过滤器，我们可以访问数组中的指定索引位置并返回其值。我们可以通过回顾本章中我们完成的一个先前项目，产品折叠面板，来提醒自己索引参数。

# 问题 4

我们可以使用哪个过滤器来快速更新主题文件中字符串值的任何出现？

# 答案

为了轻松更新字符串值的任何出现，我们需要使用 t（翻译）过滤器。通过定义翻译键，我们可以快速更新或甚至翻译任何字符串值，而无需手动更新多个文件中的硬编码字符串值。

# *第六章*，配置主题设置

# 问题 1

输入设置有两种类型吗？

# 答案

第一组设置被称为基本输入类型，它由六种设置组成，使我们能够输出基本的 HTML 输入元素，通过这些元素我们可以动态地输出某些内容。第二组设置，也称为专用设置，使我们能够生成专用选择器类型字段，通过存储访问各种对象，并使用它们的属性输出其内容。我们可以通过访问*第六章*中的*基本输入类型*和*专用输入设置*部分来提醒自己设置的基本和专用输入类型。

# 问题 2

以下代码片段将导致错误的问题是什么？

```php
{
  "type": "text",
  "id": "header_announcement",
  "label": "Text",
}
```

# 答案

虽然代码结构是正确的，但我们不小心在文本设置类型中的最后一个属性后面多加了一个逗号，这将导致 JSON 错误并阻止我们保存更改。我们可以通过访问*第六章*中的*基本 JSON 设置*部分来提醒自己严格的 JSON 格式。

# 问题 3

我们如何在 Shopify 中包含一个自定义字体文件并在主题编辑器中使用它？

# 答案

虽然`font_picker`允许我们在 Shopify 中访问大量字体，但我们无法将自定义字体包含在这个库中。要包含一组自定义字体，我们必须使用设置中的`select`输入类型，在那里我们可以手动创建一个我们希望包含的字体列表。我们可以通过访问*选择输入*子部分来提醒自己如何包含自定义字体，该子部分位于*基本输入类型*部分中的*第六章*，*配置主题设置*。

# 问题 4

哪两个问题会阻止我们执行以下代码片段？

```php
{
  "type": "range",
  "id": "number_of_products",
  "min": 110,
  "max": 220,
  "step": 1,
  "unit": "pro",
  "label": "Number of products",
  "default": 235
}
```

# 答案

考虑到每个`range`滑块最多可以有 100 个步骤，第一个问题是`min`和`max`属性值相差太远，我们可以通过减少这两个值中的一个来解决，这样它们就不会超过 100 个步骤。另一种解决方案是将`step`增加到更高的值，从而减少`min`和`max`值之间的步骤数。

第二个问题是`default`属性值目前超过了`max`属性值。我们可以通过减少`default`值或增加`max`属性值来解决这个问题。在确保`default`属性值不超过`max`值之后，我们还需要确保`default`值也高于`min`属性值。我们可以通过访问*范围输入*子部分来提醒自己`range`类型设置格式，该子部分位于*基本输入类型*部分中的*第六章*，*配置主题设置*。

# *第七章*，处理静态和动态部分

# 问题 1

静态部分和动态部分的主要区别是什么？

# 答案

静态部分和动态部分的主要区别在于，我们只能通过主题编辑器内的**添加部分**按钮将动态部分添加到 JSON 模板和主页。此外，我们可以重复此操作任意次数，使用不同的内容。

另一方面，静态部分需要手动使用`section`标签包含在主题模板中。我们可以在多个模板中包含相同的静态部分。然而，每个部分将显示相同的内容，因为我们只能有一个静态部分的实例。我们可以通过访问*静态与动态部分*部分来提醒自己静态和动态部分。

# 问题 2

我们可以使用什么对象来访问块输入值？编写一些代码，使我们能够访问特定的`blocks`模块输入值。

# 答案

我们可以通过`section`对象访问块的输入值，并将其与`blocks`属性结合，这将返回一个块对象的数组：

```php
{% for block in section.blocks %}
  {% case block.type %}
    {% when "block-type" %}
    {{ block.settings.input-id }}
  {% endcase %}
{% endfor %}
```

我们可以通过访问*使用块构建*部分来提醒自己如何访问块输入类型。

# 问题 3

`limit` 和 `max_blocks` 属性之间的区别是什么？

# 答案

`limit` 和 `max_blocks` 属性之间的主要区别在于，`limit` 属性只允许我们限制重复特定块类型的次数。另一方面，`max_blocks` 属性允许我们限制在特定部分内可以包含的块的数量，而不考虑块类型。我们可以通过访问 *使用块构建* 和 *max_blocks 属性* 部分来提醒自己如何使用 `limit` 和 `max_blocks` 属性以及两者之间的区别。

# 问题 4

我们如何应用特定部分的 CSS 样式？

# 答案

如果我们需要包含特定部分的 CSS，我们可以使用 `{% style %}{% endstyle %}` 标签，这将允许我们使用 Liquid 代码。然而，除了 `style` 标签之外，我们还需要定义一个唯一的标识符，稍后我们将用它作为选择器。我们可以使用 `section` 对象和 `id` 属性来完成这个操作，这将返回动态部分的动态 ID 或静态部分的文件名。我们可以通过访问 *样式标签* 部分来提醒自己如何创建特定部分的 CSS。

请注意，所有四个项目的解决方案都可在 GitHub 上找到：[`github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects`](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects)
