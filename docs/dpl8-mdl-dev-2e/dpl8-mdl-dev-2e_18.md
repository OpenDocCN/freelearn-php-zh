# 第十八章：Drupal 8 安全性

编写安全的代码是任何网络应用的重要方面。预防各种创意十足的黑客技术可能非常令人畏惧，这也是我们作为开发者有时选择一个具有稳固且最新的安全措施框架的原因之一。

Drupal 是一个非常重视安全的 CMS。社区有一个专门的安全团队，他们始终在寻找漏洞，并就修复潜在攻击向量向核心贡献者和模块开发者提供建议。他们还负责快速缓解任何此类问题，并向受影响的各方传播正确的信息。

当涉及到创新安装时，Drupal 8 在解决先前版本中存在的许多安全问题上已经取得了长足的进步，以至于 Drupal 7 开发者曾经需要担心的大部分问题现在都可以视为理所当然。因此，在本附录中，我们将讨论一些 Drupal 8 默认提供的最突出的安全特性，这些特性与我们作为模块开发者的工作直接相关。此外，我们还将探讨一些确保我们编写的模块遵守 Drupal 自豪的安全标准的技巧。

# 跨站脚本（XSS）

Drupal 7 本身并不容易受到 XSS 攻击，但它使新手开发者容易打开此类漏洞。特别是基于 PHP 的模板系统，使得开发者容易忘记在输出之前对用户输入和其他类型的数据进行适当的清理。此外，它允许新手开发者直接在模板中执行所有类型的业务逻辑。除了没有保持关注点的分离（业务逻辑与表示）之外，这也意味着第三方主题的验证更加困难，并且很容易包含安全漏洞。

这些担忧中的大部分在 Drupal 8 中都已得到解决，主要是通过采用 Twig 作为模板系统。这一采用的两个主要后果是：第一个解决了将表示与业务逻辑分离的需求。换句话说，主题和开发者不能再直接访问 Drupal 的 API，也不能从模板中运行 SQL 查询。为了公开任何此类功能，可以使用 Twig 扩展和过滤器，但它们要求逻辑封装在模块内部。

第二个后果是以 Twig 自动转义的形式出现。这意味着任何未特别标记为安全的字符串都将由 Twig 使用原生的 PHP `htmlspecialchars()` 函数进行转义。这提供了一种安全性，以前需要主题和开发者通过如 `check_plain()` 函数等手动积极寻求。

# Drupal 8 中的清理方法

Twig 会自动转义使用常规表示法输出的任何字符串，如下所示：

```php
{{ variable_name }}  
```

然而，有些情况下变量已经被标记为安全，Twig 不再对其进行转义。这通常是在`MarkupInterface`对象的情况下，例如`FilteredMarkup`或`FormattableMarkup`。在这些情况下，Twig 假设它们包裹的字符串已经过清理，并且可以原样输出。当然，作为模块开发者，我们必须确保我们不会使用包含未清理用户输入的字符串的此类对象。

让我们看看我们经常使用的此类对象的流行示例，然后我们将讨论我们可以用来清理用户输入的不同方法。

如果你还记得，在这本书的整个过程中，我们使用了`t()`函数（以及`StringTranslationTrait`方法），它返回一个用于翻译字符串的`TranslatableMarkup`对象。在 Twig 中打印此类对象将防止自动转义，因为 Twig 已经认为它是安全的。此外，如果你还记得，这仅适用于主字符串，因为我们使用的任何占位符都会被转义：

```php
$object = t('This does not get escaped but this does: @safe', ['@safe' => 'This can be unsafe as it will be escaped'])  
```

即使没有安全影响，我们也不应该将用户输入或变量传递给`TranslatableMarkup`，因为这阻碍了这些对象的实际目的——即翻译字符串。然而，对于其他`MarkupInterface`对象，我们有几种方法可以处理用户输入或可疑来源的字符串，以便为 Twig 做准备：

+   `Drupal\Component\Utility\Html::escape()`：这是用于打印纯文本的最严格的清理函数。它使用 PHP 的`htmlspecialchars()`将特殊字符转换为 HTML 实体。

+   `Drupal\Component\Utility\Xss::filter()`：这个函数过滤 HTML 以防止 XSS 攻击。它允许一些基本的 HTML 元素。

+   `Drupal\Component\Utility\Xss::filterAdmin()`：这是一个非常宽容的 XSS 过滤器，除了像`<script>`或`<style>`这样的元素之外，它允许通过大多数 HTML 元素。它应该仅用于已知和安全的输入来源。

+   `Drupal\Component\Utility\UrlHelper::filterBadProtocol()`：这个函数从 URL 中移除危险的协议。在从用户输入或不受信任的来源获取 URL 并打印 HTML 属性值之前应该使用它。

因此，根据情况，使用上述清理方法之一可以防止处理 Twig 不转义的标记时的 XSS 攻击。

# 双重转义

由于 Twig 已经为我们做了很多工作，因此我们也不应该过度转义。经验丰富的 Drupal 7 开发者可能会倾向于过度转义，但这可能会有意想不到的后果。例如，想象以下场景：

```php
return [ 
  '#theme' => 'my_custom_theme', 
  '#title' => 'The cow\'s got milk.', 
];  
```

由于 Twig 是自动转义的，以下字符串将被打印：

```php
The cow's got milk.  
```

因此，字符串是安全的，没有可见的变化。然而，想象一下，如果我们过于热衷于清理并做了以下操作：

```php
return [ 
  '#theme' => 'my_custom_theme', 
  '#title' => Html::escape('The cow\'s got milk.'), 
];  
```

然后，我们会得到以下标题：

```php
The cow's got milk.  
```

这是因为第一次转义时，Drupal 将撇号转换为 HTML 实体（`'`）。然而，浏览器正确地渲染它，所以我们实际上看不到它。第二次转义将那个 HTML 实体中的个别字符转换为*它们*各自的 HTML 实体。在这种情况下，`&`字符被转换为`&amp;`。因此，整个字符串不再被浏览器正确读取。

我现在将您的注意力暂时引向第四章，*主题化*。在那章中，我们了解到`#markup`和`#plain_text`属性已经足以对通过它们传递的用户输入进行清理。前者使用`Xss::filterAdmin()`方法，而后者使用`Html::escape()`方法。因此，请记住，如果您将它们作为渲染数组的一部分使用，可能不需要进一步的清理。

# SQL 注入

SQL 注入仍然是对使用数据库驱动程序不当的易受攻击应用程序的一种非常流行的向量攻击。幸运的是，通过使用 Drupal 8 数据库抽象层，我们大大提高了确保对这些漏洞的保护。我们只需正确使用它即可。

当涉及到实体查询时，我们很难出错。然而，当我们直接使用数据库 API，就像我们在第八章，*数据库 API*中所做的那样时，我们必须注意。

大多数时候，漏洞与不正确的占位符管理有关。例如，我们永远不应该这样做：

```php
$database->query('SELECT column FROM {table} t WHERE t.name = ' . $variable);  
```

这与`$variable`是什么无关——直接用户输入或其他。因为通过使用那种直接连接，恶意用户可能会注入他们自己的指令，并以不同于预期的不同方式完成语句。相反，我们应该使用我们在第八章，*数据库 API*中所使用的代码：

```php
$database->query("SELECT column FROM {table} t WHERE t.name = :name", [':name' => $variable]);  
```

换句话说，使用占位符，然后由 API 进行清理，以确保不允许任何字符形成恶意语句。

在 SQL 注入漏洞方面，Drupal 8 带来了额外的安全改进——单条语句执行。直到最近，PHP PDO 驱动程序（自 Drupal 7 以来 Drupal 进行了扩展）没有设置标志来通知 MySQL 一次只执行一条语句。理论上，由附加多条语句引起的漏洞是可能的（有一个痛苦的攻击例子，它永远标记了 Drupal 社区——SA-CORE-2014-005）。但是，这已经改变了，Drupal 现在通过 PDO 将此标志发送到数据库引擎，以防止一次执行多条语句。因此，我们得到了额外的保护。

# 跨站请求伪造（CSRF）

CSRF 攻击是应用程序被接管的一种流行方式，通过强制具有提升权限的用户在自己的网站上执行不受欢迎的操作。通常这发生在应用程序的某些 URL 通过浏览器访问（并通过认证）触发一个过程时：例如，删除资源。

在这方面最重要的考虑因素是，绝不能仅仅通过访问 URL 就执行此类操作。为了帮助解决这个问题，我们拥有强大的表单 API，它已经从 Drupal 的早期版本中嵌入了基于令牌的 CSRF 保护。因此，基本上您可以创建提交处理程序执行潜在有害操作的表单（正如我们在第二章中学习的，*创建您的第一个模块*）或者甚至添加一个第二层使用确认表单（正如我们在第六章中看到的，*数据建模和存储*和第七章中看到的，*您的自定义实体和插件类型*，当时我们讨论实体）。后者实际上在操作不可逆或具有更大影响时是推荐的。

尽管表单 API 应该涵盖大多数用例，但我们可能也会遇到需要声明一个直接处理过程的回调 URL 的需求。此外，为了保护我们免受 CSRF 攻击，我们可以使用我们在第十章中看到的 CSRF 令牌系统，*访问控制*，当时我们讨论了各种访问控制类型。我建议您查看该章节以获取更多关于此主题的信息。

# 摘要

Drupal 8 在锁定其 API 以防止攻击漏洞方面已经取得了长足的进步。当然，这并不意味着它是完美的，也不意味着一个糟糕的开发者不能创建安全漏洞。因此，密切关注您所编写代码的安全影响，遵循标准（包括 OWASP 清单），并了解您使用的贡献模块（至少要由 Drupal 安全团队覆盖）非常重要。此外，保持与 Drupal 安全团队的安全公告同步也非常重要，因为可能会发现新的漏洞并需要更新来修复它们。在某些情况下，这些更新比其他更新更具有时间敏感性，但尽快保持最新状态总是好的（通过关注 Drupal 安全团队的信息）。幸运的是，从历史的角度来看，Drupal 并没有经历很多安全危机——至少与其他开源框架相比是这样。因此，从安全角度来看，它享有良好的声誉。然而，不要认为您作为模块开发者，不需要承担保持应用程序安全的重任。

在本章中，我们讨论了网络应用程序通常面临的三种过渡性漏洞，Drupal 8 如何应对这些漏洞，以及作为模块开发者，我们可以和应该做些什么来保护自己免受其影响：跨站脚本（XSS）、SQL 注入和跨站请求伪造（CSRF）。当然，从应用程序和服务器维护的角度来看，我们还可以做很多事情。然而，这些内容超出了本书关注的范围。尽管如此，我强烈建议你阅读所有关于 Drupal 8 安全性的可用文档，并保持信息更新。

哇。你能相信你刚刚完成了这本书的最后一章，终于可以去打乒乓球了吗？是的，确实需要休息一下，因为这是一段不容易的旅程，尽管我希望它是有成效的。一旦完成，回到键盘前，我强烈建议你重新审视那些对你来说更复杂的部分。在做这件事的同时，检查并导航 Drupal 核心代码，以理解和亲自看到这些概念在实际中的应用。没有任何资源会比代码本身更好，这本书的主要目标就是为你指明正确的方向。还有许多更多有趣的事情要学习，这个过程永远不会停止。如果你感兴趣，你将每天都会学到新东西。我也是。
