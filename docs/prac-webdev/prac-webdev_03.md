# 第三章。CSS

在上一章中，我们学习了如何使用 HTML 元素和属性创建 HTML 文档。我们甚至可以包括图片和指向其他文档和图片的链接。但是当你看到屏幕上的结果时，你可能感到失望。我希望你是这样的，因为那是故意的（哎呀，我差点说成是有意为之，但设计部分正是本章的主题）。当我写我的第一个网页时，我也感到失望，特别是在发现做一件本应简单的事情有多难：在页面上放一张照片，旁边有一些文本。现在，是时候将失望转化为兴奋了！

在本章中，我们将学习如何使用**层叠样式表**（**CSS**）添加演示部分——换句话说，就是布局——到我们的网页中。样式表是桌面出版软件中的常见功能。它们允许你指定（或修改）文档中某一类部分的样式：例如，每个文本段落。当我用 Adobe InDesign 开发我的第一本书时，我知道每个组件应该是什么样子，所以我手动修改了它们的字体和大小。我不想花时间去学习如何创建样式表。然而，我后来后悔了这个决定，因为那时它已经变成了一件耗时的事情。

现在，我喜欢样式表，并且不仅推荐使用它们，还建议在开始一个新项目时，让它们成为你首先创建的东西。样式表就像一个计划的计划，你可以在以后填写细节。

通过使用样式表，你可以将设计部分与内容部分分开。你甚至可以在不同的时间或由不同的人完成，这将使所有页面看起来都保持一致。只需切换两个样式表，你的整个网站看起来就会完全不同。我们现在兴奋了吗？

让我们从一段 CSS 代码的示例开始：

```php
/* selector – by the way this is how to do comments in CSS */
p.red
/* properties */
{
color:red;
font-family:baskerville, cambria,  serif;
font-size:12px;       
font-style:italic;
}
```

CSS 中的注释可以在字符串`/*`和`*/`之间找到，类似于 C 编程语言中使用的。因此，为了鼓励良好的行为，我们在第一个例子中包含了一些注释。让我们分析一下这段代码的其余部分。

花括号之前的部分被称为**选择器**。它代表我们页面中的一个或多个元素。在我们的例子中，这包括所有具有 class red 的`<p>`元素。

在花括号之间，我们可以找到我们想要的 CSS 规则。在这个例子中，我们希望段落内的所有文本都是红色，大小为 12 像素，斜体，并且使用**Baskerville**字体。在那些没有该字体的系统上，我们希望使用**Cambria**字体代替。

注意，每个规则都以一个**分号**结束，由一个冒号分隔成两部分：一个**属性**和一个**值**。颜色是一个属性，在我们的例子中，选择的值是`red`。

在 HTML 的旧版本中，可以通过在 `<p>` 标签内放置 `<font>` 元素来实现相同的效果。想象一下，您的文档中有 40 个 `<p>` 部分，有人想要将 `red` 改为 `maroon`！您将不得不在 HTML 文件中的 40 个不同位置进行更改，而且全局查找和替换也无法帮助您，因为可能还有其他红色的“东西”。通过使用 CSS，您只需更改一行。

更常见的是找到类似以下的 CSS 代码：

```php
p {
font-size:12px;
font-family:Baskerville,cambria, serif;
}
p.red {
font-style:italic;
color:red;
}
```

这不仅会对红色 `<p>` 标签产生相同的效果，而且还会将所有其他段落设置为相同的字体和大小。这是 CSS 中的 C：整体 `<p>` 的属性会流入红色段落的子集中，就像在真实的水流中一样。

# 向我们的文档添加样式

那么 CSS 规则是如何成为我们文档的一部分的呢？有三种方式：

+   外部样式表

+   内部 CSS

+   行内样式

## 外部样式表

这是向您的网站添加 CSS 的推荐方式。您的目标应该是所有网站生产版本的样式表都是外部的。只需在网站的 `<head>` 部分添加一行，如下所示：

```php
<link rel="stylesheet" type="text/css" href="css/style.css">
```

`<link>` 是一个我们尚未介绍的 HTML 元素。其属性如下所示：

+   `rel`，用于指示 HTML 文档与链接文件之间的关系。

+   `type` 指定了文档的 MIME 类型，以便浏览器知道如何加载它。

+   `href` 用于指定文件的地址。您可能会期望在这里使用 `src` 属性，就像 `<img>` 标签中使用的那样，但指定 `<link>` 元素中文件名的属性是 `href`。对于文件名，我们建议您始终使用相对路径名。我们建议您将所有样式表收集到一个具有有意义名称的文件夹中，例如 `css` 或 `styles`。当然，文件本身也应该有一个有意义的名称。

当文件确实存在时，它将被加载。这就是为什么您的 `<link>` 元素必须位于文档的 `<head>` 部分中，以便在文档的主体之前读取所有 CSS 规则。

## 内部 CSS

对于小型项目，或者您希望限制为单个 HTML 文件以便于发送给他人，您可以使用内部 CSS。然后，所有的 CSS 规则都可以放置在文档的 `<head>` 部分内，在一个 `<style>` 标签中。该标签至少需要包含一个 `type` 属性，如下例所示：

```php
<style type="text/css">
p.red {
color:red;
}
</style>
```

## 行内样式

可以通过在 HTML 元素内部使用 `style` 属性来给单个 HTML 元素添加样式，如下例所示：

```php
<h3 style="color:green;">Congratulations</h3>
```

我们不建议在最终产品中使用这种方法，但在开发过程中立即看到更改的效果是非常有用的。如果由于某种原因，您在页面中留下了一个行内样式属性，那么您可能永远也找不到为什么您的样式表没有按照预期在页面的一行上工作。

另一方面，我每天都在使用它，因为我可以在不干扰网站其他内容的情况下，在页面上引入和测试新元素，就像修改外部的 `.css` 文件那样。

# 文档对象模型（DOM）

如我们在上一章中学到的，一个 HTML 文档由一个嵌套标签的树结构组成，HTML 作为根。在编程中，该树的内容可以存储在一个大对象中，子树可以通过使用较小的对象来访问、修改或添加。

所有这些统称为**文档对象模型**（**DOM**）。在随后的章节中，我们将学习一种编程语言（JavaScript）来做到这一点，以及一个 JavaScript 库（jQuery）来简化这个过程。在本章中，我们将不会学习如何更改我们的内容，而是学习如何更改内容的样式。在所有情况下，我们需要一种方法来访问我们的文档。这就是**选择器**发挥作用的地方。

# 选择器

CSS 规则的第一部分，即开大括号之前的部分，是选择器，或者由逗号分隔的多个选择器。选择器代表页面中一系列元素，后续规则将应用于这些元素。最简单的选择器是一个单一的标签名，就像我们在之前的例子中已经使用过的那样。以下是一个代码片段作为另一个例子：

```php
p {
color:blue;
}
```

选择器 `p` 表示整个页面中所有的段落元素。应用此规则将导致整个页面中的所有段落都以蓝色渲染。同样，我们也可以使用类名。参考以下示例：

```php
.blue {
color:blue;
}
```

选择器 `.blue` 表示页面中所有具有 `class` `blue` 的元素，无论它们是段落、标题还是其他。现在我们可以将这两个结合起来，如下所示：

```php
p.blue {
color:blue;
}
```

此选择器表示页面中所有具有 `class` 设置为蓝色的段落元素的集合。对于那些喜欢集合理论的人来说，这是 `p` 集合和 `.blue` 集合的交集。

让我们在下一个简单的例子中继续探讨一些集合理论：

```php
#errorbox {
color:red;
}
```

与此选择器匹配的元素集合，在最理想的情况下，是一个单例，因为它匹配具有 `id` 设置为 `errorbox` 的元素，如果存在的话。我无法经常提醒你，没有两个元素可以共享相同的 `id`。同样有效，但稍微更严格的是以下规则：

```php
div#errorbox {
color:red;
}
```

前一条规则是关于任何具有 `id` `errorbox` 的元素：后一条规则仅适用于具有 `id` `errorbox` 的 `div` 元素。

## 多个类

我们了解到，可以通过将一个由空格分隔的字符串分配给其 `class` 属性来将多个不同的类分配给一个元素，例如：

```php
class="green cool awesome"
```

如果你想为这样的元素创建一个 CSS 规则，选择器可能看起来像以下这样：

```php
h2.green.cool.awesome
```

当用作 CSS 规则中的选择器时，该规则将应用于所有具有 `class` `green`、`cool` 和 `awesome` 的 `h2` 元素。因此，样式将更改为以下内容：

```php
<h2 class="green cool awesome">The Hulk</h2>
```

这与以下选择器的规则完全不同：

```php
h2  .green .cool .awesome

```

这将是应用于具有`awesome`类、是具有`cool`类的元素的后代、这些元素又是设置为`green`类的标签的后代、同时自身又是`h2`元素的后代的元素的规则的一部分。

这是一个非常重要的区别，因此非常重要要记住：如果允许我改写一首著名的歌曲：*空格带来的差异有多大*！

## 后代

我们迄今为止使用的示例选择器都是顶级选择器：一个元素、一个类或一个标识符。现在我们将添加更多细节和复杂性。看看以下示例：

```php
#container h2 {
color:grey;
}
```

这条规则仅适用于位于具有`id="container"`的元素内部的`h2`元素，无论它们有多少层级。所以如果这是你 HTML 文件的一部分，这条规则将适用于包含它的`h2`元素：

```php
<div id="container">
<div id="header"></div>
<div id="main">
<h2>Title of this Document </h2>
</div>
</div>
```

以下 CSS 规则也会使标题变为灰色，但如果不幸有其他`h2`元素位于`#header` div 内部，它们不会受到这条规则的影响：

```php
#container #main h2 {
color:grey;
}
```

## 选择子元素或兄弟元素

在某些情况下，你想要在选择上更加具体，并为其他元素的**子元素**设置规则，而不是在文档树中任意数量的不同层级下的后代元素。为此，你可以使用**子选择器**，如下面的示例所示：

```php
#main >  h2 {
color:grey;
}
```

`h2`是具有 id `main`的 div 元素的子元素，因此，根据这条规则，我们小块代码中的标题将以灰色显示。现在考虑以下示例：另一方面：

```php
#container > h2 {
color:grey;
}
```

在这种情况下，将没有效果，因为`h2`不是`div#container`的子元素。

存在类似的语法来指定一个与另一个元素相邻的元素，或者称为家族树中的**兄弟元素**。参考下一个示例：

```php
h2 + p  {
margin-top:0px;
}
```

这不会给紧随`h2`之后的`p`元素添加顶部边距，但不会将此规则应用于后续的`p`标签。看看以下小块 HTML：

```php
<h2>Story</h2>
<p>First paragraph</p>
<p>Second paragraph</p>
<p>Third paragraph</p>
```

第一段不会有顶部边距；所有其他段落会有基于浏览器默认渲染段落的边距。当然，如果这条 CSS 规则是唯一的，并且没有被其他规则覆盖，那么这是真的，这带我们到下一个主题：**特定性**。

# 特定性

有时，作为一个 CSS 初学者或经验丰富的网络开发者，如果你只是在你样式表中添加了一条新的 CSS 规则，却发现它没有任何效果，你会感到沮丧。这种情况通常发生是因为有另一个具有更高特定性的规则具有优先权。

我们已经提到内联样式比外部样式表具有优先权。因此，内部 CSS 和外部样式表的链接顺序似乎会影响页面的最终外观。现在考虑以下规则：

```php
p.warning {
color:red;
}
```

假设前面的规则后面跟着这条规则：

```php
p.warning {
color:orange;
}
```

在这种情况下，所有具有`warning`类的段落元素将以橙色显示，而不是红色，因为橙色规则出现得较晚。

但这两个规则恰好共享一个共同的选择器：它是一个具有`warning`类的`p`标签。

如果你有的规则选择器如下：

```php
p#error  {
color:red;
}
```

此外，如果你还有下一个规则：

```php
body div.container div.main p.error {
color: orange;
}
```

让我们现在考虑以下内容：

```php
<div class="container">
<div class="main">
<p id="error" class="error">
What you typed is incorrect
</p>
</div></div>
```

逻辑或直觉，但不是 CSS 中的顺序，会让我们认为文本`你输入的内容不正确`将以红色显示，而不是橙色。实际上，这是正确的，但我们不希望依赖直觉，对吧？幸运的是，有公式可以确定如果有多个规则可能影响特定元素的布局，哪个 CSS 规则会获胜。这稍微有些数学性，被称为**特定性**。

CSS 规则的特定性是一系列四个数字，其计算方法如下：

+   如果规则是内联样式，第一个数字是 1，否则是 0

+   对于每个出现的**标识符**，将第二个数字加 1

+   对于每个指定的**类**，将第三个数字加 1

+   对于每个存在的**元素**，将第四个数字加 1

当比较两个规则时，首先查看第一个数字。如果其中一个更高，那么该规则就有更多的**权重**。接下来查看第二个数字，如果需要，再查看第三个，最后查看最后一个。我们两个示例规则的特定性是：0,1,0,1 和 0,0,3,4。

因此，我们的直觉现在得到了简单的算术的证实。

# 块级元素和内联元素

在我们最终按类别描述最重要的 CSS 属性之前，我们需要就两种元素类别说几句话：**块级**元素和**内联**元素。

将块级元素想象成你的屏幕或页面上的矩形区域。它们可以包含文本、数据和其它块级元素，以及内联元素。典型的块级元素是`<div>`和`<p>`标签。在每个块级元素之前和之后，都会创建一个新的文本行。

内联元素只能包含内联元素，不能包含块级元素。此外，它们不能被赋予宽度。它们从它们所在的容器继承宽度。最流行的内联元素是`<span>`元素，通常用于改变更多文本中某段文本的外观。

首先，这可能会让人困惑，因为像`<div>`这样的块级元素可能是块级元素，但如果没有内容，它们看起来似乎没有宽度或高度。此外，你可以使用 CSS 的`display`属性更改这些元素的显示方式。考虑以下代码行，并让浏览器渲染它：

```php
<p>paragraph1</p>
<p>paragraph2</p>
<p>paragraph3</p>
<p>paragraph4</p>

<p style="display:inline;">paragraph1</p>
<p style="display:inline;">paragraph2</p>
<p style="display:inline;">paragraph3</p>
<p style="display:inline;">paragraph4</p>
```

前四行被显示为块级元素，并且是真正的段落：它们之间会有一个新行，这些段落之间的距离将由浏览器选择的默认`font`和`margin`值决定。字体和边距属于最重要的 CSS 属性家族。当我们讨论字体属性以及所谓的`margin`、`border`和`padding`的`box`模型时，我们将了解它们。

如果视口有足够的空间，第二组段落将全部显示在同一行，因为我们明确声明它们是内联元素。

在我们讨论`box`模型之前，让我们再看一个例子。尝试使用第一组 div 的前半部分，因为它们本身不会显示任何内容。一旦你在`<div>`标签之间插入文本，这些文本就会与背景颜色一起显示。第二组中的`<div>`元素实际上有宽度和高度，所以你会看到四个完美的彩色方块，但可能不是你预期的样子。我们将它们两两分组，但它们都堆叠在一起。欢迎来到浏览器无所谓的世界！

```php
<style type="text/css">
.redbg {
background-color: red;
}
.greenbg {
background-color: green;
}
.yellowbg {
background-color: yellow;
}
.bluebg {
background-color: blue;
}
.sq200 {
width: 200px;
height: 200px;
}
</style>

<div>
<div class="redbg"></div><div class="yellowbg"></div>
</div>
<div>
<div class="greenbg"></div><div class="bluebg"></div>
</div>

<div>
<div class="sq200 redbg"></div><div class="sq200 yellowbg"></div>
</div>
<div>
<div class="sq200 greenbg"></div><div class="sq200 bluebg"></div>
</div>
```

# 颜色

使网站看起来瞬间更加愉悦的是正确使用颜色。这同样也是进行一些调试的有用工具。通过给某些块级元素添加不同的背景颜色，你增加了找到那个缺失的、导致混乱的闭合标签的位置的机会。我今天刚刚就用到了它。

通过专业制造公司发布印刷书籍、文档，甚至包装组件或媒体封面，与网络发布之间有着天壤之别。在印刷的世界里，你可以完全控制你使用的颜色，以及同样至关重要的字体或字型。你应该非常挑剔，并期望最终产品在颜色和字型上与你的指定完全一致。颜色信息以 RGB（**红色-绿色-蓝色**）或 CMYK（**青色-品红色-黄色-黑色**）的值进行交换。在 CSS 中，你也可以通过其 RGB 值指定所需的颜色。但比较就从这里开始了，并且结束了。

由于这个原因，我们知道高质量印刷品的颜色应该与我们预期的完全一致。然而，当我们准备网络内容时，我们无法知道我们的网站上的颜色将如何呈现给我们的访客。这取决于太多因素。例如，他们使用什么设备：电脑、平板电脑还是手机？他们查看的屏幕可以是大或小，高分辨率或低分辨率，支持数百万种颜色或只有少数几种。一旦我们意识到这一点，我们就可以放心了。因此，我建议使用足够鲜明的颜色，并且不要麻烦使用奢侈的 RGB 组合。

颜色可以通过几种方式指定。最常见的是通过**名称**和通过**RGB**值。名称更容易，但可能更容易受到浏览器的解释。所以我只在使用快速和临时的事情，或者它们是**黑色**或**白色**时使用它们。在其他所有情况下，我更喜欢使用 RGB 值，它们以`#`符号后跟三个两位十六进制数字的形式书写，例如，`#FFDEAD`，这是我最喜欢的颜色之一。它被称为**纳瓦霍**。

你可以使用**颜色**和**背景颜色**属性来设置前景和背景颜色。颜色表示将用于显示元素内部或元素的子代文本的颜色；背景颜色，正如属性名所暗示的，将设置块元素的背景颜色。

# 字体

我是一个字体爱好者。我甚至花钱购买字体，只是为了个人使用。所以我想指出，与颜色相比，打印出版和网页出版中使用字体的差异更大。

在印刷出版中，你可以完全控制你在工作中使用的`字体`或`字型`（这不是一本关于字体的书，所以请允许我交替使用这些术语）。你只需确保你计划使用的所有字体都已安装在你持有`桌面出版`程序的系统上，这样你就可以用于开发。接下来，确保它们被嵌入到你发送给打印机的最终文档中，并且你和你的印刷公司都有所有使用的字体的合法许可证。然后，所有将阅读印刷副本或甚至在线 PDF 版本的人都会看到它就像你设计的那样。

在网上发布时，访问者将在你的页面上看到的文本只能使用他们使用的设备上实际安装的字体显示。最糟糕的情况，但看起来最好的情况是，你使用了一个非常漂亮、昂贵的字体，这个字体安装在了设计和测试你网站的系统中。它可能安装在其他任何电脑上都没有。

那个网站在你的电脑上看起来绝对棒，但在最关键的地方可能看起来很糟糕。这就是为什么在 CSS 中，我们与**字体族**而不是单个字体一起工作。

在深入细节之前，关于网络**中世纪**的一个需要注意的事情是，曾经有一个标签 `<font>`——简单想一下——啊！中世纪，不要使用它。它是我们之前提到的那些表现性 HTML 元素之一。

## 那么，什么是字体？

简单来说，字体是一系列图片，或者说**符号**，决定了字母、数字和其他字符应该如何显示。在印刷的早期，大约 500 年前，古腾堡、普拉廷或莫雷图斯一次制作一个金属铸模。这些金属字母会被放在木箱里，大的放在上面，小的放在下面。这就是大写和小写这两个术语的由来。

要组成一页文本，必须将金属字母放入一个框架中，以将它们固定在一起，然后插入世界上第一台印刷机。再加上一些墨水和纸张，你就有了：一本书的一页的一个副本。当然，对于每一种不同的尺寸、厚度和样式（例如*斜体*与*正常体*），都必须有一个单独的字母框。

那些制作金属字母的人被称为冲床工人，字体以他们的名字命名。一个著名的例子是 Claude Garamond。你可以在安特卫普的 Plantijn-Moretus 博物馆看到原始的 Garamond 金属字体，它们被纸包裹起来以保护后世。那里你会发现，16 世纪的结合建筑师、肖像画家和“网页设计师”是彼得·保罗·鲁本斯，大多数人只知道他是一位画家。

现在，我们谈论的字体不再是小块金属，而是包含字体布局信息的计算机文件。一个字体包含的符号集合越多（更多的大小、样式或粗细），字母的再现就越准确。

## 字体家族

字体可以被分为不同的类别或家族。其中最重要的三个被称为**衬线**、**无衬线**和**等宽**字体。

### 衬线字体

衬线字体是具有在字母边缘某些部分带有小装饰或衬线的字型。例如，字母*m*底部每条腿的短线条。

在上一节中提到的由 Garamond 设计的字体是一个衬线字体的例子。衬线字体因其使阅读文本愉悦而受到欢迎。出版商在他们的书籍的精装版本中使用精心制作的衬线字体，并结合高质量的印刷纸张。**Times New Roman**，专为英国报纸《泰晤士报》设计，是一种非常常用的衬线字体。你现在正在阅读的文本就是使用 Times New Roman 字体。创作者以一个名为 Plantin 的字体为模型，而这个模型的名字来源于我之前提到的印刷师**Plantijn**。

Baskerville 是衬线字体的另一个例子，常用于电子书。

在网站的文字部分使用衬线字体是值得讨论的。因为符号必须使用屏幕上的像素来显示，那些在印刷中引起愉悦阅读的装饰在屏幕上可能会产生相反的效果。这是因为，在低分辨率屏幕上，那些相同的装饰可能会看起来过于像素化。我个人建议在做出决定之前，至少尝试在你的网站的主要文本部分实验一些衬线字体。

### 无衬线字体

无衬线字体是衬线字体的对立面。它们不包含笔画末尾的小装饰或衬线，因此得名无衬线（法语中意为没有衬线）。在印刷中，无衬线字体用于标题、标题等。这与用于正文文本的衬线字体形成对比。由于之前提到的原因，无衬线字体现在更常用于需要在计算机屏幕上显示的文本。常见的无衬线字体包括：**Arial**、**Open Sans**和**Helvetica**。本书的标题使用 Arial 字体。

### 等宽字体

在我们之前讨论过的字体中，并非所有字符的宽度都相同：字母`m`显然比字母`i`宽。等宽字体，也称为固定宽度字体，是一种字母和字符确实具有相同宽度的字体。最早的等宽字体是为打字机设计的，因为打字机的字车在每次输入字母时都会向前移动相同的距离。它们也被用于早期的计算机和计算机终端。软件文本编辑器至今仍在使用它们，因为当每个字符都有相同宽度时，这使对齐源代码变得更容易。

网站上显示的源代码通常以等宽字体显示，本书中的代码示例也是如此。最常用的等宽字体可能是**Courier**。另一个例子是**Lucida Console**。

让我们现在从对排版科学和历史的研究中回到我们的 CSS 故事。

## 字体家族属性

要指定元素文本的显示方式，我们在 CSS 样式表中使用**font-family**属性。例如，考虑以下内容：

```php
p {
font-family: "Open Sans", "Helvetica Neue", Verdana, Helvetica, sans-serif;
}
```

那么为什么会有多个字体指定：一个字母只能在一个字体中，不是吗？

这就是它的运作方式。当有人访问您的网站时，如果您的样式表中包含这句话，那么一个段落文本将使用`Open Sans`字体显示，如果它在访问者的计算机上安装了。如果找不到，将寻找`Helvetica Neue`；如果那个也没有，则尝试`Verdana`，依此类推。如果所有尝试都失败，将使用一些默认的无衬线字体。对于这个例子，最后一种情况非常不可能，因为我无法想象一个没有安装 Verdana 或 Helvetica 的系统。然而，建议始终以无衬线、衬线或等宽字体结束列表。注意，当字体名称由多个单词组成时，使用引号（例如，对于'Helvetica Neue'）。

## 字体粗细和字体样式

当您使用桌面应用程序中选择字体时，您还可以从`选择列表`中选择样式。一个典型的`选择列表`可能包括：正常、斜体、半粗体、半粗体斜体、粗体和粗体斜体。列表上的项目数量通常与字体附带的字形集合数量相匹配。您可以访问销售字体的公司网站，以更好地了解单个字体主题上可能有多少种变化。

在 CSS 中，这通过两个不同的属性提供：**font-weight**和**font-style**。

字体样式的两个最常见值是**正常**和**斜体**。字体粗细的值是**正常**和**粗体**，以及数字`100`、`200`等等，直到`900`。`400`与正常相同，`700`与粗体相同。所有其他值可能取决于字体中是否存在，比如说，半粗体版本以及所使用的浏览器。所以，直到我们达到书的第二部分，信息应该是响亮且清晰的——只使用基本的正常或斜体，以及正常或粗体。

## 字体大小

最后，就像在我们的桌面应用程序中一样，我们现在可以指定文本需要显示的字体，以及所有这些字母应该有什么大小。

大小可以用`像素`、`百分比`或`ems`来指定。另一个存在的是称为`rem`的单位。

当任何地方都没有指定字体大小时，典型的浏览器会将该大小设置为`16px`。`em`单位，一个来自排版的术语，指的是字体中字母`m`的大小，在 CSS 中，它只是当前元素的字体计算大小。强烈建议使用它而不是固定像素大小。让我们用一个例子来说明这一点。看看下面的 CSS 代码：

```php
h1 {
font-family: "open Sans", Arial, sans-serif;
font-size:2em;
font-weight:bold;
}
h2 {
font-family:Arial, sans-serif;
color:#999999;
font-size:1.5em;
font-weight:600;
}
```

如果没有为 body 元素指定字体大小，我们知道这将是`16px`，所有后代都将继承它。这意味着我们的`h1`标题将变为`32px`，而`h2`将是`24px`。只需将 body 元素的字体大小更改为，比如说，`20px`，就会按比例将我们的`h2`和`h1`标题的大小分别更改为`30px`和`40px`。如果我们给它们指定的大小是，例如，`20px`和`24px`，我们最终会得到与常规文本使用的字体大小相同的标题。

当用户使用浏览器放大或缩小视图时，我们保持比例。为了创建响应式设计，使用比例大小而不是固定大小是最佳选择。当然，你必须小心，并意识到当你更改元素的字体大小时，所有子元素都将继承它，并且当你错误地或不是错误地更改子元素的大小时，`em`的大小将不再是刚才的大小。

考虑以下代码：

```php
<div class="insert">
<p> A paragraph of text that represents what could be an insert in a book</p>
</div>
```

以下是相应的 CSS 规则：

```php
div.insert {
font-family:Baskerville, "Times News Roman", serif;
font-size:0.8em;
color:brown;
}
.insert p {
font-size:0.8em;
}
```

你刚刚将字体大小缩小了一半，所以这段文字中的字母大小将是`0.64`。

通常，我喜欢使用百分比，如下所示：

```php
.insert p {
font-size:80%;
}
```

## 行高

对于处理文本还有一个重要的属性：**行高**。在实践中，这决定了两行文本之间的垂直空间。行高可以指定为一个数字，该数字乘以字体大小，一个`像素`值，一个`百分比`，或者单词`normal`。通常，`normal`由浏览器决定，通常在`1.2`和`1.4`之间。所以每一行的长度是字体大小的`1.2`或`1.4`倍。这样在字母的上下方就有一些空白空间。

对于大小为`16px`的字体，以下三行 CSS 会有相同的效果：

```php
p {
line-height: 24px;
}
p {
line-height: 1.5;
}

p{
line-height: 150%;
}
```

注意，这指定的是段落行之间的空间，而不是段落之间的空间。那将由边距决定，而边距是 CSS 最重要的概念之一：**盒模型**的一个方面。

# 盒模型

所有 HTML 元素都可以被视为盒子。在 CSS 中，当我们谈论设计和布局时使用术语盒模型。它本质上是一个围绕 HTML 元素的盒子，它可以由外向内包括：边距、边框、填充和实际内容。

到目前为止，在这本书中，我们只给出了简短的例子，这样你就可以在没有电脑的情况下学习，我们将尽可能将其作为教科书。然而，为了说明盒模型，以及让你理解它，检查我们的例子并在浏览器中查看是至关重要的。考虑以下代码：

```php
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Paul Wellens - California anecdotes</title>
<link rel="stylesheet" href="styles/packtpubch3_1.css"
type="text/css" />
</head>
<body>
<div id="box">
June Lake, often called the gem of the Eastern Sierra, is a beautiful place that I visit as often as I can.
</div>
<div id="box2">
Mono Lake, saltier than the Black Sea, features tufa formations that makes the place look like it could be on the moon
</div>
</div>
</body>
</html>
```

然后是样式表文件的內容，其中我们使用了一些刚刚学到的知识，并结合引入所有的盒模型属性：

```php
body {
font-size:12px;
background-color: #ffdead;
font-family:Arial, Verdana, Helvetica, sans-serif;
color:#999;
line-height:1.3;
margin:0;

}

#box {
  width:150px;
  height:150px;
  background-color:teal;
  color:white;
  border: 5px solid orange;
  margin:40px;
  padding:20px;

}
#box2 {
  width:150px;
  height:150px;
  background-color:blue;
  color:white;
  border: 5px solid yellow;
  margin:40px;
  padding:20px;

  }
```

当我们在浏览器中显示这个时，我们将看到两个整齐堆叠在一起的方形盒子。两个盒子中都有文本；一个是绿色的，带有橙色的边框，另一个是蓝色和黄色的。视口的左侧和盒子之间、窗口的顶部和顶部盒子之间以及盒子之间的距离是相等的。你可以自由地更改 CSS 和 HTML 中`#box`盒子的值，看看会发生什么。

我们有内容，我们的文本就在那里，我们指定为`150`乘以`150`像素。如果我们没有指定宽度和高度，我们最终会得到一个厚厚的、绿色的矩形区域，文本和边框跨越我们的视口。如果我们只移除边框和填充，我们只看到有背景色的文本；如果我们只移除文本，我们看到一个有边框和颜色的矩形；如果我们两者都移除，我们最终什么也看不到。最后，如果我们只放回宽度和高度，我们就有了一个精确的 150 x 150 像素的绿色正方形。

所以从内部开始，我们有*指定*或*计算*大小的内容。这就是我们元素的大小：在我们的例子中是`150`乘以`150`像素。

接下来我们可以有**填充**。这会使用与元素相同的背景色，并增加我们盒子的内部部分。在我们的例子中，元素的所有四边都增加了`20px`。

然后，我们可以有一个**边框**。这会在我们指定的元素周围添加一个具有厚度、颜色和形状的边框。我们在所有边上使用了 `5px` 的实线边框，因此，到目前为止，我们的盒子已经是（5 + 25 + 150 + 25 + 5 = 210）x 210 像素。

最后，是**边距**。如果我们要边距，它就是元素盒子外部的区域。它是透明的，所以它有父元素的背景颜色。它仅仅在盒子与相邻盒子之间创建距离。在这个例子中，我们使用了 `40px` 的边距。这使得我们的盒子总大小为（40 + 210 + 40 = 290）x 290 像素。

如果你尝试了这个并且是一个细心的人，你可能注意到了一些不合理的地方。好样的！我们稍后会解释这个问题。现在，我们将回顾所有你可以使用的盒子模型属性。

## 填充

你可以指定或取消元素四周的填充。为此，你可以使用以下四个属性：

+   顶部填充

+   右侧填充

+   底部填充

+   左侧填充

这里有一个例子：

```php
.menulabel
{
padding-left: 8px;
padding-right: 7px;
padding-top: 4px;
padding-bottom: 5px;
}
```

你注意到我改变了顺序吗？我是故意这样做的。我使用的第一个顺序是 `padding` 属性简写版本支持的顺序。第二个顺序是我设计时考虑的顺序：水平方向上是什么，然后是垂直方向。所以，相同的四行 CSS 可以替换为以下单行：

```php
.menulabel {
padding: 4px 7px 5px 8px;
}
```

在第一个例子中，我们使用了一个单一值，这意味着四倍相同的值。简写版本也有两个和三个值的变体。例如，以下将顶部和底部设置为 `10px`，左侧和右侧设置为 `15px`：

```php
.menulabel {
padding: 10px 15px;
}
```

## 边框

对于边框属性，你也可以为顶部、右侧、底部和左侧指定不同的值，但不仅仅是宽度。你还可以指定形状、样式和颜色。所以，以下是所有三个的属性：

+   **边框宽度**

+   **边框样式**

+   **边框颜色**

对于这三个中的任何一个，你都可以在任意方向上使用一个属性，例如 **border-top-style**，所以有很多属性可以选择——虽然拥有这么多并不实用。我不认为每个边都有不同形状、颜色和大小的边框会设计得很好！

你可以选择的最常见的形状或样式有：

+   **无**

+   **实线**

+   **双倍**

当然，还有更多。双倍边框可以提供双重边框，有时甚至可以起到装饰作用。实线是我建议你大多数时候使用的。

```php
myimg {
5px solid white;
}
```

那为什么你需要没有边框呢？如果我不想有边框，我直接不指定不就行了，对吧？*错误！* 一些浏览器，例如 Internet Explorer，会自动在任意的 `img` 元素周围添加一个 1px 的白色边框。所以，很高兴你有选项来处理这种情况：

```php
img {
border:none;
}
```

我们已经在例子中使用了简写表示法，所以我只需要提醒你包含事物的顺序；我自己也经常忘记：**宽度 样式 颜色**。

能够在事物周围添加边框是一个非常酷的特性，特别是对于照片来说。网络上的照片“边框”部分可以简单地是一个精心制作的`img`元素的边框。

## 边距

最后，还有边距属性，它清除元素周围的边框。它没有背景颜色，因为它是不透明的。这五个属性是：

+   `margin`

+   `margin-top`

+   `margin-right`

+   `margin-bottom`

+   `margin-left`

你可以指定边距大小，无论是像素、百分比还是其他，就像你可以指定填充一样。然而，你可以设置边距的一个额外、极其有用的值：**auto**。将我们示例中的边距设置更改为：

```php
margin: 40px auto;

```

就像魔法一样，你的两个正方形盒子将在水平方向上居中。如果你调整浏览器窗口的大小，它们仍然会居中。将边距设置为 auto 时，浏览器会为你计算相对于父元素的左右边距。许多网站都有一个主要的`div`元素，它是`body`元素的子元素，样式类似于以下内容：

```php
#container {
margin: 0px auto;
border:none;
max-width:980px;
}
```

经典的网页开发使用一个固定宽度的画布，以及固定的高度，将所有内容放置其中。这个例子使用了`980px`。多亏了`auto`边距，左右将会有自动边距，计算为剩余水平空间的一半。`max-width`是新的，与`width`不同。宽度总是给你 980 像素，而`max-width`只有在有 980 个水平像素可用时才会生效。如果不是这样，比如在智能手机上，视口的（较小的）完整宽度将成为宽度。这是向**响应式设计**迈出的一小步。

## 边距合并

你已经学习了盒模型，使用了我们的示例，可能也在想为什么两个顶部和底部边距为 40px 的正方形盒子之间只有`40`像素，而不是 80 像素。

好吧，这并不是一个错误，而是一个特性。W3C 规范规定，当两个元素的垂直边距相接触时，较大的那个将生效，而另一个将被减小到 0。一些其他的 CSS 设置可以改变这一点，但这是默认行为。一旦你做了很多网页开发并习惯了这一点，你可能会觉得这实际上很有道理。我们将通过向 HTML 和 CSS 中添加两个带有图片的盒子来结束本节，基本上创建了一个相册的前两个条目。我们将结合所学内容，并找出仍有哪些不足。

这里是 HTML：

```php
<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8" />
<title>Paul Wellens - California pictures</title>
<link rel="stylesheet" href="styles/packtpubch3_photo.css" type="text/css">
</head>
<body>
<div class="entry">
<div class="picturebox">
<img  class="picture" src=http://www.paulpwellens.com/packtpub/images/junelakefall.jpg alt="junelake" />
</div>
<div class="textbox">
June Lake, often called the gem of the Eastern Sierra, is a beautiful place that I visit as often as I can.
</div>
</div>

<div class="entry" >
<div class="picturebox">
<img class="picture" src="img/monolake.png" alt="monolake" />
</div>
<div class="textbox">
Mono Lake, saltier than the Black Sea, features tufa formations that makes the place look like it could be on the moon
</div>
</div>
</body>
</html>
```

将以下内容放入你的`stylesheet`：

```php
.picture {
  width:200px;
  height:130px;
  border:5px solid white;
  margin-left:25px;
  margin-top:40px;

}
.entry {

  width:600px;
  margin:0 auto;

}
.picturebox {
  background-color:teal;
  color:white;  
  width:270px;
  height:220px;
  text-align:center;
  vertical-align:middle;
  /* float:left;  */
  border-bottom:1px solid #FFDEAD;

}
.textbox {

  background-color:teal;
  color:white;  
  width:250px;
  height:180px;
  padding:40px 10px 0px 10px;
  /* float:left; */
  border-bottom:1px solid #FFDEAD;
  text-align:left;
}
```

如果你在这个例子中运行浏览器，你会注意到，尽管用另一个`div`标签包裹了它们，图片和与之相关的文本仍然不是并排的，而是堆叠在一起的。解决方案已经存在，但被放在了`/*`和`*/`字符串中作为注释。取消注释这些行，就像魔法一样，一切都会看起来像你想要的那样。

# 定位

您可以使用几个 CSS 属性来改变页面元素的位置。最具影响力的一个被称为 **float**（每次我使用它时，它都会让我想起斯蒂芬·金小说和电影《它！》中的小丑角色，当它说：“它们都飘浮着！”）

## 浮动

我认为 CSS 浮动属性是 CSS 堆叠元素的另一种方式。如果您给所有这些元素一个：

```php
float:left;
```

您可以从左到右堆叠它们。使用一个：

```php
float:right;
```

您可以从右到左堆叠它们。当您想在有空间的情况下将页面的一部分，例如一个介绍，放在右侧，如果没有空间则放在顶部时，这会非常有用。在我们的上述示例中，将左浮动改为右浮动会将图片放在右侧。

## position:relative

CSS **position** 属性可以用来将元素定位在页面上一个不同于它们通常位置的地方。"通常" 与 `position:static` 相同。看看以下代码：

```php
#redsquare
{
width:100px;
height:100px;
background-color:red;
}
```

这将在其父元素的左上角产生一个红色方块。现在，尝试以下操作：

```php
#redsquare
{
position:relative;
width:100px;
height:100px;
background-color:red;
left:10px;
top:100px;
}
```

红色方块向下移动 `100px`，向右移动 `10px`。

## position:absolute

让我们添加：

```php
#container
{
  width:700px;
  margin:50px;
  background-color:teal;
  height:500px;
}
```

和

```php
<body>
<div id="container">
<div id="redsquare">

</div>
</div>
</body>
```

红色方块现在位于青色方块内部，向下 `100px`，向右 `10px`。当您将相对改为 **绝对** 时，红色方块将向下 `100px`，向右 `10px`，相对于祖先元素。这通常是浏览器窗口本身。

# 列表样式

您最终会大量使用的一个元素是 `<ul>` 标签：无序列表。默认情况下，列表中的每个项目都将显示一个圆形项目符号在文本前面。使用 CSS，您可以更改列表的样式。

## list-style-type

使用此属性，您可以更改项目符号的形状。您可以使用的某些值包括：`none`（根本不显示项目符号），`square`（一个方块），`circle`（一个小圆圈），或 `disc`（默认）。

## list-style-image

您可以使用 **list-style-image** 属性来为项目符号提供自己的图像。默认值是 `none`，这意味着项目符号图像由 **list-style-type** 的值决定。但是，如果您指定 `url`，然后是图像的路径，则将使用该图像，例如：

```php
url('smiley.gif')
```

## list-style-position

默认情况下，项目符号出现在内容流之外。如果您将 **list-style-position** 的值指定为 `inside`，则项目符号将移动到内部，文本将更靠右。

# 锚样式 – 伪类

我们通过介绍一些伪类来结束对 CSS 属性的选择，这些伪类通常但不仅限于与 `<a>` 标签一起使用，即 **锚** 标签。锚标签主要用于链接。为了使它们确实看起来像是链接，`<a>` 的默认样式恰好是蓝色，并且文本被下划线，这并不太吸引人。

使用伪类，你可以根据光标相对于链接的位置以及链接是否已被访问，给锚标签（理论上任何标签）赋予不同的外观。以下是一个示例：

```php
a:link {
text-decoration:none;  /* switches off the underline */
}
a:hover {
color:white;   /* changes color to white when the curser hangs over it (hover)  */
}
a:visited {
color:yellow;   /* changes the color to indicate that you already visited that link */
}
```

## Firebug

无论你如何学习这一章节以及关于 CSS 的各种在线参考资料，时不时地你会发现事物并不像预期的那样显示。这时，一个调试工具如**Firebug**就派上用场了。Firebug 是 Firefox 浏览器的扩展程序。它允许你点击页面上的部分，然后程序会显示相关的 HTML 和 CSS，甚至还会显示一个显示填充、边框和边距的盒模型图片。大多数其他浏览器，特别是 Safari 和 Chrome，都有类似的对应工具。

# 摘要

在本章中，我们为您概述了 CSS。这不是一个完整的参考，但我们确实包括了所有浏览器都应该支持的常用和有用的 CSS 属性。我们故意没有包括一些在 CSS3 中引入的新属性。本书的第二部分将介绍一个重要的新 CSS 特性：**媒体查询**。这对于构建响应式设计至关重要，但这个主题至少需要一章来详细讨论。

到目前为止，我们已经学习了创建网站所需的两种语言：HTML 和 CSS。无需进一步延迟，我们现在继续学习下一个，一种真正的编程语言：**JavaScript**。
