- en: Chapter 7. Database in an OOP Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：面向对象的数据库
- en: Besides regular improvements in the OOP, PHP5 also introduces many new libraries
    to seamlessly work with database in an OOP way. These libraries provide you with
    improved performance, sometimes improved security features, and of course a whole
    lot of methods to interact with new features provided by the database server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在面向对象（OOP）方面的常规改进外，PHP5还引入了许多新的库，以便以面向对象的方式无缝地与数据库工作。这些库为您提供了改进的性能，有时还提供了改进的安全性功能，当然还有一大堆与数据库服务器提供的新功能交互的方法。
- en: In this chapter we will discuss MySQL improved API, which is known as MySQLi.
    Take a look at basic PDO (well, not detailed because PDO is so huge that it is
    possible to write a whole book just on it), ADOdb, and PEAR::MDB2\. In the mean
    time we will also take a look at Active Record pattern in PHP using ADOdb's active.
    One thing to note here is that we are not focusing on how to do general database
    manipulations. We will only focus on some specific topics which are interesting
    for PHP developers who are doing database programming in an OO way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论MySQL改进的API，即MySQLi。看看基本的PDO（好吧，不是详细的，因为PDO如此庞大，以至于可以写一本书专门介绍它），ADOdb，以及PEAR::MDB2。同时，我们还将看看使用ADOdb的active在PHP中实现的Active
    Record模式。在这里要注意的一点是，我们不是关注如何进行一般的数据库操作。我们只会关注一些对在面向对象方式中做数据库编程的PHP开发者来说有趣的具体主题。
- en: Introduction to MySQLi
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQLi简介
- en: MySQLi is an improved extension introduced in PHP5 to work with advanced MySQL
    features like prepared statements and stored procedures. From a performance point
    of view, MySQLi is much better than a MySQL extension. Also this extension offers
    completely object oriented interfaces to work with a MySQL database which was
    not available before PHP5\. But keep in mind that if your MySQL version is at
    least 4.1.3 or above, you will get it working.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: MySQLi是PHP5中引入的一个改进的扩展，用于处理高级MySQL功能，如预定义语句和存储过程。从性能角度来看，MySQLi比MySQL扩展要好得多。此外，此扩展提供了完全面向对象的接口来与MySQL数据库交互，这在PHP5之前是不存在的。但请记住，如果你的MySQL版本至少是4.1.3或更高版本，你将能够使其工作。
- en: 'So what are the major improvements? Let''s have a look first:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么主要的改进有哪些呢？让我们先看看：
- en: Improved performance over MySQL extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优于MySQL扩展
- en: Flexible OO and Non OO interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的面向对象和非面向对象接口
- en: Advantage over new MySQL objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相较于新MySQL对象的优点
- en: Ability to create compressed connections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建压缩连接
- en: Ability to connect over SSL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持通过SSL连接
- en: Support for Prepared Statements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持预定义语句
- en: Support for Stored Procedure (SP)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持存储过程（SP）
- en: Support for better replication and transaction
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持更好的复制和事务
- en: We will look into some of these features in the following examples. But of course
    we are not going for anything introductory to MySQL, because that is out of scope
    for this book. We will just show you how to use OO interface using MySQLi and
    how to use some of these advanced features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的例子中查看一些这些功能。但当然，我们不是要介绍MySQL的基础知识，因为这超出了本书的范围。我们只会展示如何使用MySQLi的面向对象接口，以及如何使用这些高级功能中的某些功能。
- en: Connecting to MySQL in an OO Way
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以面向对象的方式连接到MySQL
- en: 'Remember those old days when you had to use procedural function `call` to connect
    to MySQL, even from your objects. Those days are over. Now you can take advantage
    of complete OO interface of MySQLi to talk to MySQL (well, there are a few procedural
    methods, but overall it''s completely OO). Take a look at the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那些老日子，那时候你不得不使用过程式函数`call`来连接MySQL，即使是来自你的对象。那些日子已经过去了。现在你可以利用MySQLi的完整面向对象接口与MySQL进行通信（好吧，还有一些过程式方法，但总体上是完全面向对象的）。看看下面的例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the connection fails, you may get an error message like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，你可能会得到如下错误信息：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Selecting Data in an OO Way
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以面向对象的方式选择数据
- en: Let's see how to select data from a table in an OO way using MySQLi API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用MySQLi API以面向对象的方式从表中选择数据。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that it is not good practice to store users' passwords in plain
    text in your database without encrypting them in some way. The best way is to
    store just the hash of their passwords using some hash routines like `md5()`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在数据库中不加密地将用户密码以纯文本形式存储并不是一个好的做法。最好的方式是使用某些散列例程（如`md5()`）仅存储他们密码的散列。
- en: Updating Data in an OO Way
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以面向对象的方式更新数据
- en: There is no special deal with it. You can update your data as you previously
    did with MySQL extension. But for the sake of OO style, we are showing an example
    of how you can do that with `mysqli_query()` function as shown in the above example.
    Instantiate an instance of MySQLi object and then run the query.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与它没有特别的处理。你可以像之前使用 MySQL 扩展一样更新你的数据。但为了面向对象风格的考虑，我们展示了如何使用 `mysqli_query()`
    函数来执行，如上述示例所示。实例化一个 MySQLi 对象，然后运行查询。
- en: Prepared Statements
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理语句
- en: Here we are in a really interesting section which has been introduced for the
    first time in PHP OO using MySQLi extension. The prepared statements are introduced
    in MySQL 5.0 versions (dynamic SQL) for better security and flexibility. It has
    a great performance boost over the regular one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们进入了一个非常有趣的章节，这是在 PHP OO 中首次使用 MySQLi 扩展引入的。预处理语句是在 MySQL 5.0 版本（动态 SQL）中引入的，以提高安全性和灵活性。它比常规语句有显著的性能提升。
- en: So what is actually a prepared statement? A prepared statement is nothing but
    a regular query that is pre-compiled by the MySQL sever that could be invoked
    later. Prepared statements reduce the chances of SQL injection and offers greater
    performance over the general non-prepared queries, as it need not perform different
    compilation steps at the run time.(It is already compiled, remember?)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么实际上什么是预处理语句？预处理语句只不过是一个由 MySQL 服务器预先编译的常规查询，可以在以后调用。预处理语句减少了 SQL 注入的可能性，并且与一般的非预处理查询相比提供了更好的性能，因为它不需要在运行时执行不同的编译步骤。（记住，它已经编译过了？）
- en: 'The following are advantages of using prepared statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理语句的优点如下：
- en: Better Performance
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的性能
- en: Prevention of SQL injection
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预防 SQL 注入
- en: Saving memory while handling blobs
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理 BLOB 时节省内存
- en: But there are drawbacks too!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有缺点！
- en: There is no performance boost if you use prepared statements for a single call.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只为单个调用使用预处理语句，那么不会有性能提升。
- en: There is no query cache for using prepared statements.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理语句没有查询缓存。
- en: Chance of memory leak if statements are not closed explicitly.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果语句没有显式关闭，则可能会发生内存泄漏。
- en: Not all statements can be used as a prepared statement.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有语句都可以用作预处理语句。
- en: Prepared statements can accept parameters at run time in the same order you
    specify them whilst preparing the query. In this section we will learn about creating
    prepared statements, passing values to them, and fetching results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句可以在准备查询时接受参数，其顺序与准备查询时指定的顺序相同。在本节中，我们将学习如何创建预处理语句，向它们传递值，并获取结果。
- en: Basic Prepared Statements
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本预处理语句
- en: 'Let''s prepare a statement using PHP''s native MySQLi extension. In the following
    example we will make a prepared statement, execute it, and fetch the result from
    it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PHP 的原生 MySQLi 扩展来准备一个语句。在以下示例中，我们将创建一个预处理语句，执行它，并从中获取结果：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So what did we actually do in the above example?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在上面的示例中我们实际上做了什么？
- en: 'We prepared the statement using the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码准备语句：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we executed it:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们执行了它：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we bound two variables with it, as there are two variables in our query:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用它与两个变量绑定，因为我们的查询中有两个变量：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally we fetched the result using:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们使用以下方式获取结果：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Whenever we called `fetch()`, the bound variables are populated with values.
    So we can now use them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用 `fetch()` 时，绑定的变量会被填充值。因此，我们现在可以使用它们。
- en: Prepared Statements with Variables
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带变量的预处理语句
- en: 'The advantage of prepared statements is that you can use variables with queries.
    First you can prepare the query by placing a `?` sign at the appropriate place,
    and then you can pass the value after preparing it. Let''s have a look at the
    following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句的优势在于你可以使用变量与查询结合。首先，你可以在适当的位置放置一个 `?` 符号来准备查询，然后你可以在准备之后传递值。让我们看看以下示例：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we prepare the query `"select name, pass from users where name=?`" where
    the name is definitely a string type value. As we bind parameters in the previous
    example for the result using `bind_results()`, here we have to bind parameters
    using `bind_params()` function. Besides that, we need to supply the data type
    of the parameters bound.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们准备查询 `"select name, pass from users where name=?`"，其中名称肯定是一个字符串类型的值。正如我们在前面的示例中使用
    `bind_results()` 绑定参数以获取结果一样，这里我们必须使用 `bind_params()` 函数来绑定参数。除此之外，我们还需要提供绑定参数的数据类型。
- en: 'MySQL prepared statements support four types of parameters:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 预处理语句支持四种类型的参数：
- en: '`i`, means the corresponding variable has type integer'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`，表示相应的变量是整数类型'
- en: '`d`, means the corresponding variable has type double'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`，表示相应的变量是双精度浮点数'
- en: '`s`, means the corresponding variable has type string'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 表示相应的变量具有字符串类型'
- en: '`b`, means the corresponding variable is a blob and will be sent in packets'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` 表示相应的变量是一个二进制大对象（blob），并且将以数据包的形式发送'
- en: 'As our parameter is a string, we used the following line to bind the parameter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的参数是字符串，我们使用了以下行来绑定参数：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After binding the variable, now we set the value to `$name` and call the `execute()`
    function. After that we fetch the values as before.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定变量之后，我们现在将值设置为 `$name` 并调用 `execute()` 函数。之后，我们像之前一样检索值。
- en: Using BLOB with Prepared Statements
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预处理语句与 BLOB
- en: Prepared statements support handling **BLOB** or **Binary Large Objects** efficiently.
    If you manage BLOB with prepared statements, it will save you from greater memory
    consumption by sending the data as packets. Let's see how we can store BLOB (in
    this case, an image file).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句支持高效地处理 **BLOB** 或 **二进制大对象**。如果你使用预处理语句管理 BLOB，它将通过以数据包的形式发送数据来节省你更多的内存消耗。让我们看看我们如何存储
    BLOB（在这种情况下，是一个图像文件）。
- en: Prepared statements support sending data in chunks using the `send_long_data()`
    function. In the following example we will store the image using this function,
    though you can send them as usual, unless your data exceeds the limit defined
    by the `max_allowed_packet` MySQL configuration variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句支持使用 `send_long_data()` 函数分块发送数据。在下面的例子中，我们将使用这个函数来存储图像，尽管你可以像通常一样发送它们，除非你的数据超过了由
    `max_allowed_packet` MySQL 配置变量定义的限制。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our table schema is as shown below:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表模式如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We choose medium BLOB as our data type because blob can store only 65KB of data,
    where as medium BLOB can store more than 16MB, and long blob can store more than
    4GB data in it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择中等 BLOB 作为我们的数据类型，因为 blob 只能存储 65KB 的数据，而中等 BLOB 可以存储超过 16MB，长 BLOB 可以在其中存储超过
    4GB 的数据。
- en: 'Now we will restore this BLOB data using the image again in prepared statement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用图像再次在预处理语句中恢复这个 BLOB 数据：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Executing Stored Procedure with MySQLi and PHP
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MySQLi 和 PHP 执行存储过程
- en: 'Stored procedure is another new addition to MySQL 5 which reduces the need
    for client‑side queries to a great extent. Using MySQLi extension, you can execute
    stored procedures in MySQL. We are not going to discuss stored procedures as that
    is out of scope for this book. There are several articles available in the Internet
    that will help you in writing stored procedures in MySQL. You can read this awesome
    one for getting a basic idea about advanced MySQL features: [http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf](http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程是 MySQL 5 中新增的另一个功能，它极大地减少了客户端查询的需求。使用 MySQLi 扩展，你可以在 MySQL 中执行存储过程。我们不会讨论存储过程，因为这超出了本书的范围。互联网上有几篇文章可以帮助你在
    MySQL 中编写存储过程。你可以阅读这篇很棒的文章来获取关于高级 MySQL 功能的基本概念：[http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf](http://dev.mysql.com/tech-resources/articles/mysql-storedprocedures.pdf)
- en: 'Let''s create a small stored procedure and run it using PHP. This stored procedure
    can take an input and insert that record in a table:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小型的存储过程并使用 PHP 来运行它。这个存储过程可以接受一个输入并将该记录插入到表中：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you run this stored procedure in your database (using MySQL query builder
    or anything) the `sp_create_user` procedure will be created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个数据库中运行这个存储过程（使用 MySQL 查询构建器或其他任何东西），`sp_create_user` 过程将被创建。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can manually execute any stored, procedure from MySQL client using "Execute"
    command. For example to execute the above stored procedure you have to use `call
    sp_create_user('` *`username`*`')`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 "Execute" 命令手动从 MySQL 客户端执行任何已存储的过程。例如，要执行上述存储过程，你必须使用 `call sp_create_user('`
    *`username`*`')`。
- en: Now we will run this stored procedure using PHP code. Let's see.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 PHP 代码来运行这个存储过程。让我们看看。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: PDO
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PDO
- en: Another new extension added in PHP 5.1 for managing databases is PDO (although
    PDO was available with PHP 5.0 as a PECL Extension). This comes with a set of
    drivers for working with different database engines. **PDO** stands for **PHP
    Data Objects**. It is developed to provide a lightweight interface for different
    database engines. And one of the very good features of PDO is that it works like
    a Data Access Layer so that you can use the same function names for all database
    engines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 5.1 中新增的另一个用于管理数据库的扩展是 PDO（尽管 PDO 在 PHP 5.0 中作为 PECL 扩展可用）。它包含了一组用于与不同数据库引擎工作的驱动程序。**PDO**
    代表 **PHP 数据对象**。它是为了提供不同数据库引擎的轻量级接口而开发的。PDO 的一个非常好的特性是它像数据访问层一样工作，这样你就可以为所有数据库引擎使用相同的函数名。
- en: You can connect to different databases using DSN (Data Source Name) strings.
    In the following example we will connect to a MySQL databases and retrieve some
    data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 DSN（数据源名称）字符串连接到不同的数据库。在以下示例中，我们将连接到 MySQL 数据库并检索一些数据。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's fairly hassle free, right? It just connects to MySQL server with the
    DSN (here it connects to `test` database) and then executes the query. And Finally
    we display the result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当方便，对吧？它只是通过 DSN（这里连接到 `test` 数据库）连接到 MySQL 服务器，然后执行查询。最后，我们显示结果。
- en: So what would this be like if we connected to a SQLite database?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们连接到 SQLite 数据库会是什么样子呢？
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See there is no change in the code except the DSN.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码中除了 DSN 之外没有变化。
- en: 'You can also create a SQLite database in memory and perform the operation there.
    Let''s see the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在内存中创建 SQLite 数据库并在此处执行操作。让我们看一下以下代码：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We just changed the DSN here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在这里更改了 DSN。
- en: DSN Settings for Different Databases Engines
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同数据库引擎的 DSN 设置
- en: 'Let us take a look at the DSN settings for different database engines to connect
    with PDO. Supported database drivers are as shown below:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下不同数据库引擎与 PDO 连接的 DSN 设置。支持的数据库驱动程序如下所示：
- en: PDO_DBLIB for FreeTDS/Microsoft SQL Server/Sybase
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_DBLIB 用于 FreeTDS/Microsoft SQL Server/Sybase
- en: PDO_FIREBIRD for Firebird/Interbase 6
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_FIREBIRD 用于 Firebird/Interbase 6
- en: PDO_INFORMIX for IBM Informix Dynamic Server
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_INFORMIX 用于 IBM Informix Dynamic Server
- en: PDO_MYSQL for MySQL 3.x/4.x/5.x
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_MYSQL 用于 MySQL 3.x/4.x/5.x
- en: PDO_OCI for Oracle Call Interface
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_OCI 用于 Oracle Call Interface
- en: PDO_ODBC for ODBC v3 (IBM DB2, unixODBC and win32 ODBC)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_ODBC 用于 ODBC v3（IBM DB2、unixODBC 和 win32 ODBC）
- en: PDO_PGSQL for PostgreSQL
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_PGSQL 用于 PostgreSQL
- en: PDO_SQLITE for SQLite 3 and SQLite 2
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDO_SQLITE 用于 SQLite 3 和 SQLite 2
- en: 'Let''s have a look at these sample driver-specific DSN settings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这些示例驱动程序特定的 DSN 设置：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using Prepared Statements with PDO
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PDO 的预处理语句
- en: Using PDO you can run prepared statements against your database. The benefits
    are the same as before. It increases the performance for multiple calls by parsing
    and caching the server-side query and it also eliminates the chance of SQL injection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PDO 对您的数据库运行预处理语句。好处与之前相同。它通过解析和缓存服务器端查询来提高多次调用的性能，同时也消除了 SQL 注入的机会。
- en: PDO prepared statements can take named variables, unlike what we've seen in
    the examples of MySQLi.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前在 MySQLi 的示例中看到的不同，PDO 预处理语句可以接受命名变量。
- en: 'Let''s take a look at the following example to understand this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例来理解这一点：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But you can also run the example like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但您也可以像这样运行示例：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of calling `bindParam()`, you can use `bindValues()` like the following
    one:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用 `bindParam()` 不同，您可以使用以下类似的 `bindValues()`：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Calling Stored Procedures
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用存储过程
- en: 'PDO provides an easy way to call stored procedures. All you have to do is run
    "CALL SPNAME(PARAMS)" via `exec()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PDO 提供了一种简单的方法来调用存储过程。您只需通过 `exec()` 方法运行 "CALL SPNAME(PARAMS)" 即可：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other Interesting Functions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有趣的函数
- en: 'There are several other interesting functions available in PDO. For example,
    take a look at the list below:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PDO 中还有其他几个有趣的函数可用。例如，看一下下面的列表：
- en: '`fetchAll()`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll()`'
- en: '`fetchColumn()`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchColumn()`'
- en: '`rowCount()`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowCount()`'
- en: '`setFetchMode()`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFetchMode()`'
- en: 'The `fetchAll()` function can fetch all records from a result set. Let''s have
    a look at the following example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchAll()` 函数可以从结果集中检索所有记录。让我们看一下以下示例：'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `fetchColumn()` function helps to select data from any specific column
    after executing the statement. Let''s take a look:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchColumn()` 函数有助于在执行语句后从任何特定列中选择数据。让我们看一下：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`rowCount()` returns the number of affected rows after performing any `UPDATE`
    or `DELETE` query. But you must remember that it returns the number of affected
    rows by the latest executed query.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowCount()` 在执行任何 `UPDATE` 或 `DELETE` 查询后返回受影响的行数。但您必须记住，它返回的是最新执行的查询影响的行数。'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`setFetchMode()` helps you to set the fetch mode of PDO prepared statements.
    The available values are:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFetchMode()` 帮助您设置 PDO 预处理语句的检索模式。可用的值包括：'
- en: '`PDO::FETCH_NUM`: Fetch results as a numerically indexed array'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_NUM`: 以数字索引数组的形式检索结果'
- en: '`PDO::FETCH_ASSOC`: Fetch rows as index by column names as keys'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_ASSOC`: 以列名作为键检索行'
- en: '`PDO::FETCH_BOTH`: Fetch as both of the above'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_BOTH`: 以上述两种方式检索'
- en: '`PDO::FETCH_OBJ`: Fetch the rows as objects where column names are set as properties.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PDO::FETCH_OBJ`: 将行作为对象检索，其中列名设置为属性'
- en: Introduction to Data Abstraction Layers
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据抽象层简介
- en: '**Data Abstraction Layers** (**DALs**) are developed to provide unified interfaces
    to work with every database engine. It provides similar API to work with every
    database engine independently. As the function names are similar for all platforms,
    they are easier to work with, easier to remember, and of course make your code
    portable. To make you understand the necessity of DAL, let me explain a common
    scenario.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据抽象层（DALs**）是为了提供统一的接口以与每个数据库引擎一起工作而开发的。它为每个数据库引擎提供类似的API进行独立操作。由于所有平台上的函数名称相似，因此它们更容易使用，更容易记忆，当然也使得代码更易于移植。为了让您了解DAL的必要性，让我解释一个常见的场景。'
- en: Suppose Team Y gets a big project. Their client says that they will use MySQL.
    So team Y develops the application and when the time comes to deliver, the client
    requests the team to give support for PostgreSQL. They will pay for this change
    but they require the change early.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Y团队接到了一个大项目。他们的客户说他们将使用MySQL。因此，Y团队开发了应用程序，当交付时间到来时，客户要求团队提供对PostgreSQL的支持。他们将为此变更付费，但需要尽早完成。
- en: Team Y had designed the application using all native MySQL functions. So what
    will Team Y do? Will they rewrite everything to give support for PostgreSQL? Well,
    that is the only way they have to. But what will happen if they need to give support
    for MSSQL in the near future? Another rewrite? Can you imagine the cost of refactoring
    each and every time?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Y团队使用所有原生MySQL函数设计了应用程序。那么Y团队会怎么做？他们会重写一切以支持PostgreSQL吗？嗯，这是他们唯一的选择。但如果他们未来需要支持MSSQL呢？另一个重写？你能想象每次重构的成本吗？
- en: To save from these disasters, here comes the need for DAL where the code will
    remain the same and it could be changed to support any DB at any time without
    any major change.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些灾难，就需要有DAL，这样代码就可以保持不变，并且可以在任何时间更改以支持任何数据库，而无需进行任何重大更改。
- en: There are many popular libraries to implement DAL for PHP. To name some of those,
    ADOdb and PEAR::MDB2 are very popular. PEAR::DB was very popular but its development
    has been discontinued ([http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended](http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的库用于实现PHP的DAL。以下是一些例子，如ADOdb和PEAR::MDB2非常流行。PEAR::DB曾经非常流行，但其开发已经停止（[http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended](http://blog.agoraproduction.com/index.php?/archives/42-PEARDB-is-DEPRECATED,-GOT-IT.html#extended)）。
- en: In this section we will discuss PEAR::MDB2 and ADOdb. We will see the basic
    database operations using it and learn how to install these libraries for working
    around.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论PEAR::MDB2和ADOdb。我们将使用它查看基本的数据库操作，并学习如何安装这些库以进行工作。
- en: ADOdb
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADOdb
- en: ADOdb is a nice and popular data abstraction layer developed by John Lim and
    released under LGPL. This is one of the very best data abstraction layers for
    PHP. You can get the latest version of ADOdb from [http://adodb.sourceforge.net](http://adodb.sourceforge.net).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ADOdb是由John Lim开发的一个非常好且流行的数据抽象层，并发布在LGPL下。这是PHP中最好的数据抽象层之一。您可以从[http://adodb.sourceforge.net](http://adodb.sourceforge.net)获取ADOdb的最新版本。
- en: Installing ADOdb
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 ADOdb
- en: 'There is no install of ADodb as such. It is a set of classes and regular scripts.
    So all you have to do is just extract the archive in a location from where you
    can include the script. Let''s take a look at the following image to understand
    the directory structure after extracting:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ADodb的安装。它是一组类和常规脚本。所以您只需将存档提取到可以包含脚本的位置即可。让我们看一下以下图像，了解提取后的目录结构：
- en: '![Installing ADOdb](img/2561_07_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![安装 ADOdb](img/2561_07_01.jpg)'
- en: Connecting to Different Databases
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到不同的数据库
- en: Like PDO, you can connect to different database drivers using ADOdb. DSN is
    different from PDO. Let's take a look at the supported database list and their
    DSN strings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与PDO一样，您可以使用ADOdb连接到不同的数据库驱动程序。DSN与PDO不同。让我们看一下支持的数据库列表及其DSN字符串。
- en: 'ADOdb supports a common DSN format, like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ADOdb支持常见的DSN格式，如下所示：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So what are the available drivers supported by ADOdb? Let''s take a look below.
    This is a list taken from the ADOdb manual for your understanding:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，ADOdb支持哪些可用的驱动程序呢？下面让我们看一下。这是一个从ADOdb手册中摘取的列表，供您理解：
- en: '| Name | Tested | Database | Prerequisites | Operating Systems |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 测试 | 数据库 | 预先条件 | 操作系统 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| access | B | Microsoft Access/Jet. You need to create an ODBC DSN. | ODBC
    | Windows only |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | B | Microsoft Access/Jet。您需要创建一个ODBC DSN。 | ODBC | 仅限Windows |'
- en: '| ado | B | Generic ADO, not tuned for specific databases. Allows DSN-less
    connections. For best performance, use an OLEDB provider. This is the base class
    for all ado drivers.You can set `$db->codePage` before connecting. | ADO or OLEDB
    provider | Windows only |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| ado | B | 通用 ADO，未针对特定数据库进行优化。允许无 DSN 连接。为了最佳性能，请使用 OLEDB 提供程序。这是所有 ado 驱动的基类。您可以在连接之前设置
    `$db->codePage`。| ADO 或 OLEDB 提供程序 | 仅限 Windows |'
- en: '| ado_access | B | Microsoft Access/Jet using ADO. Allows DSN‑less connections.
    For best performance, use an OLEDB provider. | ADO or OLEDB provider | Windows
    only |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| ado_access | B | 使用 ADO 的 Microsoft Access/Jet。允许无 DSN 连接。为了最佳性能，请使用 OLEDB
    提供程序。| ADO 或 OLEDB 提供程序 | 仅限 Windows |'
- en: '| ado_mssql | B | Microsoft SQL Server using ADO. Allows DSN-less connections.
    For best performance, use an OLEDB provider. | ADO or OLEDB provider | Windows
    only |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| ado_mssql | B | 使用 ADO 的 Microsoft SQL Server。允许无 DSN 连接。为了最佳性能，请使用 OLEDB
    提供程序。| ADO 或 OLEDB 提供程序 | 仅限 Windows |'
- en: '| db2 | C | Uses PHP''s db2-specific extension for better performance. | DB2
    CLI/ODBC interface | Unix and Windows. Requires IBM DB2 Universal Database client
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| db2 | C | 使用 PHP 的 db2 特定扩展以获得更好的性能。| DB2 CLI/ODBC 接口 | Unix 和 Windows。需要
    IBM DB2 Universal Database 客户端 |'
- en: '| odbc_db2 | C | Connects to DB2 using generic ODBC extension. | DB2 CLI/ODBC
    interface | Unix and Windows. Unix install hints. I have had reports that the
    `$host` and `$database` params have to be reversed in `Connect()` when using the
    CLI interface |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| odbc_db2 | C | 使用通用的 ODBC 扩展连接到 DB2。| DB2 CLI/ODBC 接口 | Unix 和 Windows。Unix
    安装提示。我收到报告说在使用 CLI 接口时，在 `Connect()` 中必须将 `$host` 和 `$database` 参数颠倒过来。|'
- en: '| vfp | A | Microsoft Visual FoxPro. You need to create an ODBC DSN. | ODBC
    | Windows only |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| vfp | A | Microsoft Visual FoxPro。您需要创建一个 ODBC DSN。| ODBC | 仅限 Windows |'
- en: '| fbsql | C | FrontBase. | ? | Unix and Windows |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| fbsql | C | FrontBase。| ? | Unix 和 Windows |'
- en: '| ibase | B | Interbase 6 or earlier. Some users report you might need to use
    this`$db->PConnect(''localhost:c:/ibase/employee.gdb'', "sysdba", "masterkey")`
    to connect. Lacks `Affected_Rows` currently.You can set `$db->role`, `$db->dialect`,
    `$db->buffers` and `$db->charSet` before connecting. | Interbase client | Unix
    and Windows |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| ibase | B | Interbase 6 或更早版本。一些用户报告说您可能需要使用此 `$db->PConnect(''localhost:c:/ibase/employee.gdb'',
    "sysdba", "masterkey")` 来连接。目前缺少 `Affected_Rows`。您可以在连接之前设置 `$db->role`，`$db->dialect`，`$db->buffers`
    和 `$db->charSet`。| Interbase 客户端 | Unix 和 Windows |'
- en: '| firebird | B | Firebird version of interbase. | Interbase client | Unix and
    Windows |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| firebird | B | Firebird 版本的 interbase。| Interbase 客户端 | Unix 和 Windows |'
- en: '| borland_ibase | C | Borland version of Interbase 6.5 or later. Very sad that
    the forks differ. | Interbase client | Unix and Windows |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| borland_ibase | C | Borland 版本的 Interbase 6.5 或更高版本。非常遗憾分支不同。| Interbase
    客户端 | Unix 和 Windows |'
- en: '| informix | C | Generic informix driver. Use this if you are using Informix
    7.3 or later. | Informix client | Unix and Windows |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| informix | C | 通用 informix 驱动程序。如果您使用的是 Informix 7.3 或更高版本，请使用此驱动程序。| Informix
    客户端 | Unix 和 Windows |'
- en: '| informix72 | C | Informix databases before Informix 7.3 that do no support
    `SELECT FIRST`. | Informix client | Unix and Windows |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| informix72 | C | 不支持 `SELECT FIRST` 的 Informix 7.3 之前的数据库。| Informix 客户端
    | Unix 和 Windows |'
- en: '| ldap | C | LDAP driver. See this example for usage information. | LDAP extension
    | ? |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| ldap | C | LDAP 驱动程序。有关使用信息，请参阅此示例。| LDAP 扩展 | ? |'
- en: '| mssql | A | Microsoft SQL Server 7 and later. Works with Microsoft SQL Server
    2000 also. Note that date formating is problematic with this driver. For example,
    the PHP MSSQL extension does not return the seconds for datetime! | Mssql client
    | Unix and Windows. Unix install howto and another one. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| mssql | A | Microsoft SQL Server 7 及更高版本。也适用于 Microsoft SQL Server 2000。注意，此驱动程序中的日期格式有问题。例如，PHP
    MSSQL 扩展不返回 datetime 的秒数！| Mssql 客户端 | Unix 和 Windows。Unix 安装指南和另一个指南。|'
- en: '| mssqlpo | A | Portable mssql driver. Identical to above mssql driver, except
    that ''&#124;&#124;'', the concatenation operator, is converted to ''+''. Useful
    for porting scripts from most other sql variants that use &#124;&#124;. | Mssql
    client | Unix and Windows. Unix install howto. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| mssqlpo | A | 可移植的 mssql 驱动程序。与上述 mssql 驱动程序相同，除了将 `''||''`，连接运算符，转换为 `+`。对于从大多数其他使用
    `''||''` 的 sql 变体移植脚本非常有用。| Mssql 客户端 | Unix 和 Windows。Unix 安装指南。|'
- en: '| mysql | A | MySQL without transaction support. You can also set `$db->clientFlags`
    before connecting. | MySQL client | Unix and Windows |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| mysql | A | 无事务支持的 MySQL。您也可以在连接之前设置 `$db->clientFlags`。| MySQL 客户端 | Unix
    和 Windows |'
- en: '| mysqli | B | Supports the newer PHP5 MySQL API. | MySQL 4.1+ client | Unix
    and Windows |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| mysqli | B | 支持较新的 PHP5 MySQL API。| MySQL 4.1+ 客户端 | Unix 和 Windows |'
- en: '| mysqlt or maxsql | A | MySQL with transaction support. We recommend using
    &#124;&#124; as the concat operator for best portability. This can be done by
    running MySQL using: `mysqld --ansi or mysqld --sql-mode=PIPES_AS_CONCAT` | MySQL
    client | Unix and Windows |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| mysqlt or maxsql | A | 具有事务支持的 MySQL。我们建议使用 `||` 作为连接运算符以获得最佳兼容性。可以通过以下方式运行
    MySQL：`mysqld --ansi` 或 `mysqld --sql-mode=PIPES_AS_CONCAT`。 | MySQL 客户端 | Unix
    和 Windows |'
- en: '| oci8 | A | Oracle 8/9\. Has more functionality than oracle driver (eg. `Affected_Rows`).
    You might have to `putenv(''ORACLE_HOME=...'')` before Connect/PConnect.There
    are 2 ways of connecting: with server IP and service name: `PConnect(''serverip:1521'',''scott'',''tiger'',''service'')`or
    using an entry in TNSNAMES.ORA or ONAMES or HOSTNAMES: `PConnect(false, ''scott'',
    ''tiger'', $oraname)`.Since 2.31, we support Oracle REF cursor variables directly
    (see `ExecuteCursor`). | Oracle client | Unix and Windows |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| oci8 | A | Oracle 8/9。比 oracle 驱动程序具有更多功能（例如 `Affected_Rows`）。您可能需要在 Connect/PConnect
    之前执行 `putenv(''ORACLE_HOME=...'')`。有两种连接方式：使用服务器 IP 和服务名称：`PConnect(''serverip:1521'',''scott'',''tiger'',''service'')`
    或使用 TNSNAMES.ORA 或 ONAMES 或 HOSTNAMES 中的条目：`PConnect(false, ''scott'', ''tiger'',
    $oraname)`。自 2.31 版本起，我们直接支持 Oracle REF cursor 变量（请参阅 `ExecuteCursor`）。 | Oracle
    客户端 | Unix 和 Windows |'
- en: '| oci805 | C | Supports reduced Oracle functionality for Oracle 8.0.5\. `SelectLimit`
    is not as efficient as in the oci8 or oci8po drivers. | Oracle client | Unix and
    Windows |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| oci805 | C | 支持 Oracle 8.0.5 的简化功能。`SelectLimit` 在 oci8 或 oci8po 驱动程序中效率不高。
    | Oracle 客户端 | Unix 和 Windows |'
- en: '| oci8po | A | Oracle 8/9 portable driver. This is nearly identical with the
    oci8 driver except (a) bind variables in `Prepare()` use the `?` convention, instead
    of `:bindvar`, (b) field names use the more common PHP convention of lowercase
    names.Use this driver if porting from other databases is important. Otherwise
    the oci8 driver offers better performance. | Oracle client | Unix and Windows
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| oci8po | A | Oracle 8/9 可移植驱动程序。此驱动程序与 oci8 驱动程序几乎相同，除了（a）`Prepare()` 中的绑定变量使用
    `?` 约定，而不是 `:bindvar`，（b）字段名称使用更常见的 PHP 约定的小写名称。如果从其他数据库迁移很重要，请使用此驱动程序。否则，oci8
    驱动程序提供更好的性能。 | Oracle 客户端 | Unix 和 Windows |'
- en: '| odbc | A | Generic ODBC, not tuned for specific databases. To connect, use
    `PConnect(''DSN'',''user'',''pwd'')`. This is the base class for all ODBC derived
    drivers. | ODBC | Unix and Windows. Unix hints |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| odbc | A | 通用 ODBC，未针对特定数据库进行优化。要连接，请使用 `PConnect(''DSN'',''user'',''pwd'')`。这是所有
    ODBC 派生驱动程序的基础类。 | ODBC | Unix 和 Windows。Unix 提示 |'
- en: '| odbc_mssql | A | Uses ODBC to connect to MSSQL | ODBC | Unix and Windows
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| odbc_mssql | A | 使用 ODBC 连接到 MSSQL。 | ODBC | Unix 和 Windows |'
- en: '| odbc_oracle | C | Uses ODBC to connect to Oracle | ODBC | Unix and Windows
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| odbc_oracle | C | 使用 ODBC 连接到 Oracle。 | ODBC | Unix 和 Windows |'
- en: '| odbtp | B | Generic odbtp driver. Odbtp is a software for accessing Windows
    ODBC data sources from other operating systems. | odbtp | Unix and Windows |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| odbtp | B | 通用 odbtp 驱动程序。Odbtp 是一种从其他操作系统访问 Windows ODBC 数据源的软件。 | odbtp
    | Unix 和 Windows |'
- en: '| odbtp_unicode | C | Odtbp with unicode support | odbtp | Unix and Windows
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| odbtp_unicode | C | 支持 Unicode 的 odbtp。 | odbtp | Unix 和 Windows |'
- en: '| oracle | C | Implements old Oracle 7 client API. Use oci8 driver if possible
    for better performance. | Oracle client | Unix and Windows |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| oracle | C | 实现旧的 Oracle 7 客户端 API。如果可能，请使用 oci8 驱动程序以获得更好的性能。 | Oracle 客户端
    | Unix 和 Windows |'
- en: '| netezza | C | Netezza driver. Netezza is based on PostGREs code-base. | ?
    | ? |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| netezza | C | Netezza 驱动程序。Netezza 基于 PostGREs 代码库。 | ? | ? |'
- en: '| pdo | C | Generic PDO driver for PHP5\. | PDO extension and database specific
    drivers | Unix and Windows |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| pdo | C | PHP5 的通用 PDO 驱动程序。 | PDO 扩展和特定数据库驱动程序 | Unix 和 Windows |'
- en: '| postgres | A | Generic PostgreSQL driver. Currently identical to postgres7
    driver. | PostgreSQL client | Unix and Windows |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| postgres | A | 通用 PostgreSQL 驱动程序。目前与 postgres7 驱动程序相同。 | PostgreSQL 客户端
    | Unix 和 Windows |'
- en: '| postgres64 | A | For PostgreSQL 6.4 and earlier which does not support LIMIT
    internally. | PostgreSQL client | Unix and Windows |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| postgres64 | A | 用于 PostgreSQL 6.4 及更早版本，这些版本不支持内部 LIMIT。 | PostgreSQL 客户端
    | Unix 和 Windows |'
- en: '| postgres7 | A | PostgreSQL which supports LIMIT and other version 7 functionality.
    | PostgreSQL client | Unix and Windows |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| postgres7 | A | 支持 LIMIT 和其他版本 7 功能的 PostgreSQL。 | PostgreSQL 客户端 | Unix
    和 Windows |'
- en: '| postgres8 | A | Currently identical to postgres7. | PostgreSQL client | Unix
    and Windows |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| postgres8 | A | 目前与 postgres7 相同。 | PostgreSQL 客户端 | Unix 和 Windows |'
- en: '| sapdb | C | SAP DB. Should work reliably as based on ODBC driver. | SAP ODBC
    client | ? |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| sapdb | C | SAP DB。基于 ODBC 驱动程序，应该能够可靠地工作。 | SAP ODBC 客户端 | ? |'
- en: '| sqlanywhere | C | Sybase SQL Anywhere. Should work reliably as based on ODBC
    driver. | SQL Anywhere ODBC client | ? |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| sqlanywhere | C | Sybase SQL Anywhere。基于 ODBC 驱动程序，应该能够可靠地工作。 | SQL Anywhere
    ODBC 客户端 | ? |'
- en: '| sqlite | B | SQLite. | - | Unix and Windows |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| sqlite | B | SQLite。 | - | Unix 和 Windows |'
- en: '| sqlitepo | B | Portable SQLite driver. This is because assoc mode does not
    work like other drivers in SQLite. Namely, when selecting (joining) multiple tables,
    the table names are included in the assoc keys in the "sqlite" driver.In "sqlitepo"
    driver, the table names are stripped from the returned column names. When this
    results in a conflict, the first field get preference. | - | Unix and Windows
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| sqlitepo | B | 可移植SQLite驱动。这是因为关联模式在SQLite中不像其他驱动那样工作。具体来说，当选择（连接）多个表时，表名包含在“sqlite”驱动程序的关联键中。在“sqlitepo”驱动程序中，表名从返回的列名中去除。当这导致冲突时，第一个字段将优先。
    | - | Unix和Windows |'
- en: '| sybase | C | Sybase. | Sybase client | Unix and Windows |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| sybase | C | Sybase. | Sybase客户端 | Unix和Windows |'
- en: Basic Database Operations using ADOdb
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ADOdb进行基本数据库操作
- en: 'Remember the directory structure that saw minutes ago? Now we are going to
    make use of those scripts. In this section we will learn basic database operation
    using ADOdb. Let''s connect to MySQL and perform a basic operation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记得刚才看到的目录结构吗？现在我们将利用那些脚本。在本节中，我们将学习使用ADOdb进行基本数据库操作。让我们连接到MySQL并执行一个基本操作：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s see an alternate connection example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个替代的连接示例：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Inserting, Deleting, and Updating Records
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入、删除和更新记录
- en: You can execute any SQL statement using `execute()` method of `ADONewConnection`
    or `ADOConnection` object. So nothing is new here. But let's see how can we insert/delete/update
    some records and track the success or failure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ADONewConnection`或`ADOConnection`对象的`execute()`方法执行任何SQL语句。所以这里没有什么新东西。但让我们看看我们如何插入、删除和更新一些记录，并跟踪成功或失败。
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, `Affected_Rows` gives you the result for these scenarios.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Affected_Rows`为你提供了这些场景的结果。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Insert Id**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入ID**'
- en: If you are looking to find the latest inserted ID, you can use the `Insert_Id()`
    function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找最新的插入ID，你可以使用`Insert_Id()`函数。
- en: Executing Prepared Statements
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行预定义语句
- en: 'ADOdb provides easy API to create and execute prepared statements. Let''s take
    a look at the following example to understand how that works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ADOdb提供了创建和执行预定义语句的简单API。让我们看看以下示例，了解它是如何工作的：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can retrieve records in the same way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用同样的方式检索记录。
- en: MDB2
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MDB2
- en: MDB2 is another popular data abstraction library developed under PEAR by combining
    the best features of PEAR::DB and Metabase. It provides very consistent API, improved
    performance, and solid development platform over DB and MDB. MDB2 comes with an
    excellent set of documentation. In this chapter we surely cannot cover all the
    features supported by MDB2 but we will go through the basic features to make you
    understand how it works.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: MDB2是另一个在PEAR下开发的流行数据抽象库，它结合了PEAR::DB和Metabase的最佳特性。它提供了非常一致的API、改进的性能和稳定的开发平台，优于DB和MDB。MDB2附带了一套优秀的文档。在本章中，我们当然不能涵盖MDB2支持的所有功能，但我们将介绍基本功能，以便你了解它是如何工作的。
- en: Installing MDB2
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装MDB2
- en: Installing MDB2 requires a working version of PEAR. So to work with MDB2 you
    must have PEAR installed and functioning in your machine. If you don't have PEAR
    installed, the following tip will be helpful for you.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 安装MDB2需要安装一个有效的PEAR版本。因此，为了使用MDB2，你必须确保PEAR已安装并能在你的机器上正常工作。如果你没有安装PEAR，以下提示将对你有所帮助。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Installing PEAR**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装PEAR**'
- en: Go to [http://pear.php.net/go-pear](http://pear.php.net/go-pear) and save the
    page as `go-pear.php` in your hard drive. Now apply the command `php /path/to/go-pear.php`
    in your shell or command prompt and follow the instructions there. If it asks
    whether you want to install MDB2, say 'Yes'. Also say Yes, if it wants to modify
    your `php.ini` file. Don't worry, it will just add entries to make PEAR available
    in your current include path, and all other settings will remain the same as before.
    So you are done.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://pear.php.net/go-pear](http://pear.php.net/go-pear)，并将页面保存为`go-pear.php`到你的硬盘上。现在在你的shell或命令提示符中执行命令`php
    /path/to/go-pear.php`，并按照那里的说明操作。如果询问你是否要安装MDB2，请回答“是”。如果它要求修改你的`php.ini`文件，也请回答“是”。不用担心，它只会添加条目以使PEAR在你的当前包含路径中可用，所有其他设置都将保持不变。所以，你已经完成了。
- en: 'If you have PEAR I installed but not MDB2, then you can install it in a second.
    Open your shell or command prompt and apply the following commands:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了PEAR但没有安装MDB2，那么你可以立即安装它。打开你的shell或命令提示符，并执行以下命令：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Where `$driver` could be anything like SQLite, PgSQL, MySQL, MYSQLi, oci8,
    MSSQL, and ibase. So for example, to install MySQL driver you have to apply the
    command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `$driver` 可以是任何类似SQLite、PgSQL、MySQL、MYSQLi、oci8、MSSQL和ibase等。例如，要安装MySQL驱动，你必须执行以下命令：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That's it. You are done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你已经完成了。
- en: Connecting to Database
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Using MDB2 you can connect to different database engines. MDB2 also has a formatted
    DSN string to connect. The format of that DSN is as shown:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MDB2，你可以连接到不同的数据库引擎。MDB2还有一个格式化的DSN字符串来连接。该DSN的格式如下所示：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But there are some variations in this DSN. These are listed here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个DSN中也有一些变化。这些变化在此列出：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The supported drivers (PHPtype) are shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的驱动程序（PHPtype）如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s connect to MySQL:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接到MySQL：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Executing Prepared Statements
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行预定义语句
- en: You can execute prepared statements using MDB2 easily. MDB2 provides flexible
    API for creating and executing prepared statements. In the following example we
    will execute two types of prepared statements. One which will just execute some
    insert/update/delete queries, and another which will return some data as output.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地使用MDB2执行预定义语句。MDB2提供了创建和执行预定义语句的灵活API。在以下示例中，我们将执行两种类型的预定义语句。一种将仅执行一些插入/更新/删除查询，另一种将返回一些数据作为输出。
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now what if we want to insert in multiple fields? Well for example, if we have
    another field like "age" in our table, we need to pass data like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们想在多个字段中插入数据呢？例如，如果我们表中还有一个名为"age"的字段，我们需要传递如下数据：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So we can also insert multiple rows at once using `executeMultiple()` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们也可以使用`executeMultiple()`方法一次性插入多行：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: Introduction to ActiveRecord
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActiveRecord简介
- en: ActiveRecord is a design pattern created to solve the data accessing problem
    in a fairly readable manner. Using ActiveRecord design pattern you can manipulate
    data like a charm. In this section we will go through the basic features of an
    ActiveRecord implementation in PHP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveRecord是一种设计模式，旨在以相当可读的方式解决数据访问问题。使用ActiveRecord设计模式，你可以像魔法一样操纵数据。在本节中，我们将介绍PHP中ActiveRecord实现的基本功能。
- en: Let's see how ActiveRecord actually works. For this, we will use ADOdb's active
    record implementation. Adodb provides a class named `Adodb_Active_Record` devoted
    to it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ActiveRecord实际上是如何工作的。为此，我们将使用ADOdb的Active Record实现。Adodb提供了一个名为`Adodb_Active_Record`的类，专门用于此。
- en: 'Let''s create a table in our database with the following structure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在数据库中创建一个具有以下结构的表：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Creating a New Record via ActiveRecord
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ActiveRecord创建新记录
- en: 'Now we will create a new user in this table. Have a look at the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在这个表中创建一个新的用户。看看以下代码：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ActiveRecord exposes a separate object for every table in your database by which
    you can perform different operations. Let's take a look at how we can select some
    data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveRecord通过为你的数据库中的每个表暴露一个单独的对象，你可以执行不同的操作。让我们看看我们如何选择一些数据。
- en: Selecting and Updating Data
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和更新数据
- en: 'We can load and change any record using ActiveRecord easily. Let''s have a
    look at the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ActiveRecord轻松地加载和更改任何记录。让我们看看以下示例：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So that's fairly easy. When you call the `load()` method with any expression,
    the record will be loaded into the object itself. Then you can make any change
    and finally save it. ActiveRecord is extremely charming to work with.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这相当简单。当你用任何表达式调用`load()`方法时，记录将被加载到对象本身中。然后你可以进行任何更改，最后保存它。ActiveRecord与工作起来非常迷人。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You finished reading a chapter devoted for total DB access using the OOP way.
    There are lot other interesting projects like Propel ([http://propel.phpdb.org/trac/](http://propel.phpdb.org/trac/))
    as Object Relational Mapping library for PHP developers, Creole ([http://creole.phpdb.org/trac/](http://creole.phpdb.org/trac/))
    as a DAL, ActiveRecord library from CodeIgniter framework ([http://www.codeigniter.com](http://www.codeigniter.com)),
    and many more. You have got a large number of resources available to manipulate
    database using PHP5 and OO style.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经阅读了一章，专门介绍使用面向对象的方式完全访问数据库。还有很多其他有趣的项目，如Propel（[http://propel.phpdb.org/trac/](http://propel.phpdb.org/trac/)）作为PHP开发者的对象关系映射库，Creole（[http://creole.phpdb.org/trac/](http://creole.phpdb.org/trac/)）作为DAL，CodeIgniter框架中的ActiveRecord库（[http://www.codeigniter.com](http://www.codeigniter.com)），等等。你有很多资源可以使用PHP5和面向对象风格来操纵数据库。
- en: In the next chapter we will learn about using XML in PHP. You will be surprised
    to find that you can use plain XML files as a lightweight alternative of regular
    heavyweight database engines. Until then, happy coding.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在PHP中使用XML。你会惊讶地发现，你可以使用纯XML文件作为常规重型数据库引擎的轻量级替代品。在此之前，祝大家编码愉快。
