- en: Caching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Application performance has always been one of the pain points when developing
    with Drupal, and there are many reasons for this. For example, PHP is not the
    fastest language out there. Many beginner Drupal developers fall prey to the multitude
    of modules available and go a bit overboard with enabling more than needed. And
    indeed, the Drupal architecture is simply not the most performant. In its defense
    though, a very complex architecture that does a lot out of the box will have some
    speed trade-offs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用性能始终是使用Drupal进行开发时的一个痛点，这有很多原因。例如，PHP并不是最快的语言。许多初学者Drupal开发者会陷入众多模块的诱惑，过度启用不必要的模块。确实，Drupal架构也不是最高效的。然而，为了辩护，一个非常复杂的架构，它提供了很多开箱即用的功能，将有一些速度上的权衡。
- en: One critical component in this game, however, is caching. For those of you not
    familiar with this term, caching is the application strategy of storing copies
    of processed code (or anything that results from it) in view of delivering it
    to the user more quickly when requested subsequent times. For example, when you
    go to a website, your browser will most likely cache (store) certain assets locally
    on your computer so that when you visit the site the next time, it can show them
    to you faster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，一个关键组件却是缓存。对于那些不熟悉这个术语的人来说，缓存是一种存储处理过的代码副本（或其结果）的应用策略，以便在后续请求时更快地将它们提供给用户。例如，当你访问一个网站时，你的浏览器很可能会在电脑上本地缓存（存储）某些资源，以便下次访问该网站时可以更快地显示它们。
- en: Although caching has been steadily improving with recent versions of Drupal,
    it has been still lacking significantly. Particularly when it comes to serving
    registered users. Drupal 8, however, is a completely different ball game. The
    system has been totally revamped and brought into all aspects of the Drupal architecture.
    Unfortunately, though, this has put yet another big new thing on the plate of
    things Drupal 7 developers need to learn. Because it's a complex system, we simply
    cannot (and should not) get around it. But you're in luck, because in this chapter
    we will break it all down and see what we're dealing with. So when you are doing
    module development in Drupal 8, your code will be more performant, your site will
    run faster, and ultimately your users will be happier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缓存在Drupal最近版本中一直在稳步改进，但它仍然存在显著不足。尤其是当涉及到为注册用户提供服务时。然而，Drupal 8却是一个完全不同的游戏。系统已经被彻底翻新，并融入Drupal架构的各个方面。不幸的是，这又给Drupal
    7开发者需要学习的内容增加了另一个大项目。因为这个系统很复杂，我们根本不能（也不应该）回避它。但幸运的是，在本章中，我们将将其分解，看看我们正在处理什么。所以，当你正在Drupal
    8中进行模块开发时，你的代码将更高效，你的网站将运行得更快，最终你的用户将更满意。
- en: So, what exactly are we going to talk about in this chapter?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们将在本章中具体讨论些什么呢？
- en: First, we are going to cover some introductory notions about the caching system
    in Drupal 8 and look at the main types of caching available. Here, we will also
    see how, during development, we can disable caching to increase our productivity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍一些关于Drupal 8中缓存系统的基本概念，并查看可用的主要缓存类型。在这里，我们还将了解在开发过程中如何禁用缓存以提高我们的生产力。
- en: Next, we are going to talk about cacheability metadata. This is one of the most
    important things you'll need to know as a Drupal 8 module developer when it comes
    to caching. It has to do with declaring render arrays (and other objects) in a
    way in which Drupal can cache them properly (and invalidate caches accordingly).
    We will talk about things such as cache tags, contexts, and max-age, but also
    see how to apply them to render arrays, block plugins, and access results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论缓存性元数据。当涉及到缓存时，这是作为Drupal 8模块开发者你需要了解的最重要的事情之一。它与以Drupal能够正确缓存（并相应地使缓存失效）的方式声明渲染数组（和其他对象）有关。我们将讨论诸如缓存标签、上下文和最大存活时间（max-age）等问题，同时也会看到如何将它们应用于渲染数组、块插件和访问结果。
- en: After that, we will look at how we can tackle highly dynamic components (render
    arrays) that cannot or should not be cached. Drupal 8 has a powerful *auto-placeholdering*
    system that uses lazy builders to postpone rendering until a later stage, which
    can greatly improve both cacheability and perceived performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探讨如何处理那些不能或不应缓存的动态组件（渲染数组）。Drupal 8有一个强大的自动占位符系统，它使用懒加载构建器将渲染推迟到更晚的阶段，这可以大大提高缓存性和感知性能。
- en: Lastly, we are going to look at how we can interact with the Cache API ourselves
    in order to create, read, and invalidate our own cache entries. Sometimes we need
    to perform expensive calculations or show external data on our site, which can
    benefit from being cached.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何我们自己与缓存 API 交互，以创建、读取和使我们的缓存条目失效。有时我们需要执行昂贵的计算或在我们的网站上显示外部数据，这些都可以从缓存中受益。
- en: So let's get to it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Introduction to Caching
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存简介
- en: The first thing I would like to mention before getting into the meat of the
    Cache API is that this subsystem is one of the best documented ones (at the time
    of writing). You can check out the main entry page ([https://www.drupal.org/docs/8/api/cache-api/cache-api](https://www.drupal.org/docs/8/api/cache-api/cache-api))
    and I recommend keeping it close by when developing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨缓存 API 之前，我想先提到的是，这个子系统是文档最完善的之一（截至撰写本文时）。您可以查看主入口页面（[https://www.drupal.org/docs/8/api/cache-api/cache-api](https://www.drupal.org/docs/8/api/cache-api/cache-api)），我建议在开发时将其放在手边。
- en: The Cache system in Drupal 8 provides the API needed to handle the creation,
    storage, and invalidation of cached data. From a storage perspective, it is extensible,
    allowing us to write our own custom cache *backends* (`CacheBackendInterface`).
    By default, however, cache data gets stored in the database and hence the default
    backend is `DatabaseBackend`. Going forward, we will focus only on this implementation
    since it is the most commonly used one, especially when starting a new project.
    Quite often though, once the site becomes more complex, alternative caching backends
    can be employed for better performance—such as Memecache or Redis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 中的缓存系统提供了处理缓存数据的创建、存储和失效所需的 API。从存储的角度来看，它是可扩展的，允许我们编写自己的自定义缓存后端（`CacheBackendInterface`）。然而，默认情况下，缓存数据存储在数据库中，因此默认后端是
    `DatabaseBackend`。向前发展，我们将只关注这一实现，因为它是最常用的，尤其是在启动新项目时。尽管如此，一旦网站变得更加复杂，可以采用替代的缓存后端来提高性能——例如
    Memecache 或 Redis。
- en: The simplest type of cache in Drupal 8 is the so-called *Internal Page Cache*,
    whose functionality resides inside the Page Cache core module. The goal of this
    cache layer is to serve anonymous users with responses that are cached in their
    entirety. The primary assumption is that certain pages can be cached once and
    served to all anonymous users just the same—an approach similar to what we had
    in Drupal 7\. Unlike the previous version though, this one is much smarter when
    it comes to (not) serving stale content as it makes use of the so-called *cache
    tags* to invalidate cached pages when something on those page changes. We will
    talk about cache tags in more detail soon.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 中最简单的缓存类型是所谓的 *内部页面缓存*，其功能位于页面缓存核心模块内部。这个缓存层的目的是为匿名用户提供完全缓存的响应。主要假设是某些页面一旦缓存就可以为所有匿名用户提供相同的响应——这与我们在
    Drupal 7 中所做的方法类似。然而，与之前的版本不同，这个版本在（不）提供过时内容方面要聪明得多，因为它使用了所谓的 *缓存标签* 来使缓存页面在页面上的某些内容发生变化时失效。我们很快就会详细介绍缓存标签。
- en: 'This module is enabled by default when installing Drupal 8 and can be configured
    more or less the same as in Drupal 7 by going to `admin/config/development/performance`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Drupal 8 时，此模块默认启用，可以通过访问 `admin/config/development/performance` 来进行配置，其配置方式与
    Drupal 7 大致相同：
- en: '![](img/f5263a7f-086a-42f7-a2ac-35fe9f36c520.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5263a7f-086a-42f7-a2ac-35fe9f36c520.png)'
- en: Although serving anonymous users in not-so-complex websites was not that bad
    in Drupal 7, when it came to authenticated users it was quite the opposite. The
    contributed Authcache module was the best solution for dynamic and granular caching,
    but it was extremely difficult to use and implement. Some of its core tenets,
    however, have been used in the development of the `Dynamic Page Cache` module
    in Drupal 8, which makes things much simpler (and robust).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Drupal 7 中，为不太复杂的网站中的匿名用户提供服务并不那么糟糕，但当涉及到认证用户时，情况则完全相反。对于动态和细粒度的缓存，`Authcache`
    扩展模块是最佳解决方案，但它极难使用和实现。然而，其中的一些核心原则已被用于 Drupal 8 中 `Dynamic Page Cache` 模块的开发，这使得事情变得更加简单（且稳健）。
- en: This core module also comes enabled by default and provides all the necessaries
    for caching pages for all kinds of users. That is, pages that can depend on certain
    *cache contexts*. In a nutshell, the approach of this module is to cache together
    the bits of the page that can be served for all users and handle the dynamic content
    that depends on a context separately. It can do so because of the standardization
    of those bits into render arrays and other components that can provide *cacheability
    metadata*. The latter is collected and used to cache and invalidate the final
    result. We will talk about cache contexts and all this metadata in this chapter
    and get a better understanding of it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此核心模块默认启用，并为所有类型的用户提供缓存页面所需的所有必要功能。也就是说，可以依赖于某些**缓存上下文**的页面。简而言之，该模块的方法是将可以服务于所有用户的页面部分一起缓存，并单独处理依赖于上下文的动态内容。它可以这样做，因为这些部分被标准化为渲染数组和可以提供**缓存性元数据**的其他组件。后者被收集并用于缓存和使最终结果失效。我们将在本章中讨论缓存上下文和所有这些元数据，并更好地理解它们。
- en: 'Before continuing, I recommend you look back to the *Developer settings* section
    of [Chapter 1](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml), *Developing for Drupal
    8*, where I recommended that you use the developer settings when doing development.
    One of the reasons is caching, primarily the dynamic page cache, which you can
    disable inside the `settings.php` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我建议你回顾一下[第1章](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml)的*开发者设置*部分，*为Drupal
    8开发*，我在那里建议你在开发时使用开发者设置。其中一个原因是缓存，主要是动态页面缓存，你可以在`settings.php`文件中禁用它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is difficult to do actual development with caching enabled, but at the same
    time, it's important to often enable it and make sure your code still runs correctly.
    It is very easy to forget about certain bits of code that depend on a context
    or should be invalidated upon an action, and sometimes you will only spot these
    if you test with caching enabled.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用缓存的情况下进行实际开发是困难的，但与此同时，经常启用缓存并确保你的代码仍然能够正确运行是很重要的。很容易忘记某些依赖于上下文或应在某些操作后失效的代码片段，有时只有在启用缓存的情况下测试时才会发现这些问题。
- en: That being said, let's talk about cacheability metadata and how this works with
    render arrays.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来谈谈缓存性元数据以及它是如何与渲染数组一起工作的。
- en: Cacheability metadata
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存性元数据
- en: Cacheability metadata is used to describe the *thing* that is rendered with
    respect to its *dynamism*. Most of the time, as Drupal 8 module developers, we
    will be using this metadata when working with render arrays. We will see a bit
    later where else these come into play, but for now, let's see what the actual
    properties are and what they are used for in the context of render arrays.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存性元数据用于描述与它的**动态性**相关的**事物**。大多数时候，作为Drupal 8模块开发者，我们将在处理渲染数组时使用这些元数据。我们稍后会看到这些元数据在其他地方的应用，但现在，让我们看看实际的属性以及它们在渲染数组上下文中的用途。
- en: When creating render arrays, there are a few things we need to think about when
    it comes to caching. And we always need to think about these things.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建渲染数组时，我们需要考虑一些与缓存相关的事项。而且我们始终需要考虑这些事项。
- en: Cache tags
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存标签
- en: The first thing we need to think about is what our render array depends on.
    Are we rendering some entity data? Are we using some configuration values? Or
    anything that might be changed elsewhere impacting what we have to render? If
    the answer is yes, we need to use *cache tags*. If we don't use them, our render
    array gets cached as it is, and if the underlying data changes, we end up showing
    our users stale content or data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要考虑的是我们的渲染数组依赖于什么。我们是渲染某些实体数据吗？我们是使用某些配置值？或者任何可能在其他地方改变并影响我们必须渲染的内容的东西？如果答案是肯定的，我们需要使用**缓存标签**。如果我们不使用它们，我们的渲染数组将按原样缓存，如果底层数据发生变化，我们最终会向用户展示过时的内容或数据。
- en: To look at this another way, imagine a simple Article node. This content can
    be shown on its main detail page, in a listing of article teasers or even a listing
    of article titles (and many other places potentially). And since there is no way
    of knowing where it will be used, it is the responsibility of the render array
    that displays this content to mark this node entity as a dependency using cache
    tags. This way, when the node gets updated, all the render arrays that depend
    on it get invalidated as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，想象一个简单的文章节点。这种内容可以在其主详情页、文章摘要列表或文章标题列表（以及许多其他潜在的地方）显示。由于无法知道它将在哪里使用，因此标记此节点实体为依赖项的责任在于显示此内容的渲染数组使用缓存标签。这样，当节点更新时，所有依赖于它的渲染数组也会被无效化。
- en: 'Cache tags are simple strings and we can declare many cache tags for a single
    render array. They do have a special form in the following pattern: `thing:identifier`,
    or in some cases, just simply `thing` (if there is only one single element of
    that "thing"). For example, the cache tag for a given node would be in the format
    `node:1`, where the identifier is the actual node ID. Or for a configuration object
    it would be `config:hello_world.custom_salutation`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存标签是简单的字符串，我们可以为单个渲染数组声明多个缓存标签。它们具有以下特殊形式：`thing:identifier`，或者在某些情况下，仅仅是`thing`（如果只有一个这样的“thing”）。例如，给定节点的缓存标签将是`node:1`的格式，其中标识符是实际的节点ID。或者对于配置对象，它将是`config:hello_world.custom_salutation`。
- en: I hinted before how, for example, some node content can be present in a list
    and therefore using the cache tags we can ensure that the render array for that
    node gets updated when the node does. Since render arrays are highly granular,
    this can present a small extra problem as the list itself can be a render array
    that may not even know which nodes it renders. Or even more so, it does not know
    when new nodes are created and should be included in it. To solve this issue,
    we have a special *list* cache tag we can use when rendering entities. For example,
    the `node_list` cache tag can be used for node entities, while the `product_list`
    cache tag can be used for product entities. These are automatically understood
    by the Drupal caching system, so all we have to do is use them appropriately.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经暗示过，例如，某些节点内容可以出现在列表中，因此我们可以使用缓存标签来确保当节点更新时，该节点的渲染数组也会得到更新。由于渲染数组非常细粒度，这可能会带来一个小问题，因为列表本身可能就是一个渲染数组，甚至可能不知道它渲染了哪些节点。或者更严重的是，它不知道何时创建了新的节点，应该将其包含在内。为了解决这个问题，我们有一个特殊的**列表**缓存标签，可以在渲染实体时使用。例如，`node_list`缓存标签可以用于节点实体，而`product_list`缓存标签可以用于产品实体。这些标签会被Drupal缓存系统自动理解，所以我们只需要适当地使用它们即可。
- en: 'To make life easier, however, all entities and configuration objects can be
    "interrogated" to provide their respective cache tags. For example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了让生活更简单，所有实体和配置对象都可以被“查询”以提供它们各自的缓存标签。例如：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where `$tags` will be an array containing one tag—`node:[nid]`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`$tags`将是一个包含一个标签的数组——`node:[nid]`。'
- en: The same applies to configuration objects and this is handy because it prevents
    typos and errors. This is due to the generic `CacheableDependencyInterface` they
    implement which defines the methods for retrieving the cache metadata properties.
    In fact, any value that needs to be a cache dependency can and should implement
    this interface. As you'll find, there are a quite a few classes in Drupal core
    that do so.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于配置对象，这很方便，因为它可以防止拼写错误和错误。这是由于它们实现的通用`CacheableDependencyInterface`定义了检索缓存元数据属性的方法。实际上，任何需要成为缓存依赖的值都可以也应该实现这个接口。你会发现，Drupal核心中有相当多的类实现了这个接口。
- en: You will also encounter `RefinableCacheableDependencyInterface` which is used
    in cases in which the cacheability of the underlying object can change at runtime.
    For example, an entity translation is added, which means that a new cache context
    needs to be added for that language.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会遇到`RefinableCacheableDependencyInterface`，它在底层对象的缓存性可以在运行时改变的情况下使用。例如，添加了一个实体翻译，这意味着需要为该语言添加一个新的缓存上下文。
- en: We can also figure out the "list" cache tag specific to a given entity type.
    For example, instead of hardcoding the `product_list` tag, we can use the `getListCacheTags()`
    method on the `EntityTypeInterface`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确定特定实体类型的“列表”缓存标签。例如，而不是硬编码`product_list`标签，我们可以使用`EntityTypeInterface`上的`getListCacheTags()`方法。
- en: If your render array depends on something custom, you can use custom cache tags,
    but it will be your responsibility to also invalidate them when the underlying
    data is changed. We will see how this is done when we interact with the Cache
    API directly. It's always good to consistently use the `CacheableDependencyInterface`
    for any custom value objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的渲染数组依赖于某些自定义内容，你可以使用自定义缓存标签，但当你更改底层数据时，你也必须负责使它们失效。当我们直接与缓存 API 交互时，我们将看到这是如何完成的。始终一致地使用
    `CacheableDependencyInterface` 对于任何自定义值对象来说都是一件好事。
- en: Cache contexts
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存上下文
- en: Once we've thought about the dependencies of the render array, the second most
    important thing to consider is what it differs by. In other words, is there any
    reason why this render array should be shown one way sometimes but another way
    some other time?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们考虑了渲染数组的依赖关系，接下来要考虑的第二件最重要的事情是它有什么不同之处。换句话说，有没有什么理由让这个渲染数组有时以一种方式显示，有时以另一种方式显示？
- en: Let's take a simple example of a render array that prints out the name of the
    current user. Nothing could be less complicated. Ignoring the cache tags for now,
    we immediately realize that we cannot show the same username to all users, right?
    So, the user *Danny* should see "Hi Danny" while user *John* should see "Hi John".
    We are talking about the same render array but one that differs by context. In
    other words, a variation of this render array needs to get cached separately for
    each encountered context. This is where we use the aforementioned *cache contexts*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个简单的例子来说明一个渲染数组，它会打印出当前用户的名称。这再简单不过了。现在忽略缓存标签，我们立刻意识到我们不能向所有用户展示相同的用户名，对吧？所以，用户
    *Danny* 应该看到“Hi Danny”，而用户 *John* 应该看到“Hi John”。我们谈论的是同一个渲染数组，但它在上下文中有所不同。换句话说，这个渲染数组的变体需要为每个遇到的上下文单独缓存。这就是我们使用前面提到的
    *缓存上下文* 的地方。
- en: Similar to cache tags, cache contexts are simple strings, and a render array
    can be defined with more than just one. For example, the `user` context will cache
    a variation of a given render array for each user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓存标签类似，缓存上下文是简单的字符串，渲染数组可以定义多个。例如，`user` 上下文将为每个用户缓存给定渲染数组的变体。
- en: Moreover, they are hierarchical in nature in the sense that some contexts can
    include others. For example, let's continue with our previous example. Let's assume
    that users with the `editor` role should see the greeting message but the ones
    with the `contributor` role should see a different, more complicated one. In this
    case, the cache context would be on the roles the user has. But since it already
    depends on the actual user due to the need to show its username, it doesn't make
    sense to even bother with the roles context because the former encompasses the
    latter. Moreover, Drupal is smart enough to remove the superfluous one when combining
    the cache contexts from all the render arrays that make up a page. But if our
    render array differs, for example, only on the user roles and not necessarily
    the user itself, we should use the specific context—`user.roles`. As you may notice,
    the hierarchical nature is reflected in the dot (`.`) separation of the contexts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们在本质上具有层次性，因为某些上下文可以包含其他上下文。例如，让我们继续我们之前的例子。假设具有 `editor` 角色的用户应该看到问候信息，而具有
    `contributor` 角色的用户应该看到不同的、更复杂的信息。在这种情况下，缓存上下文将基于用户拥有的角色。但由于它已经因为需要显示其用户名而依赖于实际用户，因此甚至没有必要考虑角色上下文，因为前者已经包含了后者。此外，Drupal
    足够智能，足以在组合构成页面的所有渲染数组的缓存上下文时删除多余的上下文。但如果我们的渲染数组仅在用户角色上有所不同，而不一定是用户本身，我们应该使用特定的上下文——`user.roles`。正如你可能注意到的，层次性体现在上下文的点（`.`）分隔上。
- en: There are a number of cache contexts already defined by Drupal core. Although
    you probably won't have to, at least in the beginning, you can define other contexts
    too. I recommend you check out the documentation page ([https://www.drupal.org/docs/8/api/cache-api/cache-contexts](https://www.drupal.org/docs/8/api/cache-api/cache-contexts))
    for the available cache contexts that come out of the box.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 核心已经定义了许多缓存上下文。虽然你可能不需要，至少在开始时不需要，但你也可以定义其他上下文。我建议你查看文档页面（[https://www.drupal.org/docs/8/api/cache-api/cache-contexts](https://www.drupal.org/docs/8/api/cache-api/cache-contexts)），了解开箱即用的可用缓存上下文。
- en: Max-age
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Max-age
- en: The last main thing we need to think about when creating render arrays is how
    long they should be stored in the cache, barring any changes in the underlying
    data that might invalidate them. This is something that you will probably rarely
    set and by default it will be permanent. More often, however, you will set this
    cache property to 0 in order to denote that this render array should never be
    cached. This is when you are rendering something highly dynamic that doesn't make
    sense to be cached at all.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建渲染数组时，我们需要考虑的最后一件主要事情是它们应该在缓存中存储多长时间，除非底层数据发生变化而使它们失效。这通常是你很少设置的事情，默认情况下它将是永久的。然而，更常见的情况是，你会将这个缓存属性设置为0，以表示这个渲染数组永远不应该被缓存。这就是当你渲染一些高度动态的内容，根本不值得缓存的时候。
- en: Using the cache metadata
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存元数据
- en: Now that we have looked at the three main cache properties, we need to consider
    creating render arrays, so let's revisit some of our previous work and apply this
    in practice as needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看过了三个主要的缓存属性，我们需要考虑创建渲染数组，所以让我们回顾一下我们之前的工作，并在需要时将其应用于实践中。
- en: Quite often, you'll see the `CacheableMetadata` object being used and passed
    around in Drupal 8 core code. This is simply used to represent cache metadata
    and also provides some handy methods to apply that metadata to a render array,
    statically instantiate itself from one, or from a `CacheableDependencyInterface`
    object, as well as merge itself with another `CacheableMetadata` object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，你会在Drupal 8核心代码中看到`CacheableMetadata`对象被使用和传递。这仅仅用于表示缓存元数据，并提供了一些方便的方法来将此元数据应用于渲染数组，从其中静态实例化自己，或者从一个`CacheableDependencyInterface`对象中实例化，以及与另一个`CacheableMetadata`对象合并。
- en: 'The render array we will look at is inside the `HelloWorldSalutation::getSalutationComponent()`
    service and is used to render the salutation message. We are building it quite
    dynamically, but a simplified version looks like this (omitting some things):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的渲染数组位于`HelloWorldSalutation::getSalutationComponent()`服务中，用于渲染问候消息。我们构建它相当动态，但简化版本看起来像这样（省略了一些内容）：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `$salutation` is either the message from the configuration object or the
    one generated based on the time of day.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$salutation`要么是来自配置对象的消息，要么是基于一天中的时间生成的。
- en: Right off the bat, I will mention that this is one of those cases in which we
    cannot really cache the render array due to its highly dynamic nature. This is
    caused by the dependency on the time of day. Sure, we could set a maximum age
    of a few seconds or an hour, but is it even worth it? And we also run the risk
    of showing the wrong salutation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 马上要提到的是，这是那种我们由于其高度动态的特性而无法真正缓存渲染数组的情况之一。这是由于对一天中的时间的依赖造成的。当然，我们可以设置几秒或一小时的最高年龄，但这值得吗？而且我们还冒着显示错误问候的风险。
- en: 'So in this case, what we can do is add a maximum age of 0:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们可以做的是添加一个最大年龄为0：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The cache metadata goes under a `#cache` render array property as shown above.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，缓存元数据位于`#cache`渲染数组属性下。
- en: Specifying the max-age basically tells Drupal not to ever cache this render
    array. Something important to know about this is that this declaration will bubble
    up to the top-level render array that makes the Controller response, preventing
    the entire thing from being cached. So, do not make the decision to prevent caching
    lightly. In our example, this is basically the entire Controller response and
    it is actually a very simple calculation, so we are good. Later in the chapter,
    we will talk about the ways this can be mitigated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指定最大年龄基本上告诉Drupal永远不要缓存这个渲染数组。关于这一点，重要的是要知道，这个声明将冒泡到顶级渲染数组，从而阻止整个内容被缓存。因此，不要轻易做出阻止缓存的决定。在我们的例子中，这基本上是整个控制器响应，而且实际上是一个非常简单的计算，所以我们没问题。在章节的后面，我们将讨论如何减轻这种情况。
- en: There is still a problem with us setting the `max-age` to 0 in this example.
    Although it will work with dynamic page caching (`max-age` will bubble up), the
    internal page cache serving anonymous users will not get this information. So,
    anonymous users will see the same thing every time. Possibly in future Drupal
    8 releases, this will be fixed. We won't account for this issue yet because it's
    a great example of a bug that becomes apparent using automated tests, and we will
    see that in the final chapter of the book—as well as the solution, of course.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`max-age`设置为0仍然存在问题。尽管它将与动态页面缓存（`max-age`将冒泡）一起工作，但为匿名用户服务的内部页面缓存将不会得到这个信息。因此，匿名用户每次都会看到相同的内容。可能在未来的Drupal
    8版本中，这个问题将会得到解决。我们不会考虑这个问题，因为它是一个很好的例子，说明了使用自动化测试时出现的错误，我们将在本书的最后一章中看到这一点——当然，还有解决方案。
- en: 'Let''s, for a minute, assume that our salutation component is simply rendering
    the message stored in the configuration object and does not show time-specific
    content. If you remember:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设我们的问候组件只是渲染配置对象中存储的消息，并且不显示特定时间的内容。如果你还记得：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we could cache the render array, but as we discussed earlier,
    we''d need to think about the dependencies as well as the potential variations
    it can have. It is already pretty obvious what the dependencies are—the configuration
    object. So, we would do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以缓存渲染数组，但正如我们之前讨论的，我们还需要考虑依赖关系以及它可能有的潜在变化。依赖关系已经很明显了——配置对象。因此，我们会这样做：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Basically, we are requesting this particular configuration object''s cache
    tags and setting those onto the render array. If we had more sets of cache tags
    to set from multiple objects, we would have to merge them. There is a tool we
    can use to ensure we do it right. For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在请求这个特定配置对象的缓存标签，并将这些标签设置到渲染数组上。如果我们有更多来自多个对象的缓存标签集要设置，我们就必须合并它们。我们可以使用一个工具来确保我们正确地做到这一点。例如：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will merge two arrays of cache tags, pure and simple. The `Drupal\Core\Cache\Cache`
    class also has static helper methods for merging cache contexts and max-ages (among
    other things, I encourage you to check this out as you progress).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地合并两个缓存标签数组。`Drupal\Core\Cache\Cache`类也有静态辅助方法用于合并缓存上下文和最大年龄（以及其他事情，我鼓励你在学习过程中查看这些）。
- en: 'Thankfully, our render array is simple and does not vary, and hence we don''t
    need cache contexts. If, however, we had appended the current username to the
    salutation, we would have had to add the `user` context to the render array as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的渲染数组很简单且不变化，因此我们不需要缓存上下文。然而，如果我们已经将当前用户名附加到问候语中，我们就必须将`user`上下文添加到渲染数组中，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This would have cached the render array differently for each user who visits
    the page and would serve them accordingly at subsequent visits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个访问页面的用户缓存不同的渲染数组，并在后续访问时相应地为他们提供服务。
- en: Caching in block plugins
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块插件的缓存
- en: The render array we saw earlier was used as part of a Controller response. The
    latter is also known as the *main content* as it is the primary output of the
    page. On a normal Drupal installation, which uses the Block module, this is included
    inside the `Main page content` block. We also said that setting a max-age of 0
    will bubble up to the top-level render array, causing the entire page to not be
    cached. This is true so far as the Controller response is concerned. Other blocks
    are still cached independently according to their own metadata.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的渲染数组被用作控制器响应的一部分。后者也被称为*主要内容*，因为它构成了页面的主要输出。在一个普通的Drupal安装中，它使用块模块，包含在`主页面内容`块中。我们还提到，将max-age设置为0将冒泡到顶级渲染数组，导致整个页面不会被缓存。就控制器响应而言，这是正确的。其他块仍然根据它们自己的元数据独立缓存。
- en: In this book, you have already learned how we can create custom blocks, and
    we saw that they are also built using render arrays. Since this is the case, cache
    metadata can also be applied to those arrays for caching them properly. However,
    since we are extending from the `BlockBase` class when creating block plugins,
    we are essentially implementing the `CacheableDependencyInterface` because `BlockPluginInterface`
    extends it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你已经学习了我们可以如何创建自定义块，我们看到了它们也是使用渲染数组构建的。既然是这样，缓存元数据也可以应用于这些数组以正确缓存它们。然而，由于我们在创建块插件时扩展了`BlockBase`类，所以我们实际上是在实现`CacheableDependencyInterface`，因为`BlockPluginInterface`扩展了它。
- en: 'So instead of setting the metadata on the render array, we should, whenever
    possible, use the methods on that interface by overriding the default parent implementations.
    For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不应该在渲染数组上设置元数据，而应该尽可能使用该接口上的方法，通过覆盖默认的父级实现来实现。例如：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We should always merge our own values with the ones from the parent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终将我们自己的值与父级的值合并。
- en: In some cases, though, especially when declaring cache tags, it makes more sense
    to set them inside the render array of the `build()` method. That is because you
    may have already done some work to get your hands on the dependent objects, and
    it doesn't make sense to repeat that inside another method. That is totally fine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，尤其是在声明缓存标签时，将它们设置在`build()`方法的渲染数组中更有意义。这是因为你可能已经做了一些工作来获取依赖对象，重复在另一个方法中做这些工作是没有意义的。这是完全可以的。
- en: Caching access results
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存访问结果
- en: Another important place where cache metadata needs to be considered is on `AccessResultInterface`
    objects. If you remember from the previous chapter, objects implementing this
    interface are used consistently to represent access to a certain resource. On
    top of that, they can also contain cacheability metadata. This is because access
    may depend on certain data that can change with an impact on the access result
    itself. Since Drupal tries to cache access as well, we need to inform it of these
    dependencies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑缓存元数据的重要地方之一是在`AccessResultInterface`对象上。如果你还记得上一章的内容，实现此接口的对象被一致地用来表示对某个资源的访问。除此之外，它们还可以包含缓存性元数据。这是因为访问可能依赖于某些可能影响访问结果本身的数据。由于Drupal试图缓存访问，我们需要通知它这些依赖关系。
- en: 'A good example to see this in action is our `HelloWorldAccess` service where
    we dynamically check access to our `hello_world.hello` route. So instead of simply
    returning the `AccessResultInterface`, we add cacheable dependencies to it before
    doing so. The rewritten `access()` method can now look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是`HelloWorldAccess`服务，我们在其中动态检查对`hello_world.hello`路由的访问。因此，我们不是简单地返回`AccessResultInterface`，而是在这样做之前向其添加缓存依赖项。重写的`access()`方法现在可以看起来像这样：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `addCacheableDependency()` method usually takes `CacheableDependencyInterface`
    objects to read their cache metadata. If something else is passed, the access
    result is deemed not cacheable. So in our case, since the access depends on both
    the salutation configuration object and the user account, we add them both as
    cache dependencies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCacheableDependency()`方法通常接受`CacheableDependencyInterface`对象来读取它们的缓存元数据。如果传递了其他内容，则认为访问结果不可缓存。因此，在我们的情况下，由于访问依赖于问候配置对象和用户账户，我们将它们两者都添加为缓存依赖项。'
- en: Placeholders and lazy building
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 占位符和延迟构建
- en: Now that we've seen a bit about how the cacheability metadata can be used in more
    common scenarios, let's shift gears and talk about those page components that
    have highly dynamic data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于如何在更常见的场景中使用缓存性元数据的信息，让我们转换一下话题，讨论那些具有高度动态数据的页面组件。
- en: When we set the maximum age of our Hello World salutation to 0 seconds (don't
    cache), I mentioned that there are ways this can be improved in order to help
    performance. This involves postponing the rendering of the respective bit to the
    very last moment with the help of placeholders. But first, a bit of background.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Hello World问候的最大年龄设置为0秒（不缓存）时，我提到过有方法可以改进这一点以帮助性能。这涉及到通过占位符将相应的渲染推迟到最后一刻。但首先，让我们了解一下背景。
- en: Each of the cache properties we talked about can have values that make caching
    the render array pointless. We've already talked about the maximum age being set
    to 0, but you can also argue very low expiration times to have the same effect.
    Additionally, certain cache tags can be invalidated too frequently, again making
    the render arrays that depend on what they represent pointless to cache. Finally,
    certain cache contexts can provide many variations that significantly limit the
    effectiveness of the cache to the point that it may even be counterproductive
    (high storage costs).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的每个缓存属性都可能具有使缓存渲染数组变得无意义的值。我们已经讨论了将最大年龄设置为0的情况，但你也可以非常低地设置过期时间以达到相同的效果。此外，某些缓存标签可能被频繁地失效，再次使依赖于它们表示的渲染数组变得无意义。最后，某些缓存上下文可能提供许多变体，这会显著限制缓存的有效性，甚至可能适得其反（高存储成本）。
- en: 'Cache tags are something very specific to the application we are building,
    so there are no general assumptions that can be made as to which have a high invalidation
    rate. However, there are two cache contexts that by default are considered to
    have much too high cardinality to be effective: `session` and `user`. Yes, we
    talked about the `user` context earlier as a good example but in reality—by default—adding
    this context to a render array has pretty much the same effect as setting the
    max-age to 0—it will not be cached. The same goes for the `session` context because
    there can be so many sessions and users on the site, you probably won''t want
    to have cache records for each individual one.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存标签是我们正在构建的应用程序中非常具体的东西，因此不能对哪些具有高失效率做出一般假设。然而，有两个缓存上下文默认被认为具有过高基数，以至于无法有效：`session`和`user`。是的，我们之前已经讨论了`user`上下文作为一个好例子，但在现实中——默认情况下——将此上下文添加到渲染数组的效果几乎与将最大存活时间设置为0相同——它将不会被缓存。对于`session`上下文也是如此，因为网站上可能有如此多的会话和用户，你可能不希望为每个单独的会话或用户保留缓存记录。
- en: 'Since these are not rules that have to necessarily apply to all applications,
    Drupal configures these values as service parameters, making them changeable if
    needed. Inside the `core.services.yml` file (which lists most of the core services),
    we can find some parameter definitions as well, including this one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些规则并非必须适用于所有应用，Drupal将这些值配置为服务参数，以便在需要时进行更改。在`core.services.yml`文件（其中列出了大多数核心服务）中，我们还可以找到一些参数定义，包括这个：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the max-age value of 0 and the previously mentioned cache contexts
    are included, but no tags. We can also change these values. So, for example, if
    in our application we know that we won''t have too many users and it does, in
    fact, make sense to cache by user context, or we know of certain cache tags with
    high invalidation frequency, it makes sense to change this. There are two ways
    we can do it: either we use our site-wide `services.yml` file and copy these declarations
    (while making the appropriate changes) or we can use the services file of a given
    module in the same way. Both methods have the effect of overriding the default
    parameters set by Drupal core.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，包括0的最大存活时间值和之前提到的缓存上下文，但没有标签。我们也可以更改这些值。例如，如果我们知道在我们的应用程序中用户不会太多，并且实际上按用户上下文进行缓存是有意义的，或者我们知道某些缓存标签具有高失效频率，那么更改这些值是有意义的。我们可以通过两种方式来实现：要么使用我们网站范围的`services.yml`文件并复制这些声明（同时进行适当的更改），要么我们可以以相同的方式使用给定模块的服务文件。这两种方法都会覆盖Drupal核心设置的默认参数。
- en: Now that we are clear on why certain things are not cacheable, let's see how
    this can be addressed using *auto-placeholdering*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚为什么某些事物不可缓存，让我们看看如何使用*自动占位符*来解决这个问题。
- en: Auto-placeholdering is the process by which Drupal identifies the render arrays
    that cannot or should not be cached for the reasons we mentioned before, and replaces
    them with a placeholder. The latter is then replaced at the very last possible
    moment while allowing the rest of the page components to be cached. This is also
    called *lazy building*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自动占位符过程是Drupal识别那些由于我们之前提到的原因不能或不应缓存的渲染数组，并用占位符替换它们的过程。然后，在最后可能的一刻替换占位符，同时允许页面的其余部分进行缓存。这也被称为*懒惰构建*。
- en: Drupal identifies the bits that need to be lazy built by the cache metadata
    that fits the conditions we saw before and the presence of the `#lazy_builder`
    property on the render array. The latter maps to a callback that returns its own
    render array, which can also contain said cache metadata. And it doesn't matter
    which of the render arrays contains the latter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal通过适合我们之前看到的条件的缓存元数据和渲染数组上`#lazy_builder`属性的存在来识别需要懒惰构建的部分。后者映射到一个返回其自己的渲染数组的回调函数，该渲染数组也可以包含上述缓存元数据。并且，无论哪个渲染数组包含后者都无关紧要。
- en: Lazy builders
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的构建者
- en: Lazy builders are nothing more than callbacks on a render array that Drupal
    can use to build the render array at a later stage. The callbacks can be static
    (a reference to a class and method) or dynamic (a reference to a service and method).
    Using the latter approach is more flexible as we can inject dependencies from
    the container as we do regularly with services. Moreover, the callback can take
    parameters, which means it can build the render array already having at least
    part of the required data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 懒构建器不过是渲染数组上的回调，Drupal可以使用它来在后续阶段构建渲染数组。回调可以是静态的（对类和方法的引用）或动态的（对服务和方法的引用）。使用后者方法更为灵活，因为我们可以从容器中注入依赖，就像我们通常对服务所做的那样。此外，回调可以接受参数，这意味着它可以在已经拥有至少部分所需数据的情况下构建渲染数组。
- en: The best way to understand this is to see an example. Since we decided that
    our salutation component should have a cache lifetime of 0 seconds, it's a good
    opportunity to build it using a lazy builder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点最好的方式是看一个例子。由于我们决定我们的问候组件应该有0秒的缓存生命周期，这是一个使用懒构建器构建的好机会。
- en: 'The first thing we need to do is replace our `helloWorld` Controller method
    in which we directly call the salutation service with this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的`helloWorld`控制器方法中的直接调用问候服务替换为以下内容：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Back in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming,*
    when I said a render array needs to have at least one of the four properties (`#type`,
    `#theme`, `#markup`, or `#plain_text`), I lied. We can also use a lazy builder
    like this to defer the building of the render array to a later stage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，关于*主题化*，当我提到渲染数组需要至少包含四个属性（`#type`、`#theme`、`#markup`或`#plain_text`）时，我说谎了。我们还可以使用这样的懒构建器来延迟构建渲染数组到后续阶段。
- en: The `#lazy_builder` needs to be an array whose first item is the callback and second
    is an array of arguments to pass to it. In our case, we don't need any of the
    latter. We could pass the salutation service, but instead, we will inject it into
    the new `hello_world.lazy_builder` service we will create in a minute. The callback
    reference is in the format of `service_name:method` (one colon used for separation)
    or for static calls `class_name::method` (two colons). We also explicitly declare
    `#create_placeholder` to make it clear that this render array should be replaced
    with a placeholder. Lastly, as I mentioned earlier, the cache metadata can be
    applied to this render array or it can also be on the resulting one from the lazy
    builder. So, we'll opt for the latter approach in this case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`#lazy_builder`需要是一个数组，其第一个元素是回调函数，第二个元素是要传递给它的参数数组。在我们的例子中，我们不需要后者的任何内容。我们可以传递问候服务，但我们将将其注入到我们将在下一分钟创建的新的`hello_world.lazy_builder`服务中。回调引用的格式为`service_name:method`（使用一个冒号进行分隔）或者对于静态调用`class_name::method`（使用两个冒号）。我们还明确声明了`#create_placeholder`，以明确指出这个渲染数组应该被占位符替换。最后，正如我之前提到的，缓存元数据可以应用于这个渲染数组，也可以应用于懒构建器生成的结果数组。因此，在这种情况下，我们将选择后者方法。'
- en: 'Let''s now define our service:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在定义我们的服务：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Nothing out of the ordinary here, but we are injecting the `HelloWorldSalutation`
    service as a dependency so that we can ask it for our salutation component. The
    actual service class looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处，但我们正在将`HelloWorldSalutation`服务作为依赖项注入，这样我们就可以请求我们的问候组件。实际的服务类看起来是这样的：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All very simple. The `renderSalutation()` method is required as we referenced
    it from our lazy builder. That is all we have to do. But, what exactly happens
    with this?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常简单。由于我们在懒构建器中引用了`renderSalutation()`方法，所以需要这个方法。这就是我们必须要做的。但是，这究竟会发生什么呢？
- en: When Drupal renders our Controller, it finds the lazy builder and registers
    it with a placeholder, which is then used instead of the actual final render array.
    Then, at a much later stage in the page-building process, the lazy builder is
    invoked and the actual output is rendered to replace the placeholder. There are
    a couple of advantages and implications with this. First, it allows Drupal to
    bypass this highly dynamic bit of output and cache the rest of the components
    in the dynamic page cache. This is to prevent the lack of cacheability from infecting
    the entire page. Second, there are two different strategies (so far) with which
    placeholders can be processed. By default, in using the so-called *Single Flush*
    method, the placeholder replacement is postponed until the last minute, but the
    response is not sent back to the browser before this is done. So, the dynamic
    page cache does improve things (caches what it can), but the response still depends
    on the placeholder processing finishing. Depending on how long that takes, the
    page load, in general, can suffer. However, when using the **BigPipe** ([https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919](https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919))
    approach, the response is sent back to the browser before the placeholders are
    replaced. And as the latter finishes as well, the replacements are streamed to
    the browser. This greatly improves the perceived performance of the site as users
    can already see most parts of the page before the slower bits appear.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当Drupal渲染我们的控制器时，它会找到懒加载构建器并将其与占位符注册，然后使用占位符代替实际的最终渲染数组。然后，在页面构建过程的后期，懒加载构建器被调用，实际输出被渲染以替换占位符。这种方法有几个优点和影响。首先，它允许Drupal绕过这个高度动态的输出部分，并将动态页面缓存中的其余组件缓存起来。这是为了防止缓存不可用的问题影响到整个页面。其次，有几种不同的策略（到目前为止）可以处理占位符。默认情况下，使用所谓的“单次刷新”方法，占位符替换被推迟到最后一刻，但在完成之前不会将响应发送回浏览器。因此，动态页面缓存确实改善了事情（缓存了它能缓存的内容），但响应仍然依赖于占位符处理完成。根据这需要多长时间，页面的加载通常可能会受到影响。然而，当使用**BigPipe**（[https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919](https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919)）方法时，在替换占位符之前，响应就被发送回浏览器。随着后者的完成，替换也被流式传输到浏览器。这大大提高了网站的感知性能，因为用户可以在较慢的部分出现之前看到页面的大部分内容。
- en: The *BigPipe* technique was invented by Facebook as a way to deal with highly
    dynamic pages and was gradually brought into Drupal 8 as an experimental core
    module. With version 8.3 it has been marked stable and ready for use in production
    sites. I highly recommend you keep this module enabled as it comes with the Standard
    installation profile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*BigPipe* 技术是由Facebook发明的一种处理高度动态页面的方法，并逐渐被引入Drupal 8作为实验性核心模块。在版本8.3中，它已被标记为稳定，并准备好在生产网站上使用。我强烈建议您保持此模块启用，因为它包含标准安装配置文件。'
- en: As you've probably guessed by now, the lazy builder approach is only useful
    when it comes to Dynamic Page Caching. That is when we cache for authenticated
    users. It will not work with the Internal Page Cache which is used for anonymous
    users.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经猜到的，懒加载构建器方法仅在动态页面缓存时有用。也就是说，当我们为认证用户缓存时。它不会与用于匿名用户的内部页面缓存一起工作。
- en: Using the Cache API
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存API
- en: So far in this chapter, we've mostly preoccupied ourselves with render arrays
    and how we can expose them to the Cache API for better performance. It's now time
    to talk a bit about how cache entries are stored by default in Drupal and how
    we can interact with them ourselves in our code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这一章中，我们主要关注渲染数组和如何将它们暴露给缓存API以获得更好的性能。现在是时候谈谈默认情况下Drupal如何存储缓存条目，以及我们如何在代码中与它们交互了。
- en: As mentioned earlier, a central interface for the cache system is the `CacheBackendInterface`,
    which is the interface any caching system needs to implement. It basically provides
    the methods for creating, reading, and invalidating cache entries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，缓存系统的中心接口是`CacheBackendInterface`，这是任何缓存系统都需要实现的接口。它基本上提供了创建、读取和使缓存条目无效的方法。
- en: 'As we might expect, when we want to interact with the Cache API, we use a service
    to retrieve an instance of the `CacheBackendInterface`. However, the service name
    we use depends on the cache *bin* we want to work with. Cache bins are repositories
    that group together cache entries based on their type. So, the aforementioned
    implementation wraps a single cache bin, and each bin has a machine name. The
    service name will then be in the following format: `cache.[bin]`. This means that
    for each cache bin, we have a separate service.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，当我们想要与缓存API交互时，我们使用一个服务来检索`CacheBackendInterface`的一个实例。然而，我们使用的服务名称取决于我们想要与之工作的缓存`bin`。缓存`bin`是根据它们的类型将缓存条目组合在一起的存储库。因此，上述实现包装了一个单独的缓存区，每个区都有一个机器名。服务名称将是以下格式：`cache.[bin]`。这意味着对于每个缓存区，我们都有一个单独的服务。
- en: 'The static shorthand for getting this service looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 获取此服务的静态简写如下：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return the `default` bin represented by a `CacheBackendInterface`
    implementation. If we want to request a specific bin, we pass the name as an argument:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回由`CacheBackendInterface`实现表示的`default`缓存区。如果我们想要请求特定的缓存区，我们传递名称作为参数：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will return the `render` cache bin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`render`缓存区。
- en: And of course, if we need to inject a cache bin wrapper somewhere, we simply
    use the service machine name in the format I mentioned before.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们需要在某处注入一个缓存区包装器，我们只需使用前面提到的格式中的服务机器名。
- en: Even though we have a separate service for each cache bin, they all basically
    do the same thing, and that is use the `CacheFactory` to instantiate the right
    type of cache backend for that bin. Individual cache backends can be registered
    and set as the default either globally or for specific bins.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为每个缓存区都有一个单独的服务，但它们基本上都做同样的事情，那就是使用`CacheFactory`为该区实例化正确的缓存后端类型。单个缓存后端可以注册并设置为全局或特定缓存区的默认后端。
- en: As I mentioned at the beginning of the chapter, the default cache backend in
    Drupal—the one this factory will instantiate for all the bins—is the `DatabaseBackend`.
    Each bin is represented by a database table. This is similar in concept to what
    we had in Drupal 7.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章开头提到的，Drupal中的默认缓存后端——这个工厂将为所有缓存区实例化——是`DatabaseBackend`。每个缓存区由一个数据库表表示。这与Drupal
    7中的概念类似。
- en: Now that we know how to load the cache backend service, let's see how we can
    use it to read and cache things. When it comes to this, your number one reference
    point is the `CacheBackendInterface` which documents all the methods. However,
    since it does not reinforce return values, the examples we will see next are done
    with the database cache backend. They might differ from other cache backend implementations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何加载缓存后端服务，让我们看看我们如何使用它来读取和缓存东西。当涉及到这一点时，你的首要参考点是`CacheBackendInterface`，它记录了所有方法。然而，由于它不强化返回值，我们接下来要看到的例子将使用数据库缓存后端。它们可能与其他缓存后端实现不同。
- en: 'The first method we''ll talk about is `get()`, which takes the ID of the cache
    entry we want to retrieve (`$cid`) and an optional `$allow_invalid` parameter.
    The first parameter is clear enough, but the second one is used in case we want
    to retrieve the entry even if it has expired or has been invalidated. This can
    be useful in those cases in which *stale* data is preferred over the recalculation
    costs of multiple concurrent requests:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个方法是`get()`，它接受我们想要检索的缓存条目的ID（`$cid`）和一个可选的`$allow_invalid`参数。第一个参数已经很明确了，但第二个参数用于在条目已过期或已失效的情况下检索条目。这在那些宁愿选择过时数据而不是多个并发请求的计算成本的情况下可能很有用：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting `$data` variable is a PHP standard class that contains the `data`
    key (the data that has been cached) and all sorts of metadata about the cache
    entry: expiration, creation timestamp, tags, valid status, and so on.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`$data`变量是一个包含`data`键（已缓存的资料）和关于缓存条目的各种元数据的PHP标准类：过期时间、创建时间戳、标签、有效状态等等。
- en: Of course, there is also a `getMultiple()` method which you can use to retrieve
    multiple entries at once.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个`getMultiple()`方法，你可以用它一次性检索多个条目。
- en: 'More fun, though, is the `set()` method which allows us to store something
    in the cache. There are four parameters to this method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，`set()`方法允许我们在缓存中存储东西。此方法有四个参数：
- en: '`$cid` : The cache ID that can be used to retrieve the entry.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$cid`：用于检索条目的缓存ID。'
- en: '`$data` : A serializable data structure such as an array or object (or simple
    scalar value).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$data`：一个可序列化的数据结构，如数组或对象（或简单的标量值）。'
- en: '`$expire` : The UNIX timestamp after which this entry is considered invalid,
    or `CacheBackendInterface::CACHE_PERMANENT` to indicate that this entry is never
    invalid unless specifically invalidated. The latter is the default.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$expire`：UNIX时间戳，在此时间戳之后，此条目被认为是无效的，或者使用`CacheBackendInterface::CACHE_PERMANENT`来表示此条目永远不会无效，除非明确使其无效。后者是默认值。'
- en: '`$tags` : An array of cache tags that will be used to invalidate this entry
    if it depends on something else (cache metadata, basically).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$tags`：一个缓存标签数组，如果这个条目依赖于其他东西（缓存元数据，基本上），则将使用这些标签来使该条目无效。'
- en: 'So to use it, we would do something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用它，我们会这样做：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this statement we are creating a simple non-serialized cache entry into
    our chosen bin that does not expire unless specifically invalidated (or deleted).
    Subsequent calls with the same cache ID will simply override the entry. If the
    cache value is an array or object, it will get serialized automatically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个语句，我们在选择的bin中创建了一个简单的非序列化缓存条目，除非明确使其无效（或删除），否则不会过期。随后的相同缓存ID调用将简单地覆盖条目。如果缓存值是数组或对象，它将自动序列化。
- en: 'When it comes to deleting, there are two easy methods: `delete()` and `deleteMultiple()`,
    which take the `$cid` (or an array of cache IDs, respectively) as an argument and
    removes the entries from the bin completely. If we want to delete all the items
    in the bin, we can use the `deleteAll()` method.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到删除时，有两种简单的方法：`delete()`和`deleteMultiple()`，它们分别以`$cid`（或缓存ID数组）作为参数，并将条目从bin中完全删除。如果我们想删除bin中的所有项目，我们可以使用`deleteAll()`方法。
- en: 'Instead of deleting entries, quite often it''s a good idea to invalidate them.
    We''ll still be able to retrieve the data using the `$allow_invalid` parameter
    and can use the entry while the new one is being recalculated. This can be done
    almost exactly as deleting but using the following methods instead: `invalidate()`,
    `invalidateMultiple()`, and `invalidateAll()`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与删除条目相比，很多时候使它们无效是一个好主意。我们仍然可以使用`$allow_invalid`参数检索数据，并在新条目被重新计算时使用条目。这几乎可以像删除一样完成，但使用以下方法代替：`invalidate()`、`invalidateMultiple()`和`invalidateAll()`。
- en: OK, but what about those cache tags we can store with the entry? We already
    kind of know their purpose and that is to *tag* cache entries across multiple
    bins with certain data markers that can make them easy to invalidate when the
    data changes. Just like with render arrays. So, how can we do this?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但那些我们可以与条目一起存储的缓存标签是什么？我们多少已经知道了它们的作用，那就是在多个bin中使用某些数据标记来标记缓存条目，这样当数据更改时可以轻松使它们无效。就像渲染数组一样。那么，我们如何做到这一点呢？
- en: 'Let''s assume that we store the following cache entry:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们存储以下缓存条目：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We essentially make it dependent on changes to the Node with the ID of 10\.
    This means that when that node changes, our entry (together with all other entries
    in all other bins that have the same tag) becomes invalid. Simple as that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上使其依赖于ID为10的节点更改。这意味着当该节点更改时，我们的条目（以及所有其他bin中的所有其他条目，这些条目具有相同的标签）将变得无效。就这么简单。
- en: 'But we can also have our own tags that make it depend on something custom of
    ours like a data value (which, as we discussed earlier in the chapter, should
    implement the `CacheableDependencyInterface`) or a process of some kind. In that
    case, we would also have to take care of invalidating all the cache entries that
    have our tag. The simplest way we can do this is statically, using the `Cache`
    class we encountered earlier when merging metadata together:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以有自己的标签，使其依赖于我们自己的某些自定义内容，如数据值（正如我们在本章前面讨论的，应该实现`CacheableDependencyInterface`）或某种过程。在这种情况下，我们还需要负责使所有带有我们标签的缓存条目无效。我们可以通过以下最简单的方式静态地做到这一点，使用我们在合并元数据时遇到的`Cache`类：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will invalidate all cache entries that are *tagged* with any of the tags
    passed in the array. Under the hood, this method uses a static call to the cache
    invalidator service, so whenever possible, it's best to actually inject that service—`cache_tags.invalidator`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使所有带有数组中传递的任何标签的缓存条目无效。在底层，此方法使用对缓存无效化服务器的静态调用，因此，尽可能的情况下，最好实际注入该服务——`cache_tags.invalidator`。
- en: Creating our own cache bin
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的缓存bin
- en: Usually, the existing cache bins, particularly the default one, will be enough
    to store our own cache entries. However, there are times in which we need to create
    multiple entries for the same functionality, in which case, it would help to have
    a special bin for that. So, let's see how that can be created.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，现有的缓存存储，尤其是默认的，足以存储我们的缓存条目。然而，有时我们需要为同一功能创建多个条目，在这种情况下，有一个专门的存储会很有帮助。那么，让我们看看如何创建它。
- en: 'It''s quite easy because all we have to do is define a service:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为我们只需要定义一个服务：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The class used in this service definition is actually an interface. This is
    because we are using a factory to instantiate the service rather than the container
    directly. This means we don't know what class will be instantiated. In this case,
    the factory in question is the service with the name `cache_factory` and its `get()`
    method. In [Chapter 3](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml), *Logging and
    Mailing*, we saw an example in which something like this happened when we talked
    about logger channels.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务定义中使用的类实际上是一个接口。这是因为我们使用工厂来实例化服务而不是直接使用容器。这意味着我们不知道将实例化哪个类。在这种情况下，相关的工厂是名为`cache_factory`的服务及其`get()`方法。在[第3章](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml)“日志和邮件”中，我们看到了一个例子，当我们讨论日志通道时，发生了类似的事情。
- en: The `cache.bin` tag is used so that Drupal can understand the function of this
    service, namely, that it is a cache bin. The responsibility of making sure this
    bin gets its storage belongs to the actual backend. So in our example, the `DatabaseBackend`
    creates and removes the cache table as needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache.bin`标签用于让Drupal理解这个服务的功能，即它是一个缓存存储。确保这个存储获得其存储的责任属于实际的后端。因此，在我们的例子中，`DatabaseBackend`根据需要创建和删除缓存表。'
- en: Lastly, the static argument is the name of the bin that gets passed to the factory
    and that is used to create the cache backend for this particular bin. That is
    pretty much it. If we clear the cache, we can already see a new cache table for
    our bin in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，静态参数是传递给工厂并用于为这个特定存储创建缓存后端的存储名称。就是这样。如果我们清除缓存，我们已经在数据库中看到了我们存储的新缓存表。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the main aspects of caching in Drupal 8 any module
    developer needs to be familiar with. We introduced some key concepts and talked
    about the two main types of caching—Internal Page Cache (used for anonymous users)
    and Dynamic Page Cache (used for authenticated users).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Drupal 8中任何模块开发者都需要熟悉的缓存的主要方面。我们介绍了一些关键概念，并讨论了两种主要的缓存类型——内部页面缓存（用于匿名用户）和动态页面缓存（用于认证用户）。
- en: We dug deeper into cacheability metadata, which is probably the most important
    and common thing we need to understand. It's imperative to use this properly so
    that all the render arrays we build are cached and invalidated correctly. We also
    saw how block plugins have specific methods we can use to define their cacheability
    metadata and how access results should also receive cacheability dependencies, as
    needed. Stemming from this, we also explored lazy builders and the *auto-placeholdering*
    strategies that allow us to handle highly dynamic components while maintaining
    good cacheability overall.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更深入地研究了缓存性元数据，这可能是我们最需要理解和最常见的事情。正确使用它是强制性的，以确保我们构建的所有渲染数组都被正确缓存和使失效。我们还看到了如何使用特定的方法来定义块插件的缓存性元数据，以及访问结果应该如何根据需要接收缓存性依赖。在此基础上，我们还探讨了懒加载构建器和允许我们在保持整体良好缓存性的同时处理高度动态组件的*自动占位符*策略。
- en: Lastly, we looked into using the Cache API ourselves in order to store, read,
    and invalidate our own cache entries. We even saw how to create our own custom
    cache bin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何自己使用Cache API来存储、读取和使我们的缓存条目失效。我们还看到了如何创建我们自己的自定义缓存存储。
- en: Caching is a very important aspect of Drupal 8 module development. In previous
    versions, it didn't even come close and we were able to get away with it quite
    often without even paying attention to it. Now, we have a powerful system in place
    to make rendering more performant, and we should make use of it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是Drupal 8模块开发的一个重要方面。在之前的版本中，它甚至无法接近，我们经常能够忽略它而无需特别注意。现在，我们有一个强大的系统来提高渲染性能，我们应该充分利用它。
- en: In the next chapter, we are going to talk about JavaScript and how we can use
    it in a Drupal context, as well as the powerful Ajax API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论JavaScript以及我们如何在Drupal环境中使用它，以及强大的Ajax API。
