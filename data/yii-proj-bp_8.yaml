- en: Chapter 8. Building an API for the CMS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 为CMS构建API
- en: Throughout this book, we've covered the development of view-oriented applications—applications
    that the user can interact with directly. Our view-oriented approach, however,
    doesn't allow us to easily integrate with other services or provide functionalities
    for native applications. This view-oriented approach often leaves us with hardcoded
    functionality and makes integrations significantly more difficult. The Yii framework,
    however, is extremely adaptable and enables us to build API-driven applications
    rather than view-driven applications. An API reduces the amount of code we have
    to maintain; if executed properly, it reduces the amount of code that needs to
    change when we want to add a feature. Ultimately, this allows us to work faster
    and be more adaptable to changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经涵盖了面向视图的应用程序的开发——用户可以直接与之交互的应用程序。然而，我们的面向视图的方法并不允许我们轻松地与其他服务集成或为原生应用程序提供功能。这种面向视图的方法通常会使我们陷入硬编码的功能，并使集成变得显著更加困难。然而，Yii框架非常灵活，使我们能够构建API驱动应用程序而不是视图驱动应用程序。API减少了我们需要维护的代码量；如果执行得当，它减少了当我们想要添加功能时需要更改的代码量。最终，这使我们能够更快地工作，并更适应变化。
- en: Building an API-driven application also enables us to easily develop both web
    and native clients that work with our API, thus completely separating view-oriented
    logic from our application. In this chapter, we'll go over what we'll need to
    do in order to build an API-driven module for our content-management system that
    we created earlier. By fostering an ecosystem around our application, we can provide
    value to both developers and users, and increase the value of our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个API驱动的应用程序也使我们能够轻松地开发与我们的API一起工作的Web和原生客户端，从而完全将面向视图的逻辑与我们应用程序分离。在本章中，我们将讨论为了构建我们之前创建的内容管理系统（CMS）的API驱动模块，我们需要做什么。通过在我们的应用程序周围培养一个生态系统，我们可以为开发者和用户都提供价值，并提高我们应用程序的价值。
- en: 'The following is the demonstration:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为演示：
- en: '![Building an API for the CMS](img/7734OS_08_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![为CMS构建API](img/7734OS_08_01.jpg)'
- en: In this chapter, we'll go over what we'll need to do to build an API-driven
    module for our content management system that we created earlier.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论为了构建我们之前创建的内容管理系统的API驱动模块，我们需要做什么。
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: Since we'll be expanding upon the work we did in [Chapter 7](ch07.html "Chapter 7. Creating
    a Management Module for the CMS"), *Creating a Management Module for the CMS*,
    we'll need the completed source code from the previous chapter. You can either
    build the project yourself, or you can use the completed source code available
    in the project resources folder in the previous chapter. We'll also need a URL
    request client that will allow us to send `GET`, `POST`, and `DELETE` requests
    with JSON-encoded data to our application. You can either use cURL, or you can
    download a Google Chrome extension called **RESTClient** available at [https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en).
    The examples throughout this chapter will use RESTClient.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将基于我们在第7章中完成的工作进行扩展，即[第7章. 为CMS创建管理模块](ch07.html "第7章. 为CMS创建管理模块")，我们需要前一章的完整源代码。你可以自己构建项目，或者你可以使用前一章项目资源文件夹中可用的完整源代码。我们还需要一个URL请求客户端，它将允许我们向应用程序发送带有JSON编码数据的`GET`、`POST`和`DELETE`请求。你可以使用cURL，或者你可以下载一个名为**RESTClient**的Google
    Chrome扩展程序，该扩展程序可在[https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en)找到。本章中的示例将使用RESTClient。
- en: Describing the project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述项目
- en: 'In this chapter, we''ll be building an API module for our content-management
    system. The development of this module can be broken down into several pieces:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的内容管理系统构建一个API模块。这个模块的开发可以分为几个部分：
- en: Configuring the module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置模块
- en: Extending Yii to "RESTfully" render JSON or XML instead of a view file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Yii以“RESTfully”渲染JSON或XML而不是视图文件
- en: Handling data input
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据输入
- en: Handling user authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户身份验证
- en: Handling exceptions and errors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常和错误
- en: Specifying what data will be returned with each response
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定每个响应将返回哪些数据
- en: Implementing authentication, deauthentication, and basic CRUD actions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现身份验证、注销和基本的CRUD操作
- en: Configuring the module
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置模块
- en: The first component of this project will consist of creating and configuring
    our module so that it integrates with our main application. Since we added the
    functionality that seamlessly integrates modules into our application in the previous
    chapter, the only work required for this section will be to clear out our module
    cache, initialize the module, and add in the necessary routes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的第一个组件将包括创建和配置我们的模块，以便它与我们的主应用程序集成。由于我们在上一章中添加了无缝将模块集成到我们的应用程序的功能，本节所需的工作仅限于清除我们的模块缓存，初始化模块，并添加必要的路由。
- en: Extending Yii to render JSON or XML in a RESTful way
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 Yii 以以 RESTful 方式渲染 JSON 或 XML
- en: Since the Yii framework is designed to work with view files, we'll need to extend
    several components of the Yii framework in order to get it to output and render
    JSON or XML documentations. We'll also need to make several different changes
    to Yii so that it knows how to handle `GET`, `POST`, and `DELETE` actions independently
    of one another. To accomplish this, we'll create a new controller that will extend
    `CMSController`, which we created in the previous chapters. This will overload
    several key methods from `CController`, namely `runAction()`, `filterAccessControl()`,
    `createAction()`, and `beforeAction()`. We'll also extend several other classes—`CInlineAction`,
    `CAccessControlFilter`, and `CAccessRule`—to implement all the functionality we
    need. Finally, we'll also change the way the renderer works so that we can return
    data from our actions and have our base controller handle the output, thus reducing
    the amount of echoing we need to perform in each controller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Yii 框架旨在与视图文件一起工作，我们需要扩展 Yii 框架的几个组件，以便使其能够输出和渲染 JSON 或 XML 文档。我们还需要对 Yii
    进行一些不同的修改，以便它能够独立处理 `GET`、`POST` 和 `DELETE` 操作。为了实现这一点，我们将创建一个新的控制器，该控制器将扩展我们在之前章节中创建的
    `CMSController`。这将覆盖 `CController` 的几个关键方法，即 `runAction()`、`filterAccessControl()`、`createAction()`
    和 `beforeAction()`。我们还将扩展其他几个类——`CInlineAction`、`CAccessControlFilter` 和 `CAccessRule`——以实现我们所需的所有功能。最后，我们还将更改渲染器的工作方式，以便我们可以从我们的操作中返回数据，并让我们的基本控制器处理输出，从而减少在每个控制器中需要执行的回声数量。
- en: Handling data input
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数据输入
- en: For any request that modifies data in our application, we'll need to handle
    the acceptance of that data to the RESTful endpoint. To keep things simple, we'll
    accept JSON-encoded data, or we'll accept data encoded with `application/x-www-form-urlencoded`
    or HTML form fields for our convenience. In our application, we'll turn either
    of these data sources into usable attributes that we can modify and work from
    in order to complete tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何修改我们应用程序中数据的请求，我们需要处理将数据接受到 RESTful 端点。为了使事情简单，我们将接受 JSON 编码的数据，或者接受使用 `application/x-www-form-urlencoded`
    或 HTML 表单字段编码的数据，以方便我们。在我们的应用程序中，我们将将这些数据源转换为可用的属性，我们可以从中修改并完成任务。
- en: Authenticating users to the API
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 API 进行用户认证
- en: In Yii, user authentication and identification are typically handled by our
    `UserIdentity` class and cookies. By convention, RESTful API's don't send or accept
    any cookies, which means that we'll have to change the way we perform authentication
    within our application. For this, we'll create a custom `AccessControlFilter`
    that will initially authenticate our users using their username and password.
    If a user successfully authenticates against our API, we'll return to them a unique
    token that the user will use for all future requests that require authentication.
    This token, and the user's email address will be sent via two custom headers,
    `X-Auth-Token` and `X-Auth-Email`, and will allow us to identify the user in our
    API without requiring them to resend their password information. This token will
    be stored alongside our user in the `user_metadata` table we created in the previous
    chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii 中，用户认证和识别通常由我们的 `UserIdentity` 类和 cookies 处理。按照惯例，RESTful API 不发送或接受任何
    cookies，这意味着我们不得不改变在应用程序中执行认证的方式。为此，我们将创建一个自定义的 `AccessControlFilter`，它将最初使用用户的用户名和密码来认证我们的用户。如果用户成功认证我们的
    API，我们将返回一个唯一的令牌给用户，用户将使用此令牌进行所有需要认证的未来请求。此令牌和用户的电子邮件地址将通过两个自定义头 `X-Auth-Token`
    和 `X-Auth-Email` 发送，并允许我们在 API 中识别用户，而无需他们重新发送密码信息。此令牌将存储在我们之前章节中创建的 `user_metadata`
    表中，与我们的用户一起。
- en: Handling API exceptions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 API 异常
- en: The next components we'll need to handle are errors and exceptions. These will
    range from errors that Yii will encounter naturally, such as 404 errors when an
    action isn't found, to exceptions that we throw within our application to notify
    clients interacting with our API of either an unexpected error or a warning that
    something has happened. Since we'll be changing the way rendering works within
    our application, we'll simply reroute our errors the same way we would for the
    response of any action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要处理的是错误和异常。这些将包括Yii自然遇到的错误，例如当找不到操作时的404错误，以及我们在应用程序中抛出的异常，以通知与我们的API交互的客户端意外错误或警告。由于我们将更改应用程序内渲染的方式，我们将简单地以与任何操作响应相同的方式重定向我们的错误。
- en: Handling data responses
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数据响应
- en: 'With every request, we''ll return the HTTP status code, a message if an error
    occurred, and a mixed content response attribute that will contain all the information
    that we want to return to the client for consumption. The response will look as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，我们将返回HTTP状态码，如果发生错误，将返回一条消息，以及一个混合内容响应属性，它将包含我们希望返回给客户端消费的所有信息。响应将如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll also have our actions return a method that will allow us to define what
    attributes should be returned with each request. This will allow us to return
    only a limited amount of information, preventing accidental information disclosure,
    and will enable us to protect private information such as passwords or credentials.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将让我们的操作返回一个方法，这将允许我们定义每个请求应该返回哪些属性。这将使我们能够只返回有限的信息，防止意外信息泄露，并使我们能够保护像密码或凭证这样的私人信息。
- en: Implementing actions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现操作
- en: 'The last big part that we''ll handle is the implementation of all of our controller
    actions. This will include our authentication endpoint, all the user actions such
    as registering and resetting their password, and the management of our three core
    data models: Users, Categories, and Content.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的最后一个大问题是实现所有控制器操作。这包括我们的认证端点，所有用户操作，如注册和重置密码，以及我们三个核心数据模型：用户、类别和内容。
- en: Initializing the project
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'For this project, we''ll be starting where we left off in [Chapter 7](ch07.html
    "Chapter 7. Creating a Management Module for the CMS"), *Creating a Management
    Module for the CMS*. The steps are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将从[第7章](ch07.html "第7章。为CMS创建管理模块")，*为CMS创建管理模块*，我们上次停止的地方开始。步骤如下：
- en: For your convenience, a skeleton project has been included in the project resources
    folder for this chapter that contains the foundation that we'll be starting with.
    Begin by copying the source code to a new folder, and make sure that it is available
    at a different URL from the one we used in the previous chapter. In this chapter,
    I'll be using `http://chapter8.example.com` as our example URL.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了您的方便，本章的项目资源文件夹中包含了一个骨架项目，其中包含我们将开始的基础。首先，将源代码复制到一个新文件夹中，并确保它位于与上一章中使用的不同URL下。在本章中，我将使用`http://chapter8.example.com`作为我们的示例URL。
- en: 'After importing the database and updating the database configuration using
    the instructions provided in the previous chapter, create a new folder called
    `api` in `protected/modules` and also create the following directory structure:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用上一章中提供的说明导入数据库并更新数据库配置后，在`protected/modules`中创建一个名为`api`的新文件夹，并创建以下目录结构：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create the `ApiModule` class, `ApiModule.php`, in `protected/modules/api/`,
    which will bootstrap our module:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`protected/modules/api/`中创建`ApiModule`类，`ApiModule.php`，这将引导我们的模块：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create `routes.php` in `protected/modules/api/config/`, and populate
    it with the following information:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`protected/modules/api/config/`中创建`routes.php`，并填充以下信息：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, remove `modules.config.php` in the `protected/runtime/` directory,
    and the contents of the `protected/runtime/cache` directory, to clear the modules
    cache that we implemented in the previous chapter. This will ensure that Yii recognizes
    and caches our new module. The next time we access Yii, this file will be regenerated
    and will contain the appropriate module configuration for our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`protected/runtime/`目录中删除`modules.config.php`文件，以及`protected/runtime/cache`目录的内容，以清除我们在上一章中实现的模块缓存。这将确保Yii能够识别并缓存我们的新模块。下次我们访问Yii时，此文件将被重新生成，并将包含适用于我们应用程序的适当模块配置。
- en: Extending Yii to return data
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Yii以返回数据
- en: There are two approaches to having Yii render the JSON or XML data. The first
    and the easiest approach is to create a JSON or XML view file and, from every
    action, call `$this->render('json')`. While this is simple, it forces us to store
    a lot of information and explicitly call the `render()` method in each action.
    If we're extending a class that modifies the `render()` method, this can be extremely
    problematic if we want to make changes later. Another issue with this approach
    is that it treats errors as separate response types. When throwing an error with
    this approach, Yii will want to render the error as HTML rather than JSON. Depending
    upon our logging and debug level, this can cause our API to return the wrong data
    to our client.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法让Yii渲染JSON或XML数据。第一种也是最简单的方法是创建一个JSON或XML视图文件，并从每个动作中调用`$this->render('json')`。虽然这很简单，但它迫使我们存储大量信息，并在每个动作中显式调用`render()`方法。如果我们扩展的类修改了`render()`方法，那么在以后想要进行更改时可能会非常麻烦。这种方法另一个问题是它将错误视为不同的响应类型。当使用这种方法抛出错误时，Yii会希望将错误渲染为HTML而不是JSON。根据我们的日志和调试级别，这可能会导致我们的API向客户端返回错误的数据。
- en: A more preferable approach is to simply return the data that we want to present
    to the client in each action and have our parent controller class handle the rendering
    and output. This approach makes it easier to identify what data is being presented
    from each action and ensures that our API consistently returns the right data
    format even when exceptions or errors happen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是，在每一个动作中简单地返回我们想要向客户端展示的数据，并由父控制器类处理渲染和输出。这种方法使得识别每个动作展示的数据更加容易，并确保即使在发生异常或错误的情况下，我们的API也能始终返回正确的数据格式。
- en: To get this working, however, we need to extend a few classes from the Yii framework
    and modify them so that they return data instead of outputting it. The first class
    we need to extend is `CInlineAction`. `CInlineAction`. It represents the actual
    action method within our controllers and is called by the `runAction()` controller
    method. To make our API return data instead of outputting it, we first need to
    intercept the response of our actions by modifying the `CInlineAction` `runWithParamsInternal()`
    method, which we'll then return to the `runAction()` method in the parent controller.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，为了使这个功能正常工作，我们需要从Yii框架扩展几个类并修改它们，以便它们返回数据而不是输出。我们需要扩展的第一个类是`CInlineAction`。`CInlineAction`代表我们控制器中的实际动作方法，并由`runAction()`控制器方法调用。为了使我们的API返回数据而不是输出，我们首先需要通过修改`CInlineAction`的`runWithParamsInternal()`方法来拦截我们动作的响应，然后将其返回给父控制器中的`runAction()`方法。
- en: 'We''ll do this by creating a new class called `ApiInlineAction` that extends
    `CInlineAction` and overloads the `runWithParamsInternal()` method. For our convenience,
    we''ll put this code in `ApiInlineAction.php`, located at `protected/modules/api/components/`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过创建一个新的类`ApiInlineAction`来扩展`CInlineAction`并重载`runWithParamsInternal()`方法。为了方便起见，我们将这段代码放在`ApiInlineAction.php`中，位于`protected/modules/api/components/`目录下：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll need to create a base controller class that all of our API controllers
    will extend from. This parent class will be what ultimately class `runWithParamsInternal`.
    Begin by creating a new class in `protected/modules/api/components` called `ApiController.php`
    with the following definition:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个基类控制器，所有我们的API控制器都将从这个基类扩展。这个父类将最终成为`runWithParamsInternal`类。首先，在`protected/modules/api/components`目录下创建一个新的类`ApiController.php`，其定义如下：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Throughout this class, we''ll be referencing the private `$_action` variable,
    which we''ll need to redefine from the parent class. We''ll define the status
    and message variables at this time as well. These variables will hold the HTTP
    status code as well as any error messages that we want to present to the client:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个类中，我们将引用私有的`$_action`变量，我们需要从父类中重新定义它。我们还将在此处定义状态和消息变量。这些变量将包含HTTP状态码以及我们想要向客户端展示的任何错误消息：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll then overload our `runAction()` method to call our output method instead
    of Yii''s rendering methods:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重载`runAction()`方法，调用我们的输出方法而不是Yii的渲染方法：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have questions about `CInlineAction`? Be sure to check out the class documentation
    at [http://www.yiiframework.com/doc/api/1.1/CInlineAction](http://www.yiiframework.com/doc/api/1.1/CInlineAction).
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于`CInlineAction`有疑问？请务必查看类文档，链接为[http://www.yiiframework.com/doc/api/1.1/CInlineAction](http://www.yiiframework.com/doc/api/1.1/CInlineAction)。
- en: Rendering data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染数据
- en: 'The next part in outputting our data is to create the `renderOutput()` method
    that we called earlier:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出我们的数据的下一部分是创建我们之前调用的 `renderOutput()` 方法：
- en: 'We''ll begin by defining the method. In order to make it as adaptable as possible,
    we''ll want the ability to manually call this method with the status and message
    that we want to present:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先定义方法。为了使其尽可能适应，我们希望有手动调用此方法的能力，并显示我们想要呈现的状态和消息：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this time, we''ll define several response headers that will allow web clients
    to talk to our API and get the same-origin policy settings that modern web browsers
    have in place in order to protect users. Without these cross-origin resource-sharing
    headers (CORS, for short), web clients won''t be able to talk to our API. This
    will also allow web browsers to send our API custom authentication headers that
    we''ll define later:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此时，我们将定义几个响应头，这将允许网络客户端与我们的 API 通信，并获取现代网络浏览器中设置的相同源策略设置，以保护用户。没有这些跨源资源共享头（简称
    CORS），网络客户端将无法与我们的 API 通信。这还将允许网络浏览器发送我们稍后定义的自定义身份验证头：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll then define our base data response:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义我们的基本数据响应：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we''ll determine the data format in which we want to return our data
    from a `GET` parameter called `format` and render the data appropriately:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将确定我们想要从名为 `format` 的 `GET` 参数返回数据的数据格式，并适当地渲染数据：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To render JSON data, we''ll simply take the data response that we built in
    the previous steps and output it with `CJSON::encode()`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渲染 JSON 数据，我们只需将我们在上一步骤中构建的数据响应输出，并使用 `CJSON::encode()`：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rendering the XML data is slightly more involved but can easily be done with
    the following recursive method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染 XML 数据稍微复杂一些，但可以使用以下递归方法轻松完成：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have questions about the methods we're extending from `CController`? Be sure
    to take a look at the guide for this class at [http://www.yiiframework.com/doc/api/1.1/CController](http://www.yiiframework.com/doc/api/1.1/CController).
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对我们从 `CController` 扩展的方法有疑问？请务必查看该类的指南，链接为 [http://www.yiiframework.com/doc/api/1.1/CController](http://www.yiiframework.com/doc/api/1.1/CController)。
- en: Calling actions in a RESTful way
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以 RESTful 方式调用操作
- en: In a RESTful API, a single endpoint might respond differently to different kinds
    of HTTP requests. For instance, the `/api/user/index` endpoint might return a
    list of users or a particular user if a `GET` request is called with an ID parameter.
    However, if a `POST` request is called, a new user will either be created or modified.
    If a `DELETE` request was called to that endpoint with an ID, it would delete
    a user from the system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 中，单个端点可能对不同类型的 HTTP 请求有不同的响应。例如，`/api/user/index` 端点可能会在带有 ID
    参数的 `GET` 请求下返回用户列表或特定用户。然而，如果调用 `POST` 请求，则可能创建或修改新用户。如果对该端点调用带有 ID 的 `DELETE`
    请求，则将从系统中删除用户。
- en: 'To emulate this behavior in Yii, we need to overload the `createAction()` method
    of our `ApiController` so that it calls the correct action. In our controllers,
    this will allow us to separate functionality by the request type. Internally,
    our API will be calling actions in the format of `action<Name><Method>`, with
    the default `GET` action hitting the raw action method (for example, `actionIndex()`,
    `actionIndexPost()` and `actionIndexDelete()`). This method will also call the
    `ApiInlineAction` class that we defined earlier instead of `CInlineAction`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Yii 中模拟这种行为，我们需要重载 `ApiController` 的 `createAction()` 方法，以便调用正确的操作。在我们的控制器中，这将允许我们通过请求类型来分离功能。内部，我们的
    API 将以 `action<Name><Method>` 的格式调用操作，默认的 `GET` 操作将击中原始操作方法（例如，`actionIndex()`、`actionIndexPost()`
    和 `actionIndexDelete()`）。此方法还将调用我们之前定义的 `ApiInlineAction` 类，而不是 `CInlineAction`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Authenticating users
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户认证
- en: 'Since RESTful APIs don''t pass the cookie information between the API and the
    client, we need to make several modifications to our controller in order to separate
    authenticated users from unauthenticated users. For this, we''ll overload `CAccessControlFilter`
    so that it operates against the user information that we''ll populate in our controller:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RESTful API 不会在 API 和客户端之间传递 cookie 信息，因此我们需要对我们的控制器进行一些修改，以便将认证用户与非认证用户分开。为此，我们将重载
    `CAccessControlFilter`，使其针对我们在控制器中填充的用户信息操作：
- en: 'We''ll begin by adding a few more public properties to our `ApiController`.
    The `xauth` attributes will store the `X-Auth-Token` and `X-Auth-Email` headers
    that we''ll send for authentication, and the `user` property will store the raw
    user model for the authenticated user. We''ll pass this information down to the
    child controllers for authentication and also to our overloaded `CAccessControlFilter`
    class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的`ApiController`中添加一些更多的公共属性。`xauth`属性将存储用于认证的`X-Auth-Token`和`X-Auth-Email`头信息，而`user`属性将存储认证用户的原始用户模型。我们将传递这些信息到子控制器进行认证，以及到我们重载的`CAccessControlFilter`类：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we''ll load our `accessControl` filter. We''ll also define another filter
    called `CHttpCacheFilter` that will tell clients not to cache the responses our
    API returns:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的`accessControl`过滤器。我们还将定义另一个名为`CHttpCacheFilter`的过滤器，它将通知客户端不要缓存API返回的响应：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll then define our base `accessRules()`that will deny access to any method
    other than our error action:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们的基本`accessRules()`，它将拒绝访问除错误操作之外的所有方法：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we''ll need to handle the authentication in our controller before passing
    it to `CInlineActionFilter`. We''ll begin by overloading the `filterAccessControl()`
    method in our `ApiController`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在控制器中处理认证，然后再将其传递给`CInlineActionFilter`。我们将首先在我们的`ApiController`中重载`filterAccessControl()`方法：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll then retrieve the `X-Auth-Token` and `X-Auth-Email` headers:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检索`X-Auth-Token`和`X-Auth-Email`头信息：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we''ll validate these against our database. For this, we''ll look up a
    user in our database with the `X-Auth-Email` address; if this is found, we''ll
    then check for the API token that we''ll generate later on in the `user_metadata`
    table. If an API token is found, we''ll populate `$this->user` with the raw user
    model:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对这些信息与我们的数据库进行验证。为此，我们将使用`X-Auth-Email`地址在我们的数据库中查找一个用户；如果找到，我们将检查稍后在`user_metadata`表中生成的API令牌。如果找到API令牌，我们将使用原始用户模型填充`$this->user`：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we''ll call our custom `CAccessControlFilter` class, pass the user
    to it, set rules, and call the filter:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将调用我们的自定义`CAccessControlFilter`类，将用户传递给它，设置规则，并调用过滤器：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Overloading CAccessControlFilter
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载CAccessControlFilter
- en: 'We need to create a new class called the `ApiAccessControl` filter within `protected/modules/api/components/`
    so that we can continue using the `accessRules` array in our controllers. This
    class will operate on the `user` object we passed to it from our controller and
    will make our `accessRules` array work with our new user object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`protected/modules/api/components/`中创建一个新的类`ApiAccessControl`过滤器，这样我们就可以在我们的控制器中继续使用`accessRules`数组。这个类将操作我们从控制器传递给它的`user`对象，并使我们的`accessRules`数组与新的用户对象一起工作：
- en: 'After creating the `ApiAccessControlFilter.php` file, define it as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`ApiAccessControlFilter.php`文件后，定义如下：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll then need to add the `user` attribute to store the user as passed from
    our controller and redefine the `private $_rules` property that the parent class
    operates on:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加`user`属性以存储从我们的控制器传递的用户，并重新定义父类操作的`private $_rules`属性：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since the `$_rules` array in the parent class is private, we''ll need to redefine
    the getter and setter for the rules array as well as the `preFilter()` method
    that uses the private property. We''ll start with the `preFilter()` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于父类中的`$_rules`数组是私有的，我们还需要重新定义规则数组的获取器和设置器，以及使用私有属性的`preFilter()`方法。我们首先从`preFilter()`方法开始：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll then create both a getter and setter for our `rules` array:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为我们的`rules`数组创建获取器和设置器：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this time, we''ll also want to redefine the `accessDenied` behavior that
    gets called when a user doesn''t have access to a particular action. Here, we''ll
    simply call the `renderOutput()` method of `ApiController`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个时候，我们还想重新定义当用户没有访问特定操作时的`accessDenied`行为。在这里，我们将简单地调用`ApiController`的`renderOutput()`方法：
- en: '[PRE26]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To follow the same convention as Yii, we will also add a second class, `ApiAccessRule`,
    that extends `CAccessRule` inside the same file. This is just a simple modification
    that ensures that our information is loaded instead of the information that is
    passed to `CAccessRule`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了遵循Yii的相同约定，我们还将添加第二个类，`ApiAccessRule`，它扩展了同一文件中的`CAccessRule`。这只是简单的修改，确保我们的信息被加载，而不是传递给`CAccessRule`的信息：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Want to learn more about `CAccessControlFilter`? Take a look at the class documentation
    at [http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter](http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter).
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想了解更多关于`CAccessControlFilter`的信息？请查看类文档[http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter](http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter)。
- en: Processing the incoming data
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理传入的数据
- en: Since our RESTful API will be returning JSON, it's only appropriate that it
    should accept JSON as well. For convenience, we'll configure our API to accept
    `application/x-www-form-urlencoded` from the data (data sent from a form), so
    that our web clients can simply POST directly to our API without having to perform
    data conversion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的RESTful API将返回JSON，因此它也接受JSON是合适的。为了方便，我们将配置我们的API接受来自数据的`application/x-www-form-urlencoded`（从表单发送的数据），这样我们的Web客户端可以直接POST到我们的API，而无需进行数据转换。
- en: 'To make our API accept this data, we''ll overload the `beforeAction()` method
    in order to take the raw JSON body, if supplied, and populate it into our `$_POST`
    data if it is a valid JSON request. If invalid JSON is sent, we''ll return an
    HTTP 400 error, indicating that something was wrong with the request. The error
    will hit our `actionError()` method and bubble up to our `runAction()` method,
    which will finally display the error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的API接受这些数据，我们将重载`beforeAction()`方法，以便在提供的情况下获取原始JSON主体，并将其填充到我们的`$_POST`数据中，如果它是一个有效的JSON请求。如果发送了无效的JSON，我们将返回HTTP
    400错误，表示请求存在问题。错误将触发我们的`actionError()`方法，并冒泡到我们的`runAction()`方法，最终显示错误：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Handling errors
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: Before moving on to creating controllers, we need to make sure that our parent
    class can handle any errors that get sent to it. There are two types of errors
    we'll want to handle—the first being errors that Yii encounters either internally,
    or through exceptions we call, and the second being errors that we want to present
    to the user but that we don't want to send through an exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建控制器之前，我们需要确保我们的父类可以处理发送给它的任何错误。我们将要处理的错误有两种类型——第一种是Yii内部遇到的错误或通过我们调用的异常，第二种是我们想要展示给用户但不想通过异常发送的错误。
- en: Exception handling
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'To handle exceptions that either we throw or that Yii throws internally, we''ll
    define the base `actionError()` method as follows. The data set here will simply
    populate the `runAction()` method that we overloaded earlier and will ensure that
    the appropriate error is displayed in the correct format:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们抛出或Yii内部抛出的异常，我们将定义基`actionError()`方法如下。这里的数据集将简单地填充我们之前重载的`runAction()`方法，并确保以正确的格式显示适当的错误：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Custom error handling
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义错误处理
- en: 'Within our controllers, there will be situations that we''ll want to return
    an error to the user without triggering an exception. A great example of this
    is a model validation error. We want to inform the user that something went wrong,
    but we want to return from the error gracefully without stalling our application.
    For this, we''ll create a `returnError()` method that we''ll call from our controller
    that will populate back up to the `runAction()` method we defined earlier:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器中，将会有我们想要返回错误给用户而不触发异常的情况。一个很好的例子是模型验证错误。我们想要通知用户出了问题，但希望优雅地返回错误而不使我们的应用程序停滞。为此，我们将创建一个`returnError()`方法，从我们的控制器中调用，并将数据填充回我们之前定义的`runAction()`方法：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing whether everything works
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试是否一切正常
- en: 'Before we start creating other controllers and actions, let''s create a very
    simple controller in order to verify that our API is working the way we want it
    to. For this, let''s create a class called `DefaultController` in `protected/modules/api/controllers`
    with the following setup:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建其他控制器和操作之前，让我们创建一个非常简单的控制器，以验证我们的API是否按预期工作。为此，让我们在`protected/modules/api/controllers`中创建一个名为`DefaultController`的类，并按照以下设置进行：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If your API is set up correctly, you should be able to open your browser to
    `http://chapter8.example.com/api` and see the following displayed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的API设置正确，您应该能够打开浏览器到`http://chapter8.example.com/api`并看到以下内容显示：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, whatever data we returned from our action is now in the response
    attribute of our JSON object. Additionally, if we want to render XML instead of
    JSON, we can add the `format=xml GET` parameter to the `http://chapter8.example.com/api?format=xml`
    URL as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从操作返回的任何数据现在都在我们的JSON对象的响应属性中。此外，如果我们想渲染XML而不是JSON，我们可以在`http://chapter8.example.com/api?format=xml`
    URL中添加`format=xml GET`参数，如下所示：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most load balancers and health-check services verify that endpoints return a
    `200` status. For this reason, it's recommended that you simply return true from
    this default method if you're going to add a health check to your API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数负载均衡器和健康检查服务都会验证端点返回`200`状态。因此，如果你打算在你的API中添加健康检查，建议你只需从默认方法返回true。
- en: Authenticating users
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: 'Now that our API is functional, let''s add the ability for users to be authenticated
    against our API. For this, we''re going to create an endpoint that accepts the
    following JSON request body:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们API已经可用，让我们添加用户认证API的能力。为此，我们将创建一个端点，该端点接受以下JSON请求体：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this information, the API will be authenticated using `LoginForm`, which
    we worked on in previous chapters. If the user is valid, we''ll generate a new
    API token that will be stored in the `user_metadata` table. This token will be
    returned to the client who is making the request and will be used to authenticate
    for all future requests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，API将通过我们在前面的章节中工作的`LoginForm`进行认证。如果用户有效，我们将生成一个新的API令牌，该令牌将被存储在`user_metadata`表中。此令牌将返回给发起请求的客户端，并将用于所有未来的请求：
- en: 'To get started, create a new controller in `protected/modules/api/controllers/`
    called `UserController.php` with the following definition:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在`protected/modules/api/controllers/`目录下创建一个新的控制器，命名为`UserController.php`，其定义如下：
- en: '[PRE35]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll need to define a default set of access rules so as to allow our
    authentication method to be used without authentication:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一组默认的访问规则，以便我们的认证方法可以在不进行认证的情况下使用：
- en: '[PRE36]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since this is a `POST` endpoint, we''ll define our new method as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个`POST`端点，我们将按照以下方式定义我们的新方法：
- en: '[PRE37]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll then instantiate a new instance of `LoginForm` and retrieve our e-mail
    address and password from the JSON body. Remember that, in our `ApiController`
    class, we transformed the raw JSON body directly into our `$_POST` parameters
    in order to make things easier to work with:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实例化一个新的`LoginForm`实例，并从JSON体中检索我们的电子邮件地址和密码。记住，在我们的`ApiController`类中，我们直接将原始JSON体转换成了我们的`$_POST`参数，以便更容易处理：
- en: '[PRE38]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After retrieving this information, we''ll attempt to log in:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取这些信息后，我们将尝试登录：
- en: '[PRE39]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If successful, we''ll load the user information:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，我们将加载用户信息：
- en: '[PRE40]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Try to either update an existing API token, or generate a new one:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更新现有的API令牌，或者生成一个新的：
- en: '[PRE41]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we are able to save the token to the database, we''ll return it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们能够将令牌保存到数据库中，我们将返回它：
- en: '[PRE42]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Outside our `if ($model->login())` condition, we''ll simply return an error
    to the user, indicating that something went wrong. Since this is an authentication
    method, we don''t want to give away too much information in order to prevent people
    from attempting to brute-force our API endpoint:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`if ($model->login())`条件之外，我们将简单地返回一个错误给用户，表明出了些问题。由于这是一个认证方法，我们不希望泄露太多信息，以防止人们尝试暴力破解我们的API端点：
- en: '[PRE43]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Testing the authentication
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试认证
- en: 'Before proceeding, let''s make sure that our authentication endpoint works.
    To test this, we''ll be using a Google Chrome extension called **RestConsole**
    and that can be downloaded from the Chrome App Store at [https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en).
    If you do not already have Google Chrome installed, you can download it from [https://www.google.com/intl/en-US/chrome/browser/](https://www.google.com/intl/en-US/chrome/browser/).
    After installing, navigate to the RestConsole download page and install the plugin.
    Once it''s installed, you can click on the **Launch App** button in the Chrome
    App Store to load RestConsole. Once it''s loaded, you''ll see several different
    sections:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们确保我们的认证端点是正常工作的。为此，我们将使用一个名为**RestConsole**的Google Chrome扩展程序进行测试，该扩展程序可以从Chrome应用商店下载，网址为[https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en)。如果你还没有安装Google
    Chrome，你可以从[https://www.google.com/intl/en-US/chrome/browser/](https://www.google.com/intl/en-US/chrome/browser/)下载。安装后，导航到RestConsole下载页面并安装插件。安装完成后，你可以在Chrome应用商店点击**启动应用**按钮来加载RestConsole。加载完成后，你将看到几个不同的部分：
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A tool such as RestConsole will allow us to quickly test our API endpoints from
    a nice GUI interface. If you prefer, you can test the endpoints directly from
    your command line using the cURL utility, available through most package managers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 像RestConsole这样的工具将允许我们从漂亮的GUI界面快速测试我们的API端点。如果您愿意，您可以直接从命令行使用cURL实用程序测试端点，该实用程序可通过大多数包管理器获得。
- en: In the **Target** section, fill out the form as shown in the following screenshot.
    Be sure to adjust to your local environment. The key detail in this section is
    the **Request URI** field.![Testing the authentication](img/7734OS_08_02.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目标**部分，填写如下截图所示的内容。请确保根据您的本地环境进行调整。本部分的关键细节是**请求URI**字段。![测试身份验证](img/7734OS_08_02.jpg)
- en: Then, scroll down to the **Body** section, and fill out the section as follows:![Testing
    the authentication](img/7734OS_08_03.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，滚动到**正文**部分，并按照以下方式填写该部分：![测试身份验证](img/7734OS_08_03.jpg)
- en: Note
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The key part of this section is the **Request Payload** section. This is where
    you'll add the raw JSON body that will be sent to the server. In this example,
    we're using the credentials that we established in [Chapter 7](ch07.html "Chapter 7. Creating
    a Management Module for the CMS"), *Creating a Management Module for the CMS*.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一部分的关键部分是**请求有效载荷**部分。这是您将添加要发送到服务器的原始JSON正文的区域。在这个例子中，我们使用的是我们在[第7章](ch07.html
    "第7章。为CMS创建管理模块")中建立的凭据，*为CMS创建管理模块*。
- en: '[PRE44]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you've changed these credentials since then, be sure to change them in your
    JSON body.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在此之后更改了这些凭据，请确保在您的JSON正文中更改它们。
- en: Finally, click on the **Post** button at the bottom of the page. This will send
    the request to the server. If successful, you'll receive an HTTP 200 status code
    in response with your API token in the response body:![Testing the authentication](img/7734OS_08_04.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击页面底部的**提交**按钮。这将向服务器发送请求。如果成功，您将收到一个包含响应正文中API令牌的HTTP 200状态码响应：![测试身份验证](img/7734OS_08_04.jpg)
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your response body will differ slightly as the API token is randomly generated
    on each authentication request.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的响应正文将略有不同，因为API令牌在每个身份验证请求中都是随机生成的。
- en: Sending authenticated requests
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送经过身份验证的请求
- en: 'Now that we can authenticate against our API, let''s make sure that we can
    send authenticated requests. For this, we''ll be creating an API endpoint in order
    to deauthenticate our user. This will accept the user''s credentials and then
    delete the API token from the database in order to prevent future use:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够对我们的API进行身份验证，让我们确保我们可以发送经过身份验证的请求。为此，我们将创建一个API端点，以便注销我们的用户。这将接受用户的凭据，然后从数据库中删除API令牌，以防止未来的使用：
- en: 'Creating this endpoint consists of two parts. First, we need to add an item
    to our `accessRules` array that allows authenticated users to send a `DELETE`
    request to the token endpoint. We''ll do this by adding the following to our `accessRules`
    array:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建此端点包括两个部分。首先，我们需要向我们的`accessRules`数组添加一个项目，允许经过身份验证的用户向令牌端点发送`DELETE`请求。我们将通过向我们的`accessRules`数组添加以下内容来实现这一点：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we''ll add the delete method for our token endpoint that will be available
    over the HTTP `DELETE` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为我们的令牌端点添加删除方法，该方法将通过HTTP `DELETE`方法提供：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that are endpoint is set up, return to RestConsole, remove the request
    body, and add the following custom headers to the **Custom Headers** section below
    the request body, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了端点，返回RestConsole，删除请求正文，并在请求正文下面的**自定义头部**部分添加以下自定义头部，如下截图所示：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Sending authenticated requests](img/7734OS_08_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![发送经过身份验证的请求](img/7734OS_08_05.jpg)'
- en: 'Then, hit the **Delete** button at the bottom of the page to send a `DELETE`
    request. You should receive the following response:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击页面底部的**删除**按钮以发送`DELETE`请求。您应该会收到以下响应：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ve now successfully tested user authentication and added the ability to
    deauthenticate from our API. Notice that, if you try to submit a `DELETE` request
    again, our `acccessRules` array will kick in and will block the request for us,
    thus returning the following response:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功测试了用户身份验证并添加了从我们的API中注销的能力。请注意，如果您再次尝试提交一个`DELETE`请求，我们的`acccessRules`数组将启动并阻止该请求，从而返回以下响应：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implementing CRUD actions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD操作
- en: Now that we can authenticate and work with our API, we can work on implementing
    the four basic CRUD actions in a RESTful manner. The RESTful actions boil down
    to three main HTTP request types—`GET`, `POST`, and `DELETE`. We'll implement
    each one for our users.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以认证并使用我们的API，我们可以以RESTful方式实现四个基本的CRUD操作。RESTful操作归结为三种主要的HTTP请求类型——`GET`、`POST`和`DELETE`。我们将为我们的用户实现每一种：
- en: 'The first method we need to implement is our `loadModel()` method. This method
    will be loaded in our User model and will throw the appropriate errors if something
    goes wrong:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的第一种方法是我们的`loadModel()`方法。此方法将在我们的用户模型中加载，并在出现错误时抛出适当的错误：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Deleting users
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'The first method that we''ll implement is our `DELETE` method. Remember that,
    for each method, we''ll be hitting a single endpoint, `/api/user/index` , with
    different HTTP request types:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是我们的`DELETE`方法。记住，对于每个方法，我们将针对单个端点`/api/user/index`使用不同的HTTP请求类型：
- en: 'The first change that we need to make is to our `accessRules`. We want only
    administrators to have the ability to delete a user. We''ll do this by setting
    up an expression that checks whether the user is an admin:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是`accessRules`。我们希望只有管理员才有权删除用户。我们将通过设置一个表达式来检查用户是否是管理员来实现这一点：
- en: '[PRE52]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we''ll implement the delete action. We want to make sure that users are
    not able to delete themselves:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现删除操作。我们想要确保用户不能删除自己：
- en: '[PRE53]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Sending a `DELETE` request to `/api/user/index/id/<user_id>` will now delete
    a user with the given ID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 向`/api/user/index/id/<user_id>`发送`DELETE`请求现在将删除具有给定ID的用户。
- en: Retrieving users
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索用户
- en: 'The second method that we''ll implement is a `GET` method that will either
    retrieve a single user if an ID is provided, or multiple users if a user is an
    administrator. In either case, we''ll want to make sure that a user is authenticated:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第二种方法是`GET`方法，该方法将根据是否提供了ID来检索单个用户，或者如果用户是管理员，则检索多个用户。在任何情况下，我们都需要确保用户已经认证：
- en: 'The first change, once again, will be to our `accessRules` array. We''ll check
    to see whether a user is an admin, or whether the given ID belongs to the currently
    authenticated users:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个更改，再次，将是我们的`accessRules`数组。我们将检查用户是否是管理员，或者给定的ID是否属于当前认证的用户：
- en: '[PRE54]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll then set up a `GET` method in our controller. Remember, we set up our
    `createAction()` method in our `ApiController` class so that `GET` requests don''t
    require the HTTP verb at the end of the method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在控制器中设置一个`GET`方法。记住，我们在`ApiController`类中设置了`createAction()`方法，这样`GET`请求就不需要在方法末尾使用HTTP动词：
- en: '[PRE55]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, if an ID was provided, we''ll simply load the requested user. If the
    user is not an admin and they requested another user, we''ll throw an exception;
    otherwise, we''ll return the appropriate data:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果提供了ID，我们将简单地加载请求的用户。如果用户不是管理员并且他们请求了另一个用户，我们将抛出一个异常；否则，我们将返回适当的数据：
- en: '[PRE56]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you recall, we made changes to our `CMSActiveRecord` model in order to add
    a `getApiAttributes()` method. Calling this method now allows us to exclude certain
    elements that we don't want to send in the request, such as the user password.
    This also allows us to return metadata about the user, such as the role and any
    metadata associated with the user.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您还记得，我们为了添加`getApiAttributes()`方法而更改了我们的`CMSActiveRecord`模型。现在调用此方法允许我们排除我们不希望在请求中发送的某些元素，例如用户密码。这也允许我们返回有关用户的元数据，例如角色和与用户关联的任何元数据。
- en: 'Carrying on, if an ID was not specified, we''ll make sure that the user is
    an admin:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续进行，如果没有指定ID，我们将确保用户是管理员：
- en: '[PRE57]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If so, we''ll load up a search instance of our model. This extends our endpoint
    to allow for dynamic searching:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们将加载我们模型的搜索实例。这扩展了我们的端点以允许动态搜索：
- en: '[PRE58]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To allow for pagination, we''ll instance a copy of `CActiveDataProvider` from
    the `$model->search()` method and set the page variable to the `GET` parameter
    page. This will allow us to paginate through our users rather than dumping all
    of them in a single request:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许分页，我们将从`$model->search()`方法实例化一个`CActiveDataProvider`的副本，并将页面变量设置为`GET`参数页面。这将允许我们通过分页浏览我们的用户，而不是在单个请求中一次性显示所有用户：
- en: '[PRE59]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To handle pagination, we''ll simply continue to display results until no results
    are found. When no results are found, we''ll throw an HTTP 404 error. This will
    allow for infinite scrolling on the client side and will let our clients know
    when to stop asking for data:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理分页，我们将继续显示结果，直到没有找到结果。当没有找到结果时，我们将抛出一个HTTP 404错误。这将允许客户端进行无限滚动，并让我们的客户知道何时停止请求数据：
- en: '[PRE60]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ll then iterate through our `dataProvider` using the `getData()` method
    and generate an array of all the user objects in the current page:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`getData()`方法遍历我们的`dataProvider`，生成当前页面上所有用户对象的数组：
- en: '[PRE61]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we''ll return the entire response:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将返回整个响应：
- en: '[PRE62]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, make a few requests to the API endpoint in order to test everything out.
    You should be able to log in as an admin and view all users or any user. You should
    also be able to log in as a regular user and only retrieve information about yourself.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向API端点发送几个请求来测试一切。你应该能够以管理员身份登录并查看所有用户或任何用户。你也应该能够以普通用户身份登录，只检索有关自己的信息。
- en: Creating and updating users
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和更新用户
- en: 'The last endpoint we''ll need to implement is a `POST` method that will serve
    as an endpoint to both creating and updating existing users:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个端点是`POST`方法，它将作为创建和更新现有用户的端点：
- en: 'We''ll begin by updating the `accessRules` array that we defined in the previous
    section in order to include `indexPost`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先更新上一节中定义的`accessRules`数组，以包括`indexPost`：
- en: '[PRE63]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We''ll then create a `POST` endpoint that will branch off into two separate
    methods—one that creates users and one that modifies users:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`POST`端点，它将分支为两个独立的方法——一个用于创建用户，另一个用于修改用户：
- en: '[PRE64]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since all the information for creating users will be coming from a normal `POST`
    response, all we need to do to create a new user is verify that they are an admin,
    instantiate a new User model, validate it, and save it. If, for any reason, we
    encounter an error (such as an invalidate attribute), we''ll simply return the
    errors from `$model->getErrors()` in the JSON response:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于创建用户的所有信息都将来自正常的`POST`响应，因此我们创建新用户所需做的只是验证他们是否是管理员，实例化一个新的用户模型，验证它，并保存它。如果由于任何原因遇到错误（例如无效的属性），我们只需在JSON响应中返回`$model->getErrors()`中的错误：
- en: '[PRE65]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As it turns out, updating users is as simple as loading an existing User model
    and doing the same thing as creating a new user. The only difference in this endpoint
    is that we need to make sure that the user is either an admin, or that they are
    trying to modify their own data:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实上，更新用户就像加载现有的用户模型并执行与创建新用户相同的事情一样简单。在这个端点中，唯一的区别是我们需要确保用户是管理员，或者他们正在尝试修改自己的数据：
- en: '[PRE66]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At this point, go ahead and verify that you can create new users as an admin
    and that existing users can modify their own data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，请确保你可以作为管理员创建新用户，以及现有用户可以修改自己的数据。
- en: Implementing other controller actions from the main application
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主应用程序中的其他控制器操作
- en: At this point, we've created the basic CRUD interface for our User data model.
    While this takes care of a lot of the administrative tasks, there are a couple
    of other methods that we can move from the frontend of our application to our
    API. These methods include actions such as registration, account verification,
    and password reset requests. Moving these methods from our frontend and into our
    API immediately makes this functionality available to any consumer of our API,
    which makes our API more valuable to both web and native clients.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的用户数据模型创建了基本的CRUD接口。虽然这处理了很多管理任务，但还有一些其他方法我们可以从应用程序的前端移动到我们的API。这些方法包括注册、账户验证和密码重置请求等操作。将这些方法从我们的前端移动到API中，可以立即使此功能对任何API消费者可用，这使得我们的API对Web和本地客户端都更有价值。
- en: 'For example, we can easily adapt our registration action from our frontend
    to our API by simply replacing the render actions with either a Boolean value
    indicating that the registration was successful, or a list of errors generated
    by the model. Because all of our validation rules and verification checks are
    performed in the model, adapting the action is fairly simple, as shown:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过简单地用表示注册成功的布尔值或由模型生成的错误列表替换渲染操作，轻松地将我们的注册操作从前端适配到API。因为所有的验证规则和验证检查都是在模型中执行的，所以适配操作相对简单，如下所示：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Go ahead and try implementing the other actions from our frontend controller,
    such as `actionVerifyPost`, `actionActivate`, `actionForgotPost`, and `actionResetPasswordPost`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试实现前端控制器中的其他操作，例如`actionVerifyPost`、`actionActivate`、`actionForgotPost`和`actionResetPasswordPost`。
- en: Implementing categories and content API controllers
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现分类和内容API控制器
- en: Our CMS is made up of more than user-related actions—we also have to manage
    content and categories. Once again, moving this functionality from our dashboard
    controllers to our API is fairly simple. We simply strip out the view-related
    functionality and return either Boolean values, or errors generated from the model.
    In the case of our `GET` method, we simply add in some pagination using the already
    provided pagination functionality of `CActiveDataProvider` and return the relevant
    results. Both of these controllers will look nearly identical to our `UserController`,
    as they work in the same way except with different data models. Go ahead and try
    to complete these controllers on your own.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CMS不仅包括与用户相关的操作——我们还需要管理内容和分类。再次强调，将此功能从我们的仪表板控制器移动到我们的API相当简单。我们只是移除了与视图相关的功能，并返回布尔值或由模型生成的错误。在我们的`GET`方法中，我们只是添加了一些使用已提供的`CActiveDataProvider`分页功能进行分页，并返回相关结果。这两个控制器将几乎与我们的`UserController`相同，因为它们以相同的方式工作，只是数据模型不同。请尝试自己完成这些控制器。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a fully completed application is included with the project resources.
    If you get stuck, take a look at the resources folder.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，完整的应用程序已包含在项目资源中。如果您遇到困难，请查看资源文件夹。
- en: Documenting our API
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录我们的API
- en: While our API can be fun to work with and easy to integrate with, it means nothing
    to developers who want to work with our API if the available endpoints, details,
    and examples aren't documented clearly. Before sharing your API with the world,
    be sure to document what endpoints clients can access. It's also a good idea to
    thoroughly document what users need to do in order to authenticate against the
    API. Generally, this is done by providing detailed example requests and detailed
    example responses.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的API使用起来很有趣，并且易于集成，但如果可用的端点、细节和示例没有清晰地记录，那么对于想要使用我们的API的开发者来说，这毫无意义。在将您的API与全世界分享之前，请确保记录下客户端可以访问的端点。同样，详细记录用户需要执行的操作以验证API也是一个好主意。通常，这是通过提供详细的示例请求和详细的示例响应来完成的。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As shown throughout this book, the Yii framework is an extremely powerful, flexible,
    and easy PHP framework to work with. In this chapter, we completely overhauled
    how the Yii framework handles user authentication through JSON requests and adapts
    it to return both JSON and XML document types for an API that can be consumed
    by both web and native applications. In this chapter, we also covered what changes
    we needed to make in order to migrate functionality that was previously designed
    to be rendered directly to the client to our API to be rendered as JSON or XML.
    Finally, we adapted our API to respond to different types of HTTP requests on
    the same endpoint, allowing us to make a RESTful JSON API that is well documented.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中所示，Yii框架是一个极其强大、灵活且易于使用的PHP框架。在本章中，我们彻底改变了Yii框架通过JSON请求处理用户认证的方式，并使其能够返回JSON和XML文档类型，以便Web和原生应用程序都可以消费API。在本章中，我们还介绍了我们需要对之前设计为直接渲染给客户端的功能进行哪些更改，以便将其迁移到我们的API以作为JSON或XML渲染。最后，我们调整了我们的API，使其能够对同一端点的不同类型的HTTP请求做出响应，从而使我们能够创建一个文档齐全的RESTful
    JSON API。
- en: Thank you for reading this book. Throughout this book, we've shown countless
    examples of how powerful and flexible Yii is. From working with third-party APIs
    to performing database-agnostic migrations and all the way to developing feature-complete
    applications complete with an API, the Yii framework enables us to quickly work,
    develop, and adapt our code to meet our objectives and end goals in a timely manner.
    I hope that you found the information contained within this book informative,
    useful, and fun. I also hope that you've learned how to use the Yii framework
    to do more than just create simple web applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读这本书。在这本书中，我们展示了无数个例子，说明了Yii框架是多么强大和灵活。从与第三方API的交互到执行数据库无关的迁移，再到开发功能齐全的应用程序，包括API，Yii框架使我们能够快速工作、开发和调整我们的代码，以便及时满足我们的目标和最终目标。我希望您觉得这本书中的信息是有益的、有用的，并且有趣的。我也希望您已经学会了如何使用Yii框架来做不仅仅是创建简单的Web应用程序。
- en: On the about page of the Yii framework, Yii is described as an acronym for "Yes
    It Is" that answers some of the most basic questions asked about Yii. Is Yii fast?
    Is Yii secure? Is Yii professional? Is Yii right for your next project? I hope
    this book has shown you that the answer to those questions is a simple "Yes, it
    is".
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii 框架的关于页面，Yii 被描述为 "Yes It Is" 的缩写，它回答了关于 Yii 的一些最基本的问题。Yii 快速吗？Yii 安全吗？Yii
    专业吗？Yii 适合您的下一个项目吗？我希望这本书已经向您表明，这些问题的答案是一个简单的“是的，它是”。
