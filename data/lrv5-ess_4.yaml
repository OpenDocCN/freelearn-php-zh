- en: Chapter 4. Eloquent ORM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Eloquent ORM
- en: In the previous chapter, we touched on Eloquent, the **object-relational mapper**
    (**ORM**) that ships with Laravel. Eloquent acts as the model layer (the M in
    MVC) in our applications. As it is such a big part of most applications built
    in Laravel, we are going to take a look at Eloquent in more detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了与 Laravel 一起提供的 **对象关系映射器**（ORM）Eloquent。Eloquent 在我们的应用程序中充当模型层（MVC
    中的 M）。由于它是大多数在 Laravel 中构建的应用程序的一个重要部分，我们将更详细地探讨 Eloquent。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reading and writing data to our database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入数据库数据
- en: Relationships between models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型之间的关系
- en: Query scopes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询作用域
- en: Model events and observers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型事件和观察者
- en: Collections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Eloquent conventions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent 约定
- en: Eloquent has some conventions, which, if followed, will make your life easier.
    This approach is known as **convention over configuration**, which means, if you
    follow these conventions, you will have to do very little configuration for things
    to "just work".
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 有一些约定，遵循这些约定可以使你的生活更轻松。这种方法被称为 **约定优于配置**，这意味着如果你遵循这些约定，你将几乎不需要进行配置，事情就能“自然而然”地工作。
- en: An Eloquent model is contained in a single class and is the "studly-cased",
    singular version of your database table's name. Studly-case is similar to camel-casing,
    but the first letter is uppercase as well. So if you have a database table called
    `cats`, then your model class will be called `Cat`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 模型包含在一个单独的类中，并且是数据库表名称的单数“大驼峰式”版本。大驼峰式类似于驼峰式，但第一个字母也是大写。所以如果你有一个名为
    `cats` 的数据库表，那么你的模型类将被称为 `Cat`。
- en: 'There is no set place in the filesystem to place your Eloquent models; you
    are free to organize them as you see fit. You can use an Artisan command to create
    a model **stub** (a simple class with the basic structure of an Eloquent model).
    The command is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中没有固定的位置来放置你的 Eloquent 模型；你可以自由地按你的意愿组织它们。你可以使用 Artisan 命令来创建一个模型 **模板**（一个具有
    Eloquent 模型基本结构的简单类）。命令如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, Artisan places new model classes in the `app` directory. You are
    free to move your model classes and store them in whatever directory you wish,
    just be sure to update the namespace declaration at the top of the file to reflect
    its new location.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Artisan 将新的模型类放在 `app` 目录中。你可以自由地移动你的模型类并将它们存储在你想要的任何目录中，只需确保更新文件顶部的命名空间声明以反映其新位置。
- en: 'Our model stub class will look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式模板类看起来像这样：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will attempt to use a table called `cats` by default.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将默认尝试使用名为 `cats` 的表。
- en: 'Our model class extends the base Eloquent `Model` class, which contains all
    of the goodness we''re going to use over the course of this chapter. The first
    thing you should do after creating a model is define the database table it maps
    to. In our case, the database table will be called `cats`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式类扩展了 Eloquent 的基本 `Model` 类，其中包含我们在本章中将使用到的所有功能。在创建模型后，你应该做的第一件事是定义它映射到的数据库表。在我们的例子中，数据库表将被称为
    `cats`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a working Eloquent model at its simplest and you can now use it to fetch
    records from your database table.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的、可工作的 Eloquent 模型，你现在可以使用它来从你的数据库表中获取记录。
- en: Retrieving data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: Eloquent provides you with numerous ways to fetch records from your database,
    each with their own appropriate use case. You can simply fetch all records in
    one go; a single record based on its primary key; records based on conditions;
    or a paginated list of either all or filtered records.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 提供了多种方式来从数据库中获取记录，每种方式都有其合适的用例。你可以一次性获取所有记录；基于主键获取单个记录；基于条件获取记录；或者获取所有或过滤记录的分页列表。
- en: 'To fetch all records, we can use the aptly-named `all` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有记录，我们可以使用名为 `all` 的方法：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To fetch a record by its primary key, you can use the `find` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过主键获取记录，你可以使用 `find` 方法：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Along with the `first` and `all` methods, there are **aggregate** methods.
    These allow you to retrieve aggregate values (rather than a record set) from your
    database tables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `first` 和 `all` 方法之外，还有 **聚合** 方法。这些方法允许你从数据库表中检索聚合值（而不是记录集）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Filtering records
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤记录
- en: Eloquent also ships with a feature-rich query builder that allows you to build
    queries in code, without having to write a single line of SQL. This abstraction
    layer makes it easier to swap database platforms, should you ever need to. With
    Laravel, the only thing you need to do is update your database configuration and
    your application will continue to function as before.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 还提供了一套功能丰富的查询构建器，允许你在代码中构建查询，而无需编写任何 SQL 代码。这个抽象层使得在需要时更容易切换数据库平台。使用
    Laravel，你只需要更新你的数据库配置，你的应用程序将继续像以前一样运行。
- en: 'Laravel''s query builder has methods for common SQL-like directives such as
    `WHERE`, `ORDER`, and `LIMIT`; and more advanced concepts such as joins. For example,
    the previous `find` illustration can be expressed—albeit in longhand—as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的查询构建器提供了常见的 SQL 类型的指令方法，如 `WHERE`、`ORDER` 和 `LIMIT`；以及更高级的概念，如连接。例如，之前的
    `find` 示例可以表达为——尽管是冗长的——：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will retrieve the first record `WHERE 'id' = 1`. We will only expect one
    record when querying based on the primary key, so use the `first` method. If we
    have a more open `WHERE` clause, where we were expecting potentially more than
    one record, we can use the `get` method, as we did in the first code example,
    and it will only return records that matched that clause.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索第一个记录 `WHERE 'id' = 1`。当我们基于主键进行查询时，我们只期望一个记录，所以使用 `first` 方法。如果我们有一个更开放的
    `WHERE` 子句，我们期望可能有多条记录，我们可以使用 `get` 方法，就像我们在第一个代码示例中所做的那样，它将只返回匹配该子句的记录。
- en: 'Clauses can also be **chained**. This allows you to build up complex query
    conditions by adding clauses together. Consider the following example code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 条件也可以**链式**使用。这允许你通过添加条件来构建复杂的查询条件。考虑以下示例代码：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will find all male users who were born after February 12, 1989\. Instead
    of specifying dates manually, we can also use **Carbon**, a date and time library.
    Here is an example of using Carbon to find all users who are older than 21 years
    of age:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到所有在 1989 年 2 月 12 日之后出生的男性用户。除了手动指定日期外，我们还可以使用 **Carbon**，一个日期和时间库。以下是一个使用
    Carbon 查找所有 21 岁以上用户的示例：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on Carbon and its available functions at its official
    GitHub repository [https://github.com/briannesbitt/Carbon](https://github.com/briannesbitt/Carbon).
    Common Carbon methods are also covered in [Appendix](apa.html "Appendix A. An
    Arsenal of Tools"), *An Arsenal of Tools*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Carbon 的官方 GitHub 仓库中找到更多关于 Carbon 及其可用函数的信息 [https://github.com/briannesbitt/Carbon](https://github.com/briannesbitt/Carbon)。Carbon
    的常见方法也在 [附录](apa.html "附录 A. An Arsenal of Tools") *An Arsenal of Tools* 中进行了介绍。
- en: 'Along with filtering records by `WHERE` conditions, you can also limit the
    number of records by using ranges using the `take` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过 `WHERE` 条件过滤记录外，你还可以使用 `take` 方法通过范围限制记录数量：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will get the first five female users. You can also specify offsets by
    using the skip method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取前五个女性用户。你还可以使用 `skip` 方法指定偏移量：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In SQL, this will look similar to the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，这看起来类似于以下：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Queries can also be ordered by using the `orderBy` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 查询也可以通过使用 `orderBy` 方法进行排序：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will correspond to a SQL statement that looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对应于一个看起来像这样的 SQL 语句：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Saving data
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存数据
- en: Applications that display data are great, but they're not very interactive.
    The fun comes when you allow users to submit data, whether these users are trusted
    contributors adding content via a content management system or contributions from
    general users on a site like Wikipedia.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显示数据的应用程序很棒，但它们并不非常交互式。当允许用户提交数据时，乐趣才开始，无论这些用户是受信任的贡献者通过内容管理系统添加内容，还是来自像维基百科这样的网站的一般用户。
- en: 'When you retrieve a record via Eloquent, you can access its properties as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 Eloquent 获取记录时，你可以按照以下方式访问其属性：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can update attribute values in the same manner:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以同样的方式更新属性值：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will set the value in the model instance, but we need to persist the change
    to the database. We do this by calling the `save` method afterwards:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模型实例中设置值，但我们需要将更改持久化到数据库中。我们通过之后调用 `save` 方法来完成此操作：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have a table with lots of columns, then it will become tiresome to assign
    each property manually like this. To this end, Eloquent allows you to fill models
    by passing an associative array with values, and the keys representing the column
    names. You can fill a model while either creating or updating it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含许多列的表格，那么手动为每个属性分配值将会变得非常繁琐。为此，Eloquent 允许你通过传递一个包含值的关联数组，并使用键来表示列名，来填充模型。你可以在创建或更新模型时填充模型：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, this will throw a `MassAssignmentException` error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将抛出`MassAssignmentException`错误。
- en: Mass assignment
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量赋值
- en: The preceding example is an example of **mass assignment**. That is where a
    model's attributes are blindly updated with values *en masse*. If the `$data`
    array in the previous example came from say, a user's form submission, then they
    can update any and all values in the same database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个**批量赋值**的例子。这就是模型属性被盲目地批量更新。如果前一个例子中的`$data`数组来自用户表单提交，那么它们可以更新数据库中相同表中的任何和所有值。
- en: Consider that you have a `users` table with a column called `is_admin`, which
    determines whether or not that user can view your website's administration area.
    Also consider that users on the public side of your website can update their profile.
    If, during form submission, the user also included a field with the name of `is_admin`
    and a value of `1`, that would update the column value in the database table and
    grant them access to your super secret admin area—this is a huge security concern
    and is exactly what mass-assignment protection prevents.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`users`的表，其中有一个名为`is_admin`的列，该列确定用户是否可以查看你的网站管理区域。还假设你的网站公共侧面的用户可以更新他们的个人资料。如果在表单提交期间，用户还包含一个名为`is_admin`且值为`1`的字段，那么这将更新数据库表中的列值，并授予他们访问你的超级秘密管理区域——这是一个重大的安全问题，这正是批量赋值保护所防止的。
- en: 'To mark columns whose values are safe to set via mass-assignment (such as `name`,
    `birth_date`, and so on.), we need to update our Eloquent models by providing
    a new property called `$fillable`. This is simply an array containing the names
    of the attributes that are safe to set via mass assignment:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标记可以通过批量赋值安全设置的列（例如`name`、`birth_date`等），我们需要通过提供一个名为`$fillable`的新属性来更新我们的Eloquent模型。这只是一个包含可以通过批量赋值安全设置的属性名称的数组：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can create and update models by passing an array of data as before,
    without facing a `MassAssignmentException` being thrown.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过传递一个数据数组的方式创建和更新模型，就像之前一样，而不会遇到抛出`MassAssignmentException`异常的情况。
- en: Along with creating a new record, there are a couple of sibling methods that
    you can use. There is `firstOrCreate`, where you can pass an array of data—Eloquent
    will first try and find a model with the matching values. If it can't find a match,
    it will instead create the record.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建新记录之外，还有一些你可以使用的兄弟方法。有`firstOrCreate`，你可以传递一个数据数组——Eloquent会首先尝试找到具有匹配值的模型。如果找不到匹配项，它将创建记录。
- en: There's also the similarly named `firstOrNew` method. However, instead of immediately
    saving the record to the database, it will instead just return a new Eloquent
    instance with the attribute values set, allowing you to set any other values first
    before manually saving it yourself.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有类似命名的`firstOrNew`方法。然而，它不会立即将记录保存到数据库中，而是会返回一个新的Eloquent实例，其中设置了属性值，允许你在手动保存之前先设置其他任何值。
- en: A good time to use these methods is when allowing users to log in by using a
    third-party service such as Facebook or Twitter. These services will usually return
    information identifying the user, such as an e-mail address, allowing you to check
    your database for a matching user. If one exists, you can simply log them in,
    otherwise you can create a new user account for them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的好时机是当允许用户通过使用第三方服务（如Facebook或Twitter）登录时。这些服务通常会返回识别用户的个人信息，例如电子邮件地址，允许你检查数据库中是否存在匹配的用户。如果存在，你可以简单地让他们登录，否则你可以为他们创建一个新的用户账户。
- en: Deleting data
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'There are two ways of deleting records. If you have a model instance that you
    have fetched from the database, then you can call the `delete` method on it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录有两种方式。如果你已经从数据库中获取了一个模型实例，那么你可以在其上调用`delete`方法：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can call the `destroy` method, specifying the IDs of the
    records you want to delete, without having to fetch those records first:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以调用`destroy`方法，指定你想要删除的记录的ID，而不需要先获取这些记录：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Soft deletion
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除
- en: By default, Eloquent will **hard-delete** records from your database. This means,
    once it's deleted, it's gone forever. If you need to retain deleted data (that
    is, for auditing), then you can use **soft deletes**. When deleting a model, the
    record is kept in the database but instead a `deleted_at` timestamp is set, and
    any records with this timestamp set will not be included when querying your database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Eloquent 将从你的数据库中**硬删除**记录。这意味着一旦删除，它就永远消失了。如果你需要保留已删除的数据（即，用于审计），那么你可以使用**软删除**。当删除模型时，记录将保留在数据库中，但会设置一个
    `deleted_at` 时间戳，并且当查询数据库时，将不包括设置此时间戳的任何记录。
- en: 'Soft deletes can be easily added to your Eloquent model. All you need to do
    is include the trait:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除可以轻松添加到你的 Eloquent 模型中。你只需要包含以下特性：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've also designated that the `deleted_at` column should be treated as a date
    column. This will yield the value as a Carbon instance and allow us to perform
    operations on it or display it in a variety of formats, should we need to.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了 `deleted_at` 列应被视为日期列。这将产生一个 Carbon 实例，并允许我们在需要时对其进行操作或以各种格式显示。
- en: 'You''ll also need to make sure the `deleted_at` column is added to your table
    migration. An example of such a migration is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保将 `deleted_at` 列添加到你的表迁移中。以下是一个此类迁移的示例：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Including deleted models in results
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含已删除模型的结果
- en: 'If you find you need to include deleted records when querying your database
    (for example, in an administration area), then you can use the `withTrashed` query
    scope. Query scopes are just methods you can use in chaining:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现需要在查询数据库时包含已删除的记录（例如，在管理区域），那么你可以使用 `withTrashed` 查询作用域。查询作用域只是你可以用于链式调用的方法：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will mix deleted records with non-deleted records. If you find you need
    to retrieve *only* deleted records, then you can use the `onlyTrashed` query scope:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将混合已删除的记录和非删除的记录。如果你发现你需要检索*仅*已删除的记录，那么你可以使用 `onlyTrashed` 查询作用域：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you find you need to "un-delete" a record, then the `SoftDeletes` trait
    provides you with a new `restore` method to undo this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你需要“恢复”一条记录，那么 `SoftDeletes` 特性为你提供了一个新的 `restore` 方法来撤销此操作：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, if you find you *really* need to delete a record from your database,
    you can use the `forceDelete` method. As the name implies, once you delete a record
    with this method, it's truly gone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你发现你真的需要从数据库中删除一条记录，可以使用 `forceDelete` 方法。正如其名所示，一旦使用此方法删除记录，它就真的消失了。
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Query scopes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询作用域
- en: The previous section introduced you to the concept of query scopes. This builds
    on from the query builder that allows you to build conditions on an ad hoc basis.
    However, what if you need certain conditions to apply to every request? Or a single
    condition that is actually the combination of multiple `WHERE` clauses? This is
    where query scopes come in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节向您介绍了查询作用域的概念。这是基于查询构建器，允许您根据需要构建条件。然而，如果你需要某些条件适用于每个请求？或者一个实际上是多个 `WHERE`
    子句组合的单个条件？这就是查询作用域发挥作用的地方。
- en: 'Query scopes allow you to define these conditions once in your model, and then
    re-use them without having to manually define the clauses that make up that condition.
    For example, imagine we need to find users above the age of 21 in multiple places
    in our application. We can express this as a query scope:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查询作用域允许你在模型中一次性定义这些条件，然后无需手动定义构成该条件的子句即可重用它们。例如，假设我们需要在我们的应用程序的多个地方找到年龄超过21岁的用户。我们可以将此表示为一个查询作用域：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Thanks to the fluent query builder, we can now use this as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了流畅的查询构建器，我们现在可以这样使用：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, query scopes are methods that begin with the word "scope",
    take the current query as a parameter, modify it in some way, and then return
    the modified query, ready to be used in another clause. This means you can chain
    query scopes just as you would any other query expression:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，查询作用域是那些以“scope”一词开头的方法，它们接受当前查询作为参数，以某种方式修改它，然后返回修改后的查询，以便在另一个子句中使用。这意味着你可以像使用任何其他查询表达式一样链式调用查询作用域：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Along with simple scopes like these, we can create more "dynamic" scopes that
    accept parameters and can be passed to the scope''s conditions. Consider the following
    example code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些简单的查询作用域之外，我们还可以创建更“动态”的查询作用域，这些作用域接受参数，并且可以将它们传递给作用域的条件。考虑以下示例代码：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can then find cats of a specific breed as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式找到特定品种的猫：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Relationships
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: 'When we built our application in [Chapter 3](ch03.html "Chapter 3. Your First
    Application"), *Your First Application*, we made use of relationships. Each cat
    in our application was of a particular breed. However, instead of storing the
    name of the breed next to every individual cat and potentially having the breed
    repeating numerous times, we created a separate `breeds` table and each cat''s
    breed was a value that referred to the ID of a record in that table. This gave
    us an example of two types of relationships: a cat *belongs to* a breed, but a
    breed can *have many* cats. This is defined as a **one-to-many** relationship.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第3章](ch03.html "第3章。您的第一个应用程序")中构建我们的应用程序时，*您的第一个应用程序*，我们使用了关系。在我们的应用程序中，每只猫都属于一个特定的品种。然而，我们并没有在每只猫旁边存储品种名称，并且可能重复多次，而是创建了一个单独的`breeds`表，每只猫的品种都是一个引用该表中记录ID的值。这为我们提供了一个关于两种关系类型的例子：猫*属于*一个品种，但一个品种可以*拥有*许多猫。这被定义为**一对多**关系。
- en: 'There are other types of relationships, for each of which Eloquent provides
    good support:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent为每种关系类型都提供了良好的支持：
- en: One-to-one
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一
- en: Many-to-many
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多
- en: Has-many-through
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多个模型关联
- en: Polymorphic relations
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态关系
- en: Many-to-many polymorphic relations
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多多态关系
- en: Here, we will look through them with an example of each.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过每个示例来查看它们。
- en: One-to-one
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: Sometimes, you may want to split data across multiple tables for ease of management,
    or because they represent two different parts of one entity. A common example
    is a user, and a user's profile. You may have a `users` table that contains core
    information about that user such as their name, account e-mail address, and password
    hash; however, if it's a social networking website, then they may also have a
    profile with more information, such as their favorite color. This information
    can then be stored in a separate `profiles` table, with a foreign key representing
    the user that the profile belongs to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想将数据分散在多个表中以便于管理，或者因为它们代表了一个实体的两个不同部分。一个常见的例子是用户及其个人资料。你可能有一个包含关于该用户核心信息的`users`表，例如他们的姓名、账户电子邮件地址和密码散列；然而，如果是一个社交网络网站，他们可能还有一个包含更多信息的个人资料，例如他们最喜欢的颜色。这些信息可以存储在一个单独的`profiles`表中，其中外键代表个人资料所属的用户。
- en: 'In your models, this relation will look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的模型中，这种关系将看起来像这样：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And in the `Profile` model, the relation will look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Profile`模型中，关系将看起来像这样：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When querying `Users`, we can also access their profile separately:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询`用户`时，我们也可以单独访问他们的个人资料：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Relations are accessed using the name of the method used to define it in the
    model. Since in the `User` model we defined the relation in a method called `profile`,
    this is the name of the property we use to access the data of that related model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在模型中定义它的方法的名称来访问关系。由于在`User`模型中我们在一个名为`profile`的方法中定义了关系，因此这是我们用来访问相关模型数据的属性名称。
- en: Many-to-many
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: A many-to-many relationship is more complicated than a one-to-one (where one
    model belongs to exactly one other model) or a one-to-many relationship (where
    many models can belong to one other model). As the name suggests, many models
    can belong to many other models. To accomplish this, instead of just two tables
    being involved, a third is introduced. This can be quite difficult to comprehend,
    so let's look at an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系比一对一（一个模型恰好属于另一个模型）或一对多关系（许多模型可以属于另一个模型）更复杂。正如其名所示，许多模型可以属于许多其他模型。为了实现这一点，除了涉及两个表之外，还需要引入第三个表。这可能会相当难以理解，所以让我们通过一个例子来看看。
- en: 'Imagine you''re building a permissions system to limit what actions each user
    can perform. Instead of assigning permissions on a per-user basis, you instead
    have roles, where each user is given a subset of permissions, depending on which
    role they''ve been assigned. In this description, we''ve identified two entities:
    a `User` and a `Role`. Also in this scenario, a user can have many roles, and
    a role can belong to many users. To map roles to users, we create a third table,
    called a join table. Laravel refers to these tables as **pivot** tables, a term
    you may have heard of if you have worked with spreadsheets before.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个权限系统来限制每个用户可以执行的操作。你不必为每个用户分配权限，而是有角色，每个用户根据他们被分配的角色获得一组子权限。在这个描述中，我们识别了两个实体：`用户`和`角色`。在这个场景中，一个用户可以有多个角色，一个角色可以属于多个用户。为了将角色映射到用户，我们创建了一个第三个表，称为连接表。Laravel将这些表称为**枢纽表**，如果你之前使用过电子表格，你可能已经听说过这个术语。
- en: By default, Eloquent expects join tables to contain the singular names of the
    two target tables, listed alphabetically and separated by an underscore. So in
    our scenario, this would be `role_user`. The table itself contains only two columns
    (other than the primary key). These columns represent the foreign key of the `Role`
    model and the `User` model it is creating a relation between. Again in convention
    over configuration, these should be lowercase, singular, with `_id` appended,
    that is, `role_id` and `user_id`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Eloquent 预期连接表包含两个目标表的单一名称，按字母顺序排列并用下划线分隔。所以在我们这个场景中，这将是一个 `role_user`。该表本身只包含两列（除了主键之外）。这些列代表
    `Role` 模型和它正在创建关系的 `User` 模型的外键。再次按照约定优于配置的原则，这些名称应该是小写、单数，并附加 `_id`，即 `role_id`
    和 `user_id`。
- en: 'The relationship is defined in both our `User` and `Role` models using the
    `belongsToMany` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `User` 和 `Role` 模型中使用 `belongsToMany` 方法定义了这种关系：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now find out what roles a user has been assigned:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找出用户被分配了哪些角色：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also find out all users with a particular role:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找出具有特定角色的所有用户：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you need to add a new role to a user, you can do so by using the `attach`
    method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向用户添加新角色，你可以通过使用 `attach` 方法来实现：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, of course, the opposite of `attach` is `detach`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`attach` 的反义词是 `detach`：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Both the `attach` and `detach` methods also accept arrays, allowing you to add/remove
    multiple relations in one operation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach` 和 `detach` 方法也接受数组，允许你在一次操作中添加/删除多个关系。'
- en: Alternatively, you can use the `sync` method. The difference with `sync` is,
    only after the operation is complete are the IDs that are passed present in the
    join table, rather than adding/removing them from the existing relations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 `sync` 方法。与 `sync` 的区别在于，只有当操作完成后，传递的 ID 才会出现在连接表中，而不是从现有关系中添加/删除它们。
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Storing data in the pivot table
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储在枢纽表中的数据
- en: 'Along with storing the primary keys of both the related models in the pivot
    table, you can also store additional data. Imagine we have users and groups in
    an application. Many users can belong to many groups, but users can also be moderators
    of groups. To indicate which users are moderators of a group, we can add a `is_moderator`
    column on the pivot table. To specify the additional data that should be stored
    in the pivot table, we can specify a second parameter when calling the `attach`
    method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在枢纽表中存储相关模型的两个主键之外，你还可以存储额外的数据。想象一下，在一个应用程序中，我们有用户和组。许多用户可以属于许多组，但用户也可以是组的调解员。为了指示哪些用户是某个组的调解员，我们可以在枢纽表上添加一个
    `is_moderator` 列。为了指定在调用 `attach` 方法时应存储在枢纽表中的额外数据，我们可以在调用 `attach` 方法时指定第二个参数：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can use the same approach when using the `sync` method too:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `sync` 方法时，我们也可以使用相同的方法：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Has-many-through
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多通过
- en: With related data, things are simple when you want data from a model that is
    directly related to the current one you're working with; but what happens if you
    want data that is two **hops** away from your current model?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要从与你当前正在操作的直接相关的模型中获取数据时，有相关数据的情况下事情很简单；但如果你想要获取与你当前模型相隔两个**跳**的数据会发生什么呢？
- en: Consider a simple e-commerce website. You may have a `Product` model, an `Order`
    model, and an `OrderItem` model that belongs to both a product and an order. You
    have been tasked with finding all orders that contain a particular product. How
    do you do this if `Product` isn't directly associated with `Order`? Thankfully,
    in our scenario, they have a common relation—the `OrderItem` model.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的电子商务网站。你可能有一个 `Product` 模型，一个 `Order` 模型，以及一个 `OrderItem` 模型，它属于产品也属于订单。你被分配的任务是找出包含特定产品的所有订单。如果
    `Product` 与 `Order` 没有直接关联，你该如何做呢？幸运的是，在我们的场景中，它们有一个共同的关系——`OrderItem` 模型。
- en: 'We can use a "has-many-through" relationship to reach orders a product is part
    of via the intermediate `OrderItem` model. We set the relationship up in our `Product`
    model, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 "一对多通过" 关系通过中间的 `OrderItem` 模型来访问产品所属的订单。我们在 `Product` 模型中设置关系，如下所示：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first parameter in the `hasManyThrough` method is the target model, and
    the second parameter is the intermediate model we go through to get to it. We
    can now easily list the orders a product is part of:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasManyThrough` 方法中的第一个参数是目标模型，第二个参数是我们通过它到达的中间模型。现在我们可以轻松地列出产品所属的订单：'
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Polymorphic relations
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态关系
- en: Polymorphic relations are difficult to grasp at first; however, once you have
    an understanding of them, they are really powerful. They allow a model to belong
    to more than one other model on a single association.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 多态关系一开始很难理解；然而，一旦你理解了它们，它们就非常强大。它们允许一个模型在单个关联中属于多个其他模型。
- en: 'A common use case for a polymorphic relationship is to create an image library
    and then allow your other models to contain images by linking to the relevant
    records in the image library table. A base `Image` model will look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 多态关系的一个常见用例是创建一个图像库，然后允许你的其他模型通过链接到图像库表中的相关记录来包含图片。一个基本的`Image`模型看起来像这样：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `morphTo` method is what makes this model polymorphic. Now, in our other
    models, we can create a relation to the `Image` model, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`morphTo`方法使得这个模型成为多态。现在，在我们的其他模型中，我们可以创建一个与`Image`模型的关联，如下所示：'
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can now fetch any related `Image` models through your `Article` model:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过你的`Article`模型获取任何相关的`Image`模型：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may think that this is no different to a one-to-many relationship, but
    the difference becomes apparent when you look at the relation from the other side.
    When retrieving an `Image` instance, if you access the `imageable` relation, you''ll
    receive an instance of whatever model "owns" the image. This may be an `Article`,
    a `Product`, or another model type in your application. Eloquent achieves this
    by not only storing a foreign key value, but also the name of the model class.
    In the case of our `Image` model, the columns would be `imageable_id` and `imageable_type`.
    When creating your migration, there is a method to create these two columns:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这和一对一关系没有区别，但当你从另一边看这个关系时，差异就变得明显了。当你检索一个`Image`实例时，如果你访问`imageable`关系，你会收到一个属于任何“拥有”该图片的模型的实例。这可能是一个`Article`、一个`Product`或者你应用中的另一个模型类型。Eloquent通过不仅存储外键值，还存储模型类名来实现这一点。在我们的`Image`模型的情况下，列将是`imageable_id`和`imageable_type`。在创建迁移时，有一个方法可以创建这两个列：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Many-to-many polymorphic relations
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多多态关系
- en: The final relation type we will look at is the **many-to-many polymorphic relation**,
    by far the most complex. Staying with our image library example, we can see that
    it has one drawback, an `Image` can only belong to one other model at a time.
    So, while we can see all images that have been uploaded by models in our application,
    we can't re-use an uploaded image like we would in a true image library. This
    is where a many-to-many polymorphic relation would come in.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个关系类型是**多对多多态关系**，这是最复杂的。继续我们的图像库示例，我们可以看到它有一个缺点，一个`Image`一次只能属于另一个模型。所以，虽然我们可以看到我们应用中所有模型上传的图片，但我们不能像在真正的图像库中那样重复使用上传的图片。这就是多对多多态关系可以发挥作用的地方。
- en: 'Keeping our `images` and `articles` tables, we need to introduce a third table,
    `imageables`. The relation data is removed from the `images` table, and instead
    placed in this new table, which also has another column that is a foreign key
    pointing to the `Image` primary key. The three columns are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们的`images`和`articles`表，我们需要引入第三个表，`imageables`。关系数据从`images`表中移除，并放置在这个新表中，这个新表还有一个外键列指向`Image`主键。这三个列是：
- en: '`image_id`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_id`'
- en: '`imageable_id`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageable_id`'
- en: '`imageable_type`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageable_type`'
- en: 'With this schema, a single `Image` can have multiple relations. That is, the
    image can be re-used in multiple models, whether that is multiple `Article` records,
    or models of different types. Our updated model classes then take this form:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模式，一个`Image`可以有多个关系。也就是说，图片可以在多个模型中重复使用，无论是多个`Article`记录，还是不同类型的模型。我们的更新后的模型类现在是这样的：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Image` model is also updated, containing methods for each of its relationships:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`模型也被更新，包含其每个关系的操作方法：'
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can still access the `images` relation as with a normal polymorphic relationship.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以像在正常的多态关系一样访问`images`关系。
- en: Model events
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型事件
- en: 'Eloquent fires numerous events at different points, such as when a model is
    being saved or deleted. The following is a list of methods Eloquent models can
    fire:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent在不同的点触发许多事件，例如当模型正在保存或删除时。以下是一个Eloquent模型可以触发的方法列表：
- en: '`creating`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creating`'
- en: '`created`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`'
- en: '`updating`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updating`'
- en: '`updated`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`'
- en: '`saving`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saving`'
- en: '`saved`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saved`'
- en: '`deleting`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleting`'
- en: '`deleted`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleted`'
- en: '`restoring`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restoring`'
- en: '`restored`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restored`'
- en: The names are self-explanatory. The difference in the past and present participles
    is that events such as `creating` are fired *before* the model is created, whereas
    `created` is fired *after* the model has been created. Therefore, if you were
    to halt execution within a handler for the `creating` event, the record will not
    be saved; whereas, if you halted execution within a handler for the `created`
    event, the record would still be persisted to the database.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称是自解释的。过去和现在分词之间的区别在于，例如`creating`这样的事件在模型创建之前触发，而`created`在模型创建之后触发。因此，如果你在`creating`事件的处理器中停止执行，记录将不会被保存；而如果你在`created`事件的处理器中停止执行，记录仍然会被持久化到数据库中。
- en: Registering event listeners
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册事件监听器
- en: 'It''s quite open-ended as to where to register listeners for model events.
    One place is in the `boot` method within the `EventServiceProvider` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常开放，关于在哪里注册模型事件的监听器。一个地方是在`EventServiceProvider`类中的`boot`方法内：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Be sure to import the namespace for the `DispatcherContract` at the top of
    the file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在文件顶部导入`DispatcherContract`命名空间：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Eloquent models provide a method for each event that you can pass an anonymous
    function to. This anonymous function receives an instance of the model that you
    can then act upon. So if you wanted to create a URL-friendly representation of
    an article headline each time your `Article` model was saved, you can do this
    by listening on the saving event:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅的模型为每个事件提供了一个方法，你可以传递一个匿名函数。这个匿名函数接收一个模型的实例，然后你可以对其执行操作。所以如果你想在每次`Article`模型保存时创建一个URL友好的文章标题表示，你可以通过监听保存事件来实现这一点：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Model observers
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型观察者
- en: As you add more and more model event handlers to your `EventServiceProvider`
    class, you may find it becoming overcrowded and difficult to maintain. This is
    where an alternative to handling model events comes into play—model observers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你向`EventServiceProvider`类添加更多的模型事件处理器，你可能会发现它变得越来越拥挤且难以维护。这就是处理模型事件的替代方案——模型观察者。
- en: 'Model observers are standalone classes that you attach to a model, and implement
    methods for as many events as you need to listen out for. So our slug-creating
    function can be re-factored into a model observer as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 模型观察者是独立类，你可以将其附加到模型上，并实现你需要的任何事件的方法。所以我们的slug创建函数可以被重构为模型观察者，如下所示：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then register our observer in our `EventServiceProvider` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`EventServiceProvider`类中注册我们的观察者：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Collections
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Historically, other frameworks that have shipped with their own ORMs and query
    builders have returned result sets as either multidimensional arrays or **Plain
    Old PHP** **Objects** (**POPOs**). Eloquent has taken its cue from other, more
    mature ORMs and instead returns result sets as an instance of a collection object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，其他带有自己ORM和查询构建器的框架返回的结果集要么是多维数组，要么是**普通的PHP对象**（**POPOs**）。Eloquent从其他更成熟的ORM中汲取灵感，而不是返回结果集为集合对象的实例。
- en: The collection object is powerful as it not only contains the data returned
    from the database, but also many helper methods, allowing you to manipulate that
    data before displaying it to the user.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象非常强大，因为它不仅包含从数据库返回的数据，还包含许多辅助方法，允许你在向用户显示之前操纵这些数据。
- en: Checking whether a key exists in a collection
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查集合中是否存在键
- en: 'If you need to find out whether a particular key exists in a collection, you
    can use the `contains` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确定某个特定的键是否存在于集合中，你可以使用`contains`方法：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When querying models, any relations are also returned as subcollections, allowing
    you to use the exact same methods on relations too:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询模型时，任何关系也会作为子集合返回，允许你在关系上使用完全相同的方法：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By default, models return an instance of `Illuminate\Database\Eloquent\Collection`.
    However, this can be overridden to instead use a different class. This is handy
    if we wanted to add additional methods to collections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模型返回`Illuminate\Database\Eloquent\Collection`的实例。然而，这可以被覆盖以使用不同的类。如果我们想向集合添加额外的功能，这会很有用。
- en: 'Say for a collection of roles and we want to determine if administrator is
    one of those roles. If we imagine the administrator role to have a primary key
    value of `1`, we can create a new method, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个角色集合，我们想要确定管理员是否是这些角色之一。如果我们想象管理员角色有一个主键值为`1`，我们可以创建一个新的方法，如下所示：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The second part is to then tell the `Role` model to use our new collection:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是告诉`Role`模型使用我们新的集合：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Instead of instantiating the default Eloquent collection, it will instead create
    a new instance of our `RoleCollection` class, filling it with the results from
    our query. This means that every time we request roles, we can use our new `containsAdmin`
    method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实例化默认的Eloquent集合，它将创建我们`RoleCollection`类的新实例，并用查询结果填充它。这意味着每次我们请求角色时，我们都可以使用我们新的`containsAdmin`方法：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Eloquent collections also have a plethora of other helpful functions for allowing
    you to manipulate, filter, and iterate over items. You can view more information
    on these methods at [http://laravel.com/docs/master/eloquent#collections](http://laravel.com/docs/master/eloquent#collections).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent集合还提供了许多其他有用的功能，允许您操作、过滤和迭代项目。您可以在[http://laravel.com/docs/master/eloquent#collections](http://laravel.com/docs/master/eloquent#collections)查看这些方法的更多信息。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although we have covered a lot in this chapter, Eloquent is so feature-rich
    that unfortunately, there isn't room to cover each and every one of its features.
    We have covered the most important aspects of Eloquent, though, and that will
    set you well on your way to saving and retrieving data, creating relations of
    varying complexity between your models, and handling various events raised during
    your models' lifecycle.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中已经涵盖了大量内容，但Eloquent功能丰富，遗憾的是，没有足够的空间来介绍其每一个特性。不过，我们已经涵盖了Eloquent最重要的方面，这将为您在保存和检索数据、在模型之间创建不同复杂度的关系以及处理模型生命周期中引发的各种事件方面打下坚实的基础。
- en: The next chapter sees us move on to learn all about testing our application
    so it remains as bulletproof as possible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章我们将继续学习如何测试我们的应用程序，以确保其尽可能的坚不可摧。
