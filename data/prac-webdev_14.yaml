- en: Chapter 14. Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 Node.js
- en: 'Congratulations! You have now made it to the final chapter of this book. After
    having gone through most of the technologies used in both classical and modern
    web development, we are now going to discuss the basics of what I would like to
    call the *avant-garde*, excuse my French, of web development: node.js and friends.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经到达了这本书的最后一章。在了解了古典和现代网络开发中使用的多数技术之后，我们现在将讨论我想要称之为网络开发的**前卫**（请原谅我的法语），的基本知识：node.js及其朋友。
- en: 'In everything we discussed so far, we used what is often referred to as the
    **LAMP** (or **MAMP** or **WAMP**, depending on the OS on your server) stack:
    **Linux** **Apache MySQL PHP**. Even when we swap out MySQL for **MongoDB**, the
    acronym still stands. Or we could call it **LANP** with the N of **NoSQL**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止讨论的所有内容中，我们使用了通常所说的**LAMP**（或**MAMP**或**WAMP**，取决于服务器上的操作系统）堆栈：**Linux**
    **Apache MySQL PHP**。即使我们用**MongoDB**替换MySQL，这个缩写仍然适用。或者我们可以称之为**LANP**，其中的N代表**NoSQL**。
- en: 'So we had to learn all these languages: JavaScript on the client side, to be
    interpreted by the browser; PHP, to be interpreted by the Apache web server; and
    many more. Just imagine you could swap out everything, even things you would not
    think of—the web server— in favor of JavaScript? That is what node.js does for
    you. As I, being of a somewhat older generation, see it, node.js did to web development
    what Schoenberg and Webern did to classical music, Picasso and Braque to painting,
    and oh well, why not, Venice Beach rappers to pop music.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须学习所有这些语言：客户端的JavaScript，由浏览器进行解析；PHP，由Apache网络服务器进行解析；还有更多。想象一下，如果你可以替换掉所有东西，甚至是你不会想到替换的东西——网络服务器——而用JavaScript来替代？这正是node.js为你做的事情。在我看来，node.js对网络开发的影响，就像Schoenberg和Webern对古典音乐的影响，Picasso和Braque对绘画的影响，哦，为什么不呢，威尼斯海滩的说唱歌手对流行音乐的影响。
- en: 'There is good news and bad news here. The bad news is that we are at risk of
    having to start everything over again and have learned a lot of things in vain,
    but the good news is that node.js based solutions *perform* well, *scale* well,
    and, for those that come after us, only require the knowledge of a single programming
    language: JavaScript. Acronyms for this are still up for grabs: **LJMJ** or **LNMJ**
    (J for **JavaScript** or N for **node.js** respectively) or **MEN** (**MongoDB**,
    **Express**, **node.js**)? One that is already used a lot is **MEAN**. Over time
    people will agree on one. Who invented the word *cubism*?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有好消息和坏消息。坏消息是我们有重新开始一切并白费很多功夫的风险，但好消息是，基于node.js的解决方案**性能**良好，**可扩展**，对于那些在我们之后的人来说，只需要了解一种编程语言：JavaScript。这个缩写的名称仍然有待确定：**LJMJ**或**LNMJ**（J代表**JavaScript**或N代表**node.js**）或**MEN**（**MongoDB**，**Express**，**node.js**）？已经被广泛使用的一个是**MEAN**。随着时间的推移，人们将达成一致。谁发明了单词**立体主义**？
- en: 'In this chapter, we will make an attempt to repeat everything you have learned
    so far while doing things the node.js way. So we already know in which language
    our code will be written: JavaScript. What we are going to write may come as a
    surprise to you.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将尝试以node.js的方式重复你迄今为止所学的所有内容。所以，我们已经知道我们的代码将用哪种语言编写：JavaScript。我们将要编写的代码可能会让你感到惊讶。
- en: Node.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: Let's recapitulate a bit; in [Chapter 1](ch01.html "Chapter 1. The World Wide
    Web"), *The World Wide Web*, you learned about the World Wide Web and how all
    these millions of pages are accessed by people using a browser that sends requests
    to a web server using the HTTP protocol. Well, people will still use browsers
    that send HTTP requests, but we just tossed the web server, now what do we do?
    We write one. Scary? No, it will be a lot of fun. Writing low-level code is not
    your thing? No sweat, somebody already did it for you. There is a whole community
    writing code for node.js that everybody else can use. That code is made available
    as what is referred to as **modules**, and of course there is a HTTP module available
    to us.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下；在[第1章](ch01.html "第1章。万维网")《万维网》中，你学习了关于万维网以及人们如何通过发送HTTP协议请求到网络服务器的浏览器来访问数百万个页面。嗯，人们仍然会使用发送HTTP请求的浏览器，但我们刚刚丢弃了网络服务器，现在我们该怎么办？我们编写一个。可怕吗？不，这将会非常有趣。编写底层代码不是你的强项？没关系，有人已经为你做了。有一个整个社区正在为node.js编写代码，其他人都可以使用。这些代码被提供为所谓的**模块**，当然，我们也有一个可用的HTTP模块。
- en: Another thing the web server did for us was to actually analyze the URL the
    user typed and explore the **file system** to see whether there is a physical
    file, for example, an `hello.html` file, and serve it up back to the client. We
    will have to write that too. This is cool because it will give us full control
    over what exactly our web server should be able to handle and what it shouldn't.
    As expected, there are `url` and `fs` modules for node.js as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器为我们做的另一件事是分析用户输入的URL，并探索**文件系统**以查看是否存在物理文件，例如，一个`hello.html`文件，并将其发送回客户端。我们也必须编写这个。这很酷，因为它将让我们完全控制我们的Web服务器应该能够处理什么，不应该处理什么。正如预期的那样，node.js也有`url`和`fs`模块。
- en: 'We will need a database but, we already know one that we like: MongoDB. Can
    we use it with node.js? Yes we can. There is a module or driver for it to access
    the existing MongoDB server from node.js. As MongoDB is a document database and
    documents are really JSON objects, this is a perfect fit in an all-JavaScript
    ecosystem.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据库，但我们已经知道我们喜欢的一个：MongoDB。我们能否用node.js使用它？是的，我们可以。有一个模块或驱动程序可以从node.js访问现有的MongoDB服务器。由于MongoDB是一个文档数据库，而文档实际上是JSON对象，所以在全JavaScript生态系统中这是一个完美的匹配。
- en: Little by little we are beginning to realize, before even having written one,
    whether a node application is actually going to be a web server that contains
    application-specific code or an application that contains a web server; take your
    pick.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 逐渐地，我们开始意识到，在写出一个应用之前，这个node应用实际上是要成为一个包含特定代码的web服务器，还是一个包含web服务器的应用；任你选择。
- en: As soon as I walk you through our first examples, you will realize that we never
    before had a need to write so much code for a simple `Hello, World` program. Imagine
    having to write a fully-featured single page web application with so much low-level
    code? This is where *Express* fits in. It is a framework for node.js that will
    help us write cleaner, more compact code. This is our jQuery on the server side.
    As soon as our examples become too boringly long, we will switch to Express.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我带你通过我们的第一个示例时，你就会意识到我们以前从未需要为简单的`Hello, World`程序编写这么多代码。想象一下，如果需要用这么多底层代码编写一个功能齐全的单页Web应用会怎样？这正是*Express*发挥作用的地方。它是一个node.js框架，将帮助我们编写更干净、更紧凑的代码。这是服务器端的jQuery。一旦我们的示例变得过于冗长，我们就会切换到Express。
- en: 'There is another thing we tossed: Apache as an **Application Server**, the
    part that gave us PHP as a language on the server. We have been generating HTML
    dynamically on the server using PHP and, by the time the browser read it, it had
    become all HTML.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还丢弃了另一件事：Apache作为一个**应用服务器**，这部分让我们在服务器上有了PHP语言。我们一直使用PHP在服务器上动态生成HTML，等到浏览器读取时，它已经变成了全部的HTML。
- en: The nice part of using PHP was that we could embed PHP code inside plain HTML
    in between `<?php` and `?>`. Stuffing an HTML file with `<script>` tags to include
    JavaScript code is not very appealing. We will look at a solution for that as
    well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的好处是，我们可以在纯HTML中嵌入PHP代码，在`<?php`和`?>`之间。用`<script>`标签填充HTML文件以包含JavaScript代码并不吸引人。我们也会看看这个问题的解决方案。
- en: Installing node.js
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装node.js
- en: 'Let''s not delay any further and install node on your computer. How to install
    it will be different depending on the OS you are running. Go to [http://nodejs.org/](http://nodejs.org/)
    and get the proper download. The result is the same everywhere: it gives us two
    programs: **node** and **npm**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再拖延，现在就在你的电脑上安装node。安装方式会根据你运行的操作系统而有所不同。访问[http://nodejs.org/](http://nodejs.org/)并获取正确的下载。结果在所有地方都是一样的：它给了我们两个程序：**node**和**npm**。
- en: npm
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: npm
- en: 'npm, the **node packaging manager**, is the tool that you use to look for and
    install modules. Each time you write code that needs a module, you specify this
    by putting something like the following in your code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: npm，**node打包管理器**，是您用来查找和安装模块的工具。每次您编写需要模块的代码时，您可以通过在代码中放入类似以下内容来指定：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It will have to be installed if it is not yet present, using the command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装，需要使用以下命令进行安装：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or you can also use:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以使用：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The latter will attempt to install the module globally, the former command in
    the directory where the command is issued. It will typically install the module
    in a folder called **node_modules**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 后者会尝试在全局范围内安装模块，前者在命令执行的目录中安装模块。它通常会在名为**node_modules**的文件夹中安装模块。
- en: node
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: node
- en: 'The `node` command is the command to use to start your node.js program, for
    example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`node`命令是用来启动你的node.js程序的命令，例如：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Node will start and interpret your code. Type *Ctrl* + *C* to stop node. Let's
    get to our first programs right away.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node 将启动并解释你的代码。输入 *Ctrl* + *C* 来停止 node。让我们立即开始我们的第一个程序。
- en: 'Our inevitable `Hello, world` example is the smallest possible web server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可避免的 `Hello, world` 示例是最小的可能网络服务器：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save this file as `hello.js`, or get it from the Packt Publishing website and,
    in a terminal window, type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `hello.js`，或者从 Packt Publishing 网站获取，然后在终端窗口中输入：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will run the program using `node`. In the terminal window, which
    becomes your console, you will see the text `Server running`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用 `node` 运行程序。在终端窗口中，它将成为你的控制台，你会看到文本 `Server running`。
- en: Next, when you start a browser and type in `http://localhost:8080` as the URL,
    something that looks like a web page, containing the famous two-word sentence
    `Hello World`, will appear. As a matter of fact, if you go to `http://localhost:8080/it/does/not/matterwhat`,
    the same thing will appear. Not very useful maybe, but it is a web server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当你启动浏览器并输入 `http://localhost:8080` 作为 URL 时，会出现一个看起来像网页的东西，包含著名的两字句子 `Hello
    World`。实际上，如果你访问 `http://localhost:8080/it/does/not/matterwhat`，会出现相同的内容。可能不是非常有用，但它是一个网络服务器。
- en: Adding HTML
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 HTML
- en: 'This is a slightly different version where we explicitly specify that we send
    HTML instead of plain text:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个略有不同的版本，我们明确指定发送 HTML 而不是纯文本：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Serving up static content
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供静态内容
- en: We are not used to the same thing popping up no matter what path we give as
    an URL. URLs typically point to a file (or a folder, in which case the server
    looks for an `index.html` file), `foo.html` or `bar.php`, and, when present, it
    is served up to the client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不习惯无论我们给出什么路径作为 URL，都会出现相同的内容。通常，URL 指向一个文件（或一个文件夹，在这种情况下，服务器会查找 `index.html`
    文件），`foo.html` 或 `bar.php`，并且当存在时，它会被提供给客户端。
- en: 'So what if we want to do this with node.js? We need a module. There are several
    ways to do the job. We use `node-static` in our example. First we need to install
    it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想用 node.js 来做这个呢？我们需要一个模块。有几种方法可以完成这项工作。在我们的例子中，我们使用 `node-static`。首先，我们需要安装它：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can typically find documentation on methods and properties on Github and
    other cool places. In our app, we create not only a web server but a `fileserver`
    as well. It will serve all the files in the local directory `public`. It is good
    to have all so called `static content` together in a separate folder. This is
    basically all the files that will be served up to and interpreted by the client.
    As we will now end up with a mix of client code and server code, it is good practice
    to separate them. When you use the Express framework, it will create these things
    for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以在 Github 和其他酷炫的地方找到关于方法和属性的帮助文档。在我们的应用程序中，我们不仅创建了一个网络服务器，还创建了一个 `fileserver`。它将为本地目录
    `public` 中的所有文件提供服务。将所有所谓的 `静态内容` 放在一起，放在一个单独的文件夹中是很好的。这基本上是所有将被客户端接收并解释的文件。由于我们最终会得到客户端代码和服务器代码的混合，因此将它们分开是一种良好的实践。当你使用
    Express 框架时，它会为你创建这些。
- en: 'In our project folder we create `hello.js`, our node.js app:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目文件夹中创建 `hello.js`，我们的 node.js 应用程序：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, in a subfolder `public`, we create `hello.html`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在子文件夹 `public` 中，我们创建 `hello.html`：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can create the background with `hello.css` as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `hello.css` 创建背景，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So if we now visit `http://localhost:8080/hello.html`, we will see our by now
    too familiar `Hello World` message with some basic styling, proving that our file
    server also delivered the CSS file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在访问 `http://localhost:8080/hello.html`，我们将看到我们至今仍然熟悉的 `Hello World`
    消息，并带有一些基本的样式，这证明了我们的文件服务器也传递了 CSS 文件。
- en: Now we will take it one step further by actually adding JavaScript to our html
    file (`hellobutton.html` (body only)). We will reuse the previous CSS file, create
    a slightly different HTML file, and add a JavaScript file. I assume you have a
    copy of jQuery around somewhere.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将更进一步，实际上在我们的 html 文件（`hellobutton.html`，仅 body 部分）中添加 JavaScript。我们将重用之前的
    CSS 文件，创建一个略有不同的 HTML 文件，并添加一个 JavaScript 文件。我假设你 somewhere 有一个 jQuery 的副本。
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To add the button, let''s create `hellobutton.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加按钮，让我们创建 `hellobutton.js`：
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So when we go to `http://localhost:8080/hellobutton.html`, we see a web page
    with a button; when we click on it, its text changes into `Hello World`. This
    means our client-side jQuery and JavaScript works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们访问 `http://localhost:8080/hellobutton.html` 时，我们会看到一个带有按钮的网页；当我们点击它时，其文本变为
    `Hello World`。这意味着我们的客户端 jQuery 和 JavaScript 正在正常工作。
- en: 'In the `public` folder, create a file `index.html`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `public` 文件夹中，创建一个文件 `index.html`：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we go to `http://localhost:8080`, we see *It Works !* Just like when we hit
    the document root of the Apache Web Server. This is because our `node-static`
    module has that file configured as the default.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问`http://localhost:8080`，我们会看到*It Works !* 就像我们点击Apache Web服务器的文档根目录一样。这是因为我们的`node-static`模块已经将这个文件配置为默认。
- en: But there are other things that do not work the way we are used to. If we type
    `hellobutton` instead of `hellobutton.html`, nothing will happen, as we did not
    program our web server to look for `hellobutton.something`. Don't even think of
    wanting to process `hello.html?key=value`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，还有一些事情我们没有习惯的方式工作。如果我们输入`hellobutton`而不是`hellobutton.html`，什么也不会发生，因为我们没有编程我们的Web服务器去寻找`hellobutton.something`。甚至不要想处理`hello.html?key=value`。
- en: On the other hand, if you put a picture file, for example, `baywatchstation.jpg`,
    in `./public` and type `http://localhost:8080/baywatchstation.jpg`, you will see
    the picture in your browser. All this is done with very few lines of code and
    two cool node.js modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你在`./public`中放置一个图片文件，例如`baywatchstation.jpg`，并输入`http://localhost:8080/baywatchstation.jpg`，你将在你的浏览器中看到这张图片。所有这些操作只需要很少的代码和两个酷炫的node.js模块。
- en: A tale of two (JavaScript) cities
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个（JavaScript）城市的传说
- en: 'We have reached an important stage here: we have two different JavaScript files,
    they are both located on our server, but one is interpreted by node.js and the
    other one is served up by node.js and interpreted by the browser, in other words
    the client.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了一个重要的阶段：我们有两个不同的JavaScript文件，它们都位于我们的服务器上，但一个是通过node.js解释的，另一个则是由node.js提供并由浏览器解释的，换句话说，是客户端。
- en: 'Try this: `http://localhost:8080/js/hellobutton.js`. You will see the code
    of your JavaScript file in a browser. Now insert `alert("Here''s Johnny!");` and
    put `<script>` tags around it, save it, and refresh your browser. `Johnny` pops
    up and then JavaScript continues with doing nothing without giving you any error
    message.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这个：`http://localhost:8080/js/hellobutton.js`。你将在浏览器中看到你的JavaScript文件的代码。现在插入`alert("Here's
    Johnny!");`并将其放在`<script>`标签中，保存并刷新浏览器。`Johnny`会出现，然后JavaScript什么也不做，不会给你任何错误信息。
- en: Because we configured `public` (well `node-static` did) as our document root
    of our mini web server, we cannot even reach `hello.js`, rescuing us from potentially
    greater confusion. I am confident that by now you understand the difference between
    a JavaScript file and a JavaScript file. That is why some developers have developed
    a habit of using different extensions (for example `.njs` for server-side JS files).
    I believe it is a lot clearer to place the different kinds of files in different
    folders as we have started doing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经将`public`（好吧，是`node-static`）配置为我们的迷你Web服务器的文档根目录，所以我们甚至无法访问`hello.js`，这使我们免于更大的困惑。我确信到现在你已经理解了JavaScript文件和JavaScript文件之间的区别。这就是为什么一些开发者养成了使用不同扩展名（例如`.njs`用于服务器端JS文件）的习惯。我相信，像我们开始做的那样，将不同类型的文件放在不同的文件夹中要清晰得多。
- en: 'But, so far, in such a short time, and just a few lines of code, we are capable
    of doing almost anything we discussed in this book up until now, the node.js way:
    we can handle HTML, CSS, JavaScript, and jQuery. We tossed PHP and we are replacing
    MySQL with MongoDB. This leaves us just with the latter and Ajax and then we will
    have, in a way, rewritten our book the node.js way.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，到目前为止，在这么短的时间内，仅仅几行代码，我们就能够用node.js的方式做到我们在这本书中讨论的几乎所有事情：我们可以处理HTML、CSS、JavaScript和jQuery。我们放弃了PHP，并用MongoDB替换了MySQL。这让我们只剩下后者和Ajax，然后我们就可以用node.js的方式重写我们的书了。
- en: node.js and MongoDB
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: node.js和MongoDB
- en: 'In [Chapter 11](ch11.html "Chapter 11. MongoDB"), *MongoDB*, we introduced
    MongoDB, a document database, and you learned how to access it from the command
    line as well as from within a PHP program. Doing so in node.js is even easier.
    First of all, let''s not forget to start the MongoDB server inside a separate
    terminal window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。MongoDB")中，我们介绍了MongoDB，一个文档数据库，并学习了如何从命令行以及PHP程序内部访问它。在node.js中这样做甚至更容易。首先，让我们不要忘记在一个单独的终端窗口中启动MongoDB服务器：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we need, of course, a node.js module, `mongodb`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们当然需要一个node.js模块，`mongodb`：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here follows a simple program that connects to the MongoDB server, the `california`
    database to be precise, and looks up a document in the `people` collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的程序，它连接到MongoDB服务器，具体来说是`california`数据库，并在`people`集合中查找一个文档。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Déjà vu … once more
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Déjà vu … 再次
- en: 'As I went through my first steps with node.js, I had a déjà vu experience.
    To paraphrase the Grace Jones song based on *Libertango* by Astor Piazolla: *Strange,
    I have seen that happen before*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始使用node.js时，我有一种似曾相识的感觉。用Grace Jones基于Astor Piazolla的《Libertango》改编的歌曲来比喻：*奇怪，我以前见过这种情况*。
- en: With node.js, you only add what you need, so it does not include the kitchen
    sink by default. This can only mean you will benefit from that as far as performance
    goes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用node.js，你只需添加你需要的东西，所以它默认不包括厨房用具。这只能意味着你在性能方面会从中受益。
- en: I am a UNIX person but this story goes back to when Linus had not yet rewritten
    it as Linux, Mac OS X did not exist yet, and so on. Memory and disk space were
    expensive, so was UNIX, as manufacturers had to pay royalties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个UNIX用户，但这个故事要追溯到当Linus还没有将其重写为Linux，Mac OS X还不存在的时候。内存和磁盘空间都很昂贵，UNIX也是如此，因为制造商必须支付版税。
- en: I was a proud product manager of a PC UNIX product and one of our coolest value-added
    things was a tool called **kconfig**, which would allow people to customize what
    was inside the UNIX kernel, so it would only contain what was needed. This is
    what node.js reminds me of. And it is written in C, just like UNIX. *Déjà vu*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经是PC UNIX产品的自豪的产品经理，我们最酷的价值增值之一是一个名为**kconfig**的工具，它允许人们自定义UNIX内核中的内容，使其只包含所需的内容。这就是node.js让我想起来的。而且它是用C语言编写的，就像UNIX一样。*似曾相识*。
- en: 'Cool as it was then, it would not be cool today, because so much more has been
    added to UNIX: it would not be manageable.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当时很酷，但今天就不会那么酷了，因为UNIX已经添加了太多东西：它将无法管理。
- en: 'The same is true if we wanted to mimic everything the Apache web server can
    handle with pure node.js. Just look at the output of the PHP `phpinfo()` function.
    It shows all the modules that are loaded into Apache. If we wanted to support
    all these with with only node.js, we would need too many modules and would end
    up with unreadable code. The movie Amadeus comes to mind, where the emperor''s
    sidekicks agree on one thing about Mozart''s *Le Nozze di Figaro* (I don''t):
    Too many notes!'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用纯node.js来模拟Apache网络服务器能处理的所有功能，也是同样的道理。只需看看PHP的`phpinfo()`函数的输出。它显示了所有加载到Apache中的模块。如果我们想只用node.js支持所有这些，我们需要太多的模块，最终代码将难以阅读。电影《莫扎特传》中的场景浮现在脑海中，皇帝的随从们对莫扎特的《费加罗的婚礼》达成一致意见（我不这么认为）：音符太多！
- en: Express
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express
- en: A good way to get the job done with fewer notes is by using the Express framework.
    On the [expressjs.com](http://expressjs.com) website, it is called a *minimal
    and flexible node.js web application framework, providing a robust set of features
    for building web applications*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express框架是完成工作而无需过多笔记的好方法。在[expressjs.com](http://expressjs.com)网站上，它被称为*最小和灵活的node.js网络应用程序框架，提供了一套强大的功能，用于构建网络应用程序*。
- en: There probably is no better way to describe what Express can do for you. It
    is minimal so there is little overhead for the framework itself. It is flexible,
    so you can add just what you need. As it gives a robust set of features, this
    means you do not have to create them yourselves and they have been tested by an
    ever-growing community.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 描述Express能为你做什么的最好方法可能没有。它是最小的，因此框架本身的开销很小。它是灵活的，因此你可以添加你需要的东西。因为它提供了一套强大的功能，这意味着你不必自己创建它们，而且它们已经由不断增长的社区进行了测试。
- en: Installing Express
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Express
- en: 'Of course, Express is also a node module, so we install it as such. At the
    time of writing, we used **Express 4**. In your project directory for your application,
    type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Express也是一个node模块，所以我们像安装模块一样安装它。在撰写本文时，我们使用了**Express 4**。在你的应用程序项目目录中，输入：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or you can also use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以使用：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you specify the `—save` option, `npm` will update the `package.json` file.
    You will notice that a folder called `express` will be created inside `node_modules`
    and inside that one there is another collection of node-modules. These are examples
    of what is called **middleware**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了`—save`选项，`npm`将会更新`package.json`文件。你会注意到在`node_modules`内部会创建一个名为`express`的文件夹，并在其中还有一个node-modules的集合。这些都是被称为**中间件**的例子。
- en: In the few examples that follow, we assume app.js as the name for your node.js
    application and `app` for the variable that you will use in that file for your
    instance of Express. This is for the sake of brevity. It would be better to use
    a string that matches your project name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子中，我们假设`app.js`是你的node.js应用程序的名称，`app`是你在该文件中使用的变量，用于Express的实例。这样做是为了简洁。最好使用一个与你的项目名称匹配的字符串。
- en: Our first Express app
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个Express应用程序
- en: 'Of course, we are going to do more `Hello, World` examples. Here is our first
    Express app:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还将进行更多的 `Hello, World` 示例。这是我们第一个 Express 应用程序：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Well, compared to our second node.js example, it is about the same number of
    lines. But it looks a lot cleaner and it does more for us. You no longer need
    to explicitly include the HTTP module, you no longer have to specify which header
    to send, and, when you specify a different URL, you will not get `Hello, World`
    but a reasonable error message. We use `app.set` and `app.get` for the port. When
    the environment variable `PORT` is set, the port will be set to its value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，与我们的第二个 node.js 示例相比，行数差不多。但它看起来干净得多，而且为我们做了更多。你不再需要显式包含 HTTP 模块，你也不再需要指定要发送哪个头，而且当你指定不同的
    URL 时，你不会得到 `Hello, World`，而是一个合理的错误消息。我们使用 `app.set` 和 `app.get` 来设置端口。当环境变量
    `PORT` 被设置时，端口将被设置为它的值。
- en: The other line containing `app.get` tells us what we want to happen when the
    server is presented with a URL in the `GET` mode. Like in node.js, there is a
    function with the `request` and `respond` objects as an argument. In `express`,
    they have been extended; there are more creative things you can do with them as
    there are more methods available to you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `app.get` 的另一行告诉我们，当服务器接收到 `GET` 模式下的 URL 时，我们希望发生什么。就像在 node.js 中一样，有一个以
    `request` 和 `respond` 对象为参数的函数。在 `express` 中，它们被扩展了；你可以用它们做更多创造性的事情，因为你可以使用更多方法。
- en: For example, you have access to `req.body`, which will contain an object of
    all the values that were sent using the `POST` method in a form (using `app.post`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以访问 `req.body`，它将包含一个对象，包含使用 `POST` 方法在表单中发送的所有值（使用 `app.post`）。
- en: An example with middleware
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个使用中间件的示例
- en: 'We will now use Express to rewrite the `hello button` example. All static resources
    in the `public` directory can remain untouched. The only change is in the node
    `app` itself:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Express 重写 `hello button` 示例。`public` 目录中的所有静态资源都可以保持不变。唯一的变化是在节点 `app`
    本身：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code uses so-called middleware (`static`) that is included with `express`.
    There is a lot more available from third parties. In the `req.body` referenced
    earlier, there is middleware available to parse that form data (`body-parse`).
    You can also write your own middleware. In its simplest form, it is a function
    with `req` and `res` as its arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了与 `express` 一起提供的所谓中间件（`static`）。第三方提供了更多。在前面提到的 `req.body` 中，有可用的中间件来解析表单数据（`body-parse`）。你也可以编写自己的中间件。在其最简单的形式中，它是一个以
    `req` 和 `res` 为参数的函数：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is your minimal 404 handler to give people something meaningful to read
    on their screen when they type in the wrong URL. You place that in your app.js
    file after the code that represents the successful scenarios.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的最小 404 处理器，当人们输入错误的 URL 时，你可以给他们一些有意义的内容在屏幕上阅读。你将这个放在你的 app.js 文件中，在代表成功场景的代码之后。
- en: Templating and handlebars.js
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板和 handlebars.js
- en: There is one more `Hello, world` example to go! Throughout the book, we have
    been using PHP most of the time. We have used it to dynamically generate web pages,
    or portions thereof. So PHP code, often embedded inside HTML code in a file with
    `.php` as an extension, is executed on the server and what is rendered by the
    browser is pure HTML. You also learned how to generate HTML from a separate PHP
    file or even JavaScript on the client side, using data that comes from the server,
    and then inject it into a portion of a web page (Ajax).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个 `Hello, world` 示例要展示！在整本书中，我们大部分时间都在使用 PHP。我们用它来动态生成网页，或者网页的一部分。所以 PHP
    代码，通常嵌入到以 `.php` 为扩展名的文件中的 HTML 代码中，在服务器上执行，浏览器渲染的是纯 HTML。你也学习了如何从单独的 PHP 文件或客户端的
    JavaScript 中生成 HTML，使用来自服务器的数据，然后将它注入到网页的一部分（Ajax）中。
- en: Combining PHP and HTML and even a small chunk of client-side JavaScript inside
    a single file was made possible thanks to the `<script>` tag and by putting PHP
    code in between `<?php` and `?>`. That is why they sometimes call PHP a *templating*
    language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `<script>` 标签和将 PHP 代码放在 `<?php` 和 `?>` 之间，将 PHP 和 HTML 以及甚至一小块客户端 JavaScript
    结合在一个文件中成为可能。这就是为什么他们有时把 PHP 称为 *模板* 语言。
- en: Now imagine an all-JavaScript ecosystem. Yes, we could still put our client
    JavaScript code in between `<script>` tags, but what about the server JavaScript
    code? There is no such thing as `<?javascript ?>` because this is not how node.js
    works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个全部由 JavaScript 构成的生态系统。是的，我们仍然可以将客户端 JavaScript 代码放在 `<script>` 标签之间，但服务器端的
    JavaScript 代码怎么办？没有 `<?javascript ?>` 这样的东西，因为这不是 node.js 的工作方式。
- en: Node.js and Express support several templating languages that allow you to separate
    layout and content and have the template system do the work to go fetch the content
    and inject it into the HTML. As we no longer want to learn yet another language,
    we decided to go with **handlebars.js**, as it uses plain HTML to define your
    layout, that you already learned some 12 chapters ago. The default templating
    language for Express appears to be **Jade**, which uses its own, albeit more compact,
    because there are no tags, format. Another advantage of using handlebars.js is
    that is also available to do client-side templating.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和Express支持多种模板语言，这些语言允许你分离布局和内容，并由模板系统完成获取内容并将其注入HTML的工作。由于我们不再想学习另一种语言，我们决定选择**handlebars.js**，因为它使用你已经在12章前学过的纯HTML来定义布局。Express的默认模板语言似乎是**Jade**，它使用自己的、尽管更紧凑的、因为没有标签的格式。使用handlebars.js的另一个优点是它也支持客户端模板。
- en: We conclude this chapter with an example of how you could use handlebars.js.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个如何使用handlebars.js的示例来结束本章。
- en: Our examples in this chapter are all node.js examples, for which we need modules.
    To use handlebars in node and Express, there are several modules available. I
    like the one with the easy to remember name **express-handlebars**. If you search
    the web for handlebars.js, you will find the library to do client-side templating.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都是node.js示例，我们需要使用模块。要在node和Express中使用handlebars，有几个模块可供选择。我喜欢名字容易记住的**express-handlebars**。如果你在网上搜索handlebars.js，你会找到用于客户端模板的库。
- en: 'Get the `handlebars` module for Express using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令为Express获取`handlebars`模块：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a layout
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建布局
- en: 'Inside your project folder that contains `public`, create a folder `views`,
    with a subdirectory `layouts`. Copy other static content you may have from `public`
    to `views`. Inside the `layouts` subfolder, create a file called `main.handlebars`.
    This is your default layout. Think of it as a common layout for almost all of
    your pages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`public`的项目文件夹内，创建一个名为`views`的文件夹，并在其中创建一个名为`layouts`的子目录。将`public`中可能有的其他静态内容复制到`views`中。在`layouts`子文件夹内，创建一个名为`main.handlebars`的文件。这是你的默认布局。把它想象成几乎所有页面的通用布局：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice the `{{{body}}}` part. This token will be replaced by HTML. Create,
    in the `views` folder, a file called `hello.handlebars` with the following content.
    This will be one (of many) example of the HTML, and it will be replaced by:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`{{{body}}}`部分。这个标记将被HTML替换。在`views`文件夹中创建一个名为`hello.handlebars`的文件，内容如下。这将是一个（许多）HTML示例之一，它将被替换为：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our last Hello, World example
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们最后的Hello, World示例
- en: 'Now create a file `lasthello.js` in the project folder. For convenience, we
    added the relevant code to the previous Express example. Everything that worked
    before still works but if you type `http://localhost:3000/`, you will see a page
    with the layout from the layout file and `{{{body}}}` replaced by(you guessed
    it):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在项目文件夹中创建一个名为`lasthello.js`的文件。为了方便，我们在之前的Express示例中添加了相关代码。之前所有工作正常，但如果你输入`http://localhost:3000/`，你会看到一个页面，其中包含布局文件中的布局，并且`{{{body}}}`被替换为（你猜对了）：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we gave an overview of node.js and Express. Thanks to
    node.js, you can use JavaScript across the board, on both the client and server
    side. You can even write your own web server with just a few lines of code. As
    you only include the things you really need, you can obtain far better performance
    with this *avant-garde* way of doing web development.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们概述了node.js和Express。得益于node.js，你可以在客户端和服务器端全面使用JavaScript。你甚至可以用几行代码就编写自己的网络服务器。因为你只包含真正需要的东西，所以你可以通过这种*前卫*的网页开发方式获得更好的性能。
- en: 'As you combine the web server and the server application in your code, there
    may be more code to write than you wish for. That is where Express comes to the
    rescue: a lightweight framework that results in more compact, yet robust code.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中将网络服务器和服务器应用程序结合起来时，可能需要编写的代码比你预期的要多。这时Express就派上用场了：一个轻量级的框架，它生成的代码既紧凑又健壮。
- en: To conclude, we touched on the tip of the templating iceberg by introducing
    handlebars.js. This is a better way to separate layout from dynamic content and
    have the framework combine the two, so the browser can render it as a view. For
    that purpose, we concluded the chapter by writing a layout in HTML.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们通过介绍handlebars.js触及了模板冰山的一角。这是一种更好的方法来分离布局和动态内容，让框架将它们结合起来，以便浏览器可以将其渲染为视图。为此，我们通过编写HTML布局来结束本章。
- en: 'This reminds me of Anna Russell''s rendition of Wagner''s *Der Ring des Nibelungen*,
    which she does in 20 minutes (normally the Ring is 16 hours) concluding that the
    story ends the way it started. It goes a little bit like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了安娜·拉塞尔对瓦格纳的*尼伯龙根的指环*的演绎，她用20分钟完成了（通常《指环》需要16小时），结论是故事以它开始的方式结束。它有点像这样：
- en: '*There is the Rhine, in the river there are the Rhinemaidens and at the bottom
    there is ... gold …*'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这里有莱茵河，河里有莱茵河女神，河底有……金子……*'
- en: 'So, after 14 chapters that took us through many aspects of web development
    we ended where it all started: HTML. I hope you enjoyed reading it as much as
    I did writing it.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过14章，我们了解了网络开发的许多方面，我们回到了一切开始的地方：HTML。我希望你们阅读它的时候和我写作它的时候一样享受。
