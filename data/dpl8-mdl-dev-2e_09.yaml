- en: Custom Fields
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义字段
- en: In [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entities and Plugin Types,* we talked quite extensively about content entities
    and how they use fields to store the actual data that they are supposed to represent.
    Then, we saw how these fields, apart from interacting with the storage layer for
    persisting it, extend Typed Data API classes in order to organize this data better
    at the code level. For example, we saw that the `BaseFieldDefinition` instances
    used on entities are actually data definitions (and so are the `FieldConfig` ones).
    Moreover, we also saw the DataType plugins at play there, namely the `FieldItemList`
    with their individual items, which down the line extend a basic DataType plugin
    (`Map` in most cases). Also, if you remember, when we were talking about these
    items, I mentioned how they are actually instances of yet another plugin—`FieldType`.
    So essentially, they are a plugin type whose plugins extend plugins of another
    type. I recommend that you revisit that section if you are fuzzy on the matter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)《数据建模和存储》和[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)《您的自定义实体和插件类型》中，我们广泛地讨论了内容实体以及它们如何使用字段来存储它们应该表示的实际数据。然后，我们看到了这些字段如何除了与存储层交互以持久化数据之外，还扩展了Typed
    Data API类，以便在代码级别更好地组织这些数据。例如，我们看到了在实体上使用的`BaseFieldDefinition`实例实际上是数据定义（`FieldConfig`也是）。此外，我们还看到了起作用的DataType插件，即`FieldItemList`及其各自的项，这些项最终扩展了一个基本的DataType插件（在大多数情况下是`Map`）。此外，如果你还记得，当我们讨论这些项时，我提到了它们实际上是另一种插件的实例——`FieldType`。所以本质上，它们是一种插件类型，其插件扩展了另一种类型的插件。我建议如果你对此事不太清楚，请重新阅读那一节。
- en: Most of these concepts are buried inside the Entity API and are only seen and
    understood by developers. However, the `FieldType` plugins (together with their
    corresponding `FieldWidget` and `FieldFormatter` plugins) break out and are one
    of the principal things site builders and content editors actually work with in
    the UI. They allow users to input structured data and save it to the database.
    If you recall, I mentioned them a few times in Chapters 6 and 7, and I promised
    you a chapter in which we will see how we can create field types that a site builder
    can then add to an entity type and use to input data. Well, this is that chapter,
    but first, let's do a quick recap on what we know about them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念中的大多数都隐藏在实体API内部，只有开发人员才能看到和理解。然而，`FieldType`插件（以及它们对应的`FieldWidget`和`FieldFormatter`插件）脱颖而出，是网站构建者和内容编辑人员在UI中实际操作的主要事物之一。它们允许用户输入结构化数据并将其保存到数据库中。如果你还记得，我在第6章和第7章中提到了它们几次，并承诺会有一章介绍我们如何创建网站构建者可以添加到实体类型并用于输入数据的字段类型。好吧，这就是那一章，但首先，让我们快速回顾一下我们对它们的了解。
- en: A recap of Field type plugins
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段类型插件回顾
- en: Field type plugins extend the lower-level TypedData API to create a unique way
    of not only representing data (within the context of entities), but also storing
    it to the database (and other stuff as well). They are primarily known as the
    type of fields site builders can add to an entity type bundle. For example a plain
    text field or a select list with multiple options. Nothing can be more common
    than that in a CMS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 字段类型插件扩展了低级别的TypedData API，以创建一种独特的方式，不仅表示数据（在实体的上下文中），而且将其存储到数据库中（以及其他一些内容）。它们主要被用作网站构建者可以添加到实体类型包中的字段类型。例如，一个纯文本字段或具有多个选项的选择列表。在CMS中，没有什么比这更常见了。
- en: 'However, they are also used as entity base field types. If you remember our
    product entity type''s `name` field definition, we actually did use these plugin
    types:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们也被用作实体基本字段类型。如果你还记得我们的产品实体类型的`name`字段定义，我们实际上确实使用了这些插件类型：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `create()` method of the definition class accepts a `FieldType` plugin ID.
    Also, the `type` of the `view` display option provided a bit below in the code
    is a `FieldFormatter` plugin ID, whereas the `type` of the `form` display option
    provided even lower in the code is a `FieldWidget` plugin ID.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的`create()`方法接受一个`FieldType`插件ID。此外，下面代码中提供的`view`显示选项的`type`是一个`FieldFormatter`插件ID，而下面代码中提供的`form`显示选项的`type`是一个`FieldWidget`插件ID。
- en: 'A crucial lesson from this recap that I insist you retain: when defining your
    custom entities, think about the types of fields you need. If there are bundles
    that need to have different sets of fields, configurable fields are your choice.
    Otherwise, base fields are perhaps more appropriate. They sit tightly with your
    Entity type class, appear on all bundles (if that''s something you need), and
    encourage you to explore the Drupal code base and understand the existing field
    types, widgets, and formatters better (as well as relevant settings they come
    with).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个回顾中，我坚持要你记住的一个关键教训：当你定义自定义实体时，要考虑你需要哪些类型的字段。如果有需要不同字段集的捆绑包，可配置字段是你的选择。否则，基础字段可能更合适。它们紧密地与你的实体类型类相关联，出现在所有捆绑包上（如果你需要的话），并鼓励你探索Drupal代码库，更好地理解现有的字段类型、小部件和格式化器（以及它们附带的相关设置）。
- en: Also, when you define base fields, think the same way as you would if adding
    them through the UI—which field type do I want (find a `FieldType` plugin), how
    do I want users to interact with it (find a `FieldWidget` plugin), and how do
    I want its values to be shown (find a `FieldFormatter` plugin). Then, inspect
    the relevant classes to determine the right settings that will go with them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你定义基础字段时，要以你通过UI添加它们的方式相同地思考——我想使用哪种字段类型（找到一个`FieldType`插件），我希望用户如何与之交互（找到一个`FieldWidget`插件），以及我希望如何显示其值（找到一个`FieldFormatter`插件）。然后，检查相关的类以确定将与之一起使用的正确设置。
- en: 'In this chapter, we will take a look at how we can create our own custom field
    type with its own default widget and formatter. To provide a bit of continuity,
    I am going to ask you to think back to the more complex example we used when talking
    about the TypedData API—the license plate. We will create a field type designed
    specifically to store license plates in the following format: *CODE NUMBER* (just
    as we saw with the example New York plate). Why?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何创建我们自己的自定义字段类型，包括其默认的小部件和格式化器。为了保持一定的连贯性，我将要求你回顾我们在讨论TypedData API时使用的更复杂的例子——车牌。我们将创建一个专门用于存储车牌的字段类型，其格式如下：*代码编号*（正如我们在纽约车牌的例子中所见）。为什么？
- en: At the moment, there is no field type that can represent this accurately. Of
    course, we have the simple text field, but that implies having to add both pieces
    of data that make up a license plate into the same field, stripping them of its
    meaning. When we were discussing the TypedData API, we saw that one of its core
    principles is the ability to apply meaning to a piece of data so as to understand
    that `$license_plate` (for example) is actually a license plate from which we
    can ask its code and its number (as well as a general description if we want to).
    Similar to this (or actually building on top of this), fields are also about storing
    this data. So, apart from understanding it in code, we also need to persist it
    in the same way. That is, placing the individual pieces of data in separate meaningful
    table columns in order to also persist that meaning.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，还没有字段类型能够准确表示这一点。当然，我们有简单的文本字段，但这意味着必须将构成车牌的两个数据部分都添加到同一个字段中，从而剥夺了它们的意义。当我们讨论TypedData
    API时，我们看到了其核心原则之一就是能够将意义应用于数据片段，以便理解`$license_plate`（例如）实际上是一张车牌，我们可以从中获取其代码和编号（以及如果我们想的话，一个一般性的描述）。类似于这一点（或者实际上是在这一点之上构建的），字段也是关于存储这些数据的。因此，除了在代码中理解它之外，我们还需要以相同的方式持久化它。也就是说，将单个数据片段放置在具有意义的单独表列中，以便也持久化那种意义。
- en: An example from Drupal core that does the same thing is the `Text (formatted)`
    field. Apart from its string value, this field also stores a format for each value,
    which is used upon rendering. Without that format, the string value loses its
    meaning, and Drupal is no longer able to reliably render it in the way it was
    intended upon creation. So you can now see that fields take the idea of *meaning*
    from TypedData and also apply it to storage as needed. So, in this chapter, you
    will learn how these three types of plugin work by creating your own license plate
    type field. Let's get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal核心中有一个例子也做了同样的事情，那就是`Text (formatted)`字段。除了其字符串值外，此字段还存储每个值的格式，该格式在渲染时使用。如果没有这个格式，字符串值就会失去其意义，Drupal也无法可靠地按照创建时的意图进行渲染。因此，你现在可以明白，字段从TypedData中吸取了“意义”的概念，并在需要时将其应用于存储。所以，在本章中，你将通过创建自己的车牌类型字段来学习这三种插件类型是如何工作的。让我们开始吧。
- en: Field type
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段类型
- en: The primary plugin type for creating a field is, as we discussed, the `FieldType`.
    It is responsible for defining the field structure, how it is stored in the database,
    and various other settings. Moreover, it also defines a default widget and formatter
    plugin that will be autoselected when we create the field in the UI. You see,
    a single field type can work with more than one widget and formatter. If more
    exist, the site builder can choose one when creating the field and adding it to
    an entity type bundle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字段的主要插件类型，正如我们讨论的那样，是 `FieldType`。它负责定义字段结构、如何在数据库中存储以及各种其他设置。此外，它还定义了一个默认的
    widget 和 formatter 插件，当我们在 UI 中创建字段时将自动选择。您可以看到，单个字段类型可以与多个 widget 和 formatter
    一起工作。如果存在更多，网站构建者可以在创建字段并将其添加到实体类型包时选择一个。
- en: Otherwise, it will be the default; each field needs one because without a widget,
    users can't add data, and without a formatter, they can't see it. Also, as you'd
    expect, widgets and formatters can also work with more than one field type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将是默认的；每个字段都需要一个，因为没有 widget，用户无法添加数据，没有 formatter，他们无法看到数据。同样，如您所预期的那样，widgets
    和 formatters 也可以与多个字段类型一起工作。
- en: 'The field we will create in this section is for the license plate data, which
    as we saw, needs two individual pieces of information: a code (such as the state
    code) and the number. License plates around the world are more complex than this,
    but I chose this example to keep things simple.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的字段是用于车牌数据的，正如我们所看到的，它需要两个独立的信息片段：一个代码（例如州代码）和一个数字。世界各地的车牌比这更复杂，但我选择这个例子是为了保持简单。
- en: 'Our new `FieldType` plugin needs to go inside the `Plugin/Field/FieldType`
    namespace of a new module we will create called `license_plate`. Although not
    mandatory, the class name should end with the word `Item`. It''s a pretty standard
    thing in Drupal core, and we will follow suit. So, let''s take a look at our `LicensePlateItem`
    plugin implementation and then talk about the code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新开发的 `FieldType` 插件需要放置在我们即将创建的新模块 `license_plate` 的 `Plugin/Field/FieldType`
    命名空间内。虽然这不是强制性的，但类的名称应该以单词 `Item` 结尾。这在 Drupal 核心中是一个相当标准的事情，我们将遵循这一做法。因此，让我们来看看我们的
    `LicensePlateItem` 插件实现，然后讨论代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I omitted the class contents, as we will be adding the methods one by one and
    discussing them individually. However, first, we have the plugin annotation, which
    is very important. We have the typical plugin metadata such as the ID, label,
    and description, as well as the plugin IDs for the widget and formatter that will
    be used by default with this field type. Make a note of those, because we will
    create them soon.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了类的内容，因为我们将会逐个添加方法并分别讨论。然而，首先，我们有插件注释，这非常重要。我们有了典型的插件元数据，如 ID、标签和描述，以及默认情况下将与该字段类型一起使用的
    widget 和 formatter 插件的插件 ID。请记住这些，因为我们很快就会创建它们。
- en: Speaking from experience, often, when creating a field type, you'll extend the
    class of an already existing field type plugin, such as a text field or an entity
    reference. This is because Drupal core already comes with a great set of available
    types and usually all you need is to either make some tweaks to an existing one,
    maybe combine them or add an extra functionality. This makes things easier, and
    you don't have to copy and paste code or come up with it again yourself. Naturally,
    though, at some point, you'll be extending from `FieldItemBase` because that is
    the base class all field types need to extend from.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从经验来看，在创建字段类型时，通常会扩展一个已经存在的字段类型插件类，例如文本字段或实体引用。这是因为 Drupal 核心已经提供了一套很好的可用类型，通常你只需要对现有的一种类型进行一些调整，也许将它们组合起来或添加额外的功能。这使得事情变得更容易，你不必复制粘贴代码或自己再次想出它。然而，自然地，在某个时候，你将需要从
    `FieldItemBase` 扩展，因为这是所有字段类型都需要扩展的基类。
- en: In our example, however, we will extend straight from the `FieldItemBase` abstract
    class because we want our field to stand on its own. Also, it's not super practical
    to extend from any existing ones in this case. That is not to say, though, that
    it doesn't have commonalities with other field types, such as `TextItem`, for
    example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，我们将直接从 `FieldItemBase` 抽象类扩展，因为我们希望我们的字段能够独立存在。此外，在这种情况下从任何现有的类扩展并不十分实用。但这并不意味着它与其他字段类型没有共性，例如
    `TextItem`。
- en: 'Let''s now take a look at the first method in our class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们类中的第一个方法：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we do in our class is override the `defaultStorageSettings()`
    method. The parent class method returns an empty array; however, it's still a
    good idea to include whatever it returns to our own array. If the parent method
    changes and returns something later on, we are a bit more robust.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中，我们首先重写 `defaultStorageSettings()` 方法。父类方法返回一个空数组；然而，将父类方法返回的内容包含到我们自己的数组中仍然是一个好主意。如果父类方法在以后更改并返回某些内容，我们就会更加健壮。
- en: 'The purpose of this method is two-fold: specifying what storage settings this
    field has and setting some defaults for them. Also, note that it is a static method,
    which means that we are not inside the plugin instance. However, what are storage
    settings, you may ask?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的目的有两个：指定这个字段有哪些存储设置，并为它们设置一些默认值。此外，请注意，这是一个静态方法，这意味着我们不在插件实例内部。然而，你可能想知道什么是存储设置？
- en: Storage settings are the configuration that applies to the field everywhere
    it's used. As you know, a field can be added to multiple bundles of an entity
    type. In Drupal 7, you could reuse a field even across entity types, but this
    is no longer possible as fields are now reusable only on the bundles of a single
    entity type. You'll need to create another field of that type if you need it on
    some other content entity type. So the storage settings are those that apply to
    this field across each bundle it is attached to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储设置是应用于字段在其使用的任何地方的配置。正如你所知，一个字段可以被添加到实体类型的多个捆绑包中。在Drupal 7中，你可以跨实体类型重用字段，但现在这不再可能，因为字段现在只能在单个实体类型的捆绑包中重用。如果你需要在其他内容实体类型上使用它，你需要创建另一个该类型的字段。因此，存储设置是应用于这个字段在其附加的每个捆绑包中的那些设置。
- en: They usually deal with things related to the schema—how the database table columns
    are constructed for this field—but they also deal with a lot of other things.
    Also, even more important to know is that once there is data in the field tables,
    they cannot be changed. It makes sense as you cannot easily change database tables
    when there is data in them. This restriction is something we enforce, as we will
    see in a bit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常处理与架构相关的事情——如何为该字段构建数据库表列——但它们也处理许多其他事情。更重要的是，要知道一旦字段表中有了数据，它们就不能更改。当你无法轻松更改包含数据的数据库表时，这很有意义。这种限制是我们强制执行的，正如我们稍后将看到的那样。
- en: 'In our example, we only have two storage settings: `number_max_length` and
    `code_max_length`. These will be used when defining the schema for the two table
    columns where the license plate data will be stored (as the maximum length that
    can be stored in those table fields). By default, we will go with the ever-so-used
    255 character maximum length on the number column and 5 for the code column, but
    these are just defaults. The user will be able to change them when creating the
    field or when editing, as long as there is no data yet.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只有两个存储设置：`number_max_length` 和 `code_max_length`。这些设置将在定义存储车牌数据的两个表列的架构时使用（作为那些表字段可以存储的最大长度）。默认情况下，我们将使用在数字列上常用的255个字符的最大长度，以及代码列的5个字符，但这些只是默认值。用户在创建字段或编辑时可以更改它们，只要还没有数据。
- en: 'Next, we can write our storage settings form which allows users to provide
    the actual settings when creating a field:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编写我们的存储设置表单，允许用户在创建字段时提供实际设置：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is called by the main field configuration form and we need to return
    an array of form elements that can be used to set values to the storage settings
    we defined earlier. We have access to the main `$form` and `$form_state` of the
    form where this is embedded, as well as a handy Boolean `$has_data` which tells
    us whether there is already any data in this field. We use this to disable the
    elements we don't want to be changed if there is data in the field (in our case,
    both).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法由主字段配置表单调用，我们需要返回一个表单元素数组，可以用来设置我们之前定义的存储设置值。我们有权访问嵌入此表单的 `$form` 和 `$form_state`
    的主要部分，以及一个方便的布尔值 `$has_data`，它告诉我们这个字段中是否已经有数据。我们使用这个布尔值来禁用如果字段中有数据我们不希望更改的元素（在我们的例子中，是两个）。
- en: So basically, our form consists of two number form elements (both required),
    whose values default to the lengths we specified earlier. The `number` form element
    also comes with `#min` and `#max` properties, which we can use to restrict the
    number to a range. Also, we obviously want our minimum lengths to be a positive
    number, that is, above 1\. This method is relatively straightforward to understand
    if you get the basics of the Form API, which you should by now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们的表单由两个数字表单元素组成（都是必填项），其值默认为我们之前指定的长度。`number`表单元素还带有`#min`和`#max`属性，我们可以使用这些属性来限制数字的范围。显然，我们希望我们的最小长度是一个正数，即大于1。如果你现在已经掌握了表单API的基础，这个方法相对容易理解。
- en: 'Finally, for our storage handling, we will need to implement the schema method
    and define our table columns:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的存储处理，我们需要实现模式方法并定义我们的表列：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is another static method, but one that receives the current field's `FieldStorageDefinitionInterface`
    instance. From there, we can access the settings the user has saved when creating
    the field, and based on those, we define our schema. If you were paying attention
    in the previous chapter when we discussed `hook_schema()`, this should already
    be clear to you. What we need to return is an array of column definitions keyed
    by their name. So we define two columns of the `varchar` type with the maximum
    lengths the user has configured. Of course, we could have had more storage settings
    and made this schema definition even more configurable if we wanted to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态方法，但它接收当前字段的`FieldStorageDefinitionInterface`实例。从那里，我们可以访问用户在创建字段时保存的设置，并根据这些设置定义我们的模式。如果你在上一章讨论`hook_schema()`时注意到了，这应该对你来说已经很清晰了。我们需要返回的是一个按名称键控的列定义数组。因此，我们定义了两个`varchar`类型的列，其最大长度与用户配置的长度相同。当然，如果我们想有更多的存储设置，并使这个模式定义更加可配置，我们也可以做到。
- en: With these three methods our storage handling is complete; however, our field
    type is not quite so. We still have a couple more things to take care of.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个方法，我们的存储处理就完成了；然而，我们的字段类型还没有完成。我们还有几件事情要处理。
- en: 'Apart from storage, as we discussed, fields also deal with data representation
    at the code level with TypedData structures. So our field type needs to define
    its individual properties for which we create storage. For this we have two main
    methods: first, to actually define the properties, and then to set some potential
    constraints on them:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储之外，正如我们讨论的，字段还通过TypedData结构在代码级别处理数据表示。因此，我们的字段类型需要定义其单个属性，为这些属性创建存储。为此，我们有两个主要方法：首先，实际定义属性，然后对它们设置一些潜在的约束：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code will look very familiar to the one in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage,* when we talked about TypedData. Again, this is a
    static method that needs to return the `DataDefinitionInterface` instance for
    the individual properties. We choose to call them `number` and `code`, respectively,
    and set some sensible labels—nothing too complicated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)中的代码非常相似，*数据建模与存储*，我们在讨论TypedData时提到了。再次强调，这是一个静态方法，需要为单个属性返回`DataDefinitionInterface`实例。我们选择分别称它们为`number`和`code`，并设置一些合理的标签——不会太复杂。
- en: 'The previous code is actually enough to define the properties, but if you remember,
    our storage has some maximum lengths in place, meaning that the table columns
    are only so long. So, if the data that gets into our field is longer, the database
    engine will throw a fit in a not-so-graceful way. In other words, it will throw
    a big exception, and we can''t have that. So, there are two things we can do to
    prevent that: put the same maximum length on the form widget to prevent users
    from inputting more than they should and add a constraint on our data definitions.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实际上足以定义属性，但如果你还记得，我们的存储有一些最大长度限制，这意味着表列的长度是有限的。因此，如果进入我们字段的数据过长，数据库引擎将以不太优雅的方式抛出异常。换句话说，它会抛出一个大异常，我们无法接受这种情况。所以，为了防止这种情况，我们可以做两件事：在表单小部件上设置相同的最大长度，以防止用户输入过多的内容，并在我们的数据定义上添加约束。
- en: The second one is more important because it ensures that the data is valid in
    any case, whereas the first one only deals with forms. However, since Drupal 8
    is so much more API-oriented than its previous version, if we create an entity
    programmatically and set its field values, we bypass forms completely. However,
    not to worry; we will also take care of the form, so our users can have a nicer
    experience and are aware of the maximum size of the values they need to input.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更重要，因为它确保数据在任何情况下都是有效的，而第一个只处理表单。然而，由于Drupal 8比其前一个版本更加面向API，如果我们以编程方式创建实体并设置其字段值，我们将完全绕过表单。但是，不用担心；我们也会处理表单，这样我们的用户就可以有一个更好的体验，并且知道他们需要输入的值的最大大小。
- en: 'So, let''s add the following constraints:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加以下约束：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since our field class actually implements the `TypedDataInterface`, it also
    has to implement the `getConstraints()` method (which the `TypedData` parent already
    starts up). However, we can override it and provide our own constraints based
    on our field values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的领域类实际上实现了`TypedDataInterface`，因此它也必须实现`getConstraints()`方法（`TypedData`父类已经启动）。然而，我们可以覆盖它并提供基于我们字段值的自己的约束。
- en: We are taking a slightly different approach here from adding constraints to
    what we saw in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data
    Modeling and Storage*. Instead of adding them straight to the data definitions,
    we will create them manually using the validation constraint manager (which is
    the plugin manager of the `Constraint` plugin type we saw in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*). This is because fields use a specific `ComplexDataConstraint`
    plugin that can combine the constraints of multiple properties (data definitions).
    Do note that even if we had only one property in this field, we'd still be using
    this constraint plugin.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取的方法与我们在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)中看到的添加约束的方法略有不同，*数据建模和存储*。我们不会直接将它们添加到数据定义中，而是会手动使用验证约束管理器（这是我们在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)中看到的`Constraint`插件类型的插件管理器，*数据建模和存储*）来创建它们。这是因为字段使用一个特定的`ComplexDataConstraint`插件，它可以组合多个属性（数据定义）的约束。请注意，即使在这个字段中只有一个属性，我们仍然会使用这个约束插件。
- en: There aren't many types of class in Drupal 8 in which you cannot inject dependencies,
    but `FieldType` plugins are one of them. This is because these plugins are actually
    built on top of the `Map` TypedData plugin, and their manager doesn't use a container-aware
    factory for instantiation but instead delegates it to the `TypedDataManger` service,
    which, as we saw, is not container-aware either. For this reason, we have to request
    the services we need statically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，有很多类类型你不能注入依赖项，但`FieldType`插件就是其中之一。这是因为这些插件实际上建立在`Map` TypedData插件之上，并且它们的经理不使用容器感知工厂进行实例化，而是将其委托给`TypedDataManger`服务，正如我们所看到的，它也不是容器感知的。因此，我们必须静态地请求我们需要的服务。
- en: 'The data needed to create this constraint plugin is a multidimensional array
    keyed by the property name which contains constraint definitions for each of them.
    So, we have a `Length` constraint for both properties, whose options denote a
    maximum length and a corresponding message if that length is exceeded. If we wanted,
    we could have had a minimum length in the same way as well: `min` and `minMessage`.
    As for the actual length, we will use the values chosen by the user when creating
    the field (the storage maximum). Now, regardless of the form widget, our field
    will not validate unless the maximum lengths are respected.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此约束插件所需的数据是一个多维数组，以属性名为键，包含每个属性的约束定义。因此，我们为两个属性都设置了`Length`约束，其选项表示最大长度以及如果超过该长度将显示的消息。如果我们愿意，我们也可以以相同的方式设置最小长度：`min`和`minMessage`。至于实际长度，我们将使用用户在创建字段时选择的值（存储最大值）。现在，无论表单小部件如何，我们的字段只有在遵守最大长度的情况下才会进行验证。
- en: 'It''s time to finish this class with the following two methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用以下两种方法来完成这门课程了：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With `generateSampleValue()`, we create some random words that fit within our
    field. That's it. This can be used when profiling or site building to populate
    the field with demo values. Arguably, this is not going to be your top priority,
    but it is good to know.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`generateSampleValue()`，我们创建一些适合我们字段的随机单词。就是这样。这可以在配置文件或站点构建时用于填充字段的演示值。可以说，这不会是你的首要任务，但了解这一点是好的。
- en: Finally, we have the `isEmpty()` method which is used to determine whether the
    field has values or not. It may seem pretty obvious, but it's an important method,
    especially for us, and you can probably deduce from the implementation why. When
    creating the field in the UI, the user can specify whether it's required or not.
    However, typically, that applies (or should apply) to the entire set of values
    within the field. Also, if the field is not required, and the user only inputs
    a license plate code without a number, what kind of useful value is that to save?
    So, we want to make sure that both of them have something before even considering
    this field as having a value (not being empty), and that is what we are checking
    in this method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`isEmpty()`方法，用于确定字段是否有值。这看起来可能非常明显，但它是一个重要的方法，特别是对我们来说，您可能可以从实现中推断出原因。在UI中创建字段时，用户可以指定是否为必填项。然而，通常这适用于字段中的整个值集。另外，如果字段不是必填项，并且用户只输入车牌代码而没有号码，这种有用的值是什么？因此，我们想要确保两者在考虑此字段作为有值（非空）之前都有内容，这正是我们在该方法中检查的。
- en: 'Since we started writing the class, we made references to a bunch of classes
    that we should *use* at the top before moving on:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们开始编写类以来，我们已经引用了一堆我们应该在顶部使用它们之前就引用的类：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we are finished with the actual plugin class, there is one last thing
    that we need to take care of, something that we tend to forget, myself included:
    the configuration schema. Our new field is a configurable field whose settings
    are stored. Guess where? In configuration. Also, as you may remember, all configuration
    needs to be defined by a schema. Drupal already takes care of those storage settings
    that come from the parent. However, we need to include ours. So, let''s create
    the typical `license_plate.schema.yml` (inside `config/schema`), where we will
    put all the schema definitions we need in this module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了实际的插件类，还有最后一件事需要我们注意，这是我们往往容易忘记的，包括我自己：配置模式。我们的新字段是一个可配置的字段，其设置被存储。猜猜在哪里？在配置中。此外，如您所记得的，所有配置都需要通过模式来定义。Drupal已经处理了来自父级的存储设置。然而，我们需要包含我们自己的。因此，让我们创建典型的`license_plate.schema.yml`（在`config/schema`内部），我们将在这里放置我们在这个模块中需要的所有模式定义：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The actual definition will already be familiar, so the only thing that is interesting
    to explain is its actual naming. The pattern is `field.storage_settings.[field_type_plugin_id]`.
    Drupal will dynamically read the schema and apply it to the settings of the actual
    `FieldStorageConfig` entity being exported.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的定义已经熟悉，所以唯一需要解释的是其命名。模式是`field.storage_settings.[field_type_plugin_id]`。Drupal将动态读取模式并将其应用于正在导出的实际`FieldStorageConfig`实体设置。
- en: 'That''s it for our `FieldType` plugin. When creating a new field of this type,
    we have the two storage settings we can configure (which will be disabled when
    editing if there is actual field data already in the database):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`FieldType`插件的全部内容。在创建此类新字段时，我们可以配置两个存储设置（如果数据库中已有实际字段数据，则编辑时将禁用）：
- en: '![](img/96367f4d-d73b-4516-be18-f188d8f002e6.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96367f4d-d73b-4516-be18-f188d8f002e6.png)'
- en: Unless we work only programmatically or via an API to manage the entities that
    use this field, it won't really be useful, as there are no widgets or formatters
    it can work with. So, we will need to create those as well. As a matter of fact,
    before we can create a field of this type, we need to ensure we have the widget
    and formatter plugins as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们仅通过编程或通过API来管理使用此字段的实体，否则它实际上将没有用处，因为没有与之协同工作的小部件或格式化工具。因此，我们还需要创建这些小部件。实际上，在我们可以创建此类字段之前，我们需要确保我们已经有小部件和格式化插件。
- en: Field widget
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段小部件
- en: 'Our new license plate field type could be added to an entity type, but there
    would be no way users could use it. For this, we will need at least a widget.
    A given field type can work, however, with multiple widgets. So, let''s create
    that default license plate widget plugin we referenced in the annotation of the
    field type, which belongs in the `Plugin/Field/FieldWidget` namespace of our module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新车牌字段类型可以添加到实体类型中，但用户将无法使用它。为此，我们至少需要一个小部件。然而，给定字段类型可以与多个小部件协同工作。因此，让我们创建我们在字段类型注释中引用的默认车牌小部件插件，它属于我们模块的`Plugin/Field/FieldWidget`命名空间：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we started by examining the annotation and class parents for just a bit.
    You will notice nothing particularly complicated, except maybe the `field_types`
    key, which specifies the `FieldType` plugin IDs this widget can work with. Just
    as a field type can have more than one widget, a widget can work with more than
    one field type. Also, it's important that we specify it here, otherwise site builders
    won't be able to use this widget with our license plate field type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们首先检查了注释和类父级，只是稍微看了看。你会发现没有什么特别复杂的地方，除了可能有点复杂的`field_types`键，它指定了此小部件可以与之协同工作的`FieldType`插件ID。就像字段类型可以有多个小部件一样，小部件也可以与多个字段类型协同工作。此外，我们在这里指定它很重要，否则网站构建者将无法使用我们的车牌字段类型来使用这个小部件。
- en: We extended `WidgetBase` which implements the obligatory `WidgetInterface` and
    provides some common defaults for all its subclasses.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`WidgetBase`，它实现了必需的`WidgetInterface`，并为所有子类提供了一些常见默认值。
- en: 'The first thing we can do inside the class is handle our settings. First, we
    will define what settings this widget has and set the default values for these
    settings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部，我们首先处理设置。首先，我们将定义这个小部件有哪些设置，并设置这些设置的默认值：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have some settings specific to how the form widget would be configured for
    our field. We will use the first two settings mentioned in the previous code to
    limit the size of the form element. It will not actually prevent users from filling
    in longer values, but will be a good indication for them as to how long the values
    should be. Then, we have the `fieldset_state` setting which we will use to indicate
    whether the form fieldset used to group the two license place textfields is by
    default open or closed. We will see that in a minute. Lastly, each of these textfields
    can have a placeholder value (potentially). So, we have that setting as well.
    Do note that these are all settings we make up and that make sense for our field.
    You can add your own if you want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些特定于如何为我们的字段配置表单小部件的设置。我们将使用前一段代码中提到的前两个设置来限制表单元素的尺寸。这实际上并不能阻止用户填写较长的值，但会为他们提供一个关于值应该有多长的良好指示。然后，我们有`fieldset_state`设置，我们将用它来指示用于组合两个车牌文本字段的表单字段集默认是打开还是关闭。我们将在下一分钟看到这一点。最后，每个文本字段都可以有一个占位符值（可能）。因此，我们也设置了该设置。请注意，这些都是我们编写的并且对我们字段有意义的设置。如果您想的话，可以添加自己的设置。
- en: 'Next, we have the form used to configure these settings (as part of the widget
    configuration):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有用于配置这些设置的表单（作为小部件配置的一部分）：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have to return the elements for our widget settings, which will then be added
    to a bigger form (passed as an argument). There is nothing special about the first
    three form elements. We have two `number` fields and a `select` list to control
    the first three settings we saw in our defaults. For the first two settings, we
    want the numbers to be positive and max out at the same maximum length we have
    set in the storage. We don't want the widget exceeding that length. However, if
    we want, we can shorten the size of the element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须返回我们的小部件设置元素，这些元素将被添加到一个更大的表单中（作为参数传递）。前三个表单元素没有什么特别之处。我们有两个`number`字段和一个`select`列表来控制我们在默认值中看到的第一个三个设置。对于前两个设置，我们希望数字是正数，并且最大长度与我们在存储中设置的相同。我们不希望小部件超过这个长度。然而，如果我们想的话，我们可以缩短元素的尺寸。
- en: The textfields for the two placeholder values are wrapped inside a `details`
    form element. The latter is a fieldset that can be open or closed and can contain
    other form elements. We will use it to wrap the actual textfields with which users
    will input license plate data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 两个占位符值的文本字段被包裹在一个`details`表单元素中。后者是一个可以打开或关闭的字段集，可以包含其他表单元素。我们将使用它来包裹用户将输入车牌数据的实际文本字段。
- en: 'The previous form will look like this when users configure the widget:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户配置小部件时，之前的格式将看起来像这样：
- en: '![](img/46ced2d4-8a43-4433-9d06-533131f1f3ab.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46ced2d4-8a43-4433-9d06-533131f1f3ab.png)'
- en: 'Lastly, we have the summary of the settings the widget, which will be displayed
    on the Manage form display page for our field:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有小部件设置的摘要，它将在我们的字段的“管理表单显示页面”上显示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method needs to return an array of strings that will make up the settings
    summary. That is what we do now: read all of our settings values and list them
    in a human-friendly way. The end result will look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要返回一个字符串数组，这些字符串将组成设置摘要。这就是我们现在所做的事情：读取我们所有的设置值并以人性化的方式列出它们。最终结果将看起来像这样：
- en: '![](img/9bc7c788-7c6f-4b39-b88c-983dbd4eea7c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bc7c788-7c6f-4b39-b88c-983dbd4eea7c.png)'
- en: 'Next, we will have to implement the core of the field widget plugins—the actual
    form used for inputting the field data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将必须实现字段小部件插件的内核——用于输入字段数据的实际表单：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a bit more complicated at first glance, but we'll break it down and
    you'll see that it actually makes sense with what you've been learning in the
    previous chapters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎有些复杂，但我们会将其分解，你会发现它实际上与你在前几章中学到的内容相符。
- en: The first argument passed to this method is the entire list of values for this
    field. Remember that each field can have multiple values, hence the usage of the
    `FieldItemListInterface` instance to hold them. So, from there, we can get the
    values of any of the items in the list. The second argument is the actual delta
    of the item in the list, which we can use to pinpoint the one for which the form
    is being built (in order to retrieve the default value). Then, we have an `$element`
    array that we should actually return, but which contains some pieces of data already
    prepared for us based on the field configuration. For example, when creating a
    field, if we set it to be required, then this `$element` already contains the
    form property `#required => TRUE`. Likewise, it contains the weight of the field
    (compared to the others on the entity type), the `#title` property, and many others.
    I recommend that you debug that array and see what's in it. Also, you can look
    inside `WidgetBase::formMultipleElments()` and `WidgetBase::formSingleElement()`
    and see how this array is prepared. Lastly, we get the form definition and form
    state information of the larger form our field element gets embedded in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此方法的第一个参数是此字段的全部值列表。请记住，每个字段可以有多个值，因此使用`FieldItemListInterface`实例来持有它们。因此，我们可以从列表中获取任何项目的值。第二个参数是列表中项目的实际增量，我们可以使用它来定位正在构建表单的那个项目（以便检索默认值）。然后，我们有一个应该实际返回的`$element`数组，但它包含了一些基于字段配置已经为我们准备好的数据。例如，在创建字段时，如果我们将其设置为必填项，那么这个`$element`已经包含了表单属性`#required
    => TRUE`。同样，它包含了字段的权重（与其他实体类型上的字段相比）、`#title`属性以及许多其他属性。我建议你调试这个数组，看看里面有什么。你还可以查看`WidgetBase::formMultipleElements()`和`WidgetBase::formSingleElement()`，看看这个数组是如何准备的。最后，我们获取了字段元素嵌入的较大表单的表单定义和表单状态信息。
- en: So, what we are doing inside the method is getting a bit creative with the data
    that we have. The one-value (columns) fields would typically just add to the `$element`
    array and then simply return that. However, we have two values we want to wrap
    inside a nice collapsible fieldset, so we create a `details` element for that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在方法内部对所拥有的数据进行了一些创造性的处理。对于单值（列）字段，通常会将其添加到`$element`数组中，然后简单地返回。然而，我们有两个值想要包裹在一个漂亮的可折叠字段集中，所以我们为它创建了一个`details`元素。
- en: It is on this element that we copy over the field title and description the
    user has specified when creating the field, which is prepared for us in the `$element`
    array. This is because those relate to the entire field, not just one of the values.
    Moreover, we also set the default `#open` state to whatever was stored in the
    widget settings. Lastly, to all this we add the rest of the values found in the
    `$elements` array because we want to inherit them as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这个元素上，我们复制了用户在创建字段时指定的字段标题和描述，这些信息已经以`$element`数组的形式为我们准备好了。这是因为这些信息与整个字段相关，而不仅仅是其中一个值。此外，我们还设置了默认的`#open`状态，使其与小部件设置中存储的内容一致。最后，我们将`$elements`数组中找到的其他值也添加进来，因为我们希望继承它们。
- en: Note that I could have left the `#title` and `#description` to be inherited
    as well, but overtly added it to make it more visible for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我本可以将`#title`和`#description`也设置为继承，但我故意添加了它们，以便让你更容易看到。
- en: Next, within our details element, we can add the two textfields for the license
    plate code and number. For both of these, we use the widget settings to set the
    element size and placeholder value, as well as a maximum length value equal to
    the field item storage. This is what will prevent users from providing values
    that are longer than what the database columns can handle. The default value for
    the two form elements will be set to the actual field values of these properties,
    retrieved from the list of items using the current delta key. Finally, we set
    the `#required` property to whatever the user has configured for this field. This
    property would be useless on the parent `details` element, so we have to move
    it down to the actual text fields. And that's pretty much it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `details` 元素内部，我们可以添加车牌代码和编号的两个文本字段。对于这两个字段，我们使用小部件设置来设置元素大小和占位符值，以及一个等于字段项存储的最大长度值。这将防止用户提供比数据库列可以处理的更长的值。两个表单元素的默认值将被设置为这些属性的实际情况字段值，通过使用当前
    delta 键从项目列表中检索。最后，我们将 `#required` 属性设置为用户为该字段配置的任何内容。这个属性在父 `details` 元素上将是无用的，所以我们必须将其移动到实际的文本字段。就这样了。
- en: 'The last method we can implement, and in our case, have to, is one that prepares
    the field values a bit when submitting:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施，并且在我们这个案例中，必须实施的最后一个方法是在提交时对字段值进行一些准备：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s what happens. From our property definitions, our field expects two
    properties: number and code. However, submitting this form will present only one
    property called "details" because that is what we arbitrarily named our fieldset
    form element (which contains the properties). Since we made this choice, we will
    need to now massage the submitted values a bit to match the expected properties.
    In other words, we have to bring the number and code properties to the top level
    of the `$values` array and unset the details element, as it''s no longer needed
    upon submission. So, now, the field receives the array in the following format:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是会发生什么。从我们的属性定义中，我们的字段期望有两个属性：编号和代码。然而，提交此表单将只显示一个名为 "details" 的属性，因为这是我们任意命名的字段集表单元素（它包含属性）。由于我们做出了这个选择，我们现在需要稍微调整提交的值以匹配预期的属性。换句话说，我们必须将编号和代码属性带到
    `$values` 数组的顶层，并取消 `details` 元素的设置，因为它在提交后不再需要。因此，现在，字段以以下格式接收数组：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you remember, this is incidentally also what we would pass to the `set()`
    method of the field if we wanted to set this value on the field. Take a look at
    the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，这也是如果我们想在字段上设置此值时，会传递给字段 `set()` 方法的。看看下面的例子：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With that, our widget is done; well, not quite. We should ensure we use all
    the newly referenced classes at the top:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的小部件就完成了；嗯，还不完全。我们应该确保我们使用所有新引用的类在顶部：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, we again forgot about the configuration schema. Let''s not do that again.
    In the same file as we wrote the field storage schema, we can add the definition
    for the widget settings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们又忘记了配置模式。让我们不要再犯同样的错误。在写入字段存储模式的同一文件中，我们可以添加小部件设置的定义：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It works just like before: a dynamic schema name that starts with `field.widget.settings.`
    and has the actual plugin ID at the end; and inside, we have a property mapping
    as we''ve seen before. With this, we really are done.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与之前相同：一个以 `field.widget.settings.` 开头的动态模式名称，并在末尾包含实际的插件ID；并且内部，我们有我们之前看到的属性映射。有了这个，我们真的就完成了。
- en: Field formatter
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段格式化器
- en: Alright, so our field now also has a widget that users can input data with.
    Let's create the default field formatter to make the field whole.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '好吧，所以我们的字段现在也有了一个用户可以输入数据的工具。让我们创建默认字段格式化器，使字段完整。 '
- en: 'Before actually coding it, let''s establish what we want our formatter to look
    and behave like. By default, we want the license plate data to be rendered like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际编码之前，让我们确定我们想要的格式化器看起来和表现如何。默认情况下，我们希望车牌数据被渲染如下：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, each component is wrapped inside its own span tag, and some handy classes
    are applied to them. Alternatively, we may want to concatenate the two values
    together into one single span tag:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个组件都被包裹在其自己的 span 标签内，并应用了一些方便的类。或者，我们可能希望将两个值连接到一个单独的 span 标签中：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This could be a setting on the formatter, allowing the user to choose the preferred
    output. So, let's do it then.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在格式化器中作为一个设置，允许用户选择首选的输出。那么，我们就这么做吧。
- en: 'Field formatters go inside the `Plugin/Field/FieldFormatter` namespace of our
    module, so let''s go ahead and create our own:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 字段格式化器位于我们模块的 `Plugin/Field/FieldFormatter` 命名空间内，所以让我们继续创建我们自己的：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, we start by inspecting the annotation, which looks very unsurprising.
    It looks almost like the one for our widget earlier, as formatters can also be
    used on multiple field types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先检查注解，它看起来非常不出所料。它看起来几乎与之前我们的小部件注解一样，因为格式化器也可以用于多种字段类型。
- en: The class extends `FormatterBase`, which itself implements the obligatory `FormatterInterface`.
    By now, you recognize the pattern used with plugins—they all have to implement
    an interface and typically extend a base class, which provides some helpful functionalities
    common to all plugins of those types. Fields are no different.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该类扩展了`FormatterBase`，它本身实现了必需的`FormatterInterface`。到现在为止，你应该已经认识到了插件使用的模式——它们都必须实现一个接口，并且通常扩展一个基类，这为所有这些类型的插件提供了一些共同的帮助功能。字段也不例外。
- en: 'The first thing we do inside this formatter class is, again, deal with its
    own settings (if we need any). As it happens, we have a configurable setting for
    our formatter, so let''s define it and provide a default value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个格式化器类内部，我们首先再次处理其自己的设置（如果我们需要的话）。碰巧的是，我们有一个可配置的格式化器设置，让我们定义它并提供一个默认值：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is just like with the previous plugins. The `concatenated` setting will
    be used to determine the output of this field according to the two options we
    talked about earlier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的插件类似。`concatenated`设置将用于确定此字段的输出，根据我们之前讨论的两个选项。
- en: 'Next, predictably, we will need the form to manage this setting:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，不出所料，我们需要表单来管理这个设置：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, nothing special; we have a checkbox, which we use to manage a Boolean
    value (represented by 1 or 0). Lastly, just like with the widget, we have a summary
    display for formatters as well that we can define:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并没有什么特别之处；我们有一个复选框，我们用它来管理布尔值（用1或0表示）。最后，就像小部件一样，我们还可以为格式化器定义一个摘要显示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we just print in a human-readable name of whatever has been configured,
    and this will be displayed when managing the field display in the UI and will
    look just like it did with the widget. Consistency is nice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是打印出配置的任何内容的可读名称，当在UI中管理字段显示时，它将看起来与小部件一样。一致性是件好事。
- en: 'Now, we''ve reached the most critical aspect of any field formatter—the actual
    display:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了任何字段格式化器的最关键部分——实际的显示：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The method used for this is `viewElements()`, but for each element in the list,
    we simply delegate the processing to a helper method, because as you remember,
    the field is itself a list of value items (depending on the field cardinality),
    even if there is only one value in the field. These are keyed by a delta, which
    we also use to key the array of `$elements` that we return from the method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此的方法是`viewElements()`，但对于列表中的每个元素，我们只是简单地委托给一个辅助方法，因为正如你记得的那样，字段本身是一个值项的列表（取决于字段的基数），即使字段中只有一个值。这些项通过一个增量来标识，我们也用它来标识从方法返回的`$elements`数组。
- en: 'For each individual item in the list, we then retrieve the value of the license
    plate code and number using the TypedData accessors we'' saw earlier. Remember
    that at this point we are working with a `FieldItemInterface` whose `get()` method
    returns the DataType plugin that represents the actual value, which, in our case,
    is `StringData`. Because that is what our field property definitions were:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个单独的项目，我们随后使用之前看到的TypedData访问器检索车牌代码和数字的值。记住，在这个阶段，我们正在处理一个`FieldItemInterface`，其`get()`方法返回代表实际值的DataType插件，在我们的例子中是`StringData`。因为这就是我们的字段属性定义：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, the actual values inside these plugins are the string representations
    the user actually provided. We use these values together with the setting to determine
    whether to concatenate and pass them to a custom theme function (we have yet to
    define this). The important thing to keep in mind is that we need to return, for
    each item, a render array. This can be anything; consider the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些插件中的实际值是用户实际提供的字符串表示。我们使用这些值与设置一起确定是否要连接并将它们传递给一个自定义主题函数（我们尚未定义）。需要记住的重要事情是，我们需要为每个项目返回一个渲染数组。这可以是任何东西；考虑以下示例：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, that doesn''t look nice, nor is it configurable or overridable. So,
    we opt for a clean new theme function that takes those three arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这看起来并不美观，也不可配置或可覆盖。因此，我们选择了一个干净的新主题函数，它接受这三个参数：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We default the value for `concatenated` to `TRUE` because that is what we used
    inside `defaultSettings()` as well. We have to be consistent. The template file
    that goes with this, `license-plate.html.twig`, is also very simple:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`concatenated`的值默认设置为`TRUE`，因为我们也在`defaultSettings()`内部使用了它。我们必须保持一致。与这个设置一起的模板文件`license-plate.html.twig`也非常简单：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Depending on our setting, we output the markup differently. Other modules and
    themes now have a host of options to alter this output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设置，我们以不同的方式输出标记。现在，其他模块和主题有许多选项可以改变这种输出：
- en: They can create a new formatter plugin altogether.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以完全创建一个新的格式化插件。
- en: They can override the template inside a theme.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以在主题内部覆盖模板。
- en: They can alter the template to be used by this theme hook.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以改变由这个主题钩子使用的模板。
- en: 'That''s it for the formatter plugin itself, but this time we''re not forgetting
    about the configuration schema. Although we have a measly little Boolean value
    to define, it still needs to be done:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是格式化插件本身的内容，但这次我们并没有忘记配置方案。尽管我们只有一个微不足道的布尔值来定义，但仍然需要这样做：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works the same way as the other ones but with a different prefix: `field.formatter.settings`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他的运作方式相同，但前缀不同：`field.formatter.settings`。
- en: 'With that, we have our field formatter in the bag. We should not forget, however,
    the missing *use* statements at the top of the formatter plugin class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了字段格式化器。然而，我们不应该忘记，格式化插件类顶部的缺失`use`语句：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now after clearing the cache, the new field type can be used to create fields.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在清除缓存后，新的字段类型可以用来创建字段。
- en: However, I still think we can do one better. Since we are working with license
    plates that deal with certain known formats, what if we make our field configurable
    to provide a list of license plate codes that can be used when inputting the data?
    This will have the added benefit of us learning something new about fields—field
    settings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为我们还可以做得更好。由于我们正在处理涉及某些已知格式的车牌，如果我们使我们的字段可配置以提供在输入数据时可以使用的车牌代码列表，会怎么样？这将带来额外的益处，即我们了解有关字段的新知识——字段设置。
- en: Field settings
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段设置
- en: When we created our field type, we specified some storage settings and we saw
    that these are typically linked to underlying storage and cannot be changed once
    the field has data in it. This is because databases have a hard time making table
    column changes when there is data present in them. However, apart from storage
    settings, we also have something called field settings, which are specific to
    the field instance on a certain entity bundle. Even more, they can (or should)
    be changeable even after the field has been created and has data in it. An example
    of such a field setting, which is available from Drupal core on all field types,
    is the "required" option which marks a field as required or not. So let's see
    how we can add our own field settings to configure what we said we want to do.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建字段类型时，我们指定了一些存储设置，并看到这些通常与底层存储相关联，一旦字段中有数据，就不能更改。这是因为数据库在它们中有数据时很难更改表列。然而，除了存储设置之外，我们还有称为字段设置的东西，它是特定于某个实体捆绑的字段实例的。更重要的是，它们（或应该）可以在字段创建后并具有数据的情况下进行更改。这样一个字段设置的例子，它可以从Drupal核心在所有字段类型中获取，是“必需”选项，它标记一个字段为必需或不必需。那么，让我们看看我们如何添加自己的字段设置来配置我们想要做的事情。
- en: 'Back in our `LicensePlateItem` plugin class, we start by adding the default
    field settings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`LicensePlateItem`插件类，我们首先添加默认字段设置：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the same pattern we''ve been seeing by which we specify what are the
    settings and what are their relevant defaults. Then, as expected, we need the
    form, where users can specify the setting values for each field instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直在看到的相同模式，我们指定了设置是什么以及它们的默认值是什么。然后，正如预期的那样，我们需要表单，用户可以在其中指定每个字段实例的设置值：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So what we provide here is a `textarea` form element by which the administrator
    can add multiple license plate codes, one per each line. In our widget, we will
    use these and turn them into a select list. However, before we do that, we need
    to provide the configuration schema for this new setting:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里提供的是一个`textarea`表单元素，管理员可以通过它添加多个车牌代码，每行一个。在我们的小工具中，我们将使用这些代码并将它们转换成一个选择列表。然而，在我们这样做之前，我们需要提供这个新设置的配置方案：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place, we can turn to our field widget and make the necessary changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们可以转向我们的字段小工具并做出必要的更改。
- en: 'Inside the `formElement()` method, let''s replace the block where we defined
    the code form element with this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`formElement()`方法中，让我们用以下内容替换我们定义代码表单元素的部分：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since the logic for determining that element depends on configuration, it''s
    a bit more complicated, so it''s best to refactor to its own method. Now let''s
    write it up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于确定该元素的逻辑取决于配置，所以它稍微复杂一些，因此最好将其重构为单独的方法。现在让我们把它写出来：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by defining the code form element defaults, such as title, default,
    and value. Then, we get the field settings for the `codes` setting we just created.
    Note that `getFieldSetting()` and `getFieldSettings()` delegate to the actual
    field type and return both storage and field settings combined. So, we don't need
    to use separate methods. However, an implication is that you should probably stick
    to different setting names for the two categories.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义代码表单元素的默认值，例如标题、默认值和值。然后，我们获取我们刚刚创建的`codes`设置的字段设置。请注意，`getFieldSetting()`和`getFieldSettings()`委托给实际的字段类型，并返回存储和字段设置的组合。因此，我们不需要使用单独的方法。然而，这意味着你可能应该坚持为两个类别使用不同的设置名称。
- en: Then, if we don't have any codes configured in this particular field instance,
    we build up our textfield form element as we did before. Otherwise, we break them
    up into an array and use them in a select list form element. Also, note that in
    this latter case we no longer need to apply any length limits because of the validation
    inherent to select lists. Values not present in the original options list will
    be considered invalid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们在这个特定的字段实例中没有配置任何代码，我们就像以前一样构建我们的文本字段表单元素。否则，我们将它们拆分成一个数组，并在选择列表表单元素中使用它们。此外，请注意，在这种情况下，我们不再需要应用任何长度限制，因为选择列表固有的验证已经足够。不在原始选项列表中的值将被视为无效。
- en: That's pretty much it. The field can now be configured to either default to
    the open textfield for adding a license plate code or to a select list of predefined
    ones. Also, the same field can be used in these two ways on two different bundles,
    which is neat.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部了。现在，该字段可以被配置为默认为开放文本字段以添加车牌代码，或者为预定义的选择列表。同样，同一个字段可以以这两种方式在两个不同的包中使用，这很方便。
- en: Using our custom field type as a base field
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的自定义字段类型作为基本字段
- en: At the beginning of this chapter, I stressed the importance of understanding
    the makeup of a field (type, widget, and formatter) so as to easily define base
    fields on custom entity types. This understanding allows you to navigate through
    Drupal core code, discover their settings and use them on base fields. So, let's
    cement this understanding by seeing how our new field could be defined as a base
    field on a custom entity type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我强调了理解字段（类型、小部件和格式化器）的构成的重要性，以便轻松地在自定义实体类型上定义基本字段。这种理解使您能够导航到Drupal核心代码，发现它们的设置并在基本字段中使用它们。因此，让我们通过查看我们的新字段如何在自定义实体类型上定义为一个基本字段来巩固这种理解。
- en: 'Here is an example where we actually use all the available settings we defined
    for each of the three plugins. Note that any settings that are left out default
    to the values we specified in the relevant *defaults* method, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，我们实际上使用了为每个插件定义的所有可用设置。请注意，任何未指定的设置都将默认为我们已在相关*默认*方法中指定的值，如下所示：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is very similar to what we've been seeing. For the `create()` method, we
    use the `FieldType` plugin ID. Inside the `setSettings()` method we pass both
    storage and field settings. They will then be used appropriately. Note that since
    the `codes` setting is stored as a string with codes separated by line breaks,
    we will need to add it accordingly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的情况非常相似。对于`create()`方法，我们使用`FieldType`插件ID。在`setSettings()`方法中，我们传递存储和字段设置。然后，它们将被适当地使用。请注意，由于`codes`设置以字符串形式存储，代码之间由换行符分隔，因此我们需要相应地添加它。
- en: Similarly, for the `view` and `form` display options, we use the formatter and
    widget plugin IDs, respectively, and inside a `settings` array, we pass any of
    the settings we have defined. Lastly, the `setDisplayConfigurable()` indicates
    that all these settings for the formatter and widget are also configurable through
    the UI. Doing so will turn the `BaseFieldDefinition` into a `BaseFieldOverride`,
    as it needs to store the configured overrides.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`view`和`form`显示选项，我们分别使用格式化器和小部件插件ID，并在`settings`数组中传递我们定义的任何设置。最后，`setDisplayConfigurable()`表示所有这些格式化器和小部件的设置也可以通过UI进行配置。这样做将`BaseFieldDefinition`转换为`BaseFieldOverride`，因为它需要存储配置的覆盖。
- en: This should be a recap for you, as we covered all these concepts in earlier
    chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是对你的回顾，因为我们已经在前面的章节中涵盖了所有这些概念。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at how we can create custom fields that site builders
    (and developers) can add to entity types. This implied defining three plugin types:
    `FieldType`, `FieldWidget`, and `FieldFormatter`, each with its own responsibility.
    The first defined the actual field, its storage and individual data properties,
    using the TypedData API. The second defined the form through which users can input
    field data when creating or editing entities that use the field. The third defined
    how the values inside this field can be displayed when viewing the entity.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何创建自定义字段，这些字段可以被网站构建者（和开发者）添加到实体类型中。这暗示了定义三种插件类型：`FieldType`、`FieldWidget`和`FieldFormatter`，每种类型都有其自己的职责。第一种定义了实际的字段，其存储和单个数据属性，使用TypedData
    API。第二种定义了用户在创建或编辑使用该字段的实体时可以输入字段数据的表单。第三种定义了在查看实体时如何显示该字段内的值。
- en: We also saw that each of these plugins can have arbitrary sets of configurable
    settings that can be used to make the field dynamic—both in how the widget works
    and in how the values are displayed. Moreover, these settings are part of the
    exported field configuration, so we saw how we can define their respective configuration
    schemas.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，这些插件都可以有任意数量的可配置设置，这些设置可以用来自定义字段——既包括小部件的工作方式，也包括值的显示方式。此外，这些设置是导出字段配置的一部分，因此我们看到了如何定义它们各自的配置模式。
- en: Lastly, we also saw how—aside from creating our new field through the UI—developers
    can add it to an entity type as a base field, making it available on all bundles
    of that entity type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还看到了除了通过UI创建我们的新字段外，开发者还可以将其作为基础字段添加到实体类型中，使其在该实体类型的所有捆绑包中可用。
- en: In the next chapter, we will talk about access control, a very important topic,
    as we need to ensure that our data and functionality are only exposed to the users
    we want, when we want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论访问控制，这是一个非常重要的主题，因为我们需要确保我们的数据和功能只在我们需要的时候，向想要的用户暴露。
