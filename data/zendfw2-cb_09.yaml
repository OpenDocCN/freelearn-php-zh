- en: Chapter 9. Catching Bugs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 捕获错误
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Handling Exceptions—your partner in crime
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常——你的犯罪伙伴
- en: Logging and how it makes your life easier
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录以及它如何使你的生活更轻松
- en: Unit testing – why would you do it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试——你为什么要做
- en: Setting up and using unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用单元测试
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: On 9 September, 1947 the first computer bug was found by Grace Hopper. This
    computer bug was an actual insect instead of a software bug. Since then we are
    basically chasing bugs in our software applications, and the more we learn to
    code the more we begin to appreciate good error handling, and catching bugs in
    time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1947年9月9日，Grace Hopper发现了第一个计算机错误。这个计算机错误实际上是一只昆虫，而不是软件错误。从那时起，我们基本上在我们的软件应用程序中追逐错误，而且我们学到的代码越多，我们就越开始欣赏良好的错误处理，并及时捕获错误。
- en: As a coder nothing is more annoying than getting customers on the phone that
    say "it doesn't work", without us knowing what actually is going on. That is why
    this chapter is focused on catching bugs early, and finding the cause of the bug
    more easily.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个程序员来说，没有什么比接到客户电话说“它不起作用”，而我们不知道到底发生了什么，更令人烦恼的了。这就是为什么本章的重点是尽早捕获错误，并更容易地找到错误的原因。
- en: Handling Exceptions – your partner in crime
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常——你的犯罪伙伴
- en: To find the source of errors, good error handling should be implemented. In
    this recipe we'll talk about Exception handling within the Zend Framework 2 and
    how to optimally use it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到错误源，应该实现良好的错误处理。在本食谱中，我们将讨论在Zend Framework 2中的异常处理以及如何最佳地使用它。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can safely assume that we all know about try-catch and Exceptions, but to
    make sure nobody is caught out please take a look at the link to the PHP manual
    in the *See also* subsection in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地假设我们所有人都知道关于try-catch和异常的知识，但为了确保没有人被遗漏，请查看本节“参见”子节中的PHP手册链接。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Exception handling is not that difficult to use, but it is a very useful tool
    if used correctly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理并不难使用，但如果使用得当，它是一个非常实用的工具。
- en: Exception classes in Zend Framework 2
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zend Framework 2中的异常类
- en: 'Let''s take a look at the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This implementation of `try-catch` is also called cascading Exceptions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`try-catch`的实现也被称为级联异常。
- en: Handling Exceptions on dispatch or rendering
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在分发或渲染时处理异常
- en: To implement the trigger on one of these events we should add some code to the
    `/module/Application/Module.php` file in one of our Modules (it doesn't specifically
    matter which one).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这些事件之一上实现触发器，我们应该在我们的模块中的一个模块的`/module/Application/Module.php`文件中添加一些代码（具体是哪一个并不重要）。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now we have seen how to do it, let's see how it actually works in Zend Framework
    2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何做到这一点，让我们看看它在Zend Framework 2中实际上是如何工作的。
- en: Exception classes in Zend Framework 2
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zend Framework 2中的异常类
- en: Zend Framework 2 throws a different Exception for almost every component of
    the framework, and although different in name they are all the same in functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2几乎为框架的每个组件抛出不同的异常，尽管名称不同，但它们在功能上都是相同的。
- en: 'First of all here is a list of Exceptions that are default to PHP but are overridden
    by Zend Framework 2 because Zend Framework 2 just likes to use Exceptions that
    are in the Zend namespace, instead of in the global namespace:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里是一个列表，列出了PHP中默认的异常，但被Zend Framework 2覆盖，因为Zend Framework 2喜欢使用在Zend命名空间中的异常，而不是在全局命名空间中：
- en: '`BadMethodCallException`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BadMethodCallException`'
- en: '`DomainException`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DomainException`'
- en: '`ExtensionNotLoadedException`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtensionNotLoadedException`'
- en: '`InvalidArgumentException`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidArgumentException`'
- en: '`InvalidCallbackException`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidCallbackException`'
- en: '`LogicException`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogicException`'
- en: '`RuntimeException`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeException`'
- en: Luckily we can use the global `\DomainException` as well as `\Zend\Stdlib\Exception\DomainException`
    (it is such a mouthful) when catching our Exceptions, as the Exceptions are overridden
    from the original.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在捕获异常时使用全局的`\DomainException`以及`\Zend\Stdlib\Exception\DomainException`（它太长了），因为异常已经从原始的异常中覆盖了。
- en: It can however be useful if we are using a chain of catches to know where a
    specific Exception comes from; for example, when we catch a `RuntimeException`
    and we know that either `Zend\Cache` or `Zend\Authentication` can throw one. However
    usually it is quite clear what it might be or reactions to Exceptions might be
    different per instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用一系列的捕获来了解特定的异常来源，这可能会很有用；例如，当我们捕获`RuntimeException`并且我们知道`Zend\Cache`或`Zend\Authentication`可能会抛出一个异常时。然而，通常情况下，它可能很清楚是什么，或者对异常的反应可能因实例而异。
- en: Zend Framework 2, however, has docblocks for every class and method and luckily
    for us also has documented `@throws` as well. This means that we can easily look
    at the documentation and see what that specific functionality throws, that way
    we can easily wrap our code inside a `try-catch` block and handle the Exceptions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Zend Framework 2 为每个类和方法都提供了 docblocks，并且幸运的是，它还为我们提供了文档化的 `@throws`。这意味着我们可以轻松地查看文档，并了解特定功能抛出了什么，这样我们就可以轻松地将代码包裹在
    `try-catch` 块中，并处理异常。
- en: We can also just catch any `\Exception` that is thrown, instead of specifically
    targeting a named Exception, but we don't tend to do that as it doesn't give us
    good control over the errors occurring. In general we would like to be as specific
    as possible when it comes to Exceptions, and the rule is to catch them from most
    specific down to least specific.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以捕获任何抛出的 `\Exception`，而不是专门针对命名异常，但我们通常不会这样做，因为这不会给我们对错误的有效控制。一般来说，当我们处理异常时，我们希望尽可能具体，规则是从最具体到最不具体地捕获它们。
- en: Handling exceptions on dispatch or rendering
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在调度或渲染时处理异常
- en: If we don't handle exceptions on either dispatch or rendering, we are in for
    a bad time. One of the issues that can arise is the white screen issue where we
    won't see anything on the screen because of an error happening. During the development
    stage, this only leads to mild frustration for the developer, but think about
    the user that sees this on a live environment as they want to tell you their nephew/cousin/uncle
    is a better coder than us. We can't have that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在调度或渲染时没有处理异常，我们将会遇到麻烦。可能出现的问题之一是白屏问题，因为我们不会在屏幕上看到任何东西，因为发生了错误。在开发阶段，这只会让开发者感到轻微的挫败感，但想想看，当用户在实时环境中看到这种情况时，他们想告诉你他们的侄子/表亲/叔叔的编码能力比我们强。我们不能有这种情况。
- en: That is why we need to make sure that we listen to the `Zend\Mvc\MvcEvent::EVENT_DISPATCH_ERROR`
    and `Zend\Mvc\MvcEvent::EVENT_RENDER_ERROR` events. These events will be triggered
    when a controller or route is not found or an error occurrs during the rendering
    of the templates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们需要确保我们监听 `Zend\Mvc\MvcEvent::EVENT_DISPATCH_ERROR` 和 `Zend\Mvc\MvcEvent::EVENT_RENDER_ERROR`
    事件。当控制器或路由未找到或模板渲染期间发生错误时，这些事件将被触发。
- en: As we can see from the example, this event is only triggered when an error occurs,
    when dispatching, or rendering. The exception retrieved can then be used to either
    log, or dump to the screen, whatever feels appropriate. The idea here is that
    we are able to debug effectively even if we don't see the error happening.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中可以看到，此事件仅在发生错误、调度或渲染时触发。然后可以检索到的异常可以用来记录或显示在屏幕上，无论哪种方式都感觉合适。这里的想法是我们即使没有看到错误发生，也能有效地进行调试。
- en: For example, if this technique was implemented on the live application, it could
    log all the exceptions to a log (or e-mail to support) then we would be able to
    see errors that occur when we are "not around" to see it for ourselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果这项技术在实时应用程序中实现，它可以将所有异常记录到日志（或发送到支持部门的电子邮件）中，这样我们就可以看到当我们“不在场”时发生的错误。
- en: About try-catch
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 try-catch
- en: The `try-catch` block in PHP is one incredibly useful tool of the trade and
    we would need to use it as much as possible as chains of Exceptions are much easier
    to solve than a `return false` or `null` back from a method. Especially in combination
    of events we are able to catch anything in time, or at least make sure we are
    able to debug it in a reasonable fashion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中的 `try-catch` 块是贸易中一个极其有用的工具，我们需要尽可能多地使用它，因为异常链比方法返回 `false` 或 `null` 更容易解决。特别是结合事件，我们能够及时捕获任何异常，或者至少确保我们能够以合理的方式对其进行调试。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Exceptions manual and the introduction to try-catch: [http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 异常手册和 try-catch 介绍：[http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php)
- en: Logging and how it makes your life easier
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和它如何使你的生活更轻松
- en: Besides good error handling, logging is a good way to make sure you get the
    most knowledge of what is going on out of your system. Most of time we can even
    build it so that we can record events that lead up to an error, which can then
    be traced back to the original issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了良好的错误处理外，记录是确保你从系统中获得最多知识的好方法。大多数时候，我们甚至可以构建它，以便记录导致错误的事件，然后可以追溯到原始问题。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Because we want to go all exotic with the logging in Zend Framework 2, it is
    required for us to install the FirePHP core on our web server. We can install
    this library through the Composer tool (we need to assume that we already use
    this on the server, otherwise it would get a bit too complicated).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要在Zend Framework 2中尝试所有外来的记录方式，所以我们需要在我们的Web服务器上安装FirePHP核心。我们可以通过Composer工具安装这个库（我们假设我们已经在服务器上使用了它，否则事情会变得有些复杂）。
- en: 'We can install the FirePHP library by adding the following lines in the require
    section of the `composer.json` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`composer.json`文件的require部分添加以下行来安装FirePHP库：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we now execute `'php composer.phar update'` in the command line, it will
    install the library for use within our code later on. To make full use of the
    logger functionality, it would also be wise to use a browser that can understand
    FirePHP headers. With the Mozilla Firefox browser we need to install the Firebug
    and FirePHP add-ons to make it work. If we want to use FirePHP logging in Google's
    Chrome browser or Microsoft Internet Explorer, we need separate extensions/add-ons
    as well, as none of these support it by default.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在命令行中执行`'php composer.phar update'`，它将安装库以便稍后在我们的代码中使用。为了充分利用记录器功能，使用一个能够理解FirePHP头部的浏览器也是明智的。使用Mozilla
    Firefox浏览器，我们需要安装Firebug和FirePHP插件来使其工作。如果我们想在Google的Chrome浏览器或Microsoft Internet
    Explorer中使用FirePHP记录，我们也需要安装相应的扩展/插件，因为这些浏览器默认都不支持。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In this recipe we will show off examples on how to implement a logger system
    in our application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何在我们的应用程序中实现记录器系统的示例。
- en: Implementing a really simple file logger
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个真正简单的文件记录器
- en: 'Let''s implement a simple file logger first, which can be done in one of our
    configuration files. We will add our logger to our /`config/autoload/global.php`
    file as we want it available everywhere in our application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个简单的文件记录器，这可以在我们的配置文件之一中完成。我们将把我们的记录器添加到我们的`/config/autoload/global.php`文件中，因为我们希望它在我们的应用程序的任何地方都可以使用：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That was pretty easy as we can see, and now everywhere we have the `ServiceManager`
    object to our disposal we can get the logger by doing something like the following
    `Controller` (file: `/module/Application/src/Application/Controller/IndexController.php`)
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这很简单，现在我们可以在任何地方使用`ServiceManager`对象来获取记录器，如下面的`Controller`（文件：`/module/Application/src/Application/Controller/IndexController.php`）代码所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing a FirePHP logger
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现FirePHP记录器
- en: The FirePHP logger is the same as the Logger initialization shown before in
    `/config/autoload/global.php` with one difference, and that is `Zend\Log\Writer`
    attached to `Zend\Log\Logger`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FirePHP记录器与之前在`/config/autoload/global.php`中显示的记录器初始化相同，只有一个区别，那就是`Zend\Log\Writer`附加到`Zend\Log\Logger`。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Logging is one of the most underestimated pieces of code that we kind of forget
    to implement. And when we implement it, we forget to make use of it regularly
    enough.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是代码中最被低估的部分之一，我们往往忘记实现它。而且当我们实现它时，我们忘记定期使用它。
- en: We all know that it is important, but for some reason we are hesitant to implement
    it on a regular basis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道这是很重要的，但出于某种原因，我们犹豫不决是否要定期实现它。
- en: What we are going to do is install a logger in our basic Zend Framework 2 application,
    and a more special way of logging with FirePHP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的就是在我们的基本Zend Framework 2应用程序中安装一个记录器，以及使用FirePHP的更特殊记录方式。
- en: Implementing a really simple file logger
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个真正简单的文件记录器
- en: 'As we saw in the preceding `indexAction` method, we have simply put a debug
    statement in our `application.log` file, which will look similar like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在先前的`indexAction`方法中看到的，我们只是简单地在我们的`application.log`文件中放入了一个调试语句，它看起来可能如下所示：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The log methods we can use are `log()`, `info()`, `warn()`, `err()`, and `debug()`,
    if we use `log()`, we need to give it a priority first and then pass the message
    as parameters. As we can also see, assigned to `DEBUG` is the value `7`, this
    refers to the level of priority used. In our case `DEBUG` has priority `7`, but
    there are more priorities:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的记录方法有`log()`、`info()`、`warn()`、`err()`和`debug()`，如果我们使用`log()`，我们需要先给出优先级，然后传递消息作为参数。正如我们也可以看到的，分配给`DEBUG`的值是`7`，这指的是优先级的级别。在我们的情况下，`DEBUG`的优先级是`7`，但还有更多的优先级：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing a FirePHP logger
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现FirePHP记录器
- en: If we now begin logging with the FirePHP writer, we will receive the following
    entries in our Browser console. (Press *F12* in Mozilla Firefox, Chrome, and Microsoft
    Internet Explorer.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在开始使用FirePHP写入器进行记录，我们将在我们的浏览器控制台中看到以下条目。（在Mozilla Firefox、Chrome和Microsoft
    Internet Explorer中按*F12*键。）
- en: '![Implementing a FirePHP logger](img/4841OS_09_01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![实现FirePHP记录器](img/4841OS_09_01.jpg)'
- en: As we can see this gives a quite clear view of the log items sent through the
    browser.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这为我们通过浏览器发送的日志项提供了一个相当清晰的视图。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please note that using the `debug()` log method in Zend Framework 2.2.4 still
    executes and outputs a `trace()` instead of the message we want to display when
    using the FirePHP writer. This is currently reported as a bug, but it hasn't been
    confirmed yet, so we don't know for sure if it will be ever solved.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Zend Framework 2.2.4中使用`debug()`日志方法仍然会执行并输出一个`trace()`，而不是我们使用FirePHP
    writer时想要显示的消息。这目前被报告为一个错误，但尚未得到确认，所以我们不能确定它是否会被解决。
- en: However, using this `debug()` method results in a really (really) big return
    header and it will slow down the response times of a larger application by literally
    minutes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这个`debug()`方法会导致一个非常（非常）大的返回头，并且会通过实际分钟来减慢大型应用程序的响应时间。
- en: One more thing before we move on, please don't use the FirePHP `log()` method
    in a production environment, as everyone (literally) will be able to see what
    and when you logged in and out; and that is something you don't want.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一件事，请勿在生产环境中使用FirePHP的`log()`方法，因为每个人（字面上）都能看到你何时登录和注销，而这并不是你想要的。
- en: About the Logger
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于记录器
- en: The `Log\Logger` holds a collection of methods that can be used to log in a
    standardized fashion. The `Logger` has one or more `Zend\Log\Writer` objects attached
    to it, to which the `Logger` writes to. The `Writer` is the only class that does
    the actual writing to the requested log method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log\Logger`包含了一组可以用来以标准化方式记录的方法。`Logger`有一个或多个`Zend\Log\Writer`对象附加到它上，`Logger`将写入这些对象。`Writer`是唯一一个实际将内容写入请求的日志方法。'
- en: With `Writer\FirePhp`, this is by sending headers to the client browser through
    the response, with the `Writer\Stream` it is a physical file (funny how we use
    physical here isn't it?).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Writer\FirePhp`，这是通过响应向客户端浏览器发送头信息来实现的，而使用`Writer\Stream`则是一个物理文件（有趣的是，我们在这里使用物理，不是吗？）。
- en: Unit testing – why would you do it
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 – 你为什么要做它
- en: Unit testing is a form of testing that has been widely accepted in the programming
    world. Unfortunately a lot of PHP developers still lack the knowledge on how to
    utilize it to their benefit, or they just don't know how to get started. This
    recipe will try to change that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是编程世界中广泛接受的一种测试形式。不幸的是，许多PHP开发者仍然缺乏如何利用它来获得利益的知识，或者他们根本不知道如何开始。这个食谱将尝试改变这一点。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with Unit testing a Zend Framework 2 application, it is required
    that we have PHPUnit 3.7.x installed. We can do this in a couple of different
    ways, but the easiest and most recommended way is by installing it through Composer,
    which comes with the Zend Framework 2 application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用PHPUnit进行单元测试Zend Framework 2应用程序，我们需要安装PHPUnit 3.7.x。我们可以通过几种不同的方式来做这件事，但最简单、最推荐的方式是通过Composer安装，它随Zend
    Framework 2应用程序一起提供。
- en: 'To install PHPUnit through Composer we just need to add the following lines
    to `composer.json`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Composer安装PHPUnit，我们只需将以下行添加到`composer.json`中：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After saving the `composer.json` file, run Composer to update the new requirements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`composer.json`文件后，运行Composer来更新新的需求。
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After a short while, the Composer installer will be complete and we will be
    ready to begin creating our unit tests. We can see that we now have an extra directory
    in our vendor directory called phpunit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间的安装，Composer安装器将完成，我们就可以开始创建我们的单元测试了。我们可以看到，我们现在在vendor目录中有一个额外的目录，名为phpunit。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Before we can show how to really unit test our application, it is best that
    we show off the concept behind it first.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示如何真正进行单元测试我们的应用程序之前，最好先展示其背后的概念。
- en: Pseudo-code examples
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪代码示例
- en: We will now examine a couple of pseudo-code examples that display an effective
    way of coding according to a (sort of) TDD principle (technically it will be PHP,
    but we won't take it too seriously as we just want to show some example).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查几个伪代码示例，这些示例展示了一种根据（某种）TDD原则（技术上将是PHP，但我们不会太认真，因为我们只想展示一些示例）进行有效编码的方法。
- en: For this example we will have a class, called `Person`, with only the `isAdult()`
    method in there. After we have defined the method, we should write our first test
    that should let our initial outcome fail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将有一个名为`Person`的类，其中只包含`isAdult()`方法。在我们定义了该方法之后，我们应该编写我们的第一个测试，这个测试应该让我们的初始结果失败。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we have no code in our method yet, the result will always be null, so this
    test will immediately fail as we expect a false to be returned back at the moment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的方法中还没有代码，结果将始终为null，因此这个测试将立即失败，正如我们预期的那样，此时应该返回`false`。
- en: 'When we execute PHPUnit now, it would (hypothetically) result in the following
    result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在执行PHPUnit时，它将（假设性地）产生以下结果：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Normally seeing a failure would be considered wrong, however in this instance,
    we would know that our method does what we expect it to do: fail! The next step
    is to make the test pass, so let''s add a simple return `false` to our `isAdult`
    definition.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常看到失败会被认为是错误的，然而在这个例子中，我们会知道我们的方法正在做我们期望它做的事情：失败！下一步是让测试通过，所以让我们在我们的`isAdult`定义中添加一个简单的返回`false`。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we know run the test again we will see that the test has now passed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行测试，我们会看到测试已经通过了：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now it is time to continue by making sure that the test fails again, this time
    we want to make sure that we accept a parameter, `$age` and we want this value
    always to be an integer and higher or equal to 18, and if not we want to get `false`
    returned back as result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候继续进行测试，确保测试再次失败，这次我们想要确保我们接受一个参数，`$age`，并且我们希望这个值始终是一个大于或等于18的整数，如果不是，我们希望返回`false`作为结果。
- en: So let's continue and edit the `test` script so that it fails again (never was
    failing so much fun).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们继续并编辑`test`脚本，让它再次失败（从未有失败如此有趣）。
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we now run the test again, we will see that the test fails, which in this
    case triggers us to rewrite the following code so that the test will pass again:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行测试，我们会看到测试失败了，在这种情况下，这会触发我们重写以下代码，以便测试再次通过：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And if we now run the test, the test will pass again, which means we can (if
    we need to) run the cycle again of making the test fail, change the code to let
    it pass again, etcetera, etcetera! The cycle will continue until we are happy
    with the result of the method and it exactly does what we planned it to do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，测试将再次通过，这意味着我们可以（如果需要的话）再次运行测试失败的循环，更改代码让它再次通过，等等！这个循环将继续，直到我们对方法的输出结果满意，并且它确实做了我们计划让它做的事情。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we talk about unit testing, a lot of developers have one of the following
    thoughts about it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论单元测试时，许多开发者对它有以下几种看法：
- en: They simply don't know what it is, or what its use is; or they know they should
    do it, but they tend to not do it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 他们根本不知道它是什么，或者它的用途是什么；或者他们知道他们应该做，但他们往往不做。
- en: Of course there is also the occasional "I don't see any positive side to it"
    kind of developer, but we will just ignore that comment for now.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，偶尔也会有“我看不出它有任何积极的一面”这样的开发者，但我们现在就忽略这个评论。
- en: What is unit testing
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试是什么
- en: Unit testing is the art of testing the smallest testable part of an application.
    Unit tests are divided up in test cases, which are compartmentalized tests that
    should test only one specific part of your code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试应用程序中最小可测试部分的技艺。单元测试被划分为测试用例，这些是隔离的测试，应该只测试你代码的一个特定部分。
- en: This unit test can use other objects through the use of mock objects, fakes
    and method stubs, but the main part is that only one particular piece of code
    should be tested in a unit test at any given time. The idea behind this is that
    we have a small unit test which tests only a small part of the code, so when problems
    occur we don't have to look far and wide to find out where the problem lies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试可以通过使用模拟对象、伪造和存根方法来使用其他对象，但主要部分是，在任何给定时间，单元测试中只应该测试一段特定的代码。这个想法的背后的理念是我们有一个小的单元测试，它只测试代码的一小部分，所以当问题发生时，我们不需要四处寻找问题所在。
- en: In reference to Zend Framework 2 we would usually unit test the models, services
    and controllers but not the html output (unless we are testing the `ViewRenderer`
    perhaps).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考Zend Framework 2时，我们通常会单元测试模型、服务和控制器，但不会测试HTML输出（除非我们在测试`ViewRenderer`）。
- en: When should we test? – before, or after code is written
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应该在什么时候进行测试？——在编写代码之前还是之后
- en: 'In a pure **TDD** (**test-driven development**) point of view, it is a simple
    answer: before. The whole idea of TDD is that a test is written before development
    begins, and therefore it always fails. The reason why it is important that a test
    fails is that we then know that the test we wrote at least fails. If we write
    a test that has never failed, how can we know that it will fail when it actually
    should fail?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯 **TDD**（**测试驱动开发**）的角度来看，答案很简单：在开发之前。TDD 整个理念是，在开发开始之前编写测试，因此它总是失败的。测试之所以重要，是因为我们知道我们编写的测试至少是失败的。如果我们编写了一个从未失败的测试，我们怎么知道它会在实际应该失败时失败呢？
- en: 'Obviously there are also arguments for writing the test afterwards, one of
    them being that we cannot test code that we haven''t designed yet. Although there
    is a point to that argument, personally I don''t view it is a valid one. We can
    write tests beforehand, but that doesn''t mean that we should write the full test
    before the code is written. The idea is to do the following: write a test, let
    it fail, write code to let it pass, and repeat the process from the start again.
    It also forces you to think about the app architecture before you start coding
    your app.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，也有人在编写测试之后进行争论，其中之一是，我们无法测试尚未设计的代码。虽然这个论点有一定道理，但就我个人而言，我认为这不是一个有效的论点。我们可以在事先编写测试，但这并不意味着我们应该在编写代码之前就编写完整的测试。理念是这样的：编写一个测试，让它失败，编写代码让它通过，然后从开始再次重复这个过程。这也迫使你在开始编写应用程序之前就考虑应用程序的架构。
- en: It is a matter of discipline
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是一项纪律问题
- en: Unit testing is a strong matter of discipline, as it requires us to stop being
    eager to code and write the test first. For a lot of developers this means that
    we should throw out our current "muscle-memory" coding and really think what we
    want to code, before we actually start to code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一项严格的纪律问题，因为它要求我们停止急切地编写代码，并先编写测试。对于许多开发者来说，这意味着我们应该摒弃当前的“肌肉记忆”编码，真正思考我们想要编写的内容，然后再开始编写代码。
- en: Of course when we start a new piece of code we have an idea of what we want
    the functionality to do, for example getting records from the database. However
    it is important to think about what we want to get as a return from that functionality.
    Is it an array, or is it a `boolean`, does it throw Exceptions and what if we
    don't get valid parameters? All of these things are questions that are architecture
    related, but are usually not defined beforehand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们开始编写新的代码时，我们有一个关于我们想要的功能实现的想法，例如从数据库中获取记录。然而，考虑我们想要从该功能中获得什么作为返回值是很重要的。是数组吗？还是
    `boolean`？它是否抛出异常？如果我们没有得到有效的参数怎么办？所有这些问题都与架构相关，但通常在事先并没有定义。
- en: Unit testing works only because of a strong discipline in the team. If we were
    the only one in our team that would write the tests for the code, we would surely
    fail in being able to maintain it as other members of our team would (unintentionally
    probably) break our unit tests whenever they would change something in the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试之所以有效，是因为团队中有着严格的纪律。如果我们是我们团队中唯一编写测试代码的人，我们肯定无法维持代码的维护，因为其他团队成员（可能无意中）在修改代码时可能会破坏我们的单元测试。
- en: However, it cannot be under estimated that unit testing is an invaluable part
    of software development, even if done after the code is already written (as you
    can see I am all for writing tests first).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不能低估单元测试在软件开发中的价值，即使是在代码编写之后（正如你所见，我非常支持先编写测试）。
- en: Setting up and using unit testing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和使用单元测试
- en: To start using Unit testing in Zend Framework 2 can be a bit of a hassle. But
    don't worry; help is coming as we fly you through a proper set up of Zend Framework
    2 unit testing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中开始使用单元测试可能会有些麻烦。但别担心；随着我们引导你完成 Zend Framework 2 单元测试的正确设置，帮助即将到来。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with Unit Testing a Zend Framework 2 application, it is required
    that we have PHPUnit 3.7.x installed. We can do this on a couple of different
    ways but the easiest and recommended way is by installing it through Composer
    which comes with the Zend Framework 2 application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Zend Framework 2 应用程序的单元测试，我们需要安装 PHPUnit 3.7.x。我们可以通过几种不同的方式来完成这项工作，但最简单、最推荐的方式是通过
    Composer 来安装，它随 Zend Framework 2 应用程序一起提供。
- en: To install PHPUnit through composer we just need to add the following lines
    to `composer.json`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 composer 安装 PHPUnit，我们只需将以下几行添加到 `composer.json` 文件中。
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After saving the `composer.json` file, run Composer to update the new requirements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 `composer.json` 文件后，运行 Composer 来更新新的需求。
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After a short while the Composer installer will be complete and we will be ready
    to begin creating our unit tests. We can see that we now have an extra directory
    in our vendor directory called `phpunit`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，Composer 安装程序将完成，我们将准备好开始创建我们的单元测试。我们可以看到，现在在我们的 vendor 目录中有一个额外的目录叫做
    `phpunit`。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Setting up unit testing with PHPUnit is fairly simple in Zend Framework 2, and
    fortunately well documented as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中使用 PHPUnit 设置单元测试相当简单，而且幸运的是，它也得到了很好的文档记录。
- en: Setting up the test framework
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置测试框架
- en: 'To get everything to work in order, we need to set up our separate test framework
    first. For that we will need three new files: `Bootstrap.php`, `TestConfig.php`,
    and `phpunit.xml`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切按顺序工作，我们首先需要设置我们独立的测试框架。为此，我们需要三个新文件：`Bootstrap.php`、`TestConfig.php` 和
    `phpunit.xml`。
- en: Because we basically want to test per module (keeping it all separate from each
    other, remember) we need to set this up for every module we are testing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们基本上想要按模块进行测试（记住，要保持它们彼此分离），我们需要为每个测试的模块设置此配置。
- en: First of all we should create the directory called `test` in the root of the
    `module` directory. In that directory we create a file called `phpunit.xml` in
    `/module/Application/test/`, which is used by PHPUnit to determine some configurations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该在 `module` 目录的根目录下创建一个名为 `test` 的目录。在那个目录中，我们在 `/module/Application/test/`
    中创建一个名为 `phpunit.xml` 的文件，该文件由 PHPUnit 用于确定一些配置。
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This first file is used for the general configuration of PHPUnit, and has many
    more options than the ones we showed here, but these are not relevant for our
    setup right here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个文件用于 PHPUnit 的一般配置，比我们在这里展示的选项要多得多，但这些选项对我们当前的设置并不相关。
- en: The next thing we want is to set up the `TestConfig.php` file in `/module/Application/test/`,
    which is a simple configuration file that loads up the most basic configurations
    we need to start up the application and run our code. It is basically the same
    as the normal `application.config.php`, but we need it in a separate file as we
    want to be able to make changes without it affecting the main application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要在 `/module/Application/test/` 中设置 `TestConfig.php` 文件，这是一个简单的配置文件，它加载启动应用程序和运行我们的代码所需的最基本配置。它基本上与正常的
    `application.config.php` 相同，但我们需要将其放在单独的文件中，因为我们希望能够在不影响主应用程序的情况下对其进行更改。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next and last thing to set up in our testing framework is the `Bootstrap.php`
    file in `/module/Application/test/` that we referenced in the `phpunit.xml` file
    as our bootstrap. This bootstrap class is created by *Evan Coury* the primary
    author of the entire ZF2 module system, but we added the commentary to make it
    all a bit clearer of what is going on. It is important for us to know how this
    bootstrap works to ensure we can make optimal use of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试框架中最后要设置的是 `/module/Application/test/` 中的 `Bootstrap.php` 文件，我们在 `phpunit.xml`
    文件中将其作为引导。这个引导类是由整个 ZF2 模块系统的首席作者 *Evan Coury* 创建的，但我们添加了注释，使整个过程更加清晰。了解这个引导的工作原理对我们来说很重要，以确保我们可以最大限度地利用它。
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now let's start by creating the init() method, which will be used later on to
    bootstrap the application so that we can use it to test on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先创建 init() 方法，这个方法将在稍后用于引导应用程序，以便我们可以用它来进行测试。
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Up until now showed the definition of the configuration file, and it is now
    all merged for use by our bootstrap. Next up is the definition of the service
    manager.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了配置文件的定义，现在它已经合并，供我们的引导使用。接下来是服务管理器的定义。
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's the end of our initialization, and as we can see it is pretty straightforward
    what is being done. The bootstrap initialization first read out the configuration
    and then created the service manager. After the service manager was created, we
    used the module manager to load up the modules (and dependencies) we required
    for our tests. Now that we have defined our most important part of the class,
    let's define the rest of the methods that we used in the preceding `init()` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始化到此结束，正如我们所看到的，所做的工作相当直接。引导初始化首先读取配置，然后创建服务管理器。在创建服务管理器之后，我们使用模块管理器加载我们测试所需的模块（及其依赖项）。现在我们已经定义了类最重要的部分，让我们定义在先前的
    `init()` 方法中使用到的其他方法。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we finally set up our testing framework, it is time to write a simple test
    to see if everything works. What we''ll do first is create a small Model (file
    `Company.php`: `/module/Application/src/Application/Model/`), which we are going
    to test.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于设置了测试框架，是时候编写一个简单的测试来看看一切是否正常工作。我们首先要做的是创建一个小的模型（文件 `Company.php`：`/module/Application/src/Application/Model/`），我们将对其进行测试。
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s it, no more coding at this point, as we first need to create our unit
    test (file `CompanyTest.php`: `/module/Application/test/Application/Model/`).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们不需要再进行编码，因为我们首先需要创建我们的单元测试（文件 `CompanyTest.php`：`/module/Application/test/Application/Model/`）。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And there we go, a simple test that does nothing but prints an `I` (which means
    one incomplete test) in the terminal if we were to execute it. As we can see we
    also defined a `@covers` PHPDoc tag, which is always a good idea for the sake
    of good documentation to actually document what method you are testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就得到了一个简单的测试，它除了在终端打印一个 `I`（表示一个不完整的测试）之外，没有做任何事情。如果我们执行它，我们可以看到我们还定义了一个
    `@covers` PHPDoc 标签，这对于良好的文档来说总是一个好主意，实际上记录了你正在测试的方法。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To execute the PHPUnit tests, simple go to the `test` directory and type `phpunit`,
    which will trigger PHPUnit to test every file that ends in `Test.php` like `SomeModelTest.php`
    and look for methods that begin with `test` like `testSomeMethod`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 PHPUnit 测试，只需进入 `test` 目录并输入 `phpunit`，这将触发 PHPUnit 测试以 `Test.php` 结尾的每个文件，如
    `SomeModelTest.php`，并查找以 `test` 开头的方法，如 `testSomeMethod`。
- en: Let's do a simple test now, which tests if our method return value is true or
    not (file `CompanyTest.php` in `/module/Application/test/Application/Model/`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做一个小测试，测试我们的方法返回值是否为真（位于 `/module/Application/test/Application/Model/`
    目录下的 `CompanyTest.php` 文件）。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we now run PHPUnit again, we'll see that it has printed a nice big red `F`
    (which means the test failed) in the terminal. Now we know that the unit test
    fails, we will modify our model (file `Company.php` in `/module/Application/src/Application/Model/`)
    again to make sure it passes again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行 PHPUnit，我们会在终端看到它打印了一个漂亮的红色大写字母 `F`（表示测试失败）。现在我们知道单元测试失败了，我们将再次修改我们的模型（位于
    `/module/Application/src/Application/Model/` 目录下的 `Company.php` 文件），以确保它再次通过。
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we now run PHPUnit again, a `.` (which means that the test passed) simply
    appears in the terminal. We know now that our test worked, and that we can trust
    the outcome of the unit test as well. We can now use this test framework over
    and over again for every other method and module that we write.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行 PHPUnit，终端中会简单地出现一个 `.`（表示测试通过）。我们现在知道测试是有效的，我们可以信任单元测试的结果。现在我们可以反复使用这个测试框架来测试我们编写的每个其他方法和模块。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we did first is set up a small testing framework that would load in anything
    we need for the module that we want to test. After that we wrote a couple of simple
    tests for some code that we wanted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是设置一个小型测试框架，它会加载我们为要测试的模块所需的所有内容。然后我们为一些我们想要的代码编写了一些简单的测试。
- en: The test framework we set up is a test framework that can be used per module
    separately, as it is unwise to make one test framework for the whole application.
    What we are trying to achieve is that our modules are still as independent as
    they can be (considering of course that some modules will have dependencies),
    and that we can test them separately as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的测试框架是一个可以单独用于每个模块的测试框架，因为为整个应用程序创建一个测试框架是不明智的。我们试图实现的是，我们的模块尽可能地独立（当然，考虑到一些模块将具有依赖关系），并且我们可以单独测试它们。
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The framework we've set up is also available in the official documentation,
    which means that there is always support available if we are stuck with something.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的框架也在官方文档中可用，这意味着如果我们遇到困难，总有支持可用。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The PHPUnit XML configuration file options:[http://phpunit.de/manual/3.7/en/appendixes.configuration.html](http://phpunit.de/manual/3.7/en/appendixes.configuration.html)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit XML 配置文件选项：[http://phpunit.de/manual/3.7/en/appendixes.configuration.html](http://phpunit.de/manual/3.7/en/appendixes.configuration.html)
- en: 'The PHPUnit cheat sheet: [https://gist.github.com/loonies/1255249](https://gist.github.com/loonies/1255249)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit 技巧表：[https://gist.github.com/loonies/1255249](https://gist.github.com/loonies/1255249)
