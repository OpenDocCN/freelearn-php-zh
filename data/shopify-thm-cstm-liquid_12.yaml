- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: '[*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), Getting Started
    with Shopify'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第1章*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015)，Shopify入门'
- en: Question 1
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What is the Partners program?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 合作伙伴计划是什么？
- en: Answer
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The Partners program is a platform created by Shopify that assembles people
    from all over the world. Through this platform, we can build new ecommerce stores
    for store owners, design themes, develop apps, refer new clients to Shopify, and
    most importantly, create a development store for us to practice. We can remind
    ourselves of this within the *How to start?* topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 合作伙伴计划是由Shopify创建的一个平台，汇集了来自世界各地的人们。通过这个平台，我们可以为店主构建新的电子商务商店，设计主题，开发应用程序，向Shopify推荐新客户，最重要的是，为我们自己创建一个用于练习的开发商店。我们可以在“如何开始？”主题中提醒自己这一点。
- en: Question 2
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: How can we disable the password protection of the development type store?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何禁用开发类型商店的密码保护？
- en: Answer
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can disable our password protection store by clicking on the **See store
    password** button within the banner on the **Themes** section, located under the
    Online store section, or by selecting the **Online store** and subsequently clicking
    the **Preferences** inside the expanded dropdown. Once inside, we can easily remove
    the password protection on the regular store. However, since our store is in development
    mode, this option is currently disabled. We can remind ourselves of this within
    the *Sidebar* subtopic, in the *Understanding theme structure* topic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击位于“主题”部分横幅中的**查看存储密码**按钮，或者在“在线商店”部分下选择**在线商店**并随后点击展开下拉菜单中的**偏好设置**来禁用我们的密码保护存储。一旦进入，我们可以轻松地移除常规商店的密码保护。然而，由于我们的商店处于开发模式，此选项目前已被禁用。我们可以在“理解主题结构”主题下的**侧边栏**子主题中提醒自己这一点。
- en: Question 3
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the difference between the Layout and Templates directory files?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和模板目录文件有什么区别？
- en: Answer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The **Layout** directory is the main directory of our theme. It contains the
    essential files, and it is where all other files, including the template files,
    will render. The template files are a group of files that allow us to easily create
    and manage the look of multiple pages all at once. We can remind ourselves of
    this within the *Sidebar* subtopic, in the *Understanding theme structure* topic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**布局**目录是我们主题的主要目录。它包含基本文件，并且是所有其他文件（包括模板文件）将渲染的地方。模板文件是一组文件，允许我们一次性轻松创建和管理多个页面的外观。我们可以在“理解主题结构”主题下的**侧边栏**子主题中提醒自己这一点。'
- en: Question 4
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 4
- en: Under what circumstances will the new template file be visible inside the admin
    section of your page?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下，新的模板文件将在你页面的管理员部分可见？
- en: Answer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Considering that the admin side of Shopify can only read values from the currently
    published theme, we must meet two conditions. Besides creating a new template
    file, we also need to ensure that the same template file exists within the currently
    live theme or to publish our duplicate theme live. We can remind ourselves of
    this within the *Templates* subtopic, in the *Understanding theme structure* topic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Shopify的管理端只能从当前发布的主题中读取值，我们必须满足两个条件。除了创建一个新的模板文件外，我们还需要确保相同的模板文件存在于当前正在运行的主题中，或者发布我们的副本主题。我们可以在“理解主题结构”主题下的**模板**子主题中提醒自己这一点。
- en: Question 5
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 5
- en: What type of files and under what conditions will allow us to access the variables
    within the parent file scope?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 什么类型的文件以及在什么条件下允许我们访问父文件作用域内的变量？
- en: Answer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The **Snippets** files allow us to re-use repetitive pieces of code over **Templates**/**Sections**
    by referencing their names. Besides allowing us to re-use parts of code, the **Snippets**
    will enable us to access the variables inside the parent element for as long as
    we pass those variables to the snippet as parameters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段**文件允许我们通过引用它们的名称在**模板**/**部分**中重用重复的代码片段。除了允许我们重用代码的部分外，**片段**还将使我们能够访问作为参数传递给片段的变量所在的父元素内的变量。'
- en: '[*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030), The Basic Flow
    of Liquid'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第2章*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030)，Liquid的基本流程'
- en: Question 1
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What type of delimiter should we use if we are expecting an output as a result?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望输出结果，我们应该使用哪种分隔符？
- en: Answer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we expect output from Liquid code, we should use a double bracket delimiter,
    as we should only use a bracket with a percentage when performing a certain logic.
    We can remind ourselves about this within the *Understanding Liquid and its delimiters*
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望从Liquid代码中获取输出，我们应该使用双括号分隔符，因为我们只有在执行特定逻辑时才应该使用带百分比的括号。我们可以在“*理解Liquid及其分隔符*”部分提醒自己。
- en: Question 2
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2
- en: What will the result of the following conditional be, and why?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件语句的结果是什么，为什么？
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Answer
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Considering that `collection.all_products_count` by default returns a number
    as its value, where the value we are comparing it against is a string since it
    is encapsulated inside the parentheses. Since we cannot compare values of different
    types, the conditional will return `false`, and our message will not be shown.
    We can remind ourselves about this within the *Learning the comparison operators*
    section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`collection.all_products_count`默认返回一个数字作为其值，而我们比较的值是一个字符串，因为它被括号封装。由于我们不能比较不同类型的数据，条件语句将返回`false`，我们的消息将不会显示。我们可以在“*学习比较运算符*”部分提醒自己。
- en: Question 3
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3
- en: What are the two methods to access an item inside an array?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组内部元素有两种方法是什么？
- en: Answer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can access the items inside an array using two methods. The first method
    allows us to use the index position of an item to recover the exact item that
    we are looking for, while the second method allows us to loop over all of the
    items inside an array. We can remind ourselves about this within the *Array* subsection,
    in the *Understand the type of data* section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法来访问数组内部的元素。第一种方法允许我们使用一个项目的索引位置来恢复我们正在寻找的确切项目，而第二种方法允许我们遍历数组中的所有项目。我们可以在“*Array*子节”中提醒自己，在“*理解数据类型*”部分。
- en: Question 4
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题4
- en: What is the correct way of accessing an object using its handle?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用句柄访问对象的方法是什么？
- en: Answer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can access the object using its handle by pluralizing the object's name we
    are trying to access, followed by either a squared bracket (`[]`) or dot (`.`)
    notation. Both methods of accessing the object are correct. However, they each
    have their use. We can remind ourselves about this within the *EmptyDrop* subsection,
    in the *Understand the type of data* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们要访问的对象的名字复数化，然后跟一个方括号（`[]`）或点（`.`）表示法来通过其句柄访问对象。这两种访问对象的方法都是正确的。然而，它们各自有其用途。我们可以在“*EmptyDrop*子节”中提醒自己，在“*理解数据类型*”部分。
- en: Question 5
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题5
- en: What are the two problems inside the following block of code?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块中存在两个问题是什么？
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Answer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Since nil is a special data type that returns an empty value, it does not have
    a visual representation, which is the first problem. We can remind ourselves about
    this within the *Nil* subsection, in the *Understand the type of data* section.
    The second problem is that we have added a hyphen to both sides of our `customer.name`
    output. While the hyphen on the right side of our output will clear the unwanted
    whitespace before the exclamation mark, we have also added a hyphen on the left
    side, removing the spacing between the word "Welcome" and our customer's name.
    We can remind ourselves about this within the *Controlling the Whitespace* section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于nil是一个特殊的数据类型，它返回一个空值，因此它没有可视化的表示，这是第一个问题。我们可以在“*Nil*子节”中提醒自己，在“*理解数据类型*”部分。第二个问题是我们在`customer.name`输出的两侧都添加了一个连字符。虽然输出右侧的连字符会清除感叹号前的多余空格，但我们也在左侧添加了一个连字符，移除了“Welcome”这个词和我们的客户名字之间的空格。我们可以在“*控制空格*”部分提醒自己。
- en: '[*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), Diving into
    Liquid Core with Tags'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)，深入Liquid核心与标签'
- en: Question 1
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1
- en: What parameters should we use inside a `for` loop if we want to show a maximum
    of seven iterations while also skipping the first three iterations?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在循环中显示最多七次迭代，同时跳过前三次迭代，我们应该在`for`循环中使用哪些参数？
- en: Answer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we are looking to create a loop that will skip the first three iterations
    and output a maximum of seven iterations, we should use a combination of the `offset`
    and `limit` parameters. The `offset` tag will allow us to skip any number of iterations,
    depending on the value we assign to it. The `limit` parameter will allow us to
    limit the number of iterations the tag should perform. We can remind ourselves
    of this by revisiting the *for parameters* subsection of the *Iterations tags*
    section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个循环，跳过前三次迭代并输出最多七次迭代，我们应该使用 `offset` 和 `limit` 参数的组合。`offset` 标签将允许我们跳过任何数量的迭代，具体取决于我们分配给它的值。`limit`
    参数将允许我们限制标签应执行的迭代次数。我们可以通过重新查看 *Iterations tags* 部分的 *for parameters* 子部分来提醒自己这一点。
- en: Question 2
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What types of data can we assign to a variable created using the `capture` tag?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `capture` 标签创建的变量分配哪些类型的数据？
- en: Answer
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can assign any type of data to a variable created using the `capture` tag.
    However, a variable created using the `capture` tag will always return string
    data as a result. We can remind ourselves of this by revisiting the *capture*
    subsection of the *Variable tags* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何类型的数据分配给使用 `capture` 标签创建的变量。然而，使用 `capture` 标签创建的变量将始终返回字符串数据作为结果。我们可以通过重新查看
    *Variable tags* 部分的 *capture* 子部分来提醒自己这一点。
- en: Question 3
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What are the two problems in the following block of code?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中存在两个问题是什么？
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Answer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: While using the `liquid` tag allows us to eliminate the brace delimiters within
    the code block we should not remove them from the `liquid` tag. We should place
    an opening brace delimiter with a percentage symbol on the left side of the `liquid`
    tag. The second issue with our code is that we are missing an `echo` tag in front
    of the `product.title`, which replaces the double curly brace delimiters. We can
    remind ourselves of this by revisiting the *The liquid and echo tags* subsection,
    in the *Theme tags* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `liquid` 标签允许我们在代码块中消除花括号分隔符，但我们不应该从 `liquid` 标签中移除它们。我们应该在 `liquid` 标签的左侧放置一个带有百分号的开括号分隔符。我们代码的第二个问题是我们在
    `product.title` 前缺少一个 `echo` 标签，它替换了双大括号分隔符。我们可以通过重新查看 *Theme tags* 部分的 *The liquid
    and echo tags* 子部分来提醒自己这一点。
- en: Question 4
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 4
- en: What approach should we take to modify an HTML-generated product form by replacing
    the existing class attribute with a combination of a string and a variable?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该采取什么方法来修改由 HTML 生成的产品表单，通过替换现有的类属性为一个字符串和变量的组合？
- en: Answer
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Considering that the `form` tag does not accept a combination of strings and
    variables as its parameter, we should first assign these values to a variable
    using the `capture` tag and then pass it to the `form` tag. We can remind ourselves
    of this by revisiting the *form* subsection, under the *Theme tags* section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `form` 标签不接受字符串和变量的组合作为其参数，我们应该首先使用 `capture` 标签将这些值分配给一个变量，然后将其传递给 `form`
    标签。我们可以通过重新查看 *Theme tags* 部分的 *form* 子部分来提醒自己这一点。
- en: Question 5
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 5
- en: What parameter should we use if we want to pass an object from the parent element?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从父元素传递一个对象，我们应该使用哪个参数？
- en: Answer
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The only tag that allows us to pass down objects from the parent element is
    the `render` tag, and even then, we can only do so by using the `with` and `as`
    parameters. We should set the value of the `with` parameter to the object we are
    looking to pass, and the value of the `as` parameter should be the name of the
    variable we will use within our snippet file. We can remind ourselves of this
    by revisiting the *render* subsection, in the *Theme tags* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一允许我们从父元素传递对象的标签是 `render` 标签，即使如此，我们也只能通过使用 `with` 和 `as` 参数来实现。我们应该将 `with`
    参数的值设置为我们要传递的对象，而 `as` 参数的值应该是我们在片段文件中将使用的变量名。我们可以通过重新查看 *Theme tags* 部分的 *render*
    子部分来提醒自己这一点。
- en: '[*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), Diving into
    Liquid Core with Objects'
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第四章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，使用对象深入液态核心'
- en: Question 1
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What are we missing in the following block of code to make `form` functional?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们缺少什么来使 `form` 功能化？
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Answer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: While we have introduced the `id` variant, which is necessary to create a working
    product form, we didn't use a `name` attribute with `id` as its value. We can
    remind ourselves of how this works by going back to the *Custom collection* subtopic,
    in the *Working with global objects* section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经介绍了必要的 `id` 变体来创建一个工作的产品表单，但我们没有使用 `name` 属性，其值为 `id`。我们可以通过回到 *自定义集合*
    子主题，在 *与全局对象一起工作* 部分来提醒自己这是如何工作的。
- en: Question 2
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个问题
- en: How can we get access to the `product` object through a link defined in the
    admin navigation?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过在管理导航中定义的链接来获取访问 `product` 对象的权限？
- en: Answer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: To access the `product` object through the navigation menu, we will need to
    use a `for` tag to iterate over the navigation menu. Once we have found which
    menu item is `product_type`, we can use that menu item, followed by the `object`
    attribute, to access that specific `product` object. We can remind ourselves of
    how this works by going back to the *Custom navigation* subtopic, in the *Working
    with global objects* section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过导航菜单访问 `product` 对象，我们需要使用一个 `for` 标签来遍历导航菜单。一旦我们找到了哪个菜单项是 `product_type`，我们就可以使用那个菜单项，然后是
    `object` 属性，来访问那个特定的 `product` 对象。我们可以通过回到 *自定义导航* 子主题，在 *与全局对象一起工作* 部分来提醒自己这是如何工作的。
- en: Question 3
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三个问题
- en: What are the two approaches to accessing single and multiple `metafield` objects?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 访问单个和多个 `metafield` 对象的两种方法是什么？
- en: Answer
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can access the single `metafield` object using the object of the page we
    are looking to recover `metafield` from, followed by the `metafields` object,
    followed by `namespace`, and finally followed by `key`. If we are looking to recover
    multiple `metafields` objects, we will need to use a `for` tag to iterate over
    all the metafields with their namespace. We can remind ourselves of how this works
    by going back to the *Improving the workflow with metafields* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问我们想要恢复 `metafield` 的页面对象，然后是 `metafields` 对象，然后是 `namespace`，最后是 `key`
    来访问单个 `metafield` 对象。如果我们想要恢复多个 `metafields` 对象，我们需要使用一个 `for` 标签来遍历所有具有其命名空间的元字段。我们可以通过回到
    *使用元字段改进工作流程* 部分来提醒自己这是如何工作的。
- en: Question 4
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四个问题
- en: What adjustment do we need to make to the input element if we were looking to
    capture the `line_item` value and hide it on the checkout page?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要捕获 `line_item` 值并在结账页面上隐藏它，我们需要对输入元素进行什么调整？
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Answer
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we were looking to capture the `line_item` value, we would need to introduce
    an underscore as a first character inside the square bracket. By introducing this
    underscore within the `line_item` input, we will automatically hide the specific
    `line_item` from the checkout page. However, this will not hide it on the cart
    page. The cart page will require some manual adjustments. We can remind ourselves
    of how this works by going back to the *Custom navigation* subtopic, in the *Working
    with global objects* section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要捕获 `line_item` 值，我们需要在方括号内引入一个下划线作为第一个字符。通过在 `line_item` 输入中引入这个下划线，我们将自动隐藏特定的
    `line_item`，使其不在结账页面上显示。然而，这不会在购物车页面上隐藏它。购物车页面需要一些手动调整。我们可以通过回到 *自定义导航* 子主题，在
    *与全局对象一起工作* 部分来提醒自己这是如何工作的。
- en: '[*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097), Diving into
    Liquid Core with Filters'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第五章*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097)，使用过滤器深入液态核心'
- en: Question 1
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个问题
- en: Suppose that we have an array named `product_handles` with handles of 30 products.
    What issue in the following code would prevent us from outputting the images of
    all 30 products successfully?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `product_handles` 的数组，包含30个产品的句柄。以下代码中哪个问题会阻止我们成功输出所有30个产品的图片？
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Answer
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Since we are looking to output more than 20 products, in this case, 30 products,
    we cannot use the `all_products` object, as the `all_products` object has a limitation
    that we can only call it 20 times on a single page. If we are looking to recover
    data from more than 20 products, we need to assign them to a collection and then
    perform a loop over those products. We can remind ourselves of the `all_products`
    object by visiting the *Working with HTML and URL filters* section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要输出超过20个产品，在这种情况下，30个产品，我们不能使用 `all_products` 对象，因为 `all_products` 对象有一个限制，我们只能在单页上调用它20次。如果我们想要从超过20个产品中恢复数据，我们需要将它们分配到一个集合中，然后对这些产品进行循环。我们可以通过访问
    *使用HTML和URL过滤器一起工作* 部分来提醒自己 `all_products` 对象。
- en: Question 2
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个问题
- en: Why is only using the `model_viewer_tag` tag not recommended when creating the
    product media gallery?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在创建产品媒体库时不推荐仅使用 `model_viewer_tag` 标签？
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Answer
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: While `model_viewer_tag` will correctly output the necessary HTML media tag
    for each media type, we should only use `model_viewer_tag` as a fallback if all
    other media tags fail to render the proper tag. Using `model_viewer_tag` will
    prevent us from including any of the specific parameters for each `media` tag.
    We can remind ourselves of the `media` object by looking over one of the previous
    projects we have completed in this chapter, enhancing the product media gallery.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`model_viewer_tag`将正确输出每种媒体类型的必要HTML媒体标签，但我们应仅在所有其他媒体标签无法渲染正确标签时才使用`model_viewer_tag`作为后备。使用`model_viewer_tag`将阻止我们包括每个`media`标签的任何特定参数。我们可以通过回顾本章中我们完成的一个先前项目，增强产品媒体库，来提醒自己`media`对象。
- en: Question 3
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3
- en: Which filter could we use if we were looking to access an item at a specific
    location inside the array?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在数组中访问特定位置的项，我们可以使用哪个过滤器？
- en: Answer
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we are looking to access an item at a specific location, we will need to
    use an array type filter named `index`. Using the `index` filter, we can access
    the specified index location in an array and return its value. We can remind ourselves
    of the index parameter by looking over one of the previous projects we have completed
    in this chapter, product accordions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要访问特定位置的项，我们需要使用一个名为`index`的数组类型过滤器。使用`index`过滤器，我们可以访问数组中的指定索引位置并返回其值。我们可以通过回顾本章中我们完成的一个先前项目，产品折叠面板，来提醒自己索引参数。
- en: Question 4
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题4
- en: What filter can we use to quickly update any occurrence of a string value inside
    the theme files?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用哪个过滤器来快速更新主题文件中字符串值的任何出现？
- en: Answer
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: To easily update any occurrence of a string value, we will need to use the t
    (translation) filter. By defining the translation keys, we can quickly update
    or even translate any string value without the need to update the hardcoded string
    values across multiple files manually.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松更新字符串值的任何出现，我们需要使用t（翻译）过滤器。通过定义翻译键，我们可以快速更新或甚至翻译任何字符串值，而无需手动更新多个文件中的硬编码字符串值。
- en: '[*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), Configuring
    the Theme Settings'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第6章*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116)，配置主题设置'
- en: Question 1
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1
- en: What are the two types of input settings?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输入设置有两种类型吗？
- en: Answer
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The first set of settings is called basic input types, and it consists of six
    types of settings, which allow us to output basic HTML input elements through
    which we can dynamically output certain content. The second set of settings, otherwise
    called specialized settings, allows us to generate specialized selector type fields
    to access various objects through the store and output their content using their
    attributes. We can remind ourselves of the basic and specialized input types of
    settings by visiting the *Basic input types* and *Specialized input settings*
    sections in [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), *Configuring
    the Theme Settings*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组设置被称为基本输入类型，它由六种设置组成，使我们能够输出基本的HTML输入元素，通过这些元素我们可以动态地输出某些内容。第二组设置，也称为专用设置，使我们能够生成专用选择器类型字段，通过存储访问各种对象，并使用它们的属性输出其内容。我们可以通过访问[*第6章*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116)中的*基本输入类型*和*专用输入设置*部分来提醒自己设置的基本和专用输入类型。
- en: Question 2
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2
- en: What's the issue that will cause an error with the following piece of code?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将导致错误的问题是什么？
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Answer
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: While the code structure is correct, we have accidentally included an extra
    comma after the last attribute inside the text setting type, which will cause
    a JSON error and prevent us from saving the changes. We can remind ourselves of
    the strict JSON format by visiting the *Basic JSON settings* section in [*Chapter
    6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), *Configuring the Theme Settings*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码结构是正确的，但我们不小心在文本设置类型中的最后一个属性后面多加了一个逗号，这将导致JSON错误并阻止我们保存更改。我们可以通过访问[*第6章*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116)中的*基本JSON设置*部分来提醒自己严格的JSON格式。
- en: Question 3
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3
- en: How can we include a custom font file within Shopify and use it throughout the
    theme editor?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Shopify中包含一个自定义字体文件并在主题编辑器中使用它？
- en: Answer
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: While `font_picker` allows us to access a significant number of fonts within
    Shopify, we have no way of including the custom font in this library. To include
    a custom set of fonts, we will have to use a `select` input type of settings,
    where we can manually create a list of fonts we wish to include. We can remind
    ourselves of how to include custom fonts by visiting *The select input* subsection
    in the *Basic input types* section from [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Configuring the Theme Settings*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`font_picker`允许我们在Shopify中访问大量字体，但我们无法将自定义字体包含在这个库中。要包含一组自定义字体，我们必须使用设置中的`select`输入类型，在那里我们可以手动创建一个我们希望包含的字体列表。我们可以通过访问*选择输入*子部分来提醒自己如何包含自定义字体，该子部分位于*基本输入类型*部分中的[*第6章*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116)，*配置主题设置*。
- en: Question 4
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题4
- en: What are the two issues that will prevent us from executing the following piece
    of code?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哪两个问题会阻止我们执行以下代码片段？
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Answer
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Considering that each `range` slider can have a maximum of 100 steps, the first
    issue is that the `min` and `max` attribute values are too far apart, which we
    can resolve by decreasing one of the two values so that they do not have more
    than 100 steps. An alternative solution is to increase `step` to a higher value,
    consequently reducing the number of steps between the `min` and `max` values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到每个`range`滑块最多可以有100个步骤，第一个问题是`min`和`max`属性值相差太远，我们可以通过减少这两个值中的一个来解决，这样它们就不会超过100个步骤。另一种解决方案是将`step`增加到更高的值，从而减少`min`和`max`值之间的步骤数。
- en: The second issue is that the `default` attribute value is currently exceeding
    the `max` attribute value. We can resolve this by decreasing the `default` value
    or increasing the `max` attribute value. After ensuring that the `default` attribute
    value does not exceed the `max` value, we also need to ensure that the `default`
    value is also higher than the `min` attribute value. We can remind ourselves of
    the `range` type setting format by visiting *The range input* subsection in the
    *Basic input types* section from [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Configuring the Theme Settings*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是`default`属性值目前超过了`max`属性值。我们可以通过减少`default`值或增加`max`属性值来解决这个问题。在确保`default`属性值不超过`max`值之后，我们还需要确保`default`值也高于`min`属性值。我们可以通过访问*范围输入*子部分来提醒自己`range`类型设置格式，该子部分位于*基本输入类型*部分中的[*第6章*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116)，*配置主题设置*。
- en: '[*Chapter 7*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131), Working with
    Static and Dynamic Sections'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第7章*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131)，处理静态和动态部分'
- en: Question 1
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1
- en: What is the main difference between the static and dynamic sections?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 静态部分和动态部分的主要区别是什么？
- en: Answer
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The main difference between the static and dynamic sections is that we can only
    add the dynamic section to the JSON templates and the home page using the **Add
    section** button inside the theme editor. Additionally, we can repeat this any
    number of times with different content.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 静态部分和动态部分的主要区别在于，我们只能通过主题编辑器内的**添加部分**按钮将动态部分添加到JSON模板和主页。此外，我们可以重复此操作任意次数，使用不同的内容。
- en: On the other hand, the static section needs to be included manually inside a
    theme template using the `section` tag. We can include the same static section
    inside multiple templates. However, each section will display the same content
    as we can only have one instance of a static section. We can remind ourselves
    of static and dynamic sections by visiting the *Static versus dynamic sections*
    section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态部分需要手动使用`section`标签包含在主题模板中。我们可以在多个模板中包含相同的静态部分。然而，每个部分将显示相同的内容，因为我们只能有一个静态部分的实例。我们可以通过访问*静态与动态部分*部分来提醒自己静态和动态部分。
- en: Question 2
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2
- en: What object can we use to access the block input value? Write some code that
    will allow us to access the specific `blocks` module input value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用什么对象来访问块输入值？编写一些代码，使我们能够访问特定的`blocks`模块输入值。
- en: Answer
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'We can access the block''s input value through the `section` object and combine
    it with the `blocks` attribute, which will return an array of block objects:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`section`对象访问块的输入值，并将其与`blocks`属性结合，这将返回一个块对象的数组：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can remind ourselves how to access the block input types by visiting the
    *Building with blocks* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问*使用块构建*部分来提醒自己如何访问块输入类型。
- en: Question 3
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3
- en: What is the difference between the `limit` and `max_blocks` attributes?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 和 `max_blocks` 属性之间的区别是什么？'
- en: Answer
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The main difference between the `limit` and `max_blocks` attributes is that
    the `limit` attribute only allows us to limit how many times we can repeat a particular
    block type. The `max_blocks` attribute, on the other hand, allows us to limit
    how many blocks we can include inside a particular section, regardless of the
    block type. We can remind ourselves how to use the `limit` and `max_blocks` attributes
    and the differences between the two by visiting the *Building with blocks* and
    *The max_blocks attribute* sections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 和 `max_blocks` 属性之间的主要区别在于，`limit` 属性只允许我们限制重复特定块类型的次数。另一方面，`max_blocks`
    属性允许我们限制在特定部分内可以包含的块的数量，而不考虑块类型。我们可以通过访问 *使用块构建* 和 *max_blocks 属性* 部分来提醒自己如何使用
    `limit` 和 `max_blocks` 属性以及两者之间的区别。'
- en: Question 4
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 4
- en: How can we apply section-specific CSS styling?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何应用特定部分的 CSS 样式？
- en: Answer
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we need to include a section-specific CSS, we can do this using the `{% style
    %}{% endstyle %}` tag, which will allow us to use Liquid code. However, besides
    the `style` tag, we will also need to define a unique identifier that we will
    call later as the selector. We can do this using the `section` object and `id`
    attribute, which will return a dynamic ID for the dynamic section or a section
    filename for the static section. We can remind ourselves how to create section-specific
    CSS by visiting *The style tag* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要包含特定部分的 CSS，我们可以使用 `{% style %}{% endstyle %}` 标签，这将允许我们使用 Liquid 代码。然而，除了
    `style` 标签之外，我们还需要定义一个唯一的标识符，稍后我们将用它作为选择器。我们可以使用 `section` 对象和 `id` 属性来完成这个操作，这将返回动态部分的动态
    ID 或静态部分的文件名。我们可以通过访问 *样式标签* 部分来提醒自己如何创建特定部分的 CSS。
- en: 'Please note that the solutions for all the four projects are available on GitHub:
    [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有四个项目的解决方案都可在 GitHub 上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects)
