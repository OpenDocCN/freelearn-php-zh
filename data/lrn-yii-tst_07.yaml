- en: Chapter 7. Having Fun Doing Browser Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。享受浏览器测试的乐趣
- en: 'We have finally arrived at the last stage of testing: **acceptance testing**.
    This is the topmost way of testing your application with Codeception in Yii.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了测试的最后阶段：**验收测试**。这是使用 Codeception 在 Yii 中测试应用程序的最高方式。
- en: As we saw in the initial chapters , functional and acceptance tests are quite
    similar in form and implementation, so you won't see anything particularly new
    in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在初始章节中看到的，功能测试和验收测试在形式和实现上相当相似，所以你在这个章节中不会看到任何特别新的内容。
- en: It is important to grasp the nature of the tests that we are going to create.
    We can recall from [Chapter 6](ch06.html "Chapter 6. Testing the API – PHPBrowser
    to the Rescue"), *Testing the API – PHPBrowser to the Rescue*, that functional
    tests are used to ensure the technical correctness of what we've built from a
    higher standpoint than unit tests. Whereas acceptance tests are the best way of
    ensuring that the acceptance criteria that were defined at the very beginning
    are still standing after everything is implemented and put together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握我们将要创建的测试的本质非常重要。我们可以从[第 6 章](ch06.html "第 6 章。测试 API – PHPBrowser 来拯救")，*测试
    API – PHPBrowser 来拯救*中回忆起，功能测试用于确保我们从更高的角度对所构建的内容进行技术正确性验证，这比单元测试更为重要。而验收测试是确保在所有内容实施并整合后，最初定义的验收标准仍然有效度的最佳方式。
- en: In this chapter, we are going to review the existing tests, install and configure
    **Selenium,** and then implement a small feature that will tie everything together
    with the work that has already been done.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾现有的测试，安装和配置 **Selenium**，然后实现一个小功能，将所有已经完成的工作结合起来。
- en: 'In this chapter, we will discuss two main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两个主要主题：
- en: Introducing Selenium WebDriver
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Selenium WebDriver
- en: Creating acceptance tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建验收测试
- en: Introducing Selenium WebDriver
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Selenium WebDriver
- en: Yii is shipped with some acceptance tests. They cover the same elements as the
    functional tests that we've already seen. The only difference between these two
    tests is technical, and by looking at the configuration you can see that they've
    been configured to run with PHPBrowser. This setup may be good enough for you,
    or it may even be better because PHPBrowser runs faster than the available acceptance
    testing suites.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 随带了一些验收测试。它们涵盖了我们已经看到的相同元素。这两个测试之间的唯一区别是技术性的，通过查看配置，你可以看到它们已经被配置为使用 PHPBrowser
    运行。这种设置可能对你来说已经足够好，或者甚至更好，因为 PHPBrowser 的运行速度比可用的验收测试套件要快。
- en: Setting aside PHPBrowser, which we've covered in [Chapter 6](ch06.html "Chapter 6. Testing
    the API – PHPBrowser to the Rescue"), *Testing the API – PHPBrowser to the Rescue*,
    Codeception can be used with other testing suites, which can perform more realistic
    frontend tests, including the JavaScript interaction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在[第 6 章](ch06.html "第 6 章。测试 API – PHPBrowser 来拯救")，*测试 API – PHPBrowser
    来拯救*中已经介绍过的 PHPBrowser 之外，Codeception 可以与其他测试套件一起使用，这些套件可以执行更真实的端到端测试，包括 JavaScript
    交互。
- en: Two of the choices you can have are Selenium WebDriver and PhantomJS. We won't
    touch PhantomJS, and it should be sufficient to know that it is a headless browser
    testing suite, which uses the WebDriver interface definition.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择的两个选项是 Selenium WebDriver 和 PhantomJS。我们不会涉及 PhantomJS，但你应该知道它是一个无头浏览器测试套件，它使用
    WebDriver 接口定义。
- en: Selenium WebDriver is also known as Selenium 2.0 + WebDriver. Together with
    Cucumber, it is probably the most well-known frontend testing tool available.
    Their use has been improved by some big companies, such as Google. They are stable
    and have lots of features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 也被称为 Selenium 2.0 + WebDriver。与 Cucumber 一起，它可能是最知名的端到端测试工具。它们的使用已经被一些大公司，如
    Google，所改进。它们稳定且功能丰富。
- en: This is a somewhat natural evolution of Selenium 1.0, which had limitations,
    such as using JavaScript for interacting with web pages. For this reason, it was
    running on the JavaScript sandbox. This meant that, in order to get around the
    same-origin policy, it had to run in conjunction with a Selenium RC server, which
    had some issues with the browser setup.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Selenium 1.0 的某种自然演变，Selenium 1.0 存在一些限制，例如使用 JavaScript 与网页交互。因此，它运行在 JavaScript
    沙盒中。这意味着，为了绕过同源策略，它必须与 Selenium RC 服务器一起运行，这导致了一些与浏览器设置相关的问题。
- en: Now the Selenium Server has replaced the RC, while remaining retro-compatible
    and supporting WebDriver natively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Selenium 服务器已经取代了 RC，同时保持向后兼容并原生支持 WebDriver。
- en: WebDriver uses a native implementation of the browser to interact with it. This
    means that it might not always be available for a specific combination of language
    /device. However, it provides the best flexibility for controlling a page without
    needing emulation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 使用浏览器的本地实现与之交互。这意味着它可能并不总是适用于特定的语言/设备组合。然而，它提供了在不进行模拟的情况下控制页面的最佳灵活性。
- en: Codeception uses a PHP implementation called php-webdriver, which was developed
    by Facebook; its source code and issue tracker can be found at [https://github.com/facebook/php-webdriver](https://github.com/facebook/php-webdriver).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Codeception 使用由 Facebook 开发的 PHP 实现，称为 php-webdriver；其源代码和问题跟踪器可以在 [https://github.com/facebook/php-webdriver](https://github.com/facebook/php-webdriver)
    找到。
- en: In its simplest implementation and configuration, the Selenium Server just listens
    for calls as a service on a specific machine, and fires up the browser on the
    request to perform the tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单实现和配置中，Selenium 服务器仅作为特定机器上的服务监听调用，并在请求执行测试时启动浏览器。
- en: So, as a first step, we need to install the Selenium Server, run it, configure
    it in Codeception, adjust the already existing tests such that they work with
    it, and then add the new tests to it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为第一步，我们需要安装 Selenium 服务器，运行它，在 Codeception 中配置它，调整现有的测试以便它们能够与之协同工作，然后向其中添加新的测试。
- en: Installing and running Selenium Server
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 Selenium 服务器
- en: From version 1.7 onwards, Codeception includes the out-of-the-box php-webdriver
    library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.7 版本开始，Codeception 包含了现成的 php-webdriver 库。
- en: As reported in the documentation, which can be found either from Codeception
    ([http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html](http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html))
    or from the official page of Selenium ([http://docs.seleniumhq.org/docs/03_webdriver.jsp](http://docs.seleniumhq.org/docs/03_webdriver.jsp)),
    you need to download the server binary and then run it on the machine from, which
    you intend to run your browser.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档所述，这些文档可以从 Codeception ([http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html](http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html))
    或 Selenium 的官方网站 ([http://docs.seleniumhq.org/docs/03_webdriver.jsp](http://docs.seleniumhq.org/docs/03_webdriver.jsp))
    获取，您需要下载服务器二进制文件，然后在您打算运行浏览器的机器上运行它。
- en: Head to [http://www.seleniumhq.org/download/](http://www.seleniumhq.org/download/)
    and download the latest version of the software. In my case, it would be `selenium-server-standalone-2.44.0.jar`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.seleniumhq.org/download/](http://www.seleniumhq.org/download/)
    并下载软件的最新版本。在我的情况下，它将是 `selenium-server-standalone-2.44.0.jar`。
- en: 'Where you save it doesn''t matter because once it starts, its server will be
    listening to any network interface:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你保存它的位置并不重要，因为一旦它启动，它的服务器将监听任何网络接口：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring Yii to work with Selenium
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Yii 以与 Selenium 协同工作
- en: 'In order to have Codeception automatically pick up and use WebDriver, we need
    to adjust our acceptance suite configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Codeception 自动获取并使用 WebDriver，我们需要调整我们的验收套件配置：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a straightforward process. We need to replace the PHPBrowser module
    with WebDriver and configure it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的过程。我们需要用 WebDriver 替换 PHPBrowser 模块，并对其进行配置。
- en: '`url` (required): This is the hostname used to connect to your application
    to perform the tests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`（必需）：这是用于连接到您的应用程序以执行测试的主机名。'
- en: '`browser` (required): This will specify the browser that you want to use. Some
    other drivers are also available for mobile phones (Android and iOS), and more
    information about these can be obtained from the online Selenium documentation,
    available at [http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers](http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser`（必需）：这将指定您想要使用的浏览器。还有一些其他驱动程序适用于手机（Android 和 iOS），更多关于这些的信息可以从在线 Selenium
    文档中获得，该文档可在 [http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers](http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers)
    找到。'
- en: '`host`: This key specifies the machine that will run the Selenium Server. By
    default, it will connect to your localhost. For example, I am using the VirtualBox
    host machine IP address. You can also specify the port and by default, it will
    use `4444`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：此键指定将运行 Selenium 服务器的机器。默认情况下，它将连接到您的本地主机。例如，我正在使用 VirtualBox 主机机的 IP
    地址。您也可以指定端口号，默认情况下，它将使用 `4444`。'
- en: '`restart`: This tells WebDriver to reset a session when a test is performed.
    This is particularly handy if you don''t want a state to be carried over from
    one test to another. For instance, you can use this when you need to (re)set the
    cookies to test the auto login functionality.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：这告诉 WebDriver 在执行测试时重置会话。如果你不希望状态从一个测试传递到另一个测试，这特别有用。例如，当你需要（重新）设置
    cookies 来测试自动登录功能时，可以使用此功能。'
- en: '`window_size`: This just specifies the size of the window.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window_size`：这仅指定窗口的大小。'
- en: There are other options, some of which will be quite handy for testing with
    multiple browsers. In particular, you have the ability to set the desired capabilities
    for Selenium 2.0, such as being able to pass a specific profile for the browser
    (quite handy when performing regression testing) and so on. More information about
    the WebDriver module, albeit not as much as I'd love to see, can be found on the
    Codeception documentation page at [http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些选项，其中一些在测试多个浏览器时非常有用。特别是，你可以设置 Selenium 2.0 的期望能力，例如能够传递浏览器的特定配置文件（在执行回归测试时非常有用）等等。有关
    WebDriver 模块的信息，尽管不是我想看到的那么多，可以在 Codeception 文档页面上找到，网址为 [http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver)。
- en: Implementing WebDriver-led tests
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现由 WebDriver 引导的测试
- en: Before we start implementing the interface that will hook into the API, which
    we implemented in [Chapter 6](ch06.html "Chapter 6. Testing the API – PHPBrowser
    to the Rescue"), *Testing the API – PHPBrowser to the Rescue*, it would be quite
    useful to look at the existing acceptance tests and see if there's anything new
    that we need to take into consideration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现将挂钩到 API 的接口之前，该 API 我们在 [第 6 章](ch06.html "第 6 章。测试 API – PHPBrowser
    来拯救") 中实现，*测试 API – PHPBrowser 来拯救*，查看现有的验收测试并查看是否有任何新内容需要我们考虑将会非常有用。
- en: 'You will find four tests: `HomeCept`, `AboutCept`, `LoginCept`, and `ContactCept`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到四个测试：`HomeCept`、`AboutCept`、`LoginCept` 和 `ContactCept`。
- en: As stated previously, the syntax is not unusual, and we can see that the level
    of knowledge of the underlying structure is more limited than the functional tests
    that we've covered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，语法并不罕见，我们可以看到对底层结构的了解程度比我们已涵盖的功能测试要有限。
- en: The important thing that we need to stress on once again is that all the actions
    that our `AcceptanceTester` can perform on the page, such as `click()`, `fillField(),`
    and the assertions that it can perform, such as `see()`, `seeLink()` and so on,
    accept a so-called Locator as one of its actual parameters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次强调的重要事情是，我们的 `AcceptanceTester` 可以在页面上执行的所有操作，例如 `click()`、`fillField()`，以及它可以执行的所有断言，例如
    `see()`、`seeLink()` 等，都接受所谓的定位器作为其实际参数之一。
- en: The Locator parameter can be either a string or an array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定位参数可以是字符串或数组。
- en: 'When passed as a string or a **fuzzy locator,** as it is called in the Codeception
    terminology, it tries to guess what you''re looking for by formally going through
    a series of steps. If you write `click(''foo'')`, then it will do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串或所谓的**模糊定位器**（在 Codeception 术语中称为）传递时，它将通过正式走过一系列步骤来猜测你正在寻找的内容。如果你编写 `click('foo')`，那么它将执行以下操作：
- en: It tries to find the element with the ID `#foo`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它试图找到具有 ID `#foo` 的元素。
- en: It tries to find the class `.foo`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它试图找到类 `.foo`。
- en: Then, it interprets it as an XPath expression.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将其解释为 XPath 表达式。
- en: Finally, it will throw an `ElementNotFound` exception.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将抛出 `ElementNotFound` 异常。
- en: You can be more prescriptive when using the array notation or a **strict locator**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用数组表示法或**严格定位器**时，你可以更加具体。
- en: '`[''id'' => ''foo'']` matches `<div id="foo">`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''id'' => ''foo'']` 匹配 `<div id="foo">`'
- en: '`[''name'' => ''foo'']` matches `<div name="foo">`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''name'' => ''foo'']` 匹配 `<div name="foo">`'
- en: '`[''css'' => ''input[type=input][value=foo]'']` matches `<input type="input"
    value="foo">`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''css'' => ''input[type=input][value=foo]'']` 匹配 `<input type="input" value="foo">`'
- en: '`[''xpath'' => "//input[@type=''submit''][contains(@value, ''foo'')]"]` matches
    `<input type="submit" value="foobar">`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''xpath'' => "//input[@type=''submit''][contains(@value, ''foo'')]"]` 匹配
    `<input type="submit" value="foobar">`'
- en: '`[''link'' => ''Click here'']` matches `<a href="google.com">Click here</a>`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''link'' => ''Click here'']` 匹配 `<a href="google.com">Click here</a>`'
- en: '`[''class'' => ''foo'']` matches `<div class="foo">`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''class'' => ''foo'']` 匹配 `<div class="foo">`'
- en: The preceding examples have been taken from the Codeception documentation, which
    can be found at [http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例取自Codeception文档，可以在[http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver)找到。
- en: 'This explains clearly how to interact with the webpage. Now, the other important
    bit can be found in the already existing tests, such as `LoginCept` and `ContactCept`.
    Here, right before asserting the presence of the validation errors, we have the
    following condition-led statement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地说明了如何与网页进行交互。现在，其他重要的部分可以在现有的测试中找到，例如`LoginCept`和`ContactCept`。在这里，在断言验证错误的存在之前，我们有以下条件语句：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Selenium introduces two types of wait: an implicit one and an explicit one.
    These cause the information to be fetched from the server, and then this information
    is interpreted and rendered.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium引入了两种等待类型：隐式等待和显式等待。这会导致从服务器获取信息，然后对这些信息进行解释和渲染。
- en: The implicit wait can be configured in the `acceptance.suite.yml` file, and
    it silently tells Selenium to poll for *X* seconds if the element it's looking
    for is not immediately available. By default, no implicit wait is set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式等待可以在`acceptance.suite.yml`文件中进行配置，并且它会静默地告诉Selenium在它寻找的元素不可立即获得时，每隔*X*秒进行轮询。默认情况下，没有设置隐式等待。
- en: The explicit wait is similar to the preceding code snippet. Doing a simple `$I->wait(X)`
    triggers a `sleep()`, and allows the browser to perform the required operation.
    For example, it would help the browser in completing animations or finishing fetching
    and manipulating the server-side data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 显式等待与前面的代码片段类似。执行简单的`$I->wait(X)`会触发`sleep()`，并允许浏览器执行所需的操作。例如，它可以帮助浏览器完成动画或完成从服务器端获取和操作数据的操作。
- en: There are other ways in which you can wait for something, and some of these
    ways can be a little more proactive, such as `waitForElement()`, `waitForElementChange()`,
    `waitForElementVisible()` and `waitForElementNotVisible()`. All these methods
    take a locator, using the aforementioned format, and a timeout in seconds as parameters.
    We will see how we can use these later on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有其他等待某种东西的方法，其中一些方法可能更加积极主动，例如`waitForElement()`、`waitForElementChange()`、`waitForElementVisible()`和`waitForElementNotVisible()`。所有这些方法都接受一个定位器，使用上述格式，以及以秒为单位的超时作为参数。我们将在稍后看到如何使用这些方法。
- en: There are other methods provided by the WebDriver Codeception module that you
    can use, along with the ability to debug your tests, in case something doesn't
    go as you want.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver Codeception模块还提供了其他方法，您可以在调试测试的同时使用这些方法，以防事情没有按照您的预期进行。
- en: 'Now, let''s try to run the available tests and see them pass:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行可用的测试并查看它们通过：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on which machine you'll be using for running these tests, their speed
    will change sensibly, although it will never be as fast as it's when performing
    unit tests, mostly because the whole browser stack has to be started for running
    these tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您将用于运行这些测试的机器，它们的速度将会有所变化，尽管它永远不会像执行单元测试那样快，这主要是因为整个浏览器堆栈必须启动才能运行这些测试。
- en: You will briefly see the browser opening and closing several times while performing
    the tests. Everything should look good at the end, and if it doesn't, then look
    into the `tests/codeception/_output/` folder. Here, you will find a markup and
    a screenshot of the page taken at the time of the failure. This debugging behavior
    is also found in the functional tests while using PHPBrowser.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行测试的过程中，您将简要看到浏览器打开和关闭几次。一切应该在最后看起来都很好，如果不好，那么请查看`tests/codeception/_output/`文件夹。在这里，您将找到在失败时捕获的页面标记和截图。这种调试行为在使用PHPBrowser进行功能测试时也存在。
- en: Creating acceptance tests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建验收测试
- en: Now that we have seen how the acceptance tests that use Selenium WebDriver are
    structured, we can start integrating the work done in the previous chapter and
    begin adding the tests we want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用Selenium WebDriver的验收测试的结构，我们可以开始整合上一章完成的工作，并开始添加我们想要的测试。
- en: For these kinds of tests, where normally the definition of the markup is left
    to whoever implements the layout, you would need to define the functionality of
    your interface, implement the tests, and then implement the markup and add the
    JavaScript functionality, if needed. After you've performed these, you will add
    the specifics of the DOM interaction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类测试，通常标记的定义留给实现布局的人，您需要定义您界面的功能，实现测试，然后实现标记，并在需要时添加 JavaScript 功能。在完成这些操作后，您将添加
    DOM 交互的具体细节。
- en: Knowing how many developers leave the frontend functionality definition for
    the very end, working "tests first" will force you to change your way of working,
    anticipating with as much detail as needed what lies ahead and discovering immediately
    any critical aspects of the design.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解有多少开发者将前端功能定义留到最后一刻，"测试先行"将迫使您改变工作方式，尽可能详细地预测前方的情况，并立即发现设计的任何关键方面。
- en: We will try to implement something that is simple enough to get you started
    with from scratch and then you can improve upon or extend it later. We know that
    the HTTP Basic Auth, which we have used, does not permit a stateful login. Therefore,
    we will have to keep some sort of a session object in JavaScript to simulate it.
    How this is going to work can be taken from the tests that we have written for
    the User API. This is practical documentation at its best.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试实现一些足够简单的东西，让您可以从头开始，然后您可以稍后对其进行改进或扩展。我们知道我们使用的 HTTP Basic Auth 不允许有状态的登录。因此，我们将在
    JavaScript 中保持某种类型的会话对象来模拟它。如何实现这一点可以从我们为用户 API 编写的测试中得知。这是最佳的实际文档。
- en: 'So, our scenario can be described as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的场景可以这样描述：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding syntax has been taken explicitly from the generated text version
    of our tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法是明确从我们的测试生成的文本版本中提取的。
- en: Implementing the modal window
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模态窗口
- en: The work of implementing the modal window will be made easy by Bootstrap, which
    is a default framework bundled with the basic app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Bootstrap，这是一个与基本应用程序捆绑的默认框架，实现模态窗口的工作将变得简单。
- en: The modal window is composed by an almost pre-determined markup and an additional
    JS, which provides the interaction part, thereby hooking it to the rest of the
    interface. I hope that the simplicity of its implementation will let you focus
    on the aim that lies behind it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模态窗口由几乎预先确定的标记和额外的 JS 组成，它提供了交互部分，从而将其连接到界面的其余部分。我希望其实现的简单性能让您专注于其背后的目标。
- en: 'The following code has deliberately been taken from the Bootstrap documentation,
    which can be found at [http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals).
    Since the modal window can be opened from any part of the website without going
    to the login page, we will have to add it to the overall layout template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是故意从 Bootstrap 文档中提取的，该文档可以在[http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals)找到。由于模态窗口可以从网站的任何部分打开而不必转到登录页面，因此我们必须将其添加到整体布局模板中：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we have moved the modal form to a separate template, which will
    receive the model of the form as a variable, keeping everything self-contained
    and organized. Please note from where the model takes its value. We're going to
    discuss it while implementing the controller.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将模态形式移动到了一个独立的模板中，该模板将作为变量接收表单的模型，保持一切自我包含和组织。请注意模型从哪里获取其值。我们将在实现控制器时讨论这个问题。
- en: The `login-modal.php` template is just a rip-off of the original `login.php`
    template, which can be found in the same directory without `H1` in the title and
    the "remember me" checkbox. We just need to add a placeholder to show the error
    that is coming from the API. This is done to inform and debug it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`login-modal.php` 模板只是原始 `login.php` 模板的复制品，可以在同一目录下找到，标题中没有 `H1`，也没有“记住我”复选框。我们只需要添加一个占位符来显示来自
    API 的错误。这样做是为了通知和调试。'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can place this snippet right after the first paragraph of the copied markup.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个片段放在复制的标记的第一段之后。
- en: Making the server side work
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使服务器端工作
- en: As we have said before, we want the modal window to be available everywhere.
    We are going to accomplish this by saving a publicly accessible property in the
    `SiteController`, so that we can retrieve it from the view. Remember that if you're
    coming from Yii 1, then views are now separate objects and not a part of the controller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们希望模态窗口在所有地方都可用。我们将通过在 `SiteController` 中保存一个公开可访问的属性来实现这一点，这样我们就可以从视图中检索它。记住，如果你是从
    Yii 1 过来的，那么现在视图是独立的对象，而不是控制器的一部分。
- en: 'Let''s use the `init()` method to do so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `init()` 方法来这样做：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once this is done, we can load our page without errors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以无错误地加载我们的页面。
- en: In the next step, we will add the interaction to JavaScript.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将添加与 JavaScript 的交互。
- en: Adding the JavaScript interaction
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 JavaScript 交互
- en: We will cover a couple of things in this section. We will discuss the basic
    functional interaction with the modal, the interaction with the form, and then
    learn how to close everything with the corner cases and error scenarios.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些内容。我们将讨论与模态的基本功能交互，与表单的交互，然后学习如何通过边缘情况和错误场景关闭一切。
- en: The interaction with the modal will be achieved by reusing the already existing
    login button, which is at the top right side of the menu. We will disable it,
    but remember that it will provide a fallback compatibility in case something goes
    wrong.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与模态的交互将通过重用已经存在的位于菜单右上角的登录按钮来实现。我们将禁用它，但请记住，如果出现问题，它将提供回退兼容性。
- en: The basic open-and-close of the modal window is provided out-of-the-box. We
    will only trigger it when required, for example upon authentication success.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模态窗口的基本打开和关闭是开箱即用的。我们只会在需要时触发它，例如在认证成功时。
- en: 'Let''s add the first basic skeleton for the JS module:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 JS 模块的第一个基本框架：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this part of our application, we will need the module pattern for creating
    a self-contained application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们应用的这部分，我们需要模块模式来创建一个自包含的应用。
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s start by caching all the jQuery elements that we are going to need along
    the way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先缓存所有我们在旅途中将要需要的 jQuery 元素：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have logged in, we will swap the link with a "fake" logout button:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们将交换链接以一个“假”注销按钮：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will need some data fields for holding our login information and creating
    some sort of a session:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些数据字段来存储我们的登录信息并创建某种形式的会话：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now comes the main part of our script, in which we will initialize our event
    listeners to the click and submit actions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是脚本的主要部分，我们将初始化我们的点击和提交动作的事件监听器：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s start by appending and hiding our logout button; we will show it only
    when the login succeeds, and define the click action it should have:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加并隐藏我们的注销按钮；我们只会在登录成功时显示它，并定义它应该有的点击动作：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to disable the click event for the login button. Otherwise, we will
    be taken to the login page, instead of opening the modal:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要禁用登录按钮的点击事件。否则，我们将被带到登录页面，而不是打开模态窗口：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The modal triggering event is done automatically by modifying the markup of
    the login button. So, navigate to `views/layouts/main.php` and then adjust it
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模态触发事件是通过修改登录按钮的标记自动完成的。因此，导航到 `views/layouts/main.php` 并按照以下方式调整：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will deal with the form submission:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理表单提交：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After disabling the default submit event, we will need to capture the username
    and the password, and then save it for future use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在禁用默认提交事件后，我们需要捕获用户名和密码，并将其保存以供将来使用：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `authorization` variable will hold our authorization header that is ready
    for dispatch:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorization` 变量将保存我们准备发送的授权头：'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code is simple enough. In case of success, we save the user ID for subsequent
    calls, we hide the login button and display the logout one, clear the error message,
    and hide the modal window. Otherwise, we just display the error message.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码足够简单。在成功的情况下，我们保存用户 ID 以供后续调用，隐藏登录按钮并显示注销按钮，清除错误信息并隐藏模态窗口。否则，我们只显示错误信息。
- en: 'The `beforesend` option will be initialized by the `authorize` function, which
    is defined as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforesend` 选项将由 `authorize` 函数初始化，该函数定义如下：'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After doing this, we won't need anything else to interact with the page. So,
    let's put everything together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之后，我们不再需要其他任何与页面交互的东西。所以，让我们把所有东西都放在一起。
- en: Tying everything together
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切整合起来
- en: At this point, we only have to add our JS to the page and then finalize our
    tests. In order to add our file to the page, we need to know what assets and asset
    bundles are.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需将我们的 JS 添加到页面中，然后完成我们的测试。为了将我们的文件添加到页面中，我们需要了解资产和资产包是什么。
- en: Dealing with Yii 2 assets bundles
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 Yii 2 资产包
- en: Yii 2 has radically changed the way assets are handled. It has introduced the
    concept of the asset bundle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 2 根本改变了处理资产的方式。它引入了资产包的概念。
- en: Asset bundles are collections of scripts and style sheets that can have a higher
    degree of configurability as compared to the past.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 资产包是脚本和样式的集合，与过去相比，它们具有更高的可配置性。
- en: 'This basic app already has a basic implementation. So, let''s navigate to `/assets/AppAsset.php`
    and see how the content is structured:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本应用已经有了基本的实现。所以，让我们导航到 `/assets/AppAsset.php` 并看看内容是如何组织的：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `AppAsset` extends from the `yii\web\AssetBundle` class and it simply defines
    a series of public properties.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppAsset` 从 `yii\web\AssetBundle` 类扩展而来，它仅仅定义了一系列公共属性。'
- en: The first two properties, `$basePath` and `$baseUrl,` are the most important
    ones. `$basePath` defines where the assets are located on a publicly accessible
    location, while `$baseUrl` defines how their resource is linked to the web pages,
    that is, their URL.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性，`$basePath` 和 `$baseUrl`，是最重要的。`$basePath` 定义了资产在公开可访问位置的位置，而 `$baseUrl`
    定义了它们的资源如何链接到网页，即它们的 URL。
- en: This asset, by using these two properties, defines the so called "published
    asset". In other words, it defines a bundle of assets, which are available at
    a publicly accessible location.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这两个属性，这个资产定义了所谓的“已发布资产”。换句话说，它定义了一个资产包，这些资产在公开可访问的位置可用。
- en: You can have "external assets", which are comprised of resources from external
    locations, and "source assets", which are not comprised of resources from publicly
    available locations. These assets define only a `$sourcePath` property and Yii
    copies them to the publicly accessible assets folder, and names them accordingly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有“外部资产”，这些资产由外部位置的资源组成，以及“源资产”，这些资产不包含来自公开位置的资源。这些资产仅定义了一个 `$sourcePath`
    属性，Yii 将它们复制到公开可访问的资产文件夹中，并相应地命名。
- en: Source assets are normally provided by libraries and widgets, and for this reason,
    we won't be covering them here. Published assets are recommended for incorporating
    assets into the page or pages by putting them somewhere in the `web/` folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 源资产通常由库和小部件提供，因此我们在这里不会涉及它们。建议将已发布的资产放入 `web/` 文件夹中以将资产合并到页面或页面上。
- en: In the example earlier, you saw that we defined the asset dependencies, and
    in our case, it's done with jQuery and Bootstrap. This is exactly why we've used
    them for developing the main JavaScript module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您看到我们定义了资产依赖项，在我们的情况下，这是通过 jQuery 和 Bootstrap 来实现的。这正是我们为什么使用它们来开发主要的
    JavaScript 模块。
- en: 'Lastly, we need to see how we can use the asset bundle for our markup. This
    can be done by looking at the top of the template view. For this, navigate to
    `/views/layouts/main.php`. Here, we can see these two lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要了解如何使用资产包来处理我们的标记。这可以通过查看模板视图的顶部来实现。为此，导航到 `/views/layouts/main.php`。在这里，我们可以看到这两行：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that the old way of associating any asset with a specific layout, although
    it's not particularly advisable, hasn't been removed. This works in the same way
    as it was working in Yii 1, that is, by using `registerCssFile()` and `registerJsFile()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然不特别建议，但将任何资产与特定布局关联的旧方法尚未被移除。这和 Yii 1 中的工作方式相同，即通过使用 `registerCssFile()`
    和 `registerJsFile()`。
- en: Assets have many other options, such as the ability to compress and compile
    SASS and LESS files, use Bower or NPM assets, and so on. Go to the documentation
    page, which is currently in a good shape and is quite comprehensive, at [http://www.yiiframework.com/doc-2.0/guide-structure-assets.html](http://www.yiiframework.com/doc-2.0/guide-structure-assets.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 资产还有许多其他选项，例如压缩和编译 SASS 和 LESS 文件，使用 Bower 或 NPM 资产等。请访问文档页面，目前它处于良好的状态，并且相当全面，链接为
    [http://www.yiiframework.com/doc-2.0/guide-structure-assets.html](http://www.yiiframework.com/doc-2.0/guide-structure-assets.html)。
- en: 'For our work, we need to slightly adjust the asset bundle provided by adding
    the JS file and tweak it where it''s going to be added to the page, otherwise
    we will encounter some problems in running it before the page is parsed. Consider
    the following code snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作中，我们需要稍微调整由添加JS文件提供的资产包，并调整它将要添加到页面上的位置，否则在页面解析之前运行它时可能会遇到一些问题。考虑以下代码片段：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you've added the preceding lines to the asset bundle, you need to head
    back to the form template that is included in the modal. This, in fact, will generate
    some problems because it requires injecting some script into the page in order
    to make the client-side validation work. This is a major problem; most of the
    time you will have to override the way `ActiveForms` works, so you should learn
    how to do it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将前面的行添加到资产包中，你需要回到模态中包含的表单模板。实际上，这会引发一些问题，因为它需要将一些脚本注入页面以使客户端验证工作。这是一个主要问题；大多数时候，你将不得不覆盖`ActiveForms`的工作方式，所以你应该学习如何做到这一点。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The two options shown here will disable both the client-side validation and
    any additional scripting facility. Disabling only one option won't do the trick.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的两个选项将禁用客户端验证和任何额外的脚本功能。仅禁用其中一个选项不起作用。
- en: We can now load the page and no error message will be displayed on the console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以加载页面，并且控制台不会显示任何错误消息。
- en: Finalizing the tests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成测试
- en: At this point, we just have to convert our scenarios into live code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需将我们的场景转换为实时代码。
- en: 'Let''s start creating the test in the same way as we created unit tests and
    functional tests:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建单元测试和功能测试相同的方式开始创建测试：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Navigate to the file and let''s start by asserting the initial statements:
    where we are and ensure that we are not logged in:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到文件，让我们首先断言初始语句：我们所在的位置，并确保我们没有登录：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although this might seem like a simplistic way of determining whether the user
    is logged in, it serves the purpose. If we find that anything more complex is
    needed, then we can always add it to the mix later:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一种确定用户是否登录的简单方法，但它达到了目的。如果我们发现需要更复杂的方法，我们总是可以在以后添加：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The most important part of this test is the use of an explicit wait, `waitForElementVisible().`
    It does what it says on the tin: waits until the DOM element with class .modal
    is rendered and visible.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试最重要的部分是使用显式等待，`waitForElementVisible()`。它做了它所说的：等待直到具有类.modal的DOM元素渲染并可见。
- en: The assertion made at the end does not check for any specific errors. So feel
    free to add any level of customization here, as I've tried to be as generic as
    possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的断言并没有检查任何特定的错误。所以你可以在这里添加任何级别的定制，因为我已经尽量保持尽可能通用。
- en: 'The same goes for the following test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试也是同样的情况：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This interesting part of the test comes when we''re trying to access using
    valid credentials. In fact, as we''ve seen in the script we created previously,
    the modal window will be dismissed and the login button will be replaced by the
    logout link:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的这个有趣部分出现在我们尝试使用有效凭据访问时。实际上，正如我们在之前创建的脚本中所看到的，模态窗口将被关闭，登录按钮将被注销链接替换：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to do this, we need to add another explicit wait for the AJAX call
    to complete and then the window will disappear. Using `waitForElementNotVisible()`
    might not do the trick because it involves animation. It also depends on the responsiveness
    of the system you''re testing on because it might not work as expected and fail
    from time to time. So, `wait()` seems like the simplest solution for the problem.
    Consider this code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要为AJAX调用完成添加另一个显式等待，然后窗口将消失。使用`waitForElementNotVisible()`可能不起作用，因为它涉及动画。它还取决于你正在测试的系统的响应性，因为它可能不会按预期工作，有时会失败。所以，`wait()`似乎是解决问题的最简单方法。考虑以下代码片段：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last test doesn't need much attention and you should be able to understand
    it without facing any problems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试不需要太多关注，你应该能够理解它而不会遇到任何问题。
- en: 'Now that we have put together our tests, let''s run them:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，让我们运行它们：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing multiple browsers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试多个浏览器
- en: Version 1.7 onwards, Codeception also provides a method for testing multiple
    browsers. This is not particularly difficult, and it can ensure that cross-browser
    compatibility is achieved.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.7开始，Codeception还提供了一种测试多个浏览器的方法。这并不特别困难，并且可以确保实现跨浏览器兼容性。
- en: 'This is normally done by configuring environments in the `acceptance.suite.yml`
    file by adding something similar to the following at the bottom of the file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过在 `acceptance.suite.yml` 文件中配置环境来完成的，在文件底部添加类似以下内容：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each key under the `env` variable represents a specific browser you want to
    run the test on, and this is done by overriding the default configuration that
    we have already defined.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 变量下的每个键都代表你想要在测试上运行的特定浏览器，这是通过覆盖我们已定义的默认配置来实现的。'
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Within `env`, you can override just about any other key that was specified in
    the YAML configuration files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `env` 中，你可以覆盖 YAML 配置文件中指定的任何其他键。
- en: You can have several machines, each having different versions of the browsers,
    with Selenium Server listening on them, so you can also perform retro-compatibility
    tests when deciding which polyfills to use for the new features introduced recently
    and also depending on your browser support chart.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有几台机器，每台机器上运行不同版本的浏览器，Selenium 服务器在这些机器上监听，这样你还可以在决定为最近引入的新功能使用哪些 polyfills
    时进行回溯兼容性测试，同时也取决于你的浏览器支持图表。
- en: 'In order to trigger the various environments, just append the `--env <environment>`
    parameter to the `run` command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发各种环境，只需在 `run` 命令后附加 `--env <环境>` 参数：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Internet Explorer requires its own driver to be installed on the host machine
    and a few more steps to be performed to set it up correctly, which is covered
    in the Selenium documentation, which can be found at [https://code.google.com/p/selenium/wiki/InternetExplorerDriver](https://code.google.com/p/selenium/wiki/InternetExplorerDriver).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer 需要在主机机器上安装自己的驱动程序，并执行一些额外的步骤来正确设置，这可以在 Selenium 文档中找到，文档地址为
    [https://code.google.com/p/selenium/wiki/InternetExplorerDriver](https://code.google.com/p/selenium/wiki/InternetExplorerDriver)。
- en: Understanding Selenium limits
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Selenium 的限制
- en: By now, you have probably seen how powerful Selenium is. By using the browser
    natively, you can finally interact with the website programmatically. This will
    save a huge portion of time that is normally spent by human beings on doing repetitive
    tasks. Repetitiveness is only a cause of problems when it comes into the hands
    of humans, so this is effectively a good thing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经看到了 Selenium 的强大之处。通过使用浏览器原生功能，你最终可以以编程方式与网站交互。这将节省人类在执行重复性任务上花费的大量时间。重复性只有在人类手中才会成为问题，所以这实际上是一件好事。
- en: Unfortunately Selenium can't do everything, and if you have already started
    looking into it and researching its full use and potential, then you might have
    noticed that there are some limitations of its use.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Selenium 不能做任何事情，如果你已经开始研究它的全面使用和潜力，那么你可能已经注意到它的一些使用限制。
- en: Clearly any kind of "pixel-perfect" tests are nearly impossible to recreate
    with Selenium, although some types of tests on designs can be created, specifically
    for responsive designs. Other frameworks, such as Galen cover this functionality
    ([http://galenframework.com/](http://galenframework.com/)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何类型的“像素完美”测试几乎都不可能使用 Selenium 来重现，尽管可以创建一些针对设计的测试，特别是针对响应式设计的测试。其他框架，如 Galen，覆盖了这一功能（[http://galenframework.com/](http://galenframework.com/))。
- en: A few words need to be spent on hover effects, as they might be quite difficult
    to achieve and you may need to use the `moveMouseOver()` method for triggering
    it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要花一些时间讨论悬停效果，因为它们可能相当难以实现，你可能需要使用 `moveMouseOver()` 方法来触发它。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered the final aspect of testing in this chapter. We've gone through
    the provided tests. We have also understood any additional syntax, configured
    Selenium, run the first batch of tests, and then moved on to implementing and
    tying the API previously developed into the interface with a modal login feature.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经涵盖了测试的最后一个方面。我们回顾了提供的测试。我们还理解了任何额外的语法，配置了 Selenium，运行了第一批测试，然后继续将之前开发的
    API 实现并绑定到具有模态登录功能的界面中。
- en: In the next chapter, we are going to learn about a lot of logs and how information
    can be generated by our tests to better our understanding of testing. We will
    also see if we've missed anything.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习大量的日志以及我们的测试如何生成信息以更好地理解测试。我们还将看看我们是否遗漏了什么。
