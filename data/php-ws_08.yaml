- en: 8\. Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 错误处理
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to describe the different error
    levels in PHP; use a custom error handler; trigger and log error messages; catch
    fatal errors at shutdown; explain how exceptions work in PHP; define, use, and
    catch multiple exception classes; and register a top-level exception handler.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述PHP中的不同错误级别；使用自定义错误处理器；触发和记录错误消息；在关闭时捕获致命错误；解释PHP中异常的工作方式；定义、使用和捕获多个异常类；并注册顶级异常处理器。
- en: Also, in this chapter, you will trigger so-called user-level error messages
    and how they can be helpful. In the last part, you will learn about exceptions
    and how they can be used to control script flow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，你将触发所谓的用户级错误消息以及它们如何有帮助。在最后一部分，你将了解异常以及如何使用它们来控制脚本流程。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you were presented with the ways in which PHP can be
    used to interact with a filesystem in order to process uploaded files, write in
    text files, and create files and directories, to name but a few aspects. Also,
    you were shown how a SQL server can be used with PHP to manipulate structured
    data, such as user accounts or a contacts list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你被介绍了PHP如何用于与文件系统交互，以便处理上传的文件、写入文本文件、创建文件和目录等。此外，你还被展示了如何使用PHP与SQL服务器一起操作结构化数据，例如用户账户或联系人列表。
- en: Handling errors in an application is very important and keeping an eye on them
    leads to early bug detection, performance improvements, and the overall robustness
    of the application. Errors can be triggered to signal a number of malfunctions—missing
    data, bad syntax, deprecated features, and more, and can bring a halt to the script
    process, depending on severity. For example, when a database connection is not
    possible, the application would emit a fatal error, which could be handled by
    writing in a log file, sending an alert email to maintainers/developers with rich
    trace information (such as connection details), and a nice, user-friendly message
    would be displayed on user output (a browser, for example). On a social media
    website, for example, when a user tries to add a comment to a post that has been
    deleted in the interim (or made inaccessible), an error would be shown providing
    notification of the failure to add the comment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中处理错误非常重要，关注它们可以导致早期错误检测、性能改进以及应用程序的整体健壮性。错误可以触发以指示多种故障——数据丢失、语法错误、已弃用功能等，并且根据严重程度可能会终止脚本过程。例如，当数据库连接不可用时，应用程序会发出致命错误，这可以通过写入日志文件、向维护者/开发者发送包含丰富跟踪信息（如连接详情）的警报电子邮件，并在用户输出（例如浏览器）上显示友好的消息来处理。例如，在一个社交媒体网站上，当用户尝试对在中间被删除（或变得不可访问）的帖子添加评论时，会显示一个错误，通知无法添加评论的失败。
- en: Errors in PHP
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP中的错误
- en: Errors and error handlers in software programming are a priceless concept that
    helps developers to identify failure points at the application compile-time or
    at runtime. They can signal different levels of severity. Hence, the script could
    emit a fatal error that causes the process to stop, it could emit warnings that
    point to possible misuse of the script, and it could also emit some notifications
    hinting at code improvements (for example, using an uninitialized variable in
    an operation). Therefore, errors are grouped in different levels, based on severity—fatal
    errors, warnings, notices, and debug messages, to name but a few. All these messages
    are usually collected to persistent storage, in a process called logging. The
    most accessible logging method is writing to a file on a local filesystem, and
    this is the default method for most (if not all) applications. These logs are
    read by developers to identify issues or look for other specific information,
    such as memory usage or SQL query response times. Modern applications, like those
    based on the cloud, do not retain the application logs on the filesystem; instead,
    they send them out to specialized log handling applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件编程中，错误和错误处理器是一个无价的概念，它帮助开发者在应用程序的编译时或运行时识别故障点。它们可以表示不同级别的严重性。因此，脚本可以发出导致进程停止的致命错误，可以发出警告，指出脚本可能的误用，也可以发出一些提示代码改进的通告（例如，在操作中使用未初始化的变量）。因此，根据严重性将错误分组在不同的级别，例如致命错误、警告、通知和调试消息，仅举几例。所有这些消息通常都收集到持久存储中，这个过程称为记录。最易访问的记录方法是写入本地文件系统上的文件，这是大多数（如果不是所有）应用程序的默认方法。开发者通过读取这些日志来识别问题或查找其他特定信息，例如内存使用或SQL查询响应时间。现代应用程序，如基于云的应用程序，不会在文件系统上保留应用程序日志；相反，它们将它们发送到专门的日志处理应用程序。
- en: In PHP, errors are handled and logged using a series of built-in functions.
    They facilitate the tailoring of error handling and logging to suit an application's
    needs by registering custom error handlers or setting error reporting for a specific
    range of levels.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，错误通过一系列内置函数来处理和记录。通过注册自定义错误处理器或设置特定范围的错误报告，这些函数可以方便地定制错误处理和记录以满足应用程序的需求。
- en: Since these functions are incorporated in the PHP core, no other extensions
    need to be installed in order to use them. The settings in the `php.ini` configuration
    file, or the use of functions such as `ini_set()` at runtime, affect the behavior
    of these functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些函数已集成在PHP核心中，因此无需安装其他扩展即可使用它们。`php.ini`配置文件中的设置，或在运行时使用`ini_set()`函数，都会影响这些函数的行为。
- en: 'Some of the most frequently encountered errors and widely used logging configuration
    options are listed in the following table:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了最常遇到的错误和广泛使用的记录配置选项：
- en: '![Figure 8.1: Common error and logging configurations'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：常见的错误和记录配置'
- en: '](img/C14196_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_08_01.jpg]'
- en: 'Figure 8.1: Common error and logging configurations'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：常见的错误和记录配置
- en: 'It is always better to check these values after you install a certain version
    of PHP and set appropriate values. Of course, special attention should be paid
    to the PHP settings on the production server. If you prefer to change a configuration
    value at runtime, the `ini_set()` function can be used as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了某个版本的PHP并设置了适当的值之后，始终建议检查这些值。当然，应特别注意生产服务器上的PHP设置。如果您希望在运行时更改配置值，可以使用以下方式使用`ini_set()`函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, it is better to have all the configurations in files only. For example,
    in the case of setting the `display_errors` to "`Off`", to hide any error message
    from the user output, should the script fail to compile before the setting is
    reached and read, then the errors will be displayed to the user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好将所有配置都放在文件中。例如，在设置`display_errors`为"`Off`"以隐藏任何错误消息从用户输出的情况下，如果脚本在设置到达并读取之前失败编译，则错误将显示给用户。
- en: 'Let''s now say a few words about "compile-time" and "runtime." PHP runs in
    two major stages, the first being compilation, and the second, interpretation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈“编译时”和“运行时”。PHP运行分为两个主要阶段，首先是编译，其次是解释：
- en: In the first stage—the compile-time, PHP parses the script file and builds the
    so-called machine code. This is the raw binary format that is run by the machine
    (the computer and server) and is not human-readable. This step can be cached using
    tools such as Opcache or APC, which is recommended on account of the huge performance
    boost it brings.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一阶段——编译时，PHP 解析脚本文件并构建所谓的机器码。这是由机器（计算机和服务器）运行的原始二进制格式，不是人类可读的。这一步可以使用 Opcache
    或 APC 等工具进行缓存，由于它带来的巨大性能提升，因此推荐使用。
- en: In the second stage—the runtime, the machine code is actually executed.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段——运行时，机器码实际上被执行。
- en: Also, in order to communicate with the server on which PHP runs, it uses a server
    application programming interface (otherwise known as a server API, aka SAPI).
    For example, running PHP from the command line (in the Terminal), the command-line
    interface (CLI) SAPI would be used. For web traffic, Apache2 SAPI may be used
    (as a module in the Apache2 server), or FastCGI Process Manager (FPM) SAPI with
    the NGINX server. These are the most commonly used interfaces for PHP, and they
    are installed as needed, each containing their own configuration files, which
    usually import the main/default configuration and are extended with their own
    specific configuration files. We will talk about configuration files a bit later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了与运行 PHP 的服务器进行通信，它使用服务器应用程序编程接口（也称为服务器 API，简称 SAPI）。例如，从命令行（在终端）运行 PHP
    时，将使用命令行界面（CLI）SAPI。对于网络流量，可以使用 Apache2 SAPI（作为 Apache2 服务器的模块），或者与 NGINX 服务器一起使用
    FastCGI 进程管理器（FPM）SAPI。这些是 PHP 最常用的接口，它们根据需要安装，每个都包含自己的配置文件，通常导入主/默认配置，并扩展了它们自己的特定配置文件。我们稍后会讨论配置文件。
- en: 'Here are the most common predefined constants for error messages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是错误消息最常见的预定义常量：
- en: '![Figure 8.2: Predefined constants for error messages'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2：错误消息的预定义常量'
- en: '](img/C14196_08_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_02.jpg)'
- en: 'Figure 8.2: Predefined constants for error messages'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：错误消息的预定义常量
- en: These errors are generated and reported by the PHP engine and will be reported
    in error handlers that we will encounter later. To change the error reporting
    level in PHP, the `error_reporting()` function, which requires only one parameter
    – the decimal number used as the *bit mask* (a bit mask is a binary sequence used
    in this case to match a triggered error message level), can be used. The `error_reporting()`
    function parameter is often used as a bitwise expression between two or more error-level
    constants. For example, if we only want to report errors and warnings, we would
    invoke `error_reporting(E_ERROR | E_WARNING);` at script runtime. Using bitwise
    expressions is also allowed for `error_reporting` entries in INI configuration
    files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误由 PHP 引擎生成并报告，将在我们稍后遇到的错误处理器中报告。要更改 PHP 中的错误报告级别，可以使用 `error_reporting()`
    函数，它只需要一个参数——用作 *位掩码* 的十进制数（在这种情况下，位掩码是一个二进制序列，用于匹配触发的错误消息级别），可以使用 `error_reporting()`
    函数。`error_reporting()` 函数参数通常用作两个或多个错误级别常量之间的位运算表达式。例如，如果我们只想报告错误和警告，我们将在脚本运行时调用
    `error_reporting(E_ERROR | E_WARNING);`。在 INI 配置文件中的 `error_reporting` 条目中也可以使用位运算表达式。
- en: Apart from these, there are some other error codes (including constants) that
    are used in user scripts to generate errors on request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有一些其他错误代码（包括常量）用于用户脚本中按请求生成错误。
- en: 'Here is the list of predefined constants for user-level generated error messages,
    using the PHP function, `trigger_error()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用户级生成错误消息的预定义常量列表，使用 PHP 函数 `trigger_error()`：
- en: '![Figure 8.3: Predefined constants for user-level generated error messages'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3：用户级生成错误消息的预定义常量'
- en: '](img/C14196_08_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_03.jpg)'
- en: 'Figure 8.3: Predefined constants for user-level generated error messages'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：用户级生成错误消息的预定义常量
- en: These are useful when the developer wants to report something in a given context
    but does not want to halt the execution of the script. For example, when you refactor
    a component by "removing" a function, among other operations (in your application
    code or in a PHP library that you manage), you might prefer to include an `E_USER_DEPRECATED`
    level message in the function to remove, pointing to the preferred alternative,
    rather than just removing the function, thereby increasing the chances of calls
    to undefined function error messages that would stop your script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者想在特定上下文中报告某些内容但又不想停止脚本的执行时，这些很有用。例如，当您通过“删除”函数等方式重构组件（在您的应用程序代码或您管理的 PHP
    库中）时，您可能更愿意在要删除的函数中包含一个 `E_USER_DEPRECATED` 级别的消息，指向首选的替代方案，而不是仅仅删除函数，从而增加调用未定义函数错误消息的可能性，这可能会停止您的脚本。
- en: 'To set custom PHP settings before runtime, it''s sufficient to add the custom
    configuration file inside the INI (configuration) directory of PHP. To find this
    directory, you should run `php --ini`; the output will be something like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时之前设置自定义 PHP 设置，只需将自定义配置文件添加到 PHP 的 INI（配置）目录中即可。要找到此目录，您应该运行 `php --ini`；输出将类似于以下内容：
- en: '![Figure 8.4: Output of the php-ini command'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4：php-ini 命令的输出]'
- en: '](img/C14196_08_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_08_04.jpg]'
- en: 'Figure 8.4: Output of the php-ini command'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4：php-ini 命令的输出]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `--ini` option scans and loads all the `.ini` files within each directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`--ini` 选项扫描并加载每个目录内的所有 `.ini` 文件。'
- en: Look for `Scan for additional .ini files`, and there you will find the directory
    where your settings should go.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找“扫描附加 .ini 文件”，在那里您将找到您设置应该去的目录。
- en: You should make sure to add the custom configuration file for both CLI and FPM
    modes, if the configuration directories used are separate among them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的配置目录在 CLI 和 FPM 模式之间是分开的，您应该确保为两种模式都添加自定义配置文件。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the preceding directory contains `/cli/` in its path, this means that the
    configuration only applies to the CLI, and you should look for the FPM directory
    on the same level as the CLI and add the custom configuration there too.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的目录路径中包含 `/cli/`，这意味着配置仅适用于 CLI，您应该在 CLI 同一级别的 FPM 目录中查找并添加自定义配置。
- en: Next, please make sure that you have set the following values related to errors
    and logs in PHP in a custom INI file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保您已在自定义 INI 文件中设置了与 PHP 中的错误和日志相关的以下值。
- en: 'Create the `/etc/php/7.3/cli/conf.d/custom.ini` file and set the following
    values:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `/etc/php/7.3/cli/conf.d/custom.ini` 文件并设置以下值：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although we could make use of an `error_log` configuration to log everything
    in a file, we will leave this job to a logger component that will be able to handle
    multiple outputs instead of a single one – sending logs in a file, to a log server,
    to Slack, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以利用 `error_log` 配置将所有内容记录到文件中，但我们将这项工作留给一个能够处理多个输出的日志组件，而不是单个输出——将日志发送到文件、日志服务器、Slack
    等等。
- en: You should make a clear distinction between error reporting and handling and
    logging these errors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在错误报告和处理以及记录这些错误之间做出明确区分。
- en: Furthermore, the preceding PHP configuration values will be considered set.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前面的 PHP 配置值将被视为已设置。
- en: 'Running a quick check, using `ls -ln /etc/php/7.3/cli/conf.d`, we should get
    the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查时，使用 `ls -ln /etc/php/7.3/cli/conf.d`，我们应该得到以下内容：
- en: '![Figure 8.5: Listing the configuration files under the folder'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.5：列出文件夹下的配置文件]'
- en: '](img/C14196_08_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_08_05.jpg]'
- en: 'Figure 8.5: Listing the configuration files under the folder'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：列出文件夹下的配置文件
- en: As you will notice, the configuration for installed modules is linked to the
    common configuration file from `/etc/php/7.3/mods-available/`, as discussed previously.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，已安装模块的配置与之前讨论过的 `/etc/php/7.3/mods-available/` 中的通用配置文件相关联。
- en: Handling Errors
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: By default, PHP will output the error messages to user output (on the browser
    screen when accessing the program through a browser, or in the Terminal/commander
    when run in a command-line interface). This should be changed in the early stages
    of application development so that, after publishing the app, you can be certain
    that no error messages will be leaked to the user, because it would look unprofessional
    and may occasionally scare the end user. The application errors should be treated
    in such a way that the end user will not see some possible faults when they occur
    (such as failing to connect to the cache service), or user-friendly error messages
    pertaining to the operation that it was not possible to execute (for example,
    the inability to add a comment while connection to the database is not possible).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP会将错误消息输出到用户输出（通过浏览器访问程序时在浏览器屏幕上，或在命令行界面运行时在终端/命令行中）。在应用程序开发的早期阶段应该更改这一点，以便在发布应用程序后，你可以确信不会向用户泄露任何错误消息，因为这会显得不专业，有时可能会吓到最终用户。应用程序的错误应该以这种方式处理，即最终用户在它们发生时不会看到一些可能的故障（例如，无法连接到缓存服务），或者与无法执行的操作相关的用户友好的错误消息（例如，在无法连接到数据库时无法添加评论）。
- en: The Default Error Handler
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认错误处理器
- en: 'PHP uses a default error handler, provided no other error handler is specified
    by the user (developer), that simply outputs the error message to the user output,
    be it the browser or the Terminal/commander. This message contains the error message
    itself, the filename, and the line number where the error was triggered. By checking
    whether the default error handler in action is enough to run in a command-line
    interface with, `php -r ''echo $iDontExist;''`, you will get the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户（开发者）没有指定其他错误处理器，PHP将使用默认的错误处理器，该处理器简单地输出错误消息到用户输出，无论是浏览器还是终端/命令行。此消息包含错误消息本身、文件名以及错误被触发的行号。通过检查是否在命令行界面中运行默认错误处理器，`php
    -r 'echo $iDontExist;'`，你将得到以下输出：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Such types of error may be output from all over the application, for a variety
    of reasons: undefined variables, using strings as an array, attempting to not
    open an existing (or without read permissions) file, calling missing methods on
    an object, and so on. Even if you set up a custom error handler and do not show
    the end user such errors, it is best practice to resolve rather than hide them.
    Designing your application to avoid such error triggering will make your application
    more performant, more robust, and less prone to bugs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误可能由应用程序的各个部分输出，原因多种多样：未定义的变量、将字符串用作数组、尝试打开一个不存在的（或没有读取权限）的文件、在对象上调用缺失的方法，等等。即使你设置了自定义的错误处理器并且不向最终用户显示这些错误，最好的做法也是解决它们而不是隐藏它们。设计你的应用程序以避免触发此类错误，将使你的应用程序性能更佳、更健壮，并且更不容易出现错误。
- en: Using a Custom Error Handler
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义错误处理器
- en: We always want to manage the reported errors in our application, instead of
    outputting them in response. For this, we have to register our own error handler,
    and we will use the built-in function, `set_error_handler()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是希望在我们的应用程序中管理报告的错误，而不是在响应中输出它们。为此，我们必须注册我们自己的错误处理器，我们将使用内置函数 `set_error_handler()`。
- en: 'The syntax is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first argument is a callable, while the second argument will specify the
    levels for which this handler will be invoked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个可调用对象，而第二个参数将指定此处理器将被调用的级别。
- en: 'A callable is a function that will be run at a certain point in execution,
    being fed an expected list of parameters. For example, by running the following
    PHP code, `php -r ''var_dump(array_map("intval", [ "10", "2.3", "ten" ]));''`,
    the `array_map()` function will invoke the `intval()` function for each element
    of the array parameter, `("10", "2.3", "ten")`, providing the element value; as
    a result, we get an array of the same length, but with integer values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象是在执行过程中的某个点运行的函数，它将接收一个预期的参数列表。例如，通过运行以下PHP代码，`php -r 'var_dump(array_map("intval",
    [ "10", "2.3", "ten" ]));'`，`array_map()` 函数将为数组参数 `("10", "2.3", "ten")` 的每个元素调用
    `intval()` 函数，提供元素值；因此，我们得到一个长度相同的数组，但包含整数值：
- en: '![Figure 8.6: Passing values to a function'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6：向函数传递值'
- en: '](img/C14196_08_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_06.jpg)'
- en: 'Figure 8.6: Passing values to a function'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：向函数传递值
- en: The type of callable can be a declared function, a function variable (an anonymous
    function), an instantiated class method, a class static method, or a class instance
    implementing the `__invoke()` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用的类型可以是声明的函数、函数变量（匿名函数）、实例化的类方法、类静态方法，或者实现`__invoke()`方法的类实例。
- en: If the error raised is of a different type to the one specified in `set_error_handler()`,
    then the default error handler will be invoked. Also, the default handler will
    be invoked when the custom error handler returns the Boolean `FALSE`. The handler
    will only be used for specified `$error_types` parameters, regardless of the `error_reporting`
    value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出的错误类型与`set_error_handler()`中指定的不同，则将调用默认错误处理器。此外，当自定义错误处理器返回布尔值`FALSE`时，也将调用默认处理器。无论`error_reporting`的值如何，处理器仅用于指定的`$error_types`参数。
- en: 'The error handler should have the following signature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理器应该具有以下签名：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The arguments are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`$errno (integer)`: points to the error level of the message'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$errno (整数)`: 指向消息的错误级别'
- en: '`$errstr (string)`: is the error message itself'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$errstr (字符串)`: 是错误信息本身'
- en: '`$errfile (string)`: the file path where the error happened'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$errfile (字符串)`: 发生错误的文件路径'
- en: '`$errline (integer)`: the line number in the file where the error occurred'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$errline (整数)`: 发生错误的文件中的行号'
- en: '`$errcontext (array)`: a list of all variables available at the time the error
    occurred in `$errfile` at `$errline`, as name-value pairs in the associative array'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$errcontext (数组)`: 在`$errfile`文件中`$errline`行发生错误时所有可用的变量列表，以关联数组中的名称-值对形式'
- en: 'Exercise 8.1: Using a Custom Error Handler'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.1：使用自定义错误处理器
- en: 'So far, we have learned about error codes and some configurations for error
    reporting using the default error handler. In this exercise, we will register
    a custom error handler and learn how we can use it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了关于错误代码以及使用默认错误处理器进行错误报告的一些配置。在这个练习中，我们将注册一个自定义错误处理器，并学习如何使用它：
- en: 'Create a file called `custom-handler.php` and add the following content. First,
    we define the error handler – an anonymous function stored in the `$errorHandler`
    variable, which will print the current date and time, the message, the filename,
    the line number, and the error code in a format of our choosing:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`custom-handler.php`的文件，并添加以下内容。首先，我们定义错误处理器 – 存储在`$errorHandler`变量中的匿名函数，它将打印当前日期和时间、消息、文件名、行号和错误代码，格式由我们选择：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we register the error handler defined previously for all types of errors,
    using the `set_error_handler()` function:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`set_error_handler()`函数为所有类型的错误注册之前定义的错误处理器：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we write an expression that should trigger some error messages at
    runtime – a division operation, the variables of which are not yet defined:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写一个表达式，该表达式应在运行时触发一些错误消息 – 一个除法操作，其变量尚未定义：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Execute the following command in the Terminal:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行以下命令：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.7: Output of the program'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：程序输出'
- en: '](img/C14196_08_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_07.jpg)'
- en: 'Figure 8.7: Output of the program'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：程序输出
- en: So, we have two `Undefined variable` (`code 8`) errors and a `Division by zero`
    (`code 2`) error. And, on the last line, we got `NAN` – not-a-number, since division
    by zero doesn't make sense. Looking at the predefined constants table, we can
    see that the `code 2` error is a warning, while the `code 8` error is a notification.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个`未定义变量`（代码8）错误和一个`除以零`（代码2）错误。并且，在最后一行，我们得到了`NAN` – 不是数字，因为除以零没有意义。查看预定义常量表，我们可以看到`代码2`错误是一个警告，而`代码8`错误是一个通知。
- en: Congratulations! You have just used your first customized error handler.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚使用了你的第一个自定义错误处理器。
- en: Now, let's see how you could use it better than just printing the errors onscreen.
    Do you recall that you don't want the visitors of your website to see all this
    stuff? So, instead of printing, let's just log them (write) in a file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何比仅仅在屏幕上打印错误信息更好地使用它。你还记得你不想让网站的访客看到所有这些内容吗？所以，而不是打印，我们只需将它们记录（写入）到文件中。
- en: As indicated earlier, the reason for logging the errors (or other kinds of messages)
    in files is to have them recorded in persistent storage so that they can be read
    at any time, by anybody with access to the server, even when the application is
    not running. This is particularly useful since many errors might arise once end
    users "exploit" the application, and logging turns out to be an appropriate way
    to check errors occurring after such usage.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将错误（或其他类型的消息）记录在文件中的原因是为了让它们记录在持久存储中，这样任何人都可以在任何时候读取，即使应用程序没有运行，只要有权限访问服务器。这尤其有用，因为许多错误可能会在最终用户“利用”应用程序后出现，而记录日志是检查此类使用后发生的错误的一种适当方式。
- en: 'Exercise 8.2: Logging with the Custom Error Handler'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.2：使用自定义错误处理器进行记录
- en: 'Logging errors on a filesystem is just one of the many other logging methods,
    and it''s probably the simplest. In this exercise, we will see how we can use
    the error handler to write in a log file, in the simplest way possible:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统上记录错误只是众多其他记录日志方法之一，而且可能是最简单的一种。在这个练习中，我们将看到我们如何使用错误处理器以最简单的方式写入日志文件：
- en: Create a file called `log-handler.php` and add the following content.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`log-handler.php`的文件，并添加以下内容。
- en: 'The custom error handler will create a data stream resource using `fopen()`,
    if this has not already been done, using the `"append" (a) flag`. The target is
    the `app.log` file in the script directory. The stream is cached for subsequent
    calls, using the static keyword to initialize the `$stream` variable. The stream
    being written to is effected using the `fwrite()` function, and the message format
    is the same as in the previous exercise:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未完成，自定义错误处理器将使用`fopen()`创建一个数据流资源，使用`"append" (a)`标志。目标是脚本目录中的`app.log`文件。使用静态关键字初始化`$stream`变量，以便缓存后续调用。写入的流使用`fwrite()`函数，消息格式与之前的练习相同：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, the error handler is set for all error types again, followed by the test
    arithmetical expression that will trigger the errors:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次为所有错误类型设置错误处理器，接着是触发错误的测试算术表达式：
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, run the file in the command-line interface with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令在命令行界面中运行文件：
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This time, as output, we only get `NAN`, as expected, since we are logging
    the errors in the `app.log` file:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，作为输出，我们只得到预期的`NAN`，因为我们正在将错误记录在`app.log`文件中：
- en: '![Figure 8.8: Output showing the NAN value'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.8：显示NAN值的输出'
- en: '](img/C14196_08_08.jpg)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_08_08.jpg)'
- en: 'Figure 8.8: Output showing the NAN value'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.8：显示NAN值的输出
- en: 'Check the `app.log` file content; you should discover the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`app.log`文件内容；你应该会发现以下内容：
- en: '![Figure 8.9: Contents of the log file'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：日志文件的内容'
- en: '](img/C14196_08_09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_09.jpg)'
- en: 'Figure 8.9: Contents of the log file'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：日志文件的内容
- en: As you can see, the script output looks cleaner now, while in the log file,
    we have only error log messages. The end user does not see any under-the-hood
    errors, and the log file contains only the information relevant to the errors
    themselves.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，脚本输出现在看起来更干净了，而在日志文件中，我们只有错误日志消息。最终用户看不到任何底层的错误，日志文件只包含与错误本身相关的信息。
- en: Using `fopen()` in this example, we did not check whether it successfully opened
    and returned the stream resource, with the probability of failing to do so being
    very small, since the script will create the file in the same directory where
    it itself resides. In a real-world application, where the target file might have
    a directory path that does not exist on disk yet, or no write permission for that
    location, and so on, you should treat all these failure cases in the way you consider
    the best, either by halting script execution, outputting to standard error output,
    by ignoring the error, and so on. My personal approach, in many cases, is to output
    to standard error output, having a health checker set up, which, at its invocation,
    will report the logger issue. But in cases where the logging component is considered
    vital (legal or business constraints), then you may decide to prevent the application
    from running at all in the case of logging issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`fopen()`，我们没有检查它是否成功打开并返回流资源，因为脚本将在它自身所在的同一目录中创建文件，所以失败的概率非常小。在现实世界的应用程序中，目标文件可能有一个在磁盘上尚不存在的目录路径，或者没有对该位置的写权限等，你应该以你认为最好的方式处理所有这些失败情况，无论是停止脚本执行、输出到标准错误输出、忽略错误等。我个人的方法，在许多情况下，是将输出到标准错误输出，并设置一个健康检查器，在调用时将报告日志问题。但是，在日志组件被认为至关重要的情况下（法律或商业约束），你可能会决定在出现日志问题时阻止应用程序运行。
- en: Triggering a User-Level Error
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发用户级错误
- en: Sometimes, depending on the purpose, it is useful to trigger errors in a script.
    For example, module refactoring would result in deprecated methods or inputs,
    and deprecation errors would be appropriate until the application that relies
    on that module completes the migration, instead of just removing the methods of
    the old API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，根据目的，在脚本中触发错误是有用的。例如，模块重构会导致过时的方法或输入，在这种情况下，直到依赖于该模块的应用程序完成迁移，应该使用过时错误，而不是仅仅移除旧API的方法。
- en: 'To achieve this, PHP provides the `trigger_error()` core function, and the
    syntax is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，PHP提供了`trigger_error()`核心函数，其语法如下：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first parameter is the error message and is required. The second parameter
    is the level of the error message and is optional, `E_USER_NOTICE` being the default
    value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是错误消息，是必需的。第二个参数是错误消息的级别，是可选的，默认值为`E_USER_NOTICE`。
- en: 'Before we continue, let''s set up an error handler that we will include in
    further exercises. We will call this file `error-handler.php`, and its content
    will be the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们设置一个错误处理器，我们将在接下来的练习中包含它。我们将把这个文件命名为`error-handler.php`，其内容如下：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we define the error handler—an anonymous function that will print the
    error message on the screen, and then, for the fatal error, `E_USER_ERROR`, it
    will halt the execution of the script with exit code `1`. This is a handler we
    can use in production, or for command-line scripts since the output is printed
    onscreen, the script is halted in the event of fatal errors, and also the exit
    code would be non-zero (meaning the script did not complete successfully).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义错误处理器——一个匿名函数，它将在屏幕上打印错误消息，然后对于致命错误`E_USER_ERROR`，它将使用退出代码`1`停止脚本的执行。这是一个我们可以用于生产环境或命令行脚本的处理器，因为输出是在屏幕上打印的，在发生致命错误时脚本会停止，并且退出代码将不为零（意味着脚本没有成功完成）。
- en: Then, we set the error handler for all types of errors and return it so that
    it can eventually be used by the script that invokes this file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为所有类型的错误设置错误处理器，并返回它，以便它最终可以被调用此文件的脚本使用。
- en: 'Exercise 8.3: Triggering Errors'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.3：触发错误
- en: In this exercise, you will trigger some errors in the script, purposely, only
    when specific conditions are met. In order to continue, please make sure you created
    the error handler file described previously since it will be used in this and
    in the following exercises.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将故意在满足特定条件时在脚本中触发一些错误。为了继续，请确保你创建了之前描述的错误处理器文件，因为它将在这个和接下来的练习中使用。
- en: 'In this particular simple script, we aim to return the square root of the input
    argument:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的简单脚本中，我们的目标是返回输入参数的平方根：
- en: 'Create a file called `sqrt.php` and add the following content. First, we include
    the error handler file that we created previously, to have our custom error handler
    set. Then, we check for the first argument presence and, if not there, we use
    `trigger_error()` to output the error message that will halt the execution of
    the script since we use `E_USER_ERROR` for the second parameter. If the first
    input argument exists, we store it in the `$input` variable for convenience:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sqrt.php` 的文件，并添加以下内容。首先，我们包含之前创建的错误处理程序文件，以便设置我们的自定义错误处理程序。然后，我们检查第一个参数是否存在，如果不存在，我们使用
    `trigger_error()` 输出错误消息，这将终止脚本的执行，因为我们使用 `E_USER_ERROR` 作为第二个参数。如果第一个输入参数存在，我们将其存储在
    `$input` 变量中以方便使用：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, there''s a list of input validation and sanitization. First, we check
    whether the input is a number, and if it''s not, we then trigger the error that
    halts the script:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有一个输入验证和清理的列表。首先，我们检查输入是否为数字，如果不是，我们则触发错误，这将终止脚本：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second validation is against the float number. Notice that we use the `$input
    * 1` expression trick (because the input is a numerical string) to convert to
    either an integer or float.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二次验证是对浮点数的验证。请注意，我们使用 `$input * 1` 表达式技巧（因为输入是一个数字字符串）将其转换为整数或浮点数。
- en: 'Since the input is a string, we need to make use of some functions to either
    convert it to the expected type (an integer, in our case) or to test its matching
    type by parsing it. We made use of the `is_numeric()` function that tells whether
    the input looks like a number, but to test whether the string input looks like
    a decimal, we will have to do this little trick of multiplying by 1, since what
    PHP does, in this case, is to convert the variables involved in the operation
    depending on the context; in our case, in the arithmetical multiplication operation,
    PHP would convert both operands to either a float or integer type. For example,
    `"3.14" * 1` will result in a floating-point number with a value of `3.14`:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于输入是字符串，我们需要使用一些函数将其转换为预期的类型（在我们的例子中是整数）或通过解析来测试其匹配的类型。我们使用了 `is_numeric()`
    函数，它告诉我们输入看起来像数字，但为了测试字符串输入看起来像小数，我们必须进行这个乘以 1 的小技巧，因为在这种情况下，PHP 会根据上下文将涉及的变量转换为浮点数或整数类型。例如，`"3.14"
    * 1` 将得到一个值为 `3.14` 的浮点数：
- en: '![Figure 8.10: Floating point output'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.10：浮点数输出'
- en: '](img/C14196_08_10.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_10.jpg)'
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And, in the end, we check whether the number provided is negative. If it''s
    negative, then we simply use the absolute value, with the help of the `abs()`
    function. Also, we trigger a warning error to provide a notification that negative
    numbers are not allowed to run in this script, an error that will not halt the
    execution of the script:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查提供的数字是否为负数。如果是负数，我们则简单地使用绝对值，借助 `abs()` 函数。此外，我们触发一个警告错误，以提供通知，说明在此脚本中不允许运行负数，这个错误不会终止脚本的执行：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the last part of the script, we finally executed and printed the square
    root of the input:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的最后部分，我们最终执行并打印了输入的平方根：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run this script in the command-line interface:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行此脚本：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will get the following output:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 8.11: Error message'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.11：错误消息'
- en: '](img/C14196_08_11.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_11.jpg)'
- en: 'Figure 8.11: Error message'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.11：错误消息
- en: In this case, the first condition was not met, since the first argument was
    not provided. Therefore, the script was halted after the error message was printed.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个条件未满足，因为第一个参数未提供。因此，在打印错误消息后，脚本被终止。
- en: 'Now, execute the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行以下命令：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/C14196_08_12.jpg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/C14196_08_12.jpg)'
- en: 'Figure 8.12: Error on adding text as a value'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.12：将文本作为值添加时的错误
- en: Just like in the previous example, the script was halted because of `E_USER_ERROR`
    (code `256`) due to invalid input; that would be condition number two – the input
    must be a number.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像上一个例子一样，脚本因为 `E_USER_ERROR`（代码 `256`）而终止，这是由于无效输入；这将是条件编号二——输入必须是数字。
- en: 'Now, run the following command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.13: Output of the command'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13：命令输出'
- en: '](img/C14196_08_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_13.jpg)'
- en: 'Figure 8.13: Output of the command'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13：命令输出
- en: The first line is an error message (a warning – `error code 512`) that provides
    a notification of the fact that the `-81.3` input value was altered, and now the
    rounded value, `-81`, will be used to allow the script to continue.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个错误消息（一个警告 - `错误代码512`），它通知我们`-81.3`输入值已被更改，现在将使用四舍五入的值`-81`，以便脚本继续执行。
- en: The second line is another warning that notices the sign change for the input
    value, so instead of the negative `-81`, it will use the absolute value, `81`,
    allowing the script to execute further.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是另一个警告，它注意到输入值的符号变化，因此将使用绝对值`81`而不是负数`-81`，允许脚本进一步执行。
- en: 'Finally, on the last line, we get the processing output, `sqrt(81) = 9`. This
    is the only line we would get if we give `81` as an input argument instead of
    `-81.3`, due to the correct format of the input. Of course, any number can be
    used, so by running `php sqrt.php 123`, we get `sqrt(123) = 11.090536506409` as
    output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一行，我们得到了处理输出，`sqrt(81) = 9`。如果我们用`81`作为输入参数而不是`-81.3`，由于输入格式的正确性，我们只会得到这一行。当然，任何数字都可以使用，所以通过运行`php
    sqrt.php 123`，我们得到输出`sqrt(123) = 11.090536506409`：
- en: '![Figure 8.14: Printing the square root of 123'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：打印123的平方根'
- en: '](img/C14196_08_14.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：打印123的平方根](img/C14196_08_14.jpg)'
- en: 'Figure 8.14: Printing the square root of 123'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：打印123的平方根
- en: As you can see, in this exercise, we made use of user-triggered errors that
    were handled by our custom error handler. The `E_ERROR` and `E_USER_ERROR` error
    types will cause the script to be halted immediately on account of their nature.
    Also, you saw that warnings show that the script did not execute following the
    ideal path; the input data was altered, or some assumptions were made (such as
    using a constant name that was not defined – PHP will assume that name to be a
    string instead of null or an empty value). So, in the event of warnings, it is
    better to take action immediately and resolve any ambiguity. In our example, we
    used some warnings for invalid input, but we could use some lower-level warnings,
    such as `E_USER_NOTICE`, to give less importance to the error log entry, or higher-level
    warnings, such as `E_USER_ERROR`, which would halt the script. As you can see,
    these warnings depend on task specifications, and, with PHP, it is easy to achieve
    this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这个练习中，我们使用了由用户触发的错误，这些错误由我们的自定义错误处理器处理。`E_ERROR`和`E_USER_ERROR`错误类型由于其性质会导致脚本立即停止。你也看到了警告表明脚本没有按照理想路径执行；输入数据被更改，或者做出了某些假设（例如使用未定义的常量名称
    - PHP将假设该名称为字符串而不是null或空值）。因此，在警告的情况下，最好立即采取行动并解决任何歧义。在我们的例子中，我们使用了一些警告来处理无效输入，但我们可以使用一些更底层的警告，如`E_USER_NOTICE`，以降低错误日志条目的重要性，或者使用更高级的警告，如`E_USER_ERROR`，这将停止脚本。正如你所见，这些警告取决于任务规范，并且使用PHP很容易实现这一点。
- en: Logging Errors at Script Shutdown
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本关闭时记录错误
- en: Fatal errors, such as a call to an undefined function or the instantiations
    of an unknown class, cannot be handled by the registered error handler. They would
    simply halt script execution. So, you might ask why we then use `E_ALL` as the
    `$error_types` argument in `set_error_handler()`. This is just for convenience,
    because it is easiest to remember, and it describes, in some way, the fact that
    it's covering all the error types it can cover. The thing is that fatal errors
    have to halt script execution, and if this simple responsibility was left to the
    custom error handler, it would have been easy to bypass by simply not invoking
    script halting with `exit()` or its alias, `die()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 致命错误，如调用未定义的函数或实例化未知类，无法由注册的错误处理器处理。它们会简单地停止脚本执行。所以，你可能会问为什么我们还在`set_error_handler()`中将`$error_types`参数设置为`E_ALL`。这只是为了方便，因为它最容易记住，并且在某种程度上描述了它涵盖了所有可以覆盖的错误类型。问题是，致命错误必须停止脚本执行，如果这个简单的责任留给自定义错误处理器，那么通过简单地不使用`exit()`或其别名`die()`来停止脚本执行，就很容易绕过它。
- en: 'It is still possible to *catch* and log some of the fatal errors, by using
    the `register_shutdown_function()` function – which does exactly this – registers
    a *function* (a callable) to be invoked at script shutdown, and `error_get_last()`,
    which will return the last error, if any:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以通过使用`register_shutdown_function()`函数来**捕获**和记录一些致命错误 - 这个函数正是这样做的 - 它注册一个**函数**（一个可调用的对象）在脚本关闭时被调用，以及`error_get_last()`，它将返回最后一个错误（如果有的话）：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the first parameter is a callable to be invoked at shutdown, followed
    by optional parameters that will become `$callback` arguments. Consider the following
    snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数是要在关闭时调用的可调用函数，后面跟着可选参数，这些参数将成为`$callback`参数。考虑以下代码片段：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the snippet, the callable receives two arguments – the string `$file`, and
    the integer `$line` – values of which are set by the `__FILE__` and `__LINE__`
    magic constants, passed as parameters with number two and three in `register_shutdown_function()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，可调用函数接收两个参数——字符串`$file`和整数`$line`——它们的值由`__FILE__`和`__LINE__`魔术常量设置，作为参数在`register_shutdown_function()`中传递，编号为二和三。
- en: 'Multiple functions can be registered for invocation at shutdown, using `register_shutdown_function()`.
    These functions will be called in the order of their registration. If we call
    `exit()` within any of these registered functions, processing will stop immediately:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`register_shutdown_function()`注册多个函数，以便在关闭时调用。这些函数将按照它们的注册顺序被调用。如果我们在这其中任何一个注册的函数中调用`exit()`，处理将立即停止：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: No parameters are expected by the `error_get_last()` function, and the output
    is the aforementioned associative array that describes the error or, if no error
    has happened thus far, then `null` is output.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_get_last()`函数不期望任何参数，输出是上述关联数组，描述错误或，如果没有发生错误，则输出`null`。'
- en: 'Exercise 8.4: Logging Fatal Errors at Shutdown'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.4：在关闭时记录致命错误
- en: 'Spotting fatal errors is very important because it will give you important
    information on why exactly the application crashes when it does. In this exercise,
    we want to catch and print the information relating to script halting (the reason
    and the place where it happened). Therefore, you will log such errors using the
    custom error handler, previously created and registered in the `error-handler.php`
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 查找致命错误非常重要，因为它将给你提供重要信息，说明应用程序为什么在崩溃时确实会崩溃。在这个练习中，我们想要捕获并打印与脚本停止（原因和发生的地方）相关的信息。因此，你将使用之前创建并注册在`error-handler.php`文件中的自定义错误处理程序记录这样的错误：
- en: 'Create a file called `on-shutdown.php` and insert the following content. Unlike
    other examples, we now store the error handler file output, which is the custom
    error handler callback (remember the last line, `return $errorHandler;`, in the
    `''error-handler.php''` file?). We want to keep the error handler for later use:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`on-shutdown.php`的文件，并插入以下内容。与其他示例不同，我们现在存储错误处理程序文件输出，即自定义错误处理程序回调（记得在`'error-handler.php'`文件中的最后一行，`return
    $errorHandler;`？）我们希望保留错误处理程序以供以后使用：
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this step, we define the shutdown function, which gets the last error using
    the `error_get_last()` function, and stores it in the `$error` variable, which
    is evaluated, and, if it''s not null, then goes to the next step. If you have
    an error type of `E_ERROR` or `E_RECOVERABLE_ERROR`, then proceed further:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们定义了关闭函数，该函数使用`error_get_last()`函数获取最后一个错误，并将其存储在`$error`变量中，该变量将被评估，如果它不为空，则进入下一步。如果你有一个`E_ERROR`或`E_RECOVERABLE_ERROR`类型的错误，那么继续下一步：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We used `[E_ERROR, E_RECOVERABLE_ERROR]` in this example; feel free to use all
    fatal error codes in your code.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`[E_ERROR, E_RECOVERABLE_ERROR]`；你可以在你的代码中使用所有致命错误代码。
- en: 'Now, it''s time to use the error handler; it is invoked, and the parameters
    are specified in the appropriate order, so as to match the callback signature:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用错误处理程序了；它被调用，参数按照适当的顺序指定，以便与回调签名匹配：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Since the last error we got has the same structure as any other errors, instead
    of duplicating the logic of the handler (logging the error in a specific format),
    we have reused the error handler callback for this purpose.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们得到的最后一个错误的结构与任何其他错误相同，我们不是重复处理程序的逻辑（以特定格式记录错误），而是重用了错误处理程序回调来完成这个目的。
- en: 'The shutdown function is registered using `register_shutdown_function()`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`register_shutdown_function()`注册关闭函数：
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the last line of the script, we simply try to instantiate a class that does
    not exist in order to trigger the fatal error:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的最后一行，我们只是尝试实例化一个不存在的类，以触发致命错误：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the script in the command-line interface with `php on-shutdown.php;` you
    should see the following output:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在命令行界面中运行脚本`php on-shutdown.php;`，你应该看到以下输出：
- en: '![Figure 8.15: Screenshot of the error message'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：错误信息的截图'
- en: '](img/C14196_08_15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_15.jpg)'
- en: 'Figure 8.15: Screenshot of the error message'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：错误信息的截图
- en: This message is an `E_ERROR` that is printed by the default error handler, which
    is also responsible for halting the script execution in the event of such a fatal
    error, as discussed earlier. So, you may be wondering whether we can handle it
    before the default handler gets invoked, and we can actually do that, but let's
    look at this further.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息是一个由默认错误处理器打印的 `E_ERROR`，该处理器还负责在发生此类致命错误时停止脚本执行，如前所述。因此，你可能想知道我们是否可以在默认处理器被调用之前处理它，实际上我们可以做到，但让我们进一步看看。
- en: 'This is a lot of information for a single error. Here is what happens:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个错误来说，这里有太多的信息。以下是发生的情况：
- en: '![Figure 8.16: Information for all the error messages'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16：所有错误信息的说明'
- en: '](img/C14196_08_16.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_16.jpg)'
- en: 'Figure 8.16: Information for all the error messages'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：所有错误信息的说明
- en: This message includes the same information – we have the call stack as well
    (the path the runtime process followed until reaching the error). This error message
    is a throwable error (better known as an exception) and is printed by the default
    exception handler. The exceptions are special objects, which contain error information,
    and which we will learn about in more detail. In this particular case, because
    no custom exception handler is registered, the exception is converted to an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息包含相同的信息——我们还有调用堆栈（运行时过程到达错误之前遵循的路径）。这条错误信息是一个可抛出的错误（也称为异常），由默认异常处理器打印。异常是特殊对象，包含错误信息，我们将更详细地了解它们。在这种情况下，因为没有注册自定义异常处理器，所以异常被转换为错误。
- en: In the last block (the third message box), we print the converted error, which
    is sent to the custom error handler.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个块（第三个消息框）中，我们打印转换后的错误信息，该信息被发送到自定义错误处理器。
- en: The output may look unexpected, but it makes sense. Trying to instantiate an
    unknown class will trigger an error exception, which, in the absence of a registered
    custom exception handler, will convert the exception to an error and will fire
    both – the default error handler and the default exception handler. In the end,
    with the script shut down, the shutdown function gets invoked, where we catch
    the last error and send it to our custom error handler to be logged.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能看起来出乎意料，但这是有道理的。尝试实例化一个未知的类将触发错误异常，如果没有注册自定义异常处理器，异常将被转换为错误，并将触发默认错误处理器和默认异常处理器。最终，随着脚本的关闭，关闭函数被调用，我们在那里捕获最后一个错误并将其发送到我们的自定义错误处理器进行记录。
- en: Exceptions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: An exception is an event that occurs during the runtime of a program, and that
    disrupts its normal flow.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是在程序运行时发生的事件，它破坏了其正常流程。
- en: Starting with version 7, PHP changed the way in which errors are reported. Unlike
    the traditional error reporting mechanism used in PHP 5, in version 7, PHP uses
    an object-oriented approach to deal with errors. Consequently, many errors are
    now thrown as exceptions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 7 开始，PHP 改变了错误报告的方式。与 PHP 5 中使用的传统错误报告机制不同，在版本 7 中，PHP 使用面向对象的方法来处理错误。因此，现在许多错误都被抛出为异常。
- en: The exception model in PHP (supported since version 5) is similar to other programming
    languages. Therefore, when an error occurs, it is transformed into an object –
    the exception object – that contains relevant information about the error and
    the location where it was triggered. We can throw and catch exceptions in a PHP
    script. When the exception is thrown, it is handed to the runtime system, which
    will try to find a place in the script where the exception can be handled. This
    place that is looked for is called the exception handler, and it will be searched
    for in the list of functions that are called in the current runtime, until the
    exception was thrown. This list of functions is known as the call stack. First,
    the system will look for the exception handler in the current function, proceeding
    through the call stack in reverse order. When an exception handler is found, before
    the system handles the exception, it will first match the type of exceptions that
    the found exception handler accepts. If there is a match, then the script execution
    will resume in that exception handler. When no exception handler is found in the
    call stack, the default PHP exception handler will be handed the exception, and
    the script execution will halt.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中的异常模型（自版本 5 起支持）与其他编程语言类似。因此，当发生错误时，它会被转换成一个对象——异常对象，该对象包含有关错误及其触发位置的相关信息。我们可以在
    PHP 脚本中抛出和捕获异常。当异常被抛出时，它会被传递给运行时系统，该系统将尝试在脚本中找到一个可以处理异常的位置。这个要查找的位置被称为异常处理器，它将在当前运行时调用的函数列表中进行搜索，直到异常被抛出。这个函数列表被称为调用栈。首先，系统将在当前函数中查找异常处理器，然后按调用栈的逆序进行搜索。当找到异常处理器时，在系统处理异常之前，它将首先匹配找到的异常处理器接受的异常类型。如果匹配成功，则脚本执行将在该异常处理器中继续。如果在调用栈中没有找到异常处理器，则默认的
    PHP 异常处理器将接收到异常，脚本执行将停止。
- en: The base class for exceptions was the `Exception` class, starting with PHP version
    5 when exceptions were introduced to PHP.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的基类是 `Exception` 类，从 PHP 版本 5 开始引入异常时起。
- en: Now, let's go back to the error reporting in PHP 7\. Starting with PHP 7, most
    fatal errors are converted to exceptions and, to ensure backward compatibility
    for existing scripts (and for libraries to be able to be consistent with exception
    handlers in both PHP 5.x and PHP 7.x), fatal error exceptions are thrown with
    a *new exception base class* called `Error`. At the same time, a new interface
    was added, called `Throwable`, which is implemented by both the `Exception` and
    `Error` classes. Therefore, catching `Throwable` in a `try-catch` block will result
    in catching any possible exception.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 PHP 7 的错误报告。从 PHP 7 开始，大多数致命错误都被转换成异常，为了确保现有脚本的向后兼容性（以及库能够在 PHP 5.x
    和 PHP 7.x 中与异常处理器保持一致），致命错误异常使用一个新的异常基类 `Error` 抛出。同时，添加了一个新的接口，称为 `Throwable`，它由
    `Exception` 和 `Error` 类实现。因此，在 `try-catch` 块中捕获 `Throwable` 将导致捕获任何可能的异常。
- en: Basic Usage
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Consider the following block of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码块：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we can distinguish four keywords: `try`, `throw`, `catch`, and `finally`.
    I''ll explain the code block and keyword usage here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以区分四个关键字：`try`、`throw`、`catch` 和 `finally`。我将在下面解释代码块和关键字的使用：
- en: The `try` block is used to run any code that is expected to fail in an exceptional
    case (throwing an exception error). Inside this block, we may throw exceptions
    explicitly or not if (when the exception is thrown by a function, that we run
    inside the `try` block,), relying on the bubbling-up-stack exceptions, property
    of exceptions to go back through the call stack (searching for an exception handler
    mentioned previously);
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 块用于运行在异常情况下预期会失败（抛出异常错误）的任何代码。在这个块内部，我们可以显式地抛出异常，或者不抛出异常（当我们在 `try` 块中运行的函数抛出异常时），依靠异常的冒泡特性，通过调用栈回溯（搜索前面提到的异常处理器）；'
- en: '`throw` is used to trigger a new exception, and it requires an exception class
    instance as an argument (any class that extends the `Exception` or `Error` class
    – more on this later).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw` 用于触发一个新的异常，并且需要一个异常类实例作为参数（任何扩展 `Exception` 或 `Error` 类的类——关于这一点稍后讨论）。'
- en: The `catch` block is used to handle exceptions, and requires the exception type
    (class) to "catch", and the variable name under which the exception will be stored;
    the exception type can be a concrete class name, an abstract class name, or an
    interface name – the caught exceptions are the ones that implement, extend, or
    indeed are the concrete-specified classes; multiple `catch` blocks may be specified,
    but only the first type-matching caught exception block will be executed; in the
    absence of any `catch` block, the `finally` block is required.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`块用于处理异常，需要指定要“捕获”的异常类型（类）以及异常将被存储的变量名；异常类型可以是具体的类名、抽象类名或接口名——捕获的异常是实现了、扩展了或确实是具体指定的类的异常；可以指定多个`catch`块，但只有第一个类型匹配的捕获异常块将被执行；如果没有任何`catch`块，则必须要有`finally`块。'
- en: The `finally` block will run the code inside it for each `try` attempt, even
    if no exception was thrown, or if the exception was thrown and caught, or if the
    exception was thrown but wasn't caught with any of the `catch` blocks. This is
    especially useful in the case of long-running processes for closing the open resources
    after the specific task ends (files, database connections, and so on).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`块将为每个`try`尝试运行其内部的代码，即使没有抛出异常，或者如果抛出了异常并被捕获，或者如果抛出了异常但没有被任何`catch`块捕获。这在长时间运行的过程结束时关闭打开的资源（文件、数据库连接等）特别有用。'
- en: In the preceding example, the script enters the `try` block and checks whether
    the first argument is set at runtime and, if it isn't set, it will throw an exception
    of the `Exception` type, which is caught by the `catch` block, because it expects
    exceptions of the `Exception` class, `Exception` `$e` variable after entering
    the `catch` block.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，脚本进入`try`块并检查第一个参数是否在运行时设置，如果没有设置，它将抛出一个`Exception`类型的异常，该异常被`catch`块捕获，因为它期望捕获`Exception`类的异常，`Exception`
    `$e`变量在进入`catch`块后。
- en: 'Exercise 8.5: Implementing Exceptions'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.5：实现异常
- en: 'In this exercise, you will throw and catch exceptions in PHP. To achieve this,
    we will create a script that will instantiate a class based on user input. Also,
    the script will print several sentences to trace the script flow in order to understand
    better how the exception mechanism works in PHP:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在PHP中抛出和捕获异常。为了实现这一点，我们将创建一个基于用户输入实例化类的脚本。此外，脚本将打印几句话以跟踪脚本流程，以便更好地理解PHP中的异常机制：
- en: 'Create a file called `basic-try.php` and add the following code. Mark the beginning
    of the script with a `SCRIPT START` message:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`basic-try.php`的文件，并添加以下代码。用`SCRIPT START`消息标记脚本的开始：
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open a `try` block and print the `Run TRY block` message:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个`try`块并打印`Run TRY block`消息：
- en: '[PRE32]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If no class name is specified in the input argument, print the `NO ARGUMENT:
    Will throw exception.` message to give notification of the intention, and throw
    an exception:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果在输入参数中没有指定类名，打印`NO ARGUMENT: Will throw exception.`消息以通知意图，并抛出异常：'
- en: '[PRE33]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Otherwise, when we have an input argument, we print it and try an instantiation
    assuming the input argument is a known class name. The new object is dumped to
    output with the `var_dump()` function:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，当我们有一个输入参数时，我们打印它并尝试实例化，假设输入参数是一个已知的类名。使用`var_dump()`函数将新对象输出到输出：
- en: '[PRE34]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Close the `try` block and add the `catch` block, hinting the `Exception` class
    as the accepted exceptions type to be caught. In the `catch` block, we print the
    exception information formatted in a text message:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`try`块并添加`catch`块，提示接受的异常类型为`Exception`类。在`catch`块中，我们打印格式化的异常信息文本消息：
- en: '[PRE35]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the `finally` block, which does nothing special in this script, except
    print the information about reaching this stage of the execution process:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个脚本中，除了打印关于到达执行过程这一阶段的信息外，不执行任何特殊操作的`finally`块：
- en: '[PRE36]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, print the message informing the user that the script execution has
    exited the `try/catch` block and that the script will end:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印一条消息通知用户脚本执行已退出`try/catch`块，并且脚本将结束：
- en: '[PRE37]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the script in the command-line interface using the following command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在命令行界面运行脚本：
- en: '[PRE38]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output should look like this:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 8.17: Output of the try/catch program'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.17：try/catch程序的输出'
- en: '](img/C14196_08_17.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_08_17.jpg)'
- en: 'Figure 8.17: Output of the try/catch program'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.17：try/catch程序的输出
- en: Notice that the last two lines of the `try` block did not execute, and that's
    because an exception was thrown – `LogicException`, due to a missing input argument.
    The exception gets caught by the `catch` block, and some information is printed
    onscreen – the message, file, and the line of the `throw` location. Since the
    exception is caught, the script resumes its execution.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`try`块的最后两行没有执行，这是因为抛出了一个异常——由于缺少输入参数而引发的`LogicException`。异常被`catch`块捕获，并在屏幕上打印了一些信息——错误消息、文件和`throw`位置所在的行。由于异常被捕获，脚本继续执行。
- en: 'Now, run `php basic-try.php DateTime;` the output will be as follows:![Figure
    8.18: Output of the command'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`php basic-try.php DateTime;`，输出将如下：![图8.18：命令输出
- en: '](img/C14196_08_18.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_18.jpg)'
- en: 'Figure 8.18: Output of the command'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.18：命令输出
- en: 'You will notice that, now, we have `ARGUMENT: DateTime` in the output, followed
    by the `DateTime` instance dump. The script flow is the *normal* one, without
    any exceptions thrown.'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '你会注意到，现在输出中有了`ARGUMENT: DateTime`，后面跟着`DateTime`实例的转储。脚本流程是*正常*的，没有抛出任何异常。'
- en: 'Run the script with `php basic-try.php DateTimeZone`; the output is as follows:![Figure
    8.19: Throwing error due to missing parameter'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`php basic-try.php DateTimeZone`运行脚本，输出如下：![图8.19：由于缺少参数抛出错误
- en: '](img/C14196_08_19.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_19.jpg)'
- en: 'Figure 8.19: Throwing error due to missing parameter'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.19：由于缺少参数抛出错误
- en: Now, we got an exception error, and the interesting thing here is that the exception
    does not appear to be caught – see that the `ARGUMENT` line in the output is followed
    by the `FINALLY` line, and no `EXCEPTION` is printed. This is because the thrown
    exception does not extend the `Exception` class.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们得到了一个异常错误，有趣的是，这个异常似乎没有被捕获——看到输出中的`ARGUMENT`行后面跟着`FINALLY`行，并且没有打印出`EXCEPTION`。这是因为抛出的异常没有扩展`Exception`类。
- en: In the preceding example, `ArgumentCountError` is extending the `Error` exception
    class and is not caught by the `catch (Exception $e)` statement. Therefore, the
    exception was handled by the default exception handler and the script process
    was halted – notice that the `FINALLY` line is not followed by either the `Outside
    TRY-CATCH.` or `SCRIPT END.` lines.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，`ArgumentCountError`扩展了`Error`异常类，并且没有被`catch (Exception $e)`语句捕获。因此，异常由默认异常处理器处理，脚本进程被终止——注意`FINALLY`行后面既没有`Outside
    TRY-CATCH.`也没有`SCRIPT END.`行。
- en: 'Copy the script to a new file called `basic-try-all.php` and add the `catch
    (Error $e)` block; the added code should be placed somewhere between the `try`
    and `finally` blocks:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本复制到名为`basic-try-all.php`的新文件中，并添加`catch (Error $e)`块；添加的代码应放置在`try`和`finally`块之间：
- en: '[PRE39]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the following command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE40]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.20: Output of the command executed'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：执行命令的输出'
- en: '](img/C14196_08_20.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_20.jpg)'
- en: 'Figure 8.20: Output of the command executed'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：执行命令的输出
- en: As expected, the error exception was now caught and printed in our format, and
    the script did not end unexpectedly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，错误异常现在被捕获并以我们的格式打印出来，脚本没有意外终止。
- en: In this example, we saw how it is possible to catch exceptions. More than that,
    we learned the two base exception classes, and we now understand the difference
    between them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了如何捕获异常。不仅如此，我们还学习了两个基本异常类，并且我们现在理解了它们之间的区别。
- en: 'In the previous exercise, the throwable interface was mentioned, which is implemented
    by both the `Error` and `Exception` classes. Since the SPL (Standard PHP Library)
    offers a rich list of exceptions, let''s display the exception hierarchy for `Error`
    exceptions that were added in version 7 of the PHP:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中提到了可抛出接口，该接口由`Error`和`Exception`类实现。由于SPL（标准PHP库）提供了一系列丰富的异常，让我们显示PHP
    7版本中添加的`Error`异常的异常层次结构：
- en: '![Figure 8.21: Exception hierarchy'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：异常层次结构'
- en: '](img/C14196_08_21.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_08_21.jpg)'
- en: 'Figure 8.21: Exception hierarchy'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：异常层次结构
- en: Many other custom exception classes can be found in today's modern PHP libraries
    and frameworks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 今天现代的PHP库和框架中可以找到许多其他自定义异常类。
- en: Custom Exceptions
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义异常
- en: In PHP, it is possible to define custom exceptions, and also to extend them
    with custom functionality. Custom exceptions are useful since the basic functionality
    can be extended according to application needs, bundling business logic in a base
    application exception class. Also, they bring meaning to the application flow,
    by being named according to the business logic to which they are related.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，可以定义自定义异常，并使用自定义功能扩展它们。自定义异常很有用，因为可以根据应用需求扩展基本功能，将业务逻辑捆绑在基应用异常类中。此外，它们通过根据相关的业务逻辑命名来为应用流程带来意义。
- en: 'Exercise 8.6: Custom Exceptions'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.6：自定义异常
- en: 'In this exercise, we will define a custom exception, with extended functionality,
    which we will throw and catch, and the custom formatted message will then be printed
    on the screen. Specifically, this is a script that validates an email address:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个具有扩展功能的自定义异常，我们将抛出并捕获它，然后将在屏幕上打印自定义格式的消息。具体来说，这是一个验证电子邮件地址的脚本：
- en: 'Create a file called `validate-email.php` and define the custom exception class,
    called `InvalidEmail`, which will extend the `Exception` class. In addition, the
    new exception class provides the option to store and retrieve the context as an
    array:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `validate-email.php` 的文件，并定义一个名为 `InvalidEmail` 的自定义异常类，它将扩展 `Exception`
    类。此外，新的异常类提供了存储和检索上下文为数组的选项：
- en: '[PRE41]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The suggested exception name does not include the `Exception` suffix, as this
    is used as a naming convention. Although exception names don't require a specific
    format, some developers prefer to add the `Exception` suffix, bringing the "specificity-in-class-name"
    argument, while others prefer not to include the suffix, bringing the "easier-to-read-the-code"
    argument. Either way, the PHP engine doesn't care, leaving the exception naming
    convention up to the developer or to the organization for which the code is written.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议的异常名称不包括 `Exception` 后缀，因为这用作命名约定。尽管异常名称不需要特定的格式，一些开发者更喜欢添加 `Exception` 后缀，以提供“在类名中具有特异性”的论点，而其他人则更喜欢不包含后缀，以提供“更容易阅读代码”的论点。无论如何，PHP
    引擎并不关心，将异常命名约定留给开发者或编写代码的组织。
- en: Add the `validateEmail()` function, which returns nothing, but throws exceptions
    in the case of errors. The `validateEmail()` function expects the input parameter
    to be the same as script input arguments. If position `1` of the input array is
    not set (the first argument is not present), then an `InvalidArgumentException`
    exception is thrown. After this step, the function execution will stop. Otherwise,
    when position `1` is set, we validate the value with the built-in `filter_var()`
    function
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `validateEmail()` 函数，该函数不返回任何内容，但在出错的情况下会抛出异常。`validateEmail()` 函数期望输入参数与脚本输入参数相同。如果输入数组的第
    `1` 个位置未设置（第一个参数不存在），则抛出 `InvalidArgumentException` 异常。在此步骤之后，函数执行将停止。否则，当第 `1`
    个位置设置时，我们将使用内置的 `filter_var()` 函数验证该值。
- en: 'and the `FILTER_VALIDATE_EMAIL` flag. If the validation fails, then we instantiate
    the `InvalidEmail` exception class, set the context with the test value, and then
    throw it:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和 `FILTER_VALIDATE_EMAIL` 标志。如果验证失败，则实例化 `InvalidEmail` 异常类，设置上下文为测试值，然后抛出它：
- en: '[PRE42]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use a `try-catch` block to run the `validateEmail()` function and print the
    success message if no exceptions were thrown, or if the exception stipulates otherwise:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `try-catch` 块运行 `validateEmail()` 函数，并在没有抛出异常或异常规定的情况下打印成功消息：
- en: '[PRE43]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Therefore, in the `try` block, you will invoke the `validateEmail()` function
    and print the successful validation message. The message will be printed only
    if no exception is thrown by the `validateEmail()` function. Instead, if an exception
    is thrown, it will be caught in the `catch` block, where the error message will
    be printed onscreen. The error message will include the error type (the exception
    class name), the message, and the file and line number where the exception was
    created. Also, in the case of a custom exception, we will include the context
    as well, JSON-encoded.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在 `try` 块中，你将调用 `validateEmail()` 函数并打印成功的验证消息。只有当 `validateEmail()` 函数没有抛出异常时，才会打印该消息。相反，如果抛出异常，它将在
    `catch` 块中被捕获，错误消息将打印在屏幕上。错误消息将包括错误类型（异常类名）、消息以及异常创建的文件和行号。此外，在自定义异常的情况下，我们还将包括上下文，以
    JSON 编码。
- en: 'Run the script without an argument:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带参数运行脚本：
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will look like this:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.22: Executing code without passing arguments'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.22：执行不带参数的代码'
- en: '](img/C14196_08_22.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_08_22.jpg)'
- en: 'Figure 8.22: Executing code without passing arguments'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.22：执行不带参数的代码
- en: We got `InvalidArgumentException`, as expected since no argument was provided
    to the script.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到了预期的 `InvalidArgumentException`，因为没有向脚本提供任何参数。
- en: 'Run the script with invalid arguments:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无效参数运行脚本：
- en: '[PRE45]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output will look like this:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '![Figure 8.23: Executing code with invalid arguments'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.23：执行带无效参数的代码'
- en: '](img/C14196_08_23.jpg)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_08_23.jpg)'
- en: 'Figure 8.23: Executing code with invalid arguments'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.23：执行带无效参数的代码
- en: This time, the caught exception is `InvalidEmail`, and the context information
    is included in the message that is printed onscreen.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，捕获到的异常是 `InvalidEmail`，上下文信息包含在打印到屏幕上的消息中。
- en: 'Run the script with a valid email address:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用有效的电子邮件地址运行脚本：
- en: '[PRE46]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will look like this:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '![Figure 8.24: Output for a valid email address'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.24：有效电子邮件地址的输出'
- en: '](img/C14196_08_24.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_24.jpg)'
- en: 'Figure 8.24: Output for a valid email address'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24：有效电子邮件地址的输出
- en: This time, the validation was successful, and the confirmation message is printed
    onscreen.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，验证成功，确认信息已打印到屏幕上。
- en: In this exercise, you created your own custom exception class, and it can be
    used along with its extended functionality. The script is not only able to validate
    the input as email, but it will also give the reason (exception) in the case of
    validation failure, bundling some helpful context when appropriate.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了自己的自定义异常类，并且它可以与扩展功能一起使用。脚本不仅能够验证输入作为电子邮件，而且在验证失败的情况下，还会提供原因（异常），并在适当的时候捆绑一些有用的上下文。
- en: Custom Exception Handler
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义异常处理器
- en: Usually, you only want to catch and treat certain exceptions, allowing the application
    to run further. Sometimes, however, it is not possible to continue without the
    right data; you do want the application to stop, and you want to do it gracefully
    and consistently (for example, an error page for web applications, specific message
    formats and details for a command-line interface).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只想捕获和处理某些异常，允许应用程序继续运行。有时，然而，没有正确数据就无法继续；您希望应用程序停止，并且希望以优雅和一致的方式（例如，为网络应用程序的错误页面，为命令行界面提供特定的消息格式和详细信息）停止。
- en: 'To accomplish this, you can use the `set_exception_handler()` function. The
    syntax is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您可以使用 `set_exception_handler()` 函数。其语法如下：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function expects a callable as an exception handler, and this handler should
    accept a `Throwable` as a first parameter. `NULL` can be passed as well, instead
    of a callable; in this case, the default handler will be restored. The return
    value is the previous exception handler or `NULL` in the case of errors or no
    previous exception handler. Usually, the return value is ignored.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数期望一个可调用的异常处理器，并且此处理器应该接受一个 `Throwable` 作为第一个参数。也可以传递 `NULL` 作为可调用项；在这种情况下，将恢复默认处理器。返回值是之前的异常处理器或错误或没有之前的异常处理器时的
    `NULL`。通常，返回值会被忽略。
- en: Using a Custom Exception Handler
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义异常处理器
- en: Just like in the default error handler case, the default exception handler in
    PHP will print the error and will also halt script execution. Since you don't
    want any of these messages to reach the end user, you would prefer to register
    your own exception handler, where you can implement the same functionality as
    in the error handler – render the messages in a specific format and log them for
    debugging purposes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在默认错误处理器的情况下，PHP中的默认异常处理器会打印错误信息，并且也会停止脚本执行。由于您不希望任何这些信息到达最终用户，您可能更愿意注册自己的异常处理器，在那里您可以实现与错误处理器相同的功能
    – 以特定格式渲染消息并记录以供调试。
- en: 'Exercise 8.7: Using a Custom Exception Handler'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.7：使用自定义异常处理器
- en: 'In this exercise, you will define, register, and use a custom exception handler
    that will print errors in a specific format:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将定义、注册和使用一个自定义异常处理器，该处理器将以特定格式打印错误信息：
- en: 'Create a file called `exception-handler.php` and add the following content.
    Define and register your own exception handler:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `exception-handler.php` 的文件，并添加以下内容。定义并注册您自己的异常处理器：
- en: '[PRE48]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this file, we register the exception handler, which is an anonymous function
    that accepts the `Throwable` parameter as a `$e` variable. Then, we calculate
    the message length and create a line of dashes, of the same length as the error
    message, using the `mb_strlen()` and `str_repeat()` built-in functions. What follows
    is simple formatting for the message, including the file and line where the exception
    was created, and the exception trace; everything being wrapped by two dashed lines
    – one on top, and the other on the bottom, of the message block.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个文件中，我们注册了异常处理器，它是一个接受`Throwable`参数作为`$e`变量的匿名函数。然后，我们使用`mb_strlen()`和`str_repeat()`内置函数计算消息长度，并创建一条与错误消息长度相同的横线。接下来是对消息的简单格式化，包括异常创建的文件和行号，以及异常跟踪；所有这些都被两条横线包裹，一条在消息块的顶部，另一条在底部。
- en: 'We will use the `basic-try.php` file as the starting point for our example.
    Copy this file to `basic-try-handler.php` and include the `exception-handler.php`
    file in `basic-try-handler.php`, right after the `SCRIPT START` line:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`basic-try.php`文件作为我们例子的起点。将此文件复制到`basic-try-handler.php`，并在`basic-try-handler.php`中的`SCRIPT
    START`行之后包含`exception-handler.php`文件：
- en: '[PRE49]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we know that, in this example, we only catch `Exception`, while we skip
    `Error` exceptions, we''ll run the command directly that would produce the `Error`,
    so that it can get caught by the handler. Therefore, run the following command:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道在这个例子中，我们只捕获`Exception`，而跳过了`Error`异常，因此我们将直接运行会产生`Error`的命令，以便它能够被处理器捕获。因此，运行以下命令：
- en: '[PRE50]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Expect an output similar to the following:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出类似于以下内容：
- en: '![Figure 8.25: Output of the command'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：命令的输出'
- en: '](img/C14196_08_25.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_25.jpg)'
- en: 'Figure 8.25: Output of the command'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：命令的输出
- en: Now, the output looks cleaner than the one produced by the default exception
    handler. Of course, the exception handler can be used to log exceptions, especially
    unexpected ones, and add as much information as possible so that bugs are easier
    to identify and trace.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出看起来比默认异常处理器产生的输出更干净。当然，异常处理器可以用来记录异常，特别是意外的异常，并尽可能添加更多信息，以便更容易识别和追踪错误。
- en: As you may notice, the exception handler is very similar to the error handler
    in PHP. Hence, it would be great if we could use a single callback to perform
    error and exception handling. To help in this matter, PHP provides an exception
    class called `ErrorException`, which translates traditional PHP errors to exceptions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，异常处理器与PHP中的错误处理器非常相似。因此，如果能使用单个回调来执行错误和异常处理将非常棒。为了帮助解决这个问题，PHP提供了一个名为`ErrorException`的异常类，它将传统的PHP错误转换为异常。
- en: Translating Errors to Exceptions
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将错误转换为异常
- en: To translate PHP errors (caught in the error handler) to exceptions, you can
    use the `ErrorException` class. This class extends the `Exception` class and,
    unlike the latter, it has a different constructor function signature from that
    of the class it extends.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要将PHP错误（在错误处理器中捕获）转换为异常，可以使用`ErrorException`类。这个类扩展了`Exception`类，并且与后者不同，它具有与它扩展的类不同的构造函数签名。
- en: 'The constructor syntax of the `ErrorException` class is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorException`类的构造函数语法如下：'
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The accepted parameters are the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接受的参数如下：
- en: '`$message`: The exception message string'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$message`：异常消息字符串'
- en: '`$code`: Integer representing the exception code'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$code`：表示异常代码的整数'
- en: '`$severity`: The severity level of the exception (while this is an integer,
    it is recommended to use one of the `E_*` error code constants)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$severity`：异常的严重级别（虽然这是一个整数，但建议使用`E_*`错误代码常量之一）'
- en: '`$filename`: The filename where the exception was thrown'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$filename`：抛出异常的文件名'
- en: '`$lineno`: The line number in the file where the exception was thrown'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lineno`：抛出异常的文件中的行号'
- en: '`$previous`: The previous exception used for the exception chaining'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$previous`：用于异常链的先前异常'
- en: Now, let's see how this class works.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个类是如何工作的。
- en: 'Exercise 8.8: Translating Errors to Exceptions'
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.8：将错误转换为异常
- en: 'In this exercise, we will register an error handler that will only have to
    translate errors to exceptions and then invoke the exception handler. The exception
    handler will be responsible for handling all exceptions (including the translated
    errors) – this can be logging, rendering an error template, printing an error
    message in a specific format, and so on. In our exercise, we will use the exception
    handler to print the exception in a friendly format, as used in the previous exercise:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将注册一个错误处理器，它只需要将错误转换为异常，然后调用异常处理器。异常处理器将负责处理所有异常（包括转换的错误）——这可以是记录日志、渲染错误模板、以特定格式打印错误消息等。在我们的练习中，我们将使用异常处理器以友好的格式打印异常，就像在之前的练习中使用的那样：
- en: 'Create a file called `all-errors-handler.php`, define the exception handler,
    and then save it under the `$exceptionHandler` variable. This is the same callback
    function we used in the previous exercise:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `all-errors-handler.php` 的文件，定义异常处理器，并将其保存在 `$exceptionHandler` 变量下。这是我们在上一个练习中使用的相同回调函数：
- en: '[PRE52]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we define and assign the error handler to the `$errorHandler` variable.
    This function will instantiate `ErrorException`, using the function arguments
    for class constructor parameters. Then, the exception handler is invoked, passing
    the `ErrorException` instance as the only parameter. Finally, if the error severity
    is `E_USER_ERROR`, curtail execution of the script:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义并分配错误处理器到 `$errorHandler` 变量。此函数将使用函数参数作为类构造函数的参数来实例化 `ErrorException`。然后，调用异常处理器，将
    `ErrorException` 实例作为唯一参数传递。最后，如果错误严重性为 `E_USER_ERROR`，则截断脚本的执行：
- en: '[PRE53]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the last part of the script, we simply set the error and the exception handlers:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的最后部分，我们只是设置了错误和异常处理器：
- en: '[PRE54]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we will test the new handlers using an example where errors were reported,
    and the error handler was used. Let''s pick the `sqrt.php` script, copy it to
    `sqrt-all.php`, and replace the `require_once ''error-handler.php'';` line at
    the beginning of the file with `require_once ''all-errors-handler.php'';`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个错误报告和错误处理器使用的示例来测试新的处理器。让我们选择 `sqrt.php` 脚本，将其复制到 `sqrt-all.php`，并将文件开头的
    `require_once 'error-handler.php';` 行替换为 `require_once 'all-errors-handler.php';`：
- en: '[PRE55]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The content of `sqrt-all.php` can be found at [https://packt.live/2INXt9q](https://packt.live/2INXt9q)
    (the following code is explained in *Exercise 8.3*, *Triggering Errors*):'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqrt-all.php` 的内容可以在 [https://packt.live/2INXt9q](https://packt.live/2INXt9q)
    找到（以下代码在 *练习 8.3*，*触发错误* 中解释）：'
- en: 'Run the following commands in the following sequence:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下顺序运行以下命令：
- en: '[PRE56]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.26: Output for different cases'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.26：不同情况下的输出'
- en: '](img/C14196_08_26.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_26.jpg)'
- en: 'Figure 8.26: Output for different cases'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26：不同情况下的输出
- en: As before, `E_USER_ERROR` (`code 256`) brings the script to a halt, while `E_USER_WARNING`
    (`code 512`) allows the script to continue.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`E_USER_ERROR`（代码 256）使脚本停止，而 `E_USER_WARNING`（代码 512）允许脚本继续。
- en: In this exercise, we managed to forward all the errors caught with the error
    handler to the exception handler by converting each of them to an exception. This
    way, we can implement the code that handles both errors and exceptions in a single
    place in the script – in the exception handler. At the same time, we have used
    the `trigger_error()` function to generate some errors and have them printed by
    the exception handler.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过将每个错误转换为异常，成功地将错误处理器捕获的所有错误转发到异常处理器。这样，我们可以在脚本的单个位置实现处理错误和异常的代码——在异常处理器中。同时，我们使用了
    `trigger_error()` 函数来生成一些错误，并由异常处理器打印。
- en: Yet, we are mixing application/technical error handling with business logic
    error handling. We want more control in terms of the flow of operations, so as
    to be able to handle issues on the spot and act accordingly. The exceptions in
    PHP allow us to do precisely that – to run a block of code for which some exceptions
    are expected, and which will be handled on the spot when they occur, controlling
    the flow of the operations. Looking at the previous exercise, we see that we can
    improve it by "catching" the errors before they reach the error handler, so we
    can print some less verbose error messages, for example.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将应用程序/技术错误处理与业务逻辑错误处理混合在一起。我们希望在操作流程方面有更多的控制，以便能够现场处理问题并相应地采取行动。PHP 中的异常允许我们做到这一点——运行一个预期会抛出某些异常的代码块，并在它们发生时现场处理，控制操作流程。查看上一个练习，我们可以通过“捕获”在它们到达错误处理器之前发生的错误来改进它，例如，我们可以打印一些更简洁的错误消息。
- en: To achieve this, we will use the exceptions approach. Therefore, we will use
    `try`-`catch` blocks, which allow us to control the flow of operations, instead
    of the `trigger_error()` function, which sends the error directly to the error
    handler.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用异常方法。因此，我们将使用`try`-`catch`块，这允许我们控制操作流程，而不是使用`trigger_error()`函数，该函数将错误直接发送到错误处理器。
- en: 'Exercise 8.9: Simple Exception Handling'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.9：简单的异常处理
- en: 'In the following exercise, we will implement a multipurpose script that aims
    to execute arbitrary PHP functions. In this case, we will not have so much control
    over input validation, since arbitrarily picked functions require different input
    parameter types, in a specific order, and a variable parameter count. In this
    case, we will use a method that validates and handles the input, and, in the event
    of validation failures, it will throw exceptions that are caught by the current
    function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将实现一个多用途脚本，旨在执行任意PHP函数。在这种情况下，我们将无法对输入验证有太多控制，因为任意选择的函数需要不同类型的输入参数，按照特定顺序，以及可变数量的参数。在这种情况下，我们将使用一种验证和处理输入的方法，并在验证失败的情况下抛出异常，这些异常将被当前函数捕获：
- en: 'Create a file called `run.php` and include the error handler file. Then, we
    define a custom exception, called `Disposable`, so we can catch precisely the
    exception that we anticipate might be thrown:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`run.php`的文件，并包含错误处理器文件。然后，我们定义一个名为`Disposable`的自定义异常，这样我们就可以精确地捕获我们预期可能会抛出的异常：
- en: '[PRE57]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we declare the `handle()` function, which will be in charge of validation
    and running the script given the function name and arguments. A `Disposable` exception
    will be thrown when no function/class name argument is provided:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明`handle()`函数，该函数将负责验证和运行给定函数名和参数的脚本。如果没有提供函数/类名参数，将抛出`Disposable`异常：
- en: '[PRE58]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Otherwise, the first argument is stored in the `$calleeName` variable:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，第一个参数将被存储在`$calleeName`变量中：
- en: '[PRE59]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `callee` arguments are prepared as a slice from the original input, since,
    in the first position (index 0) in the `$input` variable, where there is the script
    name and, at the second position (index `1`), where there is the `callee` name,
    we need a slice that starts index `2` from `$input`; for this purpose, we are
    using the `array_slice()` built-in function.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`callee`参数被准备为一个从原始输入的切片，因为，在`$input`变量的第一个位置（索引0）是脚本名称，在第二个位置（索引`1`）是`callee`名称，我们需要从`$input`开始的索引`2`的切片；为此，我们使用`array_slice()`内置函数。'
- en: 'If the callee is an existing function, then use the `call_user_func_array()`
    function to invoke the `$calleeName` function, providing the argument list of
    `$calleeArguments`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果被调用者是一个现有的函数，那么使用`call_user_func_array()`函数来调用`$calleeName`函数，提供`$calleeArguments`的参数列表：
- en: '[PRE60]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Otherwise, if `$calleeName` is an existing class name, then create an instance
    of the `$calleeName` class, providing the list of arguments for the `constructor`
    method:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果`$calleeName`是一个现有的类名，那么创建一个`$calleeName`类的实例，为构造函数方法提供参数列表：
- en: '[PRE61]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, if the callee is not a function or a class name, then throw a `Disposable`
    exception:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果被调用者既不是函数也不是类名，那么抛出一个`Disposable`异常：
- en: '[PRE62]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the last part of the script, we use the `try`-`catch` block. In the `try`
    part, we call the `handle()` function providing the script arguments, and store
    the output in the `$output` variable:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的最后部分，我们使用`try`-`catch`块。在`try`部分，我们调用`handle()`函数，提供脚本参数，并将输出存储在`$output`变量中：
- en: '[PRE63]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We display the result in the following manner: if `$output` evaluates to `TRUE`
    (a non-empty value such as zero, an empty string, or `NULL`), then use the `print_r()`
    function to display data in a friendly format; otherwise, use `var_export()` to
    give us a hint regarding the data type. Note that output printing will not happen
    if the `handle()` function throws an exception.'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们以下述方式显示结果：如果`$output`评估为`TRUE`（非空值，如零、空字符串或`NULL`），则使用`print_r()`函数以友好格式显示数据；否则，使用`var_export()`来提供有关数据类型的提示。请注意，如果`handle()`函数抛出异常，则不会发生输出打印。
- en: 'The catch part will only catch `Disposable` exceptions, which are the anticipated
    error messages that will be printed on the screen. `exit(1)` is used to signal
    unsuccessful script execution:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获部分只会捕获`Disposable`异常，这是我们预期将在屏幕上打印的错误消息。使用`exit(1)`来表示脚本执行不成功：
- en: '[PRE64]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the script with `php run.php` and then `php run.php unknownFnName`; expect
    the following output:![Figure 8.27: Output of the commands'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`php run.php`运行脚本，然后使用`php run.php unknownFnName`；预期以下输出：![图8.27：命令输出
- en: '](img/C14196_08_27.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_27.jpg](img/C14196_08_27.jpg)'
- en: 'Figure 8.27: Output of the commands'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.27：命令输出'
- en: We got the expected output – the `handle()` function threw `Disposable` exceptions
    in both cases and, therefore, the function output was not printed.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到了预期的输出——`handle()` 函数在两种情况下都抛出了 `Disposable` 异常，因此函数输出没有被打印。
- en: 'Run the script using the following command:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE65]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output will be the following:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.28: Printing a substring'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.28：打印子字符串'
- en: '](img/C14196_08_28.jpg)'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_28.jpg](img/C14196_08_28.jpg)'
- en: 'Figure 8.28: Printing a substring'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.28：打印子字符串'
- en: In this case, `substr` is a valid function name and is therefore called, with
    three arguments being passed. `substr` is performing extraction from a string
    value (first parameter), starting a specific position (the second parameter –
    `0` in our case), and returns the desired length (the third parameter – `3` in
    our case). Since no exception was thrown, the output was printed on the screen.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个情况下，`substr` 是一个有效的函数名，因此被调用，并传递了三个参数。`substr` 正在从一个字符串值（第一个参数）中提取，从特定的位置开始（第二个参数——在我们的例子中是
    `0`），并返回所需的长度（第三个参数——在我们的例子中是 `3`）。由于没有抛出异常，输出被打印在屏幕上。
- en: 'Run the script using the following command:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE66]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be the following:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.29: No string printed to the console'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.29：控制台未打印字符串'
- en: '](img/C14196_08_29.jpg)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.29：打印警告信息'
- en: 'Figure 8.29: No string printed to the console'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.29：控制台未打印字符串'
- en: Since we got an empty string, in this case, the output is printed with `var_export()`.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们得到了一个空字符串，在这种情况下，输出使用 `var_export()` 打印。
- en: 'Run the script using the following command:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE67]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output will be as follows:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.30: Printing the warning message'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.30：打印警告信息'
- en: '](img/C14196_08_30.jpg)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_30.jpg](img/C14196_08_30.jpg)'
- en: 'Figure 8.30: Printing the warning message'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.30：打印警告信息'
- en: In this case, an `E_WARNING` message was reported, since the `substr()` function
    requires at least two parameters. Since this was not a fatal error, execution
    of the script continued, and `NULL` was returned. The output was again printed
    with the same `var_export()` function.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，报告了一个 `E_WARNING` 消息，因为 `substr()` 函数至少需要两个参数。由于这不是一个致命错误，脚本的执行继续，并返回
    `NULL`。输出再次使用相同的 `var_export()` 函数打印。
- en: 'Run the script using the following command:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE68]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output will be as follows:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.31: Printing the time details'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.31：打印时间详情'
- en: '](img/C14196_08_31.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_31.jpg](img/C14196_08_31.jpg)'
- en: 'Figure 8.31: Printing the time details'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.31：打印时间详情'
- en: 'Run the script using the following command:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE69]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output will be as follows:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.32: Fatal error'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.32：致命错误'
- en: '](img/C14196_08_32.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_32.jpg](img/C14196_08_32.jpg)'
- en: 'Figure 8.32: Fatal error'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.32：致命错误'
- en: As you can see, we are now dealing with a fatal `TypeError` exception. This
    exception was not caught and was handled by the exception handler; therefore,
    the script was halted.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在正在处理一个致命的 `TypeError` 异常。这个异常没有被捕获，并由异常处理器处理；因此，脚本被终止。
- en: Since this is a generic multi-purpose script, it is very difficult to handle
    all kinds of errors, validating specific inputs for each `callee`, be it a function
    name or a class name – in our case, you would write input validation rules for
    each function or class that is expected to be called. One thing to learn here
    is that being as precise as possible is a good approach to programming, since
    this gives you, the developer, control over your application.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个通用的多用途脚本，处理所有类型的错误非常困难，为每个 `callee` 验证特定的输入，无论是函数名还是类名——在我们的例子中，你将为预期被调用的每个函数或类编写输入验证规则。在这里要学习的一点是，尽可能精确是一种好的编程方法，因为它给了你，开发者，对应用程序的控制。
- en: 'Exercise 8.10: Better Usage of Exceptions'
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.10：异常的更好使用
- en: 'In this exercise, we''ll try a better approach to `DateTime` instantiation,
    compared with the previous example, for the purpose of showing how being precise
    gives you better control over your script. This approach is supposed to parse
    the input data and prepare the `DateTime` class arguments while respecting the
    accepted data types for each:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试一个比上一个例子更好的 `DateTime` 实例化方法，目的是展示如何通过精确控制来提高脚本的控制能力。这种方法应该解析输入数据并准备
    `DateTime` 类的参数，同时尊重每个接受的输入数据类型：
- en: 'Create the `date.php` file, require the error handlers, and define the custom
    exception called `Disposable`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `date.php` 文件，包含错误处理程序，并定义名为 `Disposable` 的自定义异常：
- en: '[PRE70]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we define the `handle()` function, which will handle the request processing.
    First, it will check for the class name argument in `$input[1]`, with a `Disposable`
    exception being thrown if no such value is found:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `handle()` 函数，该函数将处理请求。首先，它将检查 `$input[1]` 中的类名参数，如果没有找到这样的值，将抛出 `Disposable`
    异常：
- en: '[PRE71]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Otherwise, the value is validated, with the requirement that only one of `DateTime`
    or `DateTimeImmutable` is allowed; a `Disposable` exception is thrown if another
    name is passed:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，值将被验证，要求只允许 `DateTime` 或 `DateTimeImmutable` 中的一个；如果传递了另一个名称，将抛出 `Disposable`
    异常：
- en: '[PRE72]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The desired time is stored in the `$time` variable, with the default value
    of `now` if no argument was set. The time zone is stored in the `$timezone` variable,
    with the default of `UTC` if no time zone argument was set:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的时间存储在 `$time` 变量中，如果没有设置参数，默认值为 `now`。时区存储在 `$timezone` 变量中，如果没有设置时区参数，默认为
    `UTC`：
- en: '[PRE73]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, the `try`-`catch` blocks are used when trying to instantiate `DateTimeZone`
    and the `$calleeName` objects. All `Exception` errors are caught, and a friendly
    message is thrown with the `Disposable` exception class instead:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当尝试实例化 `DateTimeZone` 和 `$calleeName` 对象时使用 `try`-`catch` 块。所有 `Exception`
    错误都会被捕获，并使用 `Disposable` 异常类抛出一个友好的消息：
- en: '[PRE74]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, if everything goes well, the `$dateTime` instance is returned:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，则返回 `$dateTime` 实例：
- en: '[PRE75]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The final part of the script is a try-catch block, as in the previous exercise,
    where `handle()` is run with the script input arguments, the output of which is
    stored in the `$output` variable, which is then printed onscreen using the `print_r()`
    function:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的最后一部分是一个 try-catch 块，就像之前的练习一样，其中 `handle()` 使用脚本输入参数运行，其输出存储在 `$output`
    变量中，然后使用 `print_r()` 函数在屏幕上打印：
- en: '[PRE76]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If the `handle()` function throws a `Disposable` exception, this is caught
    and the error message is printed onscreen before the process is halted with exit
    code 1\. Any other exception will be handled by the exception handler registered
    in `all-errors-handler.php`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `handle()` 函数抛出 `Disposable` 异常，这个异常会被捕获，并在进程以退出代码 1 停止之前，在屏幕上打印错误信息。任何其他异常将由在
    `all-errors-handler.php` 中注册的异常处理器处理：
- en: '[PRE77]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Run the script with `php date.php` and then with `php date.php Date`; the expected
    output is as follows:![Figure 8.33: Printing the error messages for Disposable
    exceptions'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php date.php` 运行脚本，然后使用 `php date.php Date` 运行脚本；预期的输出如下：![图 8.33：打印 `Disposable`
    异常的错误信息
- en: '](img/C14196_08_33.jpg)'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_33.jpg](img/C14196_08_33.jpg)'
- en: 'Figure 8.33: Printing the error messages for Disposable exceptions'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.33：打印 `Disposable` 异常的错误信息
- en: As expected, the `Disposable` exceptions were caught, and the error messages
    were displayed onscreen. Since no exceptions were thrown, no output result is
    printed.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，`Disposable` 异常被捕获，错误信息在屏幕上显示。由于没有抛出异常，没有打印输出结果。
- en: 'Run the script using the following command:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE78]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.34: Printing the time details'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.34：打印时间详情'
- en: '](img/C14196_08_34.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_34.jpg](img/C14196_08_34.jpg)'
- en: 'Figure 8.34: Printing the time details'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.34：打印时间详情
- en: Now, the script printed the `DateTimeImmutable` object, which has today's date
    and the time set to midnight, while the default UTC is used for the time zone.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，脚本打印了 `DateTimeImmutable` 对象，其中包含今天的日期，时间设置为午夜，而默认使用 UTC 作为时区。
- en: 'Run the script with `php date.php DateTimeImmutable summer` and then with `php
    date.php DateTimeImmutable yesterday Paris`; see the output, which should look
    like this:![Figure 8.35: Exceptions caught inside the functions'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php date.php DateTimeImmutable summer` 运行脚本，然后使用 `php date.php DateTimeImmutable
    yesterday Paris` 运行脚本；查看输出，应该看起来像这样：![图 8.35：函数内部捕获的异常
- en: '](img/C14196_08_35.jpg)'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_35.jpg](img/C14196_08_35.jpg)'
- en: 'Figure 8.35: Exceptions caught inside the functions'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.35：函数内部捕获的异常
- en: As you can see, these are the `Exception` class exceptions caught inside the
    `handle()` function, and then thrown as `Disposable` exceptions (to be caught
    in the upper level) with custom messages.
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这些是在 `handle()` 函数内部捕获的 `Exception` 类异常，然后作为 `Disposable` 异常（在上级捕获）抛出，并带有自定义消息。
- en: 'Finally, run the program using the following command:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令运行程序：
- en: '[PRE79]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You should get something like this:'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的结果：
- en: '![Figure 8.36: Printing Europe/Paris date time details'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.36：打印 Europe/Paris 日期时间详情'
- en: '](img/C14196_08_36.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_08_36.jpg](img/C14196_08_36.jpg)'
- en: 'Figure 8.36: Printing Europe/Paris date time details'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36：打印 Europe/Paris 日期时间详情
- en: This would be yesterday's date, midnight in the Europe/Paris time zone. In this
    case, the script has executed without exceptions; the second argument for `DateTimeImmutable`
    was a `DateTimeZone` object with the `Europe/Paris` time zone setting, and therefore
    the result was printed as expected.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是昨天的日期，欧洲/巴黎时区的午夜。在这种情况下，脚本已执行而没有异常；`DateTimeImmutable`的第二个参数是一个具有`Europe/Paris`时区设置的`DateTimeZone`对象，因此结果按预期打印。
- en: 'Activity 8.1: Handling System and User-Level Errors'
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.1：处理系统和用户级错误
- en: 'Let''s say you have been asked to develop a script that would calculate the
    factorial number of the given input, with the following specifications:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求开发一个脚本，该脚本将计算给定输入的阶乘数，具有以下规范：
- en: At least one input argument is required.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要一个输入参数。
- en: The input arguments should be validated as positive integers (higher than zero).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数应验证为正整数（大于零）。
- en: For each input provided, the script should calculate the factorial number; the
    result is printed line by line for each input argument.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个提供的输入，脚本应计算阶乘数；结果按行打印每个输入参数。
- en: You should validate the inputs according to the specifications and handle any
    error (thrown exceptions). No exception should halt the execution of the script,
    the difference being that the expected exceptions are printed to the user output,
    while for unexpected exceptions, a generic error message is printed, and the exception
    is logged to a log file.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 应根据规范验证输入，并处理任何错误（抛出的异常）。不应有任何异常停止脚本的执行，区别在于预期的异常打印到用户输出，而对于意外的异常，打印一个通用的错误消息，并将异常记录到日志文件中。
- en: 'Perform the following steps:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a file called `factorial.php`, which will run the script.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`factorial.php`的文件，该文件将运行脚本。
- en: Create the exception handler, which will log the formatted log message to a
    file; the message format is the same as in the exception handler of the `all-errors-handler.php`
    file.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建异常处理器，它将格式化的日志消息记录到文件中；消息格式与`all-errors-handler.php`文件的异常处理器中相同。
- en: Create the error handler to deal with the system errors reported; this will
    forward the errors to the exception handler (translating the errors to exceptions).
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建错误处理器来处理报告的系统错误；这将把错误转发到异常处理器（将错误转换为异常）。
- en: Register both the exception and the error handlers.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册异常和错误处理器。
- en: Create the custom exceptions, one for each validation rule.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义异常，每个验证规则一个。
- en: Create the function that validates and calculates a single number input (for
    example, `calculateFactorial()`).
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于验证和计算单个数字输入（例如，`calculateFactorial()`）。
- en: Create a function that will print the error message in a specific format. It
    will prepend `(!)` to each message and will include a new line feed.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于以特定格式打印错误消息。它将为每条消息添加`(!)`前缀，并包括一个换行符。
- en: If no input arguments are provided, display a message that highlights the requirement
    of at least one input number.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有提供输入参数，显示一条消息，强调至少需要一个输入数字的要求。
- en: 'Iterate through the input arguments and invoke the `calculateFactorial()` function
    providing the `input` argument. The result will be printed using the format: `3!
    = 6` (where `3` is the input number, and `6` is the result of `calculateFactorial()`).'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历输入参数，并调用`calculateFactorial()`函数，提供`input`参数。结果将按照以下格式打印：`3! = 6`（其中`3`是输入数字，`6`是`calculateFactorial()`的结果）。
- en: Catch any (expected) custom exception that might be thrown by the `calculateFactorial()`
    function and print the exception message.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获`calculateFactorial()`函数可能抛出的任何（预期的）自定义异常，并打印异常消息。
- en: Catch any unexpected exception, other than the custom exceptions defined previously,
    and invoke the exception handler to have them logged in the log file. Also, display
    a generic error message to the user output (for example, an unexpected error occurred
    for input number N, where N is the input number provided in the `calculateFactorial()`
    function).
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获所有意外的异常，除了之前定义的自定义异常之外，并调用异常处理器将它们记录到日志文件中。同时，向用户输出显示一个通用的错误消息（例如，对于输入数字N，发生了意外的错误，其中N是在`calculateFactorial()`函数中提供的输入数字）。
- en: 'The output should be similar to the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 8.37: Printing factorials of integers'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.37：打印整数的阶乘'
- en: '](img/C14196_08_37.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_08_37.jpg)'
- en: 'Figure 8.37: Printing factorials of integers'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37：打印整数的阶乘
- en: Note
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 552.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第552页找到。
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to deal with PHP errors and how to work with
    exceptions. Now, you also understand the difference between traditional errors
    and exceptions and their use cases. You learned how to set error and exception
    handlers. Now, you understand the different error levels in PHP, and why some
    will curtail the execution of the script, while most of them will allow the script
    to execute further. Also, to avoid code duplication, you learned how to translate
    traditional errors to exceptions and forward them to the exception handler.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何处理PHP错误以及如何与异常一起工作。现在，你也理解了传统错误和异常及其用例之间的区别。你学习了如何设置错误和异常处理器。现在，你理解了PHP中的不同错误级别，以及为什么某些错误会截断脚本的执行，而大多数错误则允许脚本继续执行。此外，为了避免代码重复，你学习了如何将传统错误转换为异常并将它们转发到异常处理器。
- en: Finally, my advice to you is to consider setting up a logging server (some free
    solutions are available for download and use), where you can send all the logs,
    so that, when you access the logging platform, you can filter the entries (for
    example, by severity/log level or by a search term), create data visualizations
    with various aggregations (for example, counts of warnings in the last 12 hours
    at 30-minute intervals), and more. This will help you to identify certain error
    level messages much more quickly than browsing through a log file.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我的建议是考虑设置一个日志服务器（一些免费解决方案可供下载和使用），你可以将所有日志发送到那里，这样，当你访问日志平台时，你可以过滤条目（例如，按严重性/日志级别或按搜索词），使用各种聚合创建数据可视化（例如，在过去12小时内每30分钟间隔的警告计数），等等。这将帮助你比浏览日志文件更快地识别某些错误级别的消息。
- en: The logging server is particularly useful when the application is deployed on
    at least two instances, due to the centralization of logs, which allows you not
    only to spot a problem very quickly, but you will also be able to see the instance
    that caused it and potentially more context information. In addition, a log management
    solution can be used for multiple applications.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序至少部署在两个实例上时，日志服务器尤其有用，因为日志的集中化不仅允许你非常快速地发现问题，你还将能够看到导致问题的实例以及可能更多的上下文信息。此外，日志管理解决方案可以用于多个应用程序。
- en: In fact, for the latter, you can check out titles including *Learning ELK Stack*;
    video courses including the ElasticSearch, LogStash, and Kibana ELK series; and
    many others on the *Packt Publishing* platform.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于后者，你可以查看包括*学习ELK Stack*在内的标题；包括ElasticSearch、LogStash和Kibana ELK系列的视频课程；以及*Packt
    Publishing*平台上的许多其他内容。
- en: While logging into a filesystem is perfectly acceptable, especially while developing,
    at some point, while developing your application, the production setup will require
    a centralized logging solution, be it HTTP access/error logs, application logs,
    or others (especially in a distributed architecture/microservices). You want to
    be productive and code or fix bugs, rather than lose yourself between files and
    lines of logs stored in a filesystem.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录文件系统是完全可接受的，尤其是在开发过程中，但在某个时候，当你在开发应用程序时，生产环境将需要一个集中的日志解决方案，无论是HTTP访问/错误日志、应用程序日志还是其他日志（尤其是在分布式架构/微服务中）。你希望提高生产力，编写或修复代码，而不是迷失在存储在文件系统中的文件和日志行之间。
- en: In the next chapter, we will define the composer and manage libraries using
    Composer.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将定义作曲家和使用Composer管理库。
