- en: Chapter 5. Testing – It's Easier Than You Think
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 测试 – 比您想象的要简单
- en: Testing is an often-neglected part in PHP development. Compared to languages
    such as Java and Ruby, where testing is strongly ingrained into the workflow of
    developers, PHP has been lagging behind. This is mainly because simple PHP applications
    tend to be tightly coupled and are, therefore, difficult to test. However, thanks
    to standardization and modularization efforts and frameworks that encourage the
    separation of concerns, PHP testing has become more accessible and the mentality
    towards it is slowly changing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是PHP开发中经常被忽视的部分。与Java和Ruby等语言相比，在这些语言中测试被深深植根于开发者的工作流程中，PHP在这方面落后了。这主要是因为简单的PHP应用程序往往耦合紧密，因此难以测试。然而，得益于标准化和模块化努力以及鼓励关注点分离的框架，PHP测试变得更加容易接近，并且对其的态度正在慢慢改变。
- en: Laravel 5 is a framework that was built from the ground up to facilitate testing.
    It comes with all the necessary files to get started, along with different helpers
    to test your application, thus helping beginners to overcome some of the biggest
    obstacles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 5是一个从头开始构建以促进测试的框架。它包含所有必要的文件以开始，以及不同的辅助工具来测试您的应用程序，从而帮助初学者克服一些最大的障碍。
- en: 'In this chapter, we will demonstrate how Laravel makes it very simple to get
    started with testing, without forcing you to go for a test-first approach, or
    making you aim for complete test coverage. In this gentle introduction to testing,
    we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示Laravel如何使您轻松开始测试，而无需强迫您采取测试优先的方法，或使您追求完整的测试覆盖率。在这个轻松的测试介绍中，我们将探讨以下主题：
- en: The advantages of writing tests for your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序编写测试的优势
- en: How to prepare your tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何准备您的测试
- en: The software design patterns that Laravel fosters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel培养的软件设计模式
- en: How to use Mockery to test objects in isolation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Mockery单独测试对象
- en: The built-in features and helpers that facilitate testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便测试的内置功能和辅助工具
- en: The benefits of testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的好处
- en: If you have not written tests for your web applications before, the advantages
    of testing might not always be obvious to you. After all, preparing and writing
    tests involves significant time investment, and for short-lived prototypes or
    hackathon projects, they can even seem to be a complete waste of time. However,
    in almost all the other cases, when your project is likely to grow in complexity,
    or when you collaborate with other developers, tests have the potential to save
    you and other people a lot of time and headaches.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有为您的Web应用程序编写过测试，测试的优势可能并不总是对您显而易见。毕竟，准备和编写测试需要大量的时间投入，对于短期原型或黑客马拉松项目来说，它们甚至可能看起来是完全浪费时间。然而，在几乎所有其他情况下，当您的项目可能变得复杂，或者当您与其他开发者合作时，测试有可能为您和其他人节省大量时间和头疼。
- en: Tests also introduce some changes to your workflow. In the development stage,
    you will no longer have to switch back and forth between your code editor and
    your web browser. Instead, if you are using a text editor or an IDE that supports
    it, you could bind a test runner to a keyboard shortcut.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试也会对您的流程带来一些变化。在开发阶段，您将不再需要在代码编辑器和Web浏览器之间来回切换。相反，如果您使用的是支持测试运行器的文本编辑器或IDE，您可以将测试运行器绑定到一个键盘快捷键上。
- en: Once you have proven that a certain bit of functionality works, you will have
    a way of quickly ensuring that it continues to work as expected, if the source
    code is changed at a later date. In addition to this, it forces you to clearly
    and unambiguously define the expected behavior of your application and can therefore
    complement or replace a significant part of the documentation. This can be particularly
    helpful, not only for new developers who start collaborating on the project, but
    also for yourself, if you have not touched the project for a while.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您证明某个功能部分工作正常，您将有一种快速确保它在以后日期代码更改后仍然按预期工作的方式。此外，它迫使您明确且无歧义地定义应用程序的预期行为，因此可以补充或替代大量文档。这特别有助于新开发者开始参与项目合作，如果您有一段时间没有接触过项目，这也对您自己特别有帮助。
- en: The anatomy of a test
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的结构
- en: Your application tests will reside in `tests/`. In this directory, you will
    find a base test case inside `TestCase.php`, which is responsible for bootstrapping
    the application in the testing environment. This class extends Laravel's main
    `TestCase` class, which in turn extends the `PHPUnit_Framework_TestCase` class,
    along with many helpful testing methods that we will cover later in this chapter.
    All of your tests will extend this first `TestCase` class and define one or more
    methods that are meant to test one or more features of your application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序测试将位于`tests/`目录中。在这个目录中，你将找到一个`TestCase.php`中的基本测试用例，它负责在测试环境中启动应用程序。这个类扩展了Laravel的主要`TestCase`类，该类反过来又扩展了`PHPUnit_Framework_TestCase`类，以及我们将在本章后面讨论的许多有用的测试方法。你所有的测试都将扩展这个第一个`TestCase`类，并定义一个或多个旨在测试应用程序一个或多个功能的函数。
- en: 'In every test, we generally perform the following three distinct tasks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，我们通常执行以下三个不同的任务：
- en: We *arrange* or initialize some data.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们*安排*或初始化一些数据。
- en: We execute a function to *act* on this data.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行一个函数来对这份数据进行*操作*。
- en: We *assert* or verify that the output matches what we expected.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们*断言*或验证输出是否与预期相符。
- en: 'Given we had the following Helper class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下辅助类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An example test case, `HelperTest.php`, which illustrates the three preceding
    steps, will look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例测试用例，`HelperTest.php`，它展示了前面的三个步骤，看起来是这样的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the preceding code snippet is executed, PHPUnit will run each method within
    the test case and keep track of how many tests failed or passed. With PHPUnit
    installed on your system, you can run this test, using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，PHPUnit将运行测试用例中的每个方法，并跟踪测试失败或通过的数量。如果你的系统上安装了PHPUnit，你可以使用以下命令运行此测试：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will produce the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![The anatomy of a test](img/B04308_05_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![测试的解剖结构](img/B04308_05_01.jpg)'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Most code editors also provide ways to run this directly within the editor by
    pressing a shortcut key. Examples of such editors include **PhpStorm**. It is
    even possible to run them automatically before each commit or before you deploy
    your code to a remote server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码编辑器还提供了通过按快捷键直接在编辑器中运行测试的方法。此类编辑器的例子包括**PhpStorm**。甚至可以在每次提交之前或在你将代码部署到远程服务器之前自动运行它们。
- en: Unit testing with PHPUnit
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHPUnit进行单元测试
- en: A positive effect of testing is that it forces you to split your code into manageable
    dependencies, so that you can test them in isolation. The testing of these individual
    classes and methods is referred to as **unit testing**. Since it relies on the
    PHPUnit testing framework, which already provides a large number of tools to set
    up test suites, Laravel does not need to provide any additional helpers for this
    type of testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一个积极影响是它迫使你将代码拆分成可管理的依赖项，这样你就可以单独测试它们。对这些单个类和方法的测试被称为**单元测试**。由于它依赖于PHPUnit测试框架，该框架已经提供了大量设置测试套件的工具，因此Laravel不需要为此类型测试提供任何额外的辅助函数。
- en: A great way to learn about any framework, and at the same time learn about the
    different ways in which it can be tested, is to look at how its authors have written
    tests for it. Therefore, our next examples will be taken directly from Laravel's
    test suite, which is located at `vendor/laravel/framework/tests/`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 了解任何框架的绝佳方式，同时了解它如何被测试的不同方式，是查看其作者如何为其编写测试。因此，我们的下一个示例将直接来自Laravel的测试套件，该套件位于`vendor/laravel/framework/tests/`。
- en: Defining what you expect with assertions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用断言定义你期望的内容
- en: Assertions are the fundamental components of unit tests. Simply put, they are
    used to compare the *expected output* of a function with its *actual output*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是单元测试的基本组成部分。简单来说，它们用于比较函数的*预期输出*与其*实际输出*。
- en: To see how assertions work, we will examine the test for the `Str::is()` helper,
    which checks whether a given string matches a given pattern.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解断言是如何工作的，我们将检查`Str::is()`辅助函数的测试，该函数用于检查给定的字符串是否与给定的模式匹配。
- en: 'The following test can be found near the bottom of the `Support/SupportStrTest.php`
    file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试可以在`Support/SupportStrTest.php`文件的底部找到：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding test performs five assertions to test whether the method is indeed
    returning the expected value when called with different parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试执行了五个断言，以测试当使用不同的参数调用方法时，它是否确实返回了预期的值。
- en: PHPUnit provides many other assertion methods that can, for example, help you
    test for numerical values with `assertGreaterThan()`, equality with `assertEquals()`,
    types with `assertInstanceOf()`, or existence with `assertArrayHasKey()`. While
    there are many more possible assertions, these are the ones you will probably
    end up using most frequently. In total, PHPUnit provides around 40 different assertion
    methods, all of which are described in the official documentation at [http://phpunit.de/manual/](http://phpunit.de/manual/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 提供了许多其他断言方法，例如，你可以使用 `assertGreaterThan()` 测试数值，使用 `assertEquals()`
    测试相等性，使用 `assertInstanceOf()` 测试类型，或者使用 `assertArrayHasKey()` 测试存在性。虽然还有更多可能的断言，但这些都是你可能会最频繁使用的。总而言之，PHPUnit
    提供了大约 40 种不同的断言方法，所有这些方法都在官方文档中有详细描述，请参阅 [http://phpunit.de/manual/](http://phpunit.de/manual/)。
- en: Preparing the scene and cleaning up objects
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备场景和清理对象
- en: If you need to run a function before each test method to set up some test data
    or reduce code duplication, you can use the `setUp()` method. If, on the other
    hand, you need to run some code after each test to clear any objects that were
    instantiated in your tests, you can define it inside the `tearDown()` method.
    A good example would be to remove any records from a database inserted in the
    `setUp()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在每个测试方法之前运行一个函数来设置一些测试数据或减少代码重复，你可以使用 `setUp()` 方法。另一方面，如果你需要在每个测试之后运行一些代码来清除测试中创建的任何对象，你可以在
    `tearDown()` 方法中定义它。一个很好的例子是在 `setUp()` 方法中插入到数据库中的任何记录。
- en: Expecting exceptions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期异常
- en: 'It is also possible to test for exceptions by decorating your function with
    an `@expectedException` DocBlock, like Laravel does inside `Database/ DatabaseEloquentModelTest.php`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在函数上装饰 `@expectedException` DocBlock 来测试异常，就像 Laravel 在 `Database/ DatabaseEloquentModelTest.php`
    中所做的那样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this test function, there is no assertion, but the code is expected to throw
    an exception when it is executed. Also note the use of an `EloquentModelStub`
    object. A stub creates an instance of an object that provides or simulates the
    methods that our class needs—in this case, an Eloquent model on which we can call
    the `guard()` and `fill()` methods. If you look at the definition of this stub
    further down in the test, you will see that it does not actually interact with
    a database, but it provides canned responses instead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试函数中，没有断言，但预期当它执行时将抛出异常。同时请注意 `EloquentModelStub` 对象的使用。存根创建了一个对象的实例，该对象提供了或模拟了我们类需要的某些方法——在这种情况下，是一个我们可以调用
    `guard()` 和 `fill()` 方法的 Eloquent 模型。如果你查看测试中更下面的存根定义，你会看到它实际上并没有与数据库交互，而是提供了预定义的响应。
- en: Testing interdependent classes in isolation
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离测试相互依赖的类
- en: 'In addition to stubs, which we looked at in the previous section, there is
    another way in which you can test one or more interdependent classes in isolation.
    It is by using **mocks**. In Laravel, mocks are created using the Mockery library,
    and they help define the methods that should be called during the test, the arguments
    they should receive, and their return values as well. Laravel heavily relies on
    mocks in its own tests. An example can be found in the `AuthEloquentUserProviderTest`
    class, where the `Hasher` class is mocked:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中查看的存根之外，还有另一种方法可以用来隔离测试一个或多个相互依赖的类。这是通过使用 **模拟** 来实现的。在 Laravel 中，使用
    Mockery 库创建模拟，它们有助于定义测试期间应该调用哪些方法，它们应该接收哪些参数，以及它们的返回值。Laravel 在其自己的测试中大量依赖模拟。一个例子可以在
    `AuthEloquentUserProviderTest` 类中找到，其中 `Hasher` 类被模拟：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As opposed to stubs, mocks allow us to define which methods need to be called,
    how many times they should be called, which parameters they should receive, and
    which parameters they should return. If any of these preconditions are not met,
    the test will fail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与存根不同，模拟允许我们定义需要调用哪些方法，它们应该被调用多少次，它们应该接收哪些参数，以及它们应该返回哪些参数。如果任何这些前提条件没有得到满足，测试将失败。
- en: To ensure that we do not have an instance of a mocked object that persists and
    interferes with future tests, Mockery provides a `close()` method that needs to
    be executed after each test. Thanks to this mock, the class can be tested in complete
    isolation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有持久化的模拟对象实例，它可能会干扰未来的测试，Mockery 提供了一个 `close()` 方法，需要在每次测试后执行。多亏了这个模拟，我们可以在完全隔离的情况下测试这个类。
- en: End-to-end testing
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: When we are confident that all of the interdependent classes work as expected,
    we can then conduct another type of testing. It consists of simulating the kind
    of interaction that a user would have through a web browser. This user would,
    for example, visit a specific URL, perform certain actions, and expect to see
    some kind of feedback from the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确信所有相互依赖的类都按预期工作后，我们就可以进行另一种类型的测试。这包括模拟用户通过网页浏览器进行的交互。例如，这个用户会访问特定的URL，执行某些操作，并期望从应用程序看到某种形式的反馈。
- en: This is perhaps the most straightforward type of testing, as it mimics the kind
    of testing that you manually perform each time you refresh your browser after
    a code change. When you get started, it is absolutely fine to only perform this
    type of testing. However, you must bear in mind that if any errors occur, you
    will still have to drill deep down into your code to find the exact component
    that caused the error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最直接的测试类型，因为它模仿了每次代码更改后刷新浏览器时手动执行的测试类型。当你开始时，只执行这种类型的测试是完全正常的。然而，你必须记住，如果发生任何错误，你仍然需要深入到代码中找到导致错误的精确组件。
- en: Testing – batteries included
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 - 包含电池
- en: When you start a new project with Laravel, you are provided with both a configuration
    file with sensible defaults for PHPUnit at the root of the project inside `phpunit.xml`
    as well as a directory, `tests/`, where you are expected to save your tests. This
    directory even contains an example test that you can use as a starting point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Laravel开始一个新项目时，你将在项目的根目录中提供一个配置文件`phpunit.xml`，其中包含PHPUnit的合理默认设置，以及一个名为`tests/`的目录，你可以在其中保存你的测试。此目录甚至包含一个示例测试，你可以将其用作起点。
- en: 'With these settings in place, from the root of our project, all we need to
    do is SSH into our Homestead virtual machine and run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些设置到位后，从我们项目的根目录，我们只需要SSH到我们的Homestead虚拟机并运行以下命令：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will read the XML configuration file and run our tests. If, at
    this stage, you get an error message telling you that PHPUnit cannot be found,
    you either need to add the `phpunit` command to your `PATH` variable or install
    it with Composer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将读取XML配置文件并运行我们的测试。如果在这一阶段，你收到一个错误消息告诉你PHPUnit找不到，你可能需要将`phpunit`命令添加到你的`PATH`变量中，或者使用Composer安装它。
- en: 'Laravel applications come with PHPUnit already declared in the `autoload-dev`
    block in your `composer.json` file. After running `composer update`, you will
    be able to call PHPUnit by using the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel应用程序在`composer.json`文件的`autoload-dev`块中已经声明了PHPUnit。在运行`composer update`之后，你将能够使用以下命令调用PHPUnit：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Framework assertions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架断言
- en: Now that we know about the two major types of tests and have PHPUnit installed,
    we are going to write a few tests for the application that we developed in [Chapter
    3](ch03.html "Chapter 3. Your First Application"), *Your First Application*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了两种主要的测试类型并且已经安装了PHPUnit，我们将为我们在[第3章](ch03.html "第3章。你的第一个应用程序")中开发的程序编写一些测试，*你的第一个应用程序*。
- en: 'This first test will verify whether visitors are redirected to the correct
    page when they first visit our site:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一次测试将验证访问者在首次访问我们的网站时是否被重定向到正确的页面：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we made use of the `call()` method that simulated a request to our application,
    which executes the request through Laravel''s HTTP kernel. Then, we used one of
    the assertion methods provided by Laravel to make sure that the response is a
    redirection to the new location. If you now run the `phpunit` command, you should
    see the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`call()`方法来模拟对应用程序的请求，该请求通过Laravel的HTTP内核执行请求。然后，我们使用了Laravel提供的断言方法之一来确保响应是重定向到新位置。如果你现在运行`phpunit`命令，你应该看到以下输出：
- en: '`OK (1 test, 2 assertions)`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`OK (1 test, 2 assertions)`'
- en: 'Next, we can try to write a test to make sure that the creation form is not
    accessible to the users that are not logged in; this is shown in the following
    code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以尝试编写一个测试来确保创建表单对未登录的用户不可用；这在上面的代码片段中显示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Impersonating users
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟用户
- en: 'Sometimes, you may wish to run a test as if you were a registered user of the
    application. This is possible by using the `be()` method and passing a `User`
    instance to it or whichever Eloquent model you use, along with Laravel''s authentication
    class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望以注册用户身份运行测试。这可以通过使用`be()`方法和传递一个`User`实例或你使用的任何Eloquent模型到其中，以及Laravel的认证类来实现：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Testing with a database
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带数据库的测试
- en: While some developers would advise against writing tests that hit the database,
    it can often be a simple and effective way of making sure that all the components
    work together as expected. However, it should only be done once each individual
    unit has been tested. Let's also not forget that Laravel has support for migrations
    and seeding; in other words, it has all of the tools that are required to recreate
    an identical data structure from scratch, before each test.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些开发者会建议不要编写针对数据库的测试，但通常这是一种简单而有效的方法，以确保所有组件按预期协同工作。然而，这应该在每个单独的单元测试之后才进行。我们也不应忘记Laravel支持迁移和数据填充；换句话说，它拥有从头开始重新创建相同数据结构所需的所有工具，在每次测试之前。
- en: 'To write tests that depend on a database, we need to override the `setUp()`
    method in our tests to migrate and seed the database each time a test is run.
    It is also important to run the parent `setUp()` method, otherwise, the test case
    will not be able to start properly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写依赖于数据库的测试，我们需要在我们的测试中覆盖`setUp()`方法，每次运行测试时都要迁移和填充数据库。运行父`setUp()`方法也很重要，否则测试用例将无法正确启动：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we need to configure a test database connection in `config/database.php`;
    if the application does not contain any database-specific queries, we can use
    SQLite''s in-memory feature by setting `:memory:` instead of a path to the database
    file. The following configuration also has the potential to speed up our tests:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`config/database.php`中配置测试数据库连接；如果应用程序不包含任何特定于数据库的查询，我们可以通过设置`:memory:`而不是数据库文件的路径来使用SQLite的内存功能。以下配置也有可能加快我们的测试速度：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And lastly, since we are going to test the editing and deletion features, we
    are going to need at least one row in the `cats` table of our database, so we
    prepare a seeder that will insert a cat with a forced `id` of value `1`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们将要测试编辑和删除功能，我们至少需要在数据库的`cats`表中有一行，因此我们准备了一个填充器，将插入一个强制`id`值为`1`的猫：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once this is done, we can test the deletion feature as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们就可以按照以下方式测试删除功能：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that this time, we did not need to enable the filters since the permissions
    are checked by a method in the `User` model. Since the database is wiped and re-seeded
    after each test, we do not need to worry about the fact that the previous test
    deleted that particular cat. We can also write a test to ensure that a user who
    is not an administrator cannot edit someone else''s cat profile:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们不需要启用过滤器，因为权限是由`User`模型中的方法检查的。由于数据库在每次测试后都会被清除并重新填充，所以我们不需要担心之前的测试删除了那个特定的猫。我们还可以编写一个测试来确保非管理员用户无法编辑其他人的猫资料：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inspecting the rendered views
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查渲染的视图
- en: 'Since Laravel ships with Symfony''s `DomCrawler` and `CssSelector` components,
    it is possible to inspect the contents of a rendered view. By issuing a request
    through the test client instance with `$this->client->request()`, you can filter
    its contents with CSS queries as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Laravel自带了Symfony的`DomCrawler`和`CssSelector`组件，因此可以检查渲染视图的内容。通过通过测试客户端实例发出请求`$this->client->request()`，可以使用CSS查询过滤其内容，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The complete documentation for the `DomCrawler` component can be found at [http://symfony.com/doc/current/components/dom_crawler.html](http://symfony.com/doc/current/components/dom_crawler.html).
    If you are already familiar with jQuery, its syntax will look familiar to you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DomCrawler`组件的完整文档可以在[http://symfony.com/doc/current/components/dom_crawler.html](http://symfony.com/doc/current/components/dom_crawler.html)找到。如果你已经熟悉jQuery，其语法将对你来说很熟悉。'
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While the main ideas behind testing are easy to grasp, it is often their implementation
    that can prove to be an obstacle, especially when working with a new framework.
    However, after reading this chapter, you should have a good overview of how you
    can test your Laravel applications. The techniques presented in this chapter will
    enable you to write more robust and future-proof applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试背后的主要思想很容易理解，但它们的实现往往可能成为障碍，尤其是在使用新框架时。然而，在阅读本章之后，你应该对如何测试你的Laravel应用程序有一个很好的概述。本章中介绍的技术将使你能够编写更健壮和面向未来的应用程序。
- en: In the next chapter, we will explore the possibilities offered by Artisan, Laravel's
    command-line utility.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Artisan提供的可能性，它是Laravel的命令行实用工具。
