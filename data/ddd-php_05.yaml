- en: Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'You''ve already seen what Entities and Value Objects are. As basic building
    blocks, they should contain most of the business logic of any application. However,
    there are some scenarios where Entities and Value Objects aren''t the best solutions.
    Let''s take a look at what Eric Evans has to say about this in his book, [Domain-Driven
    Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215):'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了实体和值对象是什么。作为基本构建块，它们应该包含任何应用程序的大部分业务逻辑。然而，在某些场景中，实体和值对象并不是最佳解决方案。让我们看看埃里克·埃文斯在他的书中对此有何看法，[领域驱动设计：软件核心的复杂性处理](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)：
- en: When a significant process or transformation in the domain is not a natural
    responsibility of an Entity or Value Object, add an operation to the model as
    standalone interface declared as a Service. Define the interface in terms of the
    language of the model and make sure the operation name is part of the Ubiquitous
    Language. Make the Service stateless.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当领域中的某个重要过程或转换不是实体或值对象的自然职责时，将操作添加到模型中，作为独立接口声明的服务。用模型的语言定义接口，并确保操作名称是通用语言的一部分。使服务无状态。
- en: 'So when there are operations that need to be represented, but Entities and
    Value Objects aren''t the best place, you should consider modeling these operations
    as Services. In Domain-Driven Design, there are typically three different types
    of Services you''ll encounter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当有需要表示的操作，但实体和值对象不是最佳选择时，您应该考虑将这些操作建模为服务。在领域驱动设计中，通常会遇到三种不同类型的服务：
- en: '**Application Services**: Operate on scalar types, transforming them into Domain
    types. A scalar type can be considered any type that''s unknown to the Domain
    Model. This includes primitive types and types that don''t belong to the Domain.
    We''ll provide an overview in this chapter, but for a deeper look at this topic,
    check out the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**: 在标量类型上操作，将它们转换为领域类型。标量类型可以被认为是领域模型中未知的任何类型。这包括原始类型和不属于领域的类型。我们将在本章中提供一个概述，但若要深入了解此主题，请参阅第11章[应用](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)，*应用*。'
- en: '**Domain Services**: Operate only on types belonging to the Domain. They contain
    meaningful concepts that can be found within the Ubiquitous Language. They hold
    operations that don''t fit well into Value Objects or Entities.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**: 仅在属于领域的类型上操作。它们包含可以在通用语言中找到的有意义的概念。它们包含不适合值对象或实体的操作。'
- en: '**Infrastructure Services**: Are operations that fulfill infrastructure concerns,
    such as sending emails and logging meaningful data. In terms of Hexagonal Architecture,
    they live outside the Domain boundary.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施服务**: 是满足基础设施关注点的操作，例如发送电子邮件和记录有意义的数据。在六边形架构中，它们位于领域边界之外。'
- en: Application Services
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用服务
- en: Application Services are the middleware between the outside world and the Domain
    logic. The purpose of such a mechanism is to transform commands from the outside
    world into meaningful Domain instructions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务是外部世界和领域逻辑之间的中间件。这种机制的目的是将来自外部世界的命令转换为有意义的领域指令。
- en: 'Let''s consider the *User signs up to our platform* use case. Starting with
    an outside-in approach: from the delivery mechanism, we need to compose the input
    request for our Domain operation. Using a framework like Symfony as the delivery
    mechanism, the code would look something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑*用户注册到我们的平台*用例。从外部到内部的方法开始：从交付机制，我们需要为我们的领域操作组合输入请求。使用像Symfony这样的框架作为交付机制，代码看起来可能像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we create a new instance of our Application Services, passing
    all dependencies needed — in this case, a `UserRepository`. `UserRepository` is
    an interface that can be implemented with any specific technology (Example: MySQL,
    Redis, Elasticsearch). Then, we build a request object for our Application Service
    in order to abstract the delivery mechanism — in this example, a web request —
    from the business logic. Last, we execute the Application Service, get the response,
    and use that response for rendering the result. On the Domain side, let''s check
    a possible implementation for the Application Service that coordinates the logic
    that fulfills the *User signs up* use case:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们为我们的应用程序服务创建了一个新的实例，传递了所有需要的依赖项——在这个例子中，是一个`UserRepository`。`UserRepository`是一个可以由任何特定技术实现的接口（例如：MySQL、Redis、Elasticsearch）。然后，我们为我们的应用程序服务构建一个请求对象，以便抽象化交付机制——在这个例子中，是一个网络请求——从业务逻辑中。最后，我们执行应用程序服务，获取响应，并使用该响应来渲染结果。在领域一侧，让我们检查一个可能的实现，该实现协调满足“用户注册”用例的逻辑：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Everything in the code is about the Domain problem we want to solve, and not
    about the specific technology we''re using to solve it. With this approach, we
    can decouple the high-level policies from the low-level implementation details.
    The communication between the delivery mechanism and the Domain is carried by
    data structures called DTOs, which we introduced in the [Chapter 2](d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml), *Architectural
    Styles*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的每一件事都是关于我们想要解决的领域问题，而不是我们用来解决它的特定技术。采用这种方法，我们可以将高级策略与低级实现细节解耦。交付机制与领域之间的通信由称为DTO的数据结构携带，我们在第2章中介绍了它，*架构风格*：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are different strategies for returning content, but for now, consider
    that we shouldn''t return our Entities so that they can''t be modified from outside
    our Application Services. That''s why it''s common to return another DTO with
    information, rather than the whole Entity. Let''s see a simple example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的策略用于返回内容，但到目前为止，请考虑我们不应该返回我们的实体，这样它们就不能从我们的应用程序服务外部被修改。这就是为什么通常返回另一个包含信息的DTO，而不是整个实体。让我们看看一个简单的例子：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For creating your responses, you can use getters or public instance variables.
    Application Services should take care with transaction scopes and security. However,
    you'll delve into more detail about these and other things related to Application
    Services in the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建您的响应，您可以使用getter或公共实例变量。应用程序服务应负责事务范围和安全。然而，您将在第11章中深入了解这些以及其他与应用程序服务相关的内容，*应用程序*。
- en: Domain Services
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域服务
- en: 'Throughout conversations with Domain Experts, you''ll come across concepts
    in the Ubiquitous Language that can''t be neatly represented as either an Entity
    or a Value Object, such as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在与领域专家的整个对话中，您会遇到一些在通用语言中无法整洁地表示为实体或值对象的概念，例如：
- en: Users being able to sign into systems by themselves
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能够自行登录系统
- en: A shopping cart being able to become an order by itself
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个购物车能够自行变成订单
- en: 'The preceding example are two concrete concepts, neither of which can naturally
    be bound to either an Entity or a Value Object. Further highlighting this oddity,
    we can attempt to model the behavior as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是两个具体概念，它们都不能自然地绑定到实体或值对象。进一步突出这种异常，我们可以尝试如下建模行为：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the case of the first implementation, we're not able to know that the given
    username and password relate to the invoked-upon user instance. Clearly, this
    operation doesn't suit this Entity; instead, it should be extracted out into a
    separate class, making its intention explicit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种实现的情况下，我们无法知道给定的用户名和密码与被调用的用户实例相关联。显然，这个操作不适合这个实体；相反，它应该被提取到一个单独的类中，使其意图明确。
- en: 'With this in mind, we could create a Domain Service with the sole responsibility
    of authenticating users:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以创建一个仅负责验证用户的领域服务：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, as in the case of the second example, we could create a Domain Service
    specialized in creating orders from a supplied cart:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，正如第二个示例的情况，我们可以创建一个专门从提供的购物车创建订单的领域服务：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A Domain Service can be defined as an operation that fulfills a Domain task
    and naturally doesn't fit into either an Entity or a Value Object. As concepts
    that represent operations in the Domain, Domain Services should be used by clients
    regardless of their run history. Domain Services don't hold any kind of state
    by themselves, so Domain Services are stateless operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务可以被定义为执行领域任务的操作，并且自然不适合实体或值对象。作为代表领域操作的概念，领域服务应该由客户端使用，无论它们的运行历史如何。领域服务本身不持有任何状态，因此领域服务是无状态的操作。
- en: Domain Services and Infrastructure Services
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域服务和基础设施服务
- en: 'It''s common to encounter infrastructural dependencies when modeling a Domain
    Service  — for example, in the case where an authentication mechanism that handles
    password hashing is required. In this instance, you could use a [Separated Interface](http://martinfowler.com/eaaCatalog/separatedInterface.html),
    which allows for multiple hashing mechanisms to be defined. Using this pattern
    still provides you with a clear Separation of Concerns between the Domain and
    the Infrastructure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模领域服务时，遇到基础设施依赖是很常见的——例如，在需要处理密码散列的认证机制的情况下。在这种情况下，你可以使用[分离接口](http://martinfowler.com/eaaCatalog/separatedInterface.html)，这允许定义多个散列机制。使用这种模式仍然在领域和基础设施之间提供了清晰的关注点分离：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the preceding interface found in the Domain, we could create an implementation
    in the Infrastructure layer, like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在领域中找到的先前接口，我们可以在基础设施层创建一个实现，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is another implementation based instead on the MD5 algorithm:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基于MD5算法的另一个实现：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Opting for this choice allows us to have multiple implementations of the Domain
    Service interface at the Infrastructure layer. In other words, we end up with
    several Infrastructure Domain Services. Each Infrastructure service will be responsible
    for handling a different hash mechanism. Depending on the implementation, the
    use can easily be managed through a Dependency Injection container — for example,
    through Symfony''s Dependency Injection component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这种方案允许我们在基础设施层拥有多个领域服务接口的实现。换句话说，我们最终会得到几个基础设施领域服务。每个基础设施服务将负责处理不同的散列机制。根据实现方式，用户可以通过依赖注入容器轻松管理使用，例如，通过Symfony的依赖注入组件：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If, in the future, we wish to handle a new type of hashing, we can simply start
    by implementing the Domain Service interface. Then it's a matter of declaring
    the service in the Dependency Injection container and replacing the service alias
    dependency with the newly created one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未来，我们希望处理新的散列类型，我们只需从实现领域服务接口开始。然后，只需在依赖注入容器中声明服务，并用新创建的服务别名依赖项替换即可。
- en: An Issue of Code Reuse
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码复用问题
- en: 'Although the implementation described previously clearly defines the Separation
    of Concerns, we''re required to repeat the password verification algorithm every
    time we wish to implement a new hashing mechanism. An alternative for solving
    this problem, which improves code reuse, is by separating out these two responsibilities.
    We could instead extract the password hashing logic out into a specialized class,
    using the [Strategy Pattern](http://en.wikipedia.org/wiki/Strategy_pattern) for
    all defined hashing algorithms. This leaves the design open for extension and
    closed for modification:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前描述的实现清楚地定义了关注点分离，但我们每次想要实现一个新的散列机制时，都需要重复密码验证算法。解决此问题的另一种方法，它可以提高代码复用性，是将这两个责任分离出来。我们可以将这些密码散列逻辑提取到一个专门的类中，使用[策略模式](http://en.wikipedia.org/wiki/Strategy_pattern)对所有定义的散列算法进行处理。这使设计可以扩展，但修改是封闭的：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Defining different hashing strategies is as easy as implementing the `PasswordHashing`
    interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不同的散列策略就像实现`PasswordHashing`接口一样简单：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Testing Domain Services
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试领域服务
- en: 'Given the user authentication example from multiple Domain Service implementations,
    it''s extremely beneficial to be able to easily test the service. Typically, however,
    testing the Template Method implementations can be tricky. As a result, we''ll
    be using a plain password hashing implementation for testing purposes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个领域服务实现的用户身份验证示例中，能够轻松测试服务是非常有益的。然而，通常情况下，测试模板方法实现可能会很棘手。因此，我们将使用一个简单的密码散列实现来进行测试：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can test all cases in the Domain Service:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在领域服务中测试所有情况：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Anemic Domain Models Vs Rich Domain Models
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贫血型领域模型与丰富型领域模型
- en: You must be cautious not to overuse Domain Service abstractions within your
    system. Following this path can lead to Entities and Value Objects being stripped
    of all behavior and becoming mere data containers. This is contrary to the goal
    of Object-Oriented Programming, which can be thought of as the gathering of both
    data and behavior into semantic units called objects, with the intent of expressing
    real-world concepts and problems. Domain Service overuse can be considered an
    anti-pattern and is referred to as the Anemic Domain Model.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心不要在系统中过度使用领域服务抽象。走这条路可能会导致实体和值对象失去所有行为，仅仅成为数据容器。这与面向对象编程的目标相悖，面向对象编程可以被视为将数据和行为聚集到称为对象的语义单元中，目的是表达现实世界概念和问题。过度使用领域服务可以被视为一种反模式，被称为贫血领域模型。
- en: Typically, when starting a new project or feature, it's easy to fall into the
    trap of modeling the data first. This commonly includes thinking that each database
    table has a direct one-to-one object form representation. However, this thinking
    may or may not be the exact case all the time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开始一个新的项目或功能时，很容易陷入首先建模数据的陷阱。这通常包括认为每个数据库表都有一个直接的一对一对象形式表示。然而，这种想法可能并不总是完全正确。
- en: 'Suppose we''re tasked with modeling an order processing system. If we start
    by modeling the data first, we could end up with an SQL script like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被要求建模一个订单处理系统。如果我们首先建模数据，我们可能会得到一个像这样的SQL脚本：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From this, it''s relatively easy to create an `Order` class representation.
    This representation includes the required accessor methods, which are used to
    set or get data to and from the underlying orders database table:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，创建一个`Order`类表示相对容易。这个表示包括所需的访问器方法，用于设置或获取从底层订单数据库表的数据：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An example use case for this implementation could be to update the order status
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的示例用例可能是更新订单状态如下：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With regard to code reuse, this code has a problem similar to the initial user
    authentication solution. To resolve this issue, defenders of such a practice suggest
    the use of a [Service layer](http://martinfowler.com/eaaCatalog/serviceLayer.html),
    thereby making the operations explicit and reusable. This preceding implementation
    could now instead be encapsulated into a separate class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码复用，这段代码存在与初始用户认证解决方案类似的问题。为了解决这个问题，这种做法的支持者建议使用一个[服务层](http://martinfowler.com/eaaCatalog/serviceLayer.html)，从而使操作变得明确且可重用。现在的先前实现现在可以封装到一个单独的类中：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or, in the case of updating an order amount, consider this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在更新订单金额的情况下，考虑以下情况：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The client code would be drastically reduced following a clearly intentioned
    operation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行明确意图的操作后，客户端代码将大大减少。
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implementing this approach can result in a large degree of code reusability.
    Someone who wishes to update the order amount simply has to retrieve an instance
    of `UpdateOrderAmountService` and invoke the execute method with the appropriate
    parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这种方法可以带来很高的代码复用度。如果有人想要更新订单金额，只需检索一个`UpdateOrderAmountService`实例，并使用适当的参数调用execute方法。
- en: However, choosing this path breaks the discussed Object-Oriented Design principles
    and incurs the costs of building a Domain Model without taking advantage of any
    of the benefits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，选择这条路径打破了讨论的面向对象设计原则，并承担了构建领域模型而不利用任何好处所带来的成本。
- en: Anemic Domain Model Breaks Encapsulation
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贫血领域模型破坏封装
- en: If we revisit the code used to define the services within our Service layer,
    we can see that as a client making use of the Order Entity, we're required to
    know every detail of its internal representation. This finding goes against the
    fundamental rule of Object-Oriented Programming, which is combining data with
    subsequent behavior
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾定义服务层中服务的代码，我们可以看到，作为一个使用订单实体的客户端，我们需要了解其实际表示的每一个细节。这个发现违反了面向对象编程的基本规则，即结合数据与随后的行为
- en: Anemic Domain Model Brings a False Sense of Code Reuse
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贫血领域模型带来代码复用的假象
- en: 'Say there''s an instance where a client bypasses `UpdateOrderAmountService`
    and instead fetches, updates, and persists directly to `OrderRepository`. Then,
    all the extra business logic that the `UpdateOrderAmountService` service might
    have won''t be executed. This could lead to the order being stored in an inconsistent
    state. As such, invariants should be correctly guarded, and the best way to do
    this is to let the true Domain Model handle it. In the case of this example, the
    Order Entity would be the best place to ensure this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个实例，客户端绕过`UpdateOrderAmountService`，而是直接从`OrderRepository`获取、更新和持久化。那么，`UpdateOrderAmountService`服务可能拥有的所有额外业务逻辑都不会被执行。这可能导致订单以不一致的状态存储。因此，不变量应该得到正确的保护，而最好的方式是让真正的领域模型来处理。在这个例子中，订单实体将是确保这一点的最佳位置：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that by pushing this action down into the Entity and naming it in terms
    of the Ubiquitous Language, the system achieves great code reuse. Anyone who now
    wishes to change the amount of the order has to invoke the `Order::changeAmount`
    method directly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过将此操作推入实体并以通用语言命名，系统实现了代码的重用。现在任何希望更改订单数量的人都必须直接调用`Order::changeAmount`方法。
- en: This leads to far richer classes, where behavior is the goal for code reuse.
    This is commonly referred to as a Rich Domain Model.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致产生了更丰富的类，其中行为是代码重用的目标。这通常被称为丰富的领域模型。
- en: How to Avoid Anemic Domain Models
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何避免贫血领域模型
- en: 'The way to avoid falling into an Anemic Domain Model is to, when starting a
    new project or feature, think of the behavior first. Databases, ORMs, and so on
    are just implementation details, and we should strive to push the decision to
    use these tools as late in the development process as we can. In doing so, we
    can focus on the one true attribute that matters: the behavior.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 避免陷入贫血领域模型的方法是在开始一个新项目或功能时，首先考虑行为。数据库、ORM等只是实现细节，我们应该努力将使用这些工具的决定推迟到开发过程的后期。这样做，我们可以专注于真正重要的一个属性：行为。
- en: Just as is the case with Entities, Domain Services can also fire [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*.
    However, when events are mostly fired by Domain Services and not Entities, it's
    again an indicator that you may be creating an Anemic Domain Model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与实体一样，领域服务也可以触发[第6章](607255c5-e619-4398-94bb-484c008472b7.xhtml)，*领域事件*。然而，当事件主要由领域服务而非实体触发时，这又是一个你可能正在创建贫血领域模型的指标。
- en: Wrap-Up
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'As we''ve seen, Services represent operations inside our system, and we can
    differentiate between three versions of them:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，服务代表了我们系统内的操作，我们可以区分它们的三个版本：
- en: '**Application Services**: Help coordinate requests from the outside world into
    the Domain. These Services should not contain Domain logic. Transactions are handled
    in the application level; wrapping your services inside transnational decorators
    will make your code transaction agnostic.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**：帮助协调来自外部世界的请求到领域。这些服务不应包含领域逻辑。事务在应用级别处理；将你的服务包裹在事务装饰器中会使你的代码对事务不可知。'
- en: '**Domain Services**: Operate with Domain concepts only, which are expressed
    by the Ubiquitous Language. Remember to postpone implementation details and think
    of behavior first, as abuse of Domain Services will lead to Anemic Domain Models
    and bad Object-Oriented Design.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**：仅使用领域概念进行操作，这些概念通过通用语言表达。记住推迟实现细节，首先考虑行为，因为滥用领域服务会导致贫血领域模型和糟糕的面向对象设计。'
- en: '**Infrastructure Services**: Operate over Infrastructure, doing things like
    sending emails or logging information.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施服务**：在基础设施上操作，例如发送电子邮件或记录信息。'
- en: Our most important recommendation is that you should consider all your options
    before deciding on creating a Domain Service. First try to move your business
    logic inside an Entity or Value. Check with some workmates. Review again. If,
    after different approaches, the best option is creating a Domain Service, go for
    it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最重要的建议是在决定创建领域服务之前，考虑所有选项。首先尝试将业务逻辑移入实体或值。与一些同事讨论。再次审查。如果经过不同的方法，最佳选项是创建领域服务，那么就去做吧。
