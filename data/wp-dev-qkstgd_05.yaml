- en: Extending Plugins with Addons, Filters, and Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用附加组件、过滤器以及动作扩展插件
- en: uilding sites with WordPress involves using existing plugins or creating your
    own plugins. You should be able to extend existing plugins with new features as
    well as make your plugins extendable for other developers. We use addons to extend
    the functionality of a core plugin. So, it's important to keep your plugins extendable
    so that you can later use addons to add or remove functionality. On the other
    hand, using and customizing existing plugins with addons allows you to provide
    low-cost and quality solutions. So, you need to master the techniques of building
    addons for customizing plugin features as well as integrating multiple plugins.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WordPress构建网站涉及使用现有插件或创建自己的插件。你应该能够通过添加新功能来扩展现有插件，同时使你的插件可由其他开发者扩展。我们使用附加组件来扩展核心插件的功能。因此，保持你的插件可扩展非常重要，这样你就可以在以后使用附加组件来添加或删除功能。另一方面，使用和自定义现有插件与附加组件一起，可以让你提供低成本和高品质的解决方案。因此，你需要掌握构建附加组件以自定义插件功能和集成多个插件的技巧。
- en: In this chapter, we explain the importance of addons while following the step-by-step
    guide to creating an addon for a plugin. WordPress uses a hook-based architecture
    and hence the built-in hooks are executed in a predefined sequence. We look at
    the proper execution of these hooks to prevent unnecessary conflicts. Then, we
    move into customization techniques for plugins while learning the advance uses
    of script loading and built-in AJAX features. We will be developing a product
    files addon for WooCommerce, in order to practically experience the customization
    process. Finally, we integrate the WooCommerce, MyCred, and BuddyPress plugins
    to learn the best practices of plugin integrations and their limitations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了在遵循创建插件附加组件的逐步指南的同时，附加组件的重要性。WordPress使用基于钩子的架构，因此内置钩子按照预定义的顺序执行。我们查看这些钩子的正确执行以防止不必要的冲突。然后，我们进入插件的自定义技术，同时学习脚本加载和内置AJAX功能的先进用法。我们将开发一个用于WooCommerce的产品文件附加组件，以便实际体验自定义过程。最后，我们将集成WooCommerce、MyCred和BuddyPress插件，以学习插件集成的最佳实践及其局限性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to addons development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加组件开发简介
- en: Creating a basic addon for the post attachments plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子附件插件创建一个基本的附加组件
- en: Understanding the WordPress core action execution process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WordPress核心动作执行过程
- en: Customizing third-party plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义第三方插件
- en: Identifying techniques for integrating plugins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别集成插件的技巧
- en: Integrating multiple plugins for continuous workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成多个插件以实现连续工作流程
- en: By the end of this chapter, you will have the ability to customize third-party
    plugins using different techniques, and integrate multiple plugins to build a
    continuous workflow for your site.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用不同的技术自定义第三方插件，并集成多个插件以构建你网站的连续工作流程。
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此程序需要安装WordPress 4.9.8。即使你没有
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个较新版本的WordPress，描述的示例应该没有重大问题可以运行。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2Q8LtBa](http://bit.ly/2Q8LtBa)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Q8LtBa](http://bit.ly/2Q8LtBa)'
- en: Introduction to addons
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加组件简介
- en: In general terms, addons are components that change the behavior of a core component.
    As a developer, you might be familiar with using browser extensions to support
    development tasks. In such a scenario, the web browser acts as the core component
    and the extensions act as the addons that install on top of the web browser. The
    addons in WordPress follows the same concept. However, WordPress addons itself
    are plugins that change the behavior of a main plugin. Unlike browser extensions,
    addons in WordPress don't install on top of a plugin. Instead, they act as separate
    addon plugins.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般意义上讲，附加组件是改变核心组件行为的组件。作为一名开发者，您可能熟悉使用浏览器扩展来支持开发任务。在这种情况下，网络浏览器充当核心组件，扩展充当安装在浏览器之上的附加组件。WordPress中的附加组件遵循相同的概念。然而，WordPress附加组件本身是改变主插件行为的插件。与浏览器扩展不同，WordPress中的附加组件不会安装在插件之上。相反，它们作为独立的附加插件。
- en: 'Usually, addons are used to add new features to the core component. However,
    WordPress addons are developed to add, change, or remove features of a core component.
    Let''s take a look at some of the popular plugins with a large addons base:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，附加组件用于向核心组件添加新功能。然而，WordPress附加组件的开发是为了添加、更改或删除核心组件的功能。让我们看看一些具有大型附加组件库的流行插件：
- en: '**WooCommerce**: This is an eCommerce plugin that allows you to sell physical
    goods as well as digital products. This plugin has an extensive addons base of
    over 250 addons in various categories. Payment gateways are the most popular type
    of addon in WooCommerce with over 75 addons. You can view and learn more about
    the addons base at [https://woocommerce.com/product-category/woocommerce-extensions/.](https://woocommerce.com/product-category/woocommerce-extensions/)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WooCommerce**：这是一个电子商务插件，允许您销售实体商品以及数字产品。此插件拥有超过250个各种类别的广泛附加组件库。支付网关是WooCommerce中最受欢迎的附加组件类型，拥有超过75个附加组件。您可以在[https://woocommerce.com/product-category/woocommerce-extensions/](https://woocommerce.com/product-category/woocommerce-extensions/)查看并了解更多关于附加组件的信息。'
- en: '**Easy Digital Downloads**: This is an eCommerce solution allowing you to sell
    digital products. This plugin also offers over 100 addons while many of them fall
    into the marketing category. You can learn more about the addons base at [https://easydigitaldownloads.com/downloads/.](https://easydigitaldownloads.com/downloads/)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Easy Digital Downloads**：这是一个电子商务解决方案，允许您销售数字产品。此插件还提供超过100个附加组件，其中许多属于营销类别。您可以在[https://easydigitaldownloads.com/downloads/](https://easydigitaldownloads.com/downloads/)了解更多关于附加组件的信息。'
- en: '**WP Bakery Page Builder**:This is a plugin used for building page using pre-built
    components. Both WooCommerce and Easy Digital Downloads are free plugins in the
    WordPress plugin directory. However, this is a premium-only plugin with over 250
    addons in various categories. The UI elements is the most popular addon category
    for this plugin. You can view and learn more about the addons base at [https://wpbakery.com/addons/.](https://wpbakery.com/addons/)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WP Bakery Page Builder**：这是一个用于使用预构建组件构建页面的插件。WooCommerce和Easy Digital Downloads都是WordPress插件目录中的免费插件。然而，这是一个仅限高级版的插件，拥有超过250个各种类别的附加组件。UI元素是这个插件最受欢迎的附加组件类别。您可以在[https://wpbakery.com/addons/](https://wpbakery.com/addons/)查看并了解更多关于附加组件的信息。'
- en: hese are some of the plugins with a large addons base. The existence of addons
    means that the plugin is coded with necessary hooks for future extension. You
    can check more popular free and premium plugins to check the availability of addons.
    Also, you should check the role of each addon and how it interacts with the main
    plugin. Once you explore different types of addons, you will understand the types
    of hooks needed in development and how to add them to keep the code open for extension.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些具有大型附加组件库的插件。附加组件的存在意味着插件是用必要的钩子编写的，以便未来扩展。您可以检查更多流行的免费和高级插件，以检查附加组件的可用性。此外，您应该检查每个附加组件的角色以及它如何与主插件交互。一旦您探索了不同类型的附加组件，您将了解开发中需要的钩子类型以及如何将它们添加到代码中，以保持代码可扩展。
- en: Creating addons for plugins
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为插件创建附加组件
- en: 'The process of creating addons is similar to the process we used for plugins.
    However, the possibility of creating an addon depends on the quality of the code
    in the core plugin. The core plugin should either provide an API to build addons
    or necessary hooks for extension. As many plugins don''t contain a separate API,
    most addons are built by using the existing hooks. Let''s see how we can create
    an addon for the post attachments plugin created in the previous chapter. Assume
    that we have the following requirements to be developed as an addon:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建插件的流程与我们用于插件的过程类似。然而，创建插件的可行性取决于核心插件的代码质量。核心插件应该提供构建插件的API或扩展所需的钩子。由于许多插件不包含单独的API，大多数插件都是通过使用现有的钩子构建的。让我们看看我们如何为上一章创建的帖子附件插件创建一个插件。假设我们有以下要求作为插件开发：
- en: Restrict attachment file types based on default WordPress user roles. Let's
    provide PDF file access only for non-subscriber members and all other file types
    to all users in the site.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据默认的WordPress用户角色限制附件文件类型。让我们只为非订阅会员提供PDF文件访问权限，并为网站中的所有其他用户开放所有其他文件类型。
- en: Download counter for attachments. We have to count the number of downloads for
    all attachments of a post, separately for guest users and logged-in users.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附件下载计数器。我们必须分别对访客用户和登录用户计算帖子的所有附件的下载次数。
- en: In order to implement such requirements without touching the core plugin files,
    we need to check the availability of any hooks within the plugin. Unfortunately,
    we don't have any hooks within the plugin, as it was not planned for future extension.
    So, we have to make the plugin extendable, by adding the necessary hooks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不修改核心插件文件的情况下实现这些要求，我们需要检查插件中是否有任何钩子。不幸的是，我们没有在插件中找到任何钩子，因为它没有为未来的扩展而设计。因此，我们必须通过添加必要的钩子使插件可扩展。
- en: Adding a filter hook for restricting attachments
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加过滤器钩子以限制附件
- en: 'Implementing attachment restrictions requires us to conditionally check the
    user permissions and hide the attachment for unauthorized users. So, we need a
    filter that can modify the output of attachments in list. Let''s add a filter
    to the file list code inside `wpqpa_file_attachment_list`. We need to replace
    the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实施附件限制需要我们根据用户权限进行条件检查并隐藏未授权用户的附件。因此，我们需要一个可以修改列表中附件输出的过滤器。让我们在`wpqpa_file_attachment_list`内部的文件列表代码中添加一个过滤器。我们需要替换以下代码：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, you should remove the preceding code and add the following code to the
    same location:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该删除前面的代码，并将以下代码添加到相同的位置：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of directly adding each file HTML code to the `$display` variable, we
    use a custom filter called `wpqpa_post_attachment_list_item` with file details
    passed as a parameter. This filter allows us to modify the HTML for each file
    before it's delivered to the browser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接将每个文件的HTML代码添加到`$display`变量中，而是使用一个名为`wpqpa_post_attachment_list_item`的自定义过滤器，并将文件详细信息作为参数传递。这个过滤器允许我们在文件发送到浏览器之前修改每个文件的HTML。
- en: Adding an action hook for counting downloads
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作钩子以计数下载
- en: 'In the preceding section, we looked at the process of using filter hooks to
    extend plugins. We can also use action hooks to extend plugins through addons.
    The process of counting downloads should be initialized just after the user clicks
    the Download link and before the file download popup is shown on the browser.
    So, we need an action hook within those two events. Let''s modify the `wpqpa_file_attachment_download`
    function to include a new action, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了使用过滤器钩子扩展插件的过程。我们也可以通过插件来使用动作钩子扩展插件。下载次数的计数过程应该在用户点击下载链接之后和浏览器显示文件下载弹出窗口之前初始化。因此，我们需要在这两个事件之间添加一个动作钩子。让我们修改`wpqpa_file_attachment_download`函数以包含一个新的动作，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The highlighted line shows the modifications added to the existing code. This
    action allows us to implement additional features before the file is sent to the
    browser as a download. Now, we have the necessary hooks to create the addon and
    implement the features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了添加到现有代码中的修改。这个动作允许我们在文件作为下载发送到浏览器之前实现额外的功能。现在，我们有创建插件和实现功能的必要钩子。
- en: Creating the attachments addon
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件插件
- en: 'As usual, we have to start by creating a plugin directory with a main plugin
    file, and inserting the header comments to define it as a plugin. We are not going
    to repeat the code in this section. You can find a directory and files for attachments
    addon inside the `wpquick-attachments-addon` directory in source codes. We are
    going to start the development by restricting the PDF files to users with a subscriber
    role. Let''s implement the `wpqpa_post_attachment_list_item` filter we added in
    the previous section:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们必须首先创建一个插件目录，并包含一个主插件文件，插入头部注释来定义它为一个插件。我们不会在这一节重复代码。你可以在源代码的`wpquick-attachments-addon`目录中找到一个附件插件目录和文件。我们将通过限制PDF文件只对具有订阅者角色的用户可见来开始开发。让我们实现上一节中添加的`wpqpa_post_attachment_list_item`过滤器：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s what this code does:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: The callback function has two parameters, with the first one being the HTML
    for displaying the file link and the second one being the details about the file
    from database.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调函数有两个参数，第一个是显示文件链接的HTML，第二个是从数据库中关于文件的详细信息。
- en: First, we construct the path of the file by using the WordPress `wp_upload_dir`
    function and file path captured from our custom table.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用WordPress的`wp_upload_dir`函数和从我们的自定义表中捕获的文件路径来构造文件路径。
- en: Then, we use the PHP `mime_content_type` function to get the MIME type of the
    attachment.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用PHP的`mime_content_type`函数来获取附件的MIME类型。
- en: Next, we filter the files with the MIME type for PDF.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用PDF的MIME类型来过滤文件。
- en: Then, we use the condition to check whether the file should be displayed to
    the user. The first part of the condition checks if we are logged into the site,
    as the file needs to be restricted for guest users. The second part of the condition
    checks if the user is logged in as a subscriber.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用条件来检查文件是否应该显示给用户。条件的第一部分检查我们是否登录到网站，因为文件需要限制对访客用户的访问。条件的第二部分检查用户是否以订阅者的身份登录。
- en: We restrict the file by emptying the content when one of these conditions is
    met.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当满足这些条件之一时，我们通过清空内容来限制文件。
- en: 'Now, we have implemented one of the addon features using a filter hook. Next,
    we can implement our second requirement for counting downloads using an action
    hook. Let''s implement the custom `wpqpa_before_download_post_attachment` action
    using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用过滤器钩子实现了一个插件功能。接下来，我们可以使用动作钩子来实现我们的第二个需求，即统计下载次数。让我们使用以下代码实现自定义的`wpqpa_before_download_post_attachment`动作：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we define the action with a callback function, `wpqaa_before_download_post_attachment`.
    The attachment data received from the `wp_wpqpa_post_attachments` table is passed
    as an array type parameter to this function. We use a conditional check to filter
    the logged in users and guest users. Our requirement is to count the total downloads
    for attachments of a single file. So, we can use the `wp_postmeta` table to store
    the download count.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用回调函数定义动作，`wpqaa_before_download_post_attachment`。从`wp_wpqpa_post_attachments`表中接收的附件数据以数组类型参数传递给此函数。我们使用条件检查来过滤已登录用户和访客用户。我们的需求是统计单个文件的附件的总下载次数。因此，我们可以使用`wp_postmeta`表来存储下载次数。
- en: In actual implementations, we may need to count the downloads for individual
    attachments, instead of the total count for all attachments in a post. In such
    a scenario, we can't use the `wp_postmeta` table as we can only store data based
    on post ID. So, we need to have an additional column in the `wp_wpqpa_post_attachments`
    table to keep and display the download counts for each attachment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际实现中，我们可能需要统计单个附件的下载次数，而不是文章中所有附件的总下载次数。在这种情况下，我们不能使用`wp_postmeta`表，因为我们只能根据文章ID存储数据。因此，我们需要在`wp_wpqpa_post_attachments`表中添加一个额外的列来保存和显示每个附件的下载次数。
- en: We can get the existing download count for a post using the `get_post_meta`
    function. Here, we use two keys called `wpqaa_member_download_count` and `wpqaa_guest_download_count`
    to separate the counts for guests and members. Later, we can use these keys to
    display the counts along with files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`get_post_meta`函数获取文章的现有下载次数。在这里，我们使用两个键`wpqaa_member_download_count`和`wpqaa_guest_download_count`来区分访客和成员的计数。稍后，我们可以使用这些键来显示计数和文件。
- en: In just a few lines of code, we have an addon that adds functionality to the
    core plugin and works independently. So, developing addons for any plugin is simple. However,
    the core plugin needs to provide the correct actions and filters, as well as developers
    being capable of finding the appropriate hooks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，我们就有了一个为核心插件添加功能并独立工作的插件。因此，为任何插件开发插件都很简单。然而，核心插件需要提供正确的动作和过滤器，以及开发者能够找到适当的钩子。
- en: The WordPress action execution process
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress动作执行过程
- en: Up to this point, we used some of the built-in actions and filters, while explaining
    the practical uses. However, you might be still trying to grab the concept, as
    it's not a practice used in pure PHP development. The process gets even tougher
    when coping with the lack of knowledge in the action execution process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了一些内置的动作和过滤器，同时解释了其实际用途。然而，你可能仍在尝试掌握这个概念，因为它不是纯PHP开发中常用的实践。当处理动作执行过程的知识缺乏时，这个过程变得更加困难。
- en: '**What is the action execution process?**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作执行过程是什么？**'
- en: WordPress has a set of built-in actions that are executed within the loading
    process of each and every request. Each of these actions has a sepcific responsibility
    in the loading process. The actions used for the loading process are executed
    in a predefined sequence. However, The WordPress Codex specially mentions that
    we shouldn't rely entirely on the loading process as it can vary based on the
    other components in the site.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress有一组内置的动作，这些动作在每个请求的加载过程中执行。这些动作中的每一个在加载过程中都有特定的职责。用于加载过程的动作按照预定义的顺序执行。然而，WordPress
    Codex特别指出，我们不应完全依赖加载过程，因为它可以基于网站的其他组件而变化。
- en: This list may show only the first time each action is called, and in many cases
    no function is hooked to the action. Themes and plugins can cause actions to be
    called multiple times and at differing times during a request. This list should
    be viewed as a guideline or approximation of the WordPress action execution order,
    and not a concrete specification.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表可能仅显示每个动作第一次被调用的情形，并且在许多情况下没有函数被连接到该动作。主题和插件可能导致动作被多次调用，并在请求的不同时间点调用。此列表应被视为WordPress动作执行顺序的指南或近似，而不是具体规范。
- en: Implementing features using these actions without considering the sequence can
    often lead to conflicts. In WordPress, execution of these actions in the admin
    page requests differs from a typical page request. So, we have to be aware of
    both the frontend action execution process as well as the backend action execution
    process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不考虑执行顺序，使用这些动作实现功能往往会引起冲突。在WordPress中，这些动作在管理页面请求中的执行与典型页面请求不同。因此，我们必须了解前端动作执行过程以及后端动作执行过程。
- en: The frontend action execution process
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端动作执行过程
- en: 'The frontend action execution process starts with the `muplugins_loaded` action,
    which fires after the must-use and network-activated plugins are completed loading.
    The process completes by executing the `shutdown` action. There are 40+ actions
    called in a typical request, where some of them have higher importance in the
    development tasks. However, some of these actions change based on the request,
    and hence we can only use this as guidance. Let''s take a look at the following
    illustration to understand the general actions and the order of execution:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前端动作执行过程从`muplugins_loaded`动作开始，该动作在必须使用和已激活网络插件完成加载后触发。过程通过执行`shutdown`动作来完成。在典型请求中，会调用40多个动作，其中一些在开发任务中具有更高的重要性。然而，一些动作会根据请求而变化，因此我们只能将其作为指导。让我们看一下以下插图，以了解一般动作和执行顺序：
- en: '![](img/e884d276-47f6-45a3-904e-77b432fd9e53.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e884d276-47f6-45a3-904e-77b432fd9e53.png)'
- en: Let's understand the illustration of the loading process. The process begins
    with the `muplugins_loaded` action and moves downwards until it reaches the `admin_bar_init`
    action. Then, it starts from the `add_admin_bar_menus` action in the second column
    and moves downward, and so on. We have highlighted some of the actions used frequently
    in development. You can learn more about the action execution process at [https://codex.wordpress.org/Plugin_API/Action_Reference](https://codex.wordpress.org/Plugin_API/Action_Reference).
    The order of execution of these actions is very important in custom development,
    especially when we use the built-in global objects of WordPress.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解加载过程的示意图。该过程从`muplugins_loaded`动作开始，向下移动直到达到`admin_bar_init`动作。然后，它从第二列的`add_admin_bar_menus`动作开始，向下移动，依此类推。我们突出了一些在开发中常用的一些动作。您可以在[https://codex.wordpress.org/Plugin_API/Action_Reference](https://codex.wordpress.org/Plugin_API/Action_Reference)了解更多关于动作执行过程的信息。这些动作的执行顺序在自定义开发中非常重要，尤其是在我们使用WordPress的内置全局对象时。
- en: First, we are going to create a new plugin called **WPQAL Action Loading**,
    to test the functionality when loading specific actions. The process of creating
    the plugin is same as the one used in previous occurrences. Therefore, you can
    check the source codes directory of this chapter to find the implementation for
    the WPQAL Action Loading plugin. Let's use the preceding illustration and some
    practical usage scenarios to understand the importance of proper use of actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为**WPQAL Action Loading**的新插件，用于测试加载特定动作时的功能。创建该插件的过程与之前的情况相同。因此，您可以查看本章的源代码目录，以找到WPQAL
    Action Loading插件的实现。让我们通过前面的插图和一些实际使用场景来了解正确使用动作的重要性。
- en: Scenario 1 – Using parent plugin features
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景1 – 使用父插件功能
- en: 'This is commonly used in addon development, as we rely on the features of the
    main plugin. In addon development, we have to use constants, functions, classes,
    global objects from the main plugin. Unless we use the proper WordPress actions,
    these features may not be accessible within the addon. Assume that we have an
    addon plugin that gets loaded before the parent plugin. We can think of the **WPQPA
    Post Attachments** plugin as the main plugin and WPQAL Action Loading as the addon
    plugin to check this scenario. The WPQPA Post Attachments plugin is loaded after
    WPQAL Action Loading plugin. So, we can add the following line of code to main
    file of WPQAL Action Loading plugin and check the output by refreshing the browser:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这在插件开发中常用，因为我们依赖于主插件的功能。在插件开发中，我们必须使用主插件中的常量、函数、类和全局对象。除非我们使用正确的WordPress动作，否则这些功能可能无法在插件中访问。假设我们有一个在父插件之前加载的插件插件。我们可以将**WPQPA
    Post Attachments**插件视为主插件，将WPQAL Action Loading视为插件插件来检查此场景。WPQPA Post Attachments插件在WPQAL
    Action Loading插件之后加载。因此，我们可以在WPQAL Action Loading插件的主文件中添加以下代码行，并通过刷新浏览器来检查输出：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the constant used to define the plugin path of the **WPQPA Post Attachments**
    plugin and hence it should print the actual path to the browser. Instead, the
    output will be `WPQPA_PLUGIN_URL`, as string. The problem is we are trying to
    access a constant not defined when we are trying to access it. So, we need to
    access such constants, functions, variables when all plugins have completed the
    loading process. We can refer to the image and find an action called `plugins_loaded`.
    This action is executed after WordPress has completed loading all active plugins.
    So, let''s take a look at the proper implementation of the preceding code to print
    the plugin path:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于定义**WPQPA Post Attachments**插件插件路径的常量，因此它应该打印出实际的路径到浏览器。相反，输出将是`WPQPA_PLUGIN_URL`字符串。问题是我们试图访问一个在我们试图访问时未定义的常量。因此，我们需要在所有插件完成加载过程时访问这样的常量、函数和变量。我们可以参考图像并找到一个名为`plugins_loaded`的动作。这个动作在WordPress完成加载所有活动插件后执行。因此，让我们看看前面代码的正确实现来打印插件路径：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, you should see the correct plugin path printed to the browser. You can
    uncomment the code for *Scenario 1* in the WPQAL Action Loading plugin to test
    the scenario. To access features from other plugins, we must use `plugins_loaded`
    or a later action.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能在浏览器中看到正确的插件路径。您可以在WPQAL Action Loading插件中取消注释*场景1*的代码来测试该场景。要访问其他插件的功能，我们必须使用`plugins_loaded`或更晚的动作。
- en: Scenario 2 – Accessing the WordPress post object
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景2 – 访问WordPress帖子对象
- en: 'Usually, we can use the WordPress global `$post` object in the post details
    page to get the necessary information about a post. Let''s assume we want to get
    the ID of the loaded post within a plugin function to execute some tasks. Let''s
    use the `init` action to print the post ID to the browser while accessing an individual
    post:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以在帖子详情页中使用WordPress全局`$post`对象来获取有关帖子的必要信息。假设我们想在插件函数中获取加载帖子的ID以执行某些任务。让我们使用`init`操作在访问单个帖子时将帖子ID打印到浏览器：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We expect the post ID to be printed on the browser. However, we will get an
    empty output as the `$post` object is not loaded at this stage. So, we have to
    use an action executed later in the loading process. The global `$post` object
    is only accessible in the `wp` action and the actions executed afterward. Use
    the following code to test the process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在浏览器上打印出帖子ID。然而，由于在此阶段`$post`对象尚未加载，我们将得到一个空输出。因此，我们必须使用加载过程中稍后执行的操作。全局`$post`对象仅在`wp`操作及其后续操作中可访问。使用以下代码来测试此过程：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can see the ID printed to the browser. You can also test the process
    by using the actions between `init` and `wp` in the loading process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到打印到浏览器中的ID。你还可以通过在加载过程中的`init`和`wp`之间使用操作来测试此过程。
- en: Scenario 3 – Accessing the WordPress query object
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景3 – 访问WordPress查询对象
- en: WordPress executes many database queries in the process of loading a certain
    post, page or screen. In development, we might need to access the details of the
    query such as query variables, conditions, and even the complete `sql` query generated
    from WordPress functions. So, we use the global `$wp_query` variable to access
    query details as well as make necessary modifications before execution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress在加载特定帖子、页面或屏幕的过程中执行许多数据库查询。在开发过程中，我们可能需要访问查询的详细信息，如查询变量、条件，甚至由WordPress函数生成的完整`sql`查询。因此，我们使用全局`$wp_query`变量来访问查询详细信息以及执行必要的修改。
- en: 'Let''s try to access the `$wp_query` variable using the `pre_get_posts` action
    that gets executed after the query variable object is created:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用在查询变量对象创建后执行的`pre_get_posts`操作来访问`$wp_query`变量：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the post is refreshed, you will see the details of the `$wp_query` variable
    with some parameters. But, most of the query conditions and queries are not set
    at this stage. Even though the query variable object is created, the actual query
    is not executed at this stage. This action allows us to make the modifications
    to the query using the `$query` variable passed to the function. Let''s use an
    action executed later in the process to check the `$wp_query` details using following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦帖子刷新，你将看到包含一些参数的`$wp_query`变量的详细信息。但是，在此阶段，大多数查询条件和查询尚未设置。尽管查询变量对象已创建，但实际的查询在此阶段并未执行。此操作允许我们使用传递给函数的`$query`变量对查询进行修改。让我们使用在处理过程中稍后执行的操作来使用以下代码检查`$wp_query`的详细信息：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, you will see the complete `$wp_query` variable with all the query parameters,
    conditions, and actual SQL queries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到包含所有查询参数、条件和实际SQL查询的完整`$wp_query`变量。
- en: As we experienced in these three scenarios, the action loading process plays
    a major role in development. We need to use the proper action hooks to access
    built-in WordPress variables as well as execute certain core WordPress functions.
    The method of identifying which hook to be used for certain features may not be
    straightforward. You can define the necessary actions and print the details to
    the browser without using the `exit` statements. Then you will see the action
    execution process and which action is responsible for handling each WordPress
    built-in variable and method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在这些三个场景中体验到的，动作加载过程在开发中起着重要作用。我们需要使用适当的行为钩子来访问内置WordPress变量以及执行某些核心WordPress函数。确定用于特定功能的钩子方法可能并不直接。你可以定义必要的操作并将详细信息打印到浏览器，而无需使用`exit`语句。然后你将看到动作执行过程以及哪个动作负责处理每个WordPress内置变量和方法。
- en: The backend action execution process
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端操作执行过程
- en: The backend action execution process starts with the `muplugins_loaded` action,
    which fires after the must-use and network-activated plugins are completed loading.
    The process completes by executing the `wp_dashboard_setup` action, instead of
    the `shutdown` action.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 后端操作执行过程从`muplugins_loaded`操作开始，该操作在必须使用和已激活网络插件完成加载后触发。通过执行`wp_dashboard_setup`操作而不是`shutdown`操作来完成此过程。
- en: 'There are six more actions in the backend execution process, compared to the
    frontend process. Let''s take a look at the following image to understand the
    actions and the order of execution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与前端过程相比，后端执行过程中有六个更多动作。让我们看一下下面的图片，以了解这些动作和执行顺序：
- en: '![](img/8b306c8f-5feb-4493-906f-7deec60a6311.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b306c8f-5feb-4493-906f-7deec60a6311.png)'
- en: As you can see, the initial part of the loading process is similar to the frontend
    process. Then, we see some admin-related actions executed for menus, styles, and
    header sections. So, you can use the same technique we used earlier to understand
    the execution of each action, its responsibility, and when we should use them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，加载过程的初始部分与前端过程相似。然后，我们看到一些与菜单、样式和页眉部分相关的管理相关动作被执行。因此，您可以使用我们之前使用的相同技术来了解每个动作的执行、其责任以及何时应该使用它们。
- en: How to use the priority of actions and filters
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用动作和过滤器的优先级
- en: 'We learned the action loading process and how it should be used to grab the
    proper data and execute the core features. However, developers may still get into
    trouble, even after knowing the loading process. This is due to the priority of
    executing actions. As we discussed, these actions can be executed multiple times
    within a request by WordPress core, theme, as well as other plugins. So, the same
    action hook will be implemented with different priorities. Consider the following
    code for using the `pre_get_posts` action:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了动作加载过程以及如何使用它来获取适当的数据并执行核心功能。然而，即使知道了加载过程，开发者仍然可能会遇到麻烦。这是由于执行动作的优先级。正如我们讨论的，WordPress核心、主题以及其他插件可以在请求内多次执行这些动作。因此，相同的动作钩子将以不同的优先级实现。考虑以下代码来使用`pre_get_posts`动作：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first part, we use the `pre_get_posts` action to call the `wpqal_pre_get_posts_action1`
    function and restrict site search to only posts. However, another plugin executes
    the same action with higher priority number of 20 and changes the searchable post
    types to both posts and products. So, our implementation doesn't work as expected.
    So, it's important to consider the action loading process as well as priority
    when working on a site with many plugins. Before implementing a critical hook,
    you should check the use of the same hook in other plugins of the site and make
    sure to use the correct priority to avoid conflicts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们使用`pre_get_posts`动作来调用`wpqal_pre_get_posts_action1`函数，并将站点搜索限制为仅帖子。然而，另一个插件以20的更高优先级执行了相同的动作，并将可搜索的帖子类型更改为帖子和产品。因此，我们的实现并没有按预期工作。所以，在处理拥有许多插件的站点时，考虑动作加载过程以及优先级是很重要的。在实现关键钩子之前，你应该检查站点其他插件中相同钩子的使用情况，并确保使用正确的优先级以避免冲突。
- en: Identifying the extendable features of third-party plugins
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别第三方插件的可扩展功能
- en: As we already discovered in the *Creating addons for plugins* section, not all
    plugins are extendable. Even within extendable plugins, we have a low to high
    degree of extendibility in features. So, identifying the extendable features is
    not an easy task, especially when working with advanced plugins such as WooCommerce,
    BuddyPress, and bbPress.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*为插件创建插件*部分中已经发现的，并非所有插件都是可扩展的。即使在可扩展的插件中，我们也有从低到高的可扩展性特征。因此，识别可扩展功能不是一项容易的任务，尤其是在与WooCommerce、BuddyPress和bbPress等高级插件一起工作时。
- en: In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible
    Frontends with Theme Development*, we identified the extendable features of a
    theme by searching for built-in actions and filters. We can use the same process
    for plugins, unless each and every hook in the plugin is documented on the plugin
    site. Let's take a quick look at the extendable features of the popular WooCommerce
    plugin. Use the code editor to search actions and filters within the WooCommerce
    directory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml)《使用主题开发设计灵活的前端》中，我们通过搜索内置动作和过滤器来识别主题的可扩展功能。我们可以使用相同的过程来处理插件，除非插件中的每个钩子都在插件网站上进行了文档说明。让我们快速看一下流行的WooCommerce插件的可扩展功能。使用代码编辑器在WooCommerce目录中搜索动作和过滤器。
- en: We are using WooCommerce 3.4.4 version, and we get 849 action executions and
    1,553 filter executions. So, this means we have over 2,000 locations where we
    can customize the WooCommerce plugin. In the process of customization, we have
    to find the necessary hooks with the support of documentation, checking the code
    files and experiences shared by other developers in development communities such
    as StackOverflow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 WooCommerce 3.4.4 版本，我们获得了 849 次动作执行和 1,553 次过滤器执行。这意味着我们可以在超过 2,000
    个位置自定义 WooCommerce 插件。在自定义过程中，我们必须在文档的支持下找到必要的钩子，检查代码文件以及开发社区如 StackOverflow 中其他开发者分享的经验。
- en: The availability of hooks differentiates from one plugin to another. Sometimes,
    we find plugins with a limited amount of hooks and popular plugins with thousands
    of hooks. So, you have to master the process of identifying the hook and how it
    impacts the plugin to be successful in customizing any plugin.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子的可用性因插件而异。有时，我们会发现钩子数量有限的插件和拥有数千个钩子的流行插件。因此，你必须掌握识别钩子及其对插件影响的过程，才能在自定义任何插件时取得成功。
- en: Customizing third-party plugins
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义第三方插件
- en: As developers, we prefer building our own solutions compared to using third-party
    solutions. The main reason for building our own solutions is to gain more control
    over the features as well as future enhancements. However, the main purpose of
    using WordPress is to develop rapid low-cost solutions with the use of existing
    features. It's obvious that you have to work on customizing third-patty plugins
    at some point in your development career. These third-party plugins are developed
    to provide standard solutions to common problems. Therefore, these plugins won't
    fit into the complete requirements of most sites. Often, we have to adapt these
    plugins by adding, changing, or removing features. In this section, we are going
    to look at the techniques and implementation of plugin customization using sample
    scenarios.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们更喜欢构建自己的解决方案，而不是使用第三方解决方案。构建自己解决方案的主要原因是为了获得更多对功能和未来增强的控制。然而，使用 WordPress
    的主要目的是利用现有功能开发快速、低成本的解决方案。很明显，在您的开发生涯中，您必须在某些时候处理自定义第三方插件。这些第三方插件是为了提供标准解决方案来解决常见问题而开发的。因此，这些插件不会完全符合大多数网站的需求。通常，我们必须通过添加、更改或删除功能来适应这些插件。在本节中，我们将通过示例场景来探讨插件自定义的技术和实现。
- en: Techniques for customizing third-party plugins
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义第三方插件的技术
- en: As with themes, plugins consists of various types of common customization's.
    Most site owners and developers misunderstand the meaning of plugin customization.
    Often, they think of it as a process that completely changes the plugin to suit
    the needs of your site. However, we may only need a few style changes as the customization.
    Sometime,s we have quicker and simple ways to customize plugins compared to using
    advanced processes. So, it's important to understand the different types of customization's
    and techniques for implementing them. Let's go through some of the common types
    of customization's.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像主题一样，插件由各种类型的常见自定义组成。大多数网站所有者和开发者误解了插件自定义的含义。他们经常认为这是一个完全改变插件以适应网站需求的过程。然而，我们可能只需要进行一些样式更改作为自定义。有时，与使用高级过程相比，我们有更快、更简单的方式来自定义插件。因此，了解不同类型的自定义及其实现技术非常重要。让我们来看看一些常见的自定义类型。
- en: Customizing look and feel using styles
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式自定义外观和感觉
- en: 'This is one of the frequently used customization''s where you need all plugins
    to match the styles of the theme. We have three ways of applying style customization''s
    for a plugin:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常用的自定义，需要所有插件与主题的样式相匹配。我们有三种方法来为插件应用样式自定义：
- en: '**Using theme styles files**: We can add the styles to the `style.cs` file
    of theme theme and override the plugin styles. This method should be only used
    in the child theme, when there are minor style changes to the plugin.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用主题样式文件**：我们可以将样式添加到主题的 `style.cs` 文件中，并覆盖插件样式。这种方法应仅用于子主题，当对插件进行少量样式更改时。'
- en: '**Using a custom CSS plugin**: There are many existing CSS plugins that allows
    us to add dynamic custom styles to various parts of the site without needing to
    create CSS files. These plugins provide a settings section, where we can add the
    dynamic CSS to be stored in the database and loaded to the site. This technique
    can be used for minor style customizations of many plugins.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自定义CSS插件**：有许多现有的CSS插件允许我们在不需要创建CSS文件的情况下，向网站的各个部分添加动态自定义样式。这些插件提供了一个设置部分，我们可以在此处添加要存储在数据库中并加载到网站上的动态CSS。这种技术可用于许多插件的细微样式自定义。'
- en: '**Using an addon plugin**: This is the recommended method to keep the styles
    changes independent from other plugins. In this method, we have to create a simple
    addon plugin and include a new CSS file. Then, we can override the plugin styles
    by using new styles for the same CSS classes. We have to use the dependency parameter
    of the `wp_register_style` function to include the plugin CSS file as a dependency,
    and load our CSS file after loading the plugin CSS file.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用插件插件**：这是将样式更改与其他插件独立保持的推荐方法。在此方法中，我们必须创建一个简单的插件插件并包含一个新的CSS文件。然后，我们可以通过为新CSS类使用新样式来覆盖插件样式。我们必须使用`wp_register_style`函数的依赖参数将插件CSS文件作为依赖项包含，并在加载插件CSS文件之后加载我们的CSS文件。'
- en: These are the common methods for changing the look and feel of a plugin. However,
    some plugins may provide you with a setting to add a dynamic plugin-specific CSS
    or settings to adjust the styles of different parts by modifying values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是更改插件外观和感觉的常见方法。然而，某些插件可能提供设置以添加动态插件特定CSS或通过修改值调整不同部分的样式。
- en: Customizing the features with hooks
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用钩子自定义功能
- en: In the beginning of this chapter, we have seen that the execution of hooks isn't
    always trivial. WordPress is using hooks all over the place, and this can sometimes
    make things complex. However, in plugin customization, this solution helps a lot,
    and we will see the benefit of using such a solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了钩子的执行并不总是简单的。WordPress到处都在使用钩子，这有时会使事情变得复杂。然而，在插件自定义中，这种解决方案非常有帮助，我们将看到使用这种解决方案的好处。
- en: We may have to use different plugins every day. So, it's impossible to learn
    each and every feature of the plugins we us on different projects. Instead, we
    can look for files or classes that implement the customized feature. Then, we
    can search for possible hooks that supports our customization. Once the necessary
    hooks are found, we implement them based on the guidelines. Implementing a hook
    makes sure that the complete process for the feature is executed. If hooks were
    not available, we have to go through complete plugin files and classes to identify
    the location for the customization's. Also, we have to go through follow-up code
    to check if it affects our customization or possible future modifications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能每天都要使用不同的插件。因此，学习我们在不同项目中使用的每个插件的每个功能是不可能的。相反，我们可以寻找实现自定义功能的文件或类。然后，我们可以搜索支持我们自定义的可能钩子。一旦找到必要的钩子，我们就可以根据指南实现它们。实现钩子确保了功能完整过程的执行。如果没有钩子，我们必须遍历整个插件文件和类来识别自定义的位置。此外，我们还需要遍历后续代码以检查它是否会影响我们的自定义或可能的未来修改。
- en: 'Let''s consider an example from a popular WooCommerce plugin. Assume we want
    to execute certain code after the user completes product payment. So, we can just
    search for a payment success hook and its implementation. WooCommerce executes
    the `woocommerce_payment_complete` action after the payment. Therefore, we can
    implement it using the following code to execute any kind of custom code on completion
    of the payment:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个来自流行WooCommerce插件的例子。假设我们想在用户完成产品支付后执行某些代码。因此，我们只需搜索支付成功钩子和其实施。WooCommerce在支付后执行`woocommerce_payment_complete`动作。因此，我们可以使用以下代码在支付完成后执行任何类型的自定义代码：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, within few lines of code, we have customized WooCommerce without
    spending too much time or getting in-depth knowledge of WooCommerce. Let''s assume
    there are no such hooks in WooCommerce. In such a case, first we have to find
    the `WC_Order` class and the `payment_complete` function used to handle the payment
    process. Then, we have to go through each and every line of code within the `payment_complete`
    function to understand the location for the completion of payment. You can already
    see the difficulty in the second process compared to the method of using hooks.
    So, we should always look for possible hooks to customize the plugins. There are
    two types of feature customization''s in plugin development:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在短短几行代码内，我们就已经定制了 WooCommerce，而没有花费太多时间或深入理解 WooCommerce。假设 WooCommerce
    中没有这样的钩子。在这种情况下，我们首先必须找到用于处理支付过程的 `WC_Order` 类和 `payment_complete` 函数。然后，我们必须逐行检查
    `payment_complete` 函数中的代码，以了解支付完成的定位。您已经可以看到，与使用钩子的方法相比，第二个过程存在难度。因此，我们应该始终寻找可能的钩子来定制插件。在插件开发中，有两种类型的特性定制：
- en: '**Customizing existing features**: Sometimes, we want to change or remove the
    existing features of a plugin. In such cases, we can implement an existing hook
    and change existing data or settings using the parameters passed to the function.
    Sometimes, we may want to go one step further by completely changing a feature
    with our own implementation. In such a case, we can remove the existing hook using
    the built-in `remove_action` or `remove_filter` functions. Then, we add the same
    hook with our own implementation.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制现有功能**：有时，我们想要更改或删除插件中的现有功能。在这种情况下，我们可以实现现有的钩子，并使用传递给函数的参数更改现有数据或设置。有时，我们可能想要更进一步，通过我们自己的实现完全更改一个功能。在这种情况下，我们可以使用内置的
    `remove_action` 或 `remove_filter` 函数删除现有的钩子。然后，我们添加具有我们自己的实现的相同钩子。'
- en: '**Adding new features**: In customization''s, a high percentage of tasks are
    involved in adding new features, compared to modifying existing features. In this
    method, we implement the existing hooks similar to the previous section. However,
    we use our own code and add new features on top of existing features, rather than
    modifying the existing ones.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新功能**：在定制中，与修改现有功能相比，涉及添加新功能的任务占很大比例。在此方法中，我们实现现有的钩子类似于上一节，但我们使用自己的代码，在现有功能之上添加新功能，而不是修改现有功能。'
- en: We discussed different types of customization's in plugins. In the next section,
    we are going to customize a plugin by implementing a real-world requirement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了插件中不同类型的定制。在下一节中，我们将通过实现一个现实世界的需求来定制一个插件。
- en: Building the WooCommerce product file manager
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建WooCommerce产品文件管理器
- en: The process of changing or adding a new feature using hooks is the most common
    type of customization for third-party plugins. These hooks allow us to build advanced
    features without spending much time. In this section, we are going to implement
    a real-world use case to understand the hook-based customization process in detail.
    So, we have chosen to customize WooCommerce.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用钩子更改或添加新功能的过程是第三方插件中最常见的定制类型。这些钩子允许我们在不花费太多时间的情况下构建高级功能。在本节中，我们将实现一个现实世界的用例，以详细了解基于钩子的定制过程。因此，我们选择了定制
    WooCommerce。
- en: Assume we want to provide files related to each WooCommerce product. These files
    may contain product specifications, user guides, or any information related to
    the product. So, we need a way to upload these files while creating or editing
    a product. Then, we have to list them in the frontend product page as a separate
    tab. This might seem like an uphill task for developers not familiar with WooCommerce.
    However, the implementation is quite simple once we find out the necessary WooCommerce
    hooks. Also, another purpose of this implementation is to reuse the code from
    the post attachments plugin and learn the use of AJAX, instead of normal form
    submissions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要提供与每个 WooCommerce 产品相关的文件。这些文件可能包含产品规格、用户指南或与产品相关的任何信息。因此，我们需要一种方法在创建或编辑产品时上传这些文件。然后，我们必须在前端产品页面上将它们列出来作为一个单独的标签页。这可能对不熟悉
    WooCommerce 的开发者来说是一项艰巨的任务。然而，一旦我们找到了必要的 WooCommerce 钩子，实现起来就相当简单了。此外，这种实现的另一个目的是重用来自帖子附件插件的代码，并学习
    AJAX 的使用，而不是正常的表单提交。
- en: 'Let''s start the implementation by creating a new plugin called **WQWPF Product
    Files** with the same process. You can find the plugin files inside the source
    codes directory for this chapter. Consider the initial code for the plugin:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 **WQWPF 产品文件** 的新插件开始实施，这个过程与之前相同。你可以在这个章节的源代码目录中找到这个插件的文件。考虑插件的初始代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The initial part of the code is similar to the code we used in WPQPA Post Attachments
    plugin, with the exception of removing the `file_name` column from the custom
    table for product files. This will be an addon for WooCommerce and hence we need
    to check whether WooCommerce is activated before executing any addon functions.
    Therefore, we use the `plugins_loaded` action to check the availability of `WooCommerce`
    class. We can use constants, classes, or functions to check the availability of
    a core plugin. When `WooCommerce` class is available, we add all the actions and
    filters related to the addon, so that they are executed only when `WooCommerce`
    is available. Now, we can start building the required functionalities for customization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的初始部分与我们在 WPQPA Post Attachments 插件中使用的代码类似，只是从产品文件的定制表中移除了 `file_name` 列。这将是一个
    WooCommerce 的附加组件，因此我们需要在执行任何附加功能之前检查 WooCommerce 是否已激活。因此，我们使用 `plugins_loaded`
    动作来检查 `WooCommerce` 类的可用性。我们可以使用常量、类或函数来检查核心插件的可用性。当 `WooCommerce` 类可用时，我们添加所有与附加组件相关的动作和过滤器，以确保它们仅在
    `WooCommerce` 可用的情况下执行。现在，我们可以开始构建所需的定制功能。
- en: Adding the file upload field to WooCommerce products
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件上传字段添加到 WooCommerce 产品中
- en: 'The first step in the development process is to provide an interface to let
    administrators upload files to products. We can implement this by using the metabox
    technique we used while building the post attachments plugin. However, we are
    trying to understand plugin customization and hence we are going to integrate
    this feature into WooCommerce. In the WooCommerce product creation screen, we
    can find a meta box called Product Data with various tabs such as General, Inventory,
    Shipping and so on. We are going to add a new tab to the meta box as Product Files.
    First, we have to look for actions or filters that let us modify the Product Data
    tabs. You can find a filter called `woocommerce_product_data_tabs` for customizing
    the tabs. Let''s use the following code to add a new tab using this filter:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程中的第一步是为管理员提供一个接口，让他们能够将文件上传到产品中。我们可以通过使用我们在构建帖子附件插件时使用的元框技术来实现这一点。然而，我们正在尝试理解插件定制，因此我们将把这个功能集成到
    WooCommerce 中。在 WooCommerce 产品创建屏幕中，我们可以找到一个名为“产品数据”的元框，其中包含各种标签页，如常规、库存、运输等。我们打算在元框中添加一个新的标签页，称为“产品文件”。首先，我们必须寻找允许我们修改“产品数据”标签页的动作或过滤器。你可以找到一个名为
    `woocommerce_product_data_tabs` 的过滤器来定制标签页。让我们使用以下代码通过这个过滤器添加一个新的标签页：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This filter is dependent on WooCommerce and hence the `add_filter` line should
    be placed inside the `wqwpf_plugins_loaded_action` function. The existing tabs
    are passed as a parameter to the callback function of this filter. We add a new
    tab with a unique key and assign the necessary options. The `target` setting contains
    the ID of the HTML element that is used to display the content for this tab. The
    tab content will be added in next stage. The `class` setting defines an array
    of classes assigned to this tab. Here, we have used `show_if_simple` as the class.
    So, our tab will be only visible for Simple WooCommerce products. We need to add
    more classes in case we want to make the tab available for other product types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器依赖于 WooCommerce，因此 `add_filter` 行应该放在 `wqwpf_plugins_loaded_action` 函数内部。现有的标签页作为参数传递给这个过滤器的回调函数。我们添加一个带有唯一键的新标签页，并分配必要的选项。`target`
    设置包含用于显示此标签页内容的 HTML 元素的 ID。标签页内容将在下一阶段添加。`class` 设置定义了一个分配给此标签页的类数组。在这里，我们使用了
    `show_if_simple` 作为类。因此，我们的标签页将仅对简单 WooCommerce 产品可见。如果我们想使标签页对其他产品类型可用，我们需要添加更多的类。
- en: In this scenario, we added a new tab. We can also use this filter to remove
    existing tabs by using the `unset` function on `$tab` array elements, or change
    the settings of existing tabs by using the proper array key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们添加了一个新的标签页。我们也可以使用这个过滤器通过在 `$tab` 数组元素上使用 `unset` 函数来删除现有的标签页，或者通过使用适当的数组键来更改现有标签页的设置。
- en: 'The next step is adding a file field to the tab for uploading files. We can
    find another action hook called `woocommerce_product_data_panels` for adding tab
    content. Let''s use it to add the file field, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在标签页中添加一个文件字段以上传文件。我们可以找到一个名为 `woocommerce_product_data_panels` 的另一个动作钩子来添加标签页内容。让我们使用它来添加文件字段，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, we have added a file field to upload files, a button to initialize
    the upload process, and a hidden field to keep the nonce value. The structure
    of the HTML is copied from the other available tabs. The most important part is
    understanding how this tab content connects with the tab we created earlier. We
    have used `wqwpf_file_options` as the ID of the main container for the tab. We
    used the same ID as the `target` setting for our new tab. So, once the tab is
    clicked, WooCommerce will use the target setting to find the container and display
    it to the user. The following screen previews the new tab after using the custom
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们添加了一个文件字段用于上传文件，一个按钮用于初始化上传过程，以及一个隐藏字段以保持 nonce 值。HTML 结构是从其他可用的标签中复制的。最重要的部分是理解这个标签内容是如何与之前创建的标签连接的。我们使用了
    `wqwpf_file_options` 作为标签主要容器的 ID。我们使用了与我们的新标签的 `target` 设置相同的 ID。因此，一旦点击标签，WooCommerce
    将使用目标设置来查找容器并向用户显示。以下屏幕截图显示了使用自定义代码后的新标签：
- en: '![](img/5feef139-31d1-42b0-bfe8-cc388e892f0d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5feef139-31d1-42b0-bfe8-cc388e892f0d.png)'
- en: The new tab for Product Files is added between the Inventory and Shipping tabs.
    Now, we are ready to start uploading files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 产品文件的新标签页添加在库存和运输标签之间。现在，我们准备好开始上传文件。
- en: Adding scripts for uploading files
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加上传文件的脚本
- en: 'In [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building Custom
    Modules with Plugin Development*, we created a plugin to upload attachments to
    posts. However, we had to select a file and upload files one by one while updating
    the post for each file. This is not ideal in situations where we have many files
    to be uploaded. Instead, we have to use AJAX and let the user upload multiple
    files without refreshing the browser. Before moving into the process of uploading
    files, we need to add the necessary scripts to the plugin. First, you have to
    create a new directory inside `wpquick-woo-product-files` as `js`, and create
    a new file called `wqwpf-admin.js`. Next, we can add the script to the plugins,
    as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml)，“使用插件开发构建自定义模块”，我们创建了一个插件来上传帖子附件。然而，在更新每个文件时，我们必须选择文件并逐个上传文件。在需要上传许多文件的情况下，这并不理想。相反，我们必须使用
    AJAX 并允许用户在不刷新浏览器的情况下上传多个文件。在进入上传文件的过程之前，我们需要将必要的脚本添加到插件中。首先，你必须在 `wpquick-woo-product-files`
    内部创建一个名为 `js` 的新目录，并创建一个名为 `wqwpf-admin.js` 的新文件。接下来，我们可以将脚本添加到插件中，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use the preceding code to learn some of the important techniques in
    script loading. Let''s list the important parts of script loading:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的代码来学习脚本加载的一些重要技术。让我们列出脚本加载的重要部分：
- en: '**Registering and enqueuing scripts**: Until this point, we only learned how
    to include CSS files. So, we can now move onto loading scripts with the `wp_register_script`
    function. Here, we are including a script in admin side and hence we have to use
    the `admin_enqueue_scripts` action to use a callback function for including scripts.
    The first line of the preceding code should be placed inside the `wqwpf_plugins_loaded_action`
    function, as it depends on the existence of WooCommerce. Inside the callback function,
    we can use the `wp_register_script` function to register a custom script for WordPress.
    The parameters of this function include a unique key for the script, a path to
    the script, and dependent script files. The script is only registered at this
    stage and not included in the browser. Then, we use `wp_enqueue_script` wherever
    we want to include the script to the browser using the key used in script registration.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册和队列脚本**：直到这一点，我们只学习了如何包含 CSS 文件。因此，我们现在可以使用 `wp_register_script` 函数来加载脚本。在这里，我们正在包含管理端的脚本，因此我们必须使用
    `admin_enqueue_scripts` 动作来使用回调函数包含脚本。前面代码的第一行应放置在 `wqwpf_plugins_loaded_action`
    函数内部，因为它依赖于 WooCommerce 的存在。在回调函数内部，我们可以使用 `wp_register_script` 函数为 WordPress
    注册一个自定义脚本。此函数的参数包括脚本的唯一键、脚本的路径和依赖脚本文件。脚本仅在此时注册，而不包含在浏览器中。然后，我们使用 `wp_enqueue_script`
    在任何我们想要将脚本包含到浏览器中的地方使用脚本注册时使用的键。'
- en: '**Defining script dependencies**: We can define dependent scripts using the
    third parameter of the `wp_register_script` function. In this scenario, our script
    is coded using **jQuery**, and hence it''s a dependency. So, we add jQuery as
    the key to dependency array. WordPress has a set of built-in scripts with specific
    keys. We need to use these keys without loading these libraries from our own plugins
    or external sources. The list of available script libraries can be found at [https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts](https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts).
    You can use the key in the Handle column to load these dependencies. Once we define
    `script 2` as a dependency of `script 1`, the second script will be loaded before
    the first script. Apart from using core script files, we can also use custom script
    files as dependencies. Consider the following line of code:In this code, we are
    registering a script of another plugin with **jQuery** and `wpwpf_admin_js` scripts.
    So, both of these files will be loaded before loading the script with `upme_admin_js`
    as the handle.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义脚本依赖**：我们可以使用`wp_register_script`函数的第三个参数来定义依赖脚本。在这种情况下，我们的脚本是用**jQuery**编写的，因此它是一个依赖项。所以，我们将jQuery作为依赖数组的键添加。WordPress有一组内置脚本，具有特定的键。我们需要使用这些键，而无需从我们自己的插件或外部来源加载这些库。可用的脚本库列表可以在[https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts](https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts)找到。您可以使用“处理”列中的键来加载这些依赖项。一旦我们将`script
    2`定义为`script 1`的依赖项，第二个脚本将在第一个脚本之前加载。除了使用核心脚本文件外，我们还可以使用自定义脚本文件作为依赖项。考虑以下代码行：在这个代码中，我们正在注册另一个插件的脚本，该脚本使用**jQuery**和`wpwpf_admin_js`脚本。因此，这两个文件将在加载具有`upme_admin_js`作为处理的脚本之前加载。'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Localizing scripts**: Sometimes, we need to add necessary settings and dynamic
    data to specific scripts. WordPress allows us to add such data by using the `wp_localize_script`
    function. This function uses three parameters, starting with script handle, variable
    name, and the data. Once used, these data will be added inline to the browser,
    before loading the script file. Therefore, these data will be accessible within
    the specified script and the other scripts loaded after that defined script.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地化脚本**：有时，我们需要向特定脚本添加必要的设置和动态数据。WordPress允许我们通过使用`wp_localize_script`函数来添加此类数据。此函数使用三个参数，从脚本处理程序开始，变量名称和数据。一旦使用，这些数据将被添加到浏览器中，在加载脚本文件之前。因此，这些数据将在指定的脚本以及之后加载的脚本中可用。'
- en: In this implementation, we are going to use AJAX, and hence we add the AJAX
    url to the script by using the `admin_url('admin-ajax.php')` function. More about
    AJAX will be discussed later in this section. Next, we add the necessary data
    using preferred array keys. Here, we are only adding messages as an array. We
    also add a nonce value to the script to verify the AJAX request from the server
    side. Once the page is loaded, you can use View Source option to check this data
    loaded before the `wqwpf_admin_js` script. Now, we have completed the script loading
    process and hence we can move into uploading product files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们将使用AJAX，因此我们通过使用`admin_url('admin-ajax.php')`函数将AJAX URL添加到脚本中。关于AJAX的更多内容将在本节的后面讨论。接下来，我们使用首选数组键添加必要的数据。在这里，我们只添加消息作为数组。我们还向脚本添加了一个nonce值，以从服务器端验证AJAX请求。一旦页面加载，您可以使用“查看源代码”选项来检查在`wqwpf_admin_js`脚本之前加载的这些数据。现在，我们已经完成了脚本加载过程，因此我们可以进入上传产品文件。
- en: Uploading files to products
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件上传到产品
- en: 'In this section, we are going to upload files for products using AJAX requests.
    Before diving into AJAX, we need to complete the initial script with necessary
    data retrieval and validation. Add the following code to the `wqwpf-admin.js`
    file of our plugin:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用AJAX请求上传产品文件。在深入研究AJAX之前，我们需要完成初始脚本，包括必要的数据检索和验证。将以下代码添加到我们插件的`wqwpf-admin.js`文件中：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s what this code does:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: First, we define a callback function for the `click` event of the Upload button,
    within the jQuery `ready` function.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在jQuery的`ready`函数中为上传按钮的`click`事件定义一个回调函数。
- en: Inside the `click` event, we need to capture the file and the post ID. We can't
    add our own form as the metabox is inside the WordPress form for creating posts.
    So, we use the form with the ID **post**, to capture the values of form fields.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`click`事件内部，我们需要捕获文件和帖子ID。我们不能添加自己的表单，因为元框位于WordPress创建帖子的表单内。因此，我们使用具有ID**post**的表单来捕获表单字段的值。
- en: Next, we retrieve the container element used to display messages and reset the
    CSS classes.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检索用于显示消息的容器元素并重置 CSS 类。
- en: Then, we start the validation process for fields. Here, we have only filed field
    and hence checking for empty value is the only required validation.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们开始对字段进行验证过程。在这里，我们只有字段字段，因此检查空值是唯一需要的验证。
- en: Finally, we check for any errors and display the error message by adding the
    necessary CSS classes and enabling the message container.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查是否有任何错误，并通过添加必要的 CSS 类和启用消息容器来显示错误消息。
- en: 'In the previous section, we used the `wp_localize_script` function to add the
    data to the scripts. In this section, we are using it to add the error message
    using the following line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 `wp_localize_script` 函数将数据添加到脚本中。在本节中，我们使用以下行来添加错误消息：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this line, `WQWPFAdmin` is the variable name we used earlier and `Messages`
    is the sub-key of the main array. The `fileRequired` option in the `Messages`
    array will contain the actual message. Similarly, we can access the other data
    using respective keys. Now, we need to implement the AJAX request when the validation
    is completed without errors. Before that, we are going to have a brief introduction
    to AJAX.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，`WQWPFAdmin` 是我们之前使用的变量名，而 `Messages` 是主数组的子键。`Messages` 数组中的 `fileRequired`
    选项将包含实际的消息。同样，我们可以使用相应的键来访问其他数据。现在，我们需要在验证无错误完成时实现 AJAX 请求。在此之前，我们将简要介绍 AJAX。
- en: Introduction to AJAX in WordPress
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress 中 AJAX 的介绍
- en: AJAX is an abbreviation for Asynchronous JavaScript And XML. This technology
    allows us to sent and retrieve data without refreshing the browser. So, the execution
    of repetitive tasks such as multiple file uploading can be simplified by using
    AJAX. Usually, we use a direct URL to execute AJAX requests. However, WordPress
    offers a built-in interface for executing AJAX requests and it's recommended to
    use this technique without using our own AJAX handlers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 是异步 JavaScript 和 XML 的缩写。这项技术允许我们在不刷新浏览器的情况下发送和检索数据。因此，使用 AJAX 可以简化重复任务，如多次文件上传。通常，我们使用直接
    URL 来执行 AJAX 请求。然而，WordPress 提供了一个内置接口来执行 AJAX 请求，建议使用这种技术而不使用我们自己的 AJAX 处理器。
- en: 'WordPress uses a file called `admin-ajax.php` for handling requests, and the
    file is located inside the `wp-admin` directory. This file contains the necessary
    code for built-in core AJAX requests as well as code for supporting custom requests
    through *actions*. The action is responsible for handling the AJAX request and
    providing the output. Let''s consider the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 使用一个名为 `admin-ajax.php` 的文件来处理请求，该文件位于 `wp-admin` 目录中。此文件包含内置核心 AJAX
    请求的必要代码，以及通过 *actions* 支持自定义请求的代码。动作负责处理 AJAX 请求并提供输出。让我们考虑以下代码：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code defines how we should use AJAX in WordPress. Each different
    AJAX request has an action name. We have to use the `wp_ajax_{action name}` or
    `wp_ajax_nopriv_{action name}` action to define the handling function for each
    request. The action with the `wp_ajax` prefix is used for requests when the user
    is already logged into the site. The action with `wp_ajax_nopriv` is used for
    guest users of the site. So, you have to define one or both of these actions depending
    on who is allowed to execute the request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了我们在 WordPress 中如何使用 AJAX。每个不同的 AJAX 请求都有一个动作名称。我们必须使用 `wp_ajax_{action
    name}` 或 `wp_ajax_nopriv_{action name}` 动作来定义每个请求的处理函数。带有 `wp_ajax` 前缀的动作用于用户已经登录到网站时的请求。带有
    `wp_ajax_nopriv` 前缀的动作用于网站的访客用户。因此，你必须根据谁被允许执行请求来定义一个或两个这些动作。
- en: 'Now, we have the basic knowledge about AJAX in WordPress and the method for
    handling the request from the server side. So, we can get back to the file uploading
    process by implementing the AJAX call to upload files. The following code should
    be added to the `else` statement of the `click` event in the `wqwpf-admin.js`
    file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 WordPress 中 AJAX 的基本知识以及从服务器端处理请求的方法。因此，我们可以通过实现上传文件的 AJAX 调用来回到文件上传过程。以下代码应添加到
    `wqwpf-admin.js` 文件中 `click` 事件的 `else` 语句：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s what this code does:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这段代码的功能：
- en: The first two lines resets message container and assigns form object to a variable.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前两行重置消息容器并将表单对象分配给一个变量。
- en: Then, we use the `WQWPFAdmin` variable to retrieve the WordPress AJAX URL and
    assign a custom parameter called action with a custom action name. This action
    name will be used with the `wp_ajax` and `wp_ajax_nopriv` actions to connect the
    client-side request with the server side.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`WQWPFAdmin`变量检索WordPress AJAX URL并分配一个名为action的自定义参数，该参数将用于与`wp_ajax`和`wp_ajax_nopriv`操作连接客户端请求与服务器端。
- en: Next, we create a new `FormData` object to sent the data to the server. We can
    assign the necessary data to the `FormData` object by using the `append` function
    with key-value pairs. Here, we have added a file, nonce value, and post ID as
    form data.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的`FormData`对象以将数据发送到服务器。我们可以通过使用带有键值对的`append`函数将必要的数据分配给`FormData`对象。在这里，我们添加了一个文件、nonce值和帖子ID作为表单数据。
- en: The next step is configuring the AJAX request with the jQuery `ajax` function.
    You should be familiar with the settings of the AJAX function. Now, the request
    is executed from client side whenever the user clicks the Upload button.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用jQuery `ajax`函数配置AJAX请求。您应该熟悉AJAX函数的设置。现在，当用户点击上传按钮时，请求从客户端执行。
- en: Finally, we use the success event of the `ajax` function to display the resulting
    message, reset the fields, and display a list of files uploaded to the product.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`ajax`函数的成功事件来显示结果消息、重置字段并显示上传到产品的文件列表。
- en: 'Now, we can complete the process by handling the server-side function for uploads.
    Let''s consider the following implementation with WordPress AJAX actions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过处理上传的服务器端函数来完成此过程。让我们考虑以下使用WordPress AJAX操作的实现：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Only administrators are allowed to upload files to products, and hence we only
    use the action with the `wp_ajax` prefix for logged-in users. Here''s what this
    code does:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 只有管理员可以上传文件到产品，因此我们只为登录用户使用带有`wp_ajax`前缀的操作。以下是此代码的功能：
- en: First, we have to capture the `POST` request data for post ID and nonce.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须捕获帖子ID和nonce的`POST`请求数据。
- en: Then, we use the `check_ajax_referer` function to check the nonce values. The
    first parameter of this function uses the action we defined inside the `wqwpf_admin_load_scripts`
    function by calling the `wp_create_nonce` function. The second and third parameters
    are used respectively for the nonce value key in the POST request and whether
    to `die` if nonce is invalid. We have set the third parameter as `false` since
    we want to display a custom error.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`check_ajax_referer`函数检查nonce值。此函数的第一个参数使用我们通过调用`wp_create_nonce`函数在`wqwpf_admin_load_scripts`函数内部定义的操作。第二个和第三个参数分别用于POST请求中的nonce值键以及如果nonce无效是否`die`。我们将第三个参数设置为`false`，因为我们想显示自定义错误。
- en: Once nonce is verified, we use the `wqwpf_process_file_upload` function to upload
    the files and get the results. The `wqwpf_process_file_upload` function is similar
    to the function we used in the post attachments plugin, and hence you can check
    the source code for this chapter to go through the implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证nonce，我们就使用`wqwpf_process_file_upload`函数上传文件并获取结果。`wqwpf_process_file_upload`函数与我们用于帖子附件插件中的函数类似，因此您可以检查本章的源代码以了解实现。
- en: Then, we save the file details to the custom table, similar to the post attachments
    plugin. Then, we retrieve the HTML with the list of uploaded files using the `wqwpf_product_file_list` function. The
    implementation of this function is similar to the one we used in post attachments
    plugin in [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building Custom
    Modules with Plugin Development*. Therefore, we are not going to include and discuss
    the source code. You can find the implementation of this function within the source
    codes for this chapter.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件详细信息保存到自定义表中，类似于帖子附件插件。然后，我们使用`wqwpf_product_file_list`函数检索包含上传文件的HTML列表。此函数的实现与我们用于帖子附件插件中的[第4章](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml)，*使用插件开发构建自定义模块*中使用的实现类似。因此，我们不会包括并讨论源代码。您可以在本章的源代码中找到此函数的实现。
- en: Finally, we return the output as a JSON-encoded array with a message, status,
    and the HTML for the list of uploaded files.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将输出作为带有消息、状态和上传文件列表HTML的JSON编码数组返回。
- en: Displaying uploaded files in products
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在产品中显示上传的文件
- en: 'In the last section, we displayed the list of files in the product edit screen
    and updated it each time we uploaded a new file using AJAX. Now, we need to complete
    the implementation by displaying the files list in the frontend product page as
    a new tab. We already used a common function to generate the list of files for
    a product, and hence it''s just a matter of using it within a product page tab.
    Let''s use the following code to display the file list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在产品编辑屏幕中显示了文件列表，并且每次我们使用 AJAX 上传新文件时都会更新它。现在，我们需要通过在前端产品页面以新标签页的形式显示文件列表来完成实现。我们已经使用了一个通用的函数来生成产品的文件列表，因此这只是在产品页面标签中使用它的问题。让我们使用以下代码来显示文件列表：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: WooCommerce provides a filter called `woocommerce_product_tabs` to add, modify,
    or remove tabs from the frontend product page. The existing tab details are passed
    as a parameter to this function. So, we add a new tab by using a unique key and
    assigning necessary settings. We have used a **Title** for the tab and custom
    callback function called `wqwpf_product_files_tab_content`. The **priority** setting
    defines the order of the tab within the product page. You can check the priority
    of existing tabs by executing a `var_dump` on the `$tabs` array and assigning
    the priority based on where you want to display the tab. Inside the callback function,
    we use the global `$post` object to retrieve the post ID and pass it to the `wqwpf_product_file_list`
    function to generate the files list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: WooCommerce 提供了一个名为 `woocommerce_product_tabs` 的过滤器，用于添加、修改或从前端产品页面删除标签页。现有的标签页详细信息作为参数传递给此函数。因此，我们通过使用唯一键和分配必要的设置来添加一个新标签页。我们为标签使用了一个**标题**，并自定义了一个名为
    `wqwpf_product_files_tab_content` 的回调函数。**优先级**设置定义了标签在产品页面中的顺序。您可以通过在 `$tabs`
    数组上执行 `var_dump` 并根据您想要显示标签的位置分配优先级来检查现有标签的优先级。在回调函数内部，我们使用全局 `$post` 对象来检索帖子
    ID，并将其传递给 `wqwpf_product_file_list` 函数以生成文件列表。
- en: 'Now, we have completed the customization and added a new feature for uploading
    and displaying files for WooCommerce products. The product page will look similar
    to the following screen with the product files tab:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了定制，并为上传和显示 WooCommerce 产品的文件添加了一个新功能。产品页面将类似于以下屏幕，其中包含产品文件标签页：
- en: '![](img/5b437d1d-51c9-49eb-9541-a0ae7bd9ec59.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b437d1d-51c9-49eb-9541-a0ae7bd9ec59.png)'
- en: In this chapter, we have omitted the code and explanation for file downloading,
    uploading, and listing, as we used the same functions of the post attachments
    plugin, with minor modification. Make sure to check the implementation of these
    functions within the source code for this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们省略了文件下载、上传和列表的代码和解释，因为我们使用了帖子附件插件的相同功能，只是做了轻微的修改。请确保检查本章源代码中这些函数的实现。
- en: Integrating multiple plugins for a continuous workflow
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成多个插件以实现连续的工作流程
- en: The purpose of building plugins is to provide independent feature or set of
    features as a reusable module. So, most third-party plugins are designed to provide
    solutions to a specific feature and related sub-features. We rarely find third-party
    plugins that can power an entire system. BuddyPress is one of the few plugins
    that offers many of the features of a complete system such as a social network.
    In the previous section, we discussed the need for customizing third-party plugins.
    Here, we have to move one step further by understanding how to customize and integrate
    multiple plugins.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构建插件的目的在于提供独立的功能或功能集作为可重用的模块。因此，大多数第三方插件都是设计来提供针对特定功能及其相关子功能解决方案的。我们很少找到能够驱动整个系统的第三方插件。BuddyPress
    是少数几个提供完整系统许多功能的插件之一，如社交网络。在上一节中，我们讨论了定制第三方插件的需求。在这里，我们必须进一步了解如何定制和集成多个插件。
- en: Types of plugin integrations
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件集成类型
- en: We can integrate two plugins or more using the WordPress hook system. However,
    there are different types of integrations depending on who is responsible for
    providing the integration. It's important to understand these integration types
    in order avoid or control the risks, when the integrated plugins change behavior.
    Let's take a look at the types of plugin integrations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 WordPress 钩子系统集成两个或更多插件。然而，根据谁负责提供集成，集成类型有所不同。了解这些集成类型很重要，以便在集成插件更改行为时避免或控制风险。让我们看看插件集成类型。
- en: Custom integrations
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义集成
- en: This method is used when there are no integrations between the two plugins.
    Therefore, each plugin is not aware of the existence of other plugin. This is
    the most common scenario in WordPress development, as we rarely find the necessary
    plugins integrating with the other plugins needed for our site. In such a scenario,
    we have to create an addon plugin by implementing the integrations with necessary
    plugins. In this process, we use the existing hooks or functions of the necessary
    plugins and connect them to work together for our requirements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个插件之间没有集成时，使用这种方法。因此，每个插件都不知道其他插件的存在。这在 WordPress 开发中是最常见的场景，因为我们很少找到必要的插件与我们的网站所需的插件集成。在这种情况下，我们必须通过实现与必要插件的集成来创建一个附加插件。在这个过程中，我们使用必要插件的现有钩子或函数，并将它们连接起来以满足我们的需求。
- en: There is a major limitation in this method as connecting more and more plugins
    increases the risks of breaking the site functionality. We have no control over
    the integrated plugins as they are developed by third-party developers. So, when
    implementing such integrations, we have to use the same plugin versions without
    updating, or be prepared to check the integration and apply necessary fixes on
    updates of each plugin. You will see many sites using custom integrations with
    fixed versions of the integrated plugins. This is not the ideal process as keeping
    fixed versions of plugins increases security risks. Therefore, you should develop
    integrations with minimum dependency with each plugin, and be prepared to alter
    the integration when necessary to be compatible with plugin updates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个主要限制，即连接越来越多的插件会增加破坏网站功能的风险。我们对集成插件没有控制权，因为它们是由第三方开发者开发的。因此，在实现此类集成时，我们必须使用相同的插件版本而不进行更新，或者准备好在更新每个插件的更新时检查集成并应用必要的修复。您将看到许多网站使用具有固定版本集成插件的定制集成。这不是理想的过程，因为保持插件的固定版本会增加安全风险。因此，您应该开发与每个插件最小依赖的集成，并准备好在必要时更改集成以兼容插件更新。
- en: One-sided integrations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单边积分
- en: 'In this method, one of the two plugins provides an integration with the other
    plugin. However, the second plugin is not aware of the existence or integration
    of the first plugin. We can find many existing plugins with this type of integration.
    The integration is implemented within one of the plugins or an addon of the plugin.
    Let''s take a look at some of the popular plugins with one-sided integrations
    with other plugins:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，两个插件中的一个是与其他插件进行集成的。然而，第二个插件并不知道第一个插件的存在或集成。我们可以找到许多具有这种集成类型的现有插件。集成是在插件或插件的附加组件中实现的。让我们看看一些具有与其他插件单边集成的流行插件：
- en: '**MyCred integration with WooCommerce**: MyCred is a point management system
    for WordPress and integrates with WooCommerce through the **Gateway** addon. The
    MyCred team is responsible for providing the integration and hence they will make
    sure the integration works with WooCommerce version updates. You can find more
    details about the integration at [https://mycred.me/add-ons/gateway/](https://mycred.me/add-ons/gateway/).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MyCred 与 WooCommerce 的集成**：MyCred 是一个用于 WordPress 的积分管理系统，并通过 **Gateway**
    附加组件与 WooCommerce 集成。MyCred 团队负责提供集成，因此他们将确保集成与 WooCommerce 版本更新兼容。您可以在 [https://mycred.me/add-ons/gateway/](https://mycred.me/add-ons/gateway/)
    找到有关集成的更多详细信息。'
- en: '**Easy Digital Downloads integration with Gravity Forms**: Easy Digital Downloads
    is a plugin used to sell digital products. This plugin integrates with the popular
    **Gravity Forms** plugin through an addon called **Gravity Forms checkout**. The
    Easy Digital Downloads team is responsible for providing the integration and hence
    they will make sure the integration works with Gravity Forms version updates.
    You can find more details about the integration at [https://easydigitaldownloads.com/downloads/gravity-forms-checkout/](https://easydigitaldownloads.com/downloads/gravity-forms-checkout/).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Easy Digital Downloads 与 Gravity Forms 的集成**：Easy Digital Downloads 是一个用于销售数字产品的插件。该插件通过名为
    **Gravity Forms checkout** 的附加组件与流行的 **Gravity Forms** 插件集成。Easy Digital Downloads
    团队负责提供集成，因此他们将确保集成与 Gravity Forms 版本更新兼容。您可以在 [https://easydigitaldownloads.com/downloads/gravity-forms-checkout/](https://easydigitaldownloads.com/downloads/gravity-forms-checkout/)
    找到有关集成的更多详细信息。'
- en: '**User Profiles Made Easy integration with WooCommerce**: User Profiles Made
    Easy is a frontend profile management system and provides a built-in integration
    with WooCommerce. In the previous two examples, integration was provided by a
    separate addon. In this scenario, integration is built into the plugin. The User
    Profiles Made Easy team is responsible for providing the integration, and hence
    they will make sure the integration works with WooCommerce version updates. You
    can find more details about the integration at [https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874](https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户资料简易集成 WooCommerce**：用户资料简易是一个前端资料管理系统，并提供了内置的 WooCommerce 集成。在前两个示例中，集成是由一个单独的插件提供的。在这种情况下，集成是内置在插件中的。用户资料简易团队负责提供集成，因此他们将确保集成与
    WooCommerce 版本更新兼容。您可以在[https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874](https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874)找到有关集成的更多详细信息。'
- en: As developers, we can use these kind of existing integrations with minor modifications.
    So, we can spend less time and avoid any risks compared to custom integration
    method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们可以使用这些现有的集成进行少量修改。因此，我们可以节省时间并避免与自定义集成方法相比的风险。
- en: Mutual integrations
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互集成
- en: In this method, integration is supported by both plugins. Therefore, both plugins
    are aware of the existence and integration of the other plugin. Usually, this
    is implemented through functions or APIs designed for the other plugins. The developers
    from both plugins agrees to keep the features in way that integrates with the
    other plugin. As developers, we can directly use these integrations as the functionality
    is tested by both plugins. The risk of such integrations is quite low and requires
    less time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，集成由两个插件共同支持。因此，两个插件都了解另一个插件的存在和集成。通常，这是通过为其他插件设计的函数或API实现的。两个插件的开发者同意以与另一个插件集成的形式保持功能。作为开发者，我们可以直接使用这些集成，因为功能已由两个插件测试。这种集成的风险相当低，所需时间较少。
- en: We looked at three common methods for integrations. We rarely find plugins with
    mutual integrations as it requires lot of effort from the developers of the two
    plugins. So, when a need for integration occurs, we have to check the availability
    of one-sided integrations, mainly through addons. You should always use the available
    integrations as they are used and tested by many users of that plugin. In scenarios
    where we can't find existing integrations, we have to use the custom integration
    process. In the custom integration process, we have to plan the solutions by reducing
    the impact on both plugins.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了三种常见的集成方法。我们很少找到具有相互集成的插件，因为这需要两个插件的开发者投入大量的努力。因此，当出现集成需求时，我们必须检查单方面集成的可用性，主要通过插件。你应该始终使用可用的集成，因为它们已被该插件的多位用户使用和测试。在找不到现有集成的场景中，我们必须使用自定义集成过程。在自定义集成过程中，我们必须通过减少对两个插件的影响来规划解决方案。
- en: Considerations in custom plugin integrations
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义插件集成时的注意事项
- en: The process of integrating plugins can be as simple as a few lines of code or
    as complex as thousands of lines of code. There are no recommended processes or
    techniques for integrating plugins. We have to find ways to connect plugins without
    affecting the other features or breaking the functionality on version upgrades.
    Let's take a look at some of the important things to be considered in the custom
    integration process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 插件集成的过程可能简单到只需要几行代码，也可能复杂到需要数千行代码。没有推荐的插件集成过程或技术。我们必须找到连接插件的方法，而不影响其他功能或破坏版本升级的功能。让我们看看在自定义集成过程中需要考虑的一些重要事项。
- en: Checking the feasibility of integration
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查集成的可行性
- en: This is the first step, where we explore the available hooks for integration.
    In the *Creating addons* section, we identified the limitations of the post attachments
    plugin due to lack of actions and filters. We might face similar situations in
    plugins integration, where the second plugin doesn't provide necessary hooks to
    integrate with the features of the first plugin. In such a case, our only option
    is to add custom hooks to one of the plugins. Even though it's not recommended
    and difficult to manage, developers use this method when there are no other alternatives.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一步，我们探索了可用于集成的可用钩子。在*创建插件*部分，我们确定了由于缺少操作和过滤器，帖子附件插件存在限制。在插件集成中，我们可能会遇到类似的情况，其中第二个插件没有提供必要的钩子来与第一个插件的功能集成。在这种情况下，我们唯一的选项是在其中一个插件中添加自定义钩子。尽管这不被推荐且难以管理，但开发人员在没有其他替代方案时使用这种方法。
- en: 'Assume that we use a frontend login plugin, and a content restriction plugin
    with a private page for each user. By default, the login plugin redirects the
    user to the backend profile after login. So, our integration requires us to redirect
    the user to the private page after login. We need to have at least one hook in
    the login plugin for modifying the redirection. Let''s assume we have the following
    filter in the login plugin to change the redirection URL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用一个前端登录插件，以及一个为每个用户都有一个私有页面的内容限制插件。默认情况下，登录插件在登录后将用户重定向到后端个人资料。因此，我们的集成需要我们在登录后重定向用户到私有页面。我们需要在登录插件中至少有一个钩子来修改重定向。让我们假设我们有一个以下过滤器在登录插件中更改重定向URL：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can use the following code in the content restriction plugin to modify
    the URL and integrate the two plugins:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在内容限制插件中使用以下代码来修改URL并集成两个插件：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The integration was possible due to the availability of the login redirect hook.
    So, we have to make sure necessary hooks exists and integration is feasible between
    two plugins.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 集成之所以可行，是因为登录重定向钩子的可用性。因此，我们必须确保必要的钩子存在，并且两个插件之间的集成是可行的。
- en: Identifying exact data changes and hooks
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别确切的数据更改和钩子
- en: In the integration process, usually we use the data from the first plugin in
    the second plugin or execute a certain feature of the second plugin when an event
    occurred in first plugin. The main problem is the consistency and intergrity of
    data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成过程中，通常我们使用第一个插件中的数据来在第二个插件中使用，或者在第一个插件中发生事件时执行第二个插件的一定功能。主要问题是数据的一致性和完整性。
- en: Assume that we use a frontend profile management plugin to capture and display
    the user details using custom fields. We also use WooCommerce to capture payments
    for the members. Let's say we want to integrate the two plugins to synchronize
    the user profile data with WooCommerce customer data. So, when updating profile
    details from the profile management plugin, we need to also update the WooCommerce
    customer data, and vice-versa. If the two plugins use different data formats for
    the same field, there is going to be a conflict. In such situations, we have to
    convert the data when switching between the two plugins.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用一个前端个人资料管理插件来捕获和显示用户详情，使用自定义字段。我们还使用WooCommerce来捕获会员的支付。假设我们想要集成这两个插件以同步用户个人资料数据与WooCommerce客户数据。因此，当从个人资料管理插件更新个人资料详细信息时，我们还需要更新WooCommerce客户数据，反之亦然。如果两个插件对同一字段使用不同的数据格式，将出现冲突。在这种情况下，我们必须在两个插件之间切换数据时转换数据。
- en: Also, the use of proper execution of hooks is important in integrations. Assume
    we have a user registrations plugin and a user groups plugin. The integration
    requires us to assign the user to a group after the registration process. Usually,
    we look for a function in the groups plugin that allows us to directly add users
    to a group by passing the necessary data. Then, we integrate the two plugins by
    using the registration success hook of the first plugin and executing the add
    user to group function within the hook. The main integration process works. But,
    the groups plugin may have other hooks that get executed after adding a user to
    a group. Such hooks may include features to send emails, assign group permissions,
    and so on. So, the overall process fails, even though the main integration works
    without issues. Therefore, it's important to consider all the hooks related to
    the integration process as well as data formats.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在集成中正确执行钩子也很重要。假设我们有一个用户注册插件和一个用户组插件。集成要求我们在注册过程之后将用户分配到组中。通常，我们会在组插件中寻找一个函数，允许我们通过传递必要的数据直接将用户添加到组中。然后，我们通过使用第一个插件的注册成功钩子并在钩子中执行将用户添加到组的函数来集成这两个插件。主要的集成过程是有效的。但是，组插件可能有其他在将用户添加到组之后执行的钩子。这些钩子可能包括发送电子邮件、分配组权限等功能。因此，整体过程失败，尽管主要的集成没有问题。因此，考虑与集成过程相关的所有钩子以及数据格式非常重要。
- en: Checking the impact with other plugins
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查与其他插件的影响
- en: Usually, we use at least a few plugins in every website, and some sites may
    contain dozens of plugins. Some of these plugins may have existing integrations
    between them. Let's assume we need to implement a new feature by integrating two
    or more plugins. In such scenarios, it's not sufficient to check the data, hooks,
    and integration points of those two plugins. We have to also check the impact
    by other existing plugins, or the impact on other existing plugins not involved
    in the integration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们每个网站至少使用几个插件，有些网站可能包含数十个插件。其中一些插件之间可能已经存在集成。让我们假设我们需要通过集成两个或更多插件来实现一个新功能。在这种情况下，检查这两个插件的数据、钩子和集成点是不够的。我们必须还要检查其他现有插件的影响，或者对未参与集成的其他现有插件的影响。
- en: 'Let''s consider the same scenario discussed in the *Checking the feasibility
    of integrations* section. We integrated two plugins to redirect the user to a
    private page of the content restrictions plugin after login. Assume we have a
    third plugin not involved in the integration. This plugin is used to change the
    login redirection URL based on user role. Consider the following integration in
    the third plugin:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在*检查集成可行性*部分讨论的相同场景。我们集成了两个插件，在登录后重定向用户到内容限制插件的个人页面。假设我们有一个未参与集成的第三个插件。此插件用于根据用户角色更改登录重定向URL。考虑以下第三个插件中的集成：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The URL modification hook in user role based redirection plugin has a higher
    priority value, and hence is executed later than the hook used in the previous
    scenario. Therefore, the logged-in user will be redirected to the user role specific
    page, instead of the private page of the content restrictions plugin. So, our
    integration completely falls apart.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用户角色基于的重定向插件中的URL修改钩子具有更高的优先级值，因此比前一种情况中使用的钩子晚执行。因此，登录用户将被重定向到用户角色特定的页面，而不是内容限制插件的个人页面。因此，我们的集成完全崩溃。
- en: 'We can prevent such issues by considering how other plugins use the data, and
    the hooks related to our integration process. In this scenario, we could prevent
    this situation by using a higher priority value for the hook in the first scenario:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过考虑其他插件如何使用数据以及与我们的集成过程相关的钩子来防止此类问题。在这种情况下，我们可以在第一种情况下为钩子使用更高的优先级值来防止这种情况：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This line of code is executed after the filter code in the role-based redirection
    plugin, and hence our integration works without issues. However, now you must
    also check how our integration affects the functionality of the role-based redirection
    plugin.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在基于角色的重定向插件中的过滤器代码之后执行，因此我们的集成没有问题。然而，现在你也必须检查我们的集成如何影响基于角色的重定向插件的功能。
- en: Implementing multiple plugin integrations
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多个插件集成
- en: 'Up to this point, we looked at the methods used in plugin integrations and
    important considerations. Now, it''s time to integrate a few plugins to understand
    their practical usage. We are going to integrate three popular plugins to illustrate
    the process. Let''s identify the plugins used for this integration and their functionality:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了插件集成中使用的方法和重要考虑因素。现在，是时候集成一些插件来了解它们的实际应用了。我们将集成三个流行的插件来展示这个过程。让我们确定用于此集成的插件及其功能：
- en: '**WooCommerce**: This is the most popular eCommerce plugin. The main functionality
    is selling physical and digital goods. These days, it''s also being used for selling
    services, bookings, and memberships by modifying the features through addons.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WooCommerce**: 这是最受欢迎的电子商务插件。主要功能是销售实体和数字商品。如今，它也通过修改功能通过插件来销售服务、预订和会员资格。'
- en: '**MyCred**: This is a point management plugin where you can allow users to
    earn points by doing various tasks in a site such as commenting, viewing content,
    publishing content, registering on the site, and so on. Then, you can reward these
    users by providing benefits with the use of these points.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MyCred**: 这是一个积分管理插件，您可以让用户通过在网站上执行各种任务（如评论、查看内容、发布内容、注册网站等）来赚取积分。然后，您可以通过使用这些积分来为这些用户提供奖励。'
- en: '**BuddyPress**: This is a plugin used to build online communities in your site.
    The default features include user management, groups, messages, activities, friends,
    and notifications. Many people use this plugin to build mini-social networks.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BuddyPress**: 这是一个用于在您的网站上构建在线社区的插件。默认功能包括用户管理、群组、消息、活动、朋友和通知。许多人使用这个插件来构建微型社交网络。'
- en: Now, we can take a look at the requirement for integrating these three plugins.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看集成这三个插件的要求。
- en: Assume that we have a point system in our site using **MyCred**. Users can earn
    points through various tasks and spend those points to get wide range of benefits.
    In this scenario, we assume users only get points by purchasing products from
    the **WooCommerce** store. The points will be given for *completed orders* based
    on order value. Once the user reaches a specific number of points, the user will
    be added automatically to a private **BuddyPress** group.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在网站上使用**MyCred**有一个积分系统。用户可以通过各种任务赚取积分，并用这些积分换取各种福利。在这种情况下，我们假设用户只能通过从**WooCommerce**商店购买产品来获得积分。积分将根据订单价值发放给*完成的订单*。一旦用户达到特定的积分数量，用户将被自动添加到私人**BuddyPress**群组中。
- en: Before starting the implementation, we need to create a new plugin called **WPQPI
    Plugin Integrations** in a new plugin directory called `wpquick-plugin-integrations`.
    The process for creating the main file and using header comments to define the
    plugin will be the same as previous scenarios.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们需要在名为`wpquick-plugin-integrations`的新插件目录中创建一个名为**WPQPI Plugin Integrations**的新插件。创建主文件和使用头部注释定义插件的过程将与之前的场景相同。
- en: Assigning points for completed orders
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为完成的订单分配积分
- en: 'We have to start the implementation by connecting WooCommerce and MyCred plugins
    to award points for completed orders. First, we need to find the ways for tracking
    the completion of a WooCommerce order. The simplest way is to use a search engine
    to check the availability of order complete hook, or go through the documentation
    of the WooCommerce plugin. We can find an action called `woocommerce_order_status_completed`
    for handling tasks after the completion of order. Let''s take a look at the implementation
    of order complete hook:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过连接WooCommerce和MyCred插件来为完成的订单奖励积分来开始实施。首先，我们需要找到跟踪WooCommerce订单完成的方法。最简单的方法是使用搜索引擎检查订单完成钩子的可用性，或者查阅WooCommerce插件的文档。我们可以找到一个名为`woocommerce_order_status_completed`的动作来处理订单完成后的任务。让我们看看订单完成钩子的实现：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can define the action using the `add_action` function with a specific callback
    function. The order ID is passed as a parameter to this function, and hence we
    can execute any tasks based on order details. The next task is to identify how
    we can add points in MyCred using custom code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`add_action`函数和特定的回调函数来定义动作。订单ID作为参数传递给这个函数，因此我们可以根据订单详情执行任何任务。下一个任务是确定我们如何使用自定义代码在MyCred中添加积分。
- en: 'We have few tasks to be implemented before we can add points to orders. First,
    we have to add a new hook to enable points for WooCommerce orders. MyCred points
    are added through built-in and custom hooks. The available hooks can be viewed
    by visiting the Points | Hooks section in WordPress admin. You need to go through
    the MyCred documentation to find the necessary hooks for adding custom MyCred
    hooks. So, let''s create a new hook for enabling points for WooCommerce orders:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以向订单添加点数之前，我们有一些任务需要实现。首先，我们必须添加一个新的钩子以启用 WooCommerce 订单的点数。MyCred 点数通过内置和自定义钩子添加。可以通过访问
    WordPress 管理中的“点数 | 钩子”部分来查看可用钩子。你需要查阅 MyCred 文档以找到添加自定义 MyCred 钩子所需的必要钩子。因此，让我们创建一个新的钩子以启用
    WooCommerce 订单的点数：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `mycred_setup_hooks` filter is used to add custom hooks to MyCred, or remove
    existing hooks. In this scenario, we add a new hook called `wpqpi_woo_purchase`
    for awarding points for WooCommerce purchases. The array defines the name of the
    hook, the description, and the PHP class to implement the point awarding procedure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`mycred_setup_hooks` 过滤器用于向 MyCred 添加自定义钩子或删除现有钩子。在这种情况下，我们添加了一个名为 `wpqpi_woo_purchase`
    的新钩子，用于为 WooCommerce 购买授予点数。数组定义了钩子的名称、描述以及实现点数授予过程的 PHP 类。'
- en: 'We have added a custom class called `WPQPI_WooCommerce_Hooks`. Once this code
    is added, you will see a new hook named Points for WooCommerce Purchases in the
    Available Hooks section. You can drag the hook to Active Hooks section to make
    it work, as shown in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `WPQPI_WooCommerce_Hooks` 的自定义类。一旦添加此代码，你将在可用钩子部分看到一个新的钩子，名为 WooCommerce
    购买点数。你可以将钩子拖到活动钩子部分以使其工作，如下面的截图所示：
- en: '![](img/c13b2308-d53a-441c-8f50-aef6df6aa731.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c13b2308-d53a-441c-8f50-aef6df6aa731.png)'
- en: 'The next step is to implement the class to award points for WooCommerce purchases.
    So, we need to implement the `mycred_load_hooks` action to load the hook set up
    in the previous section. Let''s take a look at the implementation of the `WPQPI_WooCommerce_Hooks`
    class inside the `mycred_load_hooks` action:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现为 WooCommerce 购买授予点数的类。因此，我们需要实现 `mycred_load_hooks` 动作来加载上一节中设置的钩子。让我们看看
    `mycred_load_hooks` 动作中 `WPQPI_WooCommerce_Hooks` 类的实现：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the hook, we just define the class by extending the `myCRED_Hook` core
    class of MyCred plugin. Then, we add the class constructor with unique ID and
    default settings. The settings include the number of points awarded by default
    and the text for the log entry of awarding points. This class executes a built-in
    function called `run`, while loading the hooks. This will be the point of integration
    where we define the WooCommerce order completed hook. Let''s see how we can implement
    the `run` function after the class constructor:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在钩子内部，我们只需通过扩展 MyCred 插件的 `myCRED_Hook` 核心类来定义类。然后，我们添加具有唯一 ID 和默认设置的类构造函数。这些设置包括默认授予的点数和授予点数的日志条目文本。此类在加载钩子时执行一个名为
    `run` 的内置函数。这将是我们定义 WooCommerce 订单完成钩子的集成点。让我们看看我们如何在类构造函数之后实现 `run` 函数：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can define any number of actions in the loading process of the MyCred hook
    created earlier. Here, we have the `woocommerce_order_status_completed` action
    and the callback function ready to be executed on successful orders. Now, we can
    move into the process of awarding points by implementing the `wpqpi_payment_complete`
    function, as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前创建的 MyCred 钩子的加载过程中定义任意数量的动作。在这里，我们有 `woocommerce_order_status_completed`
    动作和回调函数，它们在订单成功时执行。现在，我们可以进入实现 `wpqpi_payment_complete` 函数的过程，如下所示：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we use the `$order_id` parameter to load the order details using the
    `wc_get_order` function. Next, we get the order total by calling the `get_total`
    function on the `$order` object, and divide it by 10 to generate the number of
    MyCred points for the order. Next, we get the ID of the user who purchased the
    products by using the `get_user` function on the `$order` object. Finally, we
    call the MyCred `add_creds` function to add the points to the user for the order.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `$order_id` 参数通过 `wc_get_order` 函数加载订单详情。接下来，我们通过在 `$order` 对象上调用 `get_total`
    函数来获取订单总额，并将其除以 10 以生成订单的 MyCred 点数。然后，我们通过在 `$order` 对象上调用 `get_user` 函数来获取购买产品的用户的
    ID。最后，我们调用 MyCred 的 `add_creds` 函数将点数添加到用户的订单中。
- en: The `add_creds` function has three required parameters and some optional parameters.
    The first three parameters are used respectively for the reference ID, user ID,
    and number of points to be awarded. The other parameters are not important for
    the scenario used in this book. Now, the two plugins are integrated to award MyCred
    points to the user on successful WooCommerce order completion. We have used an
    event of one plugin to integrate with another plugin by modifying the data of
    the second plugin.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_creds`函数有三个必需参数和一些可选参数。前三个参数分别用于引用ID、用户ID和要授予的积分数量。其他参数对于本书中使用的场景来说并不重要。现在，这两个插件已经集成，在成功的WooCommerce订单完成后向用户授予MyCred积分。我们通过修改第二个插件的数据，使用一个插件的事件来与另一个插件集成。'
- en: Adding users to BuddyPress private groups
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户添加到BuddyPress私密群组
- en: 'In the previous section, we completed the first part of the integration with
    MyCred and WooCommerce. The next step is to complete the integration by connecting
    MyCred with BuddyPress groups. As we discussed, the requirement is to assign users
    to a BuddyPress private group once they reach specific number of MyCred points.
    So, we have to look for a way to add users to a BuddyPress group. We can either
    check for the documentation or use a search engine to find the appropriate implementation.
    BuddPress provides a function called `groups_join_group` to add users into a group.
    Let''s use that function to modify the `wpqpi_payment_complete` function and add
    users to groups:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们完成了MyCred和WooCommerce集成的第一部分。下一步是通过将MyCred与BuddyPress群组连接来完成集成。正如我们讨论的，要求是在用户达到特定的MyCred积分数量后，将用户分配到BuddyPress私密群组。因此，我们必须寻找一种方法将用户添加到BuddyPress群组。我们可以检查文档或使用搜索引擎来找到适当的实现。BuddyPress提供了一个名为`groups_join_group`的函数，用于将用户添加到群组。让我们使用这个函数来修改`wpqpi_payment_complete`函数，并将用户添加到群组：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we use the built-in `mycred_get_users_balance` function to receive the
    available points of the user. Then, we call the BuddyPress `groups_join_group`
    function with the group ID and user ID once the user balance has reached the limit
    we specified.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用内置的`mycred_get_users_balance`函数来接收用户的可用积分。然后，当用户余额达到我们指定的限制时，我们使用BuddyPress的`groups_join_group`函数，并传入群组ID和用户ID。
- en: We have simplified the code in this scenario to illustrate the process of plugin
    integration. In an ideal scenario, we have to implement a lot more permission
    checks before we add a user to a group, and points to a user.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个场景中简化了代码，以说明插件集成过程。在理想情况下，在将用户添加到群组或授予用户积分之前，我们必须进行更多的权限检查。
- en: In this implementation, we only award points for WooCommerce orders, and the
    user can only use points to join the group. Therefore, we can implement the points
    checking process within the same function. When we award points for multiple tasks,
    this balance checking code needs to be implemented in all of these tasks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们只为WooCommerce订单授予积分，用户只能使用积分加入群组。因此，我们可以在同一个函数中实现积分检查过程。当我们为多个任务授予积分时，这段平衡检查代码需要在这些所有任务中实现。
- en: Now, we have completed the integration and made three plugins work together
    for our requirements. Similarly, you can use existing hooks and functions to connect
    the necessary plugins for your requirements. However, I strongly recommend not
    to custom-integrate a large number of plugins in a single site, as it's hard to
    manage on plugin updates.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了集成，并使三个插件协同工作以满足我们的需求。同样，您可以使用现有的钩子和函数来连接满足您需求的必要插件。然而，我强烈建议不要在一个网站上自定义集成大量插件，因为插件更新时很难管理。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The process of customizing and extending plugins is crucial for building websites
    in a rapid process. So, we started extending plugins by creating an addon for
    the post attachments plugin developed in the previous chapter. Next, we looked
    at the WordPress core action execution process and its importance using sample
    scenarios. Then, we moved into the process of using various techniques for customizing
    plugins, while modifying WooCommerce product features. Finally, we looked at the
    different types of integrations between plugins, while integrating popular plugins
    to understand the process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速构建网站的过程中，自定义和扩展插件的过程至关重要。因此，我们开始通过创建前一章中开发的帖子附件插件的一个附加组件来扩展插件。接下来，我们通过示例场景来查看WordPress核心动作执行过程及其重要性。然后，我们探讨了使用各种技术来定制插件的过程，同时修改WooCommerce产品功能。最后，我们在集成流行插件以了解过程的同时，研究了插件之间不同的集成类型。
- en: In [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical Usage
    of WordPress APIs*, we will be exploring the built-in WordPress APIs, while learning
    how to use them practically in plugin development.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml)《WordPress API的实用应用》中，我们将探讨内置的WordPress
    API，同时学习如何在插件开发中实际使用它们。
