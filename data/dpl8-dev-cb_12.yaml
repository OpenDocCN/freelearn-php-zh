- en: Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务
- en: 'Drupal 8 ships with the RESTful web servers functionality to implement web
    services to interact with your application. This chapter shows you how to enable
    these features and build your API, covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 随带 RESTful Web 服务器功能，以实现与您的应用程序交互的 Web 服务。本章将向您展示如何启用这些功能并构建您的 API，涵盖以下主题：
- en: Enabling RESTful interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 RESTful 接口
- en: Using POST to create data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST 创建数据
- en: Using PATCH to update data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PATCH 更新数据
- en: Using Views to provide custom data sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Views 提供自定义数据源
- en: Authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: Using JSON API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON API
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are several modules provided by Drupal 8 that enable the ability to turn
    it into a web service provider. The Serialization module provides a means of serializing
    data to or deserializing from formats such as JSON and XML. The RESTful web services
    module then exposes entities and other APIs through Web APIs. Operations done
    through RESTful resource endpoints use the same create, edit, delete, and view
    permissions that would be used in a non-API format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 提供了几个模块，这些模块使您能够将其转变为 Web 服务提供者。序列化模块提供了一种将数据序列化到或从 JSON 和 XML 等格式反序列化的方法。然后，RESTful
    Web 服务模块通过 Web API 暴露实体和其他 API。通过 RESTful 资源端点执行的操作使用与在非 API 格式中相同的创建、编辑、删除和查看权限。
- en: The HAL module serializes entities using the **Hypertext Application Language**
    (**HAL**) format. HAL is an Internet Draft standard convention used to hyperlink
    between resources in an API. HAL+JSON is required when working with POST and PATCH
    methods. For authentication, the HTTP Basic Authentication module provides a simple
    authentication via HTTP headers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HAL 模块使用 **Hypertext Application Language**（**HAL**）格式序列化实体。HAL 是一个用于在 API 中超链接资源之间的
    Internet Draft 标准约定。当使用 POST 和 PATCH 方法时，需要 HAL+JSON。对于身份验证，HTTP Basic Authentication
    模块通过 HTTP 头提供简单的身份验证。
- en: There is a community-lead effort to implement the JSON API specification with
    Drupal, using the JSON API module, covered in the *Using JSON API* recipe of this
    chapter. Like HAL, it provides specifications not only on how data should be represented,
    but also on how it should be sorted and filtered via request parameters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个社区主导的努力，使用 JSON API 模块在 Drupal 中实现 JSON API 规范，如本章“使用 JSON API”菜谱中所述。像 HAL
    一样，它不仅提供了关于数据应该如何表示的规范，还提供了关于如何通过请求参数进行排序和过滤的规范。
- en: This chapter covers how to work with the RESTful Web Services module and the
    supporting modules around developing a RESTful API powered by Drupal 8\. We will
    cover how to use the GET, POST, and PATCH HTTP methods to manipulate content on
    the website. Additionally, we will cover how to use views to provide custom content
    that lists endpoints. Finally, we will cover how to handle custom authentication
    for our API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用 RESTful Web 服务模块及其支持模块开发由 Drupal 8 驱动的 RESTful API。我们将介绍如何使用 GET、POST
    和 PATCH HTTP 方法来操纵网站上的内容。此外，我们还将介绍如何使用视图提供列出端点的自定义内容。最后，我们将介绍如何处理 API 的自定义身份验证。
- en: In an article, *Putting off PUT*, the team behind the Web services initiative
    chose not to implement PUT and only support PATCH. For more information, refer
    to the original article at [https://groups.drupal.org/node/284948](https://groups.drupal.org/node/284948).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一篇名为“推迟 PUT”的文章中，Web 服务倡议背后的团队选择不实现 PUT，仅支持 PATCH。更多信息，请参阅原文档[https://groups.drupal.org/node/284948](https://groups.drupal.org/node/284948)。
- en: However, the API is open for contributed modules to add the PUT support for
    core resources or their own.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，API 对贡献模块开放，以添加对核心资源或其自己的 PUT 支持。
- en: Enabling RESTful interfaces
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 RESTful 接口
- en: The RESTful Web Services module provides routes that expose endpoints for your
    RESTful API. It utilizes the Serialization module to handle the normalization
    to a response and denormalization of data from requests. Endpoints support specific
    formats and authentication providers. Upon installation, the RESTful Web Services
    module does not provide any default configured endpoints.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务模块提供了暴露 RESTful API 端点的路由。它使用序列化模块来处理响应的规范化以及从请求中数据的反规范化。端点支持特定的格式和身份验证提供者。在安装后，RESTful
    Web 服务模块不提供任何默认配置的端点。
- en: 'There is one caveat: RESTful Web Services does not provide a user interface
    to configure available endpoints. Enabling resource endpoints can be done by manually
    editing configuration or the **REST UI** module. We will use the REST UI module
    in this recipe.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个注意事项：RESTful Web 服务不提供用户界面来配置可用的端点。通过手动编辑配置或 **REST UI** 模块可以启用资源端点。我们将在这个菜谱中使用
    REST UI 模块。
- en: In this recipe, we will install RESTful Web Services and enable the proper permissions
    to allow the retrieval of nodes via REST to receive our formatted JSON.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将安装RESTful Web服务并启用适当的权限，以便通过REST检索节点并接收格式化的JSON。
- en: We will cover using GET, POST, PATCH, and DELETE in later recipes. This recipe
    covers the installation and configuration of the base modules to enable Web services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的菜谱中介绍如何使用GET、POST、PATCH和DELETE。本菜谱涵盖了安装和配置基础模块以启用Web服务。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There is a configuration change that might be required if you are running PHP
    5.6: the `always_populate_raw_post_data` setting. If you try to enable the RESTful
    Web Services module without changing the default setting, you will see the following
    error message on installation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行PHP 5.6，可能需要进行配置更改：`always_populate_raw_post_data`设置。如果您尝试启用RESTful Web服务模块而不更改默认设置，则在安装时将看到以下错误消息：
- en: The `always_populate_raw_post_data` PHP setting should be set to `-1` in PHP
    version 5.6\. Please check the PHP manual for information on how to correct this.
    (Currently using `always_populate_raw_post_data` PHP setting version not set to
    -1.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5.6版本中，`always_populate_raw_post_data` PHP设置应设置为`-1`。请查阅PHP手册了解如何纠正此设置。（当前使用的`always_populate_raw_post_data`
    PHP设置版本未设置为-1。）
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we must add the REST UI module to our Drupal site so that we can easily
    configure our endpoints:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将REST UI模块添加到我们的Drupal站点，这样我们就可以轻松地配置我们的端点：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go to Extend from the administrative toolbar and install the following Web
    services modules: Serialization, RESTful Web Services, and REST UI:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理工具栏转到扩展，并安装以下Web服务模块：序列化、RESTful Web服务以及REST UI：
- en: '![](img/9b148a49-0009-4a45-a9af-06bfc1bd82cf.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b148a49-0009-4a45-a9af-06bfc1bd82cf.png)'
- en: Go to Configuration and click on REST under Web Services to configure the available
    endpoints.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往配置，然后在Web服务下点击REST以配置可用的端点。
- en: 'Click on the Enable button for the Content row:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容行的“启用”按钮：
- en: '![](img/ef337a85-00c7-4438-8538-5f2c8c8cd21c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef337a85-00c7-4438-8538-5f2c8c8cd21c.png)'
- en: 'With the endpoint enabled, it must be configured. Check the GET method checkbox
    to allow GET requests. Then, check the json checkbox so that data can be returned
    as JSON. All endpoints require a selected authentication provider. Check the cookie
    checkbox, and then save it:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点启用后，必须进行配置。勾选GET方法复选框以允许GET请求。然后，勾选json复选框以便数据可以以JSON格式返回。所有端点都需要选择一个认证提供者。勾选cookie复选框，然后保存：
- en: '![](img/03616b74-74d3-45fe-9a79-ac8297eae48a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03616b74-74d3-45fe-9a79-ac8297eae48a.png)'
- en: Any RESTful resource endpoint enabled will use the same create, update, delete,
    and view permissions that have been already configured for the entity type. In
    order to allow anonymous access over GET for content, ensure that anonymous users
    have the **View published content permission**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用了任何RESTful资源端点都将使用已经为实体类型配置的相同创建、更新、删除和查看权限。为了允许匿名用户通过GET访问内容，请确保匿名用户有**查看已发布内容权限**。
- en: 'Using cURL on the command line, a piece of content can now be retrieved using
    the RESTful endpoint. You must pass `?_format=json` to ensure that the proper
    format is returned:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行上的cURL，现在可以使用RESTful端点检索内容。您必须传递`?_format=json`以确保返回正确的格式：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The RESTful Web Services module will return the entire entity object with each
    field the user has access to view.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务模块将为每个用户可以查看的字段返回整个实体对象。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **RESTful Web Services** module works by implementing an event subscriber
    service, `rest.resource_routes`, that adds routes to Drupal based on implementations
    of its `RestResource` plugin. Each plugin returns the available routes based on
    HTTP methods that are enabled for the resource.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**RESTful Web 服务**模块通过实现一个事件订阅者服务`rest.resource_routes`来工作，该服务根据其`RestResource`插件的实现向Drupal添加路由。每个插件根据为资源启用的HTTP方法返回可用的路由。'
- en: When routes are built, the `\Drupal\rest\Routing\ResourceRoutes` class uses
    the `RestResource` plugin manager to retrieve all the available definitions. The
    endpoint configuration objects are loaded and inspected. If the resource plugin
    provides an HTTP method that is enabled in the configuration definitions, it begins
    to build a new route. Verification is done against the defined supported formats
    and supported auth definitions. If the basic validation passes, the new route
    is added to the `RouteCollection` and returned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建路由时，`\Drupal\rest\Routing\ResourceRoutes`类使用`RestResource`插件管理器检索所有可用的定义。加载并检查端点配置对象。如果资源插件提供了一个在配置定义中启用的HTTP方法，它将开始构建一个新的路由。验证是对定义的支持格式和支持认证定义进行的。如果基本验证通过，新的路由将被添加到`RouteCollection`并返回。
- en: If you provide a `supported_formats` or `supported_auth` value that is not available,
    the endpoint will still be created. There will be an error, however, if you attempt
    to use the route with the invalid plugin. This cannot occur when using the REST
    UI module, but manually providing and managing the configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了一个不可用的`supported_formats`或`supported_auth`值，端点仍然会被创建。然而，如果你尝试使用无效插件的路由，将会出现错误。在使用REST
    UI模块时，这种情况不会发生，但需要手动提供和管理配置。
- en: The default routes provided by the base class for resource plugins, `\Drupal\rest\Plugin\ResourceBase`
    class, set `\Drupal\rest\RequestHandler::handle` as the controller and method
    for the route. This method checks the passed `_format` parameter against the configured
    plugin. If the format is valid, the data is passed to the appropriate serializer.
    The serialized data is then returned in the request with appropriate content headers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基类为资源插件提供的默认路由，`\Drupal\rest\Plugin\ResourceBase`类，将`\Drupal\rest\RequestHandler::handle`设置为路由的控制器和方法。此方法将传递的_format参数与配置的插件进行比较。如果格式有效，数据将被传递到适当的序列化器。然后，序列化数据将带有适当的内容头返回到请求中。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The RESTful Web Services module provides a robust API that has some additional
    items to make a note of. We will explore these in the next recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web Services模块提供了一个强大的API，有一些额外的项目需要注意。我们将在下一个菜谱中探讨这些内容。
- en: Using _format instead of the Accept header
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用_format代替Accept头
- en: 'Earlier in the Drupal 8 life cycle, up until 8.0.0-beta12, Drupal supported
    the use of the `Accept` header instead of the `_format` parameter. Unfortunately,
    there were issues with external caches. Drupal was serving HTML and other formats
    on the same path, only using different `Accept` headers. CDNs and reverse proxies
    do not invalidate cache based on this header alone. The only solution to prevent
    cache poisoning on these external caches, such as `Varnish`, was to ensure the
    implementation of the `Vary: Accept` header. There were, however, too many issues
    regarding CDNs and variance of implementation, so the `_format` parameter was
    introduced instead of appending extensions (`.json` and `.xml`) to paths.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '在Drupal 8的生命周期早期，直到8.0.0-beta12，Drupal支持使用`Accept`头而不是_format参数。不幸的是，存在外部缓存的问题。Drupal在相同的路径上提供HTML和其他格式，只使用不同的`Accept`头。CDN和反向代理不会仅基于此头无效化缓存。防止这些外部缓存（如Varnish）缓存中毒的唯一解决方案是确保实现`Vary:
    Accept`头。然而，关于CDN和实现差异的问题太多，因此引入了_format参数，而不是将扩展（`.json`和`.xml`）附加到路径上。'
- en: 'A detail of the problem can be found on the following core issues:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于问题的详细情况可以在以下核心问题中找到：
- en: Refer to external caches mix up response formats on URLs where content negotiation
    is in use at [https://www.drupal.org/node/2364011](https://www.drupal.org/node/2364011)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[https://www.drupal.org/node/2364011](https://www.drupal.org/node/2364011)中关于在URL上使用内容协商时外部缓存混淆响应格式的说明。
- en: Check how to implement query parameter-based content negotiation as an alternative
    to extensions at [https://www.drupal.org/node/2481453](https://www.drupal.org/node/2481453)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查如何实现基于查询参数的内容协商，作为扩展的替代方案，请参阅[https://www.drupal.org/node/2481453](https://www.drupal.org/node/2481453)。
- en: RestResource plugin to expose data through RESTful Web Services
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RestResource插件通过RESTful Web Services公开数据
- en: The RESTful Web Services module defines a `RestResource` plugin. This plugin
    is used to define resource endpoints. They are discovered in a module's `Plugin/rest/resource`
    namespace and need to implement the `\Drupal\rest\Plugin\ResourceInterface` interface.
    Drupal 8 provides two implementations of the `RestResource` plugin. The first
    is the `EntityResource` class that is provided by the RESTful Web Services module.
    It implements a driver class that allows it to represent each entity type. The
    second is the **Database Logging** module that provides its own `RestResource`
    plugin, as well. It allows you to retrieve logged messages by IDs. The `\Drupal\rest\Plugin\ResourceBase`
    class provides an abstract base class that can be extended for the `RestResource`
    plugin implementations. If the child class provides a method that matches the
    available HTTP methods, it will support them. For example, if a class has only
    a GET method, you can only interact with that endpoint through HTTP `GET` requests.
    On the other hand, you can provide a trace method that allows an endpoint to support
    HTTP `TRACE` requests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web Services 模块定义了一个 `RestResource` 插件。此插件用于定义资源端点。它们在模块的 `Plugin/rest/resource`
    命名空间中找到，并需要实现 `\Drupal\rest\Plugin\ResourceInterface` 接口。Drupal 8 提供了两个 `RestResource`
    插件的实现。第一个是由 RESTful Web Services 模块提供的 `EntityResource` 类。它实现了一个驱动类，允许它表示每种实体类型。第二个是提供自己的
    `RestResource` 插件的 **Database Logging** 模块。它允许您通过 ID 检索记录的消息。`\Drupal\rest\Plugin\ResourceBase`
    类提供了一个抽象基类，可以扩展用于 `RestResource` 插件实现。如果子类提供了一个与可用 HTTP 方法匹配的方法，它将支持这些方法。例如，如果一个类只有一个
    GET 方法，您只能通过 HTTP `GET` 请求与该端点交互。另一方面，您可以提供一个跟踪方法，允许端点支持 HTTP `TRACE` 请求。
- en: Drupal 8 provides two implementations of the `RestResource` plugin. The first
    is the `EntityResource` class that is provided by the RESTful Web Services module.
    It implements a `deriver` class that allows it to represent each entity type.
    The second is the Database Logging module that provides its own `RestResource`
    plugin. It allows you to retrieve logged messages by IDs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 提供了两个 `RestResource` 插件的实现。第一个是由 RESTful Web Services 模块提供的 `EntityResource`
    类。它实现了一个 `deriver` 类，允许它表示每种实体类型。第二个是提供自己的 `RestResource` 插件的 Database Logging
    模块。它允许您通过 ID 检索记录的消息。
- en: Rate limiting your API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制您的 API 速率
- en: Many APIs implement a rate limit to prevent abuse of public APIs. When you have
    publicly exposed APIs, you will need to control the amount of traffic hitting
    the service and prevent abusers from slowing down or stopping your service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 API 实现了速率限制，以防止滥用公共 API。当您公开暴露 API 时，您将需要控制击中服务的流量量，并防止滥用者减慢或停止您的服务。
- en: The **Rate Limiter** module implements multiple ways to control access to your
    public APIs. There is an option to control the rate limit on specific requests,
    IP address-based limiting, and IP whitelisting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**速率限制器** 模块实现了多种控制对您的公共 API 访问的方式。有一个选项可以控制特定请求的速率限制，基于 IP 地址的限制，以及 IP 白名单。'
- en: You can find the Rate Limiter module at [https://www.drupal.org/project/rate_limiter](https://www.drupal.org/project/rate_limiter).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://www.drupal.org/project/rate_limiter](https://www.drupal.org/project/rate_limiter)
    找到 Rate Limiter 模块。
- en: Using the HAL format
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HAL 格式
- en: 'When installed, the HAL module can format the entity returned to provide links
    to related entities, such as the user or revision or any other entity reference
    field. When the HAL module is installed, you can add it as a supported format,
    then do a request with `_format=hal_json`. The response from the recipe would
    come back with a `_links` parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 HAL 模块时，它可以格式化返回的实体，以提供到相关实体的链接，例如用户、修订版或任何其他实体引用字段。当 HAL 模块安装后，您可以将其添加为支持的格式，然后使用
    `_format=hal_json` 进行请求。来自菜谱的响应将返回一个 `_links` 参数：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the Drupal.org documentation for the RESTful Web Services module at
    [https://www.drupal.org/documentation/modules/rest](https://www.drupal.org/documentation/modules/rest)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 Drupal.org 上的 RESTful Web Services 模块文档，[https://www.drupal.org/documentation/modules/rest](https://www.drupal.org/documentation/modules/rest)
- en: 'Refer to *Change record: Accept header based routing got replaced by a query
    parameter*, [https://www.drupal.org/node/2501221](https://www.drupal.org/node/2501221)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*变更记录：基于接受头的路由被查询参数替换*，[https://www.drupal.org/node/2501221](https://www.drupal.org/node/2501221)
- en: Refer to [*Chapter 7*](3994173f-3d31-4f01-b808-99e01368564b.xhtml), *Plug and
    Play with Plugins*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参阅[*第7章*](3994173f-3d31-4f01-b808-99e01368564b.xhtml)，*插件即插即用* '
- en: Refer to the *Rate Limiter module* at [https://www.drupal.org/project/rate_limiter](https://www.drupal.org/project/rate_limiter)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 *速率限制器模块*：[https://www.drupal.org/project/rate_limiter](https://www.drupal.org/project/rate_limiter)
- en: Refer to the *REST UI module* at [https://www.drupal.org/project/restui](https://www.drupal.org/project/restui)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 *REST UI 模块*：[https://www.drupal.org/project/restui](https://www.drupal.org/project/restui)
- en: Using POST to create data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 POST 创建数据
- en: When working with RESTful Web Services, the HTTP POST method is used to create
    new entities. We will use the **HTTP Basic Authentication** to authenticate a
    user and create a new node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 RESTful Web 服务一起工作时，使用 HTTP POST 方法来创建新实体。我们将使用 **HTTP Basic Authentication**
    来验证用户并创建新节点。
- en: In this recipe, we will use the exposed node endpoint to create a new piece
    of article content through the RESTful Web Services module. We will use the `json`
    format. In the *There's more...* section, we will discuss how to use the HAL module
    for the `hal_json` format.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用公开的节点端点通过 RESTful Web 服务模块创建新的文章内容。我们将使用 `json` 格式。在 *更多内容...* 部分中，我们将讨论如何使用
    HAL 模块来处理 `hal_json` 格式。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will use the `Article` content type provided by the standard installation.
    Following the preceding recipe, *Enabling RESTful interfaces*, you should have
    the **REST UI** module added to your Drupal installation using Composer. This
    can be done with the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用标准安装提供的 `Article` 内容类型。按照前面的配方，*启用 RESTful 接口*，您应该已经使用 Composer 将 **REST
    UI** 模块添加到您的 Drupal 安装中。这可以通过以下命令完成：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this recipe, the Drupal 8 installation is accessible through `http://127.0.0.1:8888`.
    Use the appropriate URL for your Drupal 8 site.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，Drupal 8 安装可通过 `http://127.0.0.1:8888` 访问。使用您 Drupal 8 网站的适当 URL。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Go to Extend from the administrative toolbar and install the following Web
    Services modules: Serialization, RESTful Web Services, REST UI, and HTTP Basic
    Authentication:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理工具栏转到“扩展”，并安装以下 Web 服务模块：序列化、RESTful Web 服务、REST UI 和 HTTP Basic Authentication：
- en: '![](img/34895758-9c1f-4d70-bc3f-29fb29064b88.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34895758-9c1f-4d70-bc3f-29fb29064b88.png)'
- en: Go to Configuration and click on REST under Web Services to configure the available
    endpoints.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往“配置”，然后在“Web 服务”下点击 REST 来配置可用的端点。
- en: 'Click on the Enable button for the Content row:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容行的“启用”按钮：
- en: '![](img/6eef4dca-6ac0-4c91-9f30-ad1896460e74.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6eef4dca-6ac0-4c91-9f30-ad1896460e74.png)'
- en: 'With the endpoint enabled, it must be configured. Check the GET and POST methods
    checkbox to allow GET and POST requests. Then, check the json checkbox so that
    data can be returned as JSON. Check the basic_auth checkbox, and then save it:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用端点后，必须进行配置。勾选 GET 和 POST 方法复选框以允许 GET 和 POST 请求。然后，勾选 json 复选框以便数据可以以 JSON
    格式返回。勾选 basic_auth 复选框，然后保存：
- en: '![](img/1280dbfe-c1e5-45fe-9e22-979038943da6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1280dbfe-c1e5-45fe-9e22-979038943da6.png)'
- en: 'We create our JSON payload to match the field structure expected by Drupal:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建 JSON 负载以匹配 Drupal 预期的字段结构：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we send our JSON payload, we will need to retrieve a CSRF token. We
    do this by performing a `GET` request against `/session/token`. We''ll use the
    returned value in our POST request header:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们发送 JSON 负载之前，我们需要检索 CSRF 令牌。我们通过向 `/session/token` 发送 `GET` 请求来完成此操作。我们将在
    POST 请求头中使用返回的值：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can send the request containing our body payload to the `/entity/node?_format=json`
    endpoint path through an HTTP POST request to create our node. Ensure that you
    pass a valid user login where `admin:admin` is used:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过向 `/entity/node?_format=json` 端点路径发送包含我们正文负载的请求来创建我们的节点。确保您传递有效的用户登录信息，其中
    `admin:admin` 被使用：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A successful request will return a `201` header code and the full values of
    the created node, including its identifier.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功的请求将返回 `201` 状态码和创建的节点的完整值，包括其标识符。
- en: 'View your Drupal site and verify that the node was created, by going to `/node/{nid}`,
    using the node ID from the request response:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 `/node/{nid}`，使用请求响应中的节点 ID 来查看您的 Drupal 网站，并验证节点是否已创建：
- en: '![](img/164085a1-8cd5-4816-b439-3153931668e2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/164085a1-8cd5-4816-b439-3153931668e2.png)'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When working with content entities and the POST method, the endpoint is different
    to the one used for GET requests. The `\Drupal\rest\Plugin\rest\resource\EntityResource`
    class extends the `\Drupal\rest\Plugin\ResourceBase` base class, which provides
    a route method. If a resource plugin provides an `https://www.drupal.org/link-relations/create`
    link template, then that path will be used for the POST path.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用内容实体和 POST 方法时，端点与用于 GET 请求的端点不同。`\\Drupal\\rest\\Plugin\\rest\\resource\\EntityResource`
    类扩展了 `\\Drupal\\rest\\Plugin\\ResourceBase` 基类，该类提供了一个路由方法。如果一个资源插件提供了一个 `https://www.drupal.org/link-relations/create`
    链接模板，那么将使用该路径作为 POST 路径。
- en: The `EntityResource` class defines `/entity/{entity_type}` as the create link
    template. It then overrides the `getBaseRoute` method to ensure that the `entity_type`
    parameter is properly populated from the definition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityResource` 类将 `/entity/{entity_type}` 定义为创建链接模板。然后它覆盖 `getBaseRoute`
    方法以确保 `entity_type` 参数从定义中正确填充。'
- en: The `EntityResource` class will run a set of conditions for the request. First,
    it will validate the POST request by checking whether the entity is `null`. Then,
    the current user is authorized to create the entity type if the current user also
    has access to edit all fields provided, and finally, it checks whether an identifier
    was passed or not. The last condition is important, as updates are only to be
    made through a PATCH request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityResource` 类将为请求运行一系列条件。首先，它将通过检查实体是否为 `null` 来验证 POST 请求。然后，如果当前用户也有权编辑提供的所有字段，则当前用户有权创建实体类型。最后，它检查是否传递了标识符。最后一个条件很重要，因为更新只能通过
    PATCH 请求进行。'
- en: If the entity is validated, it will be saved. On a successful save, an empty
    HTTP 201 response will be returned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体经过验证，它将被保存。在成功保存后，将返回一个空的 HTTP 201 响应。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Working with POST requests requires some specific formatting that will be explained
    in the next recipe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 POST 请求需要一些特定的格式，这些格式将在下一个菜谱中解释。
- en: Using HAL and understanding _links requirements
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HAL 和理解 _links 需求
- en: When using the HAL module and the `hal_json` format, you must provide relationships
    for the entity. This is done through the `_links` parameter in the request. This
    is done to ensure that the entity is properly created with any relationships it
    requires, such as the entity type for a content entities bundle. Another example
    will be to create a comment over a RESTful interface. You will need to provide
    a `_links` entry for the user owning the comment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 HAL 模块和 `hal_json` 格式时，你必须为实体提供关系。这是通过请求中的 `_links` 参数完成的。这是为了确保实体被正确创建，并具有它所需的任何关系，例如内容实体包的实体类型。另一个例子是在
    RESTful 接口上创建评论。你需要为拥有评论的用户提供一个 `_links` 条目。
- en: The `rest.link_manager` service uses the `rest.link_manager.type` and `rest.link_manager.relation`
    and is responsible for returning the URIs for types and relations. By default,
    a bundle will have a path that resembles `/rest/type/{entity_type}/{bundle}` and
    its relations will resemble `/rest/relation/{entity_type}/{bundle}/{field_name}`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest.link_manager` 服务使用 `rest.link_manager.type` 和 `rest.link_manager.relation`，并负责返回类型和关系的
    URI。默认情况下，一个包将有一个类似于 `/rest/type/{entity_type}/{bundle}` 的路径，其关系将类似于 `/rest/relation/{entity_type}/{bundle}/{field_name}`。'
- en: 'Taking a user reference as an example, we will have to populate a `uid` field,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以用户引用为例，我们必须填充一个 `uid` 字段，如下所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unfortunately, the documentation is sparse, and the best way to learn what `_links`
    are required is to perform a GET request and study the returned `_links` from
    the HAL JSON.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，文档很少，了解需要哪些 `_links` 的最佳方式是执行 GET 请求并研究从 HAL JSON 返回的 `_links`。
- en: Working with images
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像
- en: Most RESTful APIs utilize `base64` encoding of files to support POST operations
    to upload an image. Unfortunately, this is not supported in the Drupal core. Although
    there is a `serializer.normalizer.file_entity.hal` service that serializes file
    entities into HAL JSON, it does not currently work as of 8.3, but is hopefully
    slated for 8.4.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 RESTful API 利用文件的 `base64` 编码来支持 POST 操作上传图像。不幸的是，这不在 Drupal 核心中得到支持。尽管有一个
    `serializer.normalizer.file_entity.hal` 服务将文件实体序列化为 HAL JSON，但它目前截至 8.3 版本还没有工作，但希望计划在
    8.4 版本中实现。
- en: The `\Drupal\hal\Normalizer\FileEntityNormalizer` class supports denormalization;
    however, it does not handle `base64` and expects binary data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`\\Drupal\\hal\\Normalizer\\FileEntityNormalizer` 类支持反序列化；然而，它不处理 `base64`
    并期望二进制数据。'
- en: There is a Drupal core issue for this problem, which is available at [https://www.drupal.org/node/1927648](https://www.drupal.org/node/1927648).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有一个 Drupal 核心问题，可在 [https://www.drupal.org/node/1927648](https://www.drupal.org/node/1927648)
    找到。
- en: Using Cross-Site Request Forgery tokens
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用跨站请求伪造令牌
- en: When working with a POST request, you will need to pass a **Cross-Site Request
    Forgery** (**CSRF**) token if you are authenticating with a session cookie. The
    X-CSRF-Token header is required when using a session cookie to prevent accidental
    API requests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 POST 请求工作时，如果你使用会话 cookie 进行身份验证，你需要传递一个 **跨站请求伪造**（**CSRF**）令牌。当使用会话 cookie
    时，需要 X-CSRF-Token 标头以防止意外的 API 请求。
- en: 'If you are using the cookie provider for authentication, you will need to request
    a CSRF token from the `/session/token` route:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 cookie 提供者进行身份验证，你需要从 `/session/token` 路径请求 CSRF 令牌：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to how to serialize file content (`base64`) to support REST GET/POST/PATCH
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考如何序列化文件内容（`base64`）以支持 REST GET/POST/PATCH
- en: on file entity at [https://www.drupal.org/node/1927648](https://www.drupal.org/node/1927648)
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件实体 [https://www.drupal.org/node/1927648](https://www.drupal.org/node/1927648)
- en: Using PATCH to update data
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PATCH 更新数据
- en: When working with RESTful Web Services, the HTTP PATCH method is used to update
    entities. We will use the HTTP Basic Authentication to authenticate our user and
    update a node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 RESTful Web 服务时，使用 HTTP PATCH 方法来更新实体。我们将使用 HTTP Basic Authentication 来验证我们的用户并更新一个节点。
- en: In this recipe, we will use the exposed node endpoint to create a new piece
    of article content through the RESTful Web Services module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用暴露的节点端点通过 RESTful Web 服务模块创建新的文章内容。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the `Article` content type provided by the standard installation.
    Following the *Enabling RESTful interfaces* recipe, you should have the REST UI
    module added to your Drupal installation using Composer. This can be done with
    the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准安装提供的 `Article` 内容类型。按照 *启用 RESTful 接口* 菜谱，你应该已经使用 Composer 将 REST UI
    模块添加到你的 Drupal 安装中。这可以通过以下命令完成：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Go to Extend from the administrative toolbar and install the following Web
    Services modules: Serialization, RESTful Web Services, REST UI, and HTTP Basic
    Authentication:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理工具栏转到扩展，并安装以下 Web 服务模块：序列化、RESTful Web 服务、REST UI 和 HTTP 基本身份验证：
- en: '![](img/855e2758-aa42-405c-bfd2-a9fe8887f66e.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/855e2758-aa42-405c-bfd2-a9fe8887f66e.png)'
- en: Go to Configuration and click on REST under Web Services to configure the available
    endpoints.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往配置并点击 Web 服务下的 REST 进行配置可用的端点。
- en: 'Click on the Enable button for the Content row:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容行的“启用”按钮：
- en: '![](img/77fd5bab-7b56-491a-b8dc-5875449c4327.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77fd5bab-7b56-491a-b8dc-5875449c4327.png)'
- en: 'With the endpoint enabled, it must be configured. Check the GET, POST, and
    PATCH methods checkbox to allow the GET, POST, and PATCH requests. Then, check
    the json checkbox so that data can be sent as JSON. Check the basic_auth checkbox
    and then save it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点启用后，必须进行配置。检查 GET、POST 和 PATCH 方法复选框以允许 GET、POST 和 PATCH 请求。然后，检查 json 复选框，以便可以以
    JSON 格式发送数据。检查 basic_auth 复选框，然后保存：
- en: '![](img/89afd28a-d7a4-41ee-9172-c673fe67a83d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89afd28a-d7a4-41ee-9172-c673fe67a83d.png)'
- en: 'Create a sample `Article` node on your Drupal site that you will modify using
    the REST endpoint. Ensure that you note its path. You will use the same path later
    in our request (for example, `/node/4`). This will also show you the node''s ID:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Drupal 网站上创建一个示例 `Article` 节点，你将通过 REST 端点对其进行修改。确保你记下它的路径。你将在稍后的请求中使用相同的路径（例如，`/node/4`）。这也会显示节点的
    ID：
- en: '![](img/07ed6ccb-b637-4132-b79f-cc95b5d73dcd.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07ed6ccb-b637-4132-b79f-cc95b5d73dcd.png)'
- en: 'Then, start building your JSON payload. You must provide the identifier (`nid`)
    value for the existing node and the content type (`type`) value. Ensure that you
    provide the value of `nid`, which matches your current node:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，开始构建你的 JSON 负载。你必须提供现有节点标识符 (`nid`) 的值和内容类型 (`type`) 的值。确保你提供的 `nid` 值与你的当前节点相匹配：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before you send your JSON payload, you will need to retrieve a CSRF token.
    You can do this by performing a GET request against `/session/token`. Then, use
    the returned value in your POST request header:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送 JSON 负载之前，你需要检索 CSRF 令牌。你可以通过针对 `/session/token` 执行 GET 请求来完成此操作。然后，在 POST
    请求头中使用返回的值：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can send the request that contains your body payload to the `/node/4?_format=json`,
    where `/node/4` matches the path of the node you would like to edit, path through
    an HTTP PATCH request to create our node:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将包含您的正文有效负载的请求发送到 `/node/4?_format=json`，其中 `/node/4` 匹配您想要编辑的节点路径，通过 HTTP
    PATCH 请求创建我们的节点：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A successful request will return a `200` header code and the full values of
    the updated node.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功的请求将返回 `200` 头代码和更新节点的完整值。
- en: 'View your Drupal site and verify that the node was created, by going to `/node/{nid}`,
    using the node ID from the request response:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 `/node/{nid}` 来查看您的 Drupal 网站，并验证节点是否已创建，使用请求响应中的节点 ID：
- en: '![](img/eb4923ad-10ef-4e19-82d5-07f7e583f04d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb4923ad-10ef-4e19-82d5-07f7e583f04d.png)'
- en: How it works…
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When working with content entities and the PATCH method, the endpoint is the
    same as the GET method path. The current user's access is checked to see whether
    they have the permission to update the entity type and each of the submitted fields
    provided in the request body.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当与内容实体和 PATCH 方法一起工作时，端点与 GET 方法路径相同。检查当前用户的访问权限，以查看他们是否有权更新实体类型以及请求正文中提供的每个提交字段。
- en: Each field provided will be updated on the entity and then validated. If the
    entity is validated, it will be saved. On a successful save, an HTTP 200 response
    will be returned with the entire updated entity's content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的每个字段都会在实体上更新，然后进行验证。如果实体经过验证，它将被保存。在成功保存后，将返回包含整个更新实体内容的 HTTP 200 响应。
- en: Using Views to provide custom data sources
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图提供自定义数据源
- en: The RESTful Web Services module provides Views plugins that allow you to expose
    data over Views for your RESTful API. This allows you to create a view that has
    a path and outputs data using a serializer plugin. You can use this to output
    entities, such as JSON, HAL JSON, or XML, and it can be sent with appropriate
    headers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务模块提供了视图插件，允许您在视图上公开数据以供您的 RESTful API 使用。这允许您创建一个具有路径并使用序列化插件输出数据的视图。您可以使用此功能输出实体，例如
    JSON、HAL JSON 或 XML，并且它可以与适当的头信息一起发送。
- en: In this recipe, we will create a view that outputs the users of the Drupal site,
    providing their username, email, and picture if provided.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个视图，输出 Drupal 网站的用户，提供他们的用户名、电子邮件和图片（如果提供）。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Got o Extend from the administrative toolbar and install the following Web
    Services modules: Serialization and RESTful Web Services:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理工具栏转到扩展，并安装以下 Web 服务模块：序列化和 RESTful Web 服务：
- en: '![](img/9ea0b910-a0ed-48c5-9bbd-91dcd7ff8fce.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ea0b910-a0ed-48c5-9bbd-91dcd7ff8fce.png)'
- en: Go to Structure and then to Views. Click on Add view. Name the view **API Users**
    and make it show Users.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往结构，然后转到视图。点击添加视图。将视图命名为 **API Users** 并使其显示用户。
- en: 'Check the Provide a REST export checkbox, and type in the `api/users` path.
    This is where requests will be made:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查提供 REST 导出复选框，并输入 `api/users` 路径。这是请求将在这里进行的地方：
- en: '![](img/5be46af4-ec3b-4ad4-b1ca-6315371b7f4e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5be46af4-ec3b-4ad4-b1ca-6315371b7f4e.png)'
- en: Click on Save and edit.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存并编辑。
- en: Change the format of the row plugin from Entity to Fields instead so that we
    can control the specific output.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行插件的格式从实体更改为字段，以便我们可以控制特定的输出。
- en: 'Ensure that your view has the following user entity fields: Name, Email, and
    Picture.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的视图包含以下用户实体字段：名称、电子邮件和图片。
- en: 'Change the User: Name field to a plain text formatter and do not link it to
    the user, so the response does not contain any HTML.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户：名称字段更改为纯文本格式化程序，并且不要将其链接到用户，以便响应不包含任何 HTML。
- en: 'Change the User: Picture field to use URL to image formatter so that only a
    URL is returned and not HTML.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户：图片字段更改为使用 URL 到图片格式化程序，以便只返回 URL 而不是 HTML。
- en: Save your view.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的视图。
- en: 'Access your view by visiting `/api/users`; you will receive a JSON response
    containing the user information:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 `/api/users` 访问您的视图；您将收到包含用户信息的 JSON 响应：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The RESTful Web Services module provides display, row, and format plugins that
    allows you to export content entities to a serialized format. The REST Export
    display plugin allows you to specify a path to access the RESTful endpoint and
    properly assigns the Content-Type header for the requested format.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务模块提供了显示、行和格式插件，允许您将内容实体导出为序列化格式。REST 导出显示插件允许您指定访问 RESTful 端点的路径，并为请求的格式正确分配
    Content-Type 头。
- en: The Serializer style is provided as the only supported style plugin for the
    REST export display. This style plugin only supports row plugins that identify
    themselves as data display types. It expects data from the row plugin to be raw
    so that it can be passed to the appropriate serializer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化样式是作为REST导出显示的唯一支持样式插件提供的。此样式插件仅支持标识为数据显示类型的行插件。它期望从行插件接收原始数据，以便它可以传递给适当的序列化器。
- en: You then have the option of using the data entity or data field row plugins.
    Instead of returning a render array from their render method, they return raw
    data that will be serialized into the proper format.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你有使用数据实体或数据字段行插件的选择。它们不是从它们的渲染方法返回渲染数组，而是返回将被序列化为正确格式的原始数据。
- en: With the row plugins returning raw format data and the data serialized by the
    style plugin, the display plugin will then return the response that is converted
    into the proper format via the Serialization module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行插件返回原始格式数据，以及通过样式插件序列化的数据，显示插件将返回通过序列化模块转换为正确格式的响应。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Views provide a way to deliver specific RESTful endpoints. We will explore some
    additional features in the next recipe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 视图提供了一种提供特定RESTful端点的方式。我们将在下一个菜谱中探索一些额外的功能。
- en: Controlling the key name in JSON output
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制JSON输出中的键名
- en: The Data fields row plugin allows you to configure field aliases. When the data
    is returned to the view, it will have Drupal's machine names. This means that
    custom fields will look something like `field_my_field`, which may not make sense
    to the consumer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字段行插件允许你配置字段别名。当数据返回到视图时，它将具有Drupal的机器名称。这意味着自定义字段看起来可能像`field_my_field`，这可能对消费者来说没有意义。
- en: 'By clicking on Settings next to Fields, you can set aliases in the modal form:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“字段”旁边的设置，你可以在模态表单中设置别名：
- en: '![](img/886a4cce-5590-41f2-a4d8-8a309ff7fb54.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/886a4cce-5590-41f2-a4d8-8a309ff7fb54.png)'
- en: 'When you provide an alias, the fields will match. For example, `user_picture`
    can be changed to `avatar` and the mail key can be changed to `email`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供一个别名时，字段将匹配。例如，`user_picture`可以改为`avatar`，邮件键可以改为`email`：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Controlling access to RESTful Views
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制RESTful视图的访问
- en: When you create a RESTful endpoint with Views, you are not using the same permissions
    created by the RESTful Web Services module. You will need to define the route
    permissions within the view, allowing you to specify specific roles or permissions
    for the request.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用视图创建RESTful端点时，你不会使用RESTful Web服务模块创建的相同权限。你需要在视图中定义路由权限，这样你可以指定特定的角色或权限来请求。
- en: The default GET method provided by the `EntityResource` plugin does not provide
    a way to list entities and allows any entity to be retrieved by an ID. Using Views,
    you can provide a list of entities, limiting them to specific bundles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityResource`插件提供的默认GET方法不提供列出实体的方式，并允许通过ID检索任何实体。使用视图，你可以提供一个实体列表，限制它们到特定的捆绑包。'
- en: Using Views, you can even provide a new endpoint to retrieve a specific entity.
    Using Contextual filters, you can add route parameters and filters to limit and
    validate entity IDs. For example, you may want to expose the article content over
    the API, but not pages.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图，你甚至可以提供一个新端点来检索特定实体。使用上下文过滤器，你可以添加路由参数和过滤器来限制和验证实体ID。例如，你可能想通过API公开文章内容，但不公开页面。
- en: Authentication
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Using the RESTful Web Services module, we define specific supported authentication
    providers for an endpoint. The Drupal core provides a cookie provider, which authenticates
    through a valid cookie, such as your regular login experience. Then, there is
    the HTTP Basic Authentication module to support HTTP authentication headers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful Web服务模块，我们为端点定义特定的支持认证提供者。Drupal核心提供了一个cookie提供者，它通过有效的cookie进行认证，例如你的常规登录体验。然后，还有HTTP基本认证模块来支持HTTP认证头。
- en: There are alternatives that provide more robust authentication methods. With
    cookie-based authentication, you will need to use CSRF tokens to prevent unrequested
    page loads by an unauthorized party. When you use the HTTP authentication, you
    are sending a password for each request in the request header.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有提供更健壮认证方法的替代方案。使用基于cookie的认证，你需要使用CSRF令牌来防止未经授权的第三方加载未请求的页面。当你使用HTTP认证时，你是在请求头中发送每个请求的密码。
- en: '**OAuth** is a popular and open authorization framework. It is a proper authentication
    method that uses tokens and not passwords. In this recipe, we will implement the
    Simple OAuth module to provide OAuth 2.0 authentication for GET and POST requests.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**是一个流行且开放的授权框架。它是一种使用令牌而不是密码的正确认证方法。在本食谱中，我们将实现简单OAuth模块以提供GET和POST请求的OAuth
    2.0认证。'
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you are not familiar with OAuth or OAuth 2.0, it is a standard for authorization.
    The implementation of OAuth revolves around the usage of tokens sent in HTTP headers.
    Refer to the OAuth home page for more information at [http://oauth.net/](http://oauth.net/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉OAuth或OAuth 2.0，它是一个授权标准。OAuth的实现围绕在HTTP头中发送的令牌的使用。有关更多信息，请参阅OAuth主页[http://oauth.net/](http://oauth.net/)。
- en: 'By following the *Enabling RESTful interfaces* recipe, you should have the
    **REST UI** module added to your Drupal installation using Composer. This can
    be done with the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循*启用RESTful接口*食谱，您应该已经使用Composer将**REST UI**模块添加到您的Drupal安装中。这可以通过以下命令完成：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'First, we must add the Simple OAuth module to our Drupal site:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将简单OAuth模块添加到我们的Drupal站点：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Go to Extend from the administrative toolbar and install the following Web
    Services modules: Serialization, RESTful Web Services, REST UI, and Simple OAuth:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理工具栏转到扩展并安装以下网络服务模块：序列化、RESTful网络服务、REST UI和简单OAuth：
- en: '![](img/389b25fd-4aba-40de-be34-07c45e9f57bc.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/389b25fd-4aba-40de-be34-07c45e9f57bc.png)'
- en: Go to Configuration and click on REST under Web Services to configure the available
    endpoints.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往配置，点击网络服务下的REST进行配置可用的端点。
- en: 'Click on the Enable button for the Content row:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容行的启用按钮：
- en: '![](img/9976d9f5-9df6-4e82-99ea-43dc82563d88.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9976d9f5-9df6-4e82-99ea-43dc82563d88.png)'
- en: With the endpoint enabled, it must be configured. Check the GET and POST methods
    checkbox to allow GET and POST requests. Then, check the json checkbox so that
    data can be returned as JSON. Check the oauth2 checkbox and then save it.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点启用后，必须进行配置。勾选GET和POST方法复选框以允许GET和POST请求。然后，勾选json复选框以便数据可以以JSON格式返回。勾选oauth2复选框然后保存。
- en: 'Before we can configure the Simple OAuth module, we have to generate a pair
    of keys to encrypt the OAuth tokens. Generate these in a path accessible to Drupal,
    but not available through the web server:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们配置简单OAuth模块之前，我们必须生成一对密钥来加密OAuth令牌。在Drupal可访问但通过Web服务器不可用的路径中生成这些密钥：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the keys generated, go to the Configuration page and then to Simple OAuth.
    Enter in the paths to your private and public key that were just generated and
    click on Save configuration:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成密钥后，转到配置页面，然后转到简单OAuth。输入刚刚生成的私有和公共密钥的路径，然后点击保存配置：
- en: '![](img/b43152d1-044a-4fc9-9d09-d76b01e9b2df.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b43152d1-044a-4fc9-9d09-d76b01e9b2df.png)'
- en: From the Simple OAuth configuration form, click on Add client. Provide a label
    for the client and select the Administrator scope. Click on Save to create the
    client.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从简单的OAuth配置表单中，点击添加客户端。为客户端提供一个标签并选择管理员范围。点击保存以创建客户端。
- en: 'Next, we will generate a token through the `/oauth/token` endpoint. You will
    need the ID from the client you just created. We must pass `grant_type`, `client_id`,
    `username`, and `password`. The `grant_type` is `password`, the `client_id` is
    the ID from the created client, and then the `username` and `password` of the
    account you wish to use:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过`/oauth/token`端点生成令牌。您需要您刚刚创建的客户端的ID。我们必须传递`grant_type`、`client_id`、`username`和`password`。`grant_type`是`password`，`client_id`是创建的客户端的ID，然后是您希望使用的账户的用户名和密码：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At the time of writing this book, the endpoint did not accept a JSON body, but
    only form-encoded values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，端点不接受JSON正文，而只接受表单编码的值。
- en: The response will contain an `access_token` property. This is to be used as
    your token when making API requests.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将包含一个`access_token`属性。这将在进行API请求时用作您的令牌。
- en: 'Request a node over REST with the `Authorization: Bearer [token]` header:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用`Authorization: Bearer [token]`头请求REST中的节点：'
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: The Simple OAuth module is built using the `League\OAuth2` PHP library, a community
    de facto library for OAuth2 implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 简单OAuth模块是使用`League\OAuth2` PHP库构建的，这是一个OAuth2实现的社区事实库。
- en: In a typical authentication request, there is an authentication manager that
    uses the `authentication_collector` service to collect all the tagged authentication
    provider servers. Based on the provider's set priority, each service is invoked
    to check whether it applies to the current request. Each applied authentication
    provider then gets invoked to see whether the authentication is invalid.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的身份验证请求中，有一个身份验证管理器，它使用 `authentication_collector` 服务来收集所有标记的身份验证提供者服务器。根据提供者设置的优先级，每个服务被调用以检查它是否适用于当前请求。然后，每个适用的身份验证提供者被调用以查看身份验证是否无效。
- en: For the RESTful Web Services module, the process is more explicit. The providers
    identified in the `supported_auth` definition for the endpoint are the only services
    that run through the *applies* and *authenticates* process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 RESTful 网络服务模块，过程更为明确。在端点的 `supported_auth` 定义中标识的提供者是唯一经过 `applies` 和 `authenticates`
    过程的服务。
- en: There's more…
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will explore more information on working with authentication providers and
    the RESTful Web Services module in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探索更多关于与身份验证提供者和 RESTful 网络服务模块一起工作的信息。
- en: Authentication provider services
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证提供者服务
- en: 'When working with the RESTful Web Services module endpoints, the `supported_auth`
    values reference services tagged with `authentication_provider`. Out of the box,
    Drupal supports cookie authentication. The following code is provided by the `basic_auth`
    module to support the HTTP header authentication:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 RESTful 网络服务模块端点一起工作时，`supported_auth` 值引用了带有 `authentication_provider` 标签的服务。默认情况下，Drupal
    支持cookie身份验证。以下代码由 `basic_auth` 模块提供，以支持 HTTP 头部身份验证：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An authentication provider can be created by creating a class in your module's
    `Authentication\Provider` namespace and implementing the `\Drupal\Core\Authentication\AuthenticationProviderInterface`
    interface. Then, register the class as a service in your module's `services.yml`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在模块的 `Authentication\Provider` 命名空间中创建一个类并实现 `\Drupal\Core\Authentication\AuthenticationProviderInterface`
    接口来创建身份验证提供者。然后，将类作为服务注册到模块的 `services.yml` 文件中。
- en: Page cache request policies and authenticated Web service requests
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面缓存请求策略和已验证的 Web 服务请求
- en: When working with data that expects authenticated users, the authentication
    service provider should also provide a page cache service handler. Services that
    are tagged with `page_cache_request_policy` have the ability to check whether
    the content is cached or not. This prevents authorization requests from being
    cached.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理期望有已验证用户的数据时，身份验证服务提供者还应提供页面缓存服务处理程序。标记为 `page_cache_request_policy` 的服务有权检查内容是否已缓存。这防止了授权请求被缓存。
- en: 'The following code is taken from the `basic_auth` module:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘自 `basic_auth` 模块：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `\Drupal\basic_auth\PageCache\DisallowBasicAuthRequests` class implements
    the `\Drupal\Core\PageCache\RequestPolicyInterface` interface. The check method
    allows the page cache policy to explicitly deny or remain neutral on a page's
    ability to be cached. The `basic_auth` module checks whether the default authentication
    headers are present. For the `simple_oauth` module, it checks whether a valid
    token is present.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\basic_auth\PageCache\DisallowBasicAuthRequests` 类实现了 `\Drupal\Core\PageCache\RequestPolicyInterface`
    接口。检查方法允许页面缓存策略明确拒绝或保持中立，以确定页面是否可以缓存。`basic_auth` 模块检查默认身份验证头是否存在。对于 `simple_oauth`
    模块，它检查是否存在有效的令牌。'
- en: This is an important security measure if you are implementing your own authentication
    services.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在实现自己的身份验证服务，这是一个重要的安全措施。
- en: A page cache policy service can be implemented by creating a class in your module's
    `PageCache` namespace and implementing the `\Drupal\Core\PageCache\ResponsePolicyInterface`
    interface. Then, we need to register the class as a service in your module's `services.yml`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在模块的 `PageCache` 命名空间中创建一个类并实现 `\Drupal\Core\PageCache\ResponsePolicyInterface`
    接口来实现页面缓存策略服务。然后，我们需要将类作为服务注册到模块的 `services.yml` 文件中。
- en: The IP Authentication provider
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 身份验证提供者
- en: Some APIs that implement server-to-server communication will authenticate using
    IP address whitelists. For this use case, we have the IP Consumer Auth module.
    Whitelisted IP addresses are controlled by a form that saves a configuration value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现服务器到服务器通信的 API 将使用 IP 地址白名单进行身份验证。对于此用例，我们有 IP 消费者身份验证模块。白名单 IP 地址由一个保存配置值的表单控制。
- en: If an IP address is whitelisted, the user is authenticated as an anonymous user.
    While this may not be recommended for POST, PATCH, and DELETE requests, it can
    provide a simple way to control specific GET endpoints in a private network.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 IP 地址被列入白名单，用户将被认证为匿名用户。虽然这可能在 POST、PATCH 和 DELETE 请求中不被推荐，但它可以提供一个简单的方法来控制私有网络中的特定
    GET 端点。
- en: You can download IP Consumer Auth from its project page at [https://www.drupal.org/project/ip_consumer_auth](https://www.drupal.org/project/ip_consumer_auth).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从其项目页面下载 IP 消费者身份验证：[https://www.drupal.org/project/ip_consumer_auth](https://www.drupal.org/project/ip_consumer_auth)。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the OAuth Community Site at [http://oauth.net/](http://oauth.net/)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考 OAuth 社区网站：[http://oauth.net/](http://oauth.net/)
- en: Refer to the OAuth module for OAuth 1.0 support at [https://www.drupal.org/project/oauth](https://www.drupal.org/project/oauth)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考支持 OAuth 1.0 的 OAuth 模块：[https://www.drupal.org/project/oauth](https://www.drupal.org/project/oauth)
- en: Refer to the simple OAuth module for OAuth 2.0 support at [https://www.drupal.org/project/simple_oauth](https://www.drupal.org/project/simple_oauth)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考支持 OAuth 2.0 的简单 OAuth 模块：[https://www.drupal.org/project/simple_oauth](https://www.drupal.org/project/simple_oauth)
- en: Refer to the IP Consumer Auth module at [https://www.drupal.org/project/ip_consumer_auth](https://www.drupal.org/project/ip_consumer_auth)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考 IP 消费者身份验证模块：[https://www.drupal.org/project/ip_consumer_auth](https://www.drupal.org/project/ip_consumer_auth)
- en: Using JSON API
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON API
- en: When developing a backend API for frontend consumers, there is often much debate
    on naming conventions and returned value structures. In comes `{json:api}`, an
    open source specification set to standardize and simplify the building of APIs,
    which consume and return JSON payloads. The specification and documentation can
    be found at [http://jsonapi.org/](http://jsonapi.org/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在为前端消费者开发后端 API 时，关于命名约定和返回值结构经常有许多争议。这时出现了 `{json:api}`，这是一个开源规范，旨在标准化和简化 API
    的构建，这些 API 消费和返回 JSON 有效负载。规范和文档可以在 [http://jsonapi.org/](http://jsonapi.org/)
    找到。
- en: For Drupal, there is a community-lead effort to provide a robust JSON API specification
    implementation to turn Drupal into a streamlined API server. This recipe will
    install the JSON API module and show how to enable resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Drupal，有一个由社区主导的努力，旨在提供强大的 JSON API 规范实现，将 Drupal 转换为一个高效的 API 服务器。本食谱将安装
    JSON API 模块并展示如何启用资源。
- en: Just like the RESTful Web Services module provided by Drupal core, the JSON
    API module does not provide a user interface. It also enables all content to be
    available over the API automatically (given that users have permissions configured
    to access the endpoint.) The JSON API Extra module changes that, and this will
    be covered in the *There's more...* section of this recipe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Drupal 核心提供的 RESTful Web 服务模块一样，JSON API 模块不提供用户界面。它还自动使所有内容可通过 API 获取（假设用户已配置权限以访问端点。）JSON
    API Extra 模块改变了这一点，这将在本食谱的 *还有更多...* 部分中介绍。
- en: The JSON API module can be found at [https://www.drupal.org/project/jsonapi](https://www.drupal.org/project/jsonapi)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API 模块可以在 [https://www.drupal.org/project/jsonapi](https://www.drupal.org/project/jsonapi)
    找到。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create sample content using the `Article` content type provided by the standard
    Drupal installation. This will make testing the GET methods much easier.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准 Drupal 安装提供的 `Article` 内容类型创建示例内容。这将使测试 GET 方法变得容易得多。
- en: When making requests, all endpoint paths are prefixed with `jsonapi`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行请求时，所有端点路径都以前缀 `jsonapi` 开头。
- en: How to do it
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'First, we must add the JSON API module to our Drupal site:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将 JSON API 模块添加到我们的 Drupal 网站中：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Install the JSON API and Serialization module. Once the module is installed,
    the API endpoints will be active.:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 JSON API 和序列化模块。一旦模块安装完成，API 端点将处于活动状态：
- en: '![](img/d3e32ab7-f92b-44c0-9f8d-32120d746e96.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3e32ab7-f92b-44c0-9f8d-32120d746e96.png)'
- en: To perform a request, you must pass an Accept header with the value `application/vnd.api+json`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行请求时，必须传递一个值为 `application/vnd.api+json` 的 Accept 头部。
- en: 'For the JSON API specification, every resource must have a unique type name,
    and JSON API derives this from the entity type and its bundle. The endpoint for
    retrieving Article nodes will be:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 JSON API 规范，每个资源都必须有一个唯一的类型名称，JSON API 从实体类型及其包中推导出此名称。检索文章节点的端点将是：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The entire request can be executed with the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个请求可以使用以下命令执行：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The response will resemble the following. The content values will be in the
    attributes property:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将类似于以下内容。内容值将在属性属性中：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The JSON API module implements the `{json:api}` specification. Like the RESTful
    Web Services module provided by Drupal core, it exposes data over various endpoints.
    It builds on top of Drupal's existing routing system to work with non-HTML formats.
    The major difference is it follows a community-driven specification on how the
    data should be formatted, linked, filtered, sorted, and more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API 模块实现了 `{json:api}` 规范。类似于 Drupal 核心提供的 RESTful Web 服务模块，它通过各种端点公开数据。它建立在
    Drupal 现有的路由系统之上，以处理非 HTML 格式。主要区别在于它遵循一个社区驱动的规范，该规范决定了数据应该如何格式化、链接、过滤、排序等。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Next, we'll cover filtering, paging, sorting, and the JSON API Extras module.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍过滤、分页、排序和 JSON API Extras 模块。
- en: Paginating, filtering, and sorting requests
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页、过滤和排序请求
- en: The request in the recipe will return all available Article nodes in the system.
    These can be paginated, filtered, and sorted. Each of these operations is done
    through query parameters, which contain an array of values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱中的请求将返回系统中所有可用的文章节点。这些可以分页、过滤和排序。这些操作都是通过查询参数完成的，其中包含一个值数组。
- en: Pagination is done by appending a `page` query parameter. To limit the request
    to 10 nodes, we would append `?page[limit]=10`. To access the next set of results,
    we would also pass `page[offset]=10`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是通过附加一个 `page` 查询参数来完成的。要限制请求为 10 个节点，我们会在后面附加 `?page[limit]=10`。要访问下一组结果，我们也会传递
    `page[offset]=10`。
- en: 'The following is an example of returning the first and second pages of results:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个返回结果的第一页和第二页的示例：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each request contains a links property; this will also contain the next and
    previous links when using a paginated result.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都包含一个链接属性；当使用分页结果时，它也将包含下一页和上一页的链接。
- en: 'Filtering is done by appending a `filter` query parameter. The following is
    an example for requesting all nodes that have been promoted to the front page:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过附加一个 `filter` 查询参数来进行过滤。以下是一个请求所有被提升到首页的节点的示例：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each filter is defined by a name--in the preceding example, it is `promoted`.
    The filter then takes `path`, which is the field to filter on. The `value` and
    `operator` decide how to filter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过滤器都由一个名称定义--在前面的示例中，它是 `promoted`。然后过滤器接受 `path`，这是要过滤的字段。`value` 和 `operator`
    决定了如何过滤。
- en: 'Sorting is the simplest operation. A sort query parameter is added. The field
    name value is the field to sort by, and to sort in descending order, you add a
    minute symbol in front of the field name. The following examples show how to sort
    by the `nid` in ascending and descending order, respectively:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是最简单的操作。添加一个排序查询参数。字段名称值是要排序的字段，如果要按降序排序，则在字段名称前添加一个分钟符号。以下示例分别展示了如何按 `nid`
    升序和降序排序：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Installing the JSON API Extras module
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 JSON API Extras 模块
- en: 'The JSON API Extras module provides a user interface for additional customization.
    The JSON API Extras module should be added to your Drupal installation like all
    other modules, using Composer:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API Extras 模块提供了一个用户界面进行额外的自定义。应像所有其他模块一样，使用 Composer 将 JSON API Extras
    模块添加到您的 Drupal 安装中：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the module is installed in Drupal, you will have the ability to enable
    or disable endpoints, change resource names, alter resource paths, disable fields,
    alias field names, and enhance field outputs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 Drupal 中安装了该模块，您将能够启用或禁用端点、更改资源名称、更改资源路径、禁用字段、别名字段名称以及增强字段输出。
- en: Changing the API path prefix
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 API 路径前缀
- en: The API path prefix can be changed from `jsonapi` to `api` or any other prefix
    using the extras module.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 extras 模块，可以将 API 路径前缀从 `jsonapi` 更改为 `api` 或任何其他前缀。
- en: 'From the administrative toolbar, navigate to Configuration. Under the Web services
    section, click on JSON API Overwrites to customize the JSON API implementation.
    The Settings tab allows modification of the API path prefix:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理工具栏导航到配置。在 Web 服务部分下，单击 JSON API Overwrites 以自定义 JSON API 实现。设置选项卡允许修改 API
    路径前缀：
- en: '![](img/4b4ec93f-c4d3-4312-b274-064987cc096c.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b4ec93f-c4d3-4312-b274-064987cc096c.png)'
- en: Disabling and enhancing returned entity fields
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用和增强返回的实体字段
- en: The JSON API Extras module allows overwriting endpoints automatically exposed
    by the JSON API module. This allows disabling fields from being returned. It also
    allows using enhancers to simplify the structure of a field property.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API Extras 模块允许覆盖 JSON API 模块自动公开的端点。这允许禁用返回字段。它还允许使用增强器来简化字段属性的架构。
- en: From the administrative toolbar, go to Configuration. Under the Web services
    section, click on JSON API Overwrites to customize the JSON API implementation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理工具栏中，转到配置。在 Web 服务部分下，点击 JSON API 覆盖以自定义 JSON API 实现。
- en: 'To disable an endpoint, click on Overwrite on any endpoint. Check the Disabled
    checkbox to turn off that specific endpoint:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用端点，请点击任何端点的“覆盖”。勾选“禁用”复选框以关闭该特定端点：
- en: '![](img/467d2d17-7adc-4448-8020-6802ac5546ba.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/467d2d17-7adc-4448-8020-6802ac5546ba.png)'
- en: 'To disable, alias, or use an enhancer, click on Overwrite on any endpoint.
    The checkbox will allow you to prevent a field from being used in the API. The
    enhancers allow you to simplify fields when returned or used in POST/PATCH requests:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用、别名或使用增强器，请点击任何端点的“覆盖”。复选框将允许您防止字段在 API 中使用。增强器允许您在返回或用于 POST/PATCH 请求时简化字段：
- en: '![](img/de9a7553-27da-4a7e-8fca-182561faa36d.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de9a7553-27da-4a7e-8fca-182561faa36d.png)'
- en: In this example, the `created` and `changed` fields will no longer return Unix
    timestamps, but RFC ISO8601-formatted timestamps. The `promote` and `sticky` fields
    will return their value directly, not nested under a `value` property. Finally,
    no revision information fields will be returned.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`created` 和 `changed` 字段将不再返回 Unix 时间戳，而是返回 RFC ISO8601 格式的时间戳。`promote`
    和 `sticky` 字段将直接返回它们的值，而不是嵌套在 `value` 属性下。最后，将不会返回任何修订信息字段。
- en: Contenta CMS
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Contenta CMS
- en: Contenta CMS is a decoupled, API-driven Drupal distribution built using the
    JSON API. It is being built through the same community initiative pushing forward
    the JSON API module. The project's home page can be found at [http://www.contentacms.org/.](http://www.contentacms.org/.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Contenta CMS 是一个解耦的、基于 API 的 Drupal 分发，使用 JSON API 构建。该项目是通过推动 JSON API 模块向前发展的同一社区倡议构建的。项目主页可在
    [http://www.contentacms.org/](http://www.contentacms.org/) 找到。
- en: It provides many preconfigured options, including customizations to default
    endpoints. It also provides Simple OAuth to set up decoupled authentication with
    your frontend consumer and the API backend.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了许多预配置选项，包括对默认端点的自定义。它还提供了简单的 OAuth，以设置与前端消费者和 API 后端的解耦身份验证。
- en: 'On top of delivering a distribution, the community contributors have developed
    various frontend consumers as examples:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供分发的同时，社区贡献者还开发了各种前端消费者作为示例：
- en: '**Angular**: [https://github.com/contentacms/contenta_angular](https://github.com/contentacms/contenta_angular)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular**: [https://github.com/contentacms/contenta_angular](https://github.com/contentacms/contenta_angular)'
- en: '**Vue/Nuxt**: [https://github.com/contentacms/contenta_vue_nuxt](https://github.com/contentacms/contenta_vue_nuxt)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vue/Nuxt**: [https://github.com/contentacms/contenta_vue_nuxt](https://github.com/contentacms/contenta_vue_nuxt)'
- en: '**Ember.js**: [https://github.com/contentacms/contenta_ember](https://github.com/contentacms/contenta_ember)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember.js**: [https://github.com/contentacms/contenta_ember](https://github.com/contentacms/contenta_ember)'
- en: '**Ionic**: [https://github.com/contentacms/contenta_ionic](https://github.com/contentacms/contenta_ionic)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ionic**: [https://github.com/contentacms/contenta_ionic](https://github.com/contentacms/contenta_ionic)'
- en: '**React**: [https://github.com/contentacms/contenta_react](https://github.com/contentacms/contenta_react)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React**: [https://github.com/contentacms/contenta_react](https://github.com/contentacms/contenta_react)'
- en: See also
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: JSON API project page at [https://www.drupal.org/project/jsonapi](https://www.drupal.org/project/jsonapi)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API 项目页面位于 [https://www.drupal.org/project/jsonapi](https://www.drupal.org/project/jsonapi)
- en: JSON API Extras page at [https://www.drupal.org/project/jsonapi_extras](https://www.drupal.org/project/jsonapi_extras)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API Extras 页面位于 [https://www.drupal.org/project/jsonapi_extras](https://www.drupal.org/project/jsonapi_extras)
- en: JSON API module documentation at [https://www.drupal.org/docs/8/modules/json-api/json-api](https://www.drupal.org/docs/8/modules/json-api/json-api)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API 模块文档位于 [https://www.drupal.org/docs/8/modules/json-api/json-api](https://www.drupal.org/docs/8/modules/json-api/json-api)
- en: JSON API module video tutorials at [https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ](https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API 模块视频教程位于 [https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ](https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ)
- en: The `{json:api}` specification documentation at [http://jsonapi.org/](http://jsonapi.org/)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{json:api}` 规范文档位于 [http://jsonapi.org/](http://jsonapi.org/)'
