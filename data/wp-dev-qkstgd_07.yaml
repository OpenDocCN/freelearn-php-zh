- en: Managing Custom Post Types and Processing Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理自定义帖子类型和处理表单
- en: In web development, we use Model-View-Controller architecture to separate different
    aspects of the sites into their own layers. The Model layer is intended to manage
    the data and the business logic of the application. In WordPress development,
    it's difficult to use such architecture in its original form. However, modeling
    data and logic is important for any kind of a website. So, we use built-in custom
    post types, and custom forms to manage the data capturing process in WordPress.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发中，我们使用模型-视图-控制器（Model-View-Controller）架构将网站的不同方面分离到各自的层中。模型层旨在管理应用程序的数据和业务逻辑。在WordPress开发中，很难使用这种架构的原生形式。然而，对数据和逻辑进行建模对任何类型的网站都是重要的。因此，我们使用内置的自定义帖子类型和自定义表单来管理WordPress中的数据捕获过程。
- en: In this chapter, we are going to explore the importance and use of custom post
    type features in custom development tasks. We will be building a new custom post
    type to handle the properties in a real estate listing website, while using the
    most important features such as taxonomies, custom fields, and template loading.
    By default, custom post types features are enabled in the backend, and hence we
    explore the process of using custom forms in the frontend for data management.
    Finally, we look at the advantages and disadvantages of custom post types and
    custom forms in development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨自定义帖子类型特征在自定义开发任务中的重要性及其应用。我们将构建一个新的自定义帖子类型来处理房地产列表网站中的属性，同时使用最重要的功能，如分类法、自定义字段和模板加载。默认情况下，自定义帖子类型功能在后台已启用，因此我们将探索在前端使用自定义表单进行数据管理的过程。最后，我们来看看自定义帖子类型和自定义表单在开发中的优缺点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to custom post types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义帖子类型简介
- en: Building object-oriented plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建面向对象的插件
- en: Building custom post types for properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为属性构建自定义帖子类型
- en: Introduction to form management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单管理简介
- en: Building and using custom forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和使用自定义表单
- en: Choosing between custom post types and custom forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义帖子类型和自定义表单之间进行选择
- en: Using form management plugins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单管理插件
- en: By the end of this chapter, you will have the ability to develop with custom
    post types and custom forms, as well as know the pros and cons of the two techniques
    in different scenarios.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用自定义帖子类型和自定义表单进行开发，并了解在不同场景下两种技术的优缺点。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装WordPress 4.9.8才能遵循此过程。即使您
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是较新版本的WordPress，所描述的示例应该没有重大问题。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2AyINar](http://bit.ly/2AyINar)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2AyINar](http://bit.ly/2AyINar)'
- en: Introduction to custom post types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义帖子类型简介
- en: Custom post types were introduced in WordPress 3.0 as a solution for managing
    different content needs beyond the default posts. However, the name *custom post
    types* is ambiguous as we may grasp it as a different type of normal posts. Ideally,
    we should consider it as a custom content type, as it provides features flexible
    enough to handle complex content types such as products, properties, and events.
    Custom post types are stored in the `wp_posts` table by default. Prior to the
    introduction of custom post types, we had to use a considerable amount of filters
    and conditions in code to keep different post types separate from each other.
    This might have been a nightmare for many developers when managing a number of
    different content types in the same site.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义帖子类型是在WordPress 3.0中引入的，作为管理超出默认帖子之外的不同内容需求的解决方案。然而，“自定义帖子类型”这个名称是模糊的，因为我们可能会将其理解为一种不同于普通帖子的类型。理想情况下，我们应该将其视为自定义内容类型，因为它提供了足够灵活的功能来处理复杂的内容类型，如产品、属性和事件。自定义帖子类型默认存储在`wp_posts`表中。在自定义帖子类型引入之前，我们必须在代码中使用大量的过滤器和条件来保持不同的帖子类型彼此分离。当在同一个网站上管理多种不同内容类型时，这可能会让许多开发者感到头疼。
- en: 'Introduction of custom post types has dramatically expanded the capabilities
    of WordPress as a framework for developing sites with advanced data requirements
    and logic. Modern themes and plugins have utilized these features to its maximum
    potential. Let’s take a look at some of the popular plugins that run based on
    custom post types:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义文章类型的引入极大地扩展了WordPress作为开发具有高级数据需求和逻辑的网站的框架的能力。现代主题和插件已经充分利用了这些功能。让我们看看一些基于自定义文章类型的流行插件：
- en: '**WooCommerce**: We already looked at the functionality of this plugin in [Chapter
    5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending Plugins with Addons,
    Filters and Actions*. WooCommerce is used as an eCommerce solution for selling
    products. This plugin uses five built-in custom post types for handling **products**,
    **product variations**, **orders**, **refunds**, and **coupons**. Also, we get
    a product specific template design in the frontend for the custom post type. You
    can use this plugin as one of the best examples for understanding the use of custom
    post types.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WooCommerce插件**：我们在[第5章](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml)，*通过插件扩展、过滤器和使用动作*中已经探讨了此插件的功能。WooCommerce被用作电子商务解决方案来销售产品。此插件使用五个内置的自定义文章类型来处理**产品**、**产品变体**、**订单**、**退款**和**优惠券**。此外，我们还获得了针对自定义文章类型的特定产品模板设计。您可以将此插件作为理解自定义文章类型使用的最佳示例之一。'
- en: '**The Events Calendar**: This is a plugin that provides a calendar to create
    and manage your event-related details with built-in custom post types for **events**,
    **organizers**, and **venues**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件日历插件**：这是一个提供日历来创建和管理与事件相关的详细信息的插件，内置了用于**事件**、**组织者**和**场地**的自定义文章类型。'
- en: '**bbPress**: This is one of the most popular forum management plugins with
    built-in custom post types for **forums**, **topics**, and **replies**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bbPress插件**：这是最受欢迎的论坛管理插件之一，内置了用于**论坛**、**主题**和**回复**的自定义文章类型。'
- en: As you can see, many popular plugins use multiple custom post types to build
    the plugin features. Using custom post types considerably simplifies the process,
    as well as makes plugins compatible with WordPress core features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，许多流行的插件使用多个自定义文章类型来构建插件功能。使用自定义文章类型大大简化了过程，同时也使插件与WordPress核心功能兼容。
- en: Why do we use custom post types for modeling data?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们使用自定义文章类型来建模数据？
- en: 'The custom post type was a great addition to WordPress. But, we need to understand
    how it became so popular in such a short time span. The main reason is the ability
    to capture, store, and display advanced data needs without requiring considerable
    development effort. Let''s take a look at the main features offered by custom
    post types to reduce the development time. In less than twenty lines of code,
    we can get a fully functional custom post type with all the following features:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义文章类型是WordPress的一个伟大补充。但是，我们需要了解它如何在如此短的时间内变得如此受欢迎。主要原因是可以捕获、存储和显示高级数据需求，而不需要大量的开发工作。让我们看看自定义文章类型提供的主要功能，以减少开发时间。在不到二十行代码的情况下，我们可以获得一个具有以下所有功能的完全功能的自定义文章类型：
- en: '**Creating and updating data**: Once a new custom post type is added, we get
    a screen for adding and editing data, similar to the normal post screens. The
    main content details are saved automatically with a click of a button, and hence
    we can avoid the need for building our own custom screens with forms. Consider
    the following screenshot, highlighting the built-in features:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和更新数据**：一旦添加了新的自定义文章类型，我们就会得到一个用于添加和编辑数据的屏幕，类似于正常的文章屏幕。主要内容细节会自动保存，只需点击一下按钮，因此我们可以避免需要构建自己的带有表单的自定义屏幕。考虑以下截图，突出显示内置功能：'
- en: '![](img/93f48a31-5122-45e9-8506-66bfab7fdc4e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93f48a31-5122-45e9-8506-66bfab7fdc4e.png)'
- en: '**Flexible data list**: Usually, building a data list with pagination requires
    considerable development time. With custom post types, we get a built-in list
    for each custom post type with pagination, search, filter, and delete capabilities.
    Also, we can easily change the database query to filter and display the default
    data list. Apart from these features, we also get a dropdown called Bulk Actions,
    where we can execute built-in functionality on multiple records of a single custom
    post type. The most important feature is the ability to add our own actions and
    execute them on multiple records with a minimum custom code. Consider the following
    screenshot, highlighting the built-in features:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的数据列表**：通常，构建具有分页的数据列表需要相当的开发时间。使用自定义文章类型，我们为每个自定义文章类型获得内置的列表，具有分页、搜索、过滤和删除功能。此外，我们可以轻松更改数据库查询以过滤和显示默认数据列表。除了这些功能之外，我们还获得一个名为“批量操作”的下拉菜单，其中我们可以对单个自定义文章类型的多个记录执行内置功能。最重要的功能是能够添加我们自己的操作并在多个记录上以最少的自定义代码执行它们。 考虑以下截图，突出显示内置功能：'
- en: '![](img/684b7bda-8494-42fd-8a61-be06a6c068fb.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/684b7bda-8494-42fd-8a61-be06a6c068fb.png)'
- en: '**Built-in URL structure**: We get a default URL structure for managing all
    screens of each custom post type. We can easily change the built-in URL structure
    while creating the custom post type. So, we can avoid the time needed for setting
    up our own URL structure and conditionally managing different screens.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置URL结构**：我们为每个自定义文章类型的所有屏幕获取默认的URL结构。在创建自定义文章类型时，我们可以轻松地更改内置的URL结构。因此，我们可以避免设置自己的URL结构以及条件性地管理不同屏幕所需的时间。'
- en: '**Custom field management**: We can use the default custom fields feature of
    WordPress posts, where we can define a key and a value for each field. When we
    want more control over the custom fields, metaboxes can be used to add and manage
    custom fields in less development effort, compared to developing custom fields
    from scratch.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义字段管理**：我们可以使用WordPress文章的默认自定义字段功能，其中我们可以为每个字段定义一个键和一个值。当我们想要对自定义字段有更多控制时，可以使用元框（metaboxes）以比从头开始开发自定义字段更少的开发工作量来添加和管理自定义字段。'
- en: '**Data categorization**: Custom post types provides built-in taxonomy support
    for categorizing records of each post type. We have the ability to categorize
    new custom post type data as hierarchical categories or flat type tags based on
    the requirements. Apart from filtering, we also get default templates for these
    categorization pages. So, the data categorization process is extremely simple
    compared to usual custom development.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分类**：自定义文章类型为每个文章类型的记录提供内置的分类支持。根据需求，我们有能力将新的自定义文章类型数据分类为层次分类或平面标签。除了过滤之外，我们还获得这些分类页面的默认模板。因此，与通常的自定义开发相比，数据分类过程极其简单。'
- en: '**Built-in templates**: Building templates and displaying the data requires
    a considerable development effort. By default, custom post types use the built-in
    templates of the theme, and hence we don’t require any effort to display the data
    in basic form. Even with advanced requirements, we can just duplicate the default
    template and adjust it with minimum effort to include our design elements or custom
    data.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置模板**：构建模板并显示数据需要相当的开发工作量。默认情况下，自定义文章类型使用主题的内置模板，因此我们不需要做任何努力就可以以基本形式显示数据。即使对于高级需求，我们也可以简单地复制默认模板，并花费最少的工作量来调整它，以包含我们的设计元素或自定义数据。'
- en: These reasons may give you an idea about how custom post types became such a
    valuable feature in WordPress. Now, it's time to understand the process of using
    and developing custom solutions with these features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因可能让你对自定义文章类型如何在WordPress中成为如此有价值的功能有所了解。现在，是时候了解使用和开发这些功能的自定义解决方案的过程了。
- en: Building an object-oriented plugin
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建面向对象的插件
- en: 'Up to this point, we created several plugins in previous chapters. However,
    we used the procedural approach, where we define the necessary hooks and functions
    directly inside the main plugin file or sub-files. As the website or application
    gets complex, we will have a hard time managing the development with the procedural method.
    So, we need a way to use best development practices and modularize the code into
    necessary classes. In this section, we are going to look at the basic structure
    for creating a plugin with object-oriented concepts. Let''s consider the following
    code for the OOP-based plugin structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在前面的章节中创建了几个插件。然而，我们使用了过程式方法，直接在主插件文件或子文件中定义必要的钩子和函数。随着网站或应用的复杂化，我们将很难使用过程式方法管理开发。因此，我们需要一种方法来使用最佳开发实践并将代码模块化到必要的类中。在本节中，我们将查看使用面向对象概念创建插件的基结构。让我们考虑以下基于OOP的插件结构代码：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: WordPress doesn't provide a recommended method or boilerplate to build the plugins
    using the object oriented method. So, it's the choice of the developers to use
    a technique that better suits them. The preceding structure is used by some of
    the exciting plugins, and it's also my personal preference as well. So, you can
    use it as a guide and build a better solution that suits your style.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress没有提供推荐的方法或样板代码来使用面向对象的方法构建插件。因此，这是开发者的选择，使用更适合他们的技术。前面的结构被一些有趣的插件所使用，这也是我的个人偏好。因此，你可以将其用作指南，构建一个更适合你风格的更好解决方案。
- en: We begin by checking the availability of the main plugin class and define the
    main class for the plugin. We will be using the main class to handle all other
    files as well as classes. Then, we define a variable to hold the instance of the
    class and use the `instance` function to generate an object from this class. This
    `static` function and the private `instance` variables make sure that we only
    have one instance of our plugin class. The `instance` function acts as the initialization
    point of our plugin, and hence we can include the necessary function calls, class
    initialization, and hooks inside this function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查主插件类的可用性，并为插件定义主类。我们将使用主类来处理所有其他文件以及类。然后，我们定义一个变量来保存类的实例，并使用`instance`函数从这个类生成一个对象。这个`static`函数和私有的`instance`变量确保我们只有一个插件类的实例。`instance`函数作为我们插件初始化的起点，因此我们可以在这个函数内包含必要的函数调用、类初始化和钩子。
- en: We have two function calls to the `setup_constants` and `includes` functions,
    inside the `instance` function. These functions respectively define the constants
    required for the plugin features and add the plugin files using the PHP `require_once`
    function. As we develop complex plugins, we can have many such functions to separate
    these kinds of basic configurations for the plugin. Then, we can define all the
    `action` and `filter` hooks intended to be used throughout the plugin for configuration
    purposes. Here, we have used two actions for including the scripts and styles
    on the frontend and the backend of the website.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`instance`函数内部，我们调用了两个函数`setup_constants`和`includes`。这些函数分别定义了插件功能所需的常量，并使用PHP的`require_once`函数添加插件文件。随着我们开发复杂的插件，我们可以有许多这样的函数来分离这些基本配置。然后，我们可以定义所有`action`和`filter`钩子，这些钩子旨在在整个插件中用于配置目的。在这里，我们使用了两个动作来在网站的前端和后端包含脚本和样式。
- en: The next section should consist of the object creation for the main classes
    of the plugin. In this scenario, we only have one class, even though we will need
    many classes in advanced plugin development. We need to use the `self::$instance`
    object as we are within the `static` function. Finally, we return the instance
    of the main class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分应该包括插件主类的对象创建。在这个场景中，我们只有一个类，尽管在高级插件开发中我们可能需要许多类。我们需要使用`self::$instance`对象，因为我们处于`static`函数中。最后，我们返回主类的实例。
- en: 'This is the base structure for an object oriented type plugin. We can include
    all the main configurations and generic features within this class and use other
    classes to handle the business logic. Now, we need to initialize the main class
    by using the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是面向对象类型插件的基结构。我们可以在类中包含所有主要配置和通用功能，并使用其他类来处理业务逻辑。现在，我们需要使用以下代码初始化主类：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We execute a callback function on the `plugins_loaded` action to make sure that
    all the plugins are loaded before we initialize the main class of our plugin.
    Also, this will be the location used to check the dependencies between other plugins
    when we are doing integrations or building addons. We call the `instance` function
    of the main `WPQuick_CPT` class and define the resulted instance as a `global`
    object. As you can see, now our plugin is simplified and well-structured compared
    to previous plugins, and only includes the generic things. The site-specific implementations
    will be handled by the other classes. Now, we are ready to develop the plugin
    to handle custom post type features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`plugins_loaded`动作上执行一个回调函数，以确保在我们初始化插件的主类之前所有插件都已加载。此外，这将是我们在进行集成或构建插件时检查其他插件之间依赖关系的位置。我们调用主`WPQuick_CPT`类的`instance`函数并将结果实例定义为`global`对象。正如你所看到的，现在我们的插件与之前的插件相比已经简化并且结构良好，只包含通用事物。特定于站点的实现将由其他类处理。现在，我们已经准备好开发插件以处理自定义帖子类型的功能。
- en: Building custom post types for properties
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为属性构建自定义帖子类型
- en: We can use custom post types to model any data in a wide range of business categories.
    In this chapter, we are going to build a property custom post type for real estate
    listing websites, to illustrate the use of custom post type features. In this
    section, we will develop features for creating custom post types, assigning custom
    taxonomies, and using custom fields.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自定义帖子类型来模拟广泛商业类别中的任何数据。在本章中，我们将为房地产列表网站构建一个属性自定义帖子类型，以说明自定义帖子类型功能的使用。在本节中，我们将开发创建自定义帖子类型、分配自定义分类和使用自定义字段的功能。
- en: Creating property custom post types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建属性自定义帖子类型
- en: 'First, we need to create a separate class for handing property-related features
    as we are using an object oriented plugin. So, create a new directory called **classes**
    inside the main plugin directory, and add a new file called `class-wqcpt-property.php`.
    Then, we need to include this file in our plugin and create an object to initialize
    the features. We need to add the following line inside the `includes` function
    of the `WPQuick_CPT` class to include the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个单独的类来处理与属性相关的功能，因为我们正在使用面向对象的插件。因此，在主插件目录内创建一个名为**classes**的新目录，并添加一个名为`class-wqcpt-property.php`的新文件。然后，我们需要在我们的插件中包含这个文件并创建一个对象以初始化功能。我们需要在`WPQuick_CPT`类的`includes`函数内部添加以下行来包含该文件：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to create an object of this class by using the following line
    of code inside the `instance` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`instance`函数内部使用以下代码行来创建这个类的对象：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we have the ability to add the functionality into this class. WordPress
    provides a function called `register_post_type` to create new custom post types.
    This function takes a wide range of parameters to configure the post type for
    different requirements. This function should be called within the `init` action
    to prevent any unnecessary conflicts. Let''s add the following lines of code to
    the constructor of the `WQCPT_Model_Property` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了将功能添加到这个类的能力。WordPress提供了一个名为`register_post_type`的函数来创建新的自定义帖子类型。这个函数接受广泛的参数来配置满足不同需求的帖子类型。这个函数应该在`init`动作内部调用，以防止任何不必要的冲突。让我们将以下代码行添加到`WQCPT_Model_Property`类的构造函数中：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the first line, we add the post type key into a class variable to be reused
    inside all functions. Then, we use the `init` action to call the `create_property_post_type`
    function for creating a new post type. Since we are using a class, we need to
    call the function on a class object by using the `$this` instance. Now, we can
    take a look at the implementation of the `create_property_post_type` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将帖子类型键添加到一个类变量中以便在所有函数内部重用。然后，我们使用`init`动作来调用`create_property_post_type`函数以创建一个新的帖子类型。由于我们使用的是类，我们需要通过使用`$this`实例来在类对象上调用该函数。现在，我们可以看看`create_property_post_type`函数的实现：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We begin the function by defining the necessary variables for post type and
    labels. The next part of the code contains the labels array. We need to define
    each label, as WordPress will use the **Post** as the default label for all entries.
    It''s not ideal to show the **Post** in messages when we are actually working
    with **Properties**. The next code section contains list of arguments for creating
    the post type. Let''s discuss the most important settings and their role:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义用于帖子类型和标签的必要变量开始函数。代码的下一部分包含标签数组。我们需要定义每个标签，因为WordPress将使用**帖子**作为所有条目的默认标签。当我们实际上正在处理**属性**时，在消息中显示**帖子**并不理想。下一段代码包含创建帖子类型的参数列表。让我们讨论最重要的设置及其作用：
- en: '**Hierarchical**: Defines whether the new post type will act as a page or post.
    WordPress pages provides hierarchical capabilities where we can define parent
    pages, whereas posts has no hierarchy.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层**：定义新帖子类型将作为页面还是帖子使用。WordPress页面提供了分层功能，我们可以定义父页面，而帖子没有分层。'
- en: '**Supports**: This setting defines the allowed fields and features for the
    new post type. We have enabled post title and content for properties. We can also
    use values such as author, thumbnail, excerpt, trackbacks, custom-fields, comments,
    revisions, page-attributes, and post-formats for different features.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：此设置定义了新帖子类型允许的字段和功能。我们已经为属性启用了帖子标题和内容。我们还可以使用作者、缩略图、摘要、引用、自定义字段、评论、修订、页面属性和帖子格式等值来为不同功能使用。'
- en: '**Public**: Defines how the new post type is visible to content creators and
    visitors. We can use `true` or `false` as values. Depending on the value for this
    setting, we will see changes in other settings such as `show_in_menu`, `show_ui`,
    and `exclude_from_search`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开**：定义新帖子类型对内容创建者和访客的可见性。我们可以使用`true`或`false`作为值。根据此设置的值，我们将看到`show_in_menu`、`show_ui`和`exclude_from_search`等其他设置中的变化。'
- en: '**Rewrite**: Defines the rewrite rules status or settings for the post type.
    By default, it uses `$post_type` as a slug. We can modify it by using a custom
    slug.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写**：定义帖子类型的重写规则状态或设置。默认情况下，它使用`$post_type`作为slug。我们可以通过使用自定义slug来修改它。'
- en: More details about the available settings and their role in different combinations
    can be identified by using the documentation at [https://codex.wordpress.org/Function_Reference/register_post_type.](https://codex.wordpress.org/Function_Reference/register_post_type)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用[https://codex.wordpress.org/Function_Reference/register_post_type](https://codex.wordpress.org/Function_Reference/register_post_type)上的文档，可以识别有关可用设置及其在不同组合中的作用详情。
- en: Finally, we call the `register_post_type` function to create the post type by
    passing post type slug and the list of arguments. Now, the property post type
    is registered with WordPress and you will see a new section called Properties
    in the main WordPress menu. You can create a property and view it on the frontend
    using the property link. However, you will get a WordPress 404 page instead of
    the property details page. The reason is WordPress is not aware of the new URL
    structure of newly registered custom post types until we flush the rewrite rules.
    As we discussed in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical
    Usage of WordPress APIs*, we need to either manually update the rewrite rules
    by visiting the WordPress Settings | Permalinks section, or by flushing rewrite
    rules on plugin activation.  You can implement the activation handler for this
    plugin using the technique we discussed in previous chapter. Once rewrite rules
    are flushed, you will be able to see the property details page on the frontend
    with the layout of default posts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过传递帖子类型slug和参数列表来调用`register_post_type`函数创建帖子类型。现在，属性帖子类型已在WordPress中注册，你将在主WordPress菜单中看到一个名为属性的新部分。你可以创建一个属性并在前端使用属性链接查看它。然而，你将得到一个WordPress
    404页面而不是属性详情页面。原因是WordPress不知道新注册的自定义帖子类型的新URL结构，直到我们刷新重写规则。正如我们在[第6章](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml)中讨论的，*WordPress
    API的实际应用*，我们需要手动通过访问WordPress设置 | 永久链接部分来更新重写规则，或者通过插件激活时刷新重写规则。你可以使用我们在上一章中讨论的技术来实现此插件的激活处理程序。一旦刷新了重写规则，你将能够在前端看到具有默认帖子布局的属性详情页面。
- en: Creating the property types taxonomy
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建属性类型分类法
- en: 'WordPress **taxonomies** are a way of grouping posts or custom post types.
    We already looked at taxonomies while discussing database tables and templates
    in previous chapters. In this section, we are going to look at how taxonomies
    fit into custom post types and their implementation. In this scenario, we are
    building a property listing site. We can use taxonomies to group properties based
    on the property type. Let''s begin by adding the following action to the constructor
    of the `WQCPT_Model_Property` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress **分类法**是一种对文章或自定义文章类型进行分组的方法。我们在前几章讨论数据库表和模板时已经了解了分类法。在本节中，我们将探讨分类法如何与自定义文章类型相结合以及它们的实现。在这种情况下，我们正在构建一个房产列表网站。我们可以使用分类法根据房产类型对房产进行分组。让我们首先向`WQCPT_Model_Property`类的构造函数中添加以下操作：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As with custom post types, we have to use the `init` action to register taxonomies
    for WordPress. Let''s consider the implementation of the `create_property_custom_taxonomies`
    function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义文章类型一样，我们必须使用`init`操作来为WordPress注册分类法。让我们考虑`create_property_custom_taxonomies`函数的实现：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We start the function by defining the taxonomy and the necessary labels, similar
    to the custom post types. Then, we can call the `register_taxonomy` function with
    the necessary parameters to create the taxonomy for property types. Let''s take
    a look at the parameters in detail:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在函数中定义分类法和必要的标签，类似于自定义文章类型。然后，我们可以使用必要的参数调用`register_taxonomy`函数来创建房产类型的分类法。让我们详细看看这些参数：
- en: '`taxonomy`: This is the first parameter, where we have to pass the name for
    the taxonomy. We can only use lowercase letters and characters. We have specified
    it as `wqcpt_property_type`, with a prefix to make it unique from other plugins.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taxonomy`：这是第一个参数，其中我们必须传递分类法的名称。我们只能使用小写字母和字符。我们将其指定为`wqcpt_property_type`，并使用前缀使其与其他插件区分开来。'
- en: '`object type`: This is the second parameter, where we have to assign the post
    types that will use this taxonomy. In this scenario, we have specified `wqcpt_property`
    as the post type. We can use an array in scenarios where we have multiple post
    types. However, using a taxonomy in multiple post types makes archive pages as
    a mix of different post type entries. It might be difficult to handle archive
    pages with multiple post types due to different designs and data. So, it''s ideal
    to use separate taxonomies for each post type, unless all post types contain similar
    design and data in archive pages.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object type`：这是第二个参数，其中我们必须指定将使用此分类法的文章类型。在这种情况下，我们指定了`wqcpt_property`作为文章类型。在有多种文章类型的情况下，我们可以使用数组。然而，在多个文章类型中使用分类法会使存档页面成为不同文章类型条目的混合。由于设计和数据的不同，处理具有多个文章类型的存档页面可能很困难。因此，理想情况下，为每个文章类型使用单独的分类法，除非所有文章类型的存档页面都包含类似的设计和数据。'
- en: '`arguments`: This is the third parameter where we can pass different settings
    from the list of available options. In this scenario, we have used the **labels**
    for property listing types and **hierarchical** options. The **hierarchical**
    setting defines whether the taxonomy should act as a **tag** or **category**.
    The default value is `false`, making it act as a **tag**. We have used it as a
    **category** by setting it to **true**. There are many other settings similar
    to the custom post type registration process. You can view more details about
    all the available arguments at [https://codex.wordpress.org/Function_Reference/register_taxonomy](https://codex.wordpress.org/Function_Reference/register_taxonomy).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`：这是第三个参数，其中我们可以从可用选项列表中传递不同的设置。在这种情况下，我们使用了房产列表类型的**标签**和**分层**选项。**分层**设置定义了分类法应该作为**标签**还是**类别**。默认值是`false`，使其作为**标签**。我们将其设置为`true`，使其作为**类别**。有许多其他设置类似于自定义文章类型注册过程。您可以在[https://codex.wordpress.org/Function_Reference/register_taxonomy](https://codex.wordpress.org/Function_Reference/register_taxonomy)查看有关所有可用参数的更多详细信息。'
- en: The choice of category against tag for taxonomies depends on your requirements.
    Generally, we use categories when we want to have different sub-levels as well
    as when have a fixed set of primary options. Tags don't provide sub-levels and
    usually use a dynamic set of values to explain the data. In this scenario, property
    listing types have predefined options such as Sale, Rent, and Mortgage. Therefore,
    we choose category over tags for property listing types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类法中类别与标签的选择取决于你的需求。通常，当我们想要有不同级别的子类别以及有一个固定的主要选项集时，我们会使用类别。标签不提供子级别，通常使用动态值集来解释数据。在这种情况下，房产列表类型有预定义的选项，如销售、租赁和抵押。因此，我们选择类别而不是标签来表示房产列表类型。
- en: Once this code is used, you will see a new taxonomy added to the Property menu.
    You can create properties and assign property listing types to categorize the
    properties based on your needs. In real-world requirements, you have to match
    the taxonomy needs of each custom post type with categories or tags depending
    on the functionality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用此代码，你将看到在房产菜单中添加了一个新的分类法。你可以创建房产，并根据需要将房产列表类型分配给分类，以对房产进行分类。在实际需求中，你必须根据功能将每个自定义帖子类型的分类法需求与分类或标签相匹配。
- en: Managing custom fields for custom post types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理自定义帖子类型的自定义字段
- en: 'In normal posts, we rarely use custom fields as the primary feature is displaying
    content in the WordPress editor along with featured images, tags, and categories.
    However, custom post type implementations require a considerable amount of data
    beyond the content in the WordPress editor. So, we need a way to handle the custom
    data for each custom post type. We can use the default post custom fields feature
    to store the data in the `wp_postmeta` table. Let''s consider the custom field
    requirements of a property listing site:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规帖子中，我们很少使用自定义字段，因为主要功能是在WordPress编辑器中显示内容，包括特色图片、标签和分类。然而，自定义帖子类型实现需要比WordPress编辑器中的内容更多的数据。因此，我们需要一种方法来处理每个自定义帖子类型的自定义数据。我们可以使用默认的帖子自定义字段功能，将数据存储在`wp_postmeta`表中。让我们考虑一个房产列表网站的自定义字段需求：
- en: The property listing sites require a large amount of custom data, along with
    the property title and the main property content through the WordPress editor.
    We can match some of the property data such as property listing type as categories.
    However, the majority of the data needs to be handled using custom fields. Such
    data includes fields such as city, property type, area, price, year, property
    plans, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 房产列表网站需要大量的自定义数据，包括通过WordPress编辑器提供的房产标题和主要房产内容。我们可以将一些房产数据，如房产列表类型，匹配为分类。然而，大部分数据需要通过自定义字段来处理。这些数据包括城市、房产类型、面积、价格、年份、房产规划等字段。
- en: 'In this section, we are going to add some custom property fields to understand
    the process of adding and using custom fields in custom post types. Let''s start
    by adding a metabox to define custom fields similar to the technique we used in
    the *post attachments* plugin. We need to update the constructor of `WQCPT_Model_Property`
    with the following action:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一些自定义房产字段，以了解在自定义帖子类型中添加和使用自定义字段的过程。让我们首先添加一个元框来定义自定义字段，类似于我们在*帖子附件*插件中使用的技术。我们需要更新`WQCPT_Model_Property`构造函数，添加以下操作：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have to define the metabox and implement the function for displaying
    the content of the metabox using the following code inside the `WQCPT_Model_Property`
    class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义元框，并在`WQCPT_Model_Property`类内部使用以下代码实现显示元框内容的函数：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We already discussed the use of the `add_meta_box` function in the post attachments
    plugin and how to use a callback function to generate the content. In the post
    attachments plugin, we used HTML within PHP variables to generate the output.
    This is not ideal in large projects as it's hard to manage the output within quotes
    as well as provide extendable capabilities for templates. In the MVC pattern,
    we use a separate layer for the template called **Views**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在帖子附件插件中使用`add_meta_box`函数以及如何使用回调函数生成内容。在帖子附件插件中，我们使用了PHP变量内的HTML来生成输出。这在大型项目中并不理想，因为很难在引号内管理输出，以及为模板提供可扩展的能力。在MVC模式中，我们使用一个单独的层来表示模板，称为**视图**。
- en: '**Model–view–controller** also known as **MVC** is an architectural pattern
    commonly used for developing user interfaces that divides an application into
    three interconnected parts. The MVC design pattern decouples these major components,
    allowing for efficient code reuse and parallel development.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（Model–view–controller），也称为**MVC**，是一种常用的架构模式，用于开发将应用程序分为三个相互关联部分的用户界面。MVC设计模式解耦了这些主要组件，允许高效地重用代码和并行开发。'
- en: '– Source : [https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: – 来源：[https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller)
- en: Similarly, we have to separate the template code as much as possible to allow
    the possibility of future enhancements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们尽可能地将模板代码分离，以允许未来的增强。
- en: So, we define a global variable called `$template_data` to keep the necessary
    data for the template used in this function. Then, we assign the post type, nonce
    value, and the property data to the `$template_data` array. We use the `wp_postmeta`
    table to store the custom field details for properties. Therefore, we can use
    the `get_user_meta` function to get the existing property values to be passed
    to the template. Initially, these functions will return empty strings until we
    save the data for the first time. Then, we have to use a template loader to load
    the template for property custom fields.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个名为 `$template_data` 的全局变量来保存此函数中使用的模板所需的数据。然后，我们将帖子类型、nonce 值和属性数据分配给
    `$template_data` 数组。我们使用 `wp_postmeta` 表来存储属性的定制字段详情。因此，我们可以使用 `get_user_meta`
    函数来获取要传递给模板的现有属性值。最初，这些函数将返回空字符串，直到我们第一次保存数据。然后，我们必须使用模板加载器来加载属性自定义字段的模板。
- en: In this section, we have used our own template loader. You can refer to the
    `classes/class-wqcpt-template-loader.php` file inside the source code directory
    of our plugin for the implementation. This class is included in the main file
    of our plugin and the object is created within the `instance` function. The basic
    functionality of this class is to include PHP files from the templates directory
    of our plugin. Those developers who are familiar with using Template Engines such
    **Twig**, **Smarty**, **Mustache** in pure PHP projects may think of this as a
    similar technique. However, this is just basic PHP file inclusion with template
    code, and hence doesn't provide any advantages provided by Template Engines.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了我们自己的模板加载器。您可以在我们插件的源代码目录中的 `classes/class-wqcpt-template-loader.php`
    文件中找到其实现。这个类包含在我们插件的主体文件中，并在 `instance` 函数内部创建对象。这个类的基本功能是从我们插件的模板目录中包含 PHP 文件。那些熟悉在纯
    PHP 项目中使用模板引擎如 **Twig**、**Smarty**、**Mustache** 的开发者可能会认为这是一种类似的技术。然而，这仅仅是基本的
    PHP 文件包含和模板代码，因此不提供模板引擎提供的任何优势。
- en: We can use PHP Template Engines in WordPress plugins with bit of additional
    development work. However, most plugins including the popular plugins don't use
    Template Engines and are restricted to template loading as PHP files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 WordPress 插件中使用 PHP 模板引擎，但需要一些额外的开发工作。然而，大多数插件包括流行的插件都没有使用模板引擎，并且仅限于将模板作为
    PHP 文件加载。
- en: In this function, we have called the `ob_start` function to start the template
    loading process. This function is used to switch on output buffering, allowing
    us only to send the necessary content to the browser. Next, we access the object
    of the template loader class by using the global `$wqcpt` instance of our plugin,
    and call the `get_template_part` function. We have passed two strings called `property`
    and `meta` to this function. So, we need to have a template file called `property-meta.php`
    inside the templates directory of our plugin. Then, we use the `ob_get_clean`
    function to get the template and clean the output buffer. Finally, we use the
    `echo` statement to send the content to the browser. The next step in the process
    is to build the template and use the data specified for the template.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们调用了 `ob_start` 函数来开始模板加载过程。这个函数用于开启输出缓冲，允许我们只向浏览器发送必要的内容。接下来，我们通过使用我们插件的全局
    `$wqcpt` 实例来访问模板加载器类的对象，并调用 `get_template_part` 函数。我们向这个函数传递了两个字符串 `property`
    和 `meta`。因此，我们需要在我们的插件模板目录中有一个名为 `property-meta.php` 的模板文件。然后，我们使用 `ob_get_clean`
    函数来获取模板并清理输出缓冲。最后，我们使用 `echo` 语句将内容发送到浏览器。在过程中的下一步是构建模板并使用为模板指定的数据。
- en: Building the property fields template
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建属性字段模板
- en: 'We need to begin the process by creating a new directory called `templates`
    inside the plugin and a new file called `property-meta.php` inside the directory.
    This file should produce the custom fields to capture property data while keeping
    the amount of PHP code and logic to a minimum. Let''s take a look at the implementation
    of the template for property custom fields:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过在插件内部创建一个名为 `templates` 的新目录和一个名为 `property-meta.php` 的新文件来开始这个过程。这个文件应该生成自定义字段以捕获属性数据，同时将
    PHP 代码和逻辑的数量保持在最低。让我们看看属性自定义字段模板的实现：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s understand the implementation of the property fields template using
    the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来理解属性字段模板的实现：
- en: We begin the template by using the global `$template_data` array and extracting
    the values passed as template data.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用全局 `$template_data` 数组并提取作为模板数据传递的值来开始模板。
- en: Then, we have to add the HTML fields for keeping the nonce value and property
    data. In the preceding code, we have limited the fields to city and property type
    for explanation purposes.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须添加HTML字段以保留nonce值和属性数据。在前面的代码中，我们为了说明目的将字段限制为城市和属性类型。
- en: Next, we have to use the data passed from `WQCPT_Model_Property` to load the
    existing values for these fields.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用从`WQCPT_Model_Property`传递的数据来加载这些字段的现有值。
- en: 'Now, our template is ready. You can create or edit a property to see the property
    custom fields, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模板已经准备好了。你可以创建或编辑一个属性来查看属性自定义字段，如下面的截图所示：
- en: '![](img/aef3ed3c-d210-49ee-9810-cc788749a7a0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aef3ed3c-d210-49ee-9810-cc788749a7a0.png)'
- en: We can use this technique to group all the property fields in a single metabox
    or use multiple metaboxes to hold related fields. Also, we can change the location
    and priority of the metabox in the property screen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这项技术将所有属性字段分组到一个单个的元框中，或者使用多个元框来保存相关字段。此外，我们还可以更改元框在属性屏幕中的位置和优先级。
- en: Saving property custom fields
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存属性自定义字段
- en: 'We set up a property as a custom post type and hence the main property details
    will be saved automatically on property publication or update events. However,
    custom field data will not be saved in this process, and hence we need a custom
    implementation to store these data. We have chosen to store the custom field data
    in the `wp_postmeta` table. Let''s look at the process of saving custom fields
    using the WordPress `save_post` action. First, we need to add the following line
    of code to the constructor of the `WQCPT_Model_Property` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性设置为一个自定义文章类型，因此主要属性细节将在属性发布或更新事件上自动保存。然而，自定义字段数据不会在这个过程中保存，因此我们需要一个自定义实现来存储这些数据。我们选择将自定义字段数据存储在`wp_postmeta`表中。让我们看看使用WordPress的`save_post`操作保存自定义字段的过程。首先，我们需要将以下代码行添加到`WQCPT_Model_Property`类的构造函数中：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This action is triggered whenever we create or update a post or custom post
    type. Now, we have to implement the callback function with the following implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作会在我们创建或更新文章或自定义文章类型时触发。现在，我们必须实现以下实现的回调函数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We begin the function by verifying the nonce value assigned to the template.
    We can just return the post ID on verification failures. Next, we have to apply
    another validation for checking the autosave. WordPress autosave features periodically
    save the post content automatically. We don't need to update the custom field
    values on each autosave. So, the validation only allows the function to process
    when the user is manually saving the post. The next validation is the most important
    one since this action is executed on all post types in WordPress.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数开始时验证分配给模板的nonce值。如果验证失败，我们可以直接返回帖子ID。接下来，我们必须进行另一个验证，以检查自动保存。WordPress的自动保存功能会定期自动保存帖子内容。我们不需要在每次自动保存时更新自定义字段值。因此，验证只允许在用户手动保存帖子时处理函数。下一个验证是最重要的，因为这个操作在WordPress的所有文章类型上都会执行。
- en: We have to make sure we use the action only in necessary post types to avoid
    unnecessary conflicts. So, we check if a property is being saved and the current
    user has the permission to save properties by using the `current_user_can` function.
    We didn't assign property-specific capabilities in custom post type registration.
    Therefore, we have to check for the default post edit permission. Once all the
    validations are completed, we can retrieve and sanitize the values from the POST
    request. Finally, we use the `update_post_meta` function to save each property
    field to the `wp_postmeta` table.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保只在必要的文章类型中使用此操作，以避免不必要的冲突。因此，我们检查属性是否正在保存，以及当前用户是否有权限通过使用`current_user_can`函数保存属性。我们没有在自定义文章类型注册中分配属性特定的能力。因此，我们必须检查默认的文章编辑权限。一旦所有验证都完成，我们就可以从POST请求中检索和清理值。最后，我们使用`update_post_meta`函数将每个属性字段保存到`wp_postmeta`表中。
- en: We have the completed the functionality of managing properties from the backend.
    Now, you should be able to create properties with custom field data and display
    that data in edit property screens. Once created, you can view the properties
    from the frontend by using the property link.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了从后端管理属性的功能。现在，你应该能够创建带有自定义字段数据的属性，并在编辑属性屏幕中显示这些数据。一旦创建，你可以通过使用属性链接在前端查看属性。
- en: The theme will use the default `single.php` template to display the property.
    Since we need to display additional property-related fields, we can create a template
    inside the theme or use our plugin to load a template for handling a single property
    page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主题将使用默认的`single.php`模板来显示属性。由于我们需要显示额外的属性相关字段，我们可以在主题内部创建一个模板或使用我们的插件来加载一个用于处理单个属性页面的模板。
- en: 'In this scenario, we used two property fields with basic field types. In real
    applications, you will have to use more complex fields such as dates, maps, searchable
    dropdowns, color pickers, and so on. So, manually building custom fields may become
    an issue for most startup sites with lower development time frames. In such scenarios,
    we can use custom post type plugins that act as a framework for managing custom
    fields without the need for manual coding. Let''s take a look at some of the custom
    post type plugins that offer wide range of custom field types:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了两种基本字段类型的属性字段。在实际应用中，您将不得不使用更复杂的字段，如日期、地图、可搜索的下拉菜单、颜色选择器等。因此，手动构建自定义字段可能成为大多数开发时间较短的初创网站的问题。在这种情况下，我们可以使用充当管理自定义字段框架的自定义帖子类型插件，而无需手动编码。让我们看看一些提供广泛自定义字段类型的自定义帖子类型插件：
- en: '**Toolset Types**: This plugin lets you manage custom post types, custom taxonomies,
    and custom fields without needing any coding. This plugin offers over 20 built-in
    custom field types. Built-in interfaces allow you to manage custom fields by providing
    the necessary settings. More details about the features can be viewed from the
    plugin page at [https://wordpress.org/plugins/types/](https://wordpress.org/plugins/types/).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Toolset Types**：此插件允许您管理自定义帖子类型、自定义分类和自定义字段，而无需任何编码。此插件提供了超过20种内置自定义字段类型。内置界面允许您通过提供必要的设置来管理自定义字段。有关功能的更多详细信息，请查看插件页面[https://wordpress.org/plugins/types/](https://wordpress.org/plugins/types/)。'
- en: '**Pods**: This plugin also offers the same set of features, along with the
    ability to connect multiple custom post types. This plugin offers around 10 custom
    field types to manage the fields of each custom post type using existing screens. More
    details about the features can be viewed from the plugin page at [https://wordpress.org/plugins/pods/](https://wordpress.org/plugins/pods/).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pods**：此插件也提供了相同的功能集，同时还具有连接多个自定义帖子类型的能力。此插件提供了大约10种自定义字段类型，用于管理每个自定义帖子类型的字段，使用现有的屏幕。有关功能的更多详细信息，请查看插件页面[https://wordpress.org/plugins/pods/](https://wordpress.org/plugins/pods/)。'
- en: '**Metabox**: Compared to the other two plugins, this one mainly focuses on
    managing custom fields by allowing you to add them to metaboxes in the post creation
    screen. This plugin provides over 40 built-in field types covering a wide range
    of areas. More details about the features can be viewed from the plugin page at [https://wordpress.org/plugins/types/.](https://wordpress.org/plugins/types/)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元框**：与其他两个插件相比，此插件主要专注于通过允许您在帖子创建屏幕中添加它们到元框来管理自定义字段。此插件提供了超过40种内置字段类型，覆盖了广泛的应用领域。有关功能的更多详细信息，请查看插件页面[https://wordpress.org/plugins/types/](https://wordpress.org/plugins/types/)。'
- en: These plugins are useful for sites that require rapid development process and
    gives less priority for flexibility and the extendability of the features.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件对需要快速开发过程且对功能的灵活性和可扩展性优先级较低的网站很有用。
- en: Limitations of storing data as meta values
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储数据作为元值的限制
- en: We use the post meta table in most occasions to store custom data related to
    different custom post types. However, as the meta tables gets larger, it will
    be difficult to manage all the meta values. The site will get slower, creating
    major performance issues. So, we have to consider this limitation when planning
    the site in the initial stages. Once the posts meta table is used, it's difficult
    to migrate to a custom solution in later stages, especially when we decide to
    use custom post type plugins to manage the custom fields.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在大多数情况下使用帖子元数据表来存储与不同自定义帖子类型相关的自定义数据。然而，随着元数据表变大，管理所有元值将变得困难。网站速度会变慢，从而产生重大的性能问题。因此，在规划网站初期阶段时，我们必须考虑这一限制。一旦使用了帖子元数据表，后期迁移到自定义解决方案将变得困难，尤其是在我们决定使用自定义帖子类型插件来管理自定义字段时。
- en: So, using the post meta table to store custom field data is ideal for small-
    to medium-scale sites where the posts and post meta tables won't get overloaded
    with data. In advanced applications, we should consider using a custom table for
    the custom fields, while using the posts table for the main details of a custom
    post type item.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用帖子元数据表来存储自定义字段数据对于小型到中型规模的网站来说很理想，在这些网站上，帖子元数据表不会因数据过多而超载。在高级应用中，我们应该考虑使用自定义表来存储自定义字段，同时使用帖子表来存储自定义帖子类型项的主要细节。
- en: Introduction to form management
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形式管理简介
- en: The majority of WordPress sites consist a of few pages about the site, services,
    or products while having a blog. Among the rest, a high percentage of sites focus
    on capturing, processing, and displaying user data. So, form management becomes
    an important aspect in WordPress development. The forms are mostly used as a data
    capturing method on the frontend, as we use custom post types to capture data
    in the backend. We can develop our own custom forms in the frontend, or we can
    automate the process of managing forms by using an existing form management plugin.
    The choice between custom forms and form plugins depends on the requirements of
    the site. Let's take a look at the advantages and disadvantages of using these
    two methods.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数WordPress网站由少数关于网站、服务或产品的页面组成，同时拥有一个博客。在其余部分中，高比例的网站专注于捕获、处理和显示用户数据。因此，表单管理成为WordPress开发中的一个重要方面。表单通常用作前端的数据捕获方法，因为我们使用自定义帖子类型在后台捕获数据。我们可以在前端开发自己的自定义表单，或者我们可以通过使用现有的表单管理插件来自动化表单管理的过程。自定义表单和表单插件之间的选择取决于网站的需求。让我们来看看使用这两种方法的优缺点。
- en: '**Development time**: Form plugins provide a rapid development process with
    drag-and-drop form creation, while handling all the form field features through
    configurations. On the other hand, custom forms require considerable development
    effort and the changes to existing fields require modifications in code.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发时间**：表单插件提供了一个快速的开发过程，通过拖放创建表单，并通过配置处理所有表单字段功能。另一方面，自定义表单需要相当的开发努力，并且对现有字段的更改需要修改代码。'
- en: '**Database usage**: Each existing forms plugin is restricted to using the `wp_postmeta`
    table or a single custom table, whereas custom forms can be developed to use either
    technique according to our preference, while keeping different form data in different
    tables.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库使用**：每个现有的表单插件都限制使用`wp_postmeta`表或单个自定义表，而自定义表单可以根据我们的偏好开发以使用这两种技术，同时将不同的表单数据存储在不同的表中。'
- en: '**Extendability**: Building custom forms enables the possibility of keeping
    the features open for future enhancements. On the other hand, we will have to
    work with the limitations of forms plugins when considering the future enhancements
    of advanced sites.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：构建自定义表单使得保持功能开放以供未来增强成为可能。另一方面，在考虑高级网站的增强时，我们将不得不与表单插件的限制作斗争。'
- en: '**Consistency in design**: We can create our own custom form designs to match
    the styles of the theme. However, existing plugins may not provide 100% flexibility
    in modifying the design to match the theme styles.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计一致性**：我们可以创建自己的自定义表单设计以匹配主题的样式。然而，现有的插件可能无法提供100%的灵活性来修改设计以匹配主题样式。'
- en: Due to these reasons, we should carefully choose the development method for
    custom forms depending on the requirements of each site. Once we complete the
    upcoming sections on form management, you will have a better idea about the process
    for making correct decisions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们应该根据每个网站的需求仔细选择自定义表单的开发方法。一旦我们完成了即将到来的关于表单管理的部分，你将对做出正确决策的过程有更好的了解。
- en: Building custom forms in the frontend
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前端构建自定义表单
- en: 'We have several ways of adding forms to the frontend of a WordPress website.
    In this section, we are going to discuss two methods used by popular plugins to
    add forms:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以将表单添加到WordPress网站的前端。在本节中，我们将讨论流行插件用于添加表单的两种方法：
- en: Adding forms using shortcodes
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用短代码添加表单
- en: Loading forms using custom URLs
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义URL加载表单
- en: We will be implementing both techniques, starting with the shortcode method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实施这两种技术，首先从短代码方法开始。
- en: Adding forms using a shortcode
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用短代码添加表单
- en: This is one of the most popular methods used by many popular plugins to add
    data capturing forms to a site. In this method, we use a shortcode to generate
    the HTML for the form. Then, we add the shortcode to a WordPress post or page
    and let users access it through the post or page. This is the ideal technique
    for basic to intermediate level features, where the use of the form doesn't play
    a critical part in the functionality of the site.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最受欢迎的方法之一，许多流行的插件用它来向网站添加数据捕获表单。在这个方法中，我们使用短代码来生成表单的HTML。然后，我们将短代码添加到WordPress文章或页面中，并让用户通过文章或页面访问它。这对于基本到中级水平的功能来说是一个理想的技巧，因为表单的使用并不在网站功能中扮演关键角色。
- en: Using shortcode is one of the simplest methods to add a form. However, shortcodes
    are added to post or page and hence administrators can accidentally delete the
    page or break the shortcode by mistake. Therefore, it should not be used for advanced
    sites where the functionality of shortcode is critical. For example, consider
    a registration form in a basic social network site. The unavailability of the
    registration page for a limited time is not a major issue since the people register
    for free to share their activities. However, consider a registration form in a
    support forum of a site that provides a time-critical service. In such sites,
    unavailability of registration for even few hours is not acceptable and affects
    the user. So, we shouldn't use shortcode-based forms in such sites, or prevent
    modification access to the pages with shortcodes .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短代码是添加表单最简单的方法之一。然而，短代码是添加到文章或页面中的，因此管理员可能会不小心删除页面或错误地破坏短代码。因此，它不应用于短代码功能至关重要的高级网站。例如，考虑一个基本社交网络网站上的注册表单。由于人们免费注册以分享他们的活动，注册页面短暂不可用并不是一个大问题。然而，考虑一个提供时间关键服务的网站的支持论坛上的注册表单。在这样的网站上，即使注册页面仅短暂不可用也是不可接受的，并会影响用户。因此，我们不应该在这样的网站上使用基于短代码的表单，或者防止对带有短代码的页面进行修改访问。
- en: 'In the previous section, we used custom post types to manage the property details
    in the backend. Now, we need to add the property creation capabilities to the
    frontend. Let''s use the following line of code inside the constructor of the
    `WQCPT_Model_Property` class to define a shortcode for the property form:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了自定义文章类型来管理后端中的属性详情。现在，我们需要将属性创建功能添加到前端。让我们在`WQCPT_Model_Property`类的构造函数中使用以下行代码来定义属性表单的短代码：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to implement the callback function to display a property creation
    form in the frontend. Let''s consider the implementation of the `display_property_form`
    function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现回调函数以在前端显示属性创建表单。让我们考虑`display_property_form`函数的实现：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementation of this function is similar to the `display_property_meta_boxes`
    function we used in the backend custom post types. In this scenario, this form
    is only used for property creation and hence we don''t have to pass the existing
    data as template variables. We use a different template called `property-form.php`
    for the frontend custom form. Now, we can have a look at the implementation of
    the `property-form.php` template:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实现与我们在后端自定义文章类型中使用的`display_property_meta_boxes`函数类似。在这种情况下，这个表单仅用于属性创建，因此我们不需要将现有数据作为模板变量传递。我们使用一个不同的模板，称为`property-form.php`，用于前端自定义表单。现在，我们可以看看`property-form.php`模板的实现：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The structure of the template is exactly same as the previous scenario on backend.
    However, we have two additional fields for property title and content, along with
    a form and a submit button. In custom post types, we had the title and content
    as built-in fields. We also used the built-in post form and the Publish or Update
    buttons. On the frontend, we don''t have any built-in features, and hence we have
    to add them manually. Once the shortcode is added to a page, the property creation
    form will look similar to the following screen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的结构与后端的前一个场景完全相同。然而，我们增加了两个额外的字段，用于属性标题和内容，以及一个表单和一个提交按钮。在自定义文章类型中，我们有标题和内容作为内置字段。我们还使用了内置的文章表单和发布或更新按钮。在前端，我们没有任何内置功能，因此我们必须手动添加它们。一旦短代码被添加到页面中，属性创建表单将类似于以下屏幕截图：
- en: '![](img/7063ec2e-ca14-4360-bad5-53269c77972c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7063ec2e-ca14-4360-bad5-53269c77972c.png)'
- en: Now, we come to the final part where we create the property on the submission
    of the form.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了最后的部分，即表单提交时创建属性。
- en: Creating properties using custom forms
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义表单创建属性
- en: 'In backend custom post types, we were only coding the custom field saving part,
    and hence we were able to use the `save_post` action to handle the process. In
    the frontend, we have to build the process from scratch and hence the `init` action
    is the ideal hook for the implementation. Let''s add the following line of code
    to the constructor of our `WQCPT_Model_Property` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端自定义文章类型中，我们只编写了自定义字段保存部分，因此我们可以使用`save_post`动作来处理这个过程。在前端，我们必须从头开始构建这个过程，因此`init`动作是实现的最佳钩子。让我们向我们的`WQCPT_Model_Property`类的构造函数中添加以下代码行：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can take a look at the implementation of the `save_property_form`
    function, as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看`save_property_form`函数的实现，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We begin the function by using an `if` condition to check the availability of
    the Submit button in the frontend post creation request, to make sure our code
    is executed only for the frontend property creation form. Next, we use another
    conditional check for the nonce value and property creation permissions. In the
    custom post types section, we executed the permission check by passing the post
    ID, as we were only saving the custom fields for an already-created property.
    In this scenario, we are creating a property from scratch, and hence we don't
    have a post ID yet. So, we can only check for general post editing permissions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用`if`条件检查前端文章创建请求中提交按钮的可用性开始函数，以确保我们的代码只在前端属性创建表单上执行。然后，我们使用另一个条件检查nonce值和属性创建权限。在自定义文章类型部分，我们通过传递文章ID执行权限检查，因为我们只为已创建的属性保存自定义字段。在这种情况下，我们是从头开始创建属性，因此我们还没有文章ID。所以，我们只能检查一般的文章编辑权限。
- en: Once permission errors are generated, we can assign the error messages to a
    class variable and use it inside the shortcode function to display them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成权限错误，我们可以将错误消息分配给一个类变量，并在短代码函数中使用它来显示它们。
- en: 'Once validations are completed, we can retrieve the property data from the
    `POST` request and sanitize it before assigning to necessary variables. Here,
    we have used a function called `wp_kses_post` on the property content. This function
    sanitizes the content to only keep the allowed tags in WordPress post content
    by default. Next, we have to validate the data retrieved from the `POST` request
    and generate the errors to be displayed inside the shortcode. Now, we can take
    a look at the rest of the code for this function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成验证，我们可以从`POST`请求中检索属性数据，并在将其分配给必要的变量之前对其进行清理。在这里，我们对属性内容使用了名为`wp_kses_post`的函数。这个函数默认将内容清理为仅保留WordPress文章内容中允许的标签。接下来，我们必须验证从`POST`请求中检索的数据，并生成要显示在短代码中的错误。现在，我们可以看看这个函数的其余代码：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After validating all the property data, we use the `wp_insert_post` function
    to create the property on the `wp_posts` table. We can pass all the necessary
    settings as an array to this function. Here, we have used author as the current
    logged-in user. Then, we assign the property title and content to the respective
    settings while generating the URL for the post using the `sanitize_title` function.
    Finally, we set the correct post type and status as publish. This is a built-in
    function that creates posts while executing all the necessary filters and actions
    inside WordPress core. In case we use our own query to save the properties, we
    have to check and execute all the necessary filters and actions to make our feature
    compatible with other plugins. This function will return `true` or WordPress error
    based on the status of the execution. Next, we can check the errors and use the
    `update_post_meta` function to save the property custom fields to the `wp_postmeta`
    table.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证所有属性数据后，我们使用`wp_insert_post`函数在`wp_posts`表上创建属性。我们可以将所有必要的设置作为一个数组传递给这个函数。在这里，我们使用了当前登录用户作为作者。然后，我们在使用`sanitize_title`函数生成文章的URL的同时，将属性标题和内容分配给相应的设置。最后，我们设置正确的文章类型和状态为发布。这是一个内置函数，在执行WordPress核心内部的所有必要过滤器和动作的同时创建文章。如果我们使用自己的查询来保存属性，我们必须检查并执行所有必要的过滤器和动作，以确保我们的功能与其他插件兼容。这个函数将根据执行状态返回`true`或WordPress错误。接下来，我们可以检查错误并使用`update_post_meta`函数将属性自定义字段保存到`wp_postmeta`表。
- en: We can easily use frontend forms to store custom field data on custom database
    tables for additional flexibility. In such cases, we just have to replace the
    `wp_insert_post` function with a custom query and necessary data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用前端表单在自定义数据库表中存储自定义字段数据，以获得额外的灵活性。在这种情况下，我们只需将`wp_insert_post`函数替换为自定义查询和必要的数据。
- en: Now, we have completed the process of adding data using frontend forms, and
    you should be able to test the process by assiging the shortcode to a post or
    page and submitting the form with necessary data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了使用前端表单添加数据的过程，你应该能够通过将短代码分配到帖子或页面并提交必要的数据来测试这个过程。
- en: Loading forms using custom URLs
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义URL加载表单
- en: 'We already discussed the concept behind this technique in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml),
    *Practical Usage of WordPress APIs*, *Rewrite API* section. The shortcode method
    is not highly reliable for advanced web sites. So, we create our own URL structures
    and handle the forms using those custom URLs instead of using post, page, or custom
    post type. Since we already discussed this technique, we are going to go through
    the code without major explanations. Let''s start by adding a new rewrite rule
    and a query parameter to handle frontend property creation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第6章](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml)，“WordPress API的实际应用”，“重写API”部分讨论了这种技术背后的概念。短代码方法对于高级网站来说并不可靠。因此，我们创建了自己的URL结构，并使用这些自定义URL来处理表单，而不是使用帖子、页面或自定义帖子类型。由于我们已经讨论了这种技术，我们将不带主要解释地通过代码。让我们从添加一个新的重写规则和一个查询参数来处理前端属性创建开始：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code adds new rewrite rule accessible through [http://www.example.com/property-listing/add](http://www.example.com/property-listing/add)
    for creating properties from frontend custom forms. We also use a tag called `wpquick_property_actions`
    to identify the functionality for properties. Ideally, we need to include this
    code within the main class of our plugin to keep the object oriented nature of
    our plugin. However, we discussed the need to flush rewrite rules on activation.
    So, there is a conflict since our plugin is initialized on the `plugins_loaded`
    action, and the activation handler is executed before that action. Therefore,
    we have to use the preceding code outside the main class of the plugin, along
    with the activation handler. The following code contains the activation handler
    for this plugin:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个新的重写规则，可以通过[http://www.example.com/property-listing/add](http://www.example.com/property-listing/add)访问，用于从前端自定义表单创建属性。我们还使用了一个名为`wpquick_property_actions`的标签来识别属性的功能。理想情况下，我们需要将此代码包含在我们的插件的主要类中，以保持我们插件的对象化特性。然而，我们讨论了在激活时刷新重写规则的需要。因此，由于我们的插件是在`plugins_loaded`动作上初始化的，而激活处理程序是在该动作之前执行的，所以存在冲突。因此，我们必须在插件的主要类之外使用前面的代码，以及激活处理程序。以下是这个插件的激活处理程序代码：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we did in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical
    Usage of WordPress APIs*, we register the rewrite rules on the activation handler,
    just before calling the `flush_rewrite_rules` function. Next, we need to filter
    the URL and load the custom form for creating properties. We use the built-in
    `template_redirect` action for this functionality, and we can include the action
    inside the `WQCPT_Model_Property` class, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml)，“WordPress API的实际应用”中做的那样，我们在激活处理程序上注册重写规则，在调用`flush_rewrite_rules`函数之前。接下来，我们需要过滤URL并加载用于创建属性的定制表单。我们使用内置的`template_redirect`动作来实现这个功能，并且我们可以在`WQCPT_Model_Property`类中包含这个动作，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we receive the value of `wpquick_property_actions` using WordPress query
    variables. Then, we use a `switch` statement to filter different actions for properties.
    In this scenario, we have only used `add` as a filter. In complete implementation,
    we will have to include `edit`, `delete`, and `list` actions at a minimum. Inside
    the `add` case, we load the same template we used for the shortcode process. Then,
    we include it between the header and footer of the site to display the frontend
    form. Now, you should be able to access and create properties by visiting `www.example.com/property-listing/add`
    in the browser URL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用WordPress查询变量接收`wpquick_property_actions`的值。然后，我们使用`switch`语句来过滤不同属性的动作。在这个场景中，我们只使用了`add`作为过滤器。在完整的实现中，我们至少需要包括`edit`、`delete`和`list`动作。在`add`情况下，我们加载与短代码处理相同的模板。然后，我们在网站的头和尾之间包含它以显示前端表单。现在，你应该能够通过在浏览器URL中访问`www.example.com/property-listing/add`来访问和创建属性。
- en: Choosing between custom post types and custom forms
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自定义文章类型和自定义表单之间进行选择
- en: We looked at the features and process of both custom post types and custom forms
    in the previous sections. We started this chapter by discussing the custom post
    type features that have changed the way we develop with WordPress. Now, we can
    compare them with custom forms, and identify the advantages and disadvantages.
    Let's start by looking at the advantages of custom post types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中探讨了自定义文章类型和自定义表单的特点及流程。我们本章一开始就讨论了那些改变了我们使用WordPress进行开发的自定义文章类型特点。现在，我们可以将它们与自定义表单进行比较，并识别出它们的优缺点。让我们先看看自定义文章类型的优点。
- en: 'You may have already noticed the amount of coding we needed to get to display
    a custom form and use it for capturing data. We didn’t spent even half of the
    time doing the same thing with custom post types. Let''s summarize the additional
    things we had to do in custom form development, compared to custom post types:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，为了显示自定义表单并使用它来捕获数据，我们需要编写大量的代码。而我们使用自定义文章类型做同样的事情，所花费的时间甚至不到一半。让我们总结一下，与自定义文章类型相比，在自定义表单开发中我们需要额外做的事情：
- en: '**Creating fields for title and content**: We had a built-in title field and
    content field with Rich Text Editor in custom post types, whereas we had to create
    two new fields to handle them in custom forms.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建标题和内容字段**：在自定义文章类型中，我们内置了标题字段和内容字段，并带有富文本编辑器，而在自定义表单中，我们必须创建两个新字段来处理它们。'
- en: '**Adding a form and submit button**: We didn''t need to add a form or submit
    button in custom post types as we were using the built-in post functions of WordPress.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加表单和提交按钮**：在自定义文章类型中，我们不需要添加表单或提交按钮，因为我们正在使用WordPress内置的文章功能。'
- en: '**Saving the property**: We didn''t have to create the property and save the
    main details in custom post types as it was done automatically by the WordPress
    core process.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存属性**：在自定义文章类型中，我们不需要创建属性并保存主要细节，因为WordPress核心进程会自动完成这些操作。'
- en: '**Handing property validations**: In custom post types, all the necessary validation
    on main property data is handled by core features. However, we need to check the
    existence of the property, URL, and make sure to sanitize the property content
    manually.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理属性验证**：在自定义文章类型中，所有必要的属性数据验证都由核心功能处理。然而，我们需要检查属性的存在、URL，并确保手动清理属性内容。'
- en: '**Post editing and listing**: We have the ability to edit, list, or delete
    a post as soon as we create one using backend custom post types. However, we only
    built the create form using the custom form, and hence we have to develop edit,
    list, and delete features from scratch using more custom forms.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文章编辑和列表**：使用后端自定义文章类型，我们可以在创建文章后立即编辑、列出或删除文章。然而，我们只使用自定义表单构建了创建表单，因此我们必须从头开始使用更多自定义表单来开发编辑、列表和删除功能。'
- en: 'So, in this perspective, built-in custom post types offer a lot more advantages
    over custom forms. Here are the advantages of using custom forms over custom post
    types:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这个角度来看，内置的自定义文章类型在自定义表单之上提供了更多的优势。以下是使用自定义表单而非自定义文章类型的优势：
- en: '**Frontend interfaces**: Custom post types doesn''t offer the data capturing
    features on the frontend and hence users need to be redirected to the backend.
    So, we can''t match the forms with the styles of themes, whereas custom forms
    allow us to create any type of design. This also means we will have to manage
    the permission to other menu items in the backend.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端界面**：自定义文章类型不提供前端的数据捕获功能，因此用户需要被重定向到后端。因此，我们无法将表单与主题的样式相匹配，而自定义表单允许我们创建任何类型的设计。这也意味着我们将在后端管理其他菜单项的权限。'
- en: '**Mix of frontend and backend**: When using custom forms, we can let users
    use the other site features as well as data submissions within the frontend, allowing
    users to have a consistent set of screens. However, using custom post types means
    that the user will have to switch between the frontend and backend of the site,
    creating unnecessary complexity.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端和后端的混合**：使用自定义表单时，我们可以让用户在前端使用其他网站功能以及数据提交，使用户能够拥有一致的屏幕集。然而，使用自定义文章类型意味着用户将需要在网站的前端和后端之间切换，从而产生不必要的复杂性。'
- en: '**Flexibility in validations**: WordPress automatically saves custom post types
    using the autosave feature and hence we can’t wait for the custom post creation,
    until custom validations are completed. So, we have to use some workarounds to
    validate custom fields and display the error messages, while keeping the post
    type record inaccessible. In custom forms, we can have the complete freedom for
    data validation before we actually create the record on the `wp_posts` table.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证的灵活性**：WordPress自动使用自动保存功能保存自定义帖子类型，因此我们无法等待自定义帖子创建完成，直到自定义验证完成。因此，我们必须使用一些变通方法来验证自定义字段并显示错误消息，同时保持帖子类型记录不可访问。在自定义表单中，我们可以在实际上传`wp_posts`表中的记录之前对数据进行完全自由的验证。'
- en: '**Flexibility in using database tables**: In backend custom post types, the
    newly created post always saves to the `wp_posts` table. However, in custom forms
    we can decide whether to use existing tables or use our own custom tables for
    managing data.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用数据库表时的灵活性**：在后端自定义帖子类型中，新创建的帖子总是保存到`wp_posts`表中。然而，在自定义表单中，我们可以决定是使用现有表还是使用我们自己的自定义表来管理数据。'
- en: By considering the advantages and disadvantages of each technique, we can come
    to a conclusion that backend custom post types are mostly suitable for sites with
    low budget and require a rapid development process. Also, we can consider custom
    post types when basic functionality is more important than flexibility. On the
    other hand, custom forms can be used for advanced sites, where performance is
    crucial and requires flexibility for future enhancements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑每种技术的优缺点，我们可以得出结论，后端自定义帖子类型主要适用于预算较低且需要快速开发流程的网站。此外，当基本功能比灵活性更重要时，我们也可以考虑使用自定义帖子类型。另一方面，自定义表单可以用于需要高性能和未来增强灵活性的高级网站。
- en: Using a form management plugin
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单管理插件
- en: 'We looked at the use of custom post types and custom forms for capturing and
    displaying the data needed for WordPress sites. However, many startup sites don''t
    have the budget or time to develop a custom solution specific for their sites.
    So, developers will have to use existing solutions and build the features on top
    of them. In such cases, WordPress form plugins become the ideal solution. There
    are some popular form plugins developed to cater a specific area, such as contact
    forms. We can also find forms plugins such as Gravity Forms, Ninja Forms developed
    to cater any purpose. Let''s understand the features expected from a quality forms
    plugin:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了使用自定义帖子类型和自定义表单来捕获和显示WordPress网站所需的数据。然而，许多初创网站没有预算或时间来开发针对其网站的特定解决方案。因此，开发者必须使用现有解决方案，并在其基础上构建功能。在这种情况下，WordPress表单插件成为理想的解决方案。有一些流行的表单插件是为了满足特定领域而开发的，例如联系表单。我们还可以找到如Gravity
    Forms、Ninja Forms等表单插件，它们是为了满足任何目的而开发的。让我们了解一个高质量的表单插件所期望的功能：
- en: '**Drag and drop builder**: This is the feature that accelerates the development
    of custom forms with existing plugins. Instead of writing own HTML for each field,
    we should be able to drag and drop existing custom fields and build fully working
    custom forms in minutes.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拖放构建器**：这是通过现有插件加速自定义表单开发的功能。我们不需要为每个字段编写自己的HTML，而应该能够拖放现有的自定义字段，并在几分钟内构建完全工作的自定义表单。'
- en: '**Ajax-based form submission**: This is a very important feature in modern
    websites as developers don''t use the normal post submissions for many features.
    So, the forms plugin should have the ability use normal form submission as well
    as AJAX-based submissions.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Ajax的表单提交**：这是现代网站中的一个非常重要的功能，因为开发者不会为许多功能使用常规的帖子提交。因此，表单插件应该能够使用常规表单提交以及基于Ajax的提交。'
- en: '**Different field types**: In this plugin, we only used basic text and dropdown
    fields. However, we need many field types such as dates, google maps, and searchable
    dropdowns in advanced websites. So, the ability to handle such advanced requirements
    with the built-in fields in forms plugins is definitely a huge advantage.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的字段类型**：在这个插件中，我们只使用了基本的文本和下拉字段。然而，在高级网站上，我们需要许多字段类型，如日期、谷歌地图和可搜索的下拉菜单。因此，能够通过表单插件内置字段处理此类高级要求无疑是一个巨大的优势。'
- en: '**Form field validations**: Usually, we had to validate each field by applying
    the necessary validation rules. In a quality forms plugin, we should have the
    ability to select from an existing set of rules and validate the fields without
    writing a single line of code.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单字段验证**：通常，我们必须通过应用必要的验证规则来验证每个字段。在一个高质量的表单插件中，我们应该能够从现有规则集中选择并验证字段，而无需编写任何代码。'
- en: '**Conditional logic**: In custom forms, we develop each form for specific requirements
    and hence we can manually apply conditions before loading certain fields. In forms
    plugins, we add the fields dynamically to a form, and hence we should have the
    ability to define the conditions before making each field visible on the site.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件逻辑**：在自定义表单中，我们为特定需求开发每个表单，因此我们可以在加载某些字段之前手动应用条件。在表单插件中，我们动态地将字段添加到表单中，因此我们应该有能力在使每个字段在网站上可见之前定义条件。'
- en: '**Displaying and exporting data**: We should have the ability to display submitted
    data in the frontend and export it to common file types when necessary.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示和导出数据**：我们应该有能力在前端显示提交的数据，并在必要时将其导出为常见文件类型。'
- en: '**Saving form data to a custom database table**: Usually, many forms plugins
    save the data to the `wp_postmeta` table or use the same custom table to save
    the data of all forms to a single custom table. We should at least have the ability
    to choose between existing tables or a custom table.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将表单数据保存到自定义数据库表**：通常，许多表单插件将数据保存到`wp_postmeta`表或使用相同的自定义表将所有表单的数据保存到单个自定义表中。我们至少应该有能力在现有表或自定义表之间进行选择。'
- en: 'These are some of the features we expect from quality form plugins. Let''s
    take a look at the following screen for the form-creating interface of one of
    the most popular forms plugins:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们期望从高质量表单插件中获得的一些功能。让我们看一下以下屏幕截图，这是最受欢迎的表单插件之一的形式创建界面：
- en: '![](img/6bf02239-3d3e-4fbf-a5dd-ccfee4eba423.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bf02239-3d3e-4fbf-a5dd-ccfee4eba423.png)'
- en: The preceding screenshot previews some of the features we discussed in the previous
    section. However, it will be difficult to find a forms plugins that provides all
    these features in a way that we expect to use them. Also, almost all the forms
    plugin don't provide a frontend interface to let the user edit the submitted data
    or list them. So, forms plugins are best-suited for scenarios where we want to
    use one-time forms to capture the user data. Popular examples include registration
    forms, contact forms, payment forms, and surveys. We should always use custom
    forms or custom post types to manage forms that requires the user to submit data,
    update it, and list all the submitted data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图预览了我们在上一节中讨论的一些功能。然而，要找到一个以我们期望的方式提供所有这些功能的表单插件将很困难。此外，几乎所有表单插件都不提供前端界面，让用户编辑提交的数据或列出它们。因此，表单插件最适合我们想要使用一次性表单来捕获用户数据的场景。流行的例子包括注册表单、联系表单、支付表单和调查。我们应该始终使用自定义表单或自定义文章类型来管理需要用户提交、更新和列出所有提交数据的表单。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The process of managing the data is one of the most important aspect of a website
    or application. WordPress custom post types allow us to model different content
    types in a standard way, and use built-in features for rapid development. We began
    the chapter by understanding the importance of custom post types and the features
    that made it a popular choice in plugin development. Then, we looked at the process
    of creating custom post types, while understanding the use of taxonomies and custom
    fields with custom post types. Next, we moved to the process and techniques of
    developing custom forms for the frontend of a website. Finally, we looked at the
    need for using forms plugins, and compared the advantages and disadvantages of
    custom post types and custom forms.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据的过程是网站或应用最重要的方面之一。WordPress自定义文章类型允许我们以标准方式建模不同的内容类型，并使用内置功能进行快速开发。我们通过理解自定义文章类型的重要性及其在插件开发中成为流行选择的功能开始本章。然后，我们研究了创建自定义文章类型的过程，同时理解了与自定义文章类型一起使用分类和自定义字段。接下来，我们转向开发网站前端自定义表单的过程和技术。最后，我们探讨了使用表单插件的需要，并比较了自定义文章类型和自定义表单的优缺点。
- en: In [Chapter 8](f84651b7-727e-4336-845c-14fc12ae10ab.xhtml), *Discovering Key
    Modules in Development*, we will be exploring the development of key modules in
    modern web sites, such as UI component integration, improving usability, and customizing
    core admin features.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](f84651b7-727e-4336-845c-14fc12ae10ab.xhtml)《发现开发中的关键模块》中，我们将探讨现代网站中关键模块的开发，例如UI组件集成、提高可用性和自定义核心管理功能。
