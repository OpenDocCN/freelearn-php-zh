- en: Chapter 12. Performance and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。性能和安全
- en: Out of the box, Yii2 is an both a performant and efficient PHP framework. It
    was designed to be as fast as possible while still providing a feature-rich toolbox
    to work with. There are many factors that determine the performance of our application
    that can negatively affect the performance of our application, such as long running
    queries and data generation. In this chapter, we'll cover several ways in which
    we can optimize and fine-tune Yii2 so that our applications remain performant.
    We'll also cover several important aspects of securing our code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2 既是高性能的也是高效的 PHP 框架。它被设计得尽可能快，同时仍然提供功能丰富的工具箱以供使用。有许多因素会影响我们应用程序的性能，这些因素可能会对我们的应用程序性能产生负面影响，例如长时间运行的查询和数据生成。在本章中，我们将介绍几种优化和微调
    Yii2 的方法，以确保我们的应用程序保持高性能。我们还将介绍保护我们代码的几个重要方面。
- en: Caching
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: One of the easiest ways to improve the performance of our applications is to
    implement caching. By implementing caching within our application, we can reduce
    the amount of time it takes to generate and deliver data to our end users. With
    Yii2, we can cache everything from generated data, database queries, and even
    entire pages and page fragments. We can also instruct our browsers to cache pages
    for us. In this section, we'll cover several different caching techniques that
    we can implement within Yii2 in order to improve the performance of our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 提高我们应用程序性能的最简单方法之一是实现缓存。通过在我们的应用程序中实现缓存，我们可以减少生成和向最终用户交付数据所需的时间。使用 Yii2，我们可以缓存从生成数据、数据库查询到整个页面和页面片段的一切。我们还可以指示我们的浏览器为我们缓存页面。在本节中，我们将介绍几种不同的缓存技术，我们可以在
    Yii2 中实现这些技术，以提高我们应用程序的性能。
- en: Caching data
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存数据
- en: Data caching is all about storing commonly generated data so that we can generate
    it once for a given period of time rather than on every request, and in Yii2,
    it is implemented through the cache component of our application. Yii2 provides
    a variety of different classes that we can use to cache data, all of which follow
    and use a consistent API by implementing the `yii\caching\Cache` abstract class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据缓存主要是关于存储常见生成数据，以便我们可以为给定时间段生成一次，而不是每次请求都生成，在 Yii2 中，它是通过应用程序的缓存组件实现的。Yii2
    提供了多种不同的类，我们可以使用这些类来缓存数据，所有这些类都遵循并使用一致的 API，通过实现 `yii\caching\Cache` 抽象类。
- en: 'This consistent API enables us to swap out our caching component with any of
    the caches listed in the following table without having to make any change to
    the code within our application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一致的 API 允许我们无需修改应用程序内部的代码，就可以用以下表格中列出的任何缓存替换我们的缓存组件：
- en: '| Cache Name | Description | Class reference |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 缓存名称 | 描述 | 类引用 |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `yii\caching\ApcCache` | A cache that uses APC PHP extensions. On a single
    server configuration, an APC cache is very performant but suffers from compatibility
    issues if PHP Opcache is enabled. | [http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html](http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\ApcCache` | 使用 APC PHP 扩展的缓存。在单个服务器配置中，APC 缓存性能非常好，但如果启用了 PHP
    Opcache，则存在兼容性问题。 | [http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html](http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html)
    |'
- en: '| `yii\caching\DbCache` | A cache that uses a database table to store information.
    | [http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\DbCache` | 使用数据库表来存储信息的缓存。 | [http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html)
    |'
- en: '| `yii\caching\DummyCache` | A placeholder cache that doesn''t do any caching
    but serves as a standing for a real cache that can be used during development
    in order to ensure that our applications will work with a real cache. | [http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\DummyCache` | 一个占位符缓存，不执行任何缓存操作，但在开发期间用作真实缓存的代表，以确保我们的应用程序能够与真实缓存一起工作。
    | [http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html)
    |'
- en: '| `yii\caching\FileCache` | A cache that stores data in a file store and is
    recommended for the storing of pages or page fragments. | [http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html](http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\FileCache` | 一种将数据存储在文件存储中的缓存，适用于存储页面或页面片段。 | [http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html](http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html)
    |'
- en: '| `yii\caching\MemCache` | An in-memory cache that uses the PHP memcache or
    memcached extensions to store data. | [http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\MemCache` | 使用 PHP memcache 或 memcached 扩展存储数据的内存缓存。 | [http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html)
    |'
- en: '| `yii\caching\WinCache` | A cache that uses the WinCache PHP extension. |
    [http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html](http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\WinCache` | 使用 WinCache PHP 扩展的缓存。 | [http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html](http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html)
    |'
- en: '| `yii\redis\Cache` | A cache that implements the Redis key value store. |
    [http://www.yiiframework.com/doc-2.0/yii-redis-cache.html](http://www.yiiframework.com/doc-2.0/yii-redis-cache.html)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `yii\redis\Cache` | 实现 Redis 键值存储的缓存。 | [http://www.yiiframework.com/doc-2.0/yii-redis-cache.html](http://www.yiiframework.com/doc-2.0/yii-redis-cache.html)
    |'
- en: '| `yii\caching\XCache` | A cache that uses the XCache PHP extension. | [http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\XCache` | 使用 XCache PHP 扩展的缓存。 | [http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html)
    |'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While each cache that's listed implements the `yii\caching\Cache` API, some
    caches, such as `yii\redis\Cache` and `yii\caching\MemCache`, require some additional
    configuration. Ensure that you refer to the class reference for the cache you
    decide to use in your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列出的每个缓存都实现了 `yii\caching\Cache` API，但一些缓存，例如 `yii\redis\Cache` 和 `yii\caching\MemCache`，需要一些额外的配置。请确保您参考您在应用程序中决定使用的缓存类的参考文档。
- en: 'Using `yii\caching\FileCache` as an example, we can implement caching within
    our application by adding the following to our application configuration file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `yii\caching\FileCache` 为例，我们可以在应用程序配置文件中添加以下内容来实现应用程序内的缓存：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After implementing a specific caching system, we can then use our cache by referencing
    `Yii::$app->cache` within our application code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现特定的缓存系统之后，我们可以在应用程序代码中通过引用 `Yii::$app->cache` 来使用我们的缓存。
- en: As mentioned previously, each cache implements a consistent API, as defined
    by the `yii\caching\Cache` abstract class. Consequently, each cache provides the
    following methods that we can use to manipulate the data in our cache.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个缓存都实现了由 `yii\caching\Cache` 抽象类定义的一致 API。因此，每个缓存都提供了以下方法，我们可以使用这些方法来操作缓存中的数据。
- en: '| Method | Explanation |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 说明 |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `yii\caching\Cache::add()` | Stores the value with a given key in the cache
    if it does not exist. If the cached item exists, no operation will occur. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::add()` | 如果缓存中不存在，则使用给定键存储值。如果缓存的项已存在，则不会执行任何操作。 |'
- en: '| `yii\caching\Cache::get()` | Retrieves an item with a given key from the
    cache. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::get()` | 从缓存中检索具有给定键的项。 |'
- en: '| `yii\caching\Cache::set()` | Sets an item with a given key into the cache
    with the option to specify an expiration date. The cached items set with an expiration
    date will automatically be expunged by either the underlying cache mechanism or
    by Yii2 itself. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::set()` | 将具有给定键的项设置到缓存中，并可选择指定过期日期。设置了过期日期的缓存项将自动由底层缓存机制或
    Yii2 本身清除。 |'
- en: '| `yii\caching\Cache::madd()` | Stores multiple items in the cache as a key
    value array. If a given cache key already exists, nothing will occur.In Yii 2.1,
    this method will be marked as deprecated and will be superseded by `yii\caching\Cache::multiAdd()`.
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::madd()` | 将多个项作为键值数组存储到缓存中。如果给定的缓存键已存在，则不会发生任何操作。在 Yii
    2.1 中，此方法将被标记为已弃用，并由 `yii\caching\Cache::multiAdd()` 取代。 |'
- en: '| `yii\caching\Cache::mget()` | Retrieves multiple data keys from the cache
    simultaneously.In Yii 2.1, this method will be marked as deprecated and will be
    superseded by `yii\caching\Cache::multiGet()`. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::mget()` | 同时从缓存中检索多个数据键。在 Yii 2.1 中，此方法将被标记为已弃用，并由 `yii\caching\Cache::multiGet()`
    取代。 |'
- en: '| `yii\caching\Cache::mset()` | Sets multiple cached items represented as a
    key value simultaneously into the cache. The cached items set with an expiration
    date will automatically be expunged by either the underlying cache mechanism or
    by Yii2 itself.In Yii 2.1, this method will be marked as deprecated and will be
    superseded by `yii\caching\Cache::multiSet()`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::mset()` | 将多个缓存项（以键值对的形式）同时设置到缓存中。带有过期时间的缓存项将被底层缓存机制或Yii2自动清除。在Yii
    2.1中，此方法将被标记为弃用，并由`yii\caching\Cache::multiSet()`方法取代。|'
- en: '| `yii\caching\Cache::exists()` | Returns `true` or `false` if a given cache
    key exists within the cache. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::exists()` | 返回一个布尔值，表示给定的缓存键是否存在于缓存中。|'
- en: '| `yii\caching\Cache::delete()` | Deletes a given cache key from the cache.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::delete()` | 从缓存中删除给定的缓存键。|'
- en: '| `yii\caching\Cache::flush()` | Flushes all the data from the cache. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\Cache::flush()` | 清除缓存中的所有数据。|'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on each method and its use, refer to the noninherited public
    methods described by the `yii\caching\Cache` abstract class at [http://www.yiiframework.com/doc-2.0/yii-caching-cache.html](http://www.yiiframework.com/doc-2.0/yii-caching-cache.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个方法和其使用的更多信息，请参阅`yii\caching\Cache`抽象类中描述的非继承的公共方法，链接为[http://www.yiiframework.com/doc-2.0/yii-caching-cache.html](http://www.yiiframework.com/doc-2.0/yii-caching-cache.html)。
- en: 'In general, our cache can be used by calling any of these methods against our
    `Yii::$app->cache` component, as shown in the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以通过调用`Yii::$app->cache`组件的任何这些方法来使用我们的缓存，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Caching dependencies
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存依赖项
- en: In addition to setting a cache with a given expiration time, we can also cache
    data with certain dependencies, such as the last modification time of a file of
    an expression of some kind, and automatically expire our data should that dependency
    change. Yii2 provides several dependencies that we can use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置具有给定过期时间的缓存外，我们还可以使用某些依赖项（如文件的最后修改时间或某种表达式的表达式）来缓存数据，如果依赖项发生变化，我们的数据将自动过期。Yii2提供了几个我们可以使用的依赖项。
- en: '| Method | Explanation | Class Reference |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 说明 | 类引用 |'
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `yii\caching\ChainedDependency` | A dependency that allows us to chain multiple
    dependencies together and expire a cache item if any of the dependencies fail.
    | [http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html)
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\ChainedDependency` | 允许我们将多个依赖项链接在一起，如果任何依赖项失败，则使缓存项过期。| [http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html)
    |'
- en: '| `yii\caching\DbDependency` | A dependency upon a given SQL query. Should
    the result of the query change, the cache will be invalidated. | [http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\DbDependency` | 基于给定SQL查询的一个依赖项。如果查询的结果发生变化，缓存将被失效。| [http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html)
    |'
- en: '| `yii\caching\FileDependency` | A dependency upon a file based upon the last
    modification time of the file. | [http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html)
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\FileDependency` | 基于文件的最后修改时间的一个依赖项。| [http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html)
    |'
- en: '| `yii\caching\ExpressionDependency` | A dependency represented by a Boolean
    expression. | [http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html)
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\ExpressionDependency` | 由布尔表达式表示的依赖项。| [http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html)
    |'
- en: '| `yii\caching\TagDependency` | A dependency upon an array of tags that can
    be managed. | [http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html)
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `yii\caching\TagDependency` | 基于可管理的标签数组的一个依赖项。| [http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html)
    |'
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Check out the class reference for each dependency for more information on its
    available properties and methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每个依赖项的类引用，以获取有关其可用属性和方法的信息。
- en: 'Expanding upon our previous example, we can add a cache dependency, as shown
    in the following example. In the following code, we create a dependency upon a
    file called `data.csv`, which can contain a report or some other data that we
    wish to generate or import into our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例基础上，我们可以添加一个缓存依赖，如下面的示例所示。在下面的代码中，我们创建了一个对名为`data.csv`的文件的依赖，该文件可以包含报告或其他我们希望生成或导入到我们的应用程序中的数据：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Database query caching
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库查询缓存
- en: 'With Yii2, we can also cache the result of a database query. To enable query
    caching, we need to set three properties within our database component: `$enableQueryCache`,
    which toggles the query cache on and off; `$queryCacheDuration`, which sets the
    duration queries should be cached for; and `$queryCache`, which specifies the
    cache component that should be used.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yii2，我们还可以缓存数据库查询的结果。要启用查询缓存，我们需要在我们的数据库组件中设置三个属性：`$enableQueryCache`，用于切换查询缓存的开启和关闭；`$queryCacheDuration`，用于设置查询应该缓存的持续时间；以及`$queryCache`，用于指定应使用的缓存组件。
- en: 'The following connection example illustrates how to enable the query cache:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下连接示例说明了如何启用查询缓存：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After configuring database query caching, we can then cache the results of
    a single DAO query by adding or chaining the cache method to our query, as shown
    in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置数据库查询缓存后，我们可以通过添加或链接缓存方法到我们的查询上来缓存单个DAO查询的结果，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, if we have multiple queries we''d like to cache, we can call
    the `yii\db\Connection::cache()` function directly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想缓存多个查询，我们可以直接调用`yii\db\Connection::cache()`函数：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ActiveRecord` can also take advantage of query caching by fetching the database
    component from the `ActiveRecord` model, as shown in the next example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActiveRecord`也可以通过从`ActiveRecord`模型获取数据库组件来利用查询缓存，如下面的示例所示：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Moreover, within a query cache, we can exclude certain queries from being cached
    by chaining the `noCache()` method to our query, as illustrated by the following
    examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在查询缓存中，我们可以通过将`noCache()`方法链接到我们的查询上来排除某些查询的缓存，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some databases such as MySQL have their own built-in caching implemented in
    the software layer. Implementing both MySQL's native query cache and Yii2's query
    cache can cause problems in ensuring that the right data is presented. Additionally,
    any data that is returned as a resource handler cannot be cached by Yii2\. Furthermore,
    some caches, such as `Memcache`, limit how much data can be associated with a
    specific key. Be cognizant of these limitations when using query caching.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库，如MySQL，在其软件层中实现了自己的内置缓存。同时实现MySQL的本地查询缓存和Yii2的查询缓存可能会导致确保正确数据呈现的问题。此外，任何作为资源处理器返回的数据都不能由Yii2缓存。此外，一些缓存，如`Memcache`，限制了可以与特定键关联的数据量。在使用查询缓存时，请注意这些限制。
- en: Fragment caching
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段缓存
- en: 'Fragment caching is built on top of data caching. Fragment caching in Yii2
    allows us to cache a fragment of a page and present that cached fragment rather
    than regenerating the entire contents of the page on every request. In general,
    we can use fragment caching by wrapping our code in the following block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 片段缓存建立在数据缓存之上。Yii2中的片段缓存允许我们缓存页面的一部分，并在每次请求时呈现该缓存片段，而不是重新生成页面的全部内容。通常，我们可以通过以下代码块使用片段缓存：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Like data caching, fragment caching has support for several conditions, such
    as duration, dependencies, variation, and toggling the fragment cache on and off.
    These conditions can be added as key value arrays to the second parameter of the
    `beginCache()` method, as shown in the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据缓存一样，片段缓存也支持多个条件，如持续时间、依赖项、变化和切换片段缓存的开启和关闭。这些条件可以作为键值数组添加到`beginCache()`方法的第二个参数中，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Page caching
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面缓存
- en: 'As an alternative to caching just a fragment of a web page, with Yii2, we can
    also cache an entire page and serve the cached copy instead of generating the
    page on every page load. This is exceptionally useful when we have a read-heavy
    application, such as a blog. Page caching in Yii2 is implemented by adding the
    `yii\filters\PageCache` filter to the `behaviors()` method of our controller,
    as shown in the following example. Like fragment caching, we can specify variations
    for our page, dependencies upon which our content should be invalidated, and the
    duration it should be cached for. Like other filters, we can also specify the
    actions we want our cache to apply to using the `only` and `except` parameters.
    The following example illustrates the use of page caching:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为仅缓存网页片段的替代方案，使用Yii2，我们还可以缓存整个页面，并在每次页面加载时提供缓存的副本而不是生成页面。这对于我们有一个读密集型应用程序，如博客来说非常有用。在Yii2中，通过将`yii\filters\PageCache`过滤器添加到我们的控制器中的`behaviors()`方法来实现页面缓存，如下面的示例所示。与片段缓存一样，我们可以为我们的页面指定变体，指定内容应该无效化的依赖项，以及缓存的时间长度。与其他过滤器一样，我们还可以使用`only`和`except`参数指定我们想要我们的缓存应用到的操作。以下示例说明了页面缓存的使用：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: HTTP caching
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP缓存
- en: 'Data, fragment, and page caching are all strategies that we can use to optimize
    the server-side performance of our application. To further improve the performance
    of our application, we can also send across headers with our application in order
    to indicate that we want the client''s browser to cache the output of our page.
    These three headers are `Last-Modified`, `ETag`, and `Cache-Control`. By sending
    these headers along with our application, we can significantly reduce the number
    of HTTP requests sent to our application from our clients for pages that don''t
    change often. HTTP caching in Yii2 is implemented by the `yii\filtersHttpCache`
    filter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据、片段和页面缓存都是我们可以用来优化我们应用程序服务器端性能的策略。为了进一步提高我们应用程序的性能，我们还可以将带有我们应用程序的标题发送出去，以指示我们希望客户端的浏览器缓存我们页面的输出。这三个标题是`Last-Modified`、`ETag`和`Cache-Control`。通过将这三个标题与我们的应用程序一起发送，我们可以显著减少客户端对我们应用程序发送的HTTP请求的数量，对于不经常更改的页面。在Yii2中，HTTP缓存是通过`yii\filtersHttpCache`过滤器实现的：
- en: The first header, `Last-Modified`, informs the client about the last time the
    page was changed. If a client makes a HEAD request to the server and sees that
    the `Last-Modified` header differs from what it currently has, it will re-request
    the page and cache it instead. Otherwise, it will load the page from the client's
    cache.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个标题`Last-Modified`通知客户端页面最后更改的时间。如果客户端向服务器发送HEAD请求并看到`Last-Modified`标题与它目前拥有的不同，它将重新请求页面并缓存它。否则，它将从客户端的缓存中加载页面。
- en: The `ETag` header is used to represent a hash of the tag. Like the `Last-Modified`
    header, if the `ETag` hash changes, the browser knows that it had to re-download
    the page.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETag`标题用于表示标签的哈希。与`Last-Modified`标题一样，如果`ETag`哈希发生变化，浏览器就知道它必须重新下载页面。'
- en: 'Finally, the `Cache-Control` header indicates what type of cache the page should
    be stored in and for how long. By default, Yii2 will send `public; max-age: 3600`
    for this header, which will indicate that the client should cache the content
    for 3600 seconds or 1 hour.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后，`Cache-Control`标题指示页面应该存储在哪种类型的缓存中，以及存储多长时间。默认情况下，Yii2将为该标题发送`public; max-age:
    3600`，这将指示客户端应将内容缓存3600秒或1小时。'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the Cache-Control header can be found on the w3c specification
    reference guide at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于Cache-Control头部的信息可以在w3c规范参考指南中找到，链接为[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)。
- en: 'An example illustrating the use of all three of these headers combined is illustrated
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个说明如何结合使用这三个标题的示例：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that for HTTP caching, you only need to specify the headers you want to
    send. Specifying multiple headers can give you more fine grain control over when
    caches should be expired.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于HTTP缓存，您只需要指定您想要发送的标题。指定多个标题可以为您提供更精细的控制，以确定缓存何时过期。
- en: Caching database schema
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存数据库模式
- en: 'In order to make `ActiveRecord` models work automagically, Yii2 will automatically
    query the database to determine the schema of our application at the beginning
    of each query. While useful in a development environment, this operation is unnecessary
    in production environments where our schema rarely changes. We can tell Yii2 to
    cache our database schema to improve the performance of our database operations
    by enabling three properties of database component: `$schemeCache`, which represents
    the cache component we want to use; `$schemaCacheDuration`, which defines how
    long we want Yii2 to cache our schema; and `$enableSchemaCache`, which enables
    or disables the schema cache.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`ActiveRecord`模型自动工作，Yii2将在每次查询的开始自动查询数据库以确定应用程序的模式。虽然这在开发环境中很有用，但在我们的模式很少改变的生产环境中，这个操作是不必要的。我们可以通过启用数据库组件的三个属性来告诉Yii2缓存我们的数据库模式，以改善数据库操作的性能：`$schemeCache`，它代表我们想要使用的缓存组件；`$schemaCacheDuration`，它定义了Yii2缓存我们的模式的时间长度；以及`$enableSchemaCache`，它启用或禁用模式缓存。
- en: 'The following MySQL database component illustrates the use of the schema cache
    properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下MySQL数据库组件说明了模式缓存属性的使用：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When schema cache is enabled, run the `cache/flush` command after applying new
    migrations so that Yii2 can pick up your new database structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用模式缓存时，在应用新的迁移之后运行`cache/flush`命令，以便Yii2能够获取你的新数据库结构。
- en: General performance enhancements
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用性能提升
- en: For considerable performance gains, there are several changes that you can make
    to your application as well as your web server environment that can significantly
    increase the performance of your application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得显著的性能提升，你可以对你的应用程序以及你的Web服务器环境进行一些更改，这些更改可以显著提高应用程序的性能。
- en: Enabling OPCache
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用OPCache
- en: Unlike compiled languages such as C and C++, PHP is an interpreted scripting
    language. Consequently, every time our web server requests a new page or every
    time we run a command from our command line, PHP needs to interpret our code into
    machine code that our servers can actually run. Even if our source code doesn't
    change, PHP will automatically perform this step on every request. In our development
    environments, this allows us to simply make a change to our source code, save
    the file, and then reload it in the page to see our changes. In a production environment,
    however, this step is unnecessary since our code will only change if we perform
    a deployment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和C++等编译型语言不同，PHP是一种解释型脚本语言。因此，每次我们的Web服务器请求一个新页面，或者每次我们从命令行运行一个命令时，PHP都需要将我们的代码解释成服务器可以实际运行的机器码。即使我们的源代码没有改变，PHP也会在每次请求时自动执行这一步骤。在我们的开发环境中，这允许我们简单地更改源代码，保存文件，然后在页面上重新加载以查看我们的更改。然而，在生产环境中，这一步骤是不必要的，因为我们的代码只有在进行部署时才会改变。
- en: Starting in PHP 5.5, a new tool called OPCache was released by Zend Framework
    Technologies Ltd and built into the PHP core. Once enabled, OPCache will cache
    the compiled and optimized opcode that our PHP code is generated from and store
    it in a shared memory store. If our code is ever run again, OPCache will look
    inside that shared memory store for our code and execute it rather than re-interpreting
    our raw source code file. Depending upon the size of our application, enabling
    OPCache can have significant performance implications for our app. Moreover, since
    OPCache is now built into PHP, enabling it is fairly simple.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 5.5开始，Zend Framework Technologies Ltd发布了一个名为OPCache的新工具，并将其集成到PHP核心中。一旦启用，OPCache将缓存由我们的PHP代码生成的编译和优化后的操作码，并将其存储在共享内存存储中。如果我们的代码再次运行，OPCache将查找那个共享内存存储中的代码并执行它，而不是重新解释我们的原始源代码文件。根据我们应用程序的大小，启用OPCache可以对我们的应用程序性能产生重大影响。此外，由于OPCache现在已集成到PHP中，启用它相对简单。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that Zend OPCache and APCCache both can be configured to cache PHP's opcode.
    It's highly recommended that you do not run both Zend OPCache and APCCache at
    the same time as it can cause instability within PHP. As Zend OPCache is maintained
    by PHP maintainers, it's recommended that you use it instead of APC.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Zend OPCache和APCCache都可以配置为缓存PHP的操作码。强烈建议你不要同时运行Zend OPCache和APCCache，因为这可能会在PHP中引起不稳定。由于Zend
    OPCache由PHP维护者维护，建议你使用它而不是APC。
- en: 'Depending upon your package managed, OPCache may either be built into your
    PHP instance or provided as an external extension. A simply way to check whether
    OPCache is installed or not is to run the following command from your command
    line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的包管理器，OPCache可能已经内置到你的PHP实例中，或者作为外部扩展提供。一个简单的方法是检查OPCache是否已安装，可以通过从你的命令行运行以下命令来完成：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If OPCache is installed, you should see **Zend OPcache** appear in the output.
    If you don''t see this output, you''ll need to install OPCache from your package
    manager. Once OPCache is installed, you can enable it by adding the following
    to your `php.ini` file or to a file in your PHP INI includes folder and restarting
    your web server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果OPCache已安装，你应该在输出中看到**Zend OPcache**。如果你没有看到这个输出，你需要从你的包管理器安装OPCache。一旦安装了OPCache，你可以通过将以下内容添加到你的`php.ini`文件或PHP
    INI包含文件夹中的文件，并重新启动你的Web服务器来启用它：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you perform a deployment, you'll need to clear OPCache for your new code
    to take effect. Typically, this is done by restarting your web server or your
    PHP process. Alternatively, you can use a tool such as `cachetool` (available
    at [https://github.com/gordalina/cachetool](https://github.com/gordalina/cachetool))
    to clear the cache tool. Using a tool like `cachetool` is beneficial because it
    allows you to clear your OPCache without restarting your web server and facing
    potential downtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行部署时，你需要清除OPCache以使新代码生效。通常，这是通过重新启动你的Web服务器或PHP进程来完成的。或者，你可以使用像`cachetool`（可在[https://github.com/gordalina/cachetool](https://github.com/gordalina/cachetool)）这样的工具来清除缓存。使用像`cachetool`这样的工具是有益的，因为它允许你在不重新启动Web服务器并面临潜在的中断的情况下清除OPCache。
- en: Optimizing Composer dependencies
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化Composer依赖项
- en: 'Another performance change you can make as part of your deployment is to exclude
    your development dependencies from your production deployments:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为部署的一部分，你可以进行另一种性能改进，即从你的生产部署中排除开发依赖项：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since our development dependencies are used in development, loading and registering
    that code with our application only adds extra overhead to our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的开发依赖项在开发中使用，将此代码加载并注册到我们的应用程序中只会给我们的应用程序增加额外的开销。
- en: 'Additionally, we can instruct Composer to optimize the autoloader that it generates
    by running the following command when we install our composer dependencies:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在安装composer依赖项时通过运行以下命令来指示Composer优化它生成的自动加载器：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, we can generate an optimized autoloader file after installing
    our dependencies by running the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在安装依赖项后通过运行以下命令生成一个优化的自动加载文件：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By optimizing Composer's autoloader file, we can reduce the number of file and
    disk lookups with which we need to load our classes in our source code, which
    in turn will make our application faster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优化Composer的自动加载文件，我们可以减少在源代码中加载类时所需的文件和磁盘查找次数，这反过来会使我们的应用程序运行更快。
- en: Upgrading to PHP 7
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级到PHP 7
- en: At the time of publication, PHP 7 has been released, and it contains a refactored
    PHP engine that is able to interpret, compile, and execute the same PHP code with
    significantly less instructions. By reducing the number of CPU instructions and
    memory usage, PHP 7 is significantly faster than PHP 5.6\. For significant performance
    gains, consider upgrading your PHP instance from 5.6 to 7.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，PHP 7已经发布，它包含了一个重构的PHP引擎，能够以显著较少的指令解释、编译和执行相同的PHP代码。通过减少CPU指令和内存使用，PHP
    7比PHP 5.6快得多。为了获得显著的性能提升，考虑将你的PHP实例从5.6升级到7。
- en: Switch to Facebook's HHVM
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换到Facebook的HHVM
- en: As an alternative to upgrading to PHP 7, you can consider leaving the PHP engine
    and switching to HHVM, a reengineered engine for PHP created by Facebook. Like
    PHP 7, HHVM is significantly faster than PHP 5.6, and for high traffic applications,
    it can significantly reduce the costs associated with hosting a high traffic application.
    Unlike PHP 7, however, HHVM doesn't have support for all the PHP modules you may
    be accustomed to. Moreover, while Yii2 is fully compatible with HHVM, third-party
    Composer packages may not be, which may cause problems if thorough testing is
    not performed. For more information on HHVM, check out the HHVM documentation
    at [http://docs.hhvm.com/manual/en/index.php](http://docs.hhvm.com/manual/en/index.php).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为升级到PHP 7的替代方案，你可以考虑保留PHP引擎并切换到HHVM，这是Facebook创建的针对PHP的重构引擎。与PHP 7一样，HHVM比PHP
    5.6快得多，对于高流量应用程序，它可以显著降低托管高流量应用程序的相关成本。然而，与PHP 7不同的是，HHVM不支持你可能习惯的所有PHP模块。此外，虽然Yii2完全兼容HHVM，但第三方Composer包可能不兼容，如果不进行彻底测试，可能会出现问题。有关HHVM的更多信息，请参阅[http://docs.hhvm.com/manual/en/index.php](http://docs.hhvm.com/manual/en/index.php)的HHVM文档。
- en: Security considerations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全考虑
- en: When using Yii2, it's important to remember to follow security best practices
    in order to ensure the security of your application, the servers they run on,
    the data we collect, and our end users who entrust us with this information. In
    previous chapters, we explored how we can use the `yii\base\Security` class to
    safely encrypt and hash data and how to use hazing algorithms such as Bcrypt to
    secure passwords. In this section, we'll cover some additional security best practices
    that we can apply when building our applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Yii2时，重要的是要记住遵循安全最佳实践，以确保应用程序、运行它们的服务器、我们收集的数据以及将此信息托付于我们的最终用户的安全。在之前的章节中，我们探讨了如何使用`yii\base\Security`类安全地加密和散列数据，以及如何使用Bcrypt等哈希算法来保护密码。在本节中，我们将介绍一些在构建我们的应用程序时可以应用的其他安全最佳实践。
- en: Certificates
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书
- en: In almost every application that Yii2 will be providing the backend for, our
    clients (browsers or native clients) will communicate with our application over
    HTTP (Hypertext Transfer Protocol). An easy way to ensure that the information
    our client submits from their clients reaches our servers in the same state it
    left in is to encrypt the traffic between our clients and the server with a certificate
    signed by a trusted certificate authority transmitted over the TLS (Transport
    Layer Security) protocol.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个Yii2将提供后端支持的应用程序中，我们的客户端（浏览器或本地客户端）将通过HTTP（超文本传输协议）与我们的应用程序通信。确保我们的客户端从客户端提交的信息以相同的状态到达我们的服务器的一个简单方法是通过TLS（传输层安全性）协议传输由受信任的证书颁发机构签名的证书来加密客户端和服务器之间的流量。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: TLS is the successor to SSL (Secure Sockets Layer), and both are often referred
    to as SSL certificates. As of 2014, all versions of SSL (1.0, 2.0, and 3.0) have
    been deprecated due to known security issues with the SSL protocol itself. Its
    successor, TLS versions 1.1 and 1.2, are not vulnerable and are the recommended
    protocol to use when encrypting data between clients and servers over HTTP.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TLS（传输层安全性）是SSL（安全套接字层）的后继者，两者通常统称为SSL证书。截至2014年，所有版本的SSL（1.0、2.0和3.0）由于SSL协议本身存在的已知安全问题而被弃用。其继任者，TLS
    1.1和1.2版本不受影响，并且在通过HTTP在客户端和服务器之间加密数据时是推荐的协议。
- en: 'Adding a signed and trusted certificate to our server has several major advantages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将已签名和受信任的证书添加到我们的服务器具有几个主要优点：
- en: Encrypting data in transit prevents data from being viewed and manipulated by
    third parties. Health information, credit card information, usernames, and passwords
    can all be protected by encrypting data while in transit
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传输过程中加密数据可以防止第三方查看和操纵数据。健康信息、信用卡信息、用户名和密码都可以通过在传输过程中加密数据来得到保护。
- en: Clients can pin certificates that we publish so that they know to communicate
    with us only if our certificate matches the one they have pinned. This prevents
    Man-in-the-Middle attacks (MITM) and prevents others from learning about our data.
    Additionally, when using pinned certificates, our clients will know not to communicate
    with servers masquerading as ours. Again, this protects us and our users
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以锁定我们发布的证书，这样他们就知道只有当我们的证书与他们锁定的证书匹配时才与我们通信。这防止了中间人攻击（MITM）并阻止他人了解我们的数据。此外，当使用锁定证书时，我们的客户端将知道不要与冒充我们的服务器通信。再次，这保护了我们和我们的用户。
- en: Search engines such as Google and Bing give higher rankings to sites that use
    TLS
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎如Google和Bing会给使用TLS的网站更高的排名
- en: Implementing TLS in our web server is a simple task, and on modern computers,
    it incurs almost no overhead
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的网络服务器中实施TLS是一个简单的任务，在现代计算机上，它几乎不产生开销
- en: When implementing TLS, there are several resources you can use to determine
    the most secure cipher suites and to verify that your configuration is secure.
    For instance, the [https://cipherli.st](https://cipherli.st) site provides a list
    of modern cipher suites for a variety of web servers and configurations. Qualys'
    SSL Labs site ([https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/))
    can also give you a complete report of your TLS configuration and can validate
    your web server configuration. Combined, these tools can help better secure your
    application and infrastructure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当实施TLS时，您可以使用多种资源来确定最安全的加密套件，并验证您的配置是否安全。例如，[https://cipherli.st](https://cipherli.st)网站提供了一系列现代加密套件，适用于各种网络服务器和配置。Qualys的SSL
    Labs网站([https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/))也可以为您提供完整的TLS配置报告，并验证您的网络服务器配置。结合这些工具，可以帮助更好地保护您的应用程序和基础设施。
- en: Cookies
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookie
- en: 'When retrieving data from cookies using `yii\web\Request` and `yii\web\Response`,
    Yii2 will automatically encrypt your cookie information using your cookie validation
    key:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`yii\web\Request`和`yii\web\Response`从cookie中检索数据时，Yii2会自动使用您的cookie验证密钥对您的cookie信息进行加密：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When working with cookies and session cookies, we can take additional protections
    by adding additional attributes to our cookies, such as `yii\web\Cookie::$secure`
    and `yii\web\Cookie::$httpOnly`. By marking our cookies as `secure`, we can ensure
    that our cookies will only be sent over a secure connection, as described in the
    previous section. Moreover, by setting our cookies to be `httpOnly`, we can ensure
    that JavaScript and other web scripting languages cannot read our cookies. By
    configuring our cookies with these two flags, we can significantly improve the
    security of our application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理cookie和会话cookie时，我们可以通过向我们的cookie添加额外的属性来采取额外的保护措施，例如`yii\web\Cookie::$secure`和`yii\web\Cookie::$httpOnly`。通过将我们的cookie标记为`secure`，我们可以确保我们的cookie只通过安全连接发送，如前所述。此外，通过将我们的cookie设置为`httpOnly`，我们可以确保JavaScript和其他网络脚本语言无法读取我们的cookie。通过配置这两个标志，我们可以显著提高我们应用程序的安全性。
- en: Protecting against cross-site scripting
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止跨站脚本攻击
- en: As a general rule of web development, any time we display information submitted
    by an end user, we should encode it so that we can protect our site and users
    against XSS or cross-site scripting. XSS occurs when a user submits data that,
    when displayed on our page, can be interpreted by our browser. This could be something
    innocuous, such as adding `<em>` or `<b>` tags to our markup, or it could be something
    more sinister, such as injecting a `<script>` tag that tracks information about
    the user or redirects them to another site all together. Fortunately, Yii2 provides
    two ways of working with data submitted by end users that we can display.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络开发的一般规则，每次我们展示由最终用户提交的信息时，我们都应该对其进行编码，以便保护我们的网站和用户免受跨站脚本（XSS）攻击。XSS发生在用户提交的数据，当显示在我们的页面上时，可以被我们的浏览器解释。这可能是一些无害的操作，例如在我们的标记中添加`<em>`或`<b>`标签，或者可能是更危险的操作，例如注入一个`<script>`标签来跟踪用户信息或将他们重定向到另一个网站。幸运的是，Yii2提供了两种处理最终用户提交数据并显示的方法。
- en: 'The first method we can use to protect our site from XSS is to encode end user
    data using the `yii\helpers\Html::encode()` method, as illustrated in the following
    example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来保护我们的网站免受XSS攻击的第一种方法是通过使用`yii\helpers\Html::encode()`方法对最终用户数据进行编码，如下面的示例所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When encoding our data using this method, Yii2 will convert tags such as `<`
    and `>` into HTML-encoded entities that modern browsers know how to display and
    interpret.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种方法对数据进行编码时，Yii2会将`<`和`>`等标签转换为现代浏览器知道如何显示和解释的HTML编码实体。
- en: 'In the instance where we do want end user data to be displayed as HTML, we
    can use `yii\web\HtmlPurifier::purify()` to correctly parse our data with the
    rich HTML we want without allowing JavaScript code to be injected:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确实希望将最终用户数据以HTML形式显示的情况下，我们可以使用`yii\web\HtmlPurifier::purify()`来正确解析我们想要的数据，同时不允许注入JavaScript代码：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: HtmlPurifier can be extremely slow even when configured properly. Be sure you
    understand and configure HtmlPurifier properly before deploying your code as it
    can significantly hurt the performance of your application. More information on
    how to configure HtmlPurifier within Yii2 can be found at [http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html](http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html),
    and HtmlPurifier's complete documentation can be found at [http://htmlpurifier.org/](http://htmlpurifier.org/).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使配置得当，HtmlPurifier也可能非常慢。在部署代码之前，请确保您正确理解和配置HtmlPurifier，因为它可能会显著影响您应用程序的性能。有关如何在Yii2中配置HtmlPurifier的更多信息，请参阅[http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html](http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html)，HtmlPurifier的完整文档可以在[http://htmlpurifier.org/](http://htmlpurifier.org/)找到。
- en: Enabling cross-site request forgery protection
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用跨站请求伪造保护
- en: '**CSRF** (**cross-site request forgery**) is another common vulnerability that
    many sites deal with, which Yii2 can help protect us against. When dealing with
    client requests, we generally assume that the request came from the user himself.
    With JavaScript, however, we can send false requests in the background without
    the user''s knowledge. These requests can be as simple as logging a user out of
    a given service without their knowledge or scraping a specific page for information
    about the user then transmitting it to a malicious server. Yii2 automatically
    protects us from CSRF attacks. The only additional protection you can perform
    is to follow the HTTP specification (such as not allowing state changes on GET
    requests).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSRF**（**跨站请求伪造**）是许多网站处理的一种常见漏洞，Yii2可以帮助我们保护自己免受其侵害。在处理客户端请求时，我们通常假设请求来自用户本人。然而，使用JavaScript，我们可以在用户不知情的情况下在后台发送虚假请求。这些请求可能很简单，比如在用户不知情的情况下将其从特定服务中注销，或者抓取有关用户信息的特定页面并将其传输到恶意服务器。Yii2自动保护我们免受CSRF攻击。您唯一可以执行的其他保护措施是遵循HTTP规范（例如，不允许在GET请求上更改状态）。'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that there may be many times when CSRF needs to be disabled for one reason
    or another. Within our controller, we can disable CSRF for specific actions by
    adding this code within our action by setting `Yii::$app->controller->enableCsrfValidation`
    to `false`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能会有很多次出于各种原因需要禁用CSRF。在我们的控制器中，我们可以通过在动作中添加以下代码来为特定动作禁用CSRF：将`Yii::$app->controller->enableCsrfValidation`设置为`false`。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered several different ways in which we can improve and
    explore the performance of our application and learned how to improve the security
    of our application. We explored how we can use data, page, fragment, HTTP, database,
    and schema caching to improve the performance of our application. We also discovered
    general improvements we can make to Yii2 and PHP in order to make our application
    run faster. Finally, we discovered several ways in which we can improve the security
    of our application through the use of certificates, enabling certain cookie attributes,
    and protecting our site against XSS and CSRF attacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了多种提高和探索我们应用程序性能的方法，并学习了如何提高我们应用程序的安全性。我们探讨了如何使用数据、页面、片段、HTTP、数据库和模式缓存来提高我们应用程序的性能。我们还发现了我们可以对Yii2和PHP进行的一般改进，以使我们的应用程序运行得更快。最后，我们发现了通过使用证书、启用某些cookie属性以及保护我们的网站免受XSS和CSRF攻击的几种方法来提高我们应用程序安全性的几种方法。
- en: In our final chapter, we'll cover how we can speed up our already fast development
    time with Yii2, learn how to explore our application through logging, and discover
    fast and secure ways to deploy our application with almost no downtime or interruption
    of service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将介绍如何使用Yii2加快我们已有的快速开发时间，学习如何通过日志记录探索我们的应用程序，并发现快速且安全的方法来部署我们的应用程序，几乎不会出现停机或服务中断。
