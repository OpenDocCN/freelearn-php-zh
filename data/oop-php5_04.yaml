- en: Chapter 4. Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 设计模式
- en: Object oriented programming was basically introduced to ease the development
    process as well as reduce the time of development by reducing amounts of code.
    If properly planned and designed, OOP can increase the performance of the program
    to a great extent. One of those magical performance cum code reduction issues
    is "Design Pattern" which was introduced by Eric Gamma and his three other friends
    in the book *Design Patterns* in 1972\. Because of four authors, the book was
    introduced as written by *Gang of Four* or simply *Goff*. In that legendary book,
    Gang of Four introduced several patterns to minimize the amount of code as well
    as to introduce effective coding practice. In this chapter we will learn some
    of those patterns to implement in PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程最初是为了简化开发过程以及通过减少代码量来缩短开发时间而引入的。如果规划得当，设计合理，面向对象编程（OOP）可以极大地提高程序的性能。其中之一是“设计模式”，这是由埃里克·伽玛和他的三位朋友在1972年出版的《设计模式》一书中提出的。由于有四位作者，这本书被介绍为“四人帮”的作品，或者简单地称为“Goff”。在这本传奇性的书中，“四人帮”介绍了几种模式，以最大限度地减少代码量并引入有效的编码实践。在本章中，我们将学习一些这些模式，以便在PHP中实现。
- en: You Might have Done this Before…
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可能以前做过这件事…
- en: While coding, many of us use these patterns without being aware that these techniques
    are actually known as patterns. Even in my early coding life, I used some coding
    techniques, which I later found out to be similar to some patterns. So don't be
    afraid about using patterns. They are daily coding tricks, which you may have
    always performed, but you may not have known.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码过程中，我们中的许多人使用这些模式，却不知道这些技术实际上被称为模式。即使在早期的编码生涯中，我也使用了一些编码技术，后来发现它们与某些模式相似。所以，不要害怕使用模式。它们是日常编码技巧，你可能一直都在使用，但你可能不知道。
- en: While developing software, some problems are addressed on a regular basis. Almost
    every software development faces some of these problems. These problems are termed
    "design patterns" and are given some common solutions. So knowing design patterns
    saves a lot of time for developers in software development. Let's have a closer
    look at design patterns.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中，一些问题会定期出现。几乎每个软件开发都会遇到这些问题。这些问题被称为“设计模式”，并给出了一些常见的解决方案。因此，了解设计模式可以为软件开发者节省大量时间。让我们更深入地了解设计模式。
- en: Strategy Pattern
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'One of the common problems we face whilst programming, is that we have to make
    decisions on different strategies. Strategy pattern is a common pattern helps
    us make decisions on different cases, more easily. To understand this better,
    let us use a scenario that you''re developing a notifier program. This notifier
    program will check the given options for a user. A user may want to be notified
    in many ways, like email, SMS, or fax. Your program has to check the available
    options to contact that user and then make a decision upon that. This case can
    easily be solved by Strategy pattern:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编程过程中遇到的一个常见问题是，我们必须在不同的策略上做出决策。策略模式是一种常见的模式，它帮助我们更容易地在不同情况下做出决策。为了更好地理解这一点，让我们使用一个场景，即你正在开发一个通知程序。这个通知程序将检查用户的给定选项。用户可能希望以多种方式被通知，如电子邮件、短信或传真。你的程序必须检查可用的联系方式，然后据此做出决策。这种情况可以通过策略模式轻松解决：
- en: '![Strategy Pattern](img/2561_04_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式](img/2561_04_01.jpg)'
- en: In the above pattern we are using three classes called `SMSNotifier`, `EmailNotifier`,
    and `FaxNotifier`. All these classes implement the Notifier interface, which has
    a method named `notify`. Each of these classes implement that method on their
    own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模式中，我们使用了三个类，分别是`SMSNotifier`、`EmailNotifier`和`FaxNotifier`。所有这些类都实现了`Notifier`接口，该接口有一个名为`notify`的方法。每个类都独立实现了该方法。
- en: Let's create the interface first.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建接口。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we will create different types of notifiers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建不同类型的通知器。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we will use this code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用以下代码：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I'm sure you'll agree that this is pretty simple. I am also sure that you have
    already used such solutions in your existing codes on more than one occasion
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信你会同意这很简单。我也确信你已经在你的现有代码中不止一次使用过这样的解决方案。
- en: Factory Pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Another common design pattern is factory pattern. The main goal of this pattern
    is delivering an object by hiding all the complexities behind it. This may sound
    cryptic, so let's look at it using a real life scenario.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的设计模式是工厂模式。这种模式的主要目标是通过隐藏其背后的所有复杂性来提供对象。这可能听起来有些神秘，所以让我们用一个现实生活中的场景来看看它。
- en: 'You are doing a project that works on a very complex system. For this example,
    you are creating an online document repository, which saves documents in temporary
    storage. For this you need support for PostgreSQL, MySQL, Oracle, and SQLite because
    users may deploy your application using any of these. So you create an object,
    which connects to MySQL and perform the necessary tasks. Your MySQL object is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在进行一个针对非常复杂系统的项目。在这个例子中，你正在创建一个在线文档存储库，它将文档保存在临时存储中。为此，你需要支持 PostgreSQL、MySQL、Oracle
    和 SQLite，因为用户可能会使用这些中的任何一种来部署你的应用程序。所以你创建了一个对象，该对象连接到 MySQL 并执行必要的任务。你的 MySQL
    对象是：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Well, now you use this class like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你可以这样使用这个类：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now see that before you started using your class, you needed to do
    a lot of things. Your PostgreSQL class also looks similar:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，在你开始使用你的类之前，你需要做很多事情。你的 PostgreSQL 类看起来也很相似：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And usage is also the same:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式也是一样的：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But now usage could be a bit difficult when you merge them together:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在当它们合并在一起时，使用可能会有些困难：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shortly after this you will find that as more database engines are added, the
    core code changes significantly and you have to hard code all these things in
    core classes. However, a very good practice of programming is loose coupling.
    Here you make a separate class called `DBManager`, which will perform all these
    things from a central place. Let''s make it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简短地说，当你添加更多的数据库引擎时，核心代码会显著变化，你必须将这些所有东西硬编码到核心类中。然而，编程的一个非常好的实践是松耦合。在这里，你创建一个名为
    `DBManager` 的单独类，它将从中央位置执行所有这些操作。让我们来定义它：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Strategy patternexampleFactory Pattern](img/2561_04_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式示例工厂模式](img/2561_04_02.jpg)'
- en: Now you can use it from a single place called `DBManager`. This makes the thing
    a whole lot easier than before.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从单个位置 `DBManager` 使用它。这使得事情比以前容易得多。
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the real life example of a Factory design pattern. The `DBManager` now
    works as a Factory, which encapsulates all the complexities behind the scene and
    delivers two products. Factory simplifies programming by encapsulating the difficulties
    inside it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工厂设计模式在现实生活中的真实例子。`DBManager` 现在作为一个工厂工作，它封装了幕后所有的复杂性，并提供了两种产品。工厂通过封装其内部的困难来简化编程。
- en: Abstract Factory
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Abstract Factory is almost similar to Factory, the only difference is that all
    your concrete objects must extend a common abstract class. You may ask what is
    the benefit of doing so is. Well, as long as concrete objects are derived from
    a known abstract object, programming is simplified because they all come in the
    same standard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂几乎与工厂相似，唯一的区别是所有具体的对象都必须扩展一个共同的抽象类。你可能会问这样做的好处是什么。好吧，只要具体的对象是从一个已知的抽象对象派生出来的，编程就会简化，因为它们都遵循相同的标准。
- en: Let's have a look at the previous example. We first create an abstract class
    and then extend that object to develop all concrete driver classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的例子。我们首先创建一个抽象类，然后扩展该对象以开发所有具体的驱动类。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now our MySQL will be derived from it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 MySQL 将从它派生出来：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Afactory patternexamplebstract Factory](img/2561_04_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![工厂模式示例抽象工厂](img/2561_04_03.jpg)'
- en: Later we will use this `MySQLManager` class as usual in our `DBManager`. One
    major benefit is that we define all the necessary functions in a single place,
    which is present in all derived classes with the same standard. We can also encapsulate
    common functions/procedures in the abstract class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将像往常一样在 `DBManager` 中使用这个 `MySQLManager` 类。一个主要的好处是我们可以在一个地方定义所有必要的函数，这些函数在所有派生类中都有相同的标准。我们还可以在抽象类中封装常见的函数/过程。
- en: Adapter Pattern
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Another interesting problem in OOP is solved by a design pattern named Adapter.
    So what is an Adapter pattern and what type of problems does it solve?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中另一个有趣的问题是通过一个名为适配器的设计模式来解决的。那么适配器模式是什么，它解决了哪些类型的问题？
- en: Adapter is actually an object that acts like an adapter in real life, in that
    it converts one thing to another. Using Adapter you can convert electric sources
    from higher to lower volts. Similarly in OOP, using Adapter pattern, one object
    can fit for the same methods of another object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器实际上是一个在现实生活中充当适配器的对象，它将一种东西转换成另一种东西。使用适配器，你可以将电源从高电压转换为低电压。同样，在面向对象编程中，使用适配器模式，一个对象可以适应另一个对象的相同方法。
- en: Let us discuss patterns in real life coding in more detail. Suppose you develop
    an online document repository, which exports written documents to popular online
    file storage services. You have developed one wrapper, which can store and retrieve
    documents from Writely using their native API. Well, soon after Google acquired
    Writely, you find that they are temporarily shut down and you have to use Google
    docs as the base of that repository. Now what will you do? You find open source
    solutions to use with Google docs but unfortunately you find that the methods
    of that Google doc object differ from the Writely object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论现实生活中的编码模式。假设你开发了一个在线文档存储库，它可以将文档导出至流行的在线文件存储服务。你已经开发了一个包装器，它可以使用Writely的本地API存储和检索文档。然而，在谷歌收购Writely不久后，你发现他们暂时关闭了服务，你必须使用谷歌文档作为该存储库的基础。现在你该怎么办？你找到了一些开源解决方案与谷歌文档一起使用，但不幸的是，你发现那个谷歌文档对象的操作方法与Writely对象不同。
- en: This is a very common scenario and it happens when classes are developed by
    different developers. You want to use this Google docs object but you don't want
    to change your core code, because then you will have to change it a lot then.
    On top of this there are chances that the code may break after these core changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的场景，它发生在不同开发者开发类的时候。你想要使用这个谷歌文档对象，但你不想更改你的核心代码，因为那样你将不得不大量更改它。而且，在这些核心更改之后，代码可能会出错。
- en: In this scenario an Adapter pattern comes to save your life. You develop a common
    interface which a Writely object implements. Now all you have to do is develop
    another wrapper class, which implements the same interface that was implemented
    by Google Docs. So what will our wrapper class do? It wraps all the methods of
    Google docs class into those available in the interface. After successfully wrapping
    everything, you can use this object straight in your code. You may need to change
    a line or two, but the rest of the core code remains unchanged.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，适配器模式可以拯救你的生命。你开发了一个通用接口，Writely对象实现了这个接口。现在你只需要开发另一个包装类，它实现了谷歌文档实现的相同接口。那么我们的包装类会做什么呢？它将谷歌文档类的所有方法包装到接口中可用的方法里。在成功包装完所有内容后，你可以在代码中直接使用这个对象。你可能需要更改一两行，但核心代码的其他部分保持不变。
- en: 'That''s what''s great about using Adapter pattern. You can keep your core code
    unchanged even when the code of third-party dependencies and external API changes.
    Let us have a closer look at it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用适配器模式的好处。即使第三方依赖和外部API的代码发生变化，你也能保持核心代码不变。让我们更仔细地看看它：
- en: '![AdAbstract Factoryexampleapter Pattern](img/2561_04_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![AdAbstract Factoryexampleapter Pattern](img/2561_04_04.jpg)'
- en: 'Here comes our first version of a Writely object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个Writely对象版本：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the `DocManager` interface:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `DocManager` 接口：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the `GoogleDoc` object looks like something below:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `GoogleDoc` 对象看起来像下面这样：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So how does it fit with our existing code?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是如何与我们的现有代码兼容的呢？
- en: To make it compatible with our existing code, we need to develop the wrapper
    object, which implements the same `DocManager` interface but uses the `GoogleDoc`
    object to perform the actual work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其与我们的现有代码兼容，我们需要开发一个包装对象，它实现了相同的 `DocManager` 接口，但使用 `GoogleDoc` 对象执行实际工作。
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we will just instantiate an instance of `GoogleDocsAdapter` and then use
    that instance in our core code. As it implements the same interface, there is
    no need to change the core code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实例化一个 `GoogleDocsAdapter` 的实例，然后在我们的核心代码中使用这个实例。因为它实现了相同的接口，所以不需要更改核心代码。
- en: 'However, there''s one more thing to note: what about the missing functions?
    For example your `WritelyDocs` object supports the `getFolders()` method, which
    is of no use in `GoogleDocs`. You must implement those methods more carefully.
    For example, if your core code requires some folder ID returned by this method,
    in `GoogleDocsAdapter` you can generate a random folder ID and return them (which
    has no use in `GoogleDocsAdapter)`. So your core code won''t break at all.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一点需要注意：缺失的功能怎么办？例如，你的 `WritelyDocs` 对象支持 `getFolders()` 方法，但在 `GoogleDocs`
    中这个方法没有用。你必须更仔细地实现这些方法。例如，如果你的核心代码需要这个方法返回的一些文件夹ID，在 `GoogleDocsAdapter` 中你可以生成一个随机的文件夹ID并返回它们（这在
    `GoogleDocsAdapter` 中没有用）。所以你的核心代码根本不会出错。
- en: Singleton Pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: One of the most used design patterns is Singleton. This pattern solves a very
    significant problem in object oriented programming and saves the lives of millions
    of programmers in practical programming.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的设计模式之一是单例。这个模式解决了面向对象编程中的一个非常重要的问题，并在实际编程中拯救了数百万程序员的性命。
- en: The main purpose of the Singleton pattern is to deliver a single instance of
    object no matter how many times you instantiate it. That is, if an object is instantiated
    once, using the Singleton pattern you can deliver only that instance when you
    require it again in your code. This saves memory consumption by preventing the
    creation of multiple instances of an object. Thus Singleton pattern is used to
    improve the performance of your application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的主要目的是无论你实例化多少次，都提供对象的单个实例。也就是说，如果一个对象被实例化一次，使用单例模式，你可以在代码中再次需要时只提供那个实例。这样可以节省内存消耗，防止创建多个对象实例。因此，单例模式用于提高应用程序的性能。
- en: '![SinAdapter patternexamplegleton Pattern](img/2561_04_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![SinAdapter 模式示例gleton 模式](img/2561_04_04.jpg)'
- en: Let's take the `MySQLManager` class, which we created in the previous example.
    Now we are adding a single instance feature using Singleton pattern.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前示例中创建的`MySQLManager`类为例。现在我们正在使用单例模式添加一个单例实例功能。
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let us see how it actually works. If you execute the following script, you
    will be surprised to see the result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它实际上是如何工作的。如果你执行以下脚本，你会对看到的结果感到惊讶。
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果为：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Strange, isn't it? The `MySQLManager` class creates only a single instance at
    the very first call, after that it is using the same old object instead of creating
    a new object all the time. Let us see how we achieve it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪，不是吗？`MySQLManager`类在第一次调用时只创建了一个实例，之后它就使用相同的旧对象，而不是每次都创建一个新对象。让我们看看我们是如何实现这一点的。
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our class has a static variable named `$instance`. At the constructor we check
    if the static variable actually contains anything. If it is empty, we instantiate
    the object itself and set the instance in this static variable. As it is static,
    it will remain available throughout the execution of this script.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中有一个名为`$instance`的静态变量。在构造函数中，我们检查这个静态变量实际上是否包含任何内容。如果它是空的，我们就实例化对象本身，并将实例设置在这个静态变量中。由于它是静态的，它将在整个脚本执行过程中保持可用。
- en: Let us get back to the constructor. At the second call, we just check if the
    `$instance` variable contains anything. We find that the `$instance` variable
    is actually containing an instance of this object, and it is still preserved because
    it is a static variable. So in the second call, we actually return the instance
    of this object, which was created by the previous call.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到构造函数。在第二次调用时，我们只是检查`$instance`变量是否包含任何内容。我们发现`$instance`变量实际上包含了这个对象的实例，并且它仍然被保留，因为它是一个静态变量。所以，在第二次调用中，我们实际上返回了由前一次调用创建的这个对象的实例。
- en: Singleton is a very important pattern and you should understand properly what
    it actually does. You can optimize your application and increase its performance
    using this pattern properly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一个非常重要的模式，你应该正确理解它实际上做什么。你可以通过正确使用这个模式来优化你的应用程序并提高其性能。
- en: Iterator Pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Iterator is a common pattern, which helps you to manipulate a collection more
    easily. Almost every language has built-in support of Iterators. Even PHP5 has
    a built-in Iterator objects. Iterators are very useful to provide an easy interface
    to manipulate a collection sequentially.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种常见的模式，它可以帮助你更轻松地操作集合。几乎每种语言都有内置的迭代器支持。甚至PHP5也有内置的迭代器对象。迭代器非常有用，可以提供一个简单的接口来按顺序操作集合。
- en: Let us consider this scenario when the Iterator pattern can save the life if
    a developer is in complex applications. Let us imagine you are creating a blog,
    where users write their daily web logs. How can you display the different posts,
    one by one?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一个场景，当迭代器模式可以在复杂应用程序中拯救开发者时。让我们想象你正在创建一个博客，用户在这里写下他们的日常网络日志。你该如何逐个显示不同的帖子呢？
- en: 'In the following example you pass all the `post_id` made by an author in your
    template and the template designer writes the following code to display it properly
    in the template:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你将所有由作者创建的`post_id`传递到你的模板中，并且模板设计者编写了以下代码来在模板中正确显示：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example we do everything in the template; we fetch all post ids, then
    get authors, comments, content, and display it. We also fetch the comments list
    in the template code. The whole code is too hazy to read and manage and may crash
    successively at any core changes. But just think, if we turn the comments into
    a collection of comment object for that post and all the posts into a collection
    of post object for easier accessing, it will remove the burden of template designing
    as well as create manageable code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在模板中做所有的事情；我们获取所有帖子ID，然后获取作者、评论、内容并显示。我们还在模板代码中获取评论列表。整个代码太模糊，难以阅读和管理，可能在任何核心更改时连续崩溃。但想想，如果我们把评论转换成针对该帖子的评论对象集合，把所有帖子转换成帖子对象集合以便更容易访问，这将减轻模板设计的负担，同时创建可管理的代码。
- en: Let us implement Iterator pattern for our comments and posts and see how effectively
    it turns your code into a readable piece of poem. After all, coding is poetry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的评论和帖子实现迭代器模式，看看它如何有效地将你的代码变成一首可读的诗。毕竟，编码就是诗歌。
- en: 'To use iteration effectively in PHP5 we can use `Iterator` interface. The interface
    is shown below:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP5中，为了有效地使用迭代，我们可以使用`Iterator`接口。该接口如下所示：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `rewind()` function of Iterator sets the index to the start of collection.
    The `Current()` returns the current object. `key()` function returns the current
    key. The Function `next()` returns if there are more object ahead in the current
    loop counter. If the return is yes, this function returns true, otherwise it returns
    false. The `valid()` function returns the current object if it has any value in
    it. Let us create an Iterator for our post object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewind()`函数将迭代器的索引设置到集合的开始。`Current()`返回当前对象。`key()`函数返回当前键。`next()`函数返回在当前循环计数器前是否有更多对象。如果返回是肯定的，此函数返回true，否则返回false。`valid()`函数返回当前对象，如果它有任何值。让我们为我们的帖子对象创建一个迭代器。'
- en: 'We will create a function named `getAllPosts()` that will return all posts
    from the DB. All these posts are returned as a `Post` object, which has methods
    like `getAuthor()`, `getTitle()`, `getDate()`, `getComments()`, etc. Now we will
    create the Iterator:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`getAllPosts()`的函数，该函数将从数据库返回所有帖子。所有这些帖子都以`Post`对象的形式返回，该对象具有`getAuthor()`、`getTitle()`、`getDate()`、`getComments()`等方法。现在我们将创建一个`Iterator`：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now let's use the Iterator we just created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们刚刚创建的`Iterator`。
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code becomes much readable and maintainable now.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在变得更容易阅读和维护。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In PHP array, object implements this Iterator interface by default. But of course
    you can implement it to add many more user-defined functionalities to ease your
    development cycle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP数组中，对象默认实现这个`Iterator`接口。但当然，你可以实现它来添加更多用户自定义的功能，以简化你的开发周期。
- en: Observer Pattern
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: You might wonder how these events actually work and how they are raised. Well,
    if you are familiar with the Observer pattern, you can create event driven applications
    easier than ever.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这些事件实际上是如何工作的以及它们是如何被触发的。好吧，如果你熟悉观察者模式，你可以比以往任何时候都更容易地创建事件驱动应用程序。
- en: An Observer pattern solves a common problem in OOP. For example, if you want
    some objects to be notified automatically when something happens (an event raised),
    you can solve that problem with this pattern. Let us take a closer look.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式解决了面向对象中的常见问题。例如，如果你想当某些对象在发生某些事情（一个事件被触发）时自动通知，你可以用这个模式解决这个问题。让我们更仔细地看看。
- en: An Observer pattern consists of two types of objects; one is an observable object,
    which is observed by `observer` object. When the state of an observable object
    changes, it notifies all observers registered with it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式由两种类型的对象组成；一种是可观察对象，它被`observer`对象观察。当可观察对象的状态发生变化时，它会通知所有与之注册的观察者。
- en: So where can it be used? Actually it is being used everywhere. Think about a
    logging application, which can log errors in different ways when an error occurs.
    Think about a messenger application, which pops up when the latest message arrives.
    Think about a web bulletin board where the latest messages display automatically
    whenever a new message is posted. Well, there are thousands more. Let us implement
    this pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它可以用在哪里呢？实际上，它无处不在。想想一个日志应用，当发生错误时，可以以不同的方式记录错误。想想一个消息应用，当收到最新消息时，会弹出。想想一个网络公告板，每当有新消息发布时，最新消息会自动显示。好吧，还有成千上万的其他应用。让我们实现这个模式。
- en: '![Observer Pattern](img/2561_01_01_200.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](img/2561_01_01_200.jpg)'
- en: 'Our entire `observer` objects implement `observer` interface as shown below:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的`observer`对象都实现了如下所示的`observer`接口：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now some `observer` objects, which we will notify when the state of an observable
    object changes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一些`observer`对象，当可观察对象的状态发生变化时，我们将通知它们：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another notifier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通知器：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we need to create our `observer`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的`observer`。
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let us use it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用它：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Proxy Pattern or Lazy Loading
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式或懒加载
- en: Another very important programming practice in OOP is lazy loading and loose
    coupling. The main idea is to decrease the concrete dependency among objects while
    coding. What is the benefit of such programming? One simple answer—it always increases
    the portability of your code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，另一个非常重要的编程实践是懒加载和松耦合。主要思想是在编码时减少对象之间的具体依赖。这种编程有什么好处？一个简单的答案——它总是增加了你代码的可移植性。
- en: Using the Proxy pattern you can create a local version of a remote object. It
    provides a common API for accessing methods of a remote object without knowing
    the things behind the scene. The best example of a Proxy pattern could be the
    XML RPC and SOAP client and server for PHP.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理模式，你可以创建远程对象的本地版本。它提供了一个通用的API来访问远程对象的方法，而不需要了解幕后的事情。代理模式的一个最佳例子是PHP的XML
    RPC客户端和服务器。
- en: Let's take a look at the following code. Here we are creating a class, which
    can access any method of a remotely created object. The methods of a remote object
    are exposed via the XML RPC server and then they are accessed via XML RPC clients.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码。这里我们创建了一个类，它可以访问远程创建的任何方法。远程对象的方法通过XML RPC服务器公开，然后通过XML RPC客户端访问。
- en: '![Proxy Pattern or Lazy Loading](img/2561_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![代理模式或懒加载](img/2561_04_06.jpg)'
- en: 'If you are wondering how it works, you will find that almost every blog engine
    supports three popular blogging API: i.e. Blogger, MetaWebLog, and MovableType.
    Using these methods you can remotely manage your blog. Which methods are supported,
    will depend on the blog engine.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道它是如何工作的，你会发现几乎每个博客引擎都支持三种流行的博客API，即Blogger、MetaWebLog和MovableType。使用这些方法，你可以远程管理你的博客。支持哪些方法，将取决于博客引擎。
- en: We will use Incutio PHP XML-RPC library to create a sample server and client
    object. Let us create a server first. You can download the XML-RPC Library from
    here:[http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt](http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Incutio PHP XML-RPC库来创建一个示例服务器和客户端对象。让我们先创建一个服务器。你可以从这里下载XML-RPC库：[http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt](http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt)
- en: 'We are creating a time server from which we can get Greenwich Mean Time (GMT):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个时间服务器，我们可以从中获取格林威治标准时间（GMT）：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Well very simple. We just create some methods and then map them to the XML
    RPC server. Now let us see how we can code for clients:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，非常简单。我们只是创建了一些方法，然后将它们映射到XML RPC服务器。现在让我们看看我们如何为客户编写代码：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you place the server in your web server (here `localhost`) document, the
    root in a folder named `proxy` and then access the client, you will get the following
    output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将服务器放在你的网络服务器（这里`localhost`）文档中，根目录在一个名为`proxy`的文件夹中，然后访问客户端，你将得到以下输出：
- en: '**March, 28 2007 16:13:20**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**2007年3月28日 16:13:20**'
- en: That's it! This is how Proxy pattern works and gives interface to remote objects
    for local applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是代理模式的工作原理，并为本地应用程序提供远程对象的接口。
- en: Decorator Pattern
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Decorator pattern is an important problem-solving approach introduced by GoF
    in their legendary design pattern book. Using this pattern you can add additional
    functionalities in an existing object without extending an object. So you might
    ask what is the benefit of adding additional functionalities without inheritance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是GoF在他们传奇的设计模式书中引入的一个重要的问题解决方法。使用这个模式，你可以在不扩展对象的情况下向现有对象添加额外的功能。所以你可能会问，在不使用继承的情况下添加额外的功能有什么好处？
- en: Well, there certainly are some benefits. To extend an object, sometimes you
    need to know many inner things of that class. Sometimes it's not possible to extend
    the class without rewriting the existing functionalities. If you want to add the
    same functionalities to many types of objects, it is much better to add them using
    Decorator pattern instead of extending all of them individually. Otherwise it
    might lead you to a horrible maintenance nightmare.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，当然有一些好处。要扩展一个对象，有时你需要知道那个类的许多内部事情。有时在不重写现有功能的情况下无法扩展该类。如果你想要将相同的功能添加到许多类型的对象中，使用装饰器模式而不是逐个扩展它们会更好。否则，可能会让你陷入可怕的维护噩梦。
- en: '![Decorator Pattern](img/2561_04_08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![装饰器模式](img/2561_04_08.jpg)'
- en: Let us go for a common scenario. For example, imagine that you are building
    a blog or message board where all your posts and comments come as separate post
    and comment objects. Both of these objects have a common method `getContents()`
    which returns the filtered content of that post or comment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个常见的场景。例如，想象你正在构建一个博客或论坛，其中所有帖子评论都作为单独的帖子评论对象出现。这两个对象都有一个公共方法 `getContents()`，它返回该帖子或评论的过滤内容。
- en: Now your manager is asking to add functionalities to parse emoticon and BBCode
    of those posts and comments. The core code is complex and you don't want to touch
    it anymore. Here Decorator pattern comes to save your life.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在经理要求添加解析这些帖子评论中的表情符号和 BBCode 的功能。核心代码很复杂，你不想再触碰它了。这就是装饰器模式拯救你的生命的时候。
- en: Let us see our `Post` and `Comment` object first.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们的 `Post` 和 `Comment` 对象。
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we create two Decorator objects, which can parse the BBCode and Emoticon
    respectively:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了两个装饰器对象，分别可以解析 BBCode 和 Emoticon：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here comes the emoticon parser:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是表情符号解析器：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These Decorator objects just add the BBCode and EmoticonCode parsing capability
    to the existing objects without touching them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器对象只是为现有对象添加了 BBCode 和 EmoticonCode 解析能力，而没有触及它们。
- en: 'Let us see how we can use that:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用它：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is how you can add additional functionalities to existing objects without
    even touching them. However, you saw that BBCodeParser and EmoticonParser accept
    any object, which means that if you supply an object, which doesn't have any method
    named `getContent()`, the code will crash. So you can implement a common interface
    in those objects, which you might want to decorate. Also in the Decorator object
    you can accept only those objects, which implement that or those interfaces.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以在不触及现有对象的情况下添加额外功能的方法。然而，你看到 BBCodeParser 和 EmoticonParser 接受任何对象，这意味着如果你提供一个没有任何名为
    `getContent()` 方法的对象，代码将会崩溃。因此，你可以在那些可能想要装饰的对象中实现一个公共接口。同样，在装饰器对象中，你只能接受实现了该接口或那些接口的对象。
- en: Active Record Pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动记录模式
- en: This is another very important design pattern to simplify database manipulation.
    We will learn more about this pattern in Chapter 7\.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个非常重要的设计模式，用于简化数据库操作。我们将在第 7 章中了解更多关于这个模式的内容。
- en: Facade Pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门面模式
- en: So far we have learned many common problem-solving approaches using design patterns
    in OOP. Here comes another interesting pattern, which we often use unintentionally
    in our code without knowing that it is also a pattern. Let us learn about this
    common pattern named Facade pattern.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用面向对象设计模式解决许多常见问题的方法。现在，我们将了解另一个有趣的模式，我们经常在代码中无意中使用它，而不知道它也是一个模式。让我们了解这个名为门面模式的常见模式。
- en: Facade provides a common interface to many objects. In other words, it just
    simplifies the programming providing a necessary interface, which actually uses
    a lot of other objects behind the scenes. Thus it minimizes the learning curve
    for developers. When a new developer joins the team, he suddenly gets introduced
    to a lot of objects with tons of methods and properties, among which he might
    need a few to accomplish his work. So why bother spending time learning them all?
    This is where Facade helps developers and saves a lot of their time. Let's look
    at some examples to understand it more clearly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 门面（Facade）为许多对象提供了一个公共接口。换句话说，它只是简化了编程，提供了一个必要的接口，实际上在幕后使用了大量其他对象。因此，它最小化了开发者的学习曲线。当一位新开发者加入团队时，他突然会接触到许多带有大量方法和属性的对象，其中他可能只需要几个来完成他的工作。那么为什么还要浪费时间学习它们呢？这就是门面帮助开发者并节省他们大量时间的地方。让我们看看一些例子，以便更清楚地理解它。
- en: Suppose you are creating an apartment rental system, where you have three objects
    in your repository. One object performs the geocoding with the help of online
    geocoding services. Another object locates that place using a map service. Finally,
    another service searches all the apartments for sale in that area.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个公寓租赁系统，在你的存储库中有三个对象。一个对象使用在线地理编码服务进行地理编码。另一个对象使用地图服务定位该地点。最后，另一个服务在该地区搜索所有出售的公寓。
- en: 'Now you want to create an easier interface over these three so that any future
    developer can work with your library instead of studying them all together. The
    following picture shows us the code structure before there is a Facade:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想要创建一个更简单的接口，以便任何未来的开发者都可以使用你的库，而不是一起学习它们。以下图片显示了在门面出现之前的代码结构：
- en: '![Facade Pattern](img/2561_04_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![门面模式](img/2561_04_09.jpg)'
- en: 'Here is the code structure after using Facade:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观模式（Facade）后的代码结构如下：
- en: '![Facade Pattern](img/2561_04_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![外观模式](img/2561_04_10.jpg)'
- en: 'Now let us take a look at the code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下代码：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These are our concrete classes. Now you want to develop a Facade using all
    of them and provide an easier interface for developers. See how easy it makes
    combining three of them:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的具体类。现在你想要使用它们全部来开发一个外观模式（Facade），并为开发者提供一个更简单的接口。看看它是如何使三个类的组合变得如此简单：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Anyone can now use the service of all three classes using only one single interface
    Facade:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任何人都可以通过使用单个接口外观模式（Facade）来使用所有三个类的服务：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As I said before, in object oriented programming we have done this type of job
    several times in our times in our project, however we might not have known that
    the technique is defined as a design pattern named Facade.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，在面向对象编程中，我们在项目中的某个时期已经多次做过这类工作，然而我们可能并不知道这种技术被定义为名为外观模式（Facade）的设计模式。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Design patterns are an essential part of OOP. It makes your code more effective,
    better performing, and easier to maintain. Sometimes we implement these design
    patterns in our code without knowing that these solutions are defined as design
    patterns. There are many design patterns as well, which we cannot cover in this
    book, because it would then simply be a book on just design patterns. However,
    if you are interested in learning other design patterns, you can read *Head First
    Design Patterns* published by O'reilly and *Design Patterns Explained* by Addison-Wesley.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是面向对象编程（OOP）的一个基本组成部分。它使你的代码更有效，性能更好，并且更容易维护。有时我们在代码中实现这些设计模式，却不知道这些解决方案被定义为设计模式。设计模式有很多种，这本书中无法全部涵盖，因为那样的话它就仅仅是一本关于设计模式的书籍了。然而，如果你对学习其他设计模式感兴趣，可以阅读由O'Reilly出版的《*Head
    First Design Patterns*》和由Addison-Wesley出版的《*Design Patterns Explained*》。
- en: Don't think that you have to implement design pattern in your code. Use them
    only when you need them. Proper usage of correct patterns can make your code perform
    better; similarly using them improperly could make your code slow and less efficient.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为你必须在代码中实现设计模式。只有在需要时才使用它们。正确使用正确的模式可以使你的代码性能更佳；同样，不正确地使用它们可能会使你的代码变慢且效率降低。
- en: In the next chapter we will learn about another important section of OOP in
    PHP. That is Unit testing and Reflections. Until then, keep playing with the patterns
    and explore them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习PHP中面向对象编程（OOP）的另一个重要部分。那就是单元测试和反射。在此之前，继续玩转这些模式并探索它们。
