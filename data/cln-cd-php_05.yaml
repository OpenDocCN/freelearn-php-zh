- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Optimizing Your Time and Separating Responsibilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的时间和分离责任
- en: 'It’s time for a little practice after all that theory! We’ve already seen a
    lot together: advanced principles on clean code, how to choose the right external
    libraries for your applications, and how to take advantage of the latest patches
    of these libraries while not risking making your project explode in mid-air. But
    we should not forget that there is the word “code” in “clean code” (obviously).
    In this chapter, we will therefore concentrate a little more on the source code
    of your application and see the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了所有这些理论之后，是时候进行一点实践了！我们已经一起看到了很多：关于编写清洁代码的高级原则、如何为您的应用程序选择正确的外部库，以及如何在不过度风险的情况下利用这些库的最新补丁。但我们不应忘记，“清洁代码”中的“代码”一词（显然）。因此，在本章中，我们将更专注于您应用程序的源代码，并探讨以下要点：
- en: Naming conventions and organization of files and folders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和文件夹的命名规范和组织
- en: Why is it important to separate responsibilities to respect the “S” of the SOLID
    principles? What does it bring to you?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么将责任分离以尊重SOLID原则中的“S”很重要？这对您有什么好处？
- en: We’ll discover an elegant way to manage responsibility separation with an event
    system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将发现一种优雅的方式来通过事件系统管理责任分离
- en: 'And we’ll finish with some polymorphism—namely, abstract classes and interfaces:
    why, how, and when to use them?'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将以一些多态性结束——即抽象类和接口：为什么、如何以及何时使用它们？
- en: Naming and organizational conventions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名和组织规范
- en: We must add a disclaimer before anything else. The naming conventions and organizational
    ideas given in this chapter are not an absolute truth. As we have seen before,
    the most important thing is to respect the conventions already in place in your
    project and to be consistent with your team. If you feel it is necessary, it is
    possible to adapt these rules to your needs. Again, the important thing is to
    use common sense and logic and to be as clear as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先声明，本章中给出的命名规范和组织思想并非绝对真理。正如我们之前所看到的，最重要的是尊重您项目中的现有规范，并与您的团队保持一致。如果觉得有必要，可以对这些规则进行适应以满足您的需求。再次强调，重要的是要使用常识和逻辑，并尽可能清晰。
- en: Let’s first talk about the naming of source files. Obviously, the naming conventions
    differ from one technology to another (depending on whether you use a certain
    framework or another, the good practices may change, for example). Nevertheless,
    we can note some conventions that can be found almost everywhere.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先谈谈源文件的命名。显然，命名规范因技术而异（例如，根据您是否使用某个框架或另一个框架，良好的实践可能会改变）。尽管如此，我们仍可以注意一些几乎在所有地方都可以找到的规范。
- en: Class files and interface files
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类文件和接口文件
- en: '`Foo` class should be defined in a `Foo.php` file. More than a convention,
    this naming technique has a real technical interest. Indeed, the autoloading mechanisms
    of PHP will assume that your file defines a class with the same name. Autoloading
    allows PHP to automatically discover the classes defined in your application,
    and in particular thanks to namespaces (we’ll come back to this in a few moments,
    as these are directly linked to the organization of files in your project). If
    you name your files and the classes they define differently, autoloading is likely
    to fail and throw an error. The most common naming style across the various languages
    and the global developer community for naming classes is `MySuperServiceClass`
    if we used PascalCase. There are other naming styles—we will see some of them
    and in which cases they apply.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo` 类应该在 `Foo.php` 文件中定义。这种命名技术不仅仅是一种规范，它还具有真正的技术意义。确实，PHP 的自动加载机制将假设您的文件定义了一个与文件名相同的类。自动加载允许
    PHP 自动发现您应用程序中定义的类，特别是由于命名空间（我们将在稍后回到这一点，因为它们与您项目中的文件组织直接相关）。如果您为文件和它们定义的类使用不同的名称，自动加载可能会失败并抛出错误。在各个语言和全球开发者社区中，命名类的最常见风格是
    `MySuperServiceClass`，如果我们使用 PascalCase。还有其他命名风格——我们将看到其中一些，以及它们适用的场景。'
- en: Executables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行文件
- en: 'PHP files, being executable command-line scripts, have a strong tendency to
    be named in lowercase. The `apt-get`, `docker-compose`, and `git cherry-pick`
    are perfect ambassadors. Nothing prevents you from naming your executable file
    in another way, and everything will work fine. However, by naming your command-line
    applications written in PHP this way, you provide a uniform **command-line interface**
    (**CLI**) experience with the vast majority of commands. This is exactly what
    we want when we develop a command-line application in PHP: for it to blend in
    with more *traditional* system commands.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文件作为可执行命令行脚本，有很强的趋势使用小写命名。`apt-get`、`docker-compose`和`git cherry-pick`是完美的使者。没有任何东西阻止你以其他方式命名你的可执行文件，一切都会正常工作。然而，通过这种方式命名用PHP编写的命令行应用程序，你为大多数命令提供了一个统一的**命令行界面**（**CLI**）体验。这正是我们在PHP中开发命令行应用程序时想要的：让它与传统系统命令融为一体。
- en: Web assets and resources
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络资源和资产
- en: There is another case where the kebab-case style is used, which is mainly for
    public web resources, particularly JavaScript, `/contact-us`, compared to something
    such as `/contactus` or `/ContactUs`. This can be particularly important if you
    must work on frontend files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种情况使用kebab-case风格，这主要用于公共网络资源，尤其是JavaScript，例如`/contact-us`，与`/contactus`或`/ContactUs`这样的命名方式相比。这在你必须处理前端文件时尤其重要。
- en: Naming classes, interfaces, and methods
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名类、接口和方法
- en: As we have seen in the previous chapters, abbreviations should be banned from
    your code. `Abstract` (for example, `AbstractMailer`) and your interfaces should
    end with the suffix `Interface` (for example, `MailerInterface`). This makes the
    name very slightly longer, but there is no confusion in their use. Their purpose
    is clear, defined, and visible immediately. Don’t be afraid to give your classes
    long names if it is necessary for their understanding. `AbstractWebDeveloperConsoleStreamWrapperExtension`
    may seem extremely long for a class name, but it is immediately clear what it
    is for in a project context, without having to ask too many questions. Again,
    with the autocomplete feature of your IDE, you will be able to use it within seconds
    by typing the first few letters. The same goes for your attribute and method names.
    Be explicit.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，缩写应该从你的代码中禁止。例如，`Abstract`（例如，`AbstractMailer`）以及你的接口应该以`Interface`后缀结尾（例如，`MailerInterface`）。这使得名称略微变长，但在使用上没有混淆。它们的目的清晰、定义明确且一目了然。如果为了理解它们的必要性，不要害怕给你的类起长名字。`AbstractWebDeveloperConsoleStreamWrapperExtension`对于一个类名来说可能非常长，但在项目上下文中，它立即清楚其用途，无需过多提问。再次强调，利用你IDE的自动完成功能，你只需输入前几个字母，就能在几秒钟内使用它。同样适用于你的属性和方法名称。要明确。
- en: Talking about attribute and method naming, we tend to prefer the `myGreatMethod`).
    Some languages use PascalCase for naming methods such as C#. Let’s be honest—there
    is no real justification or argument for this, and both naming styles are actually
    equal. For once, it is really a convention—a language-specific habit.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论属性和方法命名时，我们倾向于喜欢`myGreatMethod`这样的命名。一些语言使用PascalCase来命名方法，例如C#。让我们说实话——这并没有真正的理由或论据，两种命名风格实际上是一样的。一次，这真的是一种约定——一种特定语言的习惯。
- en: Naming folders
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名文件夹
- en: 'The naming conventions for folders are similar to those for files. PascalCase
    is mostly used for folders. Other naming styles can also be used for publicly
    exposed folders, such as web resources. You should not hesitate to create a large
    tree structure and give it meaning. Therefore, folders named simply `Manager`,
    `Service`, or `Wrapper` are to be avoided. These terms are too generic and do
    not allow an easy understanding of what they define. We prefer more explicit variants,
    such as `Mail` and its subfolders `Provider`, `Logger`, and so on. These subfolders
    can have more generic names, being contained in a folder whose name defines a
    context: a domain. A clever way to find your way around is to use folders to separate
    your source code into different domains. Your application will be better sliced
    and your architecture clear. What concerns the same theme will be in the same
    place. You will be much more efficient as this habit becomes natural. Many open
    source projects and libraries use this way of slicing their sources. So, you will
    be able to browse not only your own code but also the code of others. It is sometimes
    extremely complicated and time-consuming to find the right name for an element,
    whether it is a class, a file, a variable, or anything else. This step is, however,
    particularly important and should not be neglected. Be careful not to say to yourself:
    “I put a name that is not necessarily very clear, but I will change it later.”
    Chances are that you will forget it, and technical debt will be brought in without
    you even realizing it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹的命名约定与文件类似。PascalCase 主要用于文件夹。也可以为公开的文件夹使用其他命名风格，例如网络资源。你不应该犹豫创建一个大的树状结构并赋予其意义。因此，简单地命名为
    `Manager`、`Service` 或 `Wrapper` 的文件夹应避免使用。这些术语过于通用，不能轻易理解它们所定义的内容。我们更喜欢更明确的变体，如
    `Mail` 及其子文件夹 `Provider`、`Logger` 等。这些子文件夹可以具有更通用的名称，因为它们包含在一个命名上下文的文件夹中：一个领域。一种巧妙的方法是使用文件夹将源代码分离到不同的领域。你的应用程序将更好地切片，架构更清晰。关于同一主题的内容将位于同一位置。随着这种习惯变得自然，你会更加高效。许多开源项目和库都使用这种方式来分割它们的源代码。因此，你将能够浏览自己的代码，也能浏览他人的代码。有时找到一个合适的元素名称，无论是类、文件、变量还是其他任何东西，都可能是极其复杂和耗时的工作。然而，这一步尤其重要，不应被忽视。注意不要对自己说：“我给出一个不一定非常清晰的名称，但我稍后会更改它。”
    很可能你会忘记它，而且在你甚至没有意识到的情况下，技术债务就会产生。
- en: Separating responsibilities
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离职责
- en: 'Let’s see what the separation of responsibilities in the code consists of,
    to make it cleaner, understandable, maintainable, and extensible. This is the
    first point of the SOLID principles. In the second chapter, this is how we defined
    the principle of single responsibility: “*It means that a class in your code must
    respond to only one task.*”'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码中职责分离的组成部分，使其更干净、易于理解、可维护和可扩展。这是 SOLID 原则的第一点。在第二章中，我们这样定义了单一职责原则：“*这意味着你的代码中的类必须只响应一个任务。*”
- en: As a reminder, SOLID is a set of known clean-code rules that, when applied together,
    will make your code much clearer and more accurate. Rather than trying to follow
    the five principles described by each of the SOLID caps to the letter, it is more
    important to have a global idea of all this in mind when you code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，SOLID 是一组已知的清洁代码规则，当一起应用时，会使你的代码更加清晰和准确。与其试图逐字遵循每个 SOLID 原则所描述的五个原则，不如在编码时全局考虑这一点。
- en: 'The first step to respect this is, in fact... naming, as we just saw! Indeed,
    by naming a class properly, clearly, and, above all, precisely, you are already
    making sure that it doesn’t become a mess where you put a little bit of everything
    that you can think of. And it is for this very reason that it is necessary not
    to name your methods with too generic terms such as `Manager` and `Service`. This
    leads to a big problem: if we end up with a class named `EmailManager`, we will
    obviously all have as a first thought to add all our next methods that deal with
    managing emails. And that’s how the chaos begins. That’s why we will prefer to
    create classes such as `EmailFactory`, `AbstractEmailSender`, and so on in order
    to absolutely avoid having classes with hundreds of different methods.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尊重这一点的第一步实际上是……命名，就像我们刚才看到的！确实，通过恰当地、清晰地、最重要的是精确地命名一个类，你已经在确保它不会变成一个混乱的地方，你可以把所有能想到的东西都放进去。正是出于这个原因，我们有必要不要用像`Manager`和`Service`这样过于通用的术语来命名方法。这会导致一个大问题：如果我们最终得到一个名为`EmailManager`的类，我们显然都会首先想到添加所有处理电子邮件管理的方法。这就是混乱开始的原因。这就是为什么我们更愿意创建像`EmailFactory`、`AbstractEmailSender`等类，以绝对避免有包含数百个不同方法的类。
- en: 'We start to understand better this principle of single responsibility. Let’s
    repeat: the goal is not to create classes with a single method in them. It doesn’t
    make sense. You must split it up intelligently. There is no general rule for splitting
    classes. The right way to split a class will come naturally with experience and
    it will come by itself. If it helps you, you can see folders as domains, and the
    files as subdomains. Using the next examples, we have a domain (or folder) that
    would be named `Email`, and subdomains dedicated to specific tasks: creating an
    email, defining a base class to send an email with a specific email provider,
    and so on. We can go even further in this separation of responsibilities. Indeed,
    tools exist to help us solve this problem in an effortless way. We are going to
    discover (or rediscover!) event dispatching.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始更好地理解单一职责原则。让我们再重复一遍：目标不是创建只包含一个方法的类。这样做没有意义。你必须智能地将其拆分。拆分类的没有通用规则。正确拆分类的方法会随着经验自然出现，并且会自然而然地出现。如果你有帮助，你可以把文件夹看作是领域，而文件看作是子领域。使用接下来的例子，我们有一个名为`Email`的领域（或文件夹），以及专门针对特定任务的子领域：创建电子邮件，定义一个基类以使用特定的电子邮件提供商发送电子邮件，等等。我们甚至可以在职责分离上更进一步。确实，存在一些工具可以帮助我们轻松地解决这个问题。我们将发现（或重新发现！）事件分发。
- en: Event dispatching
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件分发
- en: 'Event dispatching is usually implemented thanks to the Observer and Mediator
    design patterns, as is the case in Symfony’s `EventDispatcher` component. This
    information is just for general knowledge. Indeed, design patterns can seem obscure,
    even scary at first. Moreover, explaining them deserves a book of its own. So,
    we’re going to vulgarize all this without talking about design patterns. Moreover,
    we are not going to implement an event dispatcher: it is about understanding how
    it can help us.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事件分发通常是通过观察者（Observer）和中介者（Mediator）设计模式实现的，就像在Symfony的`EventDispatcher`组件中那样。这些信息只是为了一般了解。确实，设计模式一开始可能会显得晦涩，甚至令人恐惧。此外，解释它们需要一本自己的书。所以，我们将不谈论设计模式，而将这一切通俗化。此外，我们不会实现一个事件分发器：这是关于理解它如何帮助我们的问题。
- en: 'Very simply, the principle of event dispatching is to notify all parties interested
    in the change of state of a particular entity when it happens. The parties will
    notify a central mediator by saying: “I’m interested in knowing when this particular
    event occurs; notify me when it does because I have things to do if it happens.”
    The mediator will then retain this information. When said event occurs, the mediator
    will then go through the list of parties interested in it and say: “The event
    just happened; do what you have to do.” Taking this a step further, it is even
    possible that the interested parties will declare a priority to go before everyone
    else if necessary. Be careful—we are talking about synchronous events, which is
    to say that the parties interested in the event will execute one by one, following
    the others, and not in parallel. Asynchronous event management is a whole other
    story.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单地说，事件分发的原则是在特定实体状态发生变化时，通知所有对此感兴趣的各方。各方将通过以下方式通知中央调解者：“我对知道这个特定事件何时发生感兴趣；当它发生时通知我，因为如果发生，我有一些事情要做。”调解者将保留这些信息。当所述事件发生时，调解者将遍历对此感兴趣的各方列表，并说：“事件刚刚发生；做你需要做的事情。”更进一步，如果必要，感兴趣的各方甚至可以声明一个优先级，以便在其他所有人之前执行。请注意——我们谈论的是同步事件，也就是说，对事件感兴趣的各方将依次执行，跟随他人，而不是并行执行。异步事件管理是另一回事。
- en: 'Event dispatching is as simple as that. But then, how will it help us reinforce
    our principle of single responsibility? Let’s look at a concrete example: a user
    deletes their account from your application. You then need to do two tasks, as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事件分发就是这样简单。但是，它如何帮助我们强化单一责任原则呢？让我们看看一个具体的例子：用户从你的应用程序中删除他们的账户。然后你需要执行两个任务，如下所示：
- en: Delete the account from the database
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中删除账户
- en: Send a last email to the user to say a sad goodbye
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给用户发送最后一封电子邮件，说一声悲伤的再见
- en: So, we will naturally create a service such as `UserRemover`, which will perform
    these two tasks in a row. It works very well. `UserRemover` is an explicit name
    that defines a very precise task. No problem so far. Then, one day, your application
    gains popularity. You want to send an email to the administrators to notify them
    that the user has left. Our `UserRemover` class ends up deleting data and sending
    two emails, both with very specific content and recipients.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们自然会创建一个名为`UserRemover`的服务，它将依次执行这两个任务。它工作得很好。`UserRemover`是一个明确的名称，定义了一个非常精确的任务。到目前为止没有问题。然后，有一天，你的应用程序变得流行起来。你想要给管理员发送一封电子邮件，通知他们用户已经离开。我们的`UserRemover`类最终删除数据并发送了两封电子邮件，内容非常具体，收件人也非常明确。
- en: 'Later on, you want to give the user the possibility to delete their account
    to respect the `UserRemover` service that actually removes nothing, sends emails,
    and maybe many other tasks. We have a real problem: the class doesn’t do what
    it is supposed to do, and it is likely that it is now thousands of lines long
    and has dozens of methods.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你想要给用户删除账户的可能性，以尊重实际上不删除任何内容、发送电子邮件以及可能执行许多其他任务的`UserRemover`服务。我们遇到了一个真正的问题：这个类没有做它应该做的事情，并且它现在可能已经有一千多行代码，有几十个方法。
- en: 'Things would have been hugely different if you had used event dispatching from
    the beginning. Here is an example of a resolution. When a user wants to leave
    your application, you will dispatch an event named `UserRemovalRequestEvent`.
    Then, as your application grows, you will create parties interested in this event:
    event listeners. We will have one per task, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一开始就使用事件分发，情况将会大不相同。以下是一个解决方案的例子。当用户想要离开你的应用程序时，你将分发一个名为`UserRemovalRequestEvent`的事件。然后，随着你的应用程序的增长，你将创建对此事件感兴趣的各方：事件监听器。我们将为每个任务创建一个，如下所示：
- en: A listener to remove data from the database
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于从数据库中删除数据的监听器
- en: A listener for the goodbye mail to the user
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于发送给用户的告别邮件监听器
- en: A listener for the mail to the administrators
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于发送给管理员的邮件监听器
- en: 'What about anonymization? Nothing simpler: we will create a listener for this
    task too, and we will “unplug” the listener for deleting data. So, we have one
    class per task. Each class has its own unique responsibility (send an email to
    the administrators, anonymize data, and so on). If in the future you need to add
    a task, you will create a new class (or listener) with a specific task, without
    ever touching the other classes. The code is then clean and extremely extensible.
    The classes remain well-named and concise. If a task is obsolete, you can simply
    remove it from the list of parties interested in the event in question. The principle
    of single responsibility is respected.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于匿名化？这很简单：我们也将为这个任务创建一个监听器，并将删除数据的监听器“断开连接”。因此，每个任务都有一个类。每个类都有其独特的责任（向管理员发送电子邮件、匿名化数据等等）。如果在将来你需要添加一个任务，你将创建一个新的类（或监听器）来执行特定的任务，而无需触及其他类。这样代码就变得干净且极具可扩展性。类名保持清晰且简洁。如果一个任务已经过时，你可以简单地将其从对相关事件的感兴趣方列表中移除。单一责任原则得到了尊重。
- en: If you want to use a ready-to-use event dispatcher, we recommend using the `symfony/event-dispatcher`
    package. This is exactly the component that is used in the framework for its operation.
    It is very robust and efficient and has been proven for several years.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用现成的事件分发器，我们推荐使用`symfony/event-dispatcher`包。这正是框架用于其操作所使用的组件。它非常健壮和高效，并且已经经过了几年的验证。
- en: Demystifying polymorphism – interfaces and abstract classes
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性的揭秘——接口和抽象类
- en: 'As far as the separation of responsibilities is concerned, event dispatching
    is a concept that is already advanced. You can consider that your level in the
    world of clean code has increased considerably if you know this mechanism, understand
    it, and have the chance to use it. All this obviously requires a bit of setup.
    Either you implement this system by yourself or you use an external library. In
    the second case, there is obviously a whole learning phase to be included. Either
    way, this is obviously not the only way to improve the separation of your responsibilities.
    There is a way that is native to PHP to improve this separation, sometimes not
    used enough, sometimes misunderstood, and often underestimated. We are talking
    here about polymorphism, or vulgarly: abstract classes and interfaces.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就责任分离而言，事件分发是一个已经相当高级的概念。如果你知道这个机制，理解它，并且有机会使用它，那么你可以认为你在干净代码的世界中的水平已经大大提高。所有这些显然都需要一些设置。要么你自己实现这个系统，要么使用外部库。在后一种情况下，显然有一个完整的学习阶段需要包括。无论如何，这显然不是提高你责任分离的唯一方法。有一种方法是PHP的本地方法，可以用来提高这种分离，有时没有得到足够的利用，有时被误解，并且经常被低估。我们在这里谈论的是多态性，或者通俗地说：抽象类和接口。
- en: First, why the word *polymorphism*? *Poly* comes from the Greek meaning *many*,
    and *morphism* means *form*/*shape*. Abstract classes and interfaces are just
    one way to implement polymorphism in code and **object-oriented programming**
    (**OOP**). To simplify things, let’s take only the case of interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么是“多态性”这个词？*Poly*来自希腊语，意思是“许多”，而*morphism*意味着“形式”或“形状”。抽象类和接口只是实现代码中多态性的一种方式，以及面向对象编程（**OOP**）。为了简化问题，让我们只考虑接口的情况。
- en: Interfaces
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'Interfaces define a common form/shape for classes that implement them later.
    They determine the methods that each implementation should define for its case.
    An implementation must necessarily define all the methods of its interface(s).
    This is often the reason why we hear the following statement: “an interface is
    a contract”. We can see it this way: if you implement an interface, you commit
    to implementing the methods it defines. You have no other alternative.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接口为后来实现它们的类定义了一个通用的形式/形状。它们确定了每个实现应该为其情况定义的方法。实现必须必然定义其接口（或接口）的所有方法。这通常是我们听到以下声明的原因：“接口是一种契约”。我们可以这样理解：如果你实现了一个接口，你承诺实现它定义的方法。你没有其他选择。
- en: 'This is where the full power of polymorphism takes place. In your code, you
    can tell PHP that a so-and-so argument of a method will necessarily be an instance
    of an object implementing a precise interface. You can manipulate the different
    methods of this interface and call them. You don’t have to worry about how it
    will be implemented when it is used: we are not interested in that. As an example,
    is worth a thousand words, let’s take our mail system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多态的强大之处所在。在你的代码中，你可以告诉PHP，一个方法的一个参数必然是实现了精确接口的对象的实例。你可以操作这个接口的不同方法并调用它们。你不必担心它在被使用时如何实现：我们对此不感兴趣。举个例子，一张图片胜过千言万语，让我们以我们的邮件系统为例。
- en: 'You have `MailerInterface` that defines only one method: a method to send a
    mail. We could name it `sendEmail`. As before, when a user is deleted in your
    application, the event listener for sending a goodbye mail is called. In this
    case, what you are interested in is that the mail is simply sent, not the internal
    workings of the sending. By the way, couldn’t these internal workings be different
    depending on certain conditions? You don’t have to look far for an example: your
    main email provider could be down, but you absolutely need to send your message.
    You then must use another email provider, with a different **application programming
    interface** (**API**), different options, and so on. Without polymorphism, things
    could get extremely complicated very quickly.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你有`MailerInterface`，它只定义了一个方法：一个发送邮件的方法。我们之前可以将其命名为`sendEmail`。当用户在你的应用程序中被删除时，发送告别邮件的事件监听器被调用。在这种情况下，你感兴趣的是邮件简单地被发送，而不是发送的内部工作原理。顺便说一句，这些内部工作原理是否可能根据某些条件而不同？你不必找太远就能找到一个例子：你的主要电子邮件提供商可能不可用，但你绝对需要发送你的消息。然后你必须使用另一个电子邮件提供商，它有不同的**应用程序编程接口**（**API**）、不同的选项等等。没有多态，事情可能会很快变得极其复杂。
- en: 'The solution is to create two implementations of `MailerInterface`, each defining
    the `sendEmail` method, depending on the email provider used. But the result is
    the same: the mail is sent. When a user deletes their account, you perform a check
    to make sure that your main email provider is up and instantiate its implementation.
    If it is down, you instantiate the backup email provider implementation. On the
    other hand, in the email sending event listener, you just keep calling the `sendEmail`
    method defined in `MailerInterface`, without worrying about the rest. The code
    is clean, clear; responsibilities are separated; you save time. And on top of
    that, it has become resilient to failure.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建两个`MailerInterface`的实现，每个实现根据所使用的电子邮件提供商定义`sendEmail`方法。但结果是相同的：邮件被发送。当用户删除他们的账户时，你执行检查以确保你的主要电子邮件提供商是可用的并实例化其实现。如果它不可用，你实例化备份电子邮件提供商的实现。另一方面，在电子邮件发送事件监听器中，你只需不断调用在`MailerInterface`中定义的`sendEmail`方法，无需担心其他问题。代码干净、清晰；责任分离；你节省了时间。而且更重要的是，它已经变得对失败具有弹性。
- en: 'You could do this with 10, 15, or 20 email providers if you wanted to. The
    advantage is that if the API of one of the providers changes or you find a bug
    in your implementation, you only have to touch the one implementation that is
    problematic. All the others don’t move, as is the case with the calls that are
    made to the interface. You considerably reduce the risk of bugs, and your code
    is much more testable: you can write tests specifically for each implementation.
    This is much more robust than generalized, endless tests that try to evaluate
    every possible case! The time saved is exceptional and priceless.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以用10、15或20个电子邮件提供商来做这件事。优势在于，如果某个提供商的API发生变化或你在你的实现中找到一个错误，你只需修改有问题的那个实现。其他所有实现都不会移动，就像调用接口时的那样。你大大降低了错误的风险，你的代码也更容易测试：你可以为每个实现编写特定的测试。这比那些试图评估所有可能情况的通用、无休止的测试要稳健得多！节省的时间是异常的，无价的。
- en: Abstract classes
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'And how do abstract classes fit in all this? We can see these as an intermediate
    layer between an interface and its implementations. Although it is obviously not
    mandatory that an abstract class implements an interface, it is often a clever
    idea to create an interface on top of an abstract class. Indeed, the latter are
    more permissive than interfaces: you can partially define the methods that are
    declared, declare attributes, and decide on the visibility of the methods and
    attributes of the class (where interfaces only allow `public` visibility and not
    `private` or `protected`). With an interface, you have a clean contract, without
    any information that would be here “just in case” and with only the bare essentials
    if you respect the “I” of the SOLID principles—the interfaces’ segregation. As
    a reminder and simply put, this principle indicates that an interface should not
    contain methods that are declared “just in case” and that each one should help
    to meet the principle of single responsibility.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么抽象类在这个体系中是如何定位的呢？我们可以将其视为接口及其实现之间的一个中间层。虽然显然抽象类不一定要实现接口，但通常在抽象类之上创建一个接口是一个明智的想法。确实，抽象类比接口更宽容：你可以部分定义声明的方法，声明属性，并决定类的方法和属性的可见性（接口只允许`public`可见性，不允许`private`或`protected`）。使用接口，你有一个干净的合同，没有任何“以防万一”的信息，并且只有当你尊重SOLID原则中的“I”（接口的隔离）时，才包含最基本的信息。作为一个提醒，简单来说，这个原则表明接口不应该包含“以防万一”声明的方
- en: Abstract classes allow us to define common behaviors to the classes that extend
    them and that wish to take advantage of the power of polymorphism. In particular,
    this avoids code redundancy, sources of bugs, and endless copy-pasting. Indeed,
    in our previous example, it is highly likely that the different implementations
    of `MailerInterface` have common behaviors, such as the creation of the HTTP client
    that communicates with the API of the email provider or the creation of a `Message`
    common object used in the internal workings of the implementations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类允许我们为扩展它们的类定义共同的行为，这些类希望利用多态性的力量。特别是，这避免了代码冗余、错误来源和无休止的复制粘贴。确实，在我们的上一个例子中，`MailerInterface`的不同实现很可能有共同的行为，例如创建与电子邮件提供商API通信的HTTP客户端或创建一个在实现内部操作中使用的通用`Message`对象。
- en: In this case, we would declare `AbstractMailer` implementing `MailerInterface`
    and define common behaviors of the different implementations. Then, the different
    implementations would extend `AbstractMailer` in order to enjoy the common behavior
    you just defined.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会声明实现`MailerInterface`的`AbstractMailer`并定义不同实现中的共同行为。然后，不同的实现会扩展`AbstractMailer`以享受你刚刚定义的共同行为。
- en: Be careful—this does not mean that it is necessary to create interfaces and
    abstract classes everywhere, all the time, and in all cases. We should not neglect
    the impact that this has on the complexity of the code compared to a single class.
    Also, just because you haven’t created an interface for a case doesn’t mean that
    it is immutable and set in stone. Very often, we find ourselves refactoring our
    code and creating interfaces and abstract classes and adapting existing classes
    to implement and extend them. As we have seen, we need to keep the code simple
    at first (respecting the *YAGNI* and *KISS* principles). We cannot predict the
    future, business constraints evolve.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意——这并不意味着在所有地方、所有时候和所有情况下都必须创建接口和抽象类。我们不应该忽视这对比单一类对代码复杂性的影响。此外，仅仅因为你还没有为某个情况创建接口，并不意味着它是不可变的和固定不变的。很多时候，我们发现自己在重构代码，创建接口和抽象类，并调整现有类以实现和扩展它们。正如我们所看到的，我们最初需要保持代码的简单性（尊重*YAGNI*和*KISS*原则）。我们无法预测未来，业务约束在不断发展。
- en: If at the time of creating a class, there is nothing to suggest that different
    implementations will be needed, this is not a concern. This is a job that will
    be done later. On the other hand, if during development you find yourself copying
    code from one side to the other and perceive a strong redundancy, it will be an
    excellent reflex to think about polymorphism.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建类的时候，没有迹象表明需要不同的实现，这并不是一个需要担心的问题。这是一个以后会完成的任务。另一方面，如果在开发过程中，你发现自己正在从一边复制代码到另一边，并且感觉到强烈的冗余，那么考虑多态性将是一个极好的反应。
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just covered the most advanced part of the theoretical section of this
    book. We are now armed with the knowledge to cut our code cleanly while keeping
    it maintainable and extensible for future developers. It will also be ready for
    the future by being strongly open to extension and closed to modification (as
    described in one of the *SOLID* principles).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚覆盖了这本书理论部分的最高级内容。我们现在拥有了知识，可以在保持代码可维护和可扩展的同时，为未来的开发者编写干净的代码。它也将通过强烈地开放扩展和封闭修改（如*SOLID*原则之一所述）为未来做好准备。
- en: We have reviewed many of the cases that you may encounter regarding the naming
    of files, classes, and methods when developing a PHP application. In addition,
    we have seen that folders must have specific names and can be used to divide your
    application into different domains.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了许多你可能在开发PHP应用程序时遇到的关于文件、类和方法命名的案例。此外，我们还看到文件夹必须有特定的名称，并且可以用来将你的应用程序划分为不同的域。
- en: The separation of responsibilities was also a big topic. It is particularly
    important to understand why this separation is useful, even vital, in a project.
    It is the real key to a well-architected project that is easy to navigate. Event
    dispatching is an excellent way to achieve this, as we have seen. Event dispatching
    is one of the cornerstones of some critical web projects such as the Symfony framework,
    to name but one. This one relies heavily on this mechanism, making it a tool known
    for its robustness, its efficiency, and—especially—its flexibility. This is also
    due to the polymorphism and the different interfaces declared within it. You can
    redeclare pretty much any part of the framework thanks to this and adapt everything
    to your most advanced needs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 职责分离也是一个重要的话题。理解为什么这种分离在项目中是有用的，甚至是至关重要的，尤为重要。这是构建一个易于导航的、良好架构项目的真正关键。正如我们所看到的，事件分发是实现这一目标的绝佳方式。事件分发是某些关键Web项目（如Symfony框架）的基石之一。这个框架在很大程度上依赖于这种机制，使其成为一个以稳健性、效率和——尤其是——灵活性著称的工具。这也归功于其内部的泛型和不同接口的声明。你可以通过这种方式重新声明框架的几乎所有部分，并将其适应到你的最高级需求。
- en: It is not always easy to understand when to create an interface or an abstract
    class. This comes with practice and experience. Soon, it will seem natural. When
    in doubt, talk to one of your peers!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是容易理解何时创建一个接口或抽象类。这需要实践和经验。很快，这就会显得很自然。如果有疑问，不妨和你的同行交流一下！
- en: We will finish the theoretical part of this book with a lighter part in the
    next chapter, dealing with the new features of PHP. These make us more rigorous
    and better developers, especially in the last few years.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章以一个轻松的部分结束这本书的理论部分，这部分将讨论PHP的新特性。这些特性使我们更加严谨，成为更好的开发者，尤其是在过去几年里。
