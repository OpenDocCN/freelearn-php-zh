- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building Solution Code with BDD and TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BDD和TDD构建解决方案代码
- en: 'Now that we have gone through the fundamentals of writing test programs using
    **test-driven development** (**TDD**) and **behavior-driven development** (**BDD**),
    we can start using both processes in developing our example application. When
    working on commercially successful and large-scale applications, one thing is
    common: they all need maintenance. There will always be room for improvement in
    terms of the product’s functionality. There could be some bugs that were missed,
    and—more commonly—more features to improve the product will continuously be added
    to the application. This is usually how badly written code gets worse. A nicely
    written class can end up being a god class: a class that can do everything with
    a few thousand lines of code. A developer can start writing additional functions
    inside the god class while another developer is using that class, therefore changing
    the class’s behavior. You can guess what happens next! A new bug is introduced.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**）编写测试程序的基础，我们可以开始在开发我们的示例应用程序时使用这两个过程。当处理商业成功的大型应用程序时，有一件事是共同的：它们都需要维护。在产品的功能方面，总会有改进的空间。可能会有一些被遗漏的bug，而且更常见的是，为了改进产品，将不断向应用程序中添加更多功能。这就是编写糟糕的代码变得更糟的通常方式。一个编写得很好的类最终可能成为一个神级类：一个可以用几千行代码做所有事情的类。一个开发者可以在另一个开发者使用该类的同时在神级类中编写额外的函数，因此改变类的行为。你可以猜到接下来会发生什么！引入了一个新的bug。
- en: There are a lot of times during development when a developer may start working
    on a feature that will depend on other features that are not written yet. So,
    how do we write tests for these types of features? We’ll need to start mocking
    those dependencies. In this chapter, we will learn how to use mock objects and
    we will also start writing our code so that it will be cleaner and easier to maintain
    by following the SOLID principles. We will also be using the Red-Green-Refactor
    pattern to help us lay down the tests and features that we need to build. But
    before all that, we’ll first create a Behat feature to kickstart all of the tests
    and code we’ll be writing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，开发者可能会开始开发一个将依赖于尚未编写的其他功能的功能。那么，我们如何为这类功能编写测试呢？我们需要开始模拟这些依赖项。在本章中，我们将学习如何使用模拟对象，并且我们将开始编写代码，以便遵循SOLID原则使其更干净、更容易维护。我们还将使用红-绿-重构模式来帮助我们构建所需的测试和功能。但在所有这些之前，我们首先创建一个Behat功能来启动我们将要编写的所有测试和代码。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Implementing the Red-Green-Refactor pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施红-绿-重构模式
- en: Writing tests and solution code for the example project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为示例项目编写测试和解决方案代码
- en: Creating a Behat feature based on a Jira ticket
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Jira工单创建Behat功能
- en: Passing the Behat registration feature
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Behat注册功能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you are advised to use the following base code from this code
    repository: [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd).
    After completing the chapter, the resulting solution code can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/complete](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/complete)
    for reference.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，建议您使用以下来自此代码仓库的基本代码：[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd)。完成本章后，最终的解决方案代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/complete](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/complete)处找到以供参考。
- en: Preparing the development environment for the chapter
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备章节的开发环境
- en: 'First, get the base code for this chapter found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base)
    or simply run the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取本章的基础代码，可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base)找到，或者简单地运行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器并执行本章中的命令，你应该在 `docker-server-web-1` 容器内。
- en: 'Run the following command to confirm the container name for our web server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以确认我们的 web 服务器的容器名称：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run the containers, run the following command from the `/docker` directory
    from the repository in your host machine:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，从你的主机机器上的 `/docker` 目录运行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once inside the container, run the following commands to install the libraries
    required through Composer:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，运行以下命令以通过 Composer 安装所需的库：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Implementing the Red-Green-Refactor pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施红-绿-重构模式
- en: The Red-Green-Refactor pattern is a type of programming approach to implementing
    TDD. It’s a cycle where you first deliberately write a failing test, in which
    you see a red-colored failing message when you execute the test. Then, you write
    solution code to pass that test, in which you will see a green-colored passing
    message. After passing the test, you can then go back to clean up and refactor
    your test and solution code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 红绿重构模式是一种编程方法，用于实现 TDD。这是一个循环，你首先故意编写一个失败的测试，在执行测试时，你会看到一个红色的失败信息。然后，你编写解决方案代码来通过那个测试，在这个过程中，你会看到一个绿色的通过信息。通过测试后，你就可以回到清理和重构你的测试和解决方案代码了。
- en: If you open the `codebase/symfony/runDebug.sh` file that we created earlier
    in this book in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*,
    you’ll notice that we are running PHPUnit by adding the `--color=always` parameter.
    Then, whenever we run PHPUnit and we get a failing test, you will notice that
    we always get a red error or failed test message.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开本书前面创建的 `codebase/symfony/runDebug.sh` 文件，在 [*第 5 章*](B18318_05.xhtml#_idTextAnchor070)
    中，你会注意到我们通过添加 `--color=always` 参数来运行 PHPUnit。然后，无论何时我们运行 PHPUnit 并得到失败的测试，你都会注意到我们总是得到红色的错误或失败的测试信息。
- en: 'To demonstrate the pattern clearly, let’s go through an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地展示这个模式，让我们通过一个例子来演示：
- en: 'Create a new file called `HelloTest.php`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HelloTest.php` 的新文件：
- en: codebase/symfony/tests/Unit/HelloTest.php
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/HelloTest.php
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After creating the new unit test, run the following command to make sure that
    PHPUnit can execute a `testCanSayHello` test:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新的单元测试后，运行以下命令以确保 PHPUnit 可以执行 `testCanSayHello` 测试：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should then see the following result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下结果：
- en: '![Figure 7.1 – Red highlighted failed message](img/Figure_7.01_B18318.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 红色高亮的失败信息](img/Figure_7.01_B18318.jpg)'
- en: Figure 7.1 – Red highlighted failed message
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 红色高亮的失败信息
- en: In TDD, we always start by writing a test that will have no implementations
    to support or pass it. We then need to run the test to make sure that PHPUnit
    recognizes the test and that it can execute it. We also want to confirm that we’ve
    created the test class in the correct test suite and the correct directory and
    that it uses the correct namespace.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 中，我们总是从编写一个没有任何实现支持的测试开始。然后我们需要运行这个测试以确保 PHPUnit 识别测试并且可以执行它。我们还想确认我们已经创建了正确的测试类，在正确的测试套件和正确的目录中，并且使用了正确的命名空间。
- en: After running the command stated previously, this newly created test will fail
    as expected and PHPUnit will show a red colored error or fail message. This is
    the *Red* in the Red-Green-Refactor pattern!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前提到的命令后，这个新创建的测试将如预期失败，PHPUnit 将显示红色的错误或失败信息。这就是红-绿-重构模式中的*红色*！
- en: 'Once we are sure that we can use PHPUnit to run a test, we can then move on
    to start writing code to pass our failing test. Remember TDD? Our test will start
    or drive the creation of the solution code to solve a problem, hence test-driven.
    So, now, to quickly pass the failing test, we will write some code to pass the
    failing test by following these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确信可以使用 PHPUnit 运行测试，我们就可以开始编写代码来通过失败的测试。还记得 TDD 吗？我们的测试将启动或驱动解决方案代码的创建，以解决问题，因此是测试驱动的。所以，现在，为了快速通过失败的测试，我们将编写一些代码来通过失败的测试，按照以下步骤进行：
- en: 'Modify the test and add a new class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改测试并添加一个新类：
- en: Codebase/symfony/tests/Unit/HelloTest.php
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Codebase/symfony/tests/Unit/HelloTest.php
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类：
- en: codebase/symfony/src/Speaker.php
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Speaker.php
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `HelloTest` class, we have modified the `testCanSayHello()` method so
    that it will create an instance of the new `Speaker` class we created, and then,
    in the assertion line, we directly compare the expected word `Hello` to the string
    returned by the `sayHello()` method. Now, if we run the test again, we should
    no longer see the red failure message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HelloTest`类中，我们修改了`testCanSayHello()`方法，使其创建我们创建的新`Speaker`类的实例，然后在断言行中，我们直接将预期的单词`Hello`与`sayHello()`方法返回的字符串进行比较。现在，如果我们再次运行测试，我们就不应该再看到红色的失败消息。
- en: 'Run the same test by using the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行相同的测试：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should now see the following result from PHPUnit:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该看到以下结果来自PHPUnit：
- en: '![Figure 7.2 – Green highlighted message](img/Figure_7.02_B18318.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 高亮显示的绿色消息](img/Figure_7.02_B18318.jpg)'
- en: Figure 7.2 – Green highlighted message
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 高亮显示的绿色消息
- en: We passed the test! Now, our `testCanSayHello()` test no longer returns a red
    error/failure message. We did the minimum work to pass the test, and we can now
    see a green **OK (1 test, 1 assertion)** message instead. This is the *Green*
    in the Red-Green-Refactor pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过了测试！现在，我们的`testCanSayHello()`测试不再返回红色的错误/失败消息。我们只做了最基本的工作来通过测试，现在我们可以看到一个绿色的**OK
    (1 test, 1 assertion)**消息。这是红-绿-重构模式中的**绿色**。
- en: When you’re working on your own project, at this stage after passing a test,
    you can either move on to the next test or next problem in your list of things
    to do or you can try improving both the test and the solution code to make it
    cleaner and easier to read.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在自己的项目中工作时，在通过测试的这个阶段，你可以继续进行列表中的下一个测试或下一个问题，或者你可以尝试改进测试和解决方案代码，使其更简洁、更易于阅读。
- en: In this example, we’ll go ahead and improve both the test and solution code
    to let it support more test scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将继续改进测试和解决方案代码，以便它支持更多的测试场景。
- en: 'Follow these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Modify the `HelloTest` class with the following content:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容修改`HelloTest`类：
- en: codebase/symfony/tests/Unit/HelloTest.php
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/HelloTest.php
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modify the `Speaker.php` class with the following content:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容修改`Speaker.php`类：
- en: codebase/symfony/src/Speaker.php
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Speaker.php
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have refactored the test so that we can add more flexibility to the `Speaker.php`
    class. We have also refactored the `HelloTest.php` test class itself to be more
    flexible as well. If we run the test again, we should still pass the test.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了测试，以便我们可以为`Speaker.php`类添加更多灵活性。我们还重构了`HelloTest.php`测试类本身，使其更加灵活。如果我们再次运行测试，我们应该仍然通过测试。
- en: 'Run the test again by running the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令再次运行测试：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we should see the following result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该看到以下结果：
- en: '![Figure 7.3 – Still green after the refactor](img/Figure_7.03_B18318.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 重构后仍然绿色](img/Figure_7.03_B18318.jpg)'
- en: Figure 7.3 – Still green after the refactor
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 重构后仍然绿色
- en: You will notice that instead of getting `@dataProvider`. We then created a new
    function called `provideHelloStrings()` that returns an array of closures and
    strings. Each array set will be used as parameters for the `testCanSayHello()`
    test method. At this stage, we still pass the test, even after we have done the
    refactors. This is the *Refactor* phase of the Red-Green-Refactor pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们不是使用`@dataProvider`。然后我们创建了一个名为`provideHelloStrings()`的新函数，它返回一个包含闭包和字符串的数组。每个数组集将被用作`testCanSayHello()`测试方法的参数。在这个阶段，即使我们进行了重构，我们仍然可以通过测试。这是红-绿-重构模式中的**重构**阶段。
- en: It will be very common in a real-world enterprise project to write programs
    that rely on someone else’s project that is not readily available to you or your
    team. Should this stop you from developing your program that relies on something
    that is not complete yet? Probably not! Next, we’ll need a way to focus on testing
    a specific part of our application, even if it depends on other objects that are
    not built yet. For this, we will need to use mock objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的企业项目中，编写依赖于其他人项目（而你或你的团队无法轻易获得）的程序是非常常见的。这会阻止你开发依赖于尚未完成的某物的程序吗？可能不会！接下来，我们需要一种方法来专注于测试我们应用程序的特定部分，即使它依赖于尚未构建的其他对象。为此，我们将需要使用模拟对象。
- en: Writing tests and solution code for the example project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为示例项目编写测试和解决方案代码
- en: Back in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027), *Understanding and
    Organizing the Business Requirements of Our Project*, we used Jira as a tool to
    organize the list of things we need to build for the project. Aside from using
    Jira, there is other project tracking software out there too, or we can just simply
    use a notepad or a piece of paper and write down the tasks we want to write programs
    for. But we just want to be a bit more organized, and if you’re working with a
    team of software developers and with other teams in the company, it’s easier to
    collaborate if you use issue-tracking software, rather than a piece of physical
    paper.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18318_02.xhtml#_idTextAnchor027) *理解并组织我们项目的业务需求*中，我们使用 Jira 作为工具来组织我们需要为项目构建的项目清单。除了使用
    Jira 之外，还有其他的项目跟踪软件，或者我们也可以简单地使用便签或一张纸，写下我们想要编写的程序的任务。但我们只是想更有条理一些，如果你与软件开发团队以及其他公司团队一起工作，使用问题跟踪软件比使用一张物理纸张更容易协作。
- en: 'We have grouped the Jira user stories into two groups: the **Inventory Clerk
    Solution** group and the **Visitors Page** group. These groups are called epics.
    We will start working on the **Inventory Clerk Solution** epic first. This is
    to allow the car museum inventory clerk to enter that valuable data into the system
    for the visitors to view.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 Jira 用户故事分为两组：**库存管理员解决方案**组和**访客页面**组。这些组被称为史诗。我们将首先开始工作于**库存管理员解决方案**史诗。这是为了让汽车博物馆的库存管理员能够将那些宝贵的数据输入到系统中供访客查看。
- en: Up to this point, as we were going through BDD and TDD, we were playing with
    our development environment setup as an example. Now, we can use it to build our
    example project too. Download the base code from [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd).
    You can use the base code and push it into your master branch that is linked to
    your Jira project. Then, all subsequent tickets that we will be working on moving
    forward will branch off and get merged from and into that master branch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们通过 BDD 和 TDD 进行操作时，我们以我们的开发环境设置为例进行操作。现在，我们也可以用它来构建我们的示例项目。从[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%207/base/phptdd)下载基础代码。你可以使用基础代码并将其推送到与你的
    Jira 项目链接的 master 分支。然后，我们将从该 master 分支分叉，并将所有后续的票证分支出来，合并到该 master 分支中。
- en: 'Let’s start with the first ticket, `TOYC-2`. Go back to your Jira `TOYC-2`
    story, then click on the **Create branch** link from the popup:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一张票开始，`TOYC-2`。回到你的 Jira `TOYC-2` 故事，然后从弹出菜单中点击 **创建分支** 链接：
- en: '![Figure 7.4 – TOYC-2 story: Create branch link](img/Figure_7.04_B18318.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – TOYC-2 故事：创建分支链接](img/Figure_7.04_B18318.jpg)'
- en: 'Figure 7.4 – TOYC-2 story: Create branch link'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – TOYC-2 故事：创建分支链接
- en: We’ll need to create a new Bitbucket branch for this feature. This is where
    we will commit all additional code we will be building for this specific ticket.
    Ideally, you’ll need to develop a branch that is branched off the master branch.
    We will then branch off the develop branch, and after we finish a feature, we
    will merge it back into the develop branch.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个特性创建一个新的 Bitbucket 分支。这就是我们将提交所有为这个特定票证构建的额外代码的地方。理想情况下，你需要从一个 master
    分支分叉出一个分支。然后我们将从 develop 分支分叉，完成一个特性后，我们将将其合并回 develop 分支。
- en: Create a new feature branch from the develop branch. Let’s call this the `TOYC-1`
    branch, which represents our `TOYC-1` branch and create a new feature branch—let’s
    call it `TOYC-2`. Check out the `TOYC-2` branch into your local development environment,
    and at this stage, you should have all the base files cloned into your local machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从 develop 分支创建一个新的特性分支。让我们称这个分支为 `TOYC-1`，它代表我们的 `TOYC-1` 分支，并创建一个新的特性分支——让我们称它为
    `TOYC-2`。将 `TOYC-2` 分支检出至你的本地开发环境，在这个阶段，你应该已经将所有基础文件克隆到你的本地机器中。
- en: We will need to make sure that our containers are running. Run the following
    commands to build and run the containers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的容器正在运行。运行以下命令来构建和运行容器。
- en: 'Using your terminal, within the `docker` directory, run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的终端，在 `docker` 目录下，运行以下命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After successfully running the containers, execute the following command, and
    make sure you can go inside the web container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器成功运行后，执行以下命令，并确保你可以进入网络容器：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, you should now see our main `behat` and `symfony` directories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经看到了我们的主要 `behat` 和 `symfony` 目录：
- en: '![Figure 7.5 – behat and symfony root directories](img/Figure_7.05_B18318.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – behat 和 symfony 根目录](img/Figure_7.05_B18318.jpg)'
- en: Figure 7.5 – behat and symfony root directories
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – behat 和 symfony 根目录
- en: At this stage, our development environment is running properly again. Next,
    we will create a Behat feature that will help us start the development of the
    software solution for the `TOYC-2` ticket.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的开发环境再次正常运行。接下来，我们将创建一个 Behat 功能，这将帮助我们开始为 `TOYC-2` 工单的软件解决方案的开发。
- en: Creating a Behat feature based on a Jira ticket
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Jira工单创建 Behat 功能
- en: In the previous chapter, we learned how to create a simple Behat feature. In
    this section, we will create a new Behat feature that will represent the `TOYC-2`
    Jira ticket we created earlier, in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027),
    *Understanding and Organizing the Business Requirements of Our Project*. This
    will then help drive the development of the integration and unit tests that will
    help us build the actual solution code. Let’s get started with the steps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建一个简单的 Behat 功能。在本节中，我们将创建一个新的 Behat 功能，该功能将代表我们在 [*第 2 章*](B18318_02.xhtml#_idTextAnchor027)，*理解和组织我们项目的业务需求*中创建的
    `TOYC-2` Jira 工单。这将有助于推动集成和单元测试的开发，从而帮助我们构建实际的解决方案代码。让我们开始步骤。
- en: 'Create a Behat feature file, name it `inventory_clerk_registration.feature`,
    and save it with the following feature content:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Behat 功能文件，命名为 `inventory_clerk_registration.feature`，并保存以下功能内容：
- en: codebase/behat/features/inventory_clerk_registration.feature
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/inventory_clerk_registration.feature
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you read through the Behat feature we just created, it is going to be very
    self-explanatory about what we are trying to achieve. These steps are the steps
    that a real-life user would do to be able to register to our system. At this point,
    we won’t be building the solution code yet but will create Behat registration
    test code first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读了我们刚刚创建的 Behat 功能，它将非常清楚地说明我们试图实现什么。这些步骤是现实生活中的用户为了能够注册到我们的系统中会执行的步骤。在这个阶段，我们不会构建解决方案代码，而是首先创建
    Behat 注册测试代码。
- en: Creating a Behat registration feature
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Behat 注册功能
- en: Since we are using the base code for this chapter, we will have to make sure
    that we have all the libraries installed for us to be able to run Behat.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是本章的基础代码，因此我们必须确保安装了所有库，以便我们能够运行 Behat。
- en: 'We need to install the Composer package again to be able to use Behat. Run
    the following command to reinstall the libraries needed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次安装 Composer 包才能使用 Behat。运行以下命令以重新安装所需的库：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will then pull and install all the libraries we were using in the previous
    chapter. After the installation, let’s see whether we can generate a Behat PHP
    class for our login feature:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取并安装我们在上一章中使用的所有库。安装后，让我们看看我们是否可以为我们的登录功能生成 Behat PHP 类：
- en: 'Update the `behay.yml` file with the following content:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容更新 `behay.yml` 文件：
- en: codebase/behat/behat.yml
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/behat.yml
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After updating the `behat.yml` file, let’s now try running this command to
    generate a PHP context class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `behat.yml` 文件后，现在尝试运行以下命令以生成 PHP 上下文类：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running the command, we should have been able to generate a new PHP class
    in `codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们应该能够在 `codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php`
    中生成一个新的 PHP 类。
- en: Now, let’s try to automatically generate PHP methods inside the `InventoryClerkRegistrationContext.php`
    class based on the `inventory_clerk_registration.feature` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试根据 `inventory_clerk_registration.feature` 文件自动在 `InventoryClerkRegistrationContext.php`
    类中生成 PHP 方法。
- en: 'Run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After running the command, you should see the following result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该看到以下结果：
- en: '![Figure 7.6 – Autogenerating context methods](img/Figure_7.06_B18318.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 自动生成上下文方法](img/Figure_7.06_B18318.jpg)'
- en: Figure 7.6 – Autogenerating context methods
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 自动生成上下文方法
- en: After running the preceding command, if you open the `codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php`
    class, you should be able to see the newly added methods. Now, if we run Behat,
    we’ll probably get a failing result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，如果您打开 `codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php`
    类，您应该能够看到新添加的方法。现在，如果我们运行 Behat，我们可能会得到一个失败的结果。
- en: 'Run the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the following result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下结果：
- en: '![Figure 7.7 – Behat failures](img/Figure_7.07_B18318.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – Behat失败](img/Figure_7.07_B18318.jpg)'
- en: Figure 7.7 – Behat failures
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – Behat失败
- en: You will notice that we have failed the home feature, have skipped the pending
    tests, and at this stage, we can’t even visit the home page. This is because we
    also must install the missing libraries for the Symfony application. Like what
    we did for Behat, let’s install the missing Composer packages for the Symfony
    app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们失败了首页功能，跳过了挂起的测试，在这个阶段，我们甚至无法访问首页。这是因为我们还需要为Symfony应用程序安装缺失的库。就像我们对Behat所做的那样，让我们为Symfony应用程序安装缺失的Composer包。
- en: 'Run the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After installing the missing Symfony packages, let’s modify the `InventoryClerkRegistrationContext.php`
    class so that we throw an exception on the `iAmOn` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装缺失的Symfony包之后，让我们修改`InventoryClerkRegistrationContext.php`类，以便在`iAmOn`方法上抛出异常：
- en: codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let’s try running Behat again and see whether we can at least pass the
    home page feature test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试运行Behat，看看我们是否至少能够通过首页功能测试。
- en: 'Run Behat again by running the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令再次运行Behat：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We should now be able to pass the **home page** feature test and still continue
    to fail the inventory clerk feature test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够通过**首页**功能测试，同时仍然无法通过库存管理员功能测试：
- en: '![Figure 7.8 – Home page feature passing, login failing](img/Figure_7.08_B18318.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 首页功能通过，登录失败](img/Figure_7.08_B18318.jpg)'
- en: Figure 7.8 – Home page feature passing, login failing
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 首页功能通过，登录失败
- en: Because we have installed the missing Symfony packages, the home page test now
    passes. But since we have not built any solution code to pass the login test yet,
    it will continue to fail.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已安装了缺失的Symfony包，首页测试现在通过了。但因为我们还没有构建任何解决方案代码来通过登录测试，它将继续失败。
- en: By following the Red-Green-Refactor pattern, now that we have a failing test,
    which is the Red phase, we can now move on to writing the solution code needed
    to pass this failing test, which is the Green phase.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循红-绿-重构模式，现在我们有一个失败的测试，这是红阶段，我们现在可以继续编写通过这个失败的测试所需的解决方案代码，这是绿阶段。
- en: Passing the Behat registration feature
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Behat注册功能
- en: Now that we have a couple of failing Behat tests for the login feature, let’s
    try to do the minimum amount of work to complete the feature, and pass the tests.
    Luckily, Symfony makes it easy to implement security. We can use the `symfony/security-bundle`
    Composer package to add authentication and authorization to our application, without
    having to build everything from scratch.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个失败的Behat登录功能测试，让我们尝试做最少的努力来完成这个功能，并通过测试。幸运的是，Symfony使得实现安全性变得容易。我们可以使用`symfony/security-bundle`
    Composer包来为我们的应用程序添加身份验证和授权，而无需从头开始构建一切。
- en: You can read more about Symfony’s security documentation at [https://symfony.com/doc/current/security.html](https://symfony.com/doc/current/security.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://symfony.com/doc/current/security.html](https://symfony.com/doc/current/security.html)上了解更多关于Symfony安全文档的信息。
- en: To pass the failing Behat registration feature, as Behat simulates a user using
    a web browser, we will have to create all the programs needed for a real user
    to be able to register an account in our application from the web browser, which
    then hits the controllers, the services, and then down to the database persistence
    process. Let’s start with the controllers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过失败的Behat注册功能，因为Behat模拟用户使用网络浏览器，我们必须创建所有必要的程序，以便真实用户能够从网络浏览器在我们的应用程序中注册账户，然后击中控制器，服务，然后到数据库持久化过程。让我们从控制器开始。
- en: Writing failing controller tests
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写失败的控制器测试
- en: Before passing our main Behat feature tests, which can also be considered functional
    tests, let’s write some controller tests inside our Symfony application itself.
    Although the Behat tests will also run tests against the controllers, these Symfony
    controller tests will be less complex than the Behat feature tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过我们的主要Behat功能测试之前，这些测试也可以被视为功能测试，让我们在我们的Symfony应用程序内部编写一些控制器测试。尽管Behat测试也会对控制器进行测试，但这些Symfony控制器测试将比Behat功能测试更简单。
- en: 'By reading the Behat registration feature we created earlier, we can easily
    identify that we need two controllers at the very least: a home page controller
    and a registration page controller. The home page is where the user starts the
    journey, and the registration page is where the clerk registers for a new account.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读我们之前创建的Behat注册功能，我们可以轻松地确定我们至少需要两个控制器：主页控制器和注册页面控制器。主页是用户开始旅程的地方，注册页面是职员为新账户注册的地方。
- en: 'Create home page test classes with the following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下内容的首页测试类：
- en: codebase/symfony/tests/ Integration /Controller/HomeControllerTest.php
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/ Integration /Controller/HomeControllerTest.php
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, create a registration page test class with the following content:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建以下内容的注册页面测试类：
- en: codebase/symfony/tests/ Integration /Controller/RegistrationControllerTest.php
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/ Integration /Controller/RegistrationControllerTest.php
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have tests for the main controllers that we’ll be using to pass
    the Behat feature tests, let’s first see whether we pass these Symfony tests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们将用于通过Behat功能测试的主要控制器的测试，让我们首先看看我们是否通过了这些Symfony测试。
- en: 'Run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After running the tests, you should get two failing tests. We used the `--testsuite`
    parameter so that we only execute the two controller tests we just created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，你应该得到两个失败的测试。我们使用了`--testsuite`参数，以便只执行我们刚刚创建的两个控制器测试。
- en: Now we know that we will have to pass these two tests, we can continue working
    on the solutions to pass them. At this stage, we are in the “Red” phase of the
    Red-Green-Refactor pattern we discussed earlier in the chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们必须通过这两个测试，我们可以继续工作，解决通过它们的问题。在这个阶段，我们处于之前章节中讨论的Red-Green-Refactor模式的“红”阶段。
- en: We can now start working on the registration and registration solution first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始着手注册和注册解决方案了。
- en: Implementing a registration solution using Symfony
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Symfony实现注册解决方案
- en: The great thing about using open source frameworks is that there is a big chance
    of a lot of the software we developers need to build for our own projects having
    already been built as an open source library or package. And to pass our failing
    registration test, let’s use Symfony’s `security-bundle` package instead of writing
    everything from scratch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源框架的好处是，我们开发者需要为我们的项目构建的许多软件很可能已经被作为开源库或包构建。为了通过失败的注册测试，让我们使用Symfony的`security-bundle`包而不是从头开始编写一切。
- en: Remember—as software developers, we don’t simply develop code alone. We develop
    solutions. And if there are existing packages or libraries that can help you speed
    up the development of your solution, and if they fit your specifications, you
    can consider using them instead. Otherwise, you’ll have to build the code from
    scratch.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——作为软件开发者，我们不仅仅编写代码。我们开发解决方案。如果存在可以帮助你加快解决方案开发速度的现有包或库，并且如果它们符合你的规格，你可以考虑使用它们而不是从头开始构建代码。
- en: You can read about Symfony’s security solution on its official documentation
    page at [https://symfony.com/doc/current/security.html](https://symfony.com/doc/current/security.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Symfony官方文档页面上了解有关Symfony安全解决方案的更多信息：[https://symfony.com/doc/current/security.html](https://symfony.com/doc/current/security.html)。
- en: 'We can use Symfony’s security solution by running the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令使用Symfony的安全解决方案：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Read the prompts and enter the default values suggested.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读提示并输入建议的默认值。
- en: Next, we need to set up the databases we need. Remember—we are not only using
    one database, but we also need a separate test database as well. You can read
    more about this in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们需要的数据库。记住——我们不仅使用一个数据库，还需要一个单独的测试数据库。你可以在[*第五章*](B18318_05.xhtml#_idTextAnchor070)，*单元测试*中了解更多关于此内容。
- en: Database setup
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库设置
- en: 'We will need to create two databases: `cars` and `cars_test` databases. The
    `cars` database will serve as our main database, and the `cars_test` database
    will be like a replica database that our automated tests will use. After all,
    you don’t want to run data mutation tests against your production database.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建两个数据库：`cars`和`cars_test`数据库。`cars`数据库将作为我们的主数据库，而`cars_test`数据库将类似于一个副本数据库，我们的自动化测试将使用它。毕竟，你不想在生产数据库上运行数据突变测试。
- en: 'Run the following commands to set up our databases:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来设置我们的数据库：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we did in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*,
    we have created our MySQL databases and tables based on the Doctrine entity found
    in the `codebase/symfony/src/Entity` directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第5章*](B18318_05.xhtml#_idTextAnchor070)中做的，*单元测试*，我们已经根据`codebase/symfony/src/Entity`目录中找到的Doctrine实体创建了我们的MySQL数据库和表。
- en: Next, let’s create a registration form using Symfony’s `security-bundle` package.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用Symfony的`security-bundle`包创建一个注册表单。
- en: Using Symfony’s registration form
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Symfony的注册表单
- en: 'Next, we can use Symfony’s registration form. The base solution code already
    has all the dependencies declared in the `composer.json` file, so you can just
    run the following command to generate the registration code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用Symfony的注册表单。基本解决方案代码已经在`composer.json`文件中声明了所有依赖项，所以你可以直接运行以下命令来生成注册代码：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command will generate a few files—one of them is the `RegistrationController.php`
    class. If you open that class, you’ll see that it has a `register` method. We
    also created a test for this controller and method. Let’s see whether it now works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成几个文件，其中之一是`RegistrationController.php`类。如果你打开这个类，你会看到它有一个`register`方法。我们也为这个控制器和方法创建了一个测试。让我们看看它现在是否工作。
- en: 'Run the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After running the test, we should now be able to pass this test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，我们现在应该能够通过这个测试：
- en: '![Figure 7.9 – Passing the register route test](img/Figure_7.09_B18318.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 通过注册路由测试](img/Figure_7.09_B18318.jpg)'
- en: Figure 7.9 – Passing the register route test
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 通过注册路由测试
- en: At this stage, we are in the “Green” phase of the Red-Green-Refactor pattern.
    Does that mean we are done with the registration feature? Absolutely not. Since
    we are not completed with this test yet, usually I use PHPUnit’s `$this->markTestIncomplete();`
    method and add it to the test class. This can help remind developers that the
    test is written and the solution is partially there but is still incomplete. Go
    ahead and add the `$this->markTestIncomplete();` method inside the `testCanLoadRegister`
    method in the `codebase/symfony/tests/Functional/Controller/RegistrationControllerTest.php`
    test class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们处于红-绿-重构模式的“绿色”阶段。这意味着我们完成了注册功能吗？绝对不是。因为我们还没有完成这个测试，通常我会使用PHPUnit的`$this->markTestIncomplete();`方法并将其添加到测试类中。这可以帮助提醒开发者测试已经编写，解决方案部分存在，但仍然不完整。现在，请在`codebase/symfony/tests/Functional/Controller/RegistrationControllerTest.php`测试类中的`testCanLoadRegister`方法内添加`$this->markTestIncomplete();`方法。
- en: 'Now, run the test again:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行测试：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following result:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Figure 7.10 – Incomplete register route test](img/Figure_7.10_B18318.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 不完整的注册路由测试](img/Figure_7.10_B18318.jpg)'
- en: Figure 7.10 – Incomplete register route test
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 不完整的注册路由测试
- en: Now the test is marked as incomplete, and we can go back to it later. It’s up
    to you whether you want to use this feature, but I find it useful when working
    on large projects. The only thing I don’t like about this is that sometimes it
    doesn’t grab my attention as much as a failing test would. For now, let’s remove
    the **Incomplete** mark.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试被标记为不完整，我们可以在稍后回到它。是否使用这个功能取决于你，但我在处理大型项目时觉得它很有用。唯一我不喜欢的是，有时候它没有失败测试那么吸引我的注意力。现在，让我们移除**不完整**的标记。
- en: Creating a home controller
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建主页控制器
- en: Now let’s create a home controller where the users usually land first. Here,
    we will also find the **Register** link that the user will click to get redirected
    to the **Registration** page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个主页控制器，用户通常会首先到达这里。在这里，我们也会找到用户点击以重定向到**注册**页面的**注册**链接。
- en: 'Create a home controller by running the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个主页控制器：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After running that command, we should now have a new Symfony controller in `codebase/symfony/src/Controller/HomeController.php`.
    Edit the route inside the controller and replace `/home` with just a forward slash
    (`/`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行那个命令后，我们现在应该有一个新的Symfony控制器在`codebase/symfony/src/Controller/HomeController.php`。编辑控制器内的路由，并将`/home`替换为仅一个正斜杠(`/`)。
- en: 'Now, let’s see whether our controller tests now pass. Run the Symfony functional
    tests again:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的控制器测试是否通过。再次运行Symfony功能测试：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should now see the following result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下结果：
- en: '![Figure 7.11 – Passing controller tests](img/Figure_7.11_B18318.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 通过控制器测试](img/Figure_7.11_B18318.jpg)'
- en: Figure 7.11 – Passing controller tests
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 通过控制器测试
- en: Since our controller tests are very simple, we are basically just testing whether
    the page response for the route is successful; we can now be sure that both tests
    pass. This will not satisfy the Behat registration feature test, though. So, let’s
    continue working on it!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的控制器测试非常简单，我们基本上只是在测试路由的页面响应是否成功；我们现在可以确信这两个测试都通过了。但这不会满足Behat注册功能测试的要求。所以，让我们继续工作吧！
- en: 'Let’s modify the home controller’s twig template content. Open the following
    file and replace the entire `example-wrapper` div content with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改主页控制器的twig模板内容。打开以下文件，并将整个`example-wrapper` div内容替换为以下内容：
- en: codebase/symfony/templates/home/index.html.twig
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/templates/home/index.html.twig
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We just added a link to the registration page. If you try to access the home
    page through the browser, you’ll see something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了一个指向注册页面的链接。如果你尝试通过浏览器访问主页，你会看到类似以下的内容：
- en: '![Figure 7.12 – HomeController](img/Figure_7.12_B18318.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – HomeController](img/Figure_7.12_B18318.jpg)'
- en: Figure 7.12 – HomeController
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – HomeController
- en: Next, let’s go back to our BDD test in the `behat` directory. Let’s try to write
    some test code and see whether we can finally register a new user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到`behat`目录下的BDD测试。让我们尝试编写一些测试代码，看看我们是否最终能够注册一个新用户。
- en: Passing the Behat feature
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Behat功能传递
- en: Our Behat registration feature simulates a user visiting the home page, clicking
    on the registration link, getting redirected to the registration page, filling
    up the registration form, clicking on the **Register** button, and then getting
    redirected to some elected page.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Behat注册功能模拟了用户访问主页，点击注册链接，被重定向到注册页面，填写注册表单，点击**注册**按钮，然后被重定向到某个选定的页面。
- en: This is exactly like what a manual tester would do to test the registration
    feature. Instead of doing these steps manually using a browser, let’s just use
    Behat to do all these steps for us.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是手动测试员测试注册功能时会做的事情。而不是手动使用浏览器执行这些步骤，让我们只用Behat为我们完成所有这些步骤。
- en: 'Open the following Behat context file, and replace the content with the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打开以下Behat上下文文件，并将内容替换为以下内容：
- en: codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/bootstrap/InventoryClerkRegistrationContext.php
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding snippet, we started with the constructor. We declared the emulator
    and session objects we will use in the class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们从构造函数开始。我们在类中声明了我们将要使用的模拟器和会话对象。
- en: 'Next, add the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code will simulate a user being on the home page, then clicking
    on the **Register** link.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将模拟用户在主页上，然后点击**注册**链接。
- en: 'In the next snippet, Behat will try to confirm that it got redirected to the
    register controller page:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个片段中，Behat将尝试确认它是否被重定向到了注册控制器页面：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can easily check whether you’re on the right page by checking the route,
    but the preceding snippet shows that you can inspect the DOM itself, returned
    by the controller.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查路由来轻松地检查你是否在正确的页面上，但前面的片段显示了你可以检查由控制器返回的DOM本身。
- en: 'Next, add the following code to mimic a user inputting values into input forms:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码来模拟用户在输入表单中输入值：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding snippet, the code mimics entering text into the `Email` and
    `Password` fields. Next, we will simulate checking a checkbox and clicking on
    the **Submit** button. Add the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，代码模拟了在`Email`和`Password`字段中输入文本。接下来，我们将模拟检查复选框并点击**提交**按钮。添加以下代码：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, we have checked the **Agree terms** checkbox, then clicked
    on the **Register** button.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查了**同意条款**复选框，然后点击了**注册**按钮。
- en: 'Next, add the following code to complete the test:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码来完成测试：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since, in the Symfony app, we are redirecting the user back to the home controller
    when successful, we can check whether we got redirected to the home page. You’ll
    notice that it also checks whether the user already exists; you can break down
    this test further as much as you want so that you can separate scenarios like
    this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Symfony应用中，我们在成功时将用户重定向回主页控制器，因此我们可以检查我们是否被重定向到了主页。你会注意到它还检查了用户是否已经存在；你可以根据需要进一步分解这个测试，以便可以分离出这样的场景。
- en: What we did in the preceding code block is break down the scenarios inside the
    `codebase/behat/features/inventory_clerk_registration.feature` file into PHP methods.
    We then wrote PHP code to click links and buttons, populate text fields, check
    a checkbox, and more.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们做了以下工作：将`codebase/behat/features/inventory_clerk_registration.feature`文件中的场景分解成PHP方法。然后我们编写了PHP代码来点击链接和按钮，填充文本字段，勾选复选框等等。
- en: 'But let’s see whether this works. Run the following command to run this test:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看这是否真的有效。运行以下命令来运行此测试：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will take a few seconds to execute, but you should get the following result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将需要几秒钟，但您应该得到以下结果：
- en: '![Figure 7.13 – Registration feature test](img/Figure_7.13_B18318.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 注册功能测试](img/Figure_7.13_B18318.jpg)'
- en: Figure 7.13 – Registration feature test
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 注册功能测试
- en: By running the Behat test, we can replace a manual testing process usually done
    from a browser. But we need to confirm whether we were really able to register,
    and persist the data into our MySQL database using Doctrine ORM! At this point,
    we are in the “Refactor” phase of the Red-Green-Refactor pattern, and I personally
    think that the “Refactor” phase can be a bit more open-ended and open to interpretation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行Behat测试，我们可以替换通常从浏览器进行的手动测试过程。但我们需要确认我们是否真的能够注册，并且使用Doctrine ORM将数据持久化到我们的MySQL数据库中！在这个阶段，我们处于Red-Green-Refactor模式的“重构”阶段，我个人认为“重构”阶段可以更加开放和灵活。
- en: You can use your own MySQL client or the phpMyAdmin app that we configured earlier,
    in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039), *Setting Up Our Development
    Environment Using Docker Containers*, to verify the data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自己的MySQL客户端或我们之前配置的phpMyAdmin应用程序（[*第3章*](B18318_03.xhtml#_idTextAnchor039)，*使用Docker容器设置我们的开发环境*），来验证数据。
- en: 'You will get the following result using the command line in the MySQL container:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用MySQL容器中的命令行得到以下结果：
- en: "![Figure 7.14 – User successfully registered: view from \uFEFFthe CLI](img/Figure_7.14_B18318.jpg)"
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – 用户成功注册：从CLI查看](img/Figure_7.14_B18318.jpg)'
- en: 'Figure 7.14 – User successfully registered: view from the CLI'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 用户成功注册：从CLI查看
- en: 'And this is the result using the phpMyAdmin application we configured, which
    can be accessed with a local browser at `http://127.0.0.1:3333`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们配置的phpMyAdmin应用程序的结果，可以通过本地浏览器在`http://127.0.0.1:3333`访问：
- en: "![Figure 7.15 – User successfully registered: view from \uFEFF\uFEFFphpMyAdmin](img/Figure_7.15_B18318.jpg)"
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – 用户成功注册：从phpMyAdmin查看](img/Figure_7.15_B18318.jpg)'
- en: 'Figure 7.15 – User successfully registered: view from phpMyAdmin'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 用户成功注册：从phpMyAdmin查看
- en: We can see from the database that we were able to persist the registration details.
    At this stage, we can say that our registration functionality works! And we were
    able to test it without manually opening a desktop browser to enter form details.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中我们可以看到，我们已经能够持久化注册详情。在这个阶段，我们可以说我们的注册功能是正常工作的！而且我们能够在不手动打开桌面浏览器输入表单详情的情况下对其进行测试。
- en: 'We now have a PHP program doing the registration feature testing for us, but
    we also need to build the login feature and the most important part: the inventory
    system itself. We have a lot of other features to build, but this is a great start!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个PHP程序在为我们进行注册功能测试，但我们还需要构建登录功能以及最重要的部分：库存系统本身。我们还有许多其他功能要构建，但这是一个很好的开始！
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by creating an easy-to-understand list of features
    and scenarios detailing what needs to be built, based on a Jira ticket. Before
    working on the solution code, we first started with a Gherkin feature called **Inventory
    Clerk Registration**. This feature can be read by anyone—even non-developers will
    be able to understand it. This feature explains how our system should behave.
    We then took that behavior and created simple and failing functional tests inside
    the Symfony application. Creating these failing tests gave us a list of things
    we need to build. We then proceeded to develop the solution to pass these failing
    functional tests. And finally, we wrote code to tell Behat the intricate steps
    to click a link or a button, and fill up fields. BDD and TDD are not just about
    writing automated tests—it’s about using them as a process to develop our solutions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先基于一个 Jira 工作项创建了一个易于理解的特性列表和场景列表，详细说明了需要构建的内容。在着手编写解决方案代码之前，我们首先从 Gherkin
    功能“**库存管理员注册**”开始。这个功能可以被任何人阅读——甚至非开发者也能理解它。这个功能解释了我们的系统应该如何表现。然后，我们根据这种行为在 Symfony
    应用程序内部创建了简单且失败的函数测试。创建这些失败的测试给我们列出了一些建设内容。然后，我们着手开发解决方案以通过这些失败的函数测试。最后，我们编写了代码来告诉
    Behat 如何执行点击链接或按钮以及填写字段的复杂步骤。BDD 和 TDD 不仅关乎编写自动化测试——它关乎将它们作为开发我们解决方案的过程。
- en: In the next chapter, we will continue building tests and solution code. We will
    go through the SOLID principles to help us structure our own code to make sure
    it is more maintainable and testable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建测试和解决方案代码。我们将通过 SOLID 原则来帮助我们结构化自己的代码，以确保代码更易于维护和测试。
