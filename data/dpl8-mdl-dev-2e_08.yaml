- en: The Database API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库API
- en: In the previous two chapters, we talked extensively about our options as Drupal
    8 module developers for modeling and storing data in Drupal 8\. We also saw some
    examples of how to use things such as the State, Configuration, and Entity APIs,
    going into greater detail about the latter by using it to build something useful.
    One of the key takeaways from those chapters is that the need for custom database
    tables and/or direct queries against them and the database has become minimal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们详细讨论了作为Drupal 8模块开发者，我们在Drupal 8中建模和存储数据的选项。我们还看到了一些如何使用诸如状态、配置和实体API的例子，通过使用后者构建有用的东西来更详细地介绍后者。从那些章节中，一个关键的收获是需要自定义数据库表和/或直接对它们和数据库进行查询的需求已经变得很小。
- en: The Entity system is much more flexible and robust, the combination of configuration
    and content entities providing much of the needs for storing data. Moreover, the
    Entity query and loading mechanisms have also made finding them easy. Odds are,
    this is enough for most of your use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实体系统更加灵活和健壮，配置和内容实体的组合提供了存储数据的大部分需求。此外，实体查询和加载机制也使得查找它们变得容易。很可能，这已经足够满足大多数用例。
- en: Furthermore, storage subsystems such as the State API (key/value) and UserData
    have also removed much of the need to create custom tables to store that kind
    of "one-off" data. Also, the Configuration API provides a unified way to model
    exportable data, leaving no need for anything else.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，诸如状态API（键/值）和UserData之类的存储子系统也已经消除了创建自定义表来存储那种“一次性”数据的大部分需求。此外，配置API提供了一个统一的方式来建模可导出数据，从而不再需要其他任何东西。
- en: However, apart from these features, Drupal also has a strong Database API that
    actually powers them under the hood. This API is made available to us in case
    we need it. For example, we can create our own database tables and then run queries
    against them however we want, all through a secure layer that can work on top
    of multiple types of databases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些特性之外，Drupal还有一个强大的数据库API，实际上在幕后为它们提供动力。这个API在我们需要时提供给我们。例如，我们可以创建自己的数据库表，然后以我们想要的方式对它们进行查询，所有这些都在一个可以工作在多种数据库之上的安全层中完成。
- en: Creating custom database tables is not something you will do very often— maybe
    never— but in this chapter, you will still learn how the API works in order to
    do so. There are contributed modules out there that have legitimate uses for them,
    and who knows, you might also. So, it is still important to understand this system.
    However, even more pertinent is the API for running queries (particularly select
    queries), because you may need to run these, even against entities. There are
    times in which the entity query does not provide all you need, so looking up entities
    based on complex queries can, in fact, be more common. Hence, we will cover how
    to do that in this chapter, as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义数据库表并不是你经常要做的事情——也许永远不会——但在本章中，你仍然会学习如何使用API来做到这一点。有些贡献的模块确实有合法用途，而且谁知道呢，你可能也会有。因此，理解这个系统仍然很重要。然而，更重要的是运行查询的API（尤其是选择查询），因为你可能需要运行这些查询，甚至针对实体。有时实体查询并不能提供你需要的一切，因此基于复杂查询查找实体实际上可能更常见。因此，我们将在本章中介绍如何做到这一点。
- en: More concretely, in this chapter, we will start by creating a couple of database
    tables so that we can see how the Schema API works in Drupal 8\. For D7 developers,
    this will look strikingly familiar. Then, we will see the various ways we can
    perform queries against these tables by using the database abstraction layer.
    We can make two different types of select query, and we will practice both. For
    the others (`INSERT`, `UPDATE`, and `DELETE`), there is a standard way of doing
    it. Next, we will take a look at how queries can be altered and how we can tag
    them for better targeting. Finally, we will look at the database update hooks,
    which were one of the principal ways configuration was deployed in previous versions
    of Drupal. In reality, the purpose of these hooks is to make database updates
    once the tables have already been created.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，我们将首先创建几个数据库表，以便我们可以看到Schema API在Drupal 8中的工作方式。对于D7开发者来说，这看起来非常熟悉。然后，我们将看到我们可以通过使用数据库抽象层对这些表执行查询的各种方式。我们可以执行两种不同的选择查询，我们将练习这两种。对于其他（`INSERT`、`UPDATE`和`DELETE`），有标准的方法来做。接下来，我们将看看如何修改查询以及如何为它们标记以实现更好的定位。最后，我们将探讨数据库更新钩子，这是在Drupal的前几个版本中配置部署的主要方式之一。实际上，这些钩子的目的是在表已经创建后进行数据库更新。
- en: The Schema API
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式API
- en: The purpose of the Schema API is to allow defining database table structures
    in PHP and to have Drupal interact with the database engine and turn those definitions
    into a reality. Apart from the fact that we don't ever have to see things such
    as `CREATE TABLE`, we ensure that our table structures can be applied to multiple
    types of databases. If you remember in [Chapter 1](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml),
    *Developing for Drupal 8*, I mentioned that Drupal can work with MySQL, PostgreSQL,
    SQLite, and others, if they support PDO, so the Schema API ensures this cross-compatibility.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Schema API 的目的是允许在 PHP 中定义数据库表结构，并让 Drupal 与数据库引擎交互，将这些定义转化为现实。除了我们永远不需要看到诸如
    `CREATE TABLE` 这样的语句之外，我们还确保我们的表结构可以应用于多种类型的数据库。如果您还记得在 [第 1 章](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml)，*为
    Drupal 8 开发* 中，我提到 Drupal 可以与 MySQL、PostgreSQL、SQLite 等数据库一起工作，如果它们支持 PDO，那么 Schema
    API 确保了这种跨兼容性。
- en: The central component of the Schema API is `hook_schema()`. This is used to
    provide the initial table definitions of a given module. Implementations of this
    hook belong in the `*.install` file of the module and are fired when the module
    is first installed. If alterations need to be made to existing database tables,
    there are a number of methods that can be used inside update hooks to make these
    changes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Schema API 的核心组件是 `hook_schema()`。这个钩子用于提供给定模块的初始表定义。此钩子的实现应位于模块的 `*.install`
    文件中，并在模块首次安装时触发。如果需要对现有数据库表进行修改，可以在更新钩子内部使用多种方法来执行这些更改。
- en: 'In this section, we will create a new module called `sports` in which we want
    to define two tables: `players` and `teams`. The records in the former can reference
    records in the latter, as each player can be part of only one team at a time.
    This is a simple example, and one which could, and should, be implemented using
    entities. However, for the purpose of demonstrating the database API, we will
    stick with the manual setup.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个名为 `sports` 的新模块，我们希望在其中定义两个表：`players` 和 `teams`。前者的记录可以引用后者的记录，因为每个球员一次只能属于一个团队。这是一个简单的例子，并且可以也应该使用实体来实现。然而，为了演示数据库
    API，我们将坚持手动设置。
- en: 'So, in our `sports.install` file, we can implement `hook_schema()` as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 `sports.install` 文件中，我们可以这样实现 `hook_schema()`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implementations of this hook need to return an associative array keyed by the
    table name whose values are an array that defines the respective table. The table
    definition consists of various types of information, particularly the individual
    column definitions (fields), and also things such as which fields represent the
    primary key, foreign keys (strictly for documentation purposes), unique keys,
    and indexes. For a full reference to all the available options, check out the
    Drupal.org ([https://www.drupal.org/](https://www.drupal.org/)) documentation
    pages for the Schema API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子的实现需要返回一个关联数组，以表名为键，其值是一个定义相应表的数组。表定义由各种类型的信息组成，特别是各个列的定义（字段），以及哪些字段代表主键、外键（严格来说仅用于文档目的）、唯一键和索引等。要查看所有可用选项的完整参考，请查阅
    Drupal.org ([https://www.drupal.org/](https://www.drupal.org/)) 的 Schema API 文档页面。
- en: In our example, we defined the two tables we mentioned and defined their fields
    inside the `fields` array. The `primary key` indicates which of the fields will
    be used for that purpose, opting for the standard `id` field for both. Speaking
    of which, the latter is a field of the type `serial`, which means that it is an
    integer that has an auto-increment option to it. For number fields such as integer,
    float, and numeric, the `unsigned` option means that numbers cannot go below 0\.
    Also, `not null` is pretty easy to understand—it prevents the column from ever
    being empty.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了之前提到的两个表，并在 `fields` 数组中定义了它们的字段。`primary key` 指示哪个字段将用于此目的，我们选择了标准的
    `id` 字段。说到这一点，后者是一个 `serial` 类型的字段，这意味着它是一个具有自增选项的整数。对于整数、浮点数和数值等数字字段，`unsigned`
    选项意味着数字不能低于 0。`not null` 也很容易理解——它防止列始终为空。
- en: For the team and player name, we opted for a simple `varchar` field that takes
    a maximum of 255 characters (a pretty standard table column definition), and these,
    too, cannot be null. The description field, on the other hand, is of the `text`
    type with the `normal` size (as opposed to `tiny`, `small`, `medium`, or `big`).
    In here, we want to store strings that are longer than 255 characters. At the
    time of writing this book, there is no full documentation for the available data
    types (and their options) for Drupal 8; however, the D7 version ([https://www.drupal.org/docs/7/api/schema-api/data-types](https://www.drupal.org/docs/7/api/schema-api/data-types))
    is a good indicator and will pretty much work exactly the same.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '对于团队和玩家名称，我们选择了一个简单的“varchar”字段，它最多可以接受255个字符（这是一个相当标准的表列定义），这些字段也不能为空。另一方面，描述字段是“text”类型，大小为“normal”（与“tiny”、“small”、“medium”或“big”相对）。在这里，我们希望存储超过255个字符的字符串。在撰写这本书的时候，关于
    Drupal 8 可用数据类型（及其选项）的完整文档还不存在；然而，D7版本（[https://www.drupal.org/docs/7/api/schema-api/data-types](https://www.drupal.org/docs/7/api/schema-api/data-types)）是一个很好的指标，并且将几乎完全相同地工作。 '
- en: Lastly, for the player table, we also have a `team_id`, which is a simple integer
    field, and a `data` column, in which we want to store some arbitrary serialized
    data. This is a `blob` type, which can also be `big` or `normal`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于玩家表，我们还有一个“team_id”，它是一个简单的整数字段，还有一个“data”列，我们想在其中存储一些任意序列化的数据。这是一个“blob”类型，也可以是“big”或“normal”。
- en: 'That is pretty much all for our schema definitions. Installing the `sports`
    module will create these tables for us automatically, according to these definitions.
    Also, just as important, uninstalling the module will delete these tables, so
    we don''t need to do any kind of handling. However, if our module is already enabled
    and we add this implementation afterward, it won''t get fired. Instead, we will
    need to implement an update hook and use the `drupal_install_schema()` function,
    which will trigger it. Like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模式定义，这基本上就结束了。安装“sports”模块将根据这些定义自动为我们创建这些表。同样重要的是，卸载模块也会删除这些表，所以我们不需要进行任何处理。然而，如果我们的模块已经启用，并且之后添加了这个实现，它将不会被触发。相反，我们需要实现一个更新钩子并使用“drupal_install_schema()”函数，这将触发它。如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will see more about update hooks soon.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到更多关于更新钩子的内容。
- en: Running queries
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行查询
- en: Now that we have some tables to work with, let's take a look at how we can run
    queries against them. If you are following along, for testing purposes, feel free
    to add some dummy data into the tables via the database management tool of your
    choice. We will look at `INSERT` statements soon, but before that, we will need
    to talk about the more common types of query you'll run—`SELECT`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些表可以操作了，让我们看看如何对它们执行查询。如果你在跟随，为了测试目的，你可以通过你选择的数据库管理工具向表中添加一些虚拟数据。我们很快就会看到“INSERT”语句，但在那之前，我们需要讨论你将运行更常见的查询类型——“SELECT”。
- en: 'Queries using the Drupal 8 database abstraction layer are run using a central
    database connection service—`database`. Statically, this can be accessed via a
    shortcut:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Drupal 8 数据库抽象层的查询是通过一个中央数据库连接服务——“database”来执行的。静态地，可以通过快捷方式访问它：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This service is a special one compared to the ones we saw before, because it
    is actually created using a factory. This is its definition to better help you
    understand what I mean:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的那些服务相比，这个服务是特殊的一个，因为它实际上是使用工厂创建的。这是它的定义，以更好地帮助你理解我的意思：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a definition by which the responsibility for the instantiation is delegated
    to the factory mentioned, instead of the container as we've seen before. So, the
    resulting class does not necessarily need to match the one specified for the `class`
    key. However, in this case, the `Drupal\Core\Database\Connection` is an abstract
    base class that the resulting service extends. Again, in this case, the `arguments`
    are responsible for specifying the type of connection that it has to create. The
    site-default type is used (MySQL, usually), which means that the resulting service
    will be an instance of `Drupal\Core\Database\Driver\mysql\Connection`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义，其中将实例化的责任委托给之前提到的工厂，而不是像之前那样委托给容器。因此，生成的类不一定需要与“class”键指定的类匹配。然而，在这种情况下，“Drupal\Core\Database\Connection”是一个抽象基类，生成的服务会扩展它。再次强调，在这种情况下，“arguments”负责指定它必须创建的连接类型。使用的是“site-default”类型（通常是MySQL），这意味着生成的服务将是一个“Drupal\Core\Database\Driver\mysql\Connection”的实例。
- en: From this connection service, we can then request the relevant object with which
    we can build queries. So, let's see how these work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个连接服务中，我们可以请求相关的对象，从而构建查询。那么，让我们看看这些是如何工作的。
- en: Select queries
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择查询
- en: There are two ways we can run select queries in Drupal 8, and they both work
    similarly to the way they did in Drupal 7\. We have the D8 equivalents of `db_query()`
    and `db_query_range()` and the equivalent of `db_select()`. This will look familiar
    to D7 developers. In Drupal 8, these procedural functions still exist, but in
    a deprecated state. This means that instead of using the old functions, we should
    use the connection service I will mention next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，我们可以有两种方式运行选择查询，它们的工作方式与Drupal 7中的方式相似。我们拥有`db_query()`和`db_query_range()`的D8等价函数，以及`db_select()`的等价函数。这对于D7开发者来说应该很熟悉。在Drupal
    8中，这些过程式函数仍然存在，但处于弃用状态。这意味着我们不应该使用旧函数，而应该使用我接下来要提到的连接服务。
- en: The first type of select query is typically more performant because we construct
    them by writing the SQL statements ourselves (with placeholders, of course), whereas
    the `db_select()` type of query is an OOP query builder that still needs to transform
    a chained object construct into an SQL statement. However, don't let this performance
    be a real deciding factor, because as you can imagine, the impact is minimal.
    Also, the query builder is the more proper way of running queries, because they
    are alterable (can be deconstructed).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择查询通常性能更好，因为我们通过编写SQL语句（当然，包括占位符）来构建它们，而`db_select()`类型的查询是一个面向对象的查询构建器，它仍然需要将链式对象结构转换为SQL语句。然而，不要让这种性能成为真正的决定因素，因为正如你可以想象的那样，影响微乎其微。此外，查询构建器是运行查询的正确方式，因为它们是可更改的（可以分解）。
- en: The first type of select query is typically used for simpler queries, but if
    you are an SQL guru, it can actually be faster and easier to write a complex query
    using that method. Moreover, they rely on developers ensuring that the SQL statement
    is compatible with the underlying database. So, it is up to you which of the two
    types you choose, considering all of these factors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择查询通常用于更简单的查询，但如果你是SQL大师，实际上使用该方法编写复杂查询可能会更快、更简单。此外，它们依赖于开发者确保SQL语句与底层数据库兼容。因此，在选择这两种类型时，需要考虑所有这些因素。
- en: 'Let''s first take a look at how we can run a basic query against our tables
    using the `db_query()`-like method. We''ll then see how the same query can be
    run using the other way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用类似`db_query()`的方法运行对表格的基本查询。然后，我们将看到同样的查询如何以其他方式运行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple SQL statement, albeit a bit funky if you have not done any
    D7 development. We passed the query string as the first argument to the `query()`
    method of the connection object. The second argument is an array of placeholder
    values for this query string. These are found throughout the SQL string proceeded
    by a colon (`:id`) and are later replaced with the value that maps to the same
    key in the placeholder values array. Another thing to note is that the table name
    in the query is surrounded by curly braces. This is because, in reality, table
    names can be prefixed when the site is installed, and our code should not concern
    itself with that prefix. Drupal will prepend it automatically.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的SQL语句，尽管如果你没有进行过任何D7开发，它可能有点奇怪。我们将查询字符串作为第一个参数传递给连接对象的`query()`方法。第二个参数是查询字符串的占位符值数组。这些占位符值在整个SQL字符串中由冒号（`:id`）引导，稍后会被与占位符值数组中相同键对应的值所替换。另外，需要注意的是，查询中的表名被大括号包围。这是因为实际上，当站点安装时，表名可能会被添加前缀，而我们的代码不应该关心这个前缀。Drupal会自动添加它。
- en: 'Now, let''s take a look at how we can run the same query using the query builder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用查询构建器运行相同的查询：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, we will use the `select()` method on the connection object to get
    our hands on a `SelectInterface` instance with which we can build our query. We
    need to pass the table we want to query, as well as an alias for that table. This
    is particularly important when performing joins. Then, we use the `fields()` method
    to specify which of the table columns we want to retrieve. The first parameter
    is the table alias, whereas the second (optional) is an array of column names.
    All columns will be included (`*`). Next, we have a single condition being applied
    to the query for the `id` column and the value `1`. The third optional parameter
    is the operator that defaults to `=`. Lastly, we execute the query and get the
    same result as with the preceding example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用连接对象上的 `select()` 方法来获取一个 `SelectInterface` 实例，我们可以用它来构建我们的查询。我们需要传递我们想要查询的表，以及该表的别名。这在执行连接操作时尤其重要。然后，我们使用
    `fields()` 方法来指定我们想要检索的表列。第一个参数是表别名，而第二个（可选）是一个列名数组。所有列都将被包括（`*`）。接下来，我们有一个单一的条件应用于查询的
    `id` 列和值 `1`。第三个可选参数是默认为 `=` 的运算符。最后，我们执行查询并得到与前面示例相同的结果。
- en: You will immediately note, if you remember, that the structure of this query
    builder is very similar to the Entity Query, and the components are also chainable
    to a certain extent, as we will see.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得的话，你会立即注意到，这个查询构建器的结构非常类似于实体查询，并且组件在某种程度上也是可链式的，正如我们将看到的。
- en: Handling the result
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理结果
- en: 'Both of the previous queries return a `StatementInterface`, which is iterable.
    So, to access its data, we can do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的两个查询都返回一个 `StatementInterface`，它是可迭代的。因此，要访问其数据，我们可以这样做：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each item in the loop is a `stdClass`, and their property names are the actual
    names of the columns returned, while their values are the column values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的每个项目都是一个 `stdClass`，它们的属性名是返回的实际列名，而它们的值是列值。
- en: 'Alternatively, the `StatementInterface` also has some fetcher methods that
    can prepare the results for us in different ways. These mostly come from the parent
    `\PDOStatement` class, which is native PHP. The simplest is `fetchAll()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`StatementInterface` 也有一些可以以不同方式为我们准备结果的获取器方法。这些方法大多来自父类 `\PDOStatement`，它是原生
    PHP。最简单的是 `fetchAll()`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This returns an array of `stdClass` objects, as we saw before, so it does all
    the looping to extract the records for us. If we want this array keyed by the
    value of a field in the record, we can perform the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个 `stdClass` 对象数组，正如我们之前看到的，所以它为我们做了所有的循环来提取记录。如果我们想按记录中字段的值来键控这个数组，我们可以执行以下操作：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will use the value in the `id` field to key the array.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `id` 字段中的值作为数组的键。
- en: If we're expecting single records, we can also use the `fetch()` method, which
    returns only one such object (the next one in the result set); `fetchObject()`
    does the same thing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望单条记录，我们也可以使用 `fetch()` 方法，它只返回这样一个对象（结果集中的下一个对象）；`fetchObject()` 做的是同样的事情。
- en: More complex select queries
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的查询选择
- en: 'Let''s create a more complex query now, to join our team table and retrieve
    the team information in the same record as the player:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个更复杂的查询，将我们的团队表和球员信息连接起来，并在同一记录中检索团队信息：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return the same record as before, but inclusive of the values from
    the matching team record. Note that since we have a join, we had to use table
    aliases here as well. There is one problem with this query, though—since both
    tables have the `name` column, we cannot use `*` to include all of the fields,
    as they will get overridden. Instead, we need to include them manually:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回与之前相同的记录，但包括匹配的团队记录的值。注意，由于我们有一个连接，所以我们在这里也必须使用表别名。然而，这个查询有一个问题——由于两个表都有
    `name` 列，我们不能使用 `*` 来包含所有字段，因为它们将被覆盖。相反，我们需要手动包含它们：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we specified the fields from both tables we wanted to include,
    and we indicated different names as aliases where there was a name conflict. Now,
    let''s write the same query using the query builder:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们指定了想要包含的两个表中的字段，并在存在名称冲突的地方使用了不同的别名。现在，让我们使用查询构建器来编写相同的查询：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First of all, not all methods on the query builder are chainable. The `join()`
    method (and the other types of join methods, such as `innerJoin()`, `leftJoin()`,
    and `rightJoin()`) and the `addField()` method are prominent examples. The latter
    is a way we can add fields to the query by specifying an alias (we cannot do it
    via the `fields()` method). Moreover, the `condition()` field is also prefixed
    with the table alias it needs to be in (which was not necessary before when we
    didn't use a join).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查询构建器上的不是所有方法都是可链式的。`join()`方法（以及其他类型的连接方法，如`innerJoin()`、`leftJoin()`和`rightJoin()`）以及`addField()`方法是一些突出的例子。后者是一种我们可以通过指定别名来向查询中添加字段的方法（我们无法通过`fields()`方法来做）。此外，`condition()`字段也带有它需要的表别名前缀（在我们之前没有使用连接时这不是必要的）。
- en: For more information about all the other methods useful for building queries,
    go to `SelectInterface` and `ConditionInterface`. They are typically well-documented
    in there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建查询的所有其他有用方法的更多信息，请访问`SelectInterface`和`ConditionInterface`。它们在那里通常有很好的文档说明。
- en: Range queries
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围查询
- en: 'Since limiting queries to a certain range depends on the underlying database
    engine, we also have the `queryRange()` method on our database connection service,
    which we can use to write queries that include ranges:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将查询限制到特定范围取决于底层数据库引擎，我们还在数据库连接服务上有一个`queryRange()`方法，我们可以用它来编写包含范围的查询：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we query for all the players and limit the result set to the
    first 10 records (from 0 to 10). So, with this method, the placeholder value array
    is the fourth parameter after `$from` and `$count`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们查询所有球员并将结果集限制为前10条记录（从0到10）。因此，使用这种方法，占位符值数组是`$from`和`$count`之后的第四个参数。
- en: 'Alternatively, using the `SELECT` query builder, we have a method on the `SelectInterface`
    whereby we can specify a range. So, in that format, the previous query would look
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`SELECT`查询构建器，我们在`SelectInterface`上有一个方法，可以指定一个范围。因此，按照这种格式，之前的查询将看起来像这样：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have the `range()` method, which takes those arguments and
    limits the query.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有`range()`方法，它接受这些参数并限制查询。
- en: 'A note on running select queries on Entity tables: if you can do so using the
    Entity Query, use that. If not, feel free to use the database API. However, stick
    to using the query to figure out the IDs of the entities you need, but then use
    the entity storage handler to load those entities properly. This is unlike the
    many times in Drupal 7 where we simply used field values from such queries directly.
    In Drupal 8, that is highly discouraged.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在实体表上运行选择查询的注意事项：如果你可以使用实体查询来完成，请使用它。如果不能，请随意使用数据库API。然而，坚持使用查询来确定所需实体的ID，然后使用实体存储处理程序正确加载这些实体。这与Drupal
    7中的许多情况不同，那时我们直接从这样的查询中使用了字段值。在Drupal 8中，这被高度不建议。
- en: Pagers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页器
- en: Now that we have seen how to make `SELECT` queries of all kinds, let's take
    a look at how we can use Drupal's built-in pagination capabilities and how pagers
    work in Drupal 8\. We will illustrate these by running some queries and rendering
    the results inside a table. Refer to [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*, if you don't remember the theming aspects of outputting a table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何进行各种类型的`SELECT`查询，让我们看看如何使用Drupal内置的分页功能以及Drupal 8中的分页器是如何工作的。我们将通过运行一些查询并在表格中渲染结果来展示这些。如果你不记得输出表格的主题方面，请参阅[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*。
- en: Our playground will be inside a new controller method (`SportsController::players()`)
    which maps to the route with the `/players` path. Refer to [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*, for a refresher on how to create routes if you don't
    remember.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游乐场将位于一个新的控制器方法中（`SportsController::players()`），它映射到具有`/players`路径的路由。如果你不记得如何创建路由，请参阅[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建您的第一个模块*，以刷新记忆。
- en: 'The first thing we''ll do is create a simple query that loads all the players
    and outputs them inside a table. We''ll stick to only showing the player names
    for simplicity:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个简单的查询，该查询加载所有球员并在表格中输出它们。为了简单起见，我们只显示球员名字：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All of this should already be familiar to you. We are running the query and
    preparing the data for a table, using the `table` theme hook to render it. You'll
    note that we are creating a `$build` array so that we can include more things
    in the final output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对你来说应该都很熟悉。我们正在运行查询并准备表格数据，使用`table`主题钩子来渲染它。你会注意到我们正在创建一个`$build`数组，这样我们就可以在最终输出中包含更多内容。
- en: By navigating to `/players`, we should now already see a table with our player
    names. This will be our baseline from which to explore pagers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到`/players`，我们现在应该已经看到了一个包含我们玩家名称的表格。这将成为我们探索分页器的基线。
- en: 'Pagers work by storing some information regarding a query in the global state,
    namely the total number of items to be paged, the limit of items per page, and
    an identifier for the respective pager (so we can potentially have multiple pagers
    at once). All of this information is set using the following code (you don''t
    have to add this anywhere now):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 分页器通过在全局状态中存储有关查询的一些信息来工作，即要分页的总项目数、每页的项目限制以及相应分页器的标识符（这样我们就可以同时拥有多个分页器）。所有这些信息都使用以下代码设置（你现在不需要在任何地方添加此代码）：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Moreover, the current page is determined by the query parameter in the URL,
    named `page`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当前页码由URL中的查询参数确定，名称为`page`。
- en: Once the pager is initialized, we have a `pager` render element we can use to
    easily render a themed pager that uses this information and builds all the necessary
    links to move between the pages. As query builders, we then have to read the current
    page and use that inside our query.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分页器初始化，我们就有一个`pager`渲染元素，我们可以用它轻松渲染一个使用这些信息并构建所有必要链接以在页面之间移动的主题分页器。作为查询构建者，我们接下来必须读取当前页码并在我们的查询中使用它。
- en: However, there is a much simpler way to work with pagers, and that is using
    *select extenders*. These are *decorator* classes for the `SELECT` query class
    we've seen before, and they allow us to decorate it with an extra functionality,
    such as pagers or sorting; they encapsulate the necessary functionality for handling
    pagers in the query. So, let's see it in action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，处理分页器有一个更简单的方法，那就是使用*选择扩展器*。这些是针对我们之前看到的`SELECT`查询类的装饰器类，它们允许我们通过额外的功能对其进行装饰，例如分页或排序；它们封装了处理查询中分页所需的所有功能。让我们看看它是如何工作的。
- en: 'Here is how our player query would look using the `PagerSelectExtender`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的玩家查询将如何使用`PagerSelectExtender`来显示：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we have an `extend()` method on the `SELECT` query builder,
    which allows us to pass the name of the class that will decorate the resulting
    `SELECT` query class. This also provides us with a new method called `limit()`,
    through which we specify the number of records to load per page. Under the hood,
    it uses the `range()` method we saw earlier. Moreover, when running the query,
    it initializes the pager for us using `pager_default_initialize()`, and even determines
    the current page all on its own. So typically you'll use the extender directly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在`SELECT`查询构建器上有一个`extend()`方法，它允许我们传递将装饰结果`SELECT`查询类的类名。这也为我们提供了一个名为`limit()`的新方法，通过它我们可以指定每页要加载的记录数。在底层，它使用我们之前看到的`range()`方法。此外，在运行查询时，它使用`pager_default_initialize()`为我们初始化分页器，甚至自己确定当前页码。所以通常你会直接使用扩展器。
- en: The *Decorator Pattern* is an object-oriented programming design pattern that
    allows us to statically or dynamically add behavior to an existing object without
    altering how it, or other objects of the same class, behaves inside. A decorator
    essentially wraps an existing object to provide extra functionality from the outside.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器模式*是一种面向对象的编程设计模式，它允许我们静态或动态地向现有对象添加行为，而不会改变它或同一类其他对象的行为。装饰器本质上是对现有对象的包装，以提供从外部额外的功能。'
- en: 'So, all we need to do now is render the following pager (below the table):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在需要做的就是渲染以下分页器（在表格下方）：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Positively rocket science, right? Not really. If we refresh the page, we should
    now see only five players in the table, and also a pager below it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是正火箭科学吗？其实不是。如果我们刷新页面，现在我们应该只看到表格中的五个玩家，以及它下面的分页器。
- en: The Pager render element ([https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x))
    has some interesting properties we can use to customize it further. We can append
    query elements to the resulting links, or even specify another route for the links
    if we want to. We can, of course, control the label of the pager links, and even
    the number of links being output. Check out the documentation of this element
    for more information.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分页渲染元素([https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x))有一些有趣的属性，我们可以使用它们来进一步定制它。我们可以向生成的链接中添加查询元素，或者如果我们想的话，甚至可以指定另一个路由。当然，我们可以控制分页链接的标签，甚至输出的链接数量。查看该元素的文档以获取更多信息。
- en: Moreover, for full customization, we also have the option of preprocessing these
    variables by implementing our own preprocessor for the `pager` hook (such as `template_preprocess_page`)
    and/or overriding the `pager.twig.html` template file. We learned how to do these
    things in in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了实现完全定制，我们还可以选择通过实现自己的预处理器（例如`template_preprocess_page`）来预处理这些变量，或者覆盖`pager.twig.html`模板文件。我们在[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*中学习了如何做这些事情。
- en: Insert queries
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入查询
- en: 'In order to get data into our custom database tables, we have an `INSERT` query
    builder that we can use. For this and the other types of queries it is highly
    discouraged to use the `db_query()` approach because Drupal cannot ensure that
    it works across the different types of database engines. Instead, we can use the
    `insert()` method on the connection service and build our query using the `Insert`
    object that gets returned. So, let''s see how we can add a record to our `players`
    table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据插入到我们的自定义数据库表中，我们有一个可用的`INSERT`查询构建器。对于这种和其他类型的查询，强烈建议不要使用`db_query()`方法，因为Drupal无法保证它在不同的数据库引擎类型上都能正常工作。相反，我们可以使用连接服务上的`insert()`方法，并使用返回的`Insert`对象来构建我们的查询。那么，让我们看看我们如何向我们的`players`表中添加一条记录：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The main thing about an insert query is the `fields()` method. It expects an
    array of key/value pairs, where the keys are the column names and the values are
    the data that needs to be added to the respective columns. Alternatively, the
    first argument can be an array of the column names and the second an array of
    the values in the same order as the column names from the first array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 插入查询的主要问题是`fields()`方法。它期望一个键/值对的数组，其中键是列名，值是需要添加到相应列的数据。或者，第一个参数可以是一个列名的数组，第二个是一个与第一个数组中列名顺序相同的值的数组。
- en: 'We can also run an `INSERT` query with multiple sets of values (records):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用多组值（记录）运行一个`INSERT`查询：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the `fields()` method receives only an array of column names
    that need to be inserted, and we use `values()` method calls to add the individual
    values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`fields()`方法只接收需要插入的列名的数组，我们使用`values()`方法调用来添加单个值。
- en: The `execute()` method typically returns the ID (primary key) of the last record
    to be inserted. This is handy, especially if you insert only one record. However,
    for multiple inserts, it can also be misleading. So, do experiment for yourself
    with different use cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()`方法通常返回最后插入的记录的ID（主键）。这很有用，尤其是如果你只插入一条记录。然而，对于多个插入，它也可能具有误导性。所以，请根据自己的不同用例进行实验。'
- en: Update queries
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新查询
- en: 'Now that we''ve seen `INSERT` queries, let''s take a look at how we can update
    existing records. Say we wanted to update one of our player records; we will do
    so as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`INSERT`查询，让我们看看我们如何更新现有记录。假设我们想要更新我们的玩家记录之一；我们将这样做：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`UPDATE` queries are like `INSERT` ones, except that they take a `condition()`
    to figure out which records to update (all that match the condition). Leaving
    this out will update all records, naturally. Using the `fields()` method, we will
    simply specify which columns are getting updated, and with what. If we leave out
    a column, it will stay untouched. Lastly, the result of this query is the total
    number of records affected.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE`查询类似于`INSERT`查询，不同之处在于它们需要一个`condition()`来确定要更新的记录（所有符合该条件的记录）。省略这一点将自然地更新所有记录。使用`fields()`方法，我们将简单地指定哪些列正在更新，以及更新为什么。如果我们省略一个列，它将保持不变。最后，这个查询的结果是受影响的记录总数。'
- en: Delete queries
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除查询
- en: 'Lastly, we can also get rid of our records using the `DELETE` query:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用 `DELETE` 查询删除我们的记录：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All records that match the condition will get removed. Be careful with this
    because, as with update queries, leaving out a condition will basically truncate
    your table. The query will return the number of records affected, that is, deleted.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有匹配条件的记录都将被删除。请注意这一点，因为与更新查询一样，省略条件基本上会截断你的表。查询将返回受影响的记录数，即被删除的记录数。
- en: Although you can write `SELECT` queries against entity and field tables to find
    the IDs of the entities you want to load, you should never perform `INSERT`, `UPDATE`,
    or `DELETE` queries against these tables. You run a very high risk of corrupting
    your data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以针对实体和字段表编写 `SELECT` 查询以找到你想要加载的实体的 ID，但你绝不应该对这些表执行 `INSERT`、`UPDATE` 或
    `DELETE` 查询。你面临很高的风险会损坏你的数据。
- en: Transactions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: The Drupal database API also provides a way to represent and handle database
    transactions (for database types that support them). Transactions are a way in
    which database operations can be wrapped and grouped together with a view of committing
    them in an "all or none" type of fashion. For example, if you have multiple records
    that are related, it's possible you will want only some of them written if one
    fails its `INSERT` operation for some reason. This could leave you with corrupt
    or incomplete data that could throw your application into a spin.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 数据库 API 还提供了一种表示和处理数据库事务（对于支持这些数据库类型的数据库）的方法。事务是一种将数据库操作包装并分组在一起，并以“全部或无”的方式提交它们的方式。例如，如果你有多个相关的记录，可能你只想在其中一个记录的
    `INSERT` 操作因某些原因失败时写入其中一些。这可能会导致你得到损坏或不完整的数据，从而使你的应用程序陷入混乱。
- en: Performing multiple database-changing operations after a transaction has been
    opened only finalizes (commits) those changes to the database when that transaction
    closes. If something goes wrong, it can also be rolled back, which will prevent
    the data from being committed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开启事务之后执行多个数据库更改操作，只有在事务关闭时才会最终确定（提交）这些更改到数据库。如果出现问题，它也可以回滚，这将防止数据被提交。
- en: In Drupal 8, a transaction is represented by a `Transaction` object (a specific
    subclass for each database type). As soon as the object is destroyed (is no longer
    in scope), the operations get committed to the database. However, if we get an
    indication that something went wrong in our operations (usually via catching an
    exception), we can roll back the transaction, which will stop those operations
    from being committed. Moreover, transactions can be nested, so Drupal keeps track
    of transactions that have been opened within the scope of other transactions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，事务由一个 `Transaction` 对象表示（每个数据库类型都有一个特定的子类）。一旦对象被销毁（不再在作用域内），操作就会被提交到数据库。然而，如果我们得到我们的操作中出错的指示（通常是通过捕获异常），我们可以回滚事务，这将阻止这些操作被提交。此外，事务可以嵌套，因此
    Drupal 会跟踪在另一个事务的作用域内打开的事务。
- en: 'Let''s see an example of how to use transactions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用事务的示例：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing we did was start a transaction using our connection service.
    Then, we wrapped our operation in a *try/catch* block to catch any exceptions
    that might be thrown in performing it. If one does get thrown, we roll back the
    transaction because we don't want to commit anything to the database, as we don't
    know what failed and what shape our data is in. Finally, we used the `watchdog_exception()`
    helper to log the exception to the database log. Do note that logging this before
    the rollback would prevent the exception from being written to the database as
    well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用我们的连接服务启动了一个事务。然后，我们将操作包装在一个 *try/catch* 块中，以捕获在执行过程中可能抛出的任何异常。如果抛出了异常，我们将回滚事务，因为我们不想将任何内容提交到数据库，因为我们不知道什么失败了，我们的数据处于什么状态。最后，我们使用了
    `watchdog_exception()` 辅助函数将异常记录到数据库日志中。请注意，在回滚之前记录这个异常将防止异常被写入数据库。
- en: If there is no exception, the operation gets committed as soon as the `$transaction`
    variable gets removed and is no longer in scope (usually at the end of the function).
    It is also interesting to note that if, within this transaction, we call another
    function in which we perform database operations, those operations will be part
    of this same transaction by default. So they also get rolled back if we roll back
    or get committed if we don't. This is why the database watchdog log will not be
    saved if called before the rollback.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有异常，操作会在`$transaction`变量被移除且不再在作用域内（通常在函数末尾）时立即提交。值得注意的是，如果在这次事务中我们调用另一个执行数据库操作的功能，这些操作将默认成为同一事务的一部分。因此，如果我们回滚，它们也会回滚；如果我们不回滚，它们会提交。这就是为什么在回滚之前调用数据库看门狗日志不会被保存的原因。
- en: Query alters
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询修改
- en: Lots of things in Drupal are alterable using various hooks; queries are no different.
    This means that if a module writes a query such as we've seen before, other modules
    can alter it by implementing `hook_query_alter()`. So let's consider an example
    of how this may work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal中，许多东西都可以通过各种钩子进行修改；查询也不例外。这意味着如果一个模块编写了之前看到的查询，其他模块可以通过实现`hook_query_alter()`来修改它。所以让我们考虑一个例子，看看它是如何工作的。
- en: 'Let''s assume the following query, which simply returns all player records:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设以下查询，它简单地返回所有球员记录：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Imagine that another module wants to alter this query and limit the results
    to find only the players in a specific team. There is one problem. Our query has
    no markers that can indicate to another module that this is the one that needs
    to be altered. As you can imagine, there are a bunch of queries that are run in
    any given request, so identifying queries becomes impossible. Enter *query tags*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设另一个模块想要修改这个查询并限制结果只找到特定队伍的球员。有一个问题。我们的查询没有标记可以指示另一个模块需要修改的是这个查询。正如你可以想象的那样，在任何请求中都会运行大量的查询，因此识别查询变得不可能。这时就出现了*查询标签*。
- en: 'The previous query would not be alterable because it''s not recognizable, and
    therefore, `hook_query_alter()` is not even fired on it. In order to make it alterable,
    we will need to add a query tag and make it identifiable. There is a simple method
    on the query builder for doing just that: `addTag()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的查询无法修改，因为它无法识别，因此`hook_query_alter()`甚至不会在其上触发。为了使其可修改，我们需要添加一个查询标签并使其可识别。查询构建器上有一个简单的方法可以做到这一点：`addTag()`：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Query tags are simple strings that can be read from inside a `hook_query_alter()`
    implementation. So, we could alter the query like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 查询标签是简单的字符串，可以从`hook_query_alter()`实现内部读取。因此，我们可以这样修改查询：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only parameter of this hook is the query object onto which we can apply
    our changes. It also has methods for reading the tags, such as `hasTag()`, `hasAnyTag()`,
    or `hasAllTags()`. In the previous example we took a defensive approach and simply
    exited if the query was not about our `player_query` tagged query. I'll come back
    to this later on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子的唯一参数是我们可以对其应用更改的查询对象。它还有读取标签的方法，例如`hasTag()`、`hasAnyTag()`或`hasAllTags()`。在之前的例子中，我们采取了防御性方法，如果查询不是关于我们的`player_query`标签查询，就简单地退出。我稍后会回到这个问题。
- en: 'Now, let''s see how we can alter this query to achieve what we set out to do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何修改这个查询以实现我们的目标：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we are doing a similar thing to what we did before when we built
    our joined query. We join the team table, add its name field (as a bonus), and
    set a condition to only return the players in a certain team. Easy peasy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在做与之前构建联合查询时类似的事情。我们将队伍表连接起来，添加其名称字段（作为额外奖励），并设置一个条件，只返回特定队伍的球员。轻而易举。
- en: Let's now return for a second to my remark about the defensive approach we took
    with this hook implementation. I personally prefer to keep methods short and return
    early, rather than have a bunch of unintelligible nested conditions. This is typically
    easy to do in an object-oriented setting. However, with procedural code, it becomes
    a bit more tedious as you need many private functions that are tricky to name,
    and even more so with hook implementations into which you might need to add more
    than one block of code. For example, in our `hook_query_alter()` implementation,
    we might need to add an alteration for another query later on. Also, since we
    return early, we need to add another condition for checking for two tags, and
    then some more conditions and *if* statements, and even more conditions (OK, rant
    over). From a PHP point of view, in this case you'd delegate the actual logic
    to another function based on the tag of the query, either using a simple switch
    block or *if* conditionals. This way, if a new tag comes, a new function can be
    created for it specifically and called from the switch block. However, we can
    do one better in this case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到我对这个钩子实现采取的防御性方法的评论。我个人更喜欢保持方法简短并尽早返回，而不是有一堆难以理解的嵌套条件。在面向对象的环境中，这通常很容易做到。然而，在过程式代码中，这会变得有点繁琐，因为你需要许多难以命名的私有函数，而且在钩子实现中，你可能需要添加多个代码块。例如，在我们的`hook_query_alter()`实现中，我们可能需要在稍后添加对另一个查询的修改。此外，由于我们尽早返回，我们需要添加另一个条件来检查两个标签，然后是一些更多的条件和*if*语句，以及更多的条件（好吧，发牢骚结束了）。从PHP的角度来看，在这种情况下，你会根据查询的标签将实际逻辑委托给另一个函数，要么使用简单的switch块，要么使用*if*条件。这样，如果出现新的标签，可以为其创建一个新的函数，并从switch块中调用它。然而，在这种情况下，我们可以做得更好。
- en: 'There are a few hooks, particularly *alter* ones, that have general targeting
    but also a more specific one. In this example, we also have a `hook_query_TAG_alter()`
    hook, which is specific to a given tag. So, instead of us delegating to other
    functions, we could implement the more specific:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个钩子，尤其是*修改*钩子，具有一般的目标，但也具有更具体的目标。在这个例子中，我们还有一个针对特定标签的`hook_query_TAG_alter()`钩子。因此，我们不是将任务委托给其他函数，而是可以实施更具体的：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, essentially, the tag itself becomes part of the function name, and we don't
    need any extra functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，标签本身成为了函数名的一部分，我们不需要任何额外的函数。
- en: Update hooks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新钩子
- en: At the beginning of this chapter, we defined two tables using `hook_schema()`
    which got installed together with the module. To reiterate, if the module had
    already been installed, we could have triggered the schema installation using
    the `drupal_install_schema()` function. However, what if we needed to add another
    column later on, say to the `teams` table? Our module is installed, and so is
    the schema; so we cannot exactly uninstall it on production just to trigger the
    schema creation again, not to mention losing the data. Luckily, there is a system
    in place for this, namely *update* hooks— `hook_update_N()`—where `N` represents
    the schema version. These are sequentially named hook implementations that go
    inside the module `*.install` file and that are triggered when running the updates,
    either via going to `/update.php` or by using the `drush updatedb` command.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们使用`hook_schema()`定义了两个表格，该函数与模块一起安装。为了重申，如果模块已经安装，我们可以通过使用`drupal_install_schema()`函数来触发模式安装。然而，如果我们稍后需要向`teams`表添加另一列，那该怎么办呢？我们的模块已经安装，模式也是如此；所以我们不能在生产环境中完全卸载它来再次触发模式创建，更不用说丢失数据了。幸运的是，有一个系统可以处理这种情况，即*更新*钩子——`hook_update_N()`——其中`N`代表模式版本。这些是按顺序命名的钩子实现，它们位于模块`*.install`文件中，并且在运行更新时被触发，无论是通过访问`/update.php`还是使用`drush
    updatedb`命令。
- en: The main purpose of these update hooks is making schema alterations to existing
    database tables. However, partly due to the weak configuration management system
    in earlier versions of Drupal, they have evolved—through developer creativity—into
    a mechanism for updating various types of configuration or performing tasks (even
    content-related) upon a deployment to the next environment. Helping out with this
    is the `$sandbox` argument passed to the hook implementations, which can be used
    to batch these operations (to prevent an execution timeout). We will not cover
    this aspect here, but will instead talk about the standalone Batch API in a future
    chapter, lessons from which you'll be able to apply here as well. Instead, we
    will see how to implement such a hook to perform schema updates.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新钩子的主要目的是对现有的数据库表进行模式更改。然而，部分原因是早期版本的Drupal中配置管理系统较弱，它们已经通过开发者的创造力发展成为一种更新各种类型配置或执行部署到下一个环境时的任务（甚至与内容相关的任务）的机制。帮助实现这一点的是传递给钩子实现的`$sandbox`参数，它可以用来批量这些操作（以防止执行超时）。我们在这里不会涉及这个方面，而是在未来的章节中讨论独立的批量API，从中学到的经验你将能够在这里应用。相反，我们将看到如何实现这样的钩子以执行模式更新。
- en: 'As mentioned, these hook implementations go into the `*.install` file. Let''s
    see an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些钩子实现会放入`*.install`文件中。让我们看看一个例子：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The DocBlock of this hook implementation should contain a description of what
    it does. It is displayed when running the updates (either via the UI or using
    Drush).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子实现的DocBlock应该包含对其功能的描述。当运行更新时（无论是通过UI还是使用Drush）会显示出来。
- en: The name of the function is one of its most important aspects. It starts with
    the module name, followed by `update`, and finally, by the module's schema version
    (the next one if we want this update hook to actually run); but what is a module's
    schema version?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称是其最重要的方面之一。它以模块名称开头，然后是`update`，最后是模块的模式版本（如果我们希望此更新钩子实际运行，则是下一个版本）；但模块的模式版本是什么？
- en: 'When installed, Drupal sets each module a schema version: 8000\. In Drupal
    7, it was 7000, and in 6, it was 6000\. You get the difference between the major
    versions of Drupal. When an update hook runs, Drupal sets that module''s schema
    version to the number found in the update hook. So, in the previous example, it
    would be 8001\. This is to keep track of all the update hooks and to not run them
    more than once. By convention, but not necessity, the second digit from the left in
    the schema version represents the major version number of the module itself. For
    example, for an `8.x-1.x` version, it would be 8101.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，Drupal为每个模块设置一个模式版本：8000。在Drupal 7中，它是7000，在6中是6000。你得到了Drupal主要版本的差异。当更新钩子运行时，Drupal将该模块的模式版本设置为更新钩子中找到的编号。所以，在前面的例子中，它将是8001。这是为了跟踪所有更新钩子，并且不运行它们超过一次。按照惯例，但不是必需的，模式版本从左数第二个数字代表模块本身的主要版本号。例如，对于`8.x-1.x`版本，它将是8101。
- en: Let's now see how we can alter our `teams` database table with an update hook
    and add a column to store a `location` string field. The first thing we want to
    do is update our `hook_schema()` implementation and add this information there
    as well. This won't do anything in our case; however, due to the way update hooks
    work, we need to add it there as well. What I mean by this is that if a module
    is first installed and it has update hooks in it already, those update hooks do
    not run, but the module's schema version gets set as the number of the last update
    hook found in it. So, if we do not add our new column inside `hook_schema()`,
    installing this module on another site (or even on the current one after an uninstall)
    will not get our new column in. So, we need to account for both situations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何通过更新钩子来修改我们的`teams`数据库表，并添加一个用于存储`location`字符串字段的列。我们首先想要做的是更新我们的`hook_schema()`实现，并将这些信息也添加进去。在我们的情况下，这不会做任何事情；然而，由于更新钩子的工作方式，我们仍然需要将其添加进去。我的意思是，如果一个模块首先安装并且其中已经存在更新钩子，那么这些更新钩子不会运行，但模块的模式版本会被设置为在模块中找到的最后一个更新钩子的编号。所以，如果我们不在`hook_schema()`内部添加我们的新列，那么在另一个站点（甚至是在卸载后当前站点）安装此模块将不会得到我们的新列。因此，我们需要考虑这两种情况。
- en: 'In the field definition of our `teams` table schema, we can add the following
    column definition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`teams`表模式定义的字段定义中，我们可以添加以下列定义：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It''s as simple as that. Next, we can implement an update hook and add this
    field to the table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。接下来，我们可以实现一个更新钩子并将此字段添加到表中：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we used the same field definition, loaded the database connection service,
    and used its schema object to add that field to the table. The code itself is
    pretty self-explanatory, but it's also worth mentioning that this is an example
    in which we cannot inject the service, hence we have to use it statically. So,
    don't feel bad about situations like this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了相同的字段定义，加载了数据库连接服务，并使用其模式对象将此字段添加到表中。代码本身相当直观，但还值得一提的是，这是一个我们不能注入服务的示例，因此我们必须静态地使用它。所以，对于这种情况，请不要感到难过。
- en: 'Next, we can use Drush to run the updates:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用Drush来运行更新：
- en: '![](img/47651417-f60d-450c-acc1-fbe5471f4075.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47651417-f60d-450c-acc1-fbe5471f4075.png)'
- en: Sure enough, the `teams` table now has a new column. If you try to run the updates
    again, you'll note that there are none to be run because Drupal has set the schema
    version of the `sports` module to 8001\. So, the next one in line to be run has
    to have 8002 at the end (or, something greater than 8001 and lower than 9000,
    in any case).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`teams`表现在有一个新列。如果您再次尝试运行更新，您会注意到没有可运行的更新，因为Drupal已将`sports`模块的模式版本设置为8001。因此，下一个要运行的更新必须在末尾有8002（或者，在任何情况下，大于8001且小于9000的任何数字）。
- en: 'In the previous example, we added a new field to an existing table. However,
    we might need to create a new table entirely, or even delete one. The schema object
    on the database connection service has the relevant methods to do so. The following
    are a few examples, but I recommend that you check out the base `Drupal\Core\Database\Schema`
    class for the available methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们向一个现有的表中添加了一个新字段。然而，我们可能需要完全创建一个新表，甚至删除一个。数据库连接服务上的模式对象提供了相关方法来完成这些操作。以下是一些示例，但我建议您查看`Drupal\Core\Database\Schema`基类以了解可用的方法：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are a few cautionary aspects you need to consider when using update hooks.
    For example, you cannot be sure of the state of the environment before the hooks
    actually run, so ensure that you account for this. I recommend you check out the
    documentation ([https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x))
    about `hook_update_N()` and carefully read the section about the function body.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用更新钩子时，有几个注意事项需要考虑。例如，在钩子实际运行之前，您无法确定环境的状况，因此请确保您考虑到这一点。我建议您查看关于`hook_update_N()`的文档([https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x))，并仔细阅读关于函数体的部分。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the basics of interacting with the database API.
    Although it's something that has taken a significant step back in importance in
    day-to-day Drupal module development, it's important to understand it and be able
    work with it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与数据库API交互的基础知识。尽管在日常Drupal模块开发中，它在重要性上已经退步了很多，但了解它并能够与之工作是很重要的。
- en: We started the chapter by creating our very own database tables to hold player
    and team information in a relational way. We did so using an API that transforms
    definitions into actual tables without us having to even understand much about
    MySQL. The SQL terminology and basic operations are, however, something that every
    developer should be familiar with, notwithstanding their actual day-to-day application
    in Drupal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以创建我们自己的数据库表开始本章，以关系方式存储玩家和团队信息。我们这样做是使用一个API，该API将定义转换为实际的表，而无需我们了解太多关于MySQL的知识。然而，SQL术语和基本操作是每个开发者都应该熟悉的，尽管他们在Drupal的实际日常应用中可能并不常用。
- en: Then, we looked at some examples of how we can run `SELECT`, `INSERT`, `UPDATE`,
    and `DELETE` queries using both the more SQL-oriented way of writing statements
    and the query builder approach, which uses an OO representation of the queries.
    We've also seen how these queries can be wrapped into transactions (where supported)
    so that we can commit data changes while minimizing the potential for incomplete
    or corrupt data. Finally, we saw how these queries can be altered using query
    tags, allowing for yet another small extension point that other modules can contribute
    through. Regardless of how we build our queries, however, a key takeaway is that
    using this API is crucial for a secure interaction with the database. Moreover,
    it accounts for cross-compatibility with the different database types Drupal can
    work with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了一些示例，展示了如何使用更偏向SQL的语句编写方式以及查询构建器方法来运行`SELECT`、`INSERT`、`UPDATE`和`DELETE`查询。我们还看到了这些查询如何被封装到事务中（在支持的情况下），以便在最小化数据不完整或损坏的潜在风险的同时提交数据更改。最后，我们看到了如何使用查询标签来修改这些查询，这为其他模块通过贡献提供了另一个小的扩展点。然而，无论我们如何构建我们的查询，一个关键要点是使用此API对于与数据库的安全交互至关重要。此外，它还考虑了与Drupal可以工作的不同数据库类型的跨兼容性。
- en: Lastly, we looked at update hooks and how they can be used to perform changes
    to our database tables. More than that, they can be employed to perform some other
    tasks that might need to be coded and then deployed to the next environment to
    be run once. However, due to the Drupal 8 Configuration API, the need for this
    has reduced significantly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了更新钩子及其如何被用来对数据库表进行更改。不仅如此，它们还可以被用来执行一些可能需要编码并部署到下一个环境以运行一次的其他任务。然而，由于Drupal
    8配置API，这种需求已经显著减少。
- en: In the next chapter, we will look at custom Drupal 8 entity fields and see how
    we can define our own; yes, we'll be playing with some more plugins.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨自定义Drupal 8实体字段，并了解我们如何定义自己的字段；是的，我们将玩一些更多的插件。
