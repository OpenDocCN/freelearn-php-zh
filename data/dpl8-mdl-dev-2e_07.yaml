- en: Your Own Custom Entity and Plugin Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您自己的自定义实体和插件类型
- en: I am sure that you are looking forward to applying some of the knowledge gained
    from the previous chapters and doing something practical and fun. As promised,
    in this chapter, we will do just that. Also, apart from implementing our own entity
    types, we will cover some new things as well. So, here's the game plan.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你正在期待应用从上一章中获得的一些知识，做一些实际而有趣的事情。正如承诺的那样，在本章中，我们将这样做。此外，除了实现我们自己的实体类型外，我们还将介绍一些新内容。所以，这就是我们的计划。
- en: The premise is that we want to have products on our site that hold some basic
    product information, such as an ID, a name, and a product number. However, these
    products need to somehow get onto our site. One way will be manual entry. Another,
    more important way will be through an import from multiple external sources (such
    as a JSON endpoint). Now, things will be kept simple. For all intents and purposes,
    these products aren't going to do much, so don't expect an e-commerce solution
    being laid out for you. Instead, we will practice modeling data and functionality
    in Drupal 8.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前提是我们希望在网站上拥有包含一些基本产品信息的产品，例如 ID、名称和产品编号。然而，这些产品需要以某种方式出现在我们的网站上。一种方式是手动输入。另一种，更重要的一种方式是通过从多个外部来源（如
    JSON 端点）导入。现在，事情将保持简单。从所有目的和意图来看，这些产品不会做太多，所以不要期待为你提供一个电子商务解决方案。相反，我们将练习在 Drupal
    8 中建模数据和功能。
- en: First, we will create a simple content entity type to represent our products.
    In doing so, we will make sure that we can use the UI to create, edit, and delete
    these products with ease by taking advantage of many Entity API benefits available
    out of the box.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的内容实体类型来表示我们的产品。在这样做的时候，我们将确保通过利用许多现成的实体 API 优势，我们可以轻松地使用 UI 创建、编辑和删除这些产品。
- en: Second, we will model our importing functionality. One side of the coin will
    be a simple configuration entity type to represent the configuration needed for
    our various importers. Again, we will make use of the Entity API for quick scaffolding
    and entity management. The other side will be a custom plugin type that will actually
    perform the import based on the configuration found in the entities. As such,
    these will be linked from the direction of the config entities, which will choose
    to use one plugin or another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将建模我们的导入功能。一枚硬币的一面将是一个简单的配置实体类型，用于表示我们各种导入器所需的配置。同样，我们将利用实体 API 进行快速脚手架和实体管理。另一面将是一个自定义插件类型，它将根据在实体中找到的配置实际执行导入。因此，这些将链接到配置实体的方向，配置实体将选择使用一个插件或另一个。
- en: So these are the highlights. In building all this, we will see much of what
    is needed to define a content and configuration entity type with fields to hold
    data and configuration, as well as a plugin type to encapsulate logic. When defining
    these things, we will take the manual, more tedious, route to make sure that we
    understand what each component does and we are comfortable with what we are doing.
    Once you know all that, you'll be able to greatly speed up these processes using
    the Drupal Console to automatically generate much of the boilerplate code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这些都是重点。在构建所有这些时，我们将看到定义内容、配置实体类型以及用于封装逻辑的插件类型所需的大部分内容，这些类型具有用于存储数据和配置的字段。在定义这些内容时，我们将采取手动、更繁琐的路线，以确保我们理解每个组件的作用，并且对我们所做的事情感到舒适。一旦你了解了所有这些，你将能够使用
    Drupal Console 自动生成大量样板代码来大大加快这些过程。
- en: The code we write in this chapter will go inside a new module called `products`.
    Since we have learned how to create a module from scratch, I will not cover the
    initial steps needed for getting started with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们编写的代码将放入一个名为 `products` 的新模块中。由于我们已经学会了从头创建模块的方法，因此我将不会涵盖启动该模块所需的初始步骤。
- en: Custom content entity type
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义内容实体类型
- en: 'As we saw in the previous chapter, when looking at the Node and NodeType entity
    types, entity type definitions belong inside the `Entity` folder of our module''s
    namespace. In there, we will create a class called `Product`, which will have
    an annotation at the top to tell Drupal this is a content entity type. This is
    the most important part in defining a new entity type:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，当查看节点和节点类型实体类型时，实体类型定义属于我们模块命名空间中的 `Entity` 文件夹。在那里，我们将创建一个名为 `Product`
    的类，该类顶部将有一个注解来告诉 Drupal 这是一个内容实体类型。这是定义新实体类型最重要的部分：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the above code block, I omitted the actual contents of the class to first
    focus on the annotation and some other aspects. We will see the rest of it shortly.
    However, the entire working code can be found in the accompanying repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我省略了类的实际内容，首先关注注解和一些其他方面。我们很快就会看到其余的部分。然而，整个工作代码可以在附带的存储库中找到。
- en: If you remember from the previous chapter, we have the `ContentEntityType` annotation
    with the entity type plugin definition. Our example is relatively barebones compared
    to Node, for example, because I wanted to keep things simple. It has no bundles
    and is not revisionable, nor translatable. Also, for some of its handlers, we
    fall back to Entity API defaults.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章的内容，我们有`ContentEntityType`注解和实体类型插件定义。与Node等相比，我们的示例相对简单，因为我想保持事情简单。它没有捆绑包，也不可修订，也不可翻译。此外，对于其中的一些处理器，我们回退到实体API默认值。
- en: The entity type ID and label are immediately visible, so no need to explain
    that; we can instead skip to the "handlers" section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型ID和标签立即可见，因此无需解释；我们可以直接跳到“处理器”部分。
- en: For the view builder handler, we choose to default to the basic `EntityViewBuilder`
    because there is nothing specific our products need to be rendered. Many times,
    this will be enough, but you can also extend this class and create your own.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图构建器处理器，我们选择默认使用基本的`EntityViewBuilder`，因为没有我们产品需要渲染的特定内容。很多时候，这已经足够了，但您也可以扩展这个类并创建自己的。
- en: For the list builder, although still keeping things simple, we needed our own
    implementation in order to take care of things such as the list headers. We will
    see this class soon. The form handler for creating and editing products is our
    own implementation found inside the `Form` namespace of our module, and we will
    see it soon to get a better understanding. We rely on Drupal 8 to help us out
    with the delete form, though.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表构建器，尽管我们仍然保持简单，但我们需要自己的实现来处理列表标题等问题。我们很快就会看到这个类。创建和编辑产品的表单处理器是我们模块`Form`命名空间中的自定义实现，我们很快就会看到它以获得更好的理解。尽管如此，我们仍然依赖Drupal
    8来帮助我们处理删除表单。
- en: Finally, for the route provider, we used the default `AdminHtmlRouteProvider`,
    which takes care of all the routes necessary for an entity type to be managed
    in the admin UI. This means that we no longer need to do anything for routing
    the links referenced in the `links` section of the annotation. Speaking of links,
    it makes sense to place them under the `admin/structure` section of our administration
    for our example, but you can choose another place if you want.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于路由提供者，我们使用了默认的`AdminHtmlRouteProvider`，它负责管理在管理UI中管理实体类型所需的所有路由。这意味着我们不再需要为注释中`links`部分的链接进行路由。说到链接，将它们放在我们示例的`admin/structure`部分下是有意义的，但您可以选择其他位置。
- en: The database table our products will be stored in is `products`, and the permission
    needed for users to manage them is `administer site configuration`. I have deliberately
    omitted creating permissions specific to this entity type because we will cover
    this topic in a chapter dedicated to access. So we will use this permission that
    comes with Drupal core.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们产品将存储的数据库表是`products`，用户管理它们的权限是`administer site configuration`。我故意省略了创建特定于此实体类型的权限，因为我们将在一个专门讨论访问的章节中介绍这个话题。所以我们将使用随Drupal核心提供的这个权限。
- en: Finally, we also have some basic entity keys to map to the respective fields.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一些基本的实体键可以映射到相应的字段。
- en: 'Our `Product` class extends the `ContentEntityBase` class to inherit all the
    necessary stuff from the API and implements our very own `ProductInterface`, which
    will contain all the methods used to access relevant field values. Let''s create
    this interface real quick in the same `Entity` folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Product`类扩展了`ContentEntityBase`类，以从API继承所有必要的功能，并实现了我们自己的`ProductInterface`，它将包含所有用于访问相关字段值的方法。让我们快速在这个`Entity`文件夹中创建这个接口：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we are extending the obligatory `ContentEntityInterface` but
    also the `EntityChangedInterface`, which provides some handy methods to manage
    the last changed date of the entities. Those method implementations will be added
    to our `Product` class via the `EntityChangedTrait`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在扩展必填的`ContentEntityInterface`，同时也扩展了`EntityChangedInterface`，后者提供了一些方便的方法来管理实体的最后更改日期。这些方法实现将通过`EntityChangedTrait`添加到我们的`Product`类中：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The methods on the `ProductInterface` are relatively self-explanatory. We will
    have a product name, number, remote ID, and source field, so it's nice to have
    getters and setters for those. If you remember, the Entity API provides the `get()`
    and `set()` methods with which we can consistently access and store field values
    across all entity types. However, I find that using an interface with well-defined
    methods makes code much clearer, not to mention that IDE autocompletion is a great
    time-saver. We also have a getter and setter for the `created` date field, which
    is a typical field that content entities have.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductInterface` 上的方法相对比较直观。我们将有一个产品名称、编号、远程ID和来源字段，因此为这些字段提供getter和setter方法是很不错的。如果你还记得，实体API提供了`get()`和`set()`方法，我们可以通过这些方法一致地访问和存储所有实体类型的字段值。然而，我发现使用具有明确定义方法的接口可以使代码更加清晰，更不用说IDE自动补全是一个节省时间的伟大功能了。我们还有一个`created`日期字段的getter和setter，这是一个内容实体通常具有的典型字段。'
- en: 'Now, we can take a look at the `baseFieldDefinitions()` method of our `Product`
    entity type and see how we actually defined our fields:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们的`Product`实体类型的`baseFieldDefinitions()`方法，看看我们实际上是如何定义我们的字段的：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First and foremost, we will need to inherit the base fields of the parent class.
    This includes things such as the ID and UUID fields.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要继承父类的基字段。这包括诸如ID和UUID字段等。
- en: Second, we define our own fields, starting with the product name field, which
    is of the `string` type. This `string` type is nothing more than a `FieldType`
    plugin I mentioned in the previous chapter. If you remember, this plugin extends
    a `TypedData` class itself. Apart from the obvious label and description, it has
    some settings, most notably a maximum length for the value, which is 255 characters.
    The `view` and `form` display options reference `FieldFormatter` and `FieldWidget`
    plugins, respectively, which together with the `FieldType` make up a field. Lastly,
    with the `setDisplayConfigurable()`, we specify that some of the options on this
    field should be configurable through the UI. For example, we can change the label
    in the UI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们定义自己的字段，从产品名称字段开始，它是`string`类型。这种`string`类型不过是我在上一章中提到的`FieldType`插件。如果你还记得，这个插件本身扩展了`TypedData`类。除了明显的标签和描述外，它还有一些设置，最值得注意的是值的最大长度，为255个字符。`view`和`form`显示选项分别引用`FieldFormatter`和`FieldWidget`插件，这两个插件与`FieldType`一起构成了一个字段。最后，通过`setDisplayConfigurable()`，我们指定这个字段的一些选项可以通过UI进行配置。例如，我们可以在UI中更改标签。
- en: Then, we have the `number` field which is of the `integer` type and, for this
    example, is restricted to a number between 1 and 10,000\. This restriction setting
    turns into a constraint under the hood. The rest of the options are similar to
    the name field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`number`字段，它是`integer`类型，在这个例子中，限制在1到10,000之间。这个限制设置在底层变成了约束。其余的选项与名称字段类似。
- en: Next, we have the `remote_id` string field, but it doesn't have any widget or
    display settings because we don't necessarily want to display or edit this value.
    It is mostly for internal use to keep track of the product ID of the remote source
    it came from. Similarly, the `source` string field is not displayed or configurable
    either because we want to use it to store the source of the product, where it
    has been imported from, and also to keep track of it programmatically.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`remote_id`字符串字段，但它没有任何小部件或显示设置，因为我们不一定想显示或编辑这个值。它主要用于内部使用，以跟踪来自远程源的产品ID。同样，`source`字符串字段也不显示或可配置，因为我们想用它来存储产品的来源，它从哪里导入，以及程序化跟踪它。
- en: Finally, the `created` and `changed` fields are special fields that store the
    timestamps for when the entity is created and modified. Not much more than that
    needs to be done because these fields automatically set the current timestamps
    as the field values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`created`和`changed`字段是特殊的字段，用于存储实体创建和修改的时间戳。除了这些，不需要做更多的事情，因为这些字段会自动将当前时间戳设置为字段值。
- en: 'By now, we can also see the rest of the class content, which is mostly made
    up of the methods required by the `ProductInterface`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们也可以看到类内容的其余部分，这主要是`ProductInterface`所需的方法：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As promised, we are making use of the `EntityChangedTrait` to handle the `changed`
    field and implement simple getters and setters for the values found in the fields
    we defined as base fields. If you remember the `TypedData` section, the way we
    access a value (since the cardinality is always 1 for these fields) is by running
    the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所承诺的，我们正在使用`EntityChangedTrait`来处理`changed`字段，并为我们在基础字段中定义的字段值实现简单的getter和setter。如果你还记得`TypedData`部分，我们访问值的方式（因为这些字段的基数始终为1）是通过运行以下命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we finish off with our Product entity class, let''s ensure we *use*
    all the remaining classes at the top:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成产品实体类的编写之前，让我们确保使用顶部剩余的所有类：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s now move through the entity type plugin annotation and create the handlers
    we''ve been referencing there. We can start with the list builder, which we can
    place at the root of our namespace:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过实体类型插件注解来遍历，并创建我们在此处引用的处理程序。我们可以从列表构建器开始，我们可以将其放置在我们的命名空间根目录下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of this handler is to build the administration page that lists the
    available entities. On this page, we will then have some info about them, as well
    as operation links to edit and delete and whatever else we might need. For our
    products, we simply extend from the default `EntityListBuilder` class, but override
    the `buildHeader()` and `builderRow()` methods to add some information specific
    to our products. The names of these methods are self-explanatory, but one thing
    to keep in mind is that keys from the `$header` array we return need to match
    the keys from the `$row` array we return. Also, of course, the arrays need to
    have the same number of records so that the table header matches the individual
    rows. If you look inside `EntityListBuilder`, you can note some other handy methods
    you might want to override, such as the one that builds the query and the one
    that loads the entities. For us, this is enough.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器的目的是构建一个列出可用实体的管理页面。在这个页面上，我们将了解一些关于它们的信息，以及编辑、删除和其他可能需要的操作链接。对于我们的产品，我们简单地从默认的`EntityListBuilder`类扩展，但覆盖了`buildHeader()`和`buildRow()`方法来添加一些特定于我们产品的信息。这些方法的名称是自解释的，但需要注意的一点是，我们从`$header`数组返回的键需要与从`$row`数组返回的键匹配。当然，数组需要具有相同数量的记录，以便表头与单个行匹配。如果你查看`EntityListBuilder`内部，你可以注意一些你可能想要覆盖的其他实用方法，例如构建查询和加载实体的方法。对我们来说，这已经足够了。
- en: 'Our products list builder will have, for now, only two columns: the ID and
    the name. For the latter, each row will actually be a link to the product canonical
    URL (the main URL for this entity in Drupal). Finally, you remember, from [Chapter
    2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your First Module*,
    how to build links with the `Link` class, right?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的产品列表构建器将只有两列：ID和名称。对于后者，每一行实际上都是一个链接到产品规范URL（该实体在Drupal中的主要URL）。最后，你还记得从[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中，*创建您的第一个模块*，如何使用`Link`类构建链接吗？
- en: 'The construct for the entity canonical route is in the format: `entity.[entity_type].canonical`.
    Other useful entity links can be built by replacing the word `canonical` with
    the keys from the `links` definition of the Entity type plugin annotation.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实体规范路由的构造格式为：`entity.[entity_type].canonical`。其他有用的实体链接可以通过将`links`定义中实体类型插件注解的键替换为`canonical`来构建。
- en: 'That is pretty much it for the list builder, and we can move on to the form
    handler. Since creating and editing an entity share so much in terms of what we
    need in the form, we use the same `ProductForm` for both those operations. Let''s
    create that form class now inside the *Form* directory of the module namespace:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表构建器来说，这就差不多了，我们可以继续到表单处理器。由于创建和编辑实体在表单需求方面有很多相似之处，我们使用相同的`ProductForm`来处理这两个操作。现在让我们在模块命名空间的`Form`目录中创建这个表单类：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We extend `ContentEntityForm`, which is a specialized form class for content
    entities. It itself extends `EntityForm`, which then subclasses the `FormBase`
    we've already encountered in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*. However, the former two give us a lot of functionalities
    needed to manage our entities without writing much code ourselves.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`ContentEntityForm`，这是一个专门用于内容实体的表单类。它本身扩展了`EntityForm`，而`EntityForm`又继承了我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中遇到的`FormBase`。然而，前两个类为我们提供了许多管理实体所需的功能，而无需我们编写太多代码。
- en: The only thing we actually want to do is override the `save()` method in order
    to write a message to the user informing them that the product has either been
    created or updated. We know what happened because the `EntityInterface::save()`
    method returns a specific constant to denote the type of operation that occurred.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要做的只是覆盖`save()`方法，以便向用户发送消息，告知他们产品已被创建或更新。我们知道发生了什么，因为`EntityInterface::save()`方法返回一个特定的常量来表示发生的操作类型。
- en: We also want to redirect to the canonical URL of the product entity when the
    save happens. This we do with a very handy method on the `FormStateInterface`
    object with which we can specify a route (and any necessary parameters), and it
    will make sure that when the form is submitted, the user will be redirected to
    that route. Neat, isn't it?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存发生时，我们还想重定向到产品实体的规范URL。我们通过`FormStateInterface`对象上的一个非常方便的方法来完成这个操作，我们可以指定一个路由（以及任何必要的参数），并且它将确保当表单提交时，用户将被重定向到该路由。这不是很酷吗？
- en: You can see we use the deprecated `drupal_set_message()` global function to
    print the message to the user. I did this on purpose to keep things short. However,
    as we saw in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, you should instead inject the `Messenger` service and use
    that. Do refer back to that chapter also for a recap on how to inject services
    if you are unsure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了已弃用的`drupal_set_message()`全局函数来向用户打印消息。我故意这样做是为了让事情变得简单。然而，正如我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建您的第一个模块”中看到的，您应该注入`Messenger`服务并使用它。如果您不确定如何注入服务，请参阅该章节以回顾如何注入服务。
- en: 'As I mentioned, for the delete operation, we just use the `ContentEntityDeleteForm`,
    which does all we need: it presents a confirmation form where we submit and trigger
    the delete operation. This is a typical flow for deleting resources in Drupal.
    As we will see a bit later, for configuration entities, there will be some methods
    we will need to write ourselves for this same process to happen.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我提到的，对于删除操作，我们只需使用`ContentEntityDeleteForm`，它就完成了我们所需的所有工作：它呈现一个确认表单，我们提交并触发删除操作。这是在Drupal中删除资源的典型流程。正如我们将在稍后看到，对于配置实体，我们将需要编写一些自己的方法来完成相同的过程。 '
- en: All our handlers are done now, and our product entity type is operational. However,
    in order to be able to work with it, let's create some links in the admin menu
    to be able to easily manage them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有处理程序都已完成，我们的产品实体类型现在是可操作的。然而，为了能够使用它，让我们在管理菜单中创建一些链接，以便能够轻松地管理它们。
- en: 'First, create the `products.links.menu.yml` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`products.links.menu.yml`文件：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This defines a menu link under the Structure link for the product list (the
    page built with our list builder handler).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个位于产品列表（使用我们的列表构建器处理程序构建的页面）结构链接下的菜单链接。
- en: 'Next, let''s create some local tasks (tabs) so that we get handy links on the
    product page to edit and delete the product entity. So, inside the `products.links.task.yml`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些本地任务（标签页），以便我们在产品页面上获得方便的链接来编辑和删除产品实体。因此，在`products.links.task.yml`文件中：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You remember this from [Chapter 5](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml),
    *Menus and Menu Links*, don't you? The base route is always the canonical route
    for the entity, which essentially groups the tabs together. Then, the routes we
    use for the other two tasks are the `edit_form` and `delete_form` links of the
    entity type. You can refer to the *links* section of the Entity type plugin annotation
    to understand where these come from. The reason we don't need to specify any parameters
    here (since those routes do require a product ID) is because the base route has
    that parameter in the URL already. So, the tasks will use that one. And this is
    very handy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得[第5章](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml)，“菜单和菜单链接”，不是吗？基本路由始终是实体的规范路由，这本质上将标签分组在一起。然后，我们用于其他两个任务的路由是实体类型的`edit_form`和`delete_form`链接。您可以参考实体类型插件注释中的*links*部分来了解这些链接的来源。我们之所以不需要在这里指定任何参数（因为这些路由确实需要产品ID），是因为基本路由已经在URL中包含了该参数。因此，任务将使用该参数。这非常方便。
- en: 'Finally, we also want an action link to create a new product entity, which
    will be on the product list page. So, inside the `products.links.action.yml` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想在产品列表页面上添加一个创建新产品实体的操作链接。因此，在`products.links.action.yml`文件中：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, none of this should be new, as we covered it in detail in [Chapter 5](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml),
    *Menus and Menu Links.* We are finally done.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些内容不应该陌生，因为我们已经在[第五章](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml)中详细介绍了，*菜单和菜单链接*。我们终于完成了。
- en: If the `products` module was enabled on your site before writing all the entity
    code, you will need to run the `drush entity-updates` command in order for all
    the necessary tables to be created in the database. Otherwise, installing the
    module will do that automatically. However, keep the first point in mind for when
    you add new content entity types and fields or even change existing fields on
    an entity type. The underlying storage might need to be changed to accommodate
    your modifications. Moreover, another thing to keep in mind is that, in some cases,
    changing fields that already have data in them will not be okay with Drupal and
    will prevent you from making those changes. So, you might need to delete existing
    entities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编写所有实体代码之前您的网站上启用了`products`模块，您需要运行`drush entity-updates`命令，以便在数据库中创建所有必要的表。否则，安装模块将自动完成此操作。然而，请注意，当您添加新的内容实体类型和字段或更改实体类型上的现有字段时，需要记住第一点。底层存储可能需要更改以适应您的修改。此外，还需要注意的是，在某些情况下，更改已包含数据的字段可能不符合Drupal的要求，并阻止您进行这些更改。因此，您可能需要删除现有实体。
- en: At the time of writing, the `entity-update` Drush command was being eliminated
    in favor of updating entities using update hooks. See the related change record
    on [Drupal.org](https://www.drupal.org/node/3034742). This means that the command
    might not work anymore when you try to use it. If that's the case, check out the
    change record for information as to which contrib module this command can be found
    in for use during development.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`entity-update` Drush命令正在被淘汰，转而使用更新钩子来更新实体。请参阅[Drupal.org](https://www.drupal.org/node/3034742)上的相关变更记录。这意味着当您尝试使用该命令时，它可能不再有效。如果是这种情况，请查看变更记录以获取有关在开发期间可以在哪个贡献模块中找到此命令的信息。
- en: 'Now that we''ve done that, we can go to `admin/structure/product` and take
    a look at our (empty) product entity list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这些，我们可以去`admin/structure/product`查看我们的（空）产品实体列表：
- en: '![](img/924991b6-82d9-42aa-b845-89f6a655e596.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/924991b6-82d9-42aa-b845-89f6a655e596.png)'
- en: 'We can now create new products, edit them, and finally, delete them. Remember,
    due to our field configuration, the manual product creation/edit does not permit
    the `remote_id` and `source` fields to be managed. For our purpose, we want those
    to be only programmatically available since any manual products will be considered
    as not needing that data. For example, if we want to make the source field show
    up as a form widget, all we have to do is change its base field definition to
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建新产品，编辑它们，最后，删除它们。记住，由于我们的字段配置，手动创建/编辑产品不允许管理`remote_id`和`source`字段。对于我们的目的，我们希望这些字段只能通过程序访问，因为任何手动创建的产品都将被视为不需要这些数据。例如，如果我们想使源字段以表单小部件的形式显示，我们只需要将其基本字段定义更改为以下内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, we'd need to clear the cache. This would make the form element for the
    source field show up, but the value would still not be displayed on the canonical
    page of the entity because we have not set any `view` display options. In other
    words, we have not chosen a formatter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要清除缓存。这将使源字段的表单元素显示出来，但值仍然不会在实体的规范页面上显示，因为我们没有设置任何`view`显示选项。换句话说，我们还没有选择一个格式化器。
- en: However, in our case, the product entity is ready to store data, and all the
    TypedData APIs we practised in the previous chapter with the Node entity type
    will work just as well with this one. So, we can now turn to writing our importer
    logic to get some remote products onto our website.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，产品实体已经准备好存储数据，我们在上一章中与节点实体类型一起练习的所有TypedData API都将与这个实体一样正常工作。因此，我们现在可以转向编写我们的导入逻辑，将一些远程产品导入到我们的网站上。
- en: Custom plugin type
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义插件类型
- en: Since pretty much the second page of this book you've been reading about how
    important plugins are and how widely they are used in Drupal 8\. I have backed
    that claim with references to "this or that" being a plugin in basically every
    chapter. However, I have not really explained how you can create your own custom
    plugin type. However, since our importer logic is a perfect candidate for plugins,
    I will do so here, and to exemplify the theory, we will implement an `Importer`
    plugin type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书的几乎第二页都在讲述插件的重要性以及它们在Drupal 8中的广泛使用。我通过在基本上每一章中引用“这个或那个”是插件来支持这个说法。然而，我并没有真正解释如何创建自己的自定义插件类型。然而，由于我们的导入逻辑是插件的完美候选者，我将在这里这样做，并且为了说明理论，我们将实现一个`Importer`插件类型。
- en: 'The very first thing a plugin type needs is a manager service. This is responsible
    for bringing together two critical aspects of plugins (but not only): discovery
    and factory (instantiation). For these two tasks, it delegates to specialized
    objects. The most common method of discovery is through annotations (`AnnotatedClassDiscovery`),
    and the most common factory is the container-aware one—`ContainerFactory`. So,
    essentially, the manager is the central player that finds and processes all the
    plugin definitions and instantiates plugins. Also, it does so with the help of
    those other guys.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 插件类型最需要的是管理服务。它负责将插件的两个关键方面（但不仅限于此）结合起来：发现和工厂（实例化）。对于这两个任务，它委托给专门的对象。最常见的方法是通过注解（`AnnotatedClassDiscovery`），最常见的工厂是容器感知的——`ContainerFactory`。所以，本质上，管理器是中央玩家，它找到并处理所有插件定义并实例化插件。此外，它还借助那些其他人的帮助来完成这些工作。
- en: Many plugin types in Drupal 8, since they follow the defaults I mentioned before,
    use the `DefaultPluginManager`, or should I say, they extend this class. It provides
    them with the annotated discovery and container-aware factory. So that is what
    we will do as well and see how simple it is to create a plugin type manager.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8中许多插件类型，因为它们遵循我之前提到的默认设置，使用`DefaultPluginManager`，或者说，它们扩展了这个类。它为它们提供了注解发现和容器感知的工厂。所以这就是我们将要做的，并且看看创建插件类型管理器有多简单。
- en: 'Typically, it lives in the `Plugin` namespace of the module, so ours can look
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它位于模块的`Plugin`命名空间中，所以我们的可以看起来像这样：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Aside from extending the `DefaultPluginManager`, we will need to override the
    constructor and re-call the parent constructor with some parameters specific to
    our plugins. This is the most important part, and in order, these are the following
    (omitting the ones that are simply passed through):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展`DefaultPluginManager`之外，我们还需要重写构造函数并使用一些特定于我们插件的参数重新调用父构造函数。这是最重要的部分，按照顺序，以下是这样（省略了那些只是传递的）：
- en: The relative namespace where plugins of this type will be found—in this case,
    in the `Plugin/Importer` folder
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型的插件将被找到的相对命名空间——在这个例子中，是在`Plugin/Importer`文件夹中
- en: The interface each plugin of this type needs to implement—in our case, the `Drupal\products\Plugin\ImporterInterface`
    (which we have to create)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型的每个插件都需要实现接口——在我们的例子中，是`Drupal\products\Plugin\ImporterInterface`（我们必须创建它）
- en: The `annotation` class used by our plugin type (the one whose class properties
    map to the possible annotation properties found in the DocBlock above the plugin
    class)—in our case, `Drupal\products\Annotation\Importer` (which we have to create)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们插件类型使用的`annotation`类（其类属性映射到在插件类上方的DocBlock中找到的可能注解属性）——在我们的例子中，是`Drupal\products\Annotation\Importer`（我们必须创建）
- en: In addition to calling the parent constructor with these options, we will need
    to provide the "alter" hook for the available definitions. This will make it possible
    for other modules to implement this hook and alter the found plugin definitions.
    The resulting hook in our case is `hook_products_importer_info_alter`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些选项调用父构造函数之外，我们还需要提供“alter”钩子，用于可用的定义。这将使其他模块能够实现此钩子并修改找到的插件定义。在我们的情况下，结果是`hook_products_importer_info_alter`。
- en: 'Lastly, we also provide a specific cache key for the backend responsible for
    caching the plugin definitions. This is for increased performance: as you should already
    know by now, creating a new plugin requires clearing the cache.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还为负责缓存插件定义的后端提供了一个特定的缓存键。这是为了提高性能：正如你现在应该已经知道的，创建一个新的插件需要清除缓存。
- en: 'That''s it with our manager. However, since this is a service, we will need
    to register it as such inside the `products.services.yml` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经理就到这里。然而，由于这是一个服务，我们还需要在`products.services.yml`文件中将其注册为服务：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we inherit the dependencies (arguments) from the `default_plugin_manager`
    service instead of duplicating them here again. If you remember from [Chapter
    3](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml), *Logging and Mailing*, this is
    a neat little trick in Drupal 8.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们继承自`default_plugin_manager`服务中的依赖（参数），而不是在这里再次复制它们。如果您还记得[第3章](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml)中的内容，*日志和邮件*，这是Drupal
    8中的一个巧妙的小技巧。
- en: 'Now, since we referenced some classes in the manager, we will need to create
    them. Let''s start with the annotation class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们在管理器中引用了一些类，我们需要创建它们。让我们从注解类开始：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class needs to extend `Drupal\Component\Annotation\Plugin`, which is the
    base class for annotations and already implements `AnnotationInterface`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类需要扩展`Drupal\Component\Annotation\Plugin`，这是注解的基类，并且已经实现了`AnnotationInterface`。
- en: For our purpose, we keep it simple. All we need is a plugin ID and a label.
    If we wanted to, we could add more properties to this class and describe them.
    It's a standard practice to do so because otherwise there is no clear way to know
    which properties a plugin annotation can contain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们保持简单。我们需要的只是一个插件ID和一个标签。如果我们愿意，我们可以向这个类添加更多属性并描述它们。这样做是一个标准实践，因为否则就没有明确的方式来知道插件注解可以包含哪些属性。
- en: 'Next, let''s also write the interface the plugins are required to implement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们也编写插件必须实现的接口：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, we keep it simple. For now, our importer will have only one method specific
    to it: `import()`. However, it will have other methods specific to plugins, which
    can be found in the `PluginInspectionInterface` we are extending. These are `getPluginId()`
    and `getPluginDefinition()` and are also quite important as the system expects
    to be able to get this info from the plugins.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们保持简单。目前，我们的导入器将只有一个特定的方法：`import()`。然而，它将会有其他特定的插件方法，这些方法可以在我们扩展的`PluginInspectionInterface`中找到。这些是`getPluginId()`和`getPluginDefinition()`，它们也非常重要，因为系统期望能够从插件中获取这些信息。
- en: Next, plugins of any type need to extend `PluginBase` because it contains a
    host of mandatory implemented methods (such as the ones I mentioned before). However,
    it is also a best practice for the module that introduces a plugin type to also
    provide a base plugin class that plugins can extend. Its goal is to extend `PluginBase`
    and also provide all the necessary logic needed by all the plugins of this type.
    For example, when we create a new block, we extend `BlockBase`, which, somewhere
    down the line, extends `PluginBase`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，任何类型的插件都需要扩展`PluginBase`，因为它包含了一系列必须实现的方法（例如我之前提到的那些）。然而，对于引入插件类型的模块来说，提供一个插件基类供插件扩展也是一个最佳实践。它的目标是扩展`PluginBase`，并提供所有此类插件所需的所有必要逻辑。例如，当我们创建一个新的块时，我们扩展`BlockBase`，而`BlockBase`在某个地方会扩展`PluginBase`。
- en: 'In our case, this base (abstract) class can look something like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个基类（抽象）可以看起来像这样：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We implement `ImporterInterface` (renamed to prevent collision) to require subclasses
    to have the `import()` method. However, we also make the plugins container aware
    and already inject some helpful services. One is the `EntityTypeManager` because
    we expect all importers to need it. The other is the Guzzle HTTP Client that we
    use in Drupal 8 to make PSR-7 requests to external resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现`ImporterInterface`（重命名以避免冲突）来要求子类必须有一个`import()`方法。然而，我们也使插件容器知道，并已经注入了一些有用的服务。一个是`EntityTypeManager`，因为我们预计所有导入器都需要它。另一个是我们用于Drupal
    8中向外部资源发起PSR-7请求的Guzzle HTTP客户端。
- en: Adding this here is a judgment call. We can imagine more than one plugin needing
    external requests, but if it turns out they don't, we should surely remove it
    and add it only in that specific plugin. The opposite also holds true. If in the
    third plugin implementation we identify another common service, we can remove
    it from the plugins and inject it here. All while watching out for backwards compatibility.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加它是一个判断性的选择。我们可以想象不止一个插件需要外部请求，但如果最终证明它们不需要，我们当然应该将其从插件中移除，并仅在特定插件中添加它。相反的情况也成立。如果在第三个插件实现中我们识别出另一个通用服务，我们可以将其从插件中移除，并在这里注入它。同时，我们还要注意向后兼容性。
- en: Before talking about those exceptions we're throwing in the constructor, it's
    important to know how the plugin manager creates a new instance of a plugin. It
    uses its `createInstance()` method, which takes a plugin ID as a first parameter
    and an optional array of plugin configuration as a second parameter. The relevant
    factory then passes that array of configuration to the plugin constructor itself
    as the second parameter. Oftentimes, this is empty. However, for our plugin type,
    we will need configuration to be passed to the plugin in the form of a configuration
    entity (which we have to create next). Without such an entity, we want the plugins
    to fail because they cannot work without the instructions found in this entity.
    So, in the constructor, we check whether `$configuration['config']` is an instance
    of `Drupal\products\Entity\ImporterInterface`, which will be the interface our
    configuration entity will implement. Otherwise, we throw the exception because
    this plugin cannot work without it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论我们在构造函数中抛出的那些异常之前，了解插件管理器如何创建插件的新实例是很重要的。它使用其`createInstance()`方法，该方法将插件ID作为第一个参数，将插件配置的可选数组作为第二个参数。相关的工厂然后将该配置数组传递给插件构造函数本身作为第二个参数。通常情况下，这是空的。然而，对于我们的插件类型，我们需要将配置以配置实体（我们接下来必须创建）的形式传递给插件。如果没有这样的实体，我们希望插件失败，因为它们没有这个实体中找到的说明就无法工作。因此，在构造函数中，我们检查`$configuration['config']`是否是`Drupal\products\Entity\ImporterInterface`的实例，这将是我们配置实体将要实现的接口。如果不是，我们抛出异常，因为此插件没有它无法工作。
- en: Our plugin type is complete for now. Obviously, we don't have any plugins yet,
    and before we create one, let's create the configuration entity type first.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了插件类型的创建。显然，我们还没有任何插件，在我们创建一个之前，让我们首先创建配置实体类型。
- en: Custom configuration entity type
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义配置实体类型
- en: 'If you remember `NodeType` from the previous chapter, you know the essentials
    of creating custom configuration entity types. So, let''s create our `Importer`
    type now. Like before, we start with the annotation part, which this time is a
    `ConfigEntityType`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章中的`NodeType`，你就知道创建自定义配置实体类型的基本要素。因此，让我们现在创建我们的`Importer`类型。像之前一样，我们从注解部分开始，这次是`ConfigEntityType`：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with the `Product` entity, we will need to create a list builder handler,
    as well as form handlers. In this case, though, we also need to create a form
    handler for the `delete` operation as we will soon see why. Finally, since we
    have a configuration entity, we also specify the `config_export` and `config_prefix`
    keys to be used for the exporting. If you remember from the previous chapter,
    the first one denotes the names of the fields that should be persisted (we'll
    see them in a minute), while the second denotes the prefix the configuration names
    should get when stored. One thing you'll note is that we don't have a canonical
    link because we don't really need one—our entities don't need a details page,
    hence no canonical link to it needs to be defined.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Product`实体一样，我们需要创建一个列表构建器处理程序，以及表单处理程序。然而，在这种情况下，我们还需要为`delete`操作创建一个表单处理程序，因为我们很快就会看到原因。最后，由于我们有一个配置实体，我们还指定了用于导出的`config_export`和`config_prefix`键。如果你还记得上一章，第一个表示应该持久化的字段名称（我们很快就会看到它们），而第二个表示配置名称在存储时应获得的名称前缀。你会注意到我们没有规范链接，因为我们实际上并不需要——我们的实体不需要详情页面，因此不需要定义指向它的规范链接。
- en: 'Now, it''s time to create the `ImporterInterface` that the entities implement.
    It is named the same as the plugin interface we created earlier, but it resides
    in a different namespace:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建实体实现所需的`ImporterInterface`了。它的名称与之前创建的插件接口相同，但它位于不同的命名空间中：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In these configuration entities, we want to store, for now, a URL to the resource
    where the products can be retrieved from, the ID of the importer plugin to use,
    whether we want existing products to be updated if they had already been imported,
    and the source of the products. For all these fields, we create some getter methods.
    You'll note that `getUrl()` needs to return a `Url` instance. Again, we create
    a well-defined interface for the public API of the entity type as we did with
    the product entity type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些配置实体中，我们目前想要存储的是可以从中检索产品的资源URL、要使用的导入器插件ID、是否希望更新已导入的现有产品，以及产品的来源。对于所有这些字段，我们创建了一些获取方法。你会注意到`getUrl()`需要返回一个`Url`实例。同样，我们为实体类型的公共API创建了一个定义良好的接口，就像我们为产品实体类型所做的那样。
- en: 'And this is what the `Importer` class body that implements this interface looks
    like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现此接口的`Importer`类体：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you remember from the previous chapter, defining fields on a configuration
    entity type is as simple as defining properties on the class itself. Moreover,
    you may recall the `config_export` key on the annotation, which lists which of
    these properties need to be exported and persisted. We omitted that because we
    will simply rely on the configuration schema (which we will create soon). Lastly,
    the interface methods are implemented next, and there is no rocket science involved
    in that. The `getUrl()`, as expected, will try to create an instance of `Url`
    from the value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章的内容，定义配置实体类型的字段就像在类本身上定义属性一样简单。此外，你可能还记得注解上的`config_export`键，它列出了哪些属性需要导出和持久化。我们省略了它，因为我们将简单地依赖于配置方案（我们很快就会创建）。最后，实现接口方法，这并不涉及任何火箭科学。正如预期的那样，`getUrl()`将尝试从值中创建一个`Url`实例。
- en: 'Let''s not forget the *use* statement for it at the top:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要忘记在顶部添加它的`use`语句：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we talked about the configuration schema, let''s define that as well.
    If you remember, it goes inside the `config/schema` folder of our module in a
    `*.schema.yml` file. This can be named after the module and contains the schema
    definitions of all configurations of the module. Alternatively, it can be named after
    the individual configuration entity type, so, in our case, `importer.schema.yml`
    (to keep things neatly organized):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们讨论了配置模式，让我们也定义一下。如果你记得，它位于我们模块的`config/schema`文件夹中，在一个`*.schema.yml`文件中。这可以以模块的名称命名，包含模块中所有配置的方案定义。或者，它可以以单个配置实体类型的名称命名，在我们的情况下是`importer.schema.yml`（以保持事情整洁有序）：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you recall, the wildcard is used to apply the schema to all configuration
    items that match the prefix. So, in our case, it will match all `importer` configuration
    entities. Next, we have the `config_entity` schema with a mapping of the fields
    we defined. Apart from the default fields each entity type comes with, we are
    using a `uri`, `string`, and `boolean` schema type (which under the hood maps
    to the corresponding `TypedData` data type plugins). This schema now helps the
    system understand our entities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，通配符用于将模式应用于所有匹配前缀的配置项。因此，在我们的情况下，它将匹配所有`importer`配置实体。接下来，我们有`config_entity`模式，它映射了我们定义的字段。除了每个实体类型都有的默认字段外，我们还使用了一个`uri`、`string`和`boolean`模式类型（在底层映射到相应的`TypedData`数据类型插件）。这个模式现在帮助系统理解我们的实体。
- en: 'Now, let''s go ahead and create the list builder handler that will take care
    of the admin entity listing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建列表处理程序，它将负责管理实体列表：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time we are extending the `ConfigEntityListBuilder`, which provides some
    functionalities specific to configuration entities. However, we are essentially
    doing the same as with the products listing—setting up the table header and the
    individual row data, nothing major. I recommend that you inspect `ConfigEntityListBuilder`
    and see what else you can do in the subclass.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们扩展了`ConfigEntityListBuilder`，它提供了一些特定于配置实体的功能。然而，我们基本上与产品列表做的是同样的事情——设置表头和单个行数据，没有太大的不同。我建议你检查`ConfigEntityListBuilder`，看看你可以在子类中做些什么。
- en: 'Now, we can finally take care of the form handler and start with the default
    create/edit form:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以处理表单处理程序，并开始使用默认的创建/编辑表单：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are directly extending `EntityForm` in this case because configuration entities
    don't have a specific form class like content entities do. For this reason, we
    also have to implement the form elements for all our fields inside the `form()`
    method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们直接扩展了`EntityForm`，因为配置实体没有像内容实体那样的特定表单类。因此，我们还需要在`form()`方法中实现所有字段的表单元素。
- en: But first things first. We know we want the configuration entity to select a
    plugin to use, so, for this reason, we inject the `ImporterManager` we created
    earlier. We will use it to get all the existing definitions. And we also inject
    the `Messenger` service to use it later to print a message to the user.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们知道我们希望配置实体选择一个插件来使用，因此，出于这个原因，我们注入了我们之前创建的`ImporterManager`。我们将使用它来获取所有现有的定义。我们还注入了`Messenger`服务，以便稍后将其用于向用户打印消息。
- en: Inside the `form()` method, we define all the form elements for the fields.
    We use a `textfield` for the label and a `machine_name` field for the ID of the
    entity. The latter is a special JavaScript-powered field that derives its value
    from a "source" field (which defaults to the field `label` if one is not specified).
    It is also disabled if we are editing the form and is using a dynamic callback
    to try to load an entity by the provided ID and will fail validation if it exists.
    This is useful to ensure that IDs do not repeat. Next, we have a `url` form element,
    which does some URL-specific validation and handling to ensure that a proper URL
    is added. Then, we create an array of `select` element options of all the available
    importer plugin definitions. For this, we use the plugin manager's `getDefinitions()`,
    from which we can get the IDs and labels. A plugin definition is an array that primarily
    contains the data found in the annotation and some other data processed and added
    by the manager (in our case, only defaults). At this stage, our plugins are not
    yet instantiated. And we use those options on the select list. Finally, we have
    the simple `checkbox` and `textfield` elements for the last two fields, as we
    want to store the `update_existing` field as a Boolean and the `source` as a string.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`form()`方法内部，我们定义了所有字段的表单元素。我们使用`textfield`来设置标签，使用`machine_name`字段来设置实体的ID。后者是一个特殊的由JavaScript驱动的字段，它从“源”字段（如果没有指定，则默认为`label`字段）获取其值。如果我们正在编辑表单，它也会被禁用，并使用动态回调尝试通过提供的ID加载实体，如果存在则验证失败。这有助于确保ID不会重复。接下来，我们有一个`url`表单元素，它执行一些URL特定的验证和处理，以确保添加了正确的URL。然后，我们创建一个包含所有可用导入插件定义的`select`元素选项数组。为此，我们使用插件管理器的`getDefinitions()`，从中我们可以获取ID和标签。插件定义主要包含在注释中找到的数据以及由管理器（在我们的情况下，只有默认值）处理和添加的一些其他数据。在这个阶段，我们的插件尚未实例化。然后，我们在选择列表中使用这些选项。最后，我们有简单的`checkbox`和`textfield`元素用于最后两个字段，因为我们想将`update_existing`字段存储为布尔值，将`source`字段存储为字符串。
- en: The `save()` method is pretty much like it was in the Product entity form; we
    are simply displaying a message and redirecting the user to the entity listing
    page (using the handy `toUrl()` method on the entity to build the URL). Since
    we named the form elements exactly the same as the fields, we don't need to do
    any mapping of the form values to the field names. That is taken care of.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法几乎和产品实体表单中的相同；我们只是显示一条消息并将用户重定向到实体列表页面（使用实体上的方便的`toUrl()`方法构建URL）。由于我们命名表单元素与字段完全相同，我们不需要对表单值到字段名称进行映射。这已经由系统处理了。'
- en: 'Let''s now write the delete form handler:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写删除表单处理器：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As I mentioned earlier, for configuration entities, we will need to implement
    this form handler ourselves. However, it''s not a big deal because we can extend
    `EntityConfirmFormBase` and just implement some simple methods:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，对于配置实体，我们需要自己实现这个表单处理器。然而，这并不是什么大问题，因为我们可以扩展`EntityConfirmFormBase`并仅实现一些简单的方法：
- en: In `getQuestion()` we return the string to be used as the question for the confirmation
    form.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getQuestion()`函数中，我们返回用于确认表单的问题字符串。
- en: In `getConfirmText()` we return the label of the delete button.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getConfirmText()`函数中，我们返回删除按钮的标签。
- en: In `getCancelUrl()` we provide the redirect URL for the user after either a
    cancellation or a successful delete.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getCancelUrl()`函数中，我们提供用户在取消或成功删除后的重定向URL。
- en: In `submitForm()` we delete the entity, print a success message, and redirect
    to the URL we set in the `getCancelUrl()`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`submitForm()`函数中，我们删除实体，打印成功消息，并重定向到我们在`getCancelUrl()`中设置的URL。
- en: 'And with this, we are done with our configuration entity type. The last thing
    we might want to do is create some menu links to be able to navigate to the relevant
    pages (the same as we did for the product entity type). For the entity list page,
    we can have this in our `products.links.menu.yml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们完成了我们的配置实体类型。我们可能还想做的最后一件事是创建一些菜单链接，以便能够导航到相关页面（和我们对产品实体类型所做的一样）。对于实体列表页面，我们可以在我们的`products.links.menu.yml`文件中这样写：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There''s nothing new here. We can also create the action link to add a new
    entity inside the `products.links.action.yml` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新内容。我们也可以在`products.links.action.yml`文件中创建添加新实体的操作链接：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We do the same thing here as we did with the products. However, we won't create
    local tasks because we don't have a canonical route for the configuration entities,
    so we don't really need it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的和之前对产品所做的相同。然而，我们不会创建本地任务，因为我们没有配置实体的规范路由，所以我们实际上不需要它。
- en: 'Now, if we clear our cache and go to `admin/structure/importer`, we should
    see the empty importer entity listing:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们清除我们的缓存并转到`admin/structure/importer`，我们应该看到空的导入实体列表：
- en: '![](img/e3cd04d8-1769-4e92-b783-d7fe15157f9b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3cd04d8-1769-4e92-b783-d7fe15157f9b.png)'
- en: The Importer plugin
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入插件
- en: 'Alright, since all of our setup is in place, we can now go ahead and create
    our first importer plugin. As we defined it in the manager, these need to go in
    the `Plugin/Importer` namespace of modules. So, let''s start with a simple `JsonImporter`
    which will use a remote URL resource to import products. This is an example JSON
    file that will be processed by this plugin, just for testing purposes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然所有设置都已经到位，我们现在可以继续创建我们的第一个导入插件。正如我们在管理器中定义的那样，这些需要放在模块的`Plugin/Importer`命名空间中。所以，让我们从一个简单的`JsonImporter`开始，它将使用远程URL资源导入产品。这是一个示例JSON文件，它将由这个插件处理，仅用于测试目的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I know, VCR right? We have an ID, a name, and a product number. This is all
    totally made-up information about products just to illustrate the process. So,
    let''s create our `JsonImporter`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，VCR对吧？我们有一个ID，一个名称和一个产品编号。这些都是关于产品的完全虚构的信息，只是为了说明这个过程。所以，让我们创建我们的`JsonImporter`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can immediately spot the plugin annotation where we specify an ID and a
    label. Next, by extending `ImporterBase`, we inherit the dependent services and
    ensure that the required interface is implemented. Speaking of which, we basically
    just have to implement the `import()` method. So, let''s break down what we are
    doing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到插件注解，我们指定了一个ID和一个标签。接下来，通过扩展`ImporterBase`，我们继承了依赖的服务并确保实现了所需的接口。说到这一点，我们基本上只需要实现`import()`方法。所以，让我们分解我们在做什么：
- en: Inside the `getData()` method, we retrieve the product information from the
    remote resource. We do so by getting the URL from the `Importer` configuration
    entity and using Guzzle to make a request to that URL. We expect that to be JSON,
    so we just decode it as such. Of course, error handling is virtually nonexistent
    in this example, and that is not good.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getData()`方法内部，我们从远程资源检索产品信息。我们通过从`Importer`配置实体获取URL并使用Guzzle向该URL发出请求来做到这一点。我们期望它是JSON格式，所以我们只需将其解码为这种格式。当然，在这个例子中，错误处理几乎不存在，这是不好的。
- en: We loop through the resulting product data and call the `persistProduct()` method
    on each item. In there, we first check whether we already have the product entity.
    We do so using the simple `loadByProperties()` method on the product entity storage
    and try to find products that have the specific source and remote ID. If one doesn't
    exist, we create it. This should all be familiar from the previous chapter when
    we looked at manipulating entities. If the product already exists, we first check
    whether according to configuration, we can update it and only do so if that allows
    us to. The `loadByProperties()` method always returns an array of entities, but
    since we only expect to have a single product with the same remote ID and source
    combination, we simply `reset()` this array to get to that one entity. Then, we
    just set the name and product number on the entity.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历生成的产品数据，并对每个项目调用`persistProduct()`方法。在那里，我们首先检查我们是否已经有了产品实体。我们通过在产品实体存储上使用简单的`loadByProperties()`方法来做到这一点，并尝试找到具有特定来源和远程ID的产品。如果不存在，我们就创建它。这一切都应该在上一章中熟悉，当时我们讨论了实体的操作。如果产品已经存在，我们首先检查根据配置，我们是否可以更新它，并且只有在这样做允许的情况下才这样做。`loadByProperties()`方法始终返回一个实体数组，但由于我们只期望有一个具有相同远程ID和来源组合的单个产品，我们只需简单地`reset()`这个数组以获取那个实体。然后，我们只需在实体上设置名称和产品编号。
- en: As you can see, instead of using the Entity API/Typed Data `set()` method to
    update the entity field values, we use our own interface methods. I find that
    this is much cleaner, more modern, and an IDE-friendly way because everything
    is very explicit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不是使用实体API/类型数据`set()`方法来更新实体字段值，而是使用我们自己的接口方法。我发现这要干净得多，更现代，并且是IDE友好的方式，因为一切都是非常明确的。
- en: One thing you might notice is the error handling in this import process or more
    precisely, a lack thereof. This is because I kept things simple for the purpose
    of focusing on the current topic. Normally, you would want to maybe throw and
    catch some exceptions and definitely log some messages (both error and success).
    You know how to do the latter from [Chapter 3](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml),
    *Logging and Mailing*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，在这个导入过程中存在错误处理，或者更确切地说，是缺乏错误处理。这是因为我为了专注于当前主题，故意保持了简单。通常，您可能想要抛出并捕获一些异常，并且肯定要记录一些消息（无论是错误还是成功）。您知道如何从[第3章](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml)，*日志和邮件*中做后者。
- en: 'And that is pretty much it. We can now create our first importer entity and
    make it use this importer plugin (after clearing the cache of course):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。我们现在可以创建我们的第一个导入实体，并使其使用这个导入插件（当然是在清除缓存之后）：
- en: '![](img/3b4e1b8f-82ef-4454-8dc5-f9efd3cb2511.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b4e1b8f-82ef-4454-8dc5-f9efd3cb2511.png)'
- en: 'The URL in the previous screenshot is just a local URL where the example JSON
    file is found, and we can see the only plugin available to choose, as well as
    the other entity fields we created form elements for. By saving this new entity,
    we can make use of it programmatically (assuming that the `products.json` file
    referenced in the URL exists):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图中的URL只是一个本地URL，其中包含了示例JSON文件的位置，我们可以看到可选择的唯一插件，以及其他我们为表单元素创建的实体字段。通过保存这个新实体，我们可以程序化地使用它（假设URL中引用的`products.json`文件存在）：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We first load the importer entity by ID. Then, we use the `ImporterManager`
    service to create a new instance of a plugin using the `createInstance()` method.
    Only one parameter is required for it—the ID of the plugin—but as I said earlier,
    we want to pass the configuration entity to it because it depends on it. So we
    do just that. Then, we call the `import()` method on the plugin. After running
    this code, the product entity listing will show some shiny new products.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过ID加载导入实体。然后，我们使用`ImporterManager`服务通过`createInstance()`方法创建一个插件的新实例。只需要一个参数——插件的ID——但正如我之前所说的，我们希望传递配置实体给它，因为它依赖于它。所以我们就这样做了。然后，我们在插件上调用`import()`方法。运行此代码后，产品实体列表将显示一些闪亮的新产品。
- en: 'Let''s, however, improve things a bit. Since the configuration entities and
    plugins are so tightly connected, let''s use the plugin manager to do this entire
    thing rather than having to first load an entity and request the plugin from it.
    In other words, let''s add a method to the plugin manager where we can pass the
    configuration entity ID, and it returns an instance of the relevant plugin; something
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们改进一下。由于配置实体和插件紧密相连，让我们使用插件管理器来完成整个操作，而不是首先加载一个实体，然后从它请求插件。换句话说，让我们在插件管理器中添加一个方法，我们可以传递配置实体ID，它返回相关插件的实例；类似于这样：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we essentially do the same thing as before, but we return `NULL` if there
    is no configuration entity found. You can choose to throw an exception if you
    want instead. However, as you may have correctly noticed, we also need to inject
    the `EntityTypeManager` into this class, so our constructor changes as well to
    take it as a last parameter and set it as a class property. You should be able
    to do that on your own. But we also need to alter the service definition for the
    plugin manager to add the `EntityTypeManager` as a dependency:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们基本上与之前做的是同一件事，但如果找不到配置实体，我们返回`NULL`。您可以选择抛出异常，如果您愿意的话。然而，正如您可能正确注意到的，我们还需要将`EntityTypeManager`注入到这个类中，所以我们的构造函数也改变了，将其作为最后一个参数传递，并将其设置为类属性。您应该能够自己做到这一点。但我们还需要修改插件管理器的服务定义，以添加`EntityTypeManager`作为依赖项：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we keep the `parent` inheritance key so that all the parent
    arguments are taken in. On top, however, we add our own regular `arguments` key
    which will append arguments to the ones that come from the parent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们保留了`parent`继承键，以便接受所有父参数。然而，我们还在上面添加了我们自己的常规`arguments`键，它将附加来自父级的参数。
- en: 'And with this we have simplified things for the client code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们简化了客户端代码：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All we have to interact with is the plugin manager, and we can directly run
    the import. This is in some ways better because our configuration entities are
    not something we designed for being used by anyone else. They are simple configuration
    storage used by our importer plugins.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要与插件管理器交互，就可以直接运行导入。这在某些方面是更好的，因为我们的配置实体不是我们为其他人使用而设计的。它们是简单的配置存储，由我们的导入插件使用。
- en: Content entity bundles
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容实体包
- en: We have written a neat little piece of functionality. There are still improvements
    that we can, and will make, but those are for later chapters when we cover other
    topics that we will need to learn about. Now, however, let's take a step back
    to our content entity type and extend our products a bit by enabling bundles.
    We want to have more than one type of product that can be imported. And this will
    be a bundle which will be an option to choose when creating an Importer configuration.
    However, first, let's make the product entity type "bundleable".
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个小巧的功能。我们还可以，并将会在后面的章节中做出改进，但那些改进将在我们覆盖其他需要了解的主题时进行。现在，然而，让我们退一步回到我们的内容实体类型，通过启用捆绑包来扩展我们的产品。我们希望有不止一种类型的产品可以被导入。这将是一个捆绑包，它将在创建导入器配置时作为一个选项来选择。然而，首先，让我们将产品实体类型设置为“可捆绑”。
- en: 'We start by adjusting our Product entity plugin annotation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调整我们的产品实体插件注解：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We add a `bundle_label` for our bundle, an entity key for it that will map to
    the `type` field, the `bundle_entity_type` reference to the configuration entity
    type that will act as a bundle for the products, and a `field_ui_base_route`.
    This latter option is something we could have added before but was not necessary.
    Now, we can (and should) add it because we need a route where we can configure
    our product entities from the point of view of managing UI fields and the bundles.
    We'll see these a bit later on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的捆绑包添加一个 `bundle_label`，一个实体键，它将映射到 `type` 字段，`bundle_entity_type` 引用将指向作为产品捆绑包的配置实体类型，以及
    `field_ui_base_route`。这个后者选项是我们之前可以添加的，但不是必需的。现在，我们可以（并且应该）添加它，因为我们需要一个路由，我们可以从管理
    UI 字段和捆绑包的角度来配置我们的产品实体。我们将在稍后看到这些。
- en: 'Moreover, we also need to change something about the links. First, we will
    need to alter the `add-form` link:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要对链接做一些更改。首先，我们需要修改 `add-form` 链接：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will now take a product type in the URL to know which bundle we are creating.
    If you remember from the previous chapter when we were creating entities programmatically,
    the bundle is a required value from the beginning if the entity type has bundles.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将通过 URL 中的产品类型来识别我们正在创建哪个捆绑包。如果你还记得上一章中我们通过编程创建实体时的情况，如果实体类型有捆绑包，那么捆绑包是一个从一开始就必需的值。
- en: 'Then, we add a new link, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个新的链接，如下所示：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will go to the initial `add-form` path but will list options of available
    bundles to select for creating a new product. Clicking on one of those will take
    us to the `add-form` link.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导航到初始的 `add-form` 路径，但会列出可用于创建新产品的可用捆绑包选项。点击其中一个选项将带我们到 `add-form` 链接。
- en: 'Since we made these changes, we also need to make a quick alteration to the
    product entity action link to use `add-page` instead of the `add-form` route:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们进行了这些更改，我们还需要快速修改产品实体动作链接，使用 `add-page` 路由而不是 `add-form` 路由：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is required because, on the product entity list page (collection URL),
    we don't have a product type in context, so we cannot build a path to `add-form`;
    nor would it be logical to do so as we don't know what type of product the user
    wants to create. As a quick bonus, if there is only one bundle, Drupal will redirect
    the user to the `add-form` link of that particular bundle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在产品实体列表页面（集合 URL）上，我们没有上下文中的产品类型，因此我们无法构建到 `add-form` 的路径；而且这样做也不合逻辑，因为我们不知道用户想要创建哪种类型的产品。作为快速奖励，如果只有一个捆绑包，Drupal
    将将用户重定向到该特定捆绑包的 `add-form` 链接。
- en: 'The good thing is that since we specified an entity key for the bundle, we
    don''t have to define the field that will reference the bundle configuration entity.
    It will be done for us by the parent `ContentEntityType::baseFieldDefinitions()`.
    So, what is left to do is to create the `ProductType` configuration entity type
    that will serve as product bundles. We already know more or less how this works.
    Inside our `Entity` namespace we start our class like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好事是，由于我们为捆绑包指定了一个实体键，我们不必定义将引用捆绑配置实体的字段。这将由父 `ContentEntityType::baseFieldDefinitions()`
    方法为我们完成。所以，剩下要做的就是创建一个 `ProductType` 配置实体类型，它将作为产品捆绑包使用。我们或多或少已经知道它是如何工作的。在我们的
    `Entity` 命名空间中，我们这样开始我们的类：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Much of this is exactly the same as when we created the importer configuration
    entity type. The only difference is that we have the `bundle_of` key in the annotation, which
    denotes the content entity type this serves as a bundle for. Also, we don''t really
    need any other fields. Because of that, the `ProductTypeInterface` can look as
    simple as this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分与创建导入配置实体类型时完全相同。唯一的区别是我们在注解中有了 `bundle_of` 键，它表示这个内容实体类型作为捆绑所服务的内容类型。而且，我们实际上不需要其他字段。正因为如此，`ProductTypeInterface`
    可以看起来像这样简单：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s quickly take a look at the individual handlers, which will seem very
    familiar by now as well. The list builder looks almost the same as for the Importer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下单个处理器，现在它们看起来也应该非常熟悉。列表构建器看起来几乎与导入器相同：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The create/edit form handler also looks very similar, albeit much simpler due
    to not having many fields on the configuration entity type:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建/编辑表单处理器看起来也非常相似，但由于配置实体类型上没有很多字段，所以它要简单得多：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Again, in this form, I used the global `drupal_set_message()` function to save
    some space. You should instead inject the `Messenger` service to print messages
    to the user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在这个表单中，我使用了全局的 `drupal_set_message()` 函数来节省空间。你应该注入 `Messenger` 服务来向用户打印消息。
- en: 'Since we created the form for saving field values, we mustn''t forget about
    the configuration schema for this entity type:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了保存字段值的表单，所以我们不能忘记此实体类型的配置模式：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we should also quickly write the form handler for deleting product types:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们也应该快速编写删除产品类型的表单处理器：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You should already be familiar with what we're doing here as it's the same as
    with the Importer entities.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉我们在这里所做的事情，因为它与导入实体类型相同。
- en: 'Finally, we should create the menu link to the `ProductType` entity list URL,
    just like we did for the other two entity types inside `products.links.menu.yml`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该创建指向 `ProductType` 实体列表 URL 的菜单链接，就像我们在 `products.links.menu.yml` 内部为其他两个实体类型所做的那样：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And the same for the action link used to create a new product bundle, inside
    `products.links.action.yml`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于创建新产品捆绑所使用的操作链接，在 `products.links.action.yml` 内部：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we are done. We can clear the caches and run the `drush entity-updates`
    command because Drupal needs to create the `type` field on the product entities.
    Once that is done, we can go the UI at `admin/structure/product_type` and see
    our changes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了。我们可以清除缓存并运行 `drush entity-updates` 命令，因为 Drupal 需要在产品实体上创建 `type`
    字段。一旦完成，我们就可以在 `admin/structure/product_type` 的 UI 中查看我们的更改。
- en: 'We now have a Product type entity listing where we can create Product bundles.
    Moreover, we also have some extra operations since this entity type is used as
    a bundle: we can manage fields and displays (both for viewing and for the forms)
    for each individual bundle:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个产品类型实体列表，我们可以在这里创建产品捆绑。此外，我们还有一些额外的操作，因为此实体类型用作捆绑：我们可以为每个单独的捆绑管理字段和显示（包括查看和表单）：
- en: '![](img/a8a44fc0-8d3c-4f9b-875d-8d4c5a8e5ea7.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8a44fc0-8d3c-4f9b-875d-8d4c5a8e5ea7.png)'
- en: Managing fields and displays would have been possible before creating the bundle
    had we provided the `field_ui_base_route` to the Product entity type and created
    a menu link for it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向产品实体类型提供了 `field_ui_base_route` 并为其创建了一个菜单链接，那么在创建捆绑之前管理字段和显示是可能的。
- en: Now we can add fields to our individual bundles and can distinguish between
    our product types—for example, we can have a bundle for goods and one for services.
    We can well imagine that the two types might require a different set of fields
    and/or they are being pulled from different external resources. So, let's just
    update our importing logic to allow the selection of a bundle because now it is
    actually mandatory to specify one when attempting to create a Product.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向我们的单个捆绑添加字段，并区分我们的产品类型——例如，我们可以有一个商品捆绑和一个服务捆绑。我们可以想象这两种类型可能需要不同的字段集，或者它们可能来自不同的外部资源。所以，让我们更新我们的导入逻辑，允许选择一个捆绑，因为现在在尝试创建产品时实际上必须指定一个。
- en: 'We start by adding a new field to the Importer entity type. First, for the
    interface change:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向导入实体类型添加一个新字段。首先，对于接口更改：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we will take a look at the implementation in the class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将查看类中的实现：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we must include the new field in the configuration schema:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在配置模式中包含新的字段：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last thing we will need to do on the Importer entity type is add the form
    element for choosing a bundle:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入实体类型上，我们最后需要做的是添加选择捆绑的表单元素：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we use an `entity_autocomplete` form element which gives us the option
    to use an autocomplete text field to look up an existing entity and select one
    of the found ones. The ID of the selected entity will then be submitted in the
    form as the value. This field definition requires choosing a `#target_type`, which
    is the entity type we want to autocomplete. One thing to note is that, even if
    the submitted value is only the ID (in our case, a string), the `#default_value`
    requires the full entity object itself (or an array of entity objects). This is
    because the field shows more information about the referenced entity than just
    the ID.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个`entity_autocomplete`表单元素，它为我们提供了使用自动完成文本字段查找现有实体并选择找到的其中一个的选项。所选实体的ID将被作为值提交到表单中。这个字段定义需要选择一个`#target_type`，这是我们想要自动完成的实体类型。有一点需要注意，即使提交的值只有ID（在我们的例子中是一个字符串），`#default_value`也需要完整的实体对象本身（或实体对象的数组）。这是因为该字段显示的关于引用实体的信息比仅仅ID更多。
- en: In order to load the referenced entity for the default value, we need to inject
    the `EntityTypeManger`. You should already know how to do this injection, so I'm
    not going show it again here. We simply tack on the dependency to the `Messenger`
    service which is already being injected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载默认值所引用的实体，我们需要注入`EntityTypeManger`。你应该已经知道如何进行这种注入，所以在这里我不会再次展示。我们只需将依赖项附加到已经注入的`Messenger`服务上。
- en: 'That should be it for the Importer entity type alterations. The one last thing
    we need to do is handle the bundle inside the `JsonImporter` plugin we wrote.
    However, this is as simple as adding the `type` value when creating the product
    entity:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导入器实体类型修改来说，这就足够了。我们最后需要做的是处理我们编写的`JsonImporter`插件内部的包。然而，这就像在创建产品实体时添加`type`值一样简单：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And there we have it. Running the import code will now create products of the
    bundle specified in the Importer configuration.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就到这里。运行导入代码现在将创建在导入器配置中指定的包的产品。
- en: Drush command
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drush命令
- en: So, our logic is in place, but we will need to create a handy way we can trigger
    the imports. One option is to create an administration form where we go and press
    a button. However, a more typical example is a command that can be added to the
    crontab and that can be run at specific intervals automatically. So that's what
    we are going to do now, and we will do so using Drush.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的逻辑已经到位，但我们需要创建一种方便的方式来触发导入。一个选项是创建一个管理表单，我们可以在那里按按钮。然而，一个更典型的例子是可以在crontab中添加的命令，它可以在特定的时间间隔自动运行。所以这就是我们现在要做的，我们将使用Drush来完成。
- en: The Drush command we are going to write will take an optional parameter for
    the ID of the Importer configuration entity we want to process. This will allow
    the use of the command for more than just one importer. Alternatively, passing
    no options will process each importer (in case this is something we want to do
    later on). One thing to note is that we won't focus on performance in this example.
    This means the command will work just fine for smaller sets of data (as big as
    one request can process) but it would be better to use a queue and/or batch processing
    for larger sets. Also, we will have a chapter dedicated to these subsystems later
    on, but, for now, let's get on with our example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的Drush命令将接受一个可选参数，用于处理我们想要处理的导入器配置实体ID。这将允许命令用于不止一个导入器。作为替代，不传递任何选项将处理每个导入器（如果这是我们稍后想要做的）。有一点需要注意，我们不会在这个例子中关注性能。这意味着命令对于较小的数据集（大到可以处理一个请求的大小）将运行得很好，但对于较大的数据集，最好使用队列和/或批量处理。此外，我们将在稍后的章节中专门介绍这些子系统，但现在，让我们继续我们的例子。
- en: Before we actually write our new Drush command, let's make some alterations
    to our logic as they will make sense in the context of what we want to do.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际编写新的Drush命令之前，让我们对我们的逻辑做一些修改，因为它们将在我们想要做的上下文中变得有意义。
- en: 'First, let''s add a getter method to the Importer plugins to retrieve the corresponding
    configuration entities. We start with the interface like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们给导入器插件添加一个获取器方法来检索相应的配置实体。我们以这样的接口开始：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, to the `ImporterBase` class, we can add the implementation (it will be
    the same for all individual plugin instances):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以向`ImporterBase`类添加实现（它将适用于所有单个插件实例）：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, it's not rocket science.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这并不是什么高难度的科学。
- en: 'Second, let''s add a `createInstanceFromAllConfigs()` method to the `ImporterManager`
    which will return an array of plugin instances for each existing Importer configuration
    entity:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们向`ImporterManager`添加一个`createInstanceFromAllConfigs()`方法，该方法将为每个现有的`Importer`配置实体返回一个插件实例数组：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we use the `loadMultiple()` method on the entity storage handler, which,
    if we use without any arguments, will load all existing entities. If we get any
    results, we use our existing `createInstanceFromConfig()` method to instantiate
    the plugins based on each configuration entity. That's it; we can now go ahead
    and create our Drush command.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用实体存储处理器的`loadMultiple()`方法，如果我们不带任何参数使用它，它将加载所有现有实体。如果我们得到任何结果，我们使用现有的`createInstanceFromConfig()`方法根据每个配置实体实例化插件。就是这样；我们现在可以继续创建我们的Drush命令。
- en: With newer versions of Drush (9 and up), commands are no longer declared in
    procedural code. So let's see how we can create our command using OOP. There are
    a few steps we need to take.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drush的新版本（9及以上）中，命令不再在过程代码中声明。那么，让我们看看我们如何使用OOP创建我们的命令。我们需要采取几个步骤。
- en: 'We need to create a *composer.json* file for our module. It can look very barebones:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们模块创建一个`*composer.json*`文件。它可以看起来非常简单：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Apart from the normal boilerplate package and autoloader information, we have
    an `extras` section where we specify a YAML file where Drush can find the service
    definition that contains the commands. And since the latest version of Drush at
    the time of writing is 9, we specify that as well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的包和自动加载信息之外，我们还有一个`extras`部分，其中我们指定一个YAML文件，Drush可以在其中找到包含命令的服务定义。由于撰写本文时Drush的最新版本是9，我们也指定了这一点。
- en: With Drush 9, this is not technically needed. Simply having the `drush.services.yml`
    file in the module root will be enough for Drush to load it. However, with Drush
    10 this becomes mandatory, so you might as well use the correct approach already.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drush 9中，这实际上不是必需的。只需在模块根目录中有一个`drush.services.yml`文件就足够Drush加载它了。然而，在Drush
    10中，这变得强制性的，所以你最好现在就使用正确的方法。
- en: 'Now that we have referenced the Drush-specific services file, let''s go ahead
    and create it. It looks exactly like our other services files we''re used to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经引用了Drush特定的服务文件，让我们继续创建它。它看起来就像我们习惯的其他服务文件一样：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, we have another tagged service ( `drush.command`) whose class
    should contain some Drush commands. And I already know we will need the plugin
    manager so we are already adding it as an argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还有一个标记的服务（`drush.command`），其类应该包含一些Drush命令。而且我已经知道我们需要插件管理器，所以我们已经将其作为参数添加。
- en: 'So, let''s see how we can start the command class which should go in the *Commands*
    namespace of our module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们如何启动命令类，它应该放在我们模块的`*Commands*`命名空间中：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We are extending the `DrushCommands` base class to inherit all the things necessary
    or useful for Drush commands. And we have a single method that maps to a single
    command. What makes this an actual command is the annotation at the top which
    describes all the things related to it:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展`DrushCommands`基类以继承所有对Drush命令必要或有用的东西。我们有一个映射到单个命令的单个方法。使这成为一个实际命令的是顶部注释，它描述了与之相关的所有事情：
- en: The `@command` is the most important and specifies the actual Drush command
    name.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@command`是最重要的，它指定了实际的Drush命令名称。'
- en: The `@alias` specifies other aliases for the command.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@alias`指定了命令的其他别名。'
- en: The `@param` is simple documentation of what input arguments the command takes.
    In our case, we don't have any mandatory arguments. We do have optional arguments
    though. If we wanted mandatory arguments, we could have simply added more method
    parameters without defaults.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@param`是对命令输入参数的简单文档。在我们的例子中，我们没有强制性的参数。但我们确实有可选参数。如果我们想要强制性的参数，我们可以在没有默认值的情况下简单地添加更多方法参数。'
- en: The `@option` specifies the name of the option that can be passed; this is found
    inside the `$options` array parameter as one of its keys. And since it's mandatory,
    we use a constant to denote that.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@option`指定了可以传递的选项名称；这是在`$options`数组参数中的一个键。由于它是强制性的，我们使用一个常量来表示它。'
- en: 'With this definition, we can already use the command. After we clear the cache
    we can run the command like in the following examples:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，我们目前已经可以使用这个命令了。在我们清除缓存后，我们可以像以下示例那样运行命令：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Obviously, nothing will happen if we run these because the callback method
    is empty. So let''s flesh it out:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们运行这些代码，因为回调方法为空，所以不会发生任何事。所以让我们完善它：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: What is happening here? First, we check for the importer ID, if one was passed
    with the command. If yes, we simply use our importer manager to create an instance
    of the corresponding plugin and delegate to a helper method to run the import
    on that plugin. Otherwise we use the built-in Drush logger to log an error. On
    the contrary, if no importer ID has been passed, we use our new `createInstanceFromAllConfigs()`
    method on the plugin manager to create plugin instances from all existing configuration
    entities. We then loop through each and, again, delegate to our helper method
    to run them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，我们检查导入器ID，如果命令中传递了一个ID，我们就简单地使用我们的导入器管理器来创建相应插件的实例，并将任务委托给辅助方法在该插件上运行导入。如果没有传递导入器ID，我们就使用内置的Drush记录器记录错误。相反，如果没有传递导入器ID，我们使用插件管理器上的新`createInstanceFromAllConfigs()`方法从所有现有的配置实体创建插件实例。然后我们遍历每个实例，再次委托给我们的辅助方法来运行它们。
- en: 'Before we conclude, let''s see that helper method as well:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，让我们也看看这个辅助方法：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This method is mostly used for logging the result of the plugin import: a different
    message depending on the success of the process. And in doing so, we use the actual
    Importer label rather than the ID that was passed. Makes it nicer to read.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法主要用于记录插件导入的结果：根据过程的成功与否显示不同的消息。在这个过程中，我们使用实际的导入器标签而不是传递的ID，这样读起来更方便。
- en: Now if we clear the caches, we can run the command again (with or without an
    importer ID) and see that it correctly imports the products and prints the message
    to the terminal. Better yet, we can now add it to our crontab and have it run
    at specific intervals, once a day, for example.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们清除缓存，我们可以再次运行命令（带有或没有导入器ID）并看到它正确地导入了产品，并将消息打印到终端。更好的是，我们现在可以将其添加到我们的crontab中，使其在特定的时间间隔运行，例如每天一次。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got to implement some fun stuff. We created our very own
    content and configuration entity types as well as a custom plugin type to handle
    our logic.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们实现了有趣的东西。我们创建了我们的内容实体类型和配置实体类型，以及一个自定义插件类型来处理我们的逻辑。
- en: What we built was a Product entity type that holds some product-like data in
    various types of fields. We even created a bundle configuration entity type so
    that we can have multiple types of products with the possibility of different
    fields per bundle—a great data model.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个产品实体类型，它包含一些类似产品的数据，并在各种类型的字段中。我们甚至创建了一个捆绑配置实体类型，这样我们就可以有多个类型的产品，并且每个捆绑包都有可能有不同的字段——一个很好的数据模型。
- en: We wanted to be able to import products from all sorts of external resources.
    For this reason, we created the Importer plugin type which is responsible for
    doing the actual imports—a great functional model. However, these only work based
    on a set of configurations, which we represented via a configuration entity type.
    These can then be created in the UI and exported into YAML files like any other
    configuration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够从各种外部资源导入产品。因此，我们创建了导入器插件类型，它负责执行实际的导入——一个很好的功能模型。然而，这些插件仅基于一组配置工作，我们通过配置实体类型来表示这些配置。然后可以在UI中创建它们，并像其他任何配置一样导出为YAML文件。
- en: Finally, to use the importers, we created a Drush command, which can process
    either a single Importer or all the existing ones. This can be used inside a crontab
    for automatic imports.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用导入器，我们创建了一个Drush命令，它可以处理单个导入器或所有现有的导入器。这可以用于crontab中的自动导入。
- en: There are still some shortcomings in the way we constructed the importing functionality.
    For example, we added the URL field on the Importer configuration entity as if
    all imports need to happen from an external resource. What if we want an import
    to be from a CSV file? The URL field would be superfluous, and we'd need a file
    upload field on the configuration entity. This very much points to the differences
    between generic Importer configuration values and the plugin-specific ones. In
    future chapters, we'll come back to our module and make some adjustments in this
    respect.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建导入功能的方式上还有一些不足之处。例如，我们在导入器配置实体上添加了URL字段，好像所有的导入都需要从一个外部资源发生。如果我们想从CSV文件导入呢？URL字段就变得多余了，我们需要在配置实体上添加一个文件上传字段。这非常指向通用导入器配置值和插件特定值之间的差异。在未来的章节中，我们将回到我们的模块，并在这个方面做一些调整。
- en: In the next chapter, we will look at the Database API and how we can directly
    interact with the underlying storage engine.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据库API以及我们如何直接与底层存储引擎交互。
