- en: Chapter 12. RESTful Web Services in Drupal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：Drupal 中的 RESTful 网络服务
- en: '*One of the major new developer features of Drupal 8 is built-in support for
    REST. In this chapter, we will explore and configure built-in support for REST.
    Then we will extend it by installing the RESTful module. Finally, we will develop
    a custom Recipe AngularJS app that will consume the REST API of our recipe website.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Drupal 8 中的一个主要新开发者特性是内置对 REST 的支持。在本章中，我们将探索和配置内置的 REST 支持。然后我们将通过安装 RESTful
    模块来扩展它。最后，我们将开发一个自定义的 Recipe AngularJS 应用程序，该应用程序将消费我们食谱网站的 REST API。*'
- en: 'In this chapter, we will learn these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Introduction to web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网服务简介
- en: Introduction to REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 简介
- en: What is Headless Drupal?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是无头 Drupal？
- en: When and why to decouple Drupal?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及为什么要解耦 Drupal？
- en: RESTful web services in Drupal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal 中的 RESTful 网络服务
- en: How to create RESTful APIs in Drupal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Drupal 中创建 RESTful API
- en: Creating a basic Angular website that will consume the REST API of our recipe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的 Angular 网站，该网站将消费我们食谱的 REST API
- en: Introduction to web services
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网服务简介
- en: 'A web service can be defined as a communication bridge between two applications
    over a network. The W3C defines a web service generally as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务可以被定义为网络中两个应用程序之间的通信桥梁。W3C 通常将网络服务定义为：
- en: '*"A software system designed to support interoperable machine-to-machine interaction
    over a network."*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个设计用于支持网络中可互操作机器间交互的软件系统。"*'
- en: Web services innovation speaks to a vital route for organizations to correspond
    with one another and with customers also. Not at all like customary customer/server
    models, for example, a web server or web page framework, web administrations don't
    furnish the client with a GUI. Rather, they offer business rationale, information,
    and procedures through an automatic interface over a system. The applications
    interface with one another, not with the clients. Engineers can then add the web
    administration to a GUI (for example, a web page or an executable system), to
    offer particular usefulness to clients.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务创新是组织之间以及与客户沟通的重要途径。与传统的客户/服务器模型不同，例如网络服务器或网页框架，网络服务不向用户提供图形用户界面。相反，它们通过网络上的自动接口提供业务逻辑、数据和流程。应用程序相互连接，而不是与客户连接。工程师可以将网络服务添加到
    GUI（例如网页或可执行系统），以向用户提供特定功能。
- en: Let's look into the example that we will be following in this chapter. Our Drupal
    website holds recipe contents, and they have data about different recipes. We
    want other applications and websites to be able to use these contents and data
    to show in their respective applications. Now, as they would like to show the
    data according to their needs, they will try to get the raw values of the data
    and display them as per their requirements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本章中我们将要遵循的示例。我们的 Drupal 网站包含食谱内容，它们包含有关不同食谱的数据。我们希望其他应用程序和网站能够使用这些内容和数据，并在它们各自的应用程序中显示。现在，由于他们希望根据需要显示数据，他们将尝试获取数据的原始值，并按照他们的要求显示。
- en: In doing so, we need to take care of the authentication of the applications
    trying to fetch data from our Drupal application so that there is no third-party
    attack on our data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们需要注意尝试从我们的 Drupal 应用程序获取数据的应用程序的认证，以确保我们的数据没有受到第三方攻击。
- en: The whole scenario of providing the data and other parties consuming it is achieved
    using web services, which acts as a bridge between our Drupal application and
    the outer world.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提供数据和消费它的整个场景是通过网络服务实现的，它作为我们的 Drupal 应用程序和外部世界之间的桥梁。
- en: Numerous associations utilize various programming frameworks for administration.
    Distinctive programming frameworks regularly need to trade information with one
    another, and a web service is a strategy for correspondence that permits two product
    frameworks to trade this information over the Web. The product framework that
    demands information is known as a **Service Requester**, which is an Angular web
    page in this chapter, though the product framework that would prepare the solicitation
    and give the information is known as a service provider, which is Drupal in our
    case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织使用不同的编程框架进行管理。不同的编程框架通常需要相互交换信息，而网络服务是实现两个软件系统通过互联网交换这种信息的通信策略。需要信息的产品框架被称为**服务请求者**，在本章中是
    Angular 网页，而准备请求并提供信息的产品框架被称为服务提供者，在我们的例子中是 Drupal。
- en: In a nutshell, web services make it possible for outside applications and devices
    to communicate with our application (for this situation, our Drupal) to execute
    **CRUD** operations (short for **Create**, **Read**, **Update**, and **Delete**).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，网络服务使外部应用程序和设备能够与我们的应用程序（在这种情况下，我们的Drupal）通信，以执行**CRUD**操作（即**创建**、**读取**、**更新**和**删除**）。
- en: Introduction to REST
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST简介
- en: '**REST** is the acronym for **Representational State Transfer**, which is one
    of the most popular ways of creating web services.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**是**表示性状态转移**的缩写，这是创建网络服务最受欢迎的方式之一。'
- en: REST is one of the architectural designs for service-oriented architecture,
    which uses simple HTTP calls to interact with machines for all CRUD operations.
    REST has risen in the last couple of years alone as a dominating web services
    design model, dislodging most of the SOAP- and WSDL-based services, because of
    its simplicity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: REST是面向服务架构的架构设计之一，它使用简单的HTTP调用与机器进行所有CRUD操作。仅在过去几年中，REST因其简洁性而成为主导的网络服务设计模型，取代了大多数基于SOAP和WSDL的服务。
- en: 'The four basic design principles of REST are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: REST的四个基本设计原则如下：
- en: '**Use HTTP methods explicitly**: REST follows pure HTTP methods and encourages
    developers to utilize it clearly, which is steady with the protocol definition.
    This kind of basic REST design theory establishes a one-to-one mapping between
    CRUD functions and HTTP methods, matching to this mapping:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式使用HTTP方法**：REST遵循纯HTTP方法，并鼓励开发者明确使用它，这与协议定义一致。这种基本的REST设计理论在CRUD函数和HTTP方法之间建立了一对一的映射，匹配以下映射：'
- en: '`POST`: Create a resource'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建资源'
- en: '`GET`: Retrieve a resource'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：检索资源'
- en: '`PUT`: Update a resource'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新资源'
- en: '`DELETE`: Delete a resource'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除资源'
- en: '**Be stateless**: A stateless web service creates a response that links to
    another page in the set and lets the client perform what it needs to in order
    to maintain this value around. This kind of facet of RESTful web services design
    can be divided into two units of tasks:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：无状态网络服务创建一个响应，该响应链接到集合中的另一页，并允许客户端执行所需操作以维护此值。这种RESTful网络服务设计的特点可以分为两个任务单元：'
- en: '**Server**: This generates responses that incorporate links to other assets,
    allowing applications to get around between related resources. The server also
    includes Cache-Control and Last-Modified systems to determine what data to cache
    to reduce the load on the server.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：这生成包含链接到其他资产的响应，允许应用程序在相关资源之间导航。服务器还包括Cache-Control和Last-Modified系统，以确定要缓存哪些数据以减少服务器负载。'
- en: '**Client**: This uses the Cache-Control and Last-Modified systems to determine
    whether or not to keep a local copy and cache the resource.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这使用Cache-Control和Last-Modified系统来确定是否保留本地副本并缓存资源。'
- en: This kind of collaboration between the client app and service is vital to being
    stateless in RESTful web services. It boosts performance simply by saving bandwidth
    and reducing the server-side application state.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端应用程序与服务之间的这种协作对于RESTful网络服务的无状态性至关重要。它通过节省带宽和减少服务器端应用程序状态来提高性能。
- en: '![Introduction to REST](img/4659_12_01.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![REST简介](img/4659_12_01.jpg)'
- en: '**Expose directory structure-like URLs**: Another RESTful web service attribute
    is all about URLs. REST web service URLs need to be intuitive to the point where
    they are simple to guess. Think of a URL as a sort of self-documenting interface
    that requires very little, if any, explanation or perhaps reference for any developer
    to understand what it takes into account also to obtain related resources. For
    example, in our recipe services, we will have URIs in a structure like this:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴露类似目录结构的URL**：另一个RESTful网络服务的属性完全关乎URL。RESTful网络服务的URL需要直观到简单易猜的程度。将URL视为一种自我文档化的接口，它需要非常少的，如果有的话，解释或参考，以便任何开发者都能理解它所考虑的内容以及如何获取相关资源。例如，在我们的食谱服务中，我们将有如下结构的URI：'
- en: '`http://www.headless.dev/api/recipes/snacks/{recipe_name}`, which exposes the
    details of a particular recipe'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://www.headless.dev/api/recipes/snacks/{recipe_name}`，它公开了特定食谱的详细信息'
- en: '`http://www.headless.dev/api/recipes/{recipe_type}`, which gives the recipes
    associated with the recipe type'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://www.headless.dev/api/recipes/{recipe_type}`，它提供了与食谱类型相关的食谱'
- en: URIs should also be static so that when the resource changes or the implementation
    of the service changes, the link stays the same
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI也应该保持静态，这样当资源发生变化或服务的实现发生变化时，链接保持不变。
- en: '**Transfer XML, JavaScript Object Notation (JSON), or both**: A representational
    format is necessary for clients to consume the web service and display them on
    their presentation layer. The very last set of constraints that goes to a RESTful
    World Wide Web service design has to do with the structure in the data that the
    application and service exchange in the request/response payload or in the HTTP
    body. This is exactly where it really pays to keep things simple, human-readable,
    and connected. To provide client applications with the capability to request a
    particular article''s type that''s perfect to get them, construct your services
    in order that it makes using the built-in HTTP Recognize header, where the benefit
    from the header is a MIME type. Some prevalent MIME types utilized by RESTful
    services are shown here:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输 XML、JavaScript 对象表示法（JSON）或两者**：客户端需要一种表示格式来消费 Web 服务并在其表示层上显示它们。在 RESTful
    互联网服务设计中，最后一组约束与应用程序和服务在请求/响应有效负载或 HTTP 主体中交换的数据结构有关。这正是保持简单、可读性和关联性真正有益的地方。为了提供客户端应用程序请求特定文章类型的能力，以便它们能够得到完美的结果，请按照以下顺序构建您的服务：使用内置的
    HTTP Recognize 标头，其中标头的优势是 MIME 类型。这里展示了 RESTful 服务中使用的某些常见 MIME 类型：'
- en: '| MIME type | Content type |'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| MIME 类型 | 内容类型 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **JSON** | `application/json` |'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **JSON** | `application/json` |'
- en: '| **XML** | `application/xml` |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **XML** | `application/xml` |'
- en: '| **XHTML** | `application/xhtml+xml` |'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **XHTML** | `application/xhtml+xml` |'
- en: Headless Drupal
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头 Drupal
- en: The term "Headless Drupal" was coined to refer to the decoupling of the backend
    and frontend of a Drupal application. In Headless Drupal, a visitor to the website
    will not interact with Drupal directly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “无头 Drupal”这个术语被用来指代 Drupal 应用程序后端和前端之间的解耦。在无头 Drupal 中，网站访客不会直接与 Drupal 交互。
- en: 'From the website visitor''s point of view, the user is not directly connecting
    to Drupal but to a frontend JavaScript framework such as KnockoutJS or AngularJS.
    So, the website visitor does not see a generated Drupal theme (the head), this
    is not used: *headless*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从网站访客的角度来看，用户并不是直接连接到 Drupal，而是连接到一个前端 JavaScript 框架，例如 KnockoutJS 或 AngularJS。因此，网站访客看不到生成的
    Drupal 主题（即头部），这不被使用：*无头*。
- en: In this case, Drupal is only used as a backend content management system, which
    is read by a frontend JavaScript framework, a mobile app or another third-party
    application. So, the Drupal backend is exactly as you know it, but the frontend
    is entirely non-Drupal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Drupal 仅用作后端内容管理系统，由前端 JavaScript 框架、移动应用或其他第三方应用程序读取。因此，Drupal 后端正如您所知，但前端完全是非
    Drupal 的。
- en: Data exchange almost always takes place through JSON.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据交换几乎总是通过 JSON 进行。
- en: 'A manifesto about the future of Drupal has been laid with four goals:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Drupal 未来的一份宣言已经制定，包含四个目标：
- en: We want Drupal to be the *preferred* backend content management system for designers
    and frontend developers.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望 Drupal 成为设计师和前端开发者的*首选*后端内容管理系统。
- en: We believe that Drupal's main strengths lie in the power and flexibility of
    its backend; its primary value to users is its ability to architect and display
    complex content models.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们相信 Drupal 的主要优势在于其后端的力量和灵活性；其对用户的主要价值在于其构建和显示复杂内容模型的能力。
- en: We believe that client-side frontend frameworks are the future of the Web.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们相信客户端前端框架是 Web 的未来。
- en: It is critically important for Drupal to be service-oriented first—not HTML-oriented
    first—or risk becoming irrelevant.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Drupal 来说，首先应该是面向服务的——而不是面向 HTML 的——否则可能会变得无关紧要。
- en: 'A diagrammatical representation of a Headless Drupal site explains a lot that
    is built by Pantheon:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一张无头 Drupal 网站的示意图可以解释 Pantheon 构建的大量内容：
- en: '![Headless Drupal](img/4659_12_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![无头 Drupal](img/4659_12_02.jpg)'
- en: Headless Drupal will be served with the web services concept using the REST
    server to create APIs, which will be consumed by other applications or a single
    application to serve on the frontend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无头 Drupal 将通过使用 REST 服务器创建 API 来实现 Web 服务概念，这些 API 将被其他应用程序或单个应用程序消费，以在前端提供服务。
- en: Building a Headless site prior to Drupal 8 was possible using modules such as
    services and RESTWS, but Drupal 8 comes packed with REST APIs in the core, which
    serves the purpose well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 之前，可以使用 services 和 RESTWS 等模块构建无头网站，但 Drupal 8 内置了 REST API，这很好地满足了这一目的。
- en: When to decouple Drupal or when to use Headless Drupal
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时解耦 Drupal 或何时使用无头 Drupal
- en: As discussed, Headless Drupal will be decoupling the backend architecture and
    frontend architecture so that the frontend has the flexibility to display the
    content as per the requirements. But when should you use this method? We use it
    especially when Drupal has a strong theming layer of its own.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，无头Drupal将解耦后端架构和前端架构，这样前端就可以根据需求灵活地显示内容。但何时应该使用这种方法？我们特别在Drupal拥有强大的自身主题层时使用它。
- en: 'Let''s look at some of the pros and cons of using Headless Drupal:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用无头Drupal的一些优缺点：
- en: '**Pros**:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Clean APIs for all as it is uniform and can be used by any application to represent
    data.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有人提供干净的API，因为它是一致的，任何应用程序都可以用来表示数据。
- en: Upgrading the frontend will require any changes in the backend and similarly
    upgrading the backend will not touch the frontend. However, you will need to be
    extremely careful while designing the content APIs.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级前端将需要后端的所有更改，同样，升级后端也不会影响前端。然而，在设计内容API时需要格外小心。
- en: Less reliance of Drupal expertise as the frontend is detached from Drupal.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于前端与Drupal分离，对Drupal专业知识的依赖性减少。
- en: '**Cons**:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: A decoupled structure's engineering is more mind-boggling to comprehend and
    troubleshoot. Making sense of why something is broken is very difficult to debug.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦结构的工程更难以理解和调试。弄清楚为什么某些东西出了问题是非常困难的。
- en: Drupal's out-of-the-box functionalities need to be built from scratch. For example,
    the Facebook plugin, which provides Facebook access and login, is strong and stable.
    But to use in a decoupled environment, the whole functionality needs to be rebuilt.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal的即用功能需要从头开始构建。例如，Facebook插件，它提供Facebook访问和登录功能，功能强大且稳定。但在解耦环境中使用时，整个功能需要重新构建。
- en: The minimum team size required for efficient development is larger as the backend
    team is separated from the frontend.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于后端团队与前端团队分离，高效开发所需的最小团队规模更大。
- en: So why is Headless Drupal making us happy?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么无头Drupal让我们感到高兴呢？
- en: The Drupal installation is easier to maintain
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal的安装更容易维护
- en: The scalability of the system becomes easier
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的可扩展性变得更容易
- en: It becomes easier to work with and for different teams
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不同团队一起工作和为团队工作变得更加容易
- en: The performance is improved
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能得到提升
- en: It makes the project future-proof
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使项目具有未来保障
- en: Since the initiation of Drupal, it has grown from just being a blogging platform
    to a strong content management system, and the concept of Headless Drupal just
    strengthens its capabilities of managing contents. But you need to have a clear
    understanding of the project before jumping into decoupling Drupal. Though it
    looks tempting and has great advantages, it also has downsides.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自Drupal启动以来，它已经从仅仅是一个博客平台发展到成为一个强大的内容管理系统，无头Drupal的概念进一步加强了其内容管理能力。但在跳入解耦Drupal之前，你需要对项目有一个清晰的理解。尽管它看起来很有吸引力，并且具有很大的优势，但它也有缺点。
- en: RESTful web services in Drupal
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal中的RESTful Web服务
- en: As discussed previously, prior to Drupal 8, RESTful web services could be implemented
    in Drupal 7 using the Services module or RESTWS module, which (using the REST
    server) can be used to build powerful Headless Drupal websites. But with the evolution
    of Drupal 8, this functionality has been attached to the core of the Drupal 8
    default bundle, along with other contributed features and modules that are pushed
    to the core, such as Views, Link, WYSIWYG editors, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Drupal 8之前，可以使用Services模块或RESTWS模块在Drupal 7中实现RESTful Web服务。这些模块（使用REST服务器）可以用来构建强大的无头Drupal网站。但随着Drupal
    8的发展，这一功能已被附加到Drupal 8默认捆绑包的核心中，以及其他推送到核心的贡献特性、模块，如Views、Link、WYSIWYG编辑器等。
- en: 'Drupal 8 achieves the full functionality to set a basic web services environment
    to provide APIs using four modules in the core. They are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8通过核心中的四个模块实现了设置基本Web服务环境以提供API的完整功能。它们如下：
- en: '**RESTful web services (REST)**: This exposes entities and other resources
    via a RESTful web API. It depends on the Serialization module for serialization
    of data that is sent to and from the API.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful Web服务 (REST)**: 这通过RESTful Web API公开实体和其他资源。它依赖于Serialization模块来序列化发送到和从API发送的数据。'
- en: '**Serialization**: This provides a service for serialization of data to and
    from formats such as JSON and XML.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serialization**: 这提供了一种将数据序列化到JSON和XML等格式以及从这些格式中反序列化的服务。'
- en: '**Hypertext Application Language (HAL)**: This serializes entities using Hypertext
    Application Language. Drupal core currently uses this format, which adds two keywords:
    `_link` for linked relation and `_embedded` for embeded media.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本应用语言（HAL）**：使用超文本应用语言序列化实体。Drupal核心目前使用此格式，增加了两个关键字：`_link`用于链接关系，`_embedded`用于嵌入媒体。'
- en: '**HTTP Basic Authentication (basic_auth)**: This module implements basic user
    authentication using the HTTP Basic Authentication provider, which uses the username
    and password for authentication to make API calls.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP基本认证（basic_auth）**：此模块通过HTTP基本认证提供者实现基本用户认证，使用用户名和密码进行认证以进行API调用。'
- en: RESTful APIs in Drupal
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Drupal中的RESTful API
- en: Creating RESTful APIs in Drupal is a fairly easy task, now that the whole power
    of web services has been moved to the core. To create the APIs, we will be using
    the Recipe content type that we have built for this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal中创建RESTful API是一个相对简单的工作，因为整个Web服务的力量已经移至核心。为了创建API，我们将使用为这本书构建的食谱内容类型。
- en: 'We will go through creating three basic APIs; these will give us the following
    information:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个基本API；这些将提供以下信息：
- en: Get all the recipe types
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有食谱类型
- en: Get all the recipes under a recipe type
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取特定食谱类型下的所有食谱
- en: Time for action – getting all the recipe types
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 – 获取所有食谱类型
- en: 'This is the list of recipe types I have in my local development server running
    in Vagrant (`http://www.headless.dev`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我本地Vagrant（`http://www.headless.dev`）开发服务器上运行的食谱类型列表：
- en: '![Time for action – getting all the recipe types](img/4659_12_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![执行时间 – 获取所有食谱类型](img/4659_12_03.jpg)'
- en: 'We will create an API URL structured as `http://www.headless.dev/recipes`,
    which will give the list of recipes in my site. Let''s get started:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个API URL，结构为`http://www.headless.dev/recipes`，这将给出我网站上的食谱列表。让我们开始吧：
- en: We need to enable the Web Services module from the modules page.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从模块页面启用Web服务模块。
- en: Click on **Manage** in the administration menu bar and then click on **Extend**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击管理菜单栏中的**管理**，然后点击**扩展**。
- en: Once you are on the **Modules** page, search for **RESTful Web Services** and
    **Serialization**. Enable both these modules:![Time for action – getting all the
    recipe types](img/4659_12_04.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进入**模块**页面，搜索**RESTful Web服务**和**序列化**。启用这两个模块：![执行时间 – 获取所有食谱类型](img/4659_12_04.jpg)
- en: Next, we will need to create a REST export views for our recipe types. Views
    now comes in the core of Drupal 8, which uses the REST export mode to create web
    services APIs.![Time for action – getting all the recipe types](img/4659_12_05.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的食谱类型创建REST导出视图。视图现在是Drupal 8的核心，它使用REST导出模式创建Web服务API。![执行时间 – 获取所有食谱类型](img/4659_12_05.jpg)
- en: Then click on **Views**:![Time for action – getting all the recipe types](img/4659_12_06.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**视图**：![执行时间 – 获取所有食谱类型](img/4659_12_06.jpg)
- en: You will be greeted by the **Views** landing page, where you can manage, configure,
    and add new Views. Drupal 8 uses Views extensively to display different data and
    contents on the site. The **Web Services** module however does not provide any
    views by default.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到**视图**页面，在这里你可以管理、配置和添加新的视图。Drupal 8广泛使用视图来在网站上显示不同的数据和内容。然而，**Web服务**模块默认不提供任何视图。
- en: Moving forward, click on **Add new view** in the **Views** landing page:![Time
    for action – getting all the recipe types](img/4659_12_07.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续操作，点击**视图**页面的**添加新视图**：![执行时间 – 获取所有食谱类型](img/4659_12_07.jpg)
- en: In the views configuration page, fill out the form as given in the next screenshot.
    We have selected **Show** as **Taxonomy terms** and **of type** as **Recipe Type**
    to create a web service API to show the Recipe Types in the site.![Time for action
    – getting all the recipe types](img/4659_12_08.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图配置页面，按照下一张截图所示填写表单。我们已选择**显示**为**分类术语**，以及**类型**为**食谱类型**，以创建一个用于显示网站中食谱类型的Web服务API。![执行时间
    – 获取所有食谱类型](img/4659_12_08.jpg)
- en: After filling out the form, we need to select the REST export display to export
    or expose the API by a URL.![Time for action – getting all the recipe types](img/4659_12_09.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写完表单后，我们需要选择REST导出显示，通过URL导出或公开API。![执行时间 – 获取所有食谱类型](img/4659_12_09.jpg)
- en: Click on **Save and edit** to configure the view.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存并编辑**以配置视图。
- en: Now, by default, the view will give full entity information about the taxonomy
    terms.![Time for action – getting all the recipe types](img/4659_12_10.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，默认情况下，视图将提供关于分类术语的完整实体信息。![执行时间 – 获取所有食谱类型](img/4659_12_10.jpg)
- en: The result of the views preview is very messy and hard to read. It is shown
    as a flat list.![Time for action – getting all the recipe types](img/4659_12_11.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预览视图的结果非常混乱，难以阅读。它以一个平铺的列表形式显示。![行动时间 – 获取所有食谱类型](img/4659_12_11.jpg)
- en: To make it more readable, you need to install a Google plugin called **JSONview**,
    which renders the JSON object in a more readable manner.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使其更易于阅读，您需要安装一个名为 **JSONview** 的谷歌插件，该插件以更易读的方式渲染JSON对象。
- en: 'Once the plugin is installed, you can view the response in the browser by hitting
    this URL: `http://www.headless.dev/api/recipes`.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦安装了插件，您可以通过点击此URL在浏览器中查看响应：`http://www.headless.dev/api/recipes`。
- en: As it gives all information about the terms, we need to filter out unnecessary
    fields from the response and make it more readable and consumable.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于它提供了所有关于术语的信息，我们需要从响应中过滤掉不必要的字段，使其更易于阅读和消费。
- en: We will be exposing the title, tid, and description about the recipe type to
    be consumed. In the **Views** settings, under **FORMAT**, select the **Show**
    property and select **Fields** instead of **Entity**.![Time for action – getting
    all the recipe types](img/4659_12_12.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将公开食谱类型的标题、tid和描述以供消费。在 **Views** 设置中，在 **FORMAT** 下选择 **Show** 属性，并选择 **Fields**
    而不是 **Entity**。![行动时间 – 获取所有食谱类型](img/4659_12_12.jpg)
- en: Select **Fields** from the options provided so that you can add fields to your
    REST export:![Time for action – getting all the recipe types](img/4659_12_13.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供的选项中选择 **Fields**，以便您可以将字段添加到您的REST导出中：![行动时间 – 获取所有食谱类型](img/4659_12_13.jpg)
- en: Select **Apply**, and in the next screen, it will ask if you need alias the
    field label. But it is fine to keep it as name.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Apply**，在下一屏幕上，它会询问您是否需要为字段标签创建别名。但保留为 name 即可。
- en: Next, we need to add the rest of the fields under the **FIELDS** settings. Select
    **Add** under **FIELDS** and add in the `tid` and `description` fields:![Time
    for action – getting all the recipe types](img/4659_12_14.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 **FIELDS** 设置下添加剩余的字段。在 **FIELDS** 下选择 **Add** 并添加 `tid` 和 `description`
    字段：![行动时间 – 获取所有食谱类型](img/4659_12_14.jpg)
- en: 'Select the **Taxonomy term: Term ID** field to get the term ID in your REST
    export.![Time for action – getting all the recipe types](img/4659_12_15.jpg)'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择 **Taxonomy term: Term ID** 字段以在您的REST导出中获取术语ID。![行动时间 – 获取所有食谱类型](img/4659_12_15.jpg)'
- en: 'And then select the **Taxonomy term: Description** field from the fields list:![Time
    for action – getting all the recipe types](img/4659_12_16.jpg)'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后从字段列表中选择 **Taxonomy term: Description** 字段：![行动时间 – 获取所有食谱类型](img/4659_12_16.jpg)'
- en: Apply the settings and save the fields as default unless you need to something
    more special with the fields.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用设置并保存字段为默认值，除非您需要为字段做更特殊的事情。
- en: Next, we will rearrange the fields so that the order of the fields is tid, name,
    and description.![Time for action – getting all the recipe types](img/4659_12_17.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重新排列字段，以便字段的顺序为 tid、name 和 description。![行动时间 – 获取所有食谱类型](img/4659_12_17.jpg)
- en: Now if we visit `http://www.headless.dev/api/recipes` in our browser, we will
    get a more precise and easy-to-read JSON object ready to be consumed by any app.![Time
    for action – getting all the recipe types](img/4659_12_18.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们访问浏览器中的 `http://www.headless.dev/api/recipes`，我们将得到一个更精确且易于阅读的JSON对象，可以由任何应用程序消费。![行动时间
    – 获取所有食谱类型](img/4659_12_18.jpg)
- en: '*What just happened?*'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created an API using the Drupal REST service module and REST views export,
    which gives us a JSON of the available Recipe types in our Drupal site, ready
    to be consumed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Drupal REST服务模块和REST视图导出创建了一个API，它为我们提供了Drupal网站上可用的食谱类型的JSON，供消费使用。
- en: Time for action – creating an API to get all the recipes under a recipe type
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建一个API以获取所有食谱类型下的食谱
- en: 'Now we will create our next API, which is for exposing all the recipes under
    a recipe type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的下一个API，该API用于公开所有食谱类型下的食谱：
- en: We will have a new view created in the same manner, but instead of selecting
    Taxonomy terms, we will be choosing contents of all type recipes.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_19.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以相同的方式创建一个新的视图，但我们将选择所有类型食谱的内容而不是选择分类术语。![行动时间 – 创建一个API以获取所有食谱类型下的食谱](img/4659_12_19.jpg)
- en: In the REST export settings, give the URL as `api/recipes/%`. The `%` sign acts
    as the wildcard, which will recipe type tid as the argument.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_20.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REST导出设置中，将URL设置为`api/recipes/%`。百分号`%`符号作为通配符，将食谱类型tid作为参数。![执行时间 – 创建一个API以获取特定食谱类型下的所有食谱](img/4659_12_20.jpg)
- en: 'In the views settings page, we configure the view just like we did it for the
    recipe type. The fields that we will be showing are:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图设置页面，我们配置视图就像我们为食谱类型所做的那样。我们将显示的字段是：
- en: '**Node ID**'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点ID**'
- en: '**Title**'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**'
- en: '**Publishing status**'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布状态**'
- en: '**Recipe Type**'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食谱类型**'
- en: '**Recipe Image**'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食谱图片**'
- en: '**PrepTime**'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备时间**'
- en: '**CookTime**'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烹饪时间**'
- en: '**TotalTime**'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总时间**'
- en: '**Body**'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**'
- en: '**Ingredients**'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成分**'
- en: '**Instructions**'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**说明**'
- en: '**Yield**'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产量**'
- en: '**Review**'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评论**'
- en: To get the recipes associated with a particular recipe, we will use the fields
    Recipe Type in the recipe content, which is referenced to the Recipe Type vocabulary.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取与特定食谱相关的食谱，我们将使用食谱内容中的食谱类型字段，该字段引用了食谱类型词汇表。
- en: In the advanced section of the views configuration page, under **CONTEXTUAL
    FILTERS**, click on **Add** to add in the Recipe Type tid as an argument:![Time
    for action – creating an API to get all the recipes under a recipe type](img/4659_12_21.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图配置页面的高级部分，在**上下文过滤器**下，点击**添加**以将食谱类型tid作为参数添加：![执行时间 – 创建一个API以获取特定食谱类型下的所有食谱](img/4659_12_21.jpg)
- en: In the contextual filter form, search for `recipe type` and select the field
    to configure it:![Time for action – creating an API to get all the recipes under
    a recipe type](img/4659_12_22.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文过滤器形式中，搜索`食谱类型`并选择要配置的字段：![执行时间 – 创建一个API以获取特定食谱类型下的所有食谱](img/4659_12_22.jpg)
- en: In the contextual filter configuration form, select the **Provide default value**
    radio button and choose **Taxonomy term ID from URL** from the argument **Type**
    dropdown:![Time for action – creating an API to get all the recipes under a recipe
    type](img/4659_12_23.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文过滤器配置表单中，选择**提供默认值**单选按钮，并从**类型**下拉菜单中选择**从URL获取分类术语ID**作为参数：![执行时间 – 创建一个API以获取特定食谱类型下的所有食谱](img/4659_12_23.jpg)
- en: The JSON object will give the indexes as the machine name of the fields. So
    we will alias the fields to make the indexes' names relevant.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_24.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON对象将给出索引作为字段的机器名。因此，我们将字段别名化以使索引名称相关。![执行时间 – 创建一个API以获取特定食谱类型下的所有食谱](img/4659_12_24.jpg)
- en: 'Now if you check the result in the browser by hitting the URL `http://www.headless.dev/api/recipes/6`,
    you will get the JSON object of the nodes associated with term ID `6`, which is
    for the Snack recipe type:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你通过点击URL `http://www.headless.dev/api/recipes/6` 在浏览器中检查结果，你将获得与术语ID `6`
    相关的节点JSON对象，该ID对应于Snack食谱类型：
- en: '[PRE0]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*What just happened?*'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created an API that that gives us all recipe types and another API that gives
    out all the recipe types under a particular recipe type. Now we will see how we
    can use AngularJS to consume this REST exports JSON output and display on a web
    page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个提供所有食谱类型的API，以及一个提供特定食谱类型下所有食谱类型的API。现在我们将看看我们如何使用AngularJS来消费这个REST导出的JSON输出并在网页上显示。
- en: Time for action – consuming RESTful web services using AngularJS
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 – 使用AngularJS消费RESTful Web服务
- en: 'Now that we have an API that is providing us the services with the JSON data
    of the recipes, recipe types, and individual recipes, let us look at how we can
    use this data to display in a page using HTML and AngularJS:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个API，它提供了包含食谱、食谱类型和单个食谱的JSON数据的JSON数据服务，让我们看看我们如何使用HTML和AngularJS在页面上显示这些数据：
- en: Since it is targeted towards a Drupal audience, we will not be looking deep
    into the consumption of services.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是针对Drupal受众的，我们不会深入研究服务的消费。
- en: So for starters, let us create a directory named `recipes` inside the Drupal
    root directory. In the directory, we will have two files, `recipe.js` and `index.html`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先在Drupal根目录中创建一个名为`recipes`的目录。在目录中，我们将有两个文件，`recipe.js`和`index.html`。
- en: The `recipe.js` file will hold the code to call the API URL and parse the data
    object for consumption. The `index.html` file will hold the AngularJS code and
    HTML to read the parsed data and display it on the page.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`recipe.js`文件将包含调用API URL并解析数据对象以供消费的代码。`index.html`文件将包含读取解析数据并在页面上显示的AngularJS代码和HTML。'
- en: 'The folder structure should be similar to this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件夹结构应类似于这个：
- en: '[PRE1]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s look into the `recipe.js` file, which is the AngularJS controller. As
    said, it will hold the JavaScript code to create an Angular Controller Module
    to fetch the JSON object from the API URL and parse it to provide raw content
    from the JSON object:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看 `recipe.js` 文件，这是 AngularJS 控制器。正如所说，它将包含创建 Angular 控制器模块的 JavaScript
    代码，从 API URL 获取 JSON 对象并将其解析为从 JSON 对象提供原始内容：
- en: '[PRE2]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is a controller in Angular, which a JavaScript function.
    This function used two variables, `$http` and `$scope`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码是 Angular 中的一个控制器，一个 JavaScript 函数。这个函数使用了两个变量，`$http` 和 `$scope`。
- en: '`$http` calls the REST API URL using the `get` method'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$http` 使用 `get` 方法调用 REST API URL'
- en: '`$scope` holds the JSON returned from the API and passes it on to the HTML
    DOM of the page in an element array `recipe`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$scope` 包含从 API 返回的 JSON，并将其传递给页面中的元素数组 `recipe`'
- en: 'Now that we have an AngularJS controller, we will create the HTML page that
    will load the controller into the web browser:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了 AngularJS 控制器，我们将创建一个 HTML 页面，该页面将加载控制器到网页浏览器中：
- en: '[PRE3]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first script tag loads the minified AngularJS library (`angular.min.js`)
    from a **content delivery network** (**CDN**) so that we don't have to download
    AngularJS and place it in the project.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个脚本标签从 **内容分发网络**（**CDN**）加载了最小化的 AngularJS 库（`angular.min.js`），这样我们就不必下载
    AngularJS 并将其放置在项目中。
- en: The second script loads the controller code (`recipe.js`) from the application's
    path.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个脚本从应用程序的路径加载控制器代码（`recipe.js`）。
- en: 'AngularJS interacts with the HTML DOM with two attributes:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AngularJS 使用两个属性与 HTML DOM 交互：
- en: The `ng-app` attribute to indicate that this page is an AngularJS application
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-app` 属性用于指示此页面是 AngularJS 应用程序'
- en: The `ng-controller` attribute to define which controller to use
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-controller` 属性用于定义要使用的控制器'
- en: 'The placeholders reference the `recipe_name` and `summary` properties of the
    recipe model object, which will be set upon successfully consuming the REST service:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 占位符引用了食谱模型对象的 `recipe_name` 和 `summary` 属性，这些属性将在成功消费 REST 服务后设置：
- en: '`<h1>{{recipes.recipe_name}}</h1>`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>{{recipes.recipe_name}}</h1>`'
- en: '`<p>{{recipes.summary}}</p>`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p>{{recipes.summary}}</p>`'
- en: 'To run the client, all you need to do is open the directory in the web browser.
    Since our Angular application is inside the Drupal root directory, we can run
    it by opening this URL: `http://www.headless.dev/api/recipes/6/recipes`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行客户端，你只需要在网页浏览器中打开目录。由于我们的 Angular 应用程序位于 Drupal 根目录中，我们可以通过打开此 URL 来运行它：`http://www.headless.dev/api/recipes/6/recipes`。
- en: 'This will show the result as:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下结果：
- en: '![Time for action – consuming RESTful web services using AngularJS](img/4659_12_25.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![执行时间 – 使用 AngularJS 消费 RESTful Web 服务](img/4659_12_25.jpg)'
- en: So, this is a simple way on how to consume RESTful APIs with Angular JS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是使用 Angular JS 消费 RESTful API 的简单方法。
- en: 'A point to remember: since the Angular application is within the Drupal root
    folder, there are no cross-origin issues in running the Angular application. But
    if the Angular application is on a different server than the server hosting the
    web services, then CORS (cross-origin resource sharing) has to be enabled in the
    server hosting the web services. This allows the restricted resources to be displayed
    in the Angular application server.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个要点：由于 Angular 应用程序位于 Drupal 根目录中，因此运行 Angular 应用程序时没有跨域问题。但如果 Angular
    应用程序位于托管 web 服务的服务器之外，那么必须在托管 web 服务的服务器上启用 CORS（跨域资源共享）。这允许受限制的资源在 Angular 应用程序服务器上显示。
- en: '*What just happened?*'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created an AngularJS app that consumes the JSON result from the REST export
    created from the Drupal instance. This JSON response is used by the Angular app
    to display the result provided by the Angular app to an HTML page. This helps
    us to display the data in a faster way and we have control over the display and
    design of the page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 AngularJS 应用程序，它消费了从 Drupal 实例创建的 REST 导出的 JSON 结果。此 JSON 响应被 Angular
    应用程序用来在 HTML 页面上显示由 Angular 应用程序提供的输出。这有助于我们以更快的速度显示数据，并且我们可以控制页面显示和设计。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So we now have a Drupal website that is used for data storage. The Drupal site
    will be used to generate contents and data. This data will be represented in JSON
    format using Drupal's built-in web services modules and views to create RESTful
    JSON exports, which can be used by the app to consume this JSON output and display
    it on the app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个用于数据存储的 Drupal 网站。Drupal 网站将被用来生成内容和数据。这些数据将使用 Drupal 内置的 web 服务模块和视图以
    JSON 格式表示，创建 RESTful JSON 导出，该导出可以被应用程序用来消费此 JSON 输出并在应用程序中显示。
