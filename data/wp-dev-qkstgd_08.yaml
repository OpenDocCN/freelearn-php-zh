- en: Discovering Key Modules in Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现开发中的关键模块
- en: Modern website interfaces are mostly built on the concept of blocks, where the
    site owners can drag and drop reusable components to build the interfaces. UI
    components and page builders play a major role in developing these interfaces.
    Therefore, it's important for developers to have the knowledge of integrating
    any third-party UI component to build amazing interfaces with interactivity. On
    the other hand, WordPress is chosen by many developers due to the existing CMS
    features that accelerate the development process. So, developers need thorough
    knowledge of using backend features as well as customizing the existing features
    for custom requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站界面大多基于块的概念，网站所有者可以拖放可重复使用的组件来构建界面。UI组件和页面构建器在开发这些界面中扮演着重要角色。因此，对于开发者来说，了解如何集成任何第三方UI组件以构建具有交互性的惊人界面是非常重要的。另一方面，WordPress因其现有的CMS功能而被许多开发者选择，这些功能可以加速开发过程。因此，开发者需要深入了解使用后端功能以及根据定制需求定制现有功能。
- en: In this chapter, we are going to focus on UI component integration as well as
    customization of common backend features. We begin the chapter by integrating
    a jQuery slider to WordPress while using menu pages to capture the data. Then,
    we will integrate another popular component called accordion by using custom post
    types to capture the data. After this, we will look at the basic steps of integrating
    any UI component using the two integrations for Image Slider and accordion. Also,
    we will look at the importance of modern page builders in site development and
    discuss the basics of creating a custom component with any page builder. Finally,
    we will look at the process of customizing backend features by creating a basic
    dashboard widget and modifying list tables to provide custom features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注UI组件集成以及常见后端功能的定制。我们首先通过使用菜单页面来捕获数据，将jQuery滑块集成到WordPress中。然后，我们将使用自定义帖子类型来捕获数据，集成另一个流行的组件，称为手风琴。在此之后，我们将查看使用图像滑块和手风琴的两种集成方法来整合任何UI组件的基本步骤。此外，我们还将探讨现代页面构建器在网站开发中的重要性，并讨论使用任何页面构建器创建自定义组件的基础知识。最后，我们将查看通过创建基本仪表板小部件和修改列表表来提供自定义功能的后端功能定制过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Integrating UI components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成UI组件
- en: Integrating jQuery image slider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成jQuery图像滑块
- en: Integrating jQuery accordion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成jQuery手风琴
- en: Identifying the steps for integrating UI components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定集成UI组件的步骤
- en: Understanding the use of page builders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解页面构建器的使用
- en: Creating custom dashboard widgets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义仪表板小部件
- en: Customizing backend list tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制后端列表表
- en: By the end of this chapter, you will have the ability to customize backend admin
    features as well as integrate UI components into sites with the latest trending
    methods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用最新的趋势方法定制后端管理功能以及将UI组件集成到网站中。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循此程序，您需要安装WordPress 4.9.8。即使您有WordPress的更高版本，描述的示例也应无重大问题地工作。
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有WordPress的更高版本，描述的示例应无重大问题地工作。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际效果：
- en: '[http://bit.ly/2yGYX03](http://bit.ly/2yGYX03)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2yGYX03](http://bit.ly/2yGYX03)'
- en: UI components
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI组件
- en: Modern websites are built on top of interactive UI elements. Many premium WordPress
    themes include a wide range of UI components with the support of open source JavaScript
    and CSS libraries. These UI components attract users to a site by simplifying
    the interfaces as well as providing large content in a limited space. Among hundreds
    of UI elements, we find image sliders and galleries, tabs being the most popular
    ones. As a developer, you need to use or build these components to keep up to
    date with rising UI requirements in modern development. So, it's important to
    understand the basic process of integrating any UI component into WordPress using
    plugins or themes. In this section, we are going to look at the integration of
    two UI components. Let’s get started.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站建立在交互式UI元素之上。许多高级WordPress主题包括由开源JavaScript和CSS库支持的广泛UI组件。这些UI组件通过简化界面以及在小空间内提供大量内容来吸引用户。在数百个UI元素中，我们发现图片滑块和相册、标签是最受欢迎的。作为开发者，您需要使用或构建这些组件以跟上现代开发中日益增长的UI需求。因此，了解使用插件或主题将任何UI组件集成到WordPress中的基本过程非常重要。在本节中，我们将探讨两个UI组件的集成。让我们开始吧。
- en: Integrating the jQuery image slider
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成jQuery图片滑块
- en: The image sliders and galleries are the most popular UI elements in WordPress
    sites. You can visit the [wordpress.org](http://wordpress.org) plugin directory
    or a premium marketplace such as Codecanyon to understand the amount of downloads
    and purchases of such plugins. We can use these sliders for displaying a set of
    basic images, as well as to display advanced content and images to promote your
    products, services, and features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图片滑块和相册是WordPress网站中最受欢迎的UI元素。您可以访问[wordpress.org](http://wordpress.org)插件目录或像Codecanyon这样的高级市场，以了解此类插件的下载量和购买量。我们可以使用这些滑块来显示一组基本图片，以及显示高级内容和图片以推广您的产品、服务和功能。
- en: In this section, we are going to use Basic jQuery Slider ([http://basicslider.com/](http://basicslider.com/))
    to explain the process of integrating an Image Slider. We will be creating a single
    Image Slider to display product images in the home page of the site or any other
    preferred location.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Basic jQuery滑块([http://basicslider.com/](http://basicslider.com/))来解释集成图片滑块的过程。我们将创建一个单独的图片滑块，用于在网站的首页或其他任何首选位置显示产品图片。
- en: Image Slider plugins give you the ability to create multiple reusable sliders
    using custom post types or custom forms. In this scenario, we are only focusing
    on a single predefined slider.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图片滑块插件使您能够使用自定义帖子类型或自定义表单创建多个可重复使用的滑块。在这种情况下，我们只关注一个预定义的滑块。
- en: Before starting the implementation, we have to create another plugin for this
    chapter. We are going to name it `WPQuick Key Modules` in a directory called `wpquick-key-modules`.
    We will be using this plugin for the implementation of most of the features discussed
    in this chapter. The plugin will have the same structure as the previous plugins,
    with a main class initializing all the other features and classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们必须为这一章创建另一个插件。我们将将其命名为“WPQuick Key Modules”，并将其放在名为“wpquick-key-modules”的目录中。我们将使用此插件来实现本章讨论的大多数功能。该插件将与之前的插件具有相同的结构，其中主类初始化所有其他功能和类。
- en: Building a product image slider
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建产品图片滑块
- en: 'We can use sliders to display any type of content, with the common type of
    content being images. The first step of integrating any UI component is the process
    of capturing the data. In this scenario, the required data will be a set of images.
    So, we need to build an interface to let the administrator upload a set of images
    for the slider. We have two options for creating an interface for such requirements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用滑块来显示任何类型的内容，其中最常见的类型是图片。集成任何UI组件的第一步是数据捕获的过程。在这种情况下，所需的数据将是一组图片。因此，我们需要构建一个界面，让管理员上传一组图片用于滑块。我们有两种为这种需求创建界面的选择：
- en: '**Menu pages**: We can use the `add_menu_page` function to create a new menu
    page for the features of our plugin. This will be a top-level menu item in the
    WordPress admin menu with the ability to support sub menu pages. This is suitable
    when you need to highlight the menu of your plugin as well as create different
    menu pages for various features of the plugin. More details about the `add_menu_page`
    function are available at [https://developer.wordpress.org/reference/functions/add_menu_page/](https://developer.wordpress.org/reference/functions/add_menu_page/).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单页面**：我们可以使用`add_menu_page`函数来为我们的插件创建一个新的菜单页面。这将是一个WordPress管理员菜单中的顶级菜单项，具有支持子菜单页面的能力。当你需要突出显示你的插件菜单以及为插件的各个功能创建不同的菜单页面时，这非常适合。关于`add_menu_page`函数的更多详细信息，请参阅[https://developer.wordpress.org/reference/functions/add_menu_page/](https://developer.wordpress.org/reference/functions/add_menu_page/)。'
- en: '**Options pages**: We can use the `add_options_page` function to createa new
    options page for custom settings. This function will create a sub-level menu item
    on the Settings menu item. However, it doesn''t support further levels, and hence
    it will be difficult to use for plugins that require multiple menu pages. This
    is useful for adding general site specific settings rather than plugin settings.
    More details about the `add_options_page` function is available at [https://developer.wordpress.org/reference/functions/add_options_page/](https://developer.wordpress.org/reference/functions/add_options_page/).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项页面**：我们可以使用`add_options_page`函数来创建一个新的选项页面用于自定义设置。这个函数将在设置菜单项下创建一个子级菜单项。然而，它不支持更高级别的菜单，因此对于需要多个菜单页面的插件来说，使用起来可能会有困难。这对于添加通用的站点特定设置而不是插件设置很有用。关于`add_options_page`函数的更多详细信息，请参阅[https://developer.wordpress.org/reference/functions/add_options_page/](https://developer.wordpress.org/reference/functions/add_options_page/)。'
- en: In this scenario, we are going to choose menu pages for the image uploading
    interface, as this is a plugin-specific custom requirement. Let's build a menu
    page to upload the images.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们将选择用于图片上传界面的菜单页面，因为这是一个插件特定的自定义要求。让我们创建一个用于上传图片的菜单页面。
- en: Creating a plugin menu page
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建插件菜单页面
- en: 'WordPress provides built-in functions to add menu pages through plugins. We
    can add the interfaces as main- menu items or as sub-menu items. Create a class
    called `WQKM_UI_Components` inside the classes directory of our plugin. Then,
    we can do the usual file inclusion and object creation within the `includes` and
    `instance` functions of the main class of our plugin. Next, we can add the following
    line of code within  `admin_menu`  action to register a new menu page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress通过插件提供了内置函数来添加菜单页面。我们可以将界面添加为主菜单项或子菜单项。在我们的插件类目录中创建一个名为`WQKM_UI_Components`的类。然后，我们可以在插件主类的`includes`和`instance`函数中执行常规的文件包含和对象创建。接下来，我们可以在`admin_menu`动作中添加以下代码行来注册一个新的菜单页面：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two parameters of this function define titles for the menu page and
    the menu item. The third parameter defines the capability to load this page. Here,
    we have used `manage_options` as the capability to restrict it to the administrator.
    You can change this capability based on the person responsible for using this
    interface. The fourth parameter defines a unique slug to access the menu item
    from the URL. The final parameter defines the callback function to generate the
    content for this interface. These are the main parameters used for this function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的前两个参数定义了菜单页面的标题和菜单项的标题。第三个参数定义了加载此页面的能力。在这里，我们使用了`manage_options`作为能力来限制它只对管理员开放。你可以根据负责使用此界面的人员来更改这个能力。第四个参数定义了一个唯一的slug，可以通过URL访问菜单项。最后一个参数定义了用于生成此界面内容的回调函数。这些都是这个函数使用的主要参数。
- en: 'Now we need to implement the callback function to display the necessary fields
    to upload the images to the slider. Let''s take a look at the structure of the `ui_settings`
    function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现回调函数来显示上传图片到滑块的必要字段。让我们看看`ui_settings`函数的结构：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have already discussed a callback function for template loading in the previous
    chapters, and hence we will not be discussing the code in detail. First, we define
    the global variables for holding the main instance of our plugin and passing the
    data to templates. Then, we load the custom template using the technique we used
    in the previous chapters, with the support of the custom template loader. You
    can refer to the source code for the complete implementation. Next, we have to
    build the custom template to upload files, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中讨论了用于模板加载的回调函数，因此我们将不会详细讨论代码。首先，我们定义全局变量以保存我们插件的主要实例并将数据传递到模板中。然后，我们使用我们在上一章中使用的技术，借助自定义模板加载器加载自定义模板。您可以参考源代码以获取完整的实现。接下来，我们必须构建用于上传文件的自定义模板，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s understand the structure of this template for handling image uploads:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解此模板的结构，用于处理图像上传：
- en: First, we define the global variable to accept the template data passed from
    the `WQKM_UI_Components` class. Initially, this variable will be empty, as we
    don't have any template data or settings.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个全局变量以接受从`WQKM_UI_Components`类传递的模板数据。最初，此变量将为空，因为我们没有模板数据或设置。
- en: Then, we have to define a form to enable data submissions. Inside the form,
    we have an empty container called `wqkm-slider-msg` to handle the form error and
    success messages.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须定义一个表单来启用数据提交。在表单内部，我们有一个名为`wqkm-slider-msg`的空容器，用于处理表单的错误和成功消息。
- en: Next, we add a file input field to select and upload the images for the slider.
    We also added a DIV element called `wqkm-slider-images-panel`, inline with the
    file field to display the current images uploaded to the slider.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个文件输入字段来选择和上传滑块的图像。我们还添加了一个名为`wqkm-slider-images-panel`的DIV元素，与文件字段内联，以显示上传到滑块的当前图像。
- en: Finally, we add a button instead of a submit button, as we will be using AJAX
    to handle the form submission.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个按钮而不是提交按钮，因为我们将通过AJAX处理表单提交。
- en: Now the interface is prepared to upload images to the slider. You can access
    this interface by using the `UI Component Settings` menu item from the main menu.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在界面已准备好上传图像到滑块。您可以通过使用主菜单中的`UI组件设置`菜单项来访问此界面。
- en: Saving slider images using AJAX
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AJAX保存滑块图像
- en: We can use normal post submissions as well as AJAX submissions, as this is a
    backend screen without any other dependencies. However, AJAX gives better user
    experience, and hence we will be submitting the form data through AJAX. First,
    we have to add a new script using the `load_admin_scripts` function to handle
    the AJAX request for saving slider images. We will be using the exact same code
    used for the `WooCommerce Product Files` plugin, and hence you can refer to the
    main file inside the source code directory for the implementation of the `load_admin_scripts`
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常规的POST提交以及AJAX提交，因为这是一个没有其他依赖项的后端屏幕。然而，AJAX提供了更好的用户体验，因此我们将通过AJAX提交表单数据。首先，我们必须使用`load_admin_scripts`函数添加一个新的脚本，以处理保存滑块图像的AJAX请求。我们将使用与`WooCommerce
    Product Files`插件相同的代码，因此您可以参考源代码目录中的主文件以了解`load_admin_scripts`函数的实现。
- en: 'Next, we have to handle the form submission process using AJAX. The code for
    the file form submission is available inside the `wqkm-admin.js` file of the source
    codes directory. The implementation will be the same as the one we used in the `wqwpf-admin.js`
    file of the `WQWPF Product Files` plugin, except for the following differences:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用AJAX处理表单提交过程。文件表单提交的代码可在源代码目录的`wqkm-admin.js`文件中找到。实现将与我们在`WQWPF Product
    Files`插件的`wqwpf-admin.js`文件中使用的实现相同，除了以下差异：
- en: In this case, we have get the custom form using the form ID, instead of using
    a built-in post-submission form
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过表单ID获取自定义表单，而不是使用内置的POST提交表单
- en: We use the `wqkm_save_slider_images` action instead of the `wqwpf_save_product_files`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`wqkm_save_slider_images`操作代替`wqwpf_save_product_files`
- en: We remove the post-ID parameter, as we are not submitting a form related to
    a post
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们移除了post-ID参数，因为我们不是提交与帖子相关的表单
- en: 'Now we come to the final part of the image-saving process by uploading and
    capturing the file data. We have to begin by adding the following action to the
    constructor of the `WQKM_UI_Components` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到图像保存过程的最后部分，通过上传和捕获文件数据。我们必须首先在`WQKM_UI_Components`类的构造函数中添加以下操作：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This process is only executed by the logged users, and hence we have omitted
    the `wp_ajax_nopriv` action. Let’s take a look at the implementation of the `save_slider_images`
    function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程仅由登录用户执行，因此我们省略了`wp_ajax_nopriv`动作。让我们看看`save_slider_images`函数的实现：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what the previous code does:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码做了什么：
- en: We begin the function by retrieving the nonce value from the POST request and
    assigning the ID of the logged-in user.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从POST请求中检索nonce值并将其分配给登录用户的ID。
- en: Then, we upload the images in the request using the `process_file_upload` function,
    after completing the nonce verification. We have made a copy of the `process_file_upload`
    function from the **Post Attachments** plugin developed earlier. The only difference
    is the use of image-specific file types instead of the document file types we
    used earlier.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在完成nonce验证后，使用`process_file_upload`函数上传请求中的图片。我们已经从之前开发的**Post Attachments**插件中复制了`process_file_upload`函数。唯一的区别是使用图像特定的文件类型，而不是我们之前使用的文档文件类型。
- en: Once the images are uploaded, we use the `get_option` function to retrieve the
    existing images. Then, we add the uploaded image and save the new image set using
    `update_option`. In this scenario, we have stored slider images in the `wp_options`
    table, as it was a predefined slider. In scenarios where we need multiple dynamic
    sliders, we have to use the `wp_posts` table or a custom table to store this data.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图片上传，我们使用`get_option`函数检索现有图片。然后，我们添加上传的图片并使用`update_option`保存新的图片集。在这种情况下，我们已在`wp_options`表中存储滑块图片，因为它是一个预定义的滑块。在需要多个动态滑块的情况下，我们必须使用`wp_posts`表或自定义表来存储这些数据。
- en: Finally, we traverse through the images list and generate the HTML for images
    to be sent as part of the response for an AJAX request. In the AJAX request, we
    have to use the necessary keys and display the existing images list inline with
    the image upload field.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历图片列表并为作为AJAX请求响应一部分的图片生成HTML。在AJAX请求中，我们必须使用必要的键并将现有图片列表内联显示在图片上传字段中。
- en: Now we have captured the necessary data required for our image slider component.
    The next step is to use this data along with the necessary scripts to generate
    the UI component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了图像滑块组件所需的所有必要数据。下一步是使用这些数据以及必要的脚本生成UI组件。
- en: Preparing slider images
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备滑块图片
- en: 'We need to prepare the HTML code to include the slider images with the necessary
    containers. The element structure for each slider varies based on the library.
    Therefore, we need to refer to the documentation of the slider JavaScript library
    and find out the expected structure. So, we have to visit [http://basicslider.com/](http://basicslider.com/)
    and go to the Markup section. This section explains the required elements to implement
    the slider:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要准备HTML代码以包含滑块图片和必要的容器。每个滑块的元素结构根据库而异。因此，我们需要参考滑块JavaScript库的文档，找出预期的结构。所以，我们必须访问[http://basicslider.com/](http://basicslider.com/)并转到标记部分。本部分解释了实现滑块所需的元素：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have to use this structure and add the slider images inside `<li>` elements.
    We can directly add the HTML to a WordPress post or a page, to display a slider.
    However, we may need to reuse the slider, and hence it is always a good option
    to implement it as a shortcode or a widget. The shortcode is the perfect solution,
    as it can be also included within widgets. Let''s start the implementation by
    adding a shortcode to the constructor of the `WQKM_UI_Components` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须使用这个结构，并在`<li>`元素内添加滑块图片。我们可以直接将HTML添加到WordPress帖子或页面中，以显示滑块。然而，我们可能需要重用滑块，因此将其实现为短代码或小工具始终是一个好选择。短代码是完美的解决方案，因为它也可以包含在小工具中。让我们从向`WQKM_UI_Components`类的构造函数中添加短代码开始实现：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can implement the shortcode callback function to use the uploaded images
    and generate the HTML structure required for the slider. Consider the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现短代码回调函数，以使用上传的图片并生成滑块所需的HTML结构。考虑以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We begin the function by defining the available shortcode attributes and their
    default values. Here, we have only used the `width` and the `height` of the slider
    as settings. You may need to define more settings depending on the image slider
    library of your choice. Then, we retrieve the list of slider images using the `get_option`
    function with the `wqkm_slider_images` key. Finally, we traverse through the images
    and add the image HTML within the `<li>` elements while using the main `<ul>`
    and `<div>` containers to initialize the slider.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义可用的短代码属性及其默认值开始函数。在这里，我们只使用了滑块的 `width` 和 `height` 作为设置。你可能需要根据你选择的图片滑块库定义更多设置。然后，我们使用
    `get_option` 函数和 `wqkm_slider_images` 键检索滑块图片列表。最后，我们遍历图片，在 `<li>` 元素内添加图片 HTML，同时使用主要的
    `<ul>` 和 `<div>` 容器来初始化滑块。
- en: Once the shortcode is added to a post or page, you will see a list of images
    as bullet points, without any sliding functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦短代码被添加到帖子或页面中，你将看到作为项目符号的图片列表，没有任何滑动功能。
- en: Integrating jQuery slider
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 jQuery 滑块
- en: 'This is the final part of the integration, where we apply the functionality
    of JavaScript or CSS libraries to initialize the features of the UI component.
    So, we need to understand the required library files and the order of inclusion.
    The required files are shown in the **Usage** section of [http://basicslider.com/](http://basicslider.com/).
    So, we have to download the necessary libraries and add them within our plugin.
    Once the files are added, we can use the following script and style registering
    code inside the `load_scripts` function of the main class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是集成的最后一部分，我们将 JavaScript 或 CSS 库的功能应用于初始化 UI 组件的功能。因此，我们需要了解所需的库文件及其包含顺序。所需的文件在
    [http://basicslider.com/](http://basicslider.com/) 的 **用法** 部分中显示。因此，我们必须下载必要的库并将它们添加到我们的插件中。一旦文件被添加，我们就可以在主类的
    `load_scripts` 函数中使用以下脚本和样式注册代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have included the `bjqs.css` and `demo.css` files for styles and the `bjqs-1.3.js`
    file for scripts with jQuery as a dependency. The third line registers a plugin-specific
    custom script to initialize the slider. So, we have to use both the jQuery and
    the slider library as dependencies.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了 `bjqs.css` 和 `demo.css` 文件用于样式，以及 `bjqs-1.3.js` 文件用于脚本，jQuery 作为依赖项。第三行注册了一个插件特定的自定义脚本以初始化滑块。因此，我们必须将
    jQuery 和滑块库作为依赖项使用。
- en: Now we need to include these libraries to WordPress requests. We can use the `wp_enqueue_style`
    and the `wp_enqueue_script` functions along with registration code to include
    the files. However, it means these files will be included on every request, even
    when there are no image sliders in pages. As a solution, we can include them inside
    the shortcode function, just after the default values for the shortcode attributes.
    You can refer to the source code for the inclusion of these files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些库包含到 WordPress 请求中。我们可以使用 `wp_enqueue_style` 和 `wp_enqueue_script`
    函数以及注册代码来包含这些文件。然而，这意味着这些文件将在每个请求中包含，即使页面上没有图片滑块。作为一个解决方案，我们可以在短代码属性的默认值之后将这些文件包含在短代码函数中。你可以参考源代码以了解这些文件的包含方式。
- en: 'Then, we come to the final step, where we initialize the component using the
    necessary scripts. You can refer to the **Activation** section of [http://basicslider.com/](http://basicslider.com/)
    to understand the initialization process, as shown in the following code. This
    code should be added to the `wqkm-front.js` custom script file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来到最后一步，使用必要的脚本初始化组件。你可以参考 [http://basicslider.com/](http://basicslider.com/)
    的 **激活** 部分，了解初始化过程，如下面的代码所示。此代码应添加到 `wqkm-front.js` 自定义脚本文件中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this library, `bjqs` acts as the initialization function. We use it on the
    container with the ID `#banner-fade`. We have also assigned the shortcode attribute
    values for `width` and `height` using the data we added with the `wp_localize_script`
    function. Now you can refresh the browser and see an image slider, instead of
    the bullet list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个库中，`bjqs` 作为初始化函数。我们将其应用于具有 ID `#banner-fade` 的容器。我们还使用 `wp_localize_script`
    函数添加的数据为 `width` 和 `height` 分配了短代码属性值。现在你可以刷新浏览器，看到图片滑块，而不是项目符号列表。
- en: This is a very basic slider with basic functionality. You can find more advanced
    sliders with images, content, videos, and some amazing effects. You can try different
    sliders, as the process of integration is the same, regardless of the slider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的滑块，具有基本功能。你可以找到更多具有图片、内容、视频和一些惊人效果的先进滑块。你可以尝试不同的滑块，因为无论滑块如何，集成过程都是相同的。
- en: Reusing the slider as a widget
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用滑块作为小部件
- en: We had a brief introduction to widgets and their role in WordPress. Widgets
    was intended to add blocks of features to the sidebar of the site. However, with
    modern themes and widget areas, widgets can be considered as a reusable block
    of features similar to shortcodes. So, we are going to look at the process of
    building a frontend widget in WordPress. Let's start by adding a new file to the
    `classes` directory of our plugin with a class called `WQKM_Product_Slider_Widget`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对小部件及其在WordPress中的作用进行了简要介绍。小部件的目的是向网站的侧边栏添加功能块。然而，随着现代主题和小部件区域的出现，小部件可以被视为类似于短代码的可重复使用的功能块。因此，我们将查看在WordPress中构建前端小部件的过程。让我们首先在我们的插件
    `classes` 目录中添加一个名为 `WQKM_Product_Slider_Widget` 的新文件。
- en: 'In this scenario, we will be building a widget to display the product slider
    created in the previous section. So, we can reuse the shortcode functionality
    for this widget. Let''s take a look at the implementation of the widget, using
    the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们将构建一个显示在上一节中创建的产品滑块的小部件。因此，我们可以为这个小部件重用短代码功能。让我们看一下以下代码中小部件的实现：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'WordPress uses the `WP_Widget` class as the base for handling the widget functionality.
    All the widgets, including the core widgets, should extend this class to use the
    widget functionality. Therefore, we have extended this class in our custom `WQKM_Product_Slider_Widget`
    class declaration. Now we can go though the main functions of a widget using the
    following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress使用 `WP_Widget` 类作为处理小部件功能的基础。所有的小部件，包括核心小部件，都应该扩展这个类以使用小部件功能。因此，我们在自定义的
    `WQKM_Product_Slider_Widget` 类声明中扩展了这个类。现在我们可以通过以下步骤查看小部件的主要功能：
- en: '`constructor`: We have to use this function to call the constructor of the
    parent `WP_Widget` class, with the necessary parameters. In this case, we have
    used a unique ID, title, and a description.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constructor`: 我们必须使用此函数来调用父 `WP_Widget` 类的构造函数，并使用必要的参数。在这种情况下，我们使用了一个唯一的ID、标题和描述。'
- en: '`widget`: This function is used to generate the output of the widget in the
    frontend. Here, we have used `wqkm_product_slider` shortcode to generate the output
    for the widget. You can use a shortcode or call a function to generate the output.
    The `$instance` variable contains all the settings for the widget, added to the
    backend. So, we are using the width and height settings as attributes to the shortcode.
    You may also notice the use of the `$args[''before_widget'']` and the `$args[''before_widget'']`
    statements. These are a predefined set of arguments passed to the widget and the
    values of these arguments are specified when registering the widgets. These arguments
    are useful for adding common content before or after each widget.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`widget`: 此函数用于在前端生成小部件的输出。在这里，我们使用了 `wqkm_product_slider` 短代码来生成小部件的输出。你可以使用短代码或调用一个函数来生成输出。`$instance`
    变量包含所有小部件的设置，这些设置添加到后端。因此，我们使用宽度和高度设置作为短代码的属性。你可能也会注意到对 `$args[''before_widget'']`
    和 `$args[''after_widget'']` 语句的使用。这些是一组预定义的参数，传递给小部件，这些参数的值在注册小部件时指定。这些参数对于在前后每个小部件添加常见内容非常有用。'
- en: '`form`: This function is used to display the form to capture the settings for
    the widget. We used width and height in the widget function, and hence we need
    settings to define those values. First, we get the existing values for the settings
    using the `$instance` variable passed automatically to this function. Then, we
    generate the input fields for the width and height settings. You may notice the
    use of the `get_field_id` and the `get_field_name` functions. These are functions
    defined in the core `WP_Widget` class to provide access to the widget details
    in a standard way. You should always use these functions without hard-coding names
    and IDs.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`form`: 此函数用于显示表单以捕获小部件的设置。我们在小部件函数中使用了宽度和高度，因此我们需要设置来定义这些值。首先，我们使用自动传递给此函数的
    `$instance` 变量获取设置的现有值。然后，我们生成宽度和高度设置的输入字段。你可能注意到了对 `get_field_id` 和 `get_field_name`
    函数的使用。这些是在核心 `WP_Widget` 类中定义的函数，用于以标准方式提供对小部件细节的访问。你应该始终使用这些函数，而不是硬编码名称和ID。'
- en: '`Update`: This function is used to save or update the settings data to the
    database. Once the Save button of a widget is clicked, this function will be called
    with the old values, as well as the submitted new values. We have to make the
    necessary validations and assign the new values to the `$instance` variable with
    the respective keys. Then, the WordPress core widget class will automatically
    save the values in the `$instance` variable.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`更新`：此函数用于将设置数据保存或更新到数据库中。一旦点击了小部件的“保存”按钮，此函数将使用旧值以及提交的新值被调用。我们必须进行必要的验证并将新值分配给具有相应键的`$instance`变量。然后，WordPress核心小部件类将自动将值保存到`$instance`变量中。'
- en: 'This is the standard process for building any custom widget. Once the widget
    class is created, you have to use these four functions to generate the necessary
    settings and output for the widget. Even though we have completed creating the
    widget, it will not be visible in the Appearance | Widgets section. We have to
    register new widgets, before they appear in the widgets section. Let’s consider
    the following code for registering our widget:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建任何自定义小部件的标准流程。一旦创建了小部件类，你必须使用这四个函数来生成小部件所需的设置和输出。尽管我们已经完成了小部件的创建，但它不会在“外观
    | 小部件”部分中可见。我们必须在它们出现在小部件部分之前注册新小部件。让我们考虑以下用于注册我们小部件的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we need to include the file inside the `includes` function of the main
    class. Then, we can add the `widgets_init` action to the constructor of the `WQKM_Admin_Features`
    class. Finally, we use `register_widget` with the class name of the widget inside
    the callback function to register the new widget. Now you should be able to use
    the new widget to add the product image slider to your sidebar.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在主类的`includes`函数中包含该文件。然后，我们可以在`WQKM_Admin_Features`类的构造函数中添加`widgets_init`动作。最后，我们在回调函数中使用`register_widget`和类名来注册新小部件。现在你应该能够使用这个新小部件将产品图片滑块添加到你的侧边栏中。
- en: Integrating jQuery accordion
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成jQuery手风琴
- en: In this section, we are going to look at the integration of another popular
    UI component called **Accordion**. The accordion is a component that allows you
    to display a large amount of content within a limited space using collapsible
    sections. We have chosen the accordion component of the **jQuery UI** library
    ([https://jqueryui.com/accordion/](https://jqueryui.com/accordion/)) as a basic
    solution. You can find many advanced accordion component libraries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一个流行的UI组件——**手风琴**的集成。手风琴是一个组件，允许你通过可折叠的部分在有限的空间内显示大量内容。我们选择了**jQuery
    UI**库中的手风琴组件（[https://jqueryui.com/accordion/](https://jqueryui.com/accordion/））作为基本解决方案。你可以找到许多高级手风琴组件库。
- en: In the image sliders section, we used a menu page to capture data, and limited
    it to a single fixed-image slider. However, it’s also important to have the ability
    to use same component with different content in various places on the site. So,
    we are going to build accordions with the ability to create unlimited components
    with dynamic content. We can either use custom post types and store the data in
    a `wp_posts` table, or we can use a custom table. Since we are developing a UI
    element, we are going to use custom post types to simplify the process. Let’s
    get started.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片滑块部分，我们使用了一个菜单页面来捕获数据，并将其限制为单个固定的图片滑块。然而，在网站的各个地方使用相同组件并具有不同内容的能力也同样重要。因此，我们将构建具有创建无限组件和动态内容能力的手风琴。我们可以使用自定义文章类型并将数据存储在`wp_posts`表中，或者我们可以使用自定义表。由于我们正在开发一个UI元素，我们将使用自定义文章类型来简化流程。让我们开始吧。
- en: Creating an accordion model and capturing data
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建手风琴模型并捕获数据
- en: We have chosen to use custom post types for accordions. Therefore, we need to
    register a new custom post type by using the `register_post_type` function with
    necessary settings. We already created a custom post type and discussed the process
    in previous chapters, while working with the property post type. Therefore, you
    can refer to the `WQKM_UI_Components` class inside the source code directory to
    understand the registration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用自定义文章类型来构建手风琴。因此，我们需要使用带有必要设置的`register_post_type`函数注册一个新的自定义文章类型。我们已经在之前的章节中创建了一个自定义文章类型并讨论了与属性文章类型一起工作的过程。因此，你可以参考源代码目录中的`WQKM_UI_Components`类来了解注册过程。
- en: Unlike properties, accordions are not intended to be displayed as individual
    posts or to achieve page items. Instead, we use them to capture the data to be
    reused in UI elements within posts or pages. Therefore, we have to set the `public`
    attribute to `false` while creating the custom post type. This setting makes sure
    that the accordions are not publicly visible as an individual post type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性不同，手风琴不是为了作为单独的帖子显示或实现页面项目。相反，我们使用它们来捕获要在帖子或页面中的UI元素中重用的数据。因此，在创建自定义帖子类型时，我们必须将`public`属性设置为`false`。此设置确保手风琴不会作为单独的帖子类型公开可见。
- en: 'Once the post type is registered, we need to use metaboxes to include the necessary
    fields and capture the data for accordions. The accordion has many sections with
    dynamic content. So, we need text area fields to capture the content for each
    section. Let''s start by adding a metabox to accordions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了帖子类型，我们需要使用元框来包含必要的字段并捕获手风琴的数据。手风琴有许多具有动态内容的部分。因此，我们需要文本区域字段来捕获每个部分的内容。让我们从为手风琴添加元框开始：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have registered a new meta box for the accordion post type. The `add_meta_boxes`
    action and the post type initialization can be found inside the constructor of
    the `WQKM_UI_Components` class. Now we need to implement the callback function
    using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为手风琴帖子类型注册了一个新的元框。`add_meta_boxes`动作和帖子类型初始化可以在`WQKM_UI_Components`类的构造函数中找到。现在我们需要使用以下代码实现回调函数：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin the function by defining the global variables and adding the post type
    and nonce to the global template data variable. Then, we get the existing data
    for the accordion sections using the `get_post_meta` function. Here, we have only
    included one section. You can find three sections in the source code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数开始时定义全局变量，并将帖子类型和nonce添加到全局模板数据变量中。然后，我们使用`get_post_meta`函数获取手风琴部分现有数据。在这里，我们只包含了一个部分。您可以在源代码中找到三个部分。
- en: We have fixed the accordion sections to three, to simplify the development.
    Ideally, we should allow administrators to dynamically add an unlimited number
    of sections for accordions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将手风琴部分固定为三个，以简化开发。理想情况下，我们应该允许管理员动态添加无限数量的手风琴部分。
- en: Finally, we load a custom template for the input fields of the accordion sections.
    The template for the accordion meta boxes can be found inside the `accordion-meta.php`
    file in the `templates` directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为手风琴部分输入字段加载了一个自定义模板。手风琴元框的模板可以在`templates`目录下的`accordion-meta.php`文件中找到。
- en: 'This template is similar to the one used for the `Properties` post type, and
    hence it''s self-explanatory. However, you may notice the use of the following
    line of code instead of the code for text areas:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板与用于`Properties`帖子类型的模板类似，因此是自我解释的。然而，您可能会注意到使用了以下代码行而不是文本区域的代码：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We could have used text area fields for the accordion section. However, these
    sections may contain a considerable amount of HTML, and hence using a text area
    can be difficult. As a solution, we used the `wp_editor` function that generates
    the WordPress content editor field with all the formatting. We have to pass the
    default content and the ID of the content editor. Now we can use the WordPress
    rich content editor to add content to the accordion sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用文本区域字段来处理手风琴部分。然而，这些部分可能包含相当数量的HTML，因此使用文本区域可能很困难。作为解决方案，我们使用了`wp_editor`函数，该函数生成带有所有格式的WordPress内容编辑器字段。我们必须传递默认内容和内容编辑器的ID。现在我们可以使用WordPress丰富内容编辑器来添加内容到手风琴部分。
- en: We need to save the section data to complete the data capturing process for
    accordions. The saving process is implemented using the `save_post` action and
    the implementation is similar to the property details saving process. The only
    difference is the use of `wp_kses_post` function to filter the section content
    generated by the `wp_editor` function. You can refer to the source code for the
    implementation of the section saving process inside the `WQKM_UI_Components` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保存部分数据以完成手风琴的数据捕获过程。保存过程是通过`save_post`动作实现的，实现方式与属性详情保存过程类似。唯一的区别是使用`wp_kses_post`函数来过滤由`wp_editor`函数生成的部分内容。您可以参考`WQKM_UI_Components`类中部分保存过程的源代码。
- en: Preparing accordion content
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备手风琴内容
- en: 'We already identified the importance of shortcodes for adding UI elements to
    posts or pages. Therefore, we will be using another shortcode to prepare the content
    for the accordion. Let''s add the following code to the implementation of the
    accordion shortcode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了短代码对于在帖子或页面中添加 UI 元素的重要性。因此，我们将使用另一个短代码来准备手风琴的内容。让我们将以下代码添加到手风琴短代码的实现中：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s what the previous code does:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码做了什么：
- en: We have added a new shortcode called `wqkm_accordian` to the constructor of
    the `WQKM_UI_Components` class. We used custom post types to allow the creation
    of unlimited accordions, and hence we need a way to identify each accordion. So,
    we use the post ID as a shortcode attribute to identify the accordion.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `WQKM_UI_Components` 类的构造函数中添加了一个名为 `wqkm_accordian` 的新短代码。我们使用自定义帖子类型来允许创建无限数量的手风琴，因此我们需要一种方法来识别每个手风琴。所以，我们使用帖子
    ID 作为短代码属性来识别手风琴。
- en: Next, we generate the content sections of accordion by loading the data using
    the ID attribute.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 ID 属性加载数据来生成手风琴的内容部分。
- en: Here, we have used the section title and the section content for each section
    inside a main container. This is the required structure for the chosen accordion
    library. You will have to find the element structure in case you choose different
    library for the implementation.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用每个部分的主容器内的部分标题和部分内容。这是所选手风琴库所需的结构。如果您选择不同的库进行实现，您将需要找到元素结构。
- en: Finally, we return the output from the shortcode with accordion sections.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过从短代码中返回输出以包含手风琴部分来返回输出。
- en: 'Now you can create and add an accordion to a post or page using the necessary
    ID. However, like the image slider, you will just see a bunch of HTML sections
    displayed on browser. To enable the accordion functionality, we need to register
    the necessary scripts and styles inside the `load_scripts` function of the main
    class, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用必要的 ID 在帖子或页面中创建并添加手风琴。然而，就像图片滑块一样，您在浏览器上只会看到一堆 HTML 部分。为了启用手风琴功能，我们需要在主类的
    `load_scripts` 函数内部注册必要的脚本和样式，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we have downloaded and added the `jQuery UI CSS` file to our plugin,
    as it''s not provided within the WordPress core. Then, we have added a custom
    script called `wqkm-accordion.js`, with jQuery and jQuery UI accordion scripts
    as dependencies. The jQuery UI component libraries are available within the WordPress
    core, and hence we can directly call the script handle instead of registering
    the script separately. Then, we can add the following code to the shortcode function
    to enqueue the files:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们已经下载并添加了 `jQuery UI CSS` 文件到我们的插件中，因为它不在 WordPress 核心中提供。然后，我们添加了一个名为 `wqkm-accordion.js`
    的自定义脚本，其依赖项为 jQuery 和 jQuery UI 手风琴脚本。jQuery UI 组件库在 WordPress 核心中可用，因此我们可以直接调用脚本句柄而不是单独注册脚本。然后，我们可以将以下代码添加到短代码函数中，以排队文件：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have the accordion script and style included within the shortcode. Finally,
    we have to initialize the accordion by adding the following initialization code
    to the `wqkm-accordion.js` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在手风琴短代码中包含了手风琴脚本和样式。最后，我们必须通过在 `wqkm-accordion.js` 文件中添加以下初始化代码来初始化手风琴：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The accordion is initialized using the ID of the main container we created
    for the shortcode output. This may vary based on the accordion library of your
    choice. Now we have completed the accordion integration process, and your accordion
    should look similar to the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们为短代码输出创建的主要容器的 ID 来初始化手风琴。这可能会根据您选择的手风琴库而有所不同。现在，我们已经完成了手风琴集成过程，您的手风琴应该看起来与以下截图相似：
- en: '![](img/7b31dcb2-cbcf-4022-bbe7-055cb270108b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b31dcb2-cbcf-4022-bbe7-055cb270108b.png)'
- en: As you can see, we can use these UI components in a limited space to display
    a large amount of contents.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以在有限的空间内使用这些 UI 组件来显示大量内容。
- en: Steps for integrating UI components
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 UI 组件的步骤
- en: 'Up to this point, we looked at two implementations for integrating the jQuery
    slider and accordion UI components using different data-capturing techniques.
    The implementation may vary based on the type of UI component and its functionality.
    However, the basic process is similar for most of the common UI components. So,
    let''s summarize the keys for integrating any UI component with WordPress:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看了两套使用不同的数据捕获技术集成 jQuery 滑块和手风琴 UI 组件的实现。实现可能根据 UI 组件的类型及其功能而有所不同。然而，对于大多数常见的
    UI 组件，基本过程是相似的。所以，让我们总结一下将任何 UI 组件与 WordPress 集成的关键步骤：
- en: '**Identify component data**: Each UI component works on existing data or elements.
    So, we need to identify the data needed to use each UI component and the method
    for storing this data.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别组件数据**：每个UI组件都基于现有数据或元素工作。因此，我们需要识别使用每个UI组件所需的数据以及存储这些数据的方法。'
- en: '**Generate component output**: In this step, we have to use the captured data,
    process it, and generate the HTML output needed to enable the features of a UI
    component. Usually, we use a reusable component such as a shortcode or widget
    to add and generate the output for UI components.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成组件输出**：在这一步，我们必须使用捕获的数据，对其进行处理，并生成启用UI组件功能的HTML输出。通常，我们使用可重复使用的组件，如短代码或小工具，来添加和生成UI组件的输出。'
- en: '**Include component libraries**: Most UI components generate their features
    by applying JavaScript or CSS to the generated output. These features of the component
    generally come as an open source library. So, in this step, we need to all the
    necessary scripts and styles for the component, along with the necessary settings.
    In this process, we use `wp_register_style` and `wp_register_script` functions
    to include these resources by adding them inside plugins or themes. Then, you
    can enqueue them conditionally within the main class or inside the UI component
    generation function.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**包含组件库**：大多数UI组件通过应用JavaScript或CSS到生成的输出中生成其功能。这些组件的功能通常以开源库的形式提供。因此，在这一步，我们需要为组件添加所有必要的脚本和样式，以及必要的设置。在这个过程中，我们使用`wp_register_style`和`wp_register_script`函数通过将它们添加到插件或主题中包含这些资源。然后，你可以在主类或UI组件生成函数中条件性地将它们排队。'
- en: '**Passing script data**: Some of the UI element libraries directly apples CSS
    or JavaScript features on the generated output. However, some element scripts
    require certain data or settings to initialize the element. In such cases, we
    have to pass the necessary data to necessary scripts using the `wp_localize_script`
    function.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**传递脚本数据**：一些UI元素库直接在生成的输出上应用CSS或JavaScript功能。然而，一些元素脚本需要某些数据或设置来初始化元素。在这种情况下，我们必须使用`wp_localize_script`函数将必要的数据传递给必要的脚本。'
- en: '**Initialize the element**: Once necessary libraries and HTML output is ready,
    we can initialize the element by using the initialization function of these libraries.
    These initializations generally takes one to a few lines of code. Usually, we
    use a CSS class or HTML element ID on the generated output for this initialization.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化元素**：一旦必要的库和HTML输出准备就绪，我们可以通过使用这些库的初始化函数来初始化元素。这些初始化通常只需要一到几行代码。通常，我们使用CSS类或HTML元素ID在生成的输出上进行初始化。'
- en: Once these steps are completed, you will see the interactive features or styles
    in your UI element. This is the general process for the most common UI elements.
    However, there may be exceptions that require a different process to initialize
    the UI element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些步骤，你将在UI元素中看到交互式功能或样式。这是最常见的UI元素的一般过程。然而，可能会有例外，需要不同的过程来初始化UI元素。
- en: Simplifying development with page builders
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用页面构建器简化开发
- en: '**Page builder** is a set of components that simplifies the process of content
    creation or building the features of the site. These components allow developers
    to build complex interfaces in super-quick time by choosing and configuring built-in
    components. Page builders were initially used for simplifying content creation
    with pre-built design elements. However, page builders have now evolved into a
    state where we can use the existing components to add advanced site features such
    as form management, searchable google maps, parallax images, and videos.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面构建器**是一组简化内容创建或构建网站功能的组件。这些组件允许开发者通过选择和配置内置组件，以超级快速的时间构建复杂的界面。页面构建器最初用于简化使用预构建设计元素的内容创建。然而，页面构建器现在已经发展到我们可以使用现有组件添加高级网站功能，如表单管理、可搜索的谷歌地图、视差图像和视频。'
- en: Until recently, developers used the page builders included in themes, as well
    as free and premium page builder plugins. WordPress has introduced a block-based
    content builder called **Gutenberg**. At this stage, Gutenberg editor supports
    content editing with a basic set of elements. Currently, it's nowhere near the
    features offered by popular page builders such as Elementor, Beaver Builder, and
    Visual Composer. However, the future seems bright, as the WordPress team is backing
    the Gutenberg editor by making it a default core feature. So, we will soon see
    more powerful features of the Gutenberg editor, along with the features offered
    by other page builders.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，开发者们使用主题中包含的页面构建器，以及免费和付费的页面构建器插件。WordPress 引入了一个基于块的 内容构建器，称为 **Gutenberg**。在这个阶段，Gutenberg
    编辑器支持使用一组基本元素进行内容编辑。目前，它远远落后于 Elementor、Beaver Builder 和 Visual Composer 等流行页面构建器提供的功能。然而，未来似乎光明，因为
    WordPress 团队正在支持 Gutenberg 编辑器，将其作为默认核心功能。因此，我们很快将看到 Gutenberg 编辑器更强大的功能，以及其他页面构建器提供的功能。
- en: Understanding the features of page builders
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解页面构建器的功能
- en: 'As we discussed, page builders offer a wide range of components that can be
    dragged or assigned to any post, page, or custom post type. However, many of these
    page builders provide advanced features beyond using basic built-in components.
    So, it''s important to understand these features to use the existing components,
    as well as making your solutions integrate with page builders. Let''s take a look
    at the main features offered by modern page builders:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，页面构建器提供了一系列可以拖放或分配给任何帖子、页面或自定义帖子类型的组件。然而，许多这些页面构建器提供了超出基本内置组件使用的先进功能。因此，了解这些功能对于使用现有组件以及使您的解决方案与页面构建器集成非常重要。让我们看看现代页面构建器提供的主要功能：
- en: '**Backend and frontend editing**: Usually, we edit or build the site interfaces
    using the backend content editor, and hence we have to switch to frontend to view
    the changes. Most page builders provide frontend editing, allowing previews in
    real time and adjusting them instantly. Also, there is a backend editor, if you
    want to work with other backend features.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端和前端编辑**：通常，我们使用后端内容编辑器来编辑或构建网站界面，因此我们必须切换到前端来查看更改。大多数页面构建器提供前端编辑功能，允许实时预览并即时调整。此外，还有一个后端编辑器，如果您想使用其他后端功能。'
- en: '**Built-in templates**: Many page builders provide built-in template designs
    by using the existing components. So, the developers can use these templates designed
    for common requirements and adjust them as needed without writing a single line
    of code.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置模板**：许多页面构建器通过使用现有组件提供内置的模板设计。因此，开发者可以使用这些为常见需求设计的模板，并根据需要调整它们，而无需编写任何代码。'
- en: '**Advanced styling**: Each component allows various styling options such as
    margins, paddings, colors and so on. So, you can fine tune the design without
    going into the code.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级样式**：每个组件都允许各种样式选项，例如边距、填充、颜色等。因此，您可以在不进入代码的情况下微调设计。'
- en: '**Responsive design**: This is a must in modern development to cater for different
    devices, such as personal computers, mobiles, tabs, and so on. Usually, we have
    to spend lot of time making our designs fully responsive. Page builder structure
    and components are responsive by default. So, you don''t have to do anything to
    make the content responsive as long as you follow the proper coding standards
    for your own elements.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式设计**：在现代开发中，为了适应不同的设备，如个人电脑、手机、平板电脑等，这是必须的。通常，我们必须花费大量时间使我们的设计完全响应式。页面构建器结构和组件默认是响应式的。因此，只要您遵循自己元素的适当编码标准，您就不需要做任何事情来使内容响应式。'
- en: As you can see, page builder provides a lot of power for building the content
    and design of your site. However, these powerful features also come with some
    limitations. Some of these page builders are completely dependent on shortcodes,
    and hence you will be locked into the plugin. Also, you might experience performance
    issues when using some complex features of page builders. Therefore, you need
    to be responsible with choosing the proper page builder and the features.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，页面构建器为构建您网站的内容和设计提供了很多功能。然而，这些强大的功能也伴随着一些限制。一些页面构建器完全依赖于短代码，因此您将锁定在插件中。此外，当使用页面构建器的某些复杂功能时，您可能会遇到性能问题。因此，您在选择合适的页面构建器和功能时需要负责任。
- en: Developing components for page builders
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为页面构建器开发组件
- en: Most popular page builders come with a wide range of built-in components as
    well as additional components using addons. So, we can use the existing components
    to build general purpose WordPress sites. However, when developing advanced applications
    or sites with custom requirements, the default functionality of these components
    may not be sufficient. In such cases, we have to build our own page builder components
    to provide the necessary functionality. We can always create shortcodes and ask
    the clients to use them inside the page builder components. But building our components
    simplifies the process considerably for the client, and hence we have to build
    components whenever necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的页面构建器附带了一系列内置组件以及通过插件提供的附加组件。因此，我们可以使用现有的组件来构建通用目的的WordPress网站。然而，当开发高级应用程序或具有自定义要求的网站时，这些组件的默认功能可能不足以满足需求。在这种情况下，我们必须构建自己的页面构建器组件来提供必要的功能。我们始终可以创建短代码并要求客户在页面构建器组件中使用它们。但是构建我们的组件可以大大简化客户的过程，因此我们有必要时必须构建组件。
- en: 'Major page builders provides an API or guide for developing components for
    their plugin. The technique varies for each page builder. So, you need to use
    the documentation to understand and develop a component for each page builder. Developing
    a component from scratch with the necessary explanations is beyond the scope of
    this chapter. However, we will explore the basic steps of component creation using
    the Elementor page builder as the example. Let''s take a look at the main steps
    for building a page builder component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的页面构建器为他们的插件提供API或指南来开发组件。每种页面构建器的技术都有所不同。因此，您需要使用文档来了解和为每个页面构建器开发组件。从头开始开发具有必要解释的组件超出了本章的范围。然而，我们将以Elementor页面构建器为例，探索组件创建的基本步骤。让我们看看构建页面构建器组件的主要步骤：
- en: Each page builder identifies its components as modules, widgets, blocks, and
    so on. So, there should be a way to register new components for the page builder.
    Elementor uses the `Widget_Base` class and `register_widget_type` function to
    register new components. The other page builders offer similar techniques.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页面构建器都将其组件标识为模块、小部件、块等。因此，应该有一种方法可以为页面构建器注册新的组件。Elementor使用`Widget_Base`类和`register_widget_type`函数来注册新的组件。其他页面构建器提供类似的技术。
- en: After registering the component, you need to specify the input fields for capturing
    component data. Most page builders provide different types of input fields to
    capture and save the data for the component. Elementor provides a function called `add_control` on
    the `Widget_Base` class, supporting over 30 different control types. The other
    page builders will have similar functions to add input fields to different field
    types, as well as different data-storing mechanisms.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册组件后，您需要指定用于捕获组件数据的输入字段。大多数页面构建器提供不同类型的输入字段来捕获和保存组件的数据。Elementor在`Widget_Base`类上提供了一个名为`add_control`的函数，支持超过30种不同的控件类型。其他页面构建器将提供类似的功能来为不同字段类型添加输入字段，以及不同的数据存储机制。
- en: Finally, we need to provide the output of the component by building the HTML
    code or executing an existing shortcode. Elementor provides a function called `render` for
    retrieving the saved component data and displaying the output. The other page
    builders should have a similar method, with a similar name.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过构建HTML代码或执行现有的短代码来提供组件的输出。Elementor提供了一个名为`render`的函数，用于检索保存的组件数据并显示输出。其他页面构建器应该有类似的方法，具有类似的名字。
- en: 'We have used these steps and built a slider component for the Elementor page
    builder. You can find the code for this addon inside the `wpquick-elementor-components` directory
    of the source code for this chapter. The following screenshot previews the component
    generated by the addon with settings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用这些步骤为Elementor页面构建器构建了一个滑块组件。您可以在本章源代码的`wpquick-elementor-components`目录中找到此插件的代码。以下截图预览了带有设置的由插件生成的组件：
- en: '![](img/09809233-6d65-4b42-adf3-e8d1dbd35719.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09809233-6d65-4b42-adf3-e8d1dbd35719.png)'
- en: Elementor is one of the most popular and rising page builders at this stage.
    You can access the documentation at [https://developers.elementor.com/creating-an-extension-for-elementor/](https://developers.elementor.com/creating-an-extension-for-elementor/)
    and use the addon code for understanding the step. The process for other page
    builders will be similar, with the support of plugin-specific component creation
    functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Elementor是目前最受欢迎且正在崛起的页面构建器之一。您可以在[https://developers.elementor.com/creating-an-extension-for-elementor/](https://developers.elementor.com/creating-an-extension-for-elementor/)找到文档，并使用附加代码来理解步骤。其他页面构建器的过程将类似，需要插件特定组件创建函数的支持。
- en: Simplifying and customizing admin features
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化和定制管理功能
- en: We have to use the core features as much as possible to get the maximum benefits
    of using WordPress for site development. This includes the use of frontend theme
    features, as well as the existing backend features, that mainly focuses on post-related
    functionality. So, it's obvious that developers need to customize these features
    to suit the requirements of each website. In this section, we are going to look
    at several customizations of commonly used backend features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须尽可能使用核心功能，以获得使用WordPress进行网站开发的最佳效益。这包括使用前端主题功能以及现有的后端功能，这些功能主要关注与帖子相关的功能。因此，很明显，开发者需要根据每个网站的需求对这些功能进行定制。在本节中，我们将探讨常用后端功能的几种定制方法。
- en: Creating custom dashboard widgets
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义仪表板小部件
- en: We had a brief introduction to the **Dashboard Widget API** in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml),
    *Practical Usage of WordPress APIs*. Basically, a *dashboard* is a collection
    of widgets built for administration purposes. Unlike frontend theme widgets, we
    don't have an interface for adding or removing admin dashboard widgets. So, we
    have to build custom solutions to build new dashboard widgets as well as remove
    the existing ones. In this section, we are going to look at the process of creating
    a basic dashboard widget.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml)“WordPress API的实际应用”中简要介绍了**仪表板小部件API**。基本上，一个*仪表板*是为管理目的而构建的小部件集合。与前端主题小部件不同，我们没有添加或删除管理仪表板小部件的界面。因此，我们必须构建自定义解决方案来创建新的仪表板小部件以及删除现有的小部件。在本节中，我们将探讨创建基本仪表板小部件的过程。
- en: Registering and building dashboard widgets
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册和构建仪表板小部件
- en: 'First, we have to register the dashboard widget by using the `wp_dashboard_setup`
    action, instead of the `widgets_init` we used on the frontend widgets. Consider
    the following code for the widget registration process:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用`wp_dashboard_setup`动作来注册仪表板小部件，而不是我们在前端小部件中使用的`widgets_init`。以下代码展示了小部件注册过程：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the callback function, we use the `wp_add_dashboard_widget` function
    to register a new widget. The parameters for this function contain a unique widget
    ID, widget title, and the callback function. Then, we have to implement the function
    to display the content for the widget, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数内部，我们使用`wp_add_dashboard_widget`函数来注册一个新的小部件。此函数的参数包含一个唯一的widget ID、widget标题和回调函数。然后，我们必须实现该函数以显示小部件的内容，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have simplified the process by using a shortcode we developed in earlier
    chapters. Basically, we have a dashboard widget in fewer than 10 lines of code.
    This process is simpler compared to the frontend dashboard widget creation process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用在早期章节中开发的短代码简化了过程。基本上，我们用不到10行代码就有一个仪表板小部件。与前端仪表板小部件创建过程相比，这个过程更简单。
- en: The default dashboard widgets are mostly suitable for blogs. In many circumstances,
    we have to remove the existing widgets and add custom widgets to cater for advanced
    site-specific business requirements. In custom sites, dashboard widgets are frequently
    used for displaying the site statistics, reports, or features that need to be
    executed on a regular basis, without visiting individual screens. You can try
    the existing plugins with dashboard widgets to understand the usage. WooCommerce,
    bbPress, and Easy Digital Downloads are some of the popular plugins with built-in
    custom dashboard widgets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认仪表板小部件大多适用于博客。在许多情况下，我们必须移除现有的小部件并添加自定义小部件以满足高级站点特定业务需求。在自定义站点中，仪表板小部件通常用于显示站点统计信息、报告或需要定期执行的功能，而无需访问单个屏幕。您可以尝试带有仪表板小部件的现有插件来了解其用法。WooCommerce、bbPress和Easy
    Digital Downloads是一些内置自定义仪表板小部件的流行插件。
- en: Customizing backend list tables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制后端列表表
- en: WordPress provides backend list tables for the main content types. We discussed
    the features of list tables in [Chapter 7](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml),
    *Managing Custom Post Types and Processing Forms*, on custom post types. The default
    features provide data list tables for posts, pages, users, and comments, as well
    as all the registered custom post types. Also, we can extend the core class used
    for list tables and create our own custom data list tables. So, it's important
    to know the existing features as well as customizable features of backend list
    tables. In this section, we are going to look at the some of the common customizations
    on the backend user list. Let's get started.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress为主内容类型提供后端列表表。我们在[第7章](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml)中讨论了列表表的功能，*管理自定义帖子类型和处理表单*。默认功能为帖子、页面、用户和评论以及所有注册的自定义帖子类型提供数据列表表。此外，我们还可以扩展用于列表表的核心类，并创建我们自己的自定义数据列表表。因此，了解后端列表表现有功能以及可定制功能非常重要。在本节中，我们将查看后端用户列表的一些常见自定义设置。让我们开始吧。
- en: Creating and executing custom bulk actions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和执行自定义批量操作
- en: The WordPress list tables contains a dropdown called Bulk Actions in the top
    left-hand section of the list. This feature is used to modify multiple records
    in the table with a single predefined event. We have to choose one or more records,
    select an action from the Bulk Actions dropdown, and click the Apply button to
    complete the process. This is a very useful feature when you want to modify bulk
    records for custom features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress列表表在列表的右上角部分包含一个名为“批量操作”的下拉菜单。此功能用于通过单个预定义事件修改表中的多个记录。我们必须选择一个或多个记录，从批量操作下拉菜单中选择一个操作，然后点击应用按钮以完成此过程。当您想要修改大量记录以实现自定义功能时，这是一个非常有用的功能。
- en: 'The WordPress core actions can be used to modify the Bulk Actions dropdown
    and to include custom actions for our projects. Let''s add the following action
    to the constructor of the `WQKM_Admin_Features` class for understanding the process
    of using custom actions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress核心操作可用于修改批量操作下拉菜单并包括我们项目的自定义操作。让我们将以下操作添加到`WQKM_Admin_Features`类的构造函数中，以了解使用自定义操作的过程：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This action is used to filter the actions for the users list table. The filter
    consists of the `bulk_action`-prefix followed by the screen name. So, you can
    use the same action for other core list tables by replacing users with the screen
    name for the list. Let''s take a look at the implementation of the custom action:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作用于过滤用户列表表中的操作。该过滤器由`bulk_action`前缀后跟屏幕名称组成。因此，您可以通过将用户替换为列表的屏幕名称来使用相同的操作来处理其他核心列表表。让我们看看自定义操作的实现：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we are adding a custom action to the default backend user list
    by modifying the existing bulk actions list. We have to use a unique slug as the
    array key for this action and define the label as the array value. In this scenario,
    we are building an action that allows us to mark certain users as Featured Users.
    Now you will see a new option in the Bulk Actions dropdown for handling user-featured
    status.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们通过修改现有的批量操作列表向默认后端用户列表添加了一个自定义操作。我们必须使用唯一的slug作为此操作的数组键，并定义标签作为数组值。在这种情况下，我们正在构建一个允许我们标记某些用户为特色用户的操作。现在您将在批量操作下拉菜单中看到一个新选项来处理用户特色状态。
- en: 'Once the records and action is selected, we can click the Apply button to make
    the modifications to the selected records. So, we need to implement the action
    by adding the following action to the constructor of the class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了记录和操作，我们就可以点击应用按钮来修改所选记录。因此，我们需要通过在类的构造函数中添加以下操作来实现此操作：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this code, we have used `handle_bulk_actions-` filter followed by the screen
    name for user list table. So, let''s take a look at the implementation of the
    custom action:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用了`handle_bulk_actions-`过滤器后跟用户列表表的屏幕名称。因此，让我们看看自定义操作的实现：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s what the previous code does:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码做了什么：
- en: This function automatically receives three parameters for the redirect URL,
    the action name, and the list of IDs of the records to be modified.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数自动接收用于重定向URL、操作名称和要修改的记录ID列表的三个参数。
- en: First, we check the action and make sure our code executes only for the `wpquick_featured_user`
    action.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查操作并确保我们的代码仅针对`wpquick_featured_user`操作执行。
- en: Next, we loop through the list of selected user IDs and modify the value to
    mark the user as a featured user. We can use a different action or toggle the
    same action to remove the featured status as well.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历所选用户ID的列表，并修改值以标记用户为特色用户。我们可以使用不同的操作或切换相同的操作来移除特色状态。
- en: Finally, we redirect the user to the list by adding a custom argument to the
    URL called `bulk_featured_users`. This value will be used to filter the request
    and display a custom message using the `bulk_admin_notices` function in the source
    code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过向URL添加一个名为`bulk_featured_users`的自定义参数来将用户重定向到列表。此值将用于过滤请求，并在源代码中使用`bulk_admin_notices`函数显示自定义消息。
- en: Now we have a working custom action for the user list. You can test the feature
    by adding featured status to some of the users and confirming it by checking the
    database values. This is a simple way of modifying or applying custom data to
    multiple records for custom requirements. We can't use input fields for these
    actions, and hence the action should have a fixed feature with predefined values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为用户列表创建了一个工作的自定义操作。你可以通过向一些用户添加特色状态并检查数据库值来测试这个功能。这是一种简单的方法，用于修改或应用自定义数据以满足特定需求。我们不能使用输入字段进行这些操作，因此操作应该具有固定的特性，并具有预定义的值。
- en: Adding custom list columns
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义列表列
- en: 'The data list tables contains default set of columns, and these columns vary
    based on the type of the list. In the previous section, we changed the featured
    status of the user. However, we had to use the database to check the value. Instead,
    we can display such important information on the data list table by using custom
    columns. So, in this section, we are going to look at the process of adding custom
    columns to the default users list as well as identifying the necessary hooks for
    other lists. Let''s start by adding the following filter and action to the constructor
    of `WQKM_Admin_Features` class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 数据列表表包含默认的列集，这些列根据列表类型的不同而有所变化。在上一节中，我们更改了用户的特色状态。然而，我们必须使用数据库来检查值。相反，我们可以通过使用自定义列在数据列表表中显示此类重要信息。因此，在本节中，我们将探讨将自定义列添加到默认用户列表的过程，以及识别其他列表所需的钩子。让我们首先向`WQKM_Admin_Features`类的构造函数添加以下过滤器和操作：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `manage_users_columns` filter is used to modify or remove existing columns
    as well as to add new columns to the user list. The following code previews the
    implementation to include the featured status as a column:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage_users_columns`过滤器用于修改或删除现有列，以及向用户列表添加新列。以下代码预览了包括特色状态作为列的实现：'
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you should see an additional column in the user list without any data.
    The next step is to display the column data for each user. We have to use the
    `manage_users_custom_column` action to provide the data for our custom column.
    Let''s take a look at the implementation of the callback function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在用户列表中看到一个新的列，但没有数据。下一步是显示每个用户的列数据。我们必须使用`manage_users_custom_column`操作来为我们自定义列提供数据。让我们看看回调函数的实现：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function accepts three parameters for the column value, column name, and
    the user ID. We can use these parameters to get the custom column value for the
    selected users. Here, we use `get_user_meta` function as we stored the data on
    `wp_usermeta` table. We can also store these values and display them using custom
    tables. Next, we use a `switch` statement to return the value based on the column.
    It's important to use the `default` case and return the default value, to be compatible
    with other plugins. Now you should see the custom column in the user list with
    the custom values for each user.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受三个参数：列值、列名和用户ID。我们可以使用这些参数来获取所选用户的自定义列值。在这里，我们使用`get_user_meta`函数，因为我们把数据存储在`wp_usermeta`表中。我们也可以使用自定义表来存储这些值并显示它们。接下来，我们使用`switch`语句根据列返回值。使用`default`情况并返回默认值是很重要的，以确保与其他插件兼容。现在你应该在用户列表中看到自定义列，并为每个用户显示自定义值。
- en: Sorting custom column values
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序自定义列值
- en: 'The default list tables provides sorting capabilities for the first column
    and one or more from the remaining columns. However, these are built-in columns
    provided by the WordPress core features. So, we need the ability to sort custom
    column values to effectively use and filter the custom data. WordPress provides
    a built-in filter for specifying sortable columns. Let''s consider the following
    filter and its implementation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认列表表为第一列和剩余列中的一个或多个提供排序功能。然而，这些是WordPress核心功能提供的内置列。因此，我们需要排序自定义列值的能力，以有效地使用和过滤自定义数据。WordPress提供了一个内置过滤来指定可排序的列。让我们考虑以下过滤及其实现：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The filter needs to be added inside the constructor of the class. This filter
    accepts the list of existing sortable columns as a parameter. Here, we have added
    the key of our custom column to the sortable columns array and return the list.
    Now you should be able to see a link in custom column to change the sorting value.
    The final step of the process is to change the default query and enable sorting
    on the custom column. Let''s consider the following action and its implementation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤需要添加到类的构造函数中。这个过滤接受现有可排序列的列表作为参数。在这里，我们将我们自定义列的键添加到可排序列数组中，并返回列表。现在你应该能够在自定义列中看到一个链接来更改排序值。过程的最后一步是更改默认查询并启用自定义列的排序。让我们考虑以下动作及其实现：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s understand the implementation of this function using the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来理解这个函数的实现：
- en: We can use `pre_user_query` action to modify the default query, just before
    the execution. The `WP_User_Query` object is passed as a parameter to this function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`pre_user_query`动作在执行之前修改默认查询，该函数将`WP_User_Query`对象作为参数传递。
- en: Next, we check the `orderby` clause of the query using the `query_vars` array
    to make sure our custom code only executes on `featured_user_status` column.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`query_vars`数组检查查询的`orderby`子句，以确保我们的自定义代码仅在`featured_user_status`列上执行。
- en: Then, we have to modify the query, staring with the `join` statement on the `from`
    clause to include the `usermeta` table. The modified `where` clause makes sure
    that sorting is only applied to the values of the `featured_user_status` column.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须修改查询，从`from`子句中的`join`语句开始，包括`usermeta`表。修改后的`where`子句确保排序只应用于`featured_user_status`列的值。
- en: Finally, we change the `orderby` clause to order the list using meta values
    of the `featured_user_status` column.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`orderby`子句更改为使用`featured_user_status`列的元值来排序列表。
- en: 'Now the process is complete, and you should be able to click the column title
    to sort the users in both ways using the featured status. The following screenshot
    previews the features we added to the user list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过程已经完成，你应该能够点击列标题，使用特色状态对用户进行两种方式的排序。以下截图预览了我们添加到用户列表中的功能：
- en: '![](img/4e0c602e-5cd3-4cd6-8786-a6ea8f46edf8.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e0c602e-5cd3-4cd6-8786-a6ea8f46edf8.png)'
- en: You can follow this technique with the necessary filtering to manage more columns
    on the user list.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过必要的过滤来应用这个技术，以管理用户列表上的更多列。
- en: We looked at the list table customization for the backend user list. Similarly,
    we can apply the same technique to customize the columns of other WordPress list
    tables using necessary actions and filters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了后端用户列表的列表表自定义。同样，我们可以使用相同的技术，通过必要的动作和过滤来定制其他WordPress列表表的列。
- en: In most scenarios, we need to customize posts and custom post types lists to
    include custom columns. We have to use `manage_edit-{post_type}_columns` filter
    to define the custom columns and the `manage_{post_type}_posts_custom_column` filter
    to add the values for the custom columns. Then, we can use `manage_edit-{post_type}_sortable_columns` filter
    to define sortable columns and use `pre_get_posts` action to modify the query
    for sorting.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们需要自定义文章和自定义文章类型列表，以包括自定义列。我们必须使用`manage_edit-{post_type}_columns`过滤来定义自定义列，并使用`manage_{post_type}_posts_custom_column`过滤来添加自定义列的值。然后，我们可以使用`manage_edit-{post_type}_sortable_columns`过滤来定义可排序的列，并使用`pre_get_posts`动作来修改排序的查询。
- en: So, we need to use these actions and filters whenever necessary to display additional
    data in list tables and avoid the time-consuming visits to the edit section to
    check the values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在必要时使用这些动作和过滤来在列表表中显示额外的数据，并避免耗时地访问编辑部分来检查值。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The main purpose of using WordPress is to simplify the development process.
    So, we need to understand the process of customizing important backend features.
    Also it's important to use modern user interface components to provide all the
    important in limited space using attractive techniques. We began the chapter by
    understanding the importance of the integration of UI components. So, we integrated
    jQuery Slider and Accordion while using two different data-capturing methods.
    We also looked at the importance of page builders in modern development and the
    steps for developing custom components for page builders. Next, we moved on to
    customizing admin features by building a simple dashboard widget. Finally, we
    looked at the process of adding custom features to built-in WordPress list tables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WordPress的主要目的是简化开发过程。因此，我们需要了解自定义重要后端功能的过程。同时，使用现代用户界面组件在有限的空间内使用吸引人的技术提供所有重要功能也非常重要。我们首先通过理解UI组件集成的重要性开始了本章，因此我们在使用两种不同的数据捕获方法的同时集成了jQuery滑动器和手风琴组件。我们还探讨了在现代开发中页面构建器的重要性以及为页面构建器开发自定义组件的步骤。接下来，我们通过构建一个简单的仪表盘小部件来自定义管理功能。最后，我们研究了向内置WordPress列表表添加自定义功能的过程。
- en: In [Chapter 9](1690ebbf-249c-4892-81db-098b6a9050f5.xhtml), *Enhancing Security,
    Performance, and Maintenance*, we will be completing the content for this book
    by looking at the non-functional aspects of development, such as security, performance,
    testing, and maintenance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](1690ebbf-249c-4892-81db-098b6a9050f5.xhtml)《增强安全性、性能和维护》中，我们将通过查看开发的非功能性方面，如安全性、性能、测试和维护，来完成本书的内容。
