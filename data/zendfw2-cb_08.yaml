- en: Chapter 8. Optimizing Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 优化性能
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Caching, and when to cache
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存，以及何时缓存
- en: Understanding and using storage plugins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用存储插件
- en: Setting up a caching system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置缓存系统
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In a society where we want our data now, it is important to make sure that our
    websites and applications also deliver it as soon as possible. When we rule out
    any obvious cause of slow downs, such as network infrastructure or server configuration,
    we can start looking at caching. This chapter is all about what to cache and how
    to cache, making our lives a lot faster.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个我们希望立即获取数据的社会中，确保我们的网站和应用能够尽快提供数据是非常重要的。当我们排除了任何明显的减速原因，例如网络基础设施或服务器配置后，我们就可以开始考虑缓存。这一章全部关于应该缓存什么以及如何缓存，从而使我们的生活变得更加快捷。
- en: Caching and when to Cache
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存和何时缓存
- en: Caching, everyone knows about it, everybody talks about it, but what is it?
    In its purest essence caching is all about serving your application as quickly
    as possible to the user. That's what we will talk in this recipe when and how
    to cache.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存，每个人都知道它，每个人都在谈论它，但什么是缓存呢？在它的最纯粹的本质上，缓存就是尽可能快地向用户提供应用。这就是我们在本食谱中将要讨论的，何时以及如何进行缓存。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be working with the Zend Framework skeleton application again, so it
    would be wise to have that set up.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Zend Framework骨架应用，因此明智的做法是先设置好它。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: When developing an application, caching might not be something that immediately
    comes up in the design, and most probably this will come up when the application
    goes live and after a while you find your application responding slower than when
    you first put it live.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用时，缓存可能不是设计阶段立即考虑的事情，而且很可能是当应用上线后一段时间，你发现应用的响应速度比你最初上线时要慢。
- en: That is the perfect (well not perfect, as that would be during the design phase,
    obviously) time to consider implementing a cache.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是考虑实现缓存的理想时间（虽然不是完美的，因为显然应该在设计阶段进行），以加快应用的响应速度。
- en: When we talk about caching, a common misunderstanding is that we are solely
    talking about caching an HTML output. Nothing could be further from the truth,
    as we have several powerful methods of caching in PHP.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论缓存时，一个常见的误解是我们仅仅在谈论缓存HTML输出。这完全不是事实，因为我们有几种强大的PHP缓存方法。
- en: 'The following list is a collection of some methods available to us to cache
    different sections of our application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是我们可用于缓存应用不同部分的一些方法的集合：
- en: Caching the ZF2 configuration
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存ZF2配置
- en: Caching the rendered output
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存渲染后的输出
- en: Caching the class map
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存类映射
- en: We will now go in further detail of the methods named in the preceding list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更深入地探讨前面列表中提到的各种方法。
- en: Caching configuration
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存配置
- en: Probably the most static bit of code in your application will be the configuration.
    Oh but how we need configuration to properly load our application, but in the
    meantime we might hate it for all the merging it needs to do before we end up
    with the final version of the configuration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中，最静态的代码部分可能就是配置。哦，但我们需要配置来正确加载我们的应用，但与此同时，我们可能因为所有需要合并的操作而讨厌它，直到我们得到配置的最终版本。
- en: 'But fear not, as we can simply cache the merged configuration so that your
    application doesn''t have to parse through the lot anymore! This is actually such
    a simple process, that it is almost hilarious to give the example for it (`/config/application.config.php`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但不必担心，因为我们只需缓存合并后的配置，这样你的应用就不必再解析所有内容了！实际上，这个过程如此简单，以至于给出示例几乎令人捧腹（`/config/application.config.php`）：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And that's it. Nothing fancy is needed to make this work as everything that
    is required to make this work is already built in Zend Framework 2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。不需要任何花哨的东西来使这个工作正常，因为使这个工作正常所需的一切都已经内置在Zend Framework 2中。
- en: This is a very effective way to start caching everything that is static, and
    although it probably doesn't give the application an enormous speed boost (unless
    we have literally dozens of modules) it will be a method that shouldn't be forgotten.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有效的方法来开始缓存所有静态内容，尽管它可能不会给应用带来巨大的速度提升（除非我们真的有成百上千个模块），但它将是一个不应该被遗忘的方法。
- en: Caching output
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存输出
- en: Caching output is useful when we have a lot of static files that normally don't
    or rarely change. When we talk about content that doesn't change a lot we can
    think of blog posts or news items as those usually get generated once and put
    live indefinitely. There are obviously more output types that are useful to cache,
    but we will just give an example to show how easy it is to cache output that we
    deem static.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存输出在当我们有很多静态文件通常不会或很少改变时很有用。当我们谈论变化不大的内容时，我们可以想到博客文章或新闻条目，因为它们通常只生成一次并无限期地发布。显然还有更多有用的输出类型可以缓存，但我们将只给出一个例子来展示我们认为静态的输出是如何容易缓存的。
- en: 'First we need to create the configuration in our module to make sure the caching
    is enabled in our `ServiceManager` (`/module/SomeModule/config/module.config.php`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的模块中创建配置，以确保在`ServiceManager`中启用缓存（`/module/SomeModule/config/module.config.php`）：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we created the configuration, let''s continue to control the caching
    in our `/module/SomeModule/Module.php` file''s `onBootstrap` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了配置，让我们继续在我们的`/module/SomeModule/Module.php`文件的`onBootstrap`方法中控制缓存：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now every time we go to our application the route event will check if we might
    have a cache of the specific route, and if we do, it will return the cache (if
    not expired, of course). If the route hasn't been cached yet it will do so if
    necessary once the rendered event is triggered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们访问我们的应用时，路由事件都会检查我们是否可能有一个特定路由的缓存，如果有，它将返回缓存（当然，如果没有过期的话）。如果路由还没有被缓存，一旦渲染事件被触发，它将根据需要执行缓存。
- en: Credit for this example goes to *Jurian Sluiman* (*jurian-sluiman*) who is a
    user on the [stackoverflow.com](http://stackoverflow.com) website and a significant
    contributor to Zend Framework 2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的功劳归功于*Jurian Sluiman* (*jurian-sluiman*)，他是[stackoverflow.com](http://stackoverflow.com)网站的用户，也是Zend
    Framework 2的重要贡献者。
- en: Caching the class map
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存类映射
- en: The class map file is one of those files that are just big, and basically static
    after the application has done merging it. That it is static and is obviously
    a great opportunity for us so we can cache it and take a bit of the load from
    the applications merging away. As for the first method of our caching, this one
    also only requires us to add a couple of properties in the configuration file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类映射文件是那些一旦应用完成合并后就会变得很大的文件之一，基本上是静态的。它之所以是静态的，这显然为我们提供了一个很好的机会，我们可以缓存它，并从应用的合并中减轻一些负担。至于我们缓存的第一个方法，这也只需要我们在配置文件中添加几个属性。
- en: 'Let''s get this example started (`/config/application.config.php`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个例子开始（`/config/application.config.php`）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, although this might not be a significant improvement on the overall performance,
    we can be sure that every little bit helps, and it will certainly help lighten
    the load for the autoloader process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这可能在整体性能上可能没有显著提升，但我们确信每一丝帮助都是有益的，它肯定会帮助减轻自动加载过程的工作负担。
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: All that caching does is speeding up the application by keeping everything ready
    for when it is needed within a certain time (the `ttl` or also called time-to-live)
    period. It speeds up the application because it gives the application the data
    it requires without the application needing to make the connection to the database,
    or recompiling templates for example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些缓存所做的只是通过在特定时间（`ttl`，也称为生存时间）内保持一切准备就绪来加快应用的速度。它通过在应用需要时提供所需数据，而不需要应用连接到数据库或重新编译模板等，从而加快了应用的速度。
- en: Caching is usually done on the filesystem, as it is considered to be a very
    fast option instead of going through a database for example. However, technically
    the fastest option for caching would be in-memory (this is because the memory
    or RAM is the closest data storage for the CPU and therefore the fastest). Although
    memory caching is a great method of caching, it can also become the worst kind
    if there is just too much to cache.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存通常是在文件系统中进行的，因为它被认为是一个非常快的选项，而不是通过数据库等。然而，从技术上讲，缓存的最快选项是在内存中（这是因为内存或RAM是CPU最近的数据存储，因此是最快的）。尽管内存缓存是一种很好的缓存方法，但如果缓存的数据太多，它也可能变成最糟糕的一种。
- en: It is therefore wise to think about different caching methods (filesystem cache,
    for example, only with blog posts and application configuration, for example,
    in memory cache) before just generally using a method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在仅仅使用一种方法之前，考虑不同的缓存方法（例如，仅对博客文章和应用配置使用文件系统缓存，例如，内存缓存）是明智的。
- en: Understanding and using storage plugins
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用存储插件
- en: Instead of customizing everything, Zend Framework 2 provides an excellent interface
    that can manipulate the storing, removing, and retrieving of cache data by using
    storage plugins.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义一切不同，Zend Framework 2 提供了一个出色的接口，可以通过存储插件来操作存储、删除和检索缓存数据。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: Storage plugins are used to compliment the storage adapters whenever a developer
    feels that they need more functionality added to the adapter without necessarily
    making a custom adapter. Therefore, plugins are the handiest tool to use when
    we want to modify the way our storage adapters handle the cache.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储插件用于在开发者觉得需要向适配器添加更多功能时补充存储适配器，而不必 necessarily 制作一个自定义适配器。因此，当我们要修改我们的存储适配器处理缓存的方式时，插件是最方便的工具。
- en: There are a couple of storage plugins readily available in Zend Framework 2,
    so let's get cracking on and explain them a bit further.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中，有几个存储插件可供使用，因此让我们开始进一步解释它们。
- en: Using the ClearExpiredByFactor plugin
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ClearExpiredByFactor 插件
- en: The `ClearExpiredByFactor` plugin clears the expired cache items once in a while,
    which are determined by a set factor. The higher the factor integer is, the less
    likely it will be that the cache will clear its expired items. But don't forget;
    this being a (pseudo) random process and all chances could be that it will be
    called every single time. We understand that this is incredibly counterintuitive,
    so maybe this code snippet taken from the plugin will clear things up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearExpiredByFactor` 插件会偶尔清除过期的缓存项，这些项由一个设置的因子决定。因子整数越高，缓存清除过期项的可能性就越小。但别忘了；这是一个（伪）随机过程，所有机会都可能是它每次都会被调用。我们理解这非常不符合直觉，所以也许这个从插件中提取的代码片段可以澄清一些问题。'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We should also note that this plugin is only fired when there is cache to be
    written, it does not fire when cache is read.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，此插件仅在需要写入缓存时才会触发，当读取缓存时不会触发。
- en: '`PluginOptions` that can be set is `setClearingFactor`, which sets the clearing
    factor.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的 `PluginOptions` 是 `setClearingFactor`，它设置清除因子。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This plugin requires the storage adapter to be an instance of `ClearExpiredInterface`,
    otherwise it will not do anything (and we would never know as it doesn't log this
    error). Only the Filesystem and Memory Storage adapters support this interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件要求存储适配器必须是 `ClearExpiredInterface` 的实例，否则它将不会做任何事情（而且我们永远不会知道，因为它不会记录这个错误）。只有文件系统和内存存储适配器支持此接口。
- en: Using the ExceptionHandler plugin
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ExceptionHandler 插件
- en: The `ExceptionHandler` plugin catches any exceptions that are thrown when getting/setting
    the cache and forwards it to a developer defined callback.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionHandler` 插件会捕获在获取/设置缓存时抛出的任何异常，并将其转发到开发者定义的回调函数。'
- en: '`PluginOptions` that can be set are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的 `PluginOptions` 包括：
- en: '`setExceptionCallback`: This is a callback function to call when an exception
    occurs'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setExceptionCallback`：这是一个在发生异常时调用的回调函数'
- en: '`setThrowExceptions`: This is a Boolean (default `true`) value that tells the
    plugin to re-throw exceptions that it caught'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setThrowExceptions`：这是一个布尔值（默认 `true`），告诉插件重新抛出它捕获的异常'
- en: Using the IgnoreUserAbort plugin
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IgnoreUserAbort 插件
- en: The `IgnoreUserAbort` plugin makes sure that the script isn't aborted before
    the writing has finished to the cache. This way we can be sure we won't get any
    corrupted data in our cache.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`IgnoreUserAbort` 插件确保脚本在写入缓存完成之前不会被中止。这样我们就可以确保我们的缓存中不会有任何损坏的数据。'
- en: '`PluginOptions` that can be set is `setExitOnAbort`, which is a Boolean (default
    `true`) value that tells us if we can abort the script whenever we want, or if
    we need to wait until we are done writing.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的 `PluginOptions` 是 `setExitOnAbort`，它是一个布尔值（默认 `true`），告诉我们我们是否可以随时中止脚本，或者如果我们需要等待我们完成写入。
- en: Using the OptimizeByFactor plugin
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OptimizeByFactor 插件
- en: 'You wanted to clear by factor? I am sure you also want to optimize by factor
    then! This plugin (pseudo) randomly optimizes the cache. The factor determines
    the chance it has of actually optimizing, the lower the number (between 1 and
    a high number) the greater chance, the higher the number the lower the chance.
    We understand that this is incredibly counterintuitive, so maybe this code snippet
    taken from the plugin will clear things up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要按因子清除吗？我敢肯定你也不想按因子优化！此插件（伪）随机优化缓存。因子决定了它实际优化的机会，数字越低（在1和较大数字之间），机会越大，数字越高，机会越小。我们理解这非常不符合直觉，所以也许这个从插件中提取的代码片段可以澄清一些问题：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We should also note that this plugin is only fired when there is cache to be
    removed, it does not fire when the cache is read or written.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，此插件仅在需要移除缓存时才会触发，当缓存被读取或写入时不会触发。
- en: '`PluginOptions` that can be set is `setOptimizingFactor`, which sets the optimizing
    factor.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的`PluginOptions`是`setOptimizingFactor`，它设置优化因子。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This plugin only works on storage adapters with an instance of `OptimizableInterface`.
    If this is not available it will not throw an error, so we will never know. The
    adapters currently supporting this interface are Dba and Filesystem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件仅在具有`OptimizableInterface`实例的存储适配器上工作。如果此接口不可用，它不会抛出错误，所以我们永远不会知道。目前支持此接口的适配器是Dba和Filesystem。
- en: Using the Serializer plugin
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用序列化器插件
- en: The `Serializer` plugin will serialize and unserialize the data when setting
    and getting it from the cache.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serializer`插件将在设置和从缓存获取数据时序列化和反序列化数据。'
- en: '`PluginOptions` that can be set:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的`PluginOptions`：
- en: '`setSerializer`: This sets the serializer we want to use, it needs to be an
    class that implements the `Zend\Serializer\Adapter\AdapterInterface` class'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSerializer`: 这将设置我们想要使用的序列化器，它需要是一个实现了`Zend\Serializer\Adapter\AdapterInterface`类的类'
- en: '`setSerializerOptions`: If a string is given at the `setSerializer` option
    (the full class name as a string) then the instantiation options need to be set
    in this option'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSerializerOptions`: 如果在`setSerializer`选项（作为字符串的全类名）中给出了字符串，则需要在选项中设置实例化选项'
- en: Using any plugin
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任何插件
- en: Fortunately plugins are easy to use, and all we have to do is add them to the
    storage adapter to make it work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，插件很容易使用，我们只需要将它们添加到存储适配器即可使其工作。
- en: 'We know that there are several ways of instantiating plugins, but we will just
    display one method to show off how it basically works:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有几种方法可以实例化插件，但我们将只显示一种方法来展示它基本上是如何工作的：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's all that needs configuring to make it all work together nicely. In a
    MVC application (which we probably will use Zend Framework 2 for) plugin can be
    on very different locations. Normally though we want to configure this in the
    configuration or in the bootstrap event if we will use it constantly throughout
    the application, as that will save time compared to instantiating it more than
    once.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要配置以使其协同工作的内容。在一个MVC应用程序（我们可能将使用Zend Framework 2）中，插件可以位于非常不同的位置。通常，我们希望在配置或引导事件中配置它，如果我们打算在整个应用程序中持续使用它，因为这样可以节省时间，与多次实例化相比。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Plugins are attached to storage adapters and work because they attach themselves
    to events of the storage adapters. When these events get triggered, the functionality
    gets triggered as well. It is really as simple as that, and there is no real further
    explanation needed for this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 插件附加到存储适配器上，并且因为它们将自己附加到存储适配器的事件上，所以它们才会工作。当这些事件被触发时，功能也会被触发。这真的很简单，而且对此没有真正的进一步解释所需的。
- en: Setting up a caching system
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置缓存系统
- en: A good example on how to do it is always the best way to learn a new technique
    quickly. That is why we will show you how to implement a caching system on different
    parts of our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 学习新技术的最佳方式总是最好的例子。这就是为什么我们将向您展示如何在应用程序的不同部分实现缓存系统。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we will show off a simple system that makes use of caching. We
    will also show off some benchmarks so that we can clearly see the differences
    between a system without caching and a system with caching. The code for this
    project can also be found with the book, which contain a couple of sample classes
    so that we can measure the performance a bit better. We will not discuss any of
    the sample classes (which all can be found in the `/module/Application/src/Application`
    directory), but we will refer to them in some of the examples.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示一个简单的系统，该系统利用了缓存。我们还将展示一些基准测试，以便我们可以清楚地看到没有缓存和有缓存的系统之间的差异。此项目的代码也可以在书中找到，其中包含一些示例类，以便我们可以更好地测量性能。我们不会讨论任何示例类（所有这些类都可以在`/module/Application/src/Application`目录中找到），但我们将参考它们在示例中。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Setting up a simple caching system is easy enough, but the question most of
    the time is, where to begin.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个简单的缓存系统很容易，但大多数时候的问题是，从哪里开始。
- en: Benchmarking our application before cache
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在缓存之前基准测试我们的应用程序
- en: For the benchmark we will use an application called `ab`, which is short for
    ApacheBench. This is a tool which comes standard with the Apache web server on
    both the Microsoft Windows as the Linux version; for our recipe we will be using
    the Linux version of the benchmarking tool, don't worry though as both versions
    do exactly the same.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基准测试，我们将使用一个名为`ab`的应用程序，它是ApacheBench的缩写。这是一个标准工具，包含在Apache网络服务器中，无论是Microsoft
    Windows版本还是Linux版本；在我们的食谱中，我们将使用基准测试工具的Linux版本，不用担心，因为两个版本都完全一样。
- en: 'For our benchmark, we will use no caching at all and we will use the following
    code in `Application\Controller\IndexController` (`/module/Application/src/Application/Controller/IndexController.php`)
    to generate our ridiculously long output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的基准测试，我们将不使用任何缓存，并在`Application\Controller\IndexController`（`/module/Application/src/Application/Controller/IndexController.php`）中使用以下代码来生成我们的荒谬长输出：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This action will output a very long string, which is overly complicated, but
    we don't really care about that as we just want to measure how long it takes to
    create such a string. We can now commence with the first benchmark.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作将输出一个非常长的字符串，非常复杂，但我们并不真的关心这一点，因为我们只想测量创建这样一个字符串需要多长时间。现在我们可以开始第一个基准测试。
- en: 'The following command will be used to do the benchmarking:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将用于进行基准测试：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command stands for a concurrency of four (`-c 4`) and we want to run the
    test ten times (`-n 10`) on the `localhost` as our website. This means that a
    total of 40 times our page will be visited, which will give us quite a clear view
    on the average in response times.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令表示并发数为四（`-c 4`），我们想在`localhost`上运行测试十次（`-n 10`），作为我们的网站。这意味着我们的页面总共将被访问40次，这将给我们一个相当清晰的平均响应时间视图。
- en: The following is a review of the most important result of the benchmark. Obviously
    the rest of the result is also somewhat interesting, but we are just interested
    in the response time at the moment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对基准测试最重要的结果的回顾。显然，其余的结果也有一定的兴趣，但我们目前只对响应时间感兴趣。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will use the 18.111 seconds as the base to compare all the other results
    with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用18.111秒作为比较所有其他结果的基础。
- en: Implementing configuration/class map cache
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现配置/类映射缓存
- en: First we are going to implement the configuration cache as that is the basis
    of all caching (at least I like to think so).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现配置缓存，因为这是所有缓存的基础（至少我喜欢这样想）。
- en: 'We can do that by adding the following configuration to the `/config/application.config.php`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`/config/application.config.php`文件添加以下配置来实现这一点：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now enabled the configuration/class map caching, which should get us a very
    (very) small increase in response time. Naturally, this will be a bigger difference
    when we have a larger application with more modules.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启用了配置/类映射缓存，这应该会给我们带来一个非常（非常）小的响应时间增加。当然，当我们的应用程序更大，有更多模块时，这个差异会更大。
- en: 'Let''s do our benchmark again to see what the difference is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次进行基准测试，看看有什么区别：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see our result has been significantly different, a staggering 14.2
    percent faster actually. We should not forget, however, that our application is
    incredibly small and this percentage may actually be a lot smaller if our application
    grows larger in the future. Still, this is a clear sign that caching our configuration
    and class mapping is a good practice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的结果已经显著不同，实际上快了14.2%，令人震惊。然而，我们不应忘记，我们的应用程序非常小，如果未来应用程序规模扩大，这个百分比可能实际上会更小。尽管如此，这仍然是一个明显的迹象，表明缓存配置和类映射是一个好的实践。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A little bug in the configuration caching system we should wary about is that
    we cannot use closures (also called anonymous functions). If we do we get a PHP
    fatal error saying something like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意配置缓存系统中的一个小错误是，我们不能使用闭包（也称为匿名函数）。如果我们这样做，我们会得到一个PHP致命错误，如下所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing the class caching
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现类缓存
- en: Because we have this incredibly long output, it is interesting to use the `ClassCache`
    adapter to cache the output of the single method that generates this output. And
    we also know our `LongOutput` model has no output that changes, we can safely
    cache the output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有这个非常长的输出，使用`ClassCache`适配器来缓存生成此输出的单个方法输出是很有趣的。我们还知道我们的`LongOutput`模型没有改变输出的内容，我们可以安全地缓存输出。
- en: For this caching method to work we need to make sure that the configuration
    cache has been turned off, otherwise it will end up in a PHP error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种缓存方法工作，我们需要确保配置缓存已被关闭，否则它将导致PHP错误。
- en: 'We are going to change `module.config.php` in the `Application` module first
    to initialize our cache storage adapter first. After that we will change the `Application\Controller\IndexController`
    so that we can use our pattern. We can just add the following code to `/module/Application/config/module.config.php`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将更改`Application`模块中的`module.config.php`，以初始化我们的缓存存储适配器。之后，我们将更改`Application\Controller\IndexController`，以便我们可以使用我们的模式。我们只需将以下代码添加到`/module/Application/config/module.config.php`：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we have initialized our cache, we need to make sure our output is cached
    as well. This will be done in `IndexController` (`/module/Application/src/Application/Controller/IndexController.php`)
    of our `Application` module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了缓存，我们需要确保我们的输出也被缓存。这将在我们的`Application`模块的`IndexController`（`/module/Application/src/Application/Controller/IndexController.php`）中完成：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we now take a look at the benchmarking, we can see that the following caching
    has resulted in the following performance improvement:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看基准测试，我们可以看到以下缓存导致了以下性能提升：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see this is almost a 17.4 percent improvement on the original benchmark,
    which obviously is a fantastic improvement. It is also a 3.2 percent response
    increase in comparison to the configuration/class map caching. We know that this
    doesn't sound too impressive, and we understand your disappointment. However,
    do understand that in real life a database call or a service call can take a lot
    longer than this, and the percentage of improvement therefore would be much more!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这几乎是在原始基准测试上提高了17.4%，这显然是一个巨大的改进。它也比配置/类映射缓存提高了3.2%的响应速度。我们知道这听起来并不太令人印象深刻，我们也理解你的失望。然而，请理解，在现实生活中，数据库调用或服务调用可能比这长得多，因此改进的百分比会更大！
- en: There is only one slight issue with this method; and that is we won't be able
    to cache the configuration/class map this way. Because we want to optimize our
    application the best we can, this is obviously not good practice. Don't panic,
    however, there is a solution to this issue, and it comes in the form of `StorageCacheFactory`!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只有一个小问题；那就是我们不会以这种方式缓存配置/类映射。因为我们想尽可能优化我们的应用程序，这显然不是好的做法。但是，不要慌张，这个问题有一个解决方案，它以`StorageCacheFactory`的形式出现！
- en: We didn't immediately discuss this because it is always best to see more than
    one way of coding, at least that is my personal choice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有立即讨论这个问题，因为最好看到不止一种编码方式，至少这是我的个人选择。
- en: 'What we''ll do is strip the configuration we just added in `/module/Application/config/module.config.php`
    and add the following configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要移除在`/module/Application/config/module.config.php`中添加的配置，并添加以下配置：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we now turn back on the configuration and class map caching and do a benchmark,
    we get the following result.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在回过头来对配置和类映射缓存进行基准测试，我们会得到以下结果。
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see this time with both caching systems enabled, we get a 21 percent
    speed increase in comparison to the original.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这次在两个缓存系统都启用的情况下，与原始版本相比，我们得到了21%的速度提升。
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is always good to cache the things we use regularly and are sure about their
    persistence. If we know a class's output doesn't change, but for example merely
    does some calculations we know that it will be a strong candidate to use for caching.
    Don't forget that caching methods which rely on third party input, such as databases,
    are harder to cache as they require a certain time-to-live in which the cache
    knows the data they have cached is out-of-date.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总是缓存我们经常使用且确信其持久性的东西是很好的。如果我们知道一个类的输出不会改变，但例如仅仅做一些我们知道它会进行的计算，那么它将是一个很好的缓存候选者。不要忘记，依赖于第三方输入的缓存方法，如数据库，更难缓存，因为它们需要一定的存活时间，在这个时间内缓存知道它们缓存的这些数据已经过时。
- en: Another thing to look out for is to cache too much, that way your application
    actually slows down instead of speeding up as the cache is too busy refreshing/getting
    and setting the cache instead of actually outputting it. A good way of auto-cleaning
    and auto-optimizing however, is by setting up a periodic `cron` (much like scheduled
    tasks for Windows users) process that runs periodically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是缓存过多，这样实际上你的应用程序会变慢，而不是加快，因为缓存太忙于刷新/获取和设置缓存，而不是实际输出它。然而，设置一个周期性的`cron`（类似于Windows用户的计划任务）过程来进行自动清理和自动优化是一个好方法。
