- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Libraries and Class Syntax
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和类语法
- en: So far, we’ve only worked with Ruby and its core components without the advantage
    of other libraries that are available in Ruby. Additionally, we’ve only taken
    a partial peek at Ruby objects and classes. In this chapter, we will take a test
    drive with you to learn about Ruby libraries (gems) and how we can take advantage
    of the Gemfile to do so. Lastly, we’ll also learn the basics of class syntax to
    help us move toward more advanced tools, such as Ruby on Rails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用过 Ruby 及其核心组件，而没有利用 Ruby 中可用的其他库的优势。此外，我们只对 Ruby 对象和类进行了部分了解。在本章中，我们将与您一起进行一次测试驾驶，了解
    Ruby 库（gem）以及如何利用 Gemfile 来利用它们。最后，我们还将学习类语法的基础知识，以帮助我们迈向更高级的工具，例如 Ruby on Rails。
- en: 'With that in mind, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，在本章中，我们将涵盖以下主题：
- en: Let’s get ready to bundle!!!
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们准备好打包吧！！！
- en: Gemfile versus `composer.json`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gemfile 与 `composer.json` 的比较
- en: Integrating libraries into your code in Ruby
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ruby 中将库集成到代码中
- en: Declaring classes in Ruby
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ruby 中声明类
- en: Objects in Ruby
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 中的对象
- en: Inheritance in Ruby
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 中的继承
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along this chapter, we will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，我们需要以下内容：
- en: Any IDE to view/edit code (e.g., SublimeText, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 IDE 用于查看/编辑代码（例如，SublimeText，Visual Studio Code，Notepad++，Vim，Emacs 等）
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您还需要安装 Xcode 命令行工具
- en: Ruby version 2.6 or later installed and ready to use
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Ruby 版本 2.6 或更高版本，并准备好使用
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)找到。
- en: Let’s get ready to bundle!!!
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们准备好打包吧！！！
- en: Programming languages by themselves, while useful, can’t take into account every
    single use case that a programmer might encounter. The core of the language includes
    many useful libraries, so out of the box, the language is quite useful. This is
    true for most programming languages. However, there comes a time when we need
    to go beyond the core library and use other libraries to solve our issues at hand.
    In Ruby, the community has created a number of libraries, fondly named *gems*.
    To keep track of these gems, the Ruby community has come up with a tool called
    *bundler*. To season PHP developers, the PHP counterpart for the bundler is Composer
    ([https://getcomposer.org/](https://getcomposer.org/)). The two work for the same
    purpose (managing libraries), but bundler works slightly differently in that it
    installs the libraries in the computer, while Composer merely makes them available
    for your project. But wait – we haven’t even installed a library yet. Let’s take
    a step back and install a Ruby gem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言本身，虽然有用，但无法考虑到程序员可能遇到的每一个单一用例。语言的核心包括许多有用的库，因此开箱即用，语言本身就非常实用。这适用于大多数编程语言。然而，当我们需要超越核心库并使用其他库来解决手头的问题时，就会出现这种情况。在
    Ruby 中，社区已经创建了许多库，这些库被亲切地称为 *gems*。为了跟踪这些 gems，Ruby 社区想出了一个名为 *bundler* 的工具。对于
    PHP 开发者来说，bundler 的 PHP 对应物是 Composer ([https://getcomposer.org/](https://getcomposer.org/))。这两个工具都服务于相同的目的（管理库），但
    bundler 在安装库到计算机上时有所不同，而 Composer 只是使它们对项目可用。但是等等——我们甚至还没有安装一个库。让我们退一步，安装一个 Ruby
    gem。
- en: Installing a gem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 gem
- en: 'Before letting bundler take over, we should understand what and how to install
    gems on our system. Ruby has the ability to parse JSON objects, but there is a
    gem called `oj` that is more efficient in handling JSON strings and converting
    them to Ruby hashes. Let’s first install the `oj` gem. In a shell, let’s type
    the following commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bundler 接管之前，我们应该了解在我们的系统上安装 gem 的什么和如何操作。Ruby 有解析 JSON 对象的能力，但有一个名为 `oj`
    的 gem 在处理 JSON 字符串并将它们转换为 Ruby 哈希方面更为高效。让我们首先安装 `oj` gem。在 shell 中，让我们输入以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We should get the following output after running the preceding command and
    pressing the *Enter* key:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下 *Enter* 键后运行前面的命令，我们应该得到以下输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Congratulations! We have installed our first gem and are now ready to use it
    within our code. Let’s put this gem to the test by creating a file called `reading_json.rb`
    and adding the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经安装了我们的第一个 gem，现在可以在代码中使用它了。让我们通过创建一个名为 `reading_json.rb` 的文件并添加以下代码来测试这个
    gem：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s go back to our shell and try to execute the following script:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 shell 中，尝试执行以下脚本：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will get the following error:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下错误：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Why is our script failing? Well, we installed our gem and did not get any errors
    while doing so. As it turns out, we not only need to install our gem but also
    need to import it within our code. Let’s do that at the beginning of our file,
    so our code will now look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们的脚本会失败？嗯，我们安装了我们的gem，并且在安装过程中没有出现任何错误。实际上，我们不仅需要安装我们的gem，还需要在我们的代码中导入它。让我们在文件的开始处做这件事，这样我们的代码现在看起来就像这样：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, let’s execute our script again with the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们再次执行我们的脚本，使用以下命令：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will get the correct output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将得到正确的输出：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we’ve converted a JSON string into a Ruby hash, and it is now
    ready to be used within our script. This is useful when loading configuration
    from a JSON file or when processing an API call that returns a JSON response.
    However, there is one issue that we have not dealt with yet. How can we make sure
    that other people who use our script will have the same results? Well, this is
    the cue for both bundler and the Gemfile to enter our scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将JSON字符串转换成了Ruby哈希，现在它已经准备好在我们的脚本中使用。这在从JSON文件加载配置或处理返回JSON响应的API调用时非常有用。然而，我们还没有处理一个问题。我们如何确保使用我们脚本的其他人会得到相同的结果？嗯，这就是bundler和Gemfile进入场景的提示。
- en: Gemfile versus composer.json
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gemfile与composer.json的比较
- en: 'As I mentioned before, bundler helps us handle all our program’s dependencies
    – that is, everything we need to install in order for our program to run correctly.
    To accomplish this, bundler uses a text file, which we will call a `Gemfile`.
    Composer works in a very similar way by having us create a file called `composer.json`,
    but while Composer downloads the required libraries into a folder, bundler installs
    them on our system. If bundler determines that a dependency is missing, it will
    automatically try to install it. Ruby’s way is a bit more magical (or automatic).
    Let’s take bundler for a test drive to understand the process a little further.
    We will start by uninstalling our previously installed `oj` gem with the following
    command in the shell:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，bundler帮助我们处理我们程序的所有依赖项——也就是说，我们需要安装的所有内容，以便我们的程序能够正确运行。为了完成这项任务，bundler使用一个文本文件，我们将称之为`Gemfile`。Composer以非常相似的方式工作，通过让我们创建一个名为`composer.json`的文件，但与Composer将所需的库下载到文件夹不同，bundler将它们安装到我们的系统上。如果bundler确定缺少依赖项，它将自动尝试安装它。Ruby的方式有点更神奇（或自动）。让我们通过测试bundler来进一步了解这个过程。我们将首先使用shell中的以下命令卸载之前安装的`oj`gem：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command will confirm when the gem is removed from our system:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将确认当gem从我们的系统中移除时：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if we try to run our `reading_json.rb` again, we will get the following
    error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次尝试运行我们的`reading_json.rb`，我们将得到以下错误：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are back to where we started, but now we will solve our library (or gem)
    installation with a Gemfile. Let’s create a file called `Gemfile` with the following
    content:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了起点，但现在我们将用Gemfile来解决我们的库（或gem）安装问题。让我们创建一个名为`Gemfile`的文件，内容如下：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this, we tell bundler where to download the dependencies and what our
    dependencies are. We could tell bundler other things, such as the gem version
    or even what Ruby version (or equivalent) to use, but for now, we’ll keep it simple.
    Now, let’s try it. On a shell, let’s type the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们告诉bundler在哪里下载依赖项以及我们的依赖项是什么。我们可以告诉bundler其他事情，比如gem版本或甚至要使用的Ruby版本（或等效版本），但现在我们将保持简单。现在，让我们试试。在shell中，让我们输入以下命令：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Depending on the operating system that you’re using, you may need to type your
    root or administrator password, but once you do, the output of the command should
    be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您所使用的操作系统，您可能需要输入您的root或管理员密码，但一旦您完成，命令的输出应该如下所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that our gem is installed, we can safely run our script again with the
    following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了gem，我们可以安全地再次使用以下命令运行我们的脚本：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We should get the exact same output as before:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到与之前完全相同的输出：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, now we will notice something slightly different. If we look at the
    contents of the folder where we have our script and the Gemfile, we also have
    a new file called `Gemfile.lock`. Also, if we look at the contents, there should
    be something similar to this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们会注意到一些细微的差别。如果我们查看我们脚本和Gemfile所在的文件夹的内容，我们还有一个新文件叫做`Gemfile.lock`。此外，如果我们查看内容，应该会有类似以下的内容：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Gemfile.lock` file serves as a map of dependencies. If there is no map,
    bundler has to build it from scratch, and this process sometimes takes a while.
    However, if there is a lock file, even if the dependencies have not been installed,
    the process of installing them is much more efficient.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gemfile.lock`文件充当依赖关系的地图。如果没有地图，bundler必须从头开始构建它，这个过程有时会花费一些时间。然而，如果有锁文件，即使依赖项尚未安装，安装它们的过程也会更加高效。'
- en: We’ve come a long way from just installing a gem to now creating the ideal scenario
    for our script to run. In the next section, we’ll look at additional options (such
    as using a specific version of a gem) that we can set with our Gemfile to add
    further specificity to our Ruby environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从仅仅安装gem发展到现在为我们的脚本运行创建理想的场景。在下一节中，我们将探讨我们可以通过Gemfile设置的额外选项（例如使用gem的特定版本），以进一步明确我们的Ruby环境。
- en: Integrating libraries into your code in Ruby
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ruby中将库集成到你的代码中
- en: 'One of the most useful skills you should acquire in your path to becoming a
    seasoned Ruby developer is integrating other gems into your code. As we’ve seen
    before, this is accomplished by using the Gemfile, but we’ll look at some additional
    options we can add to it and integrate them into our own scripts. Let’s write
    a script that takes the GitHub public API and lists all of the public repos for
    the user `@PacktPublishing`. There are several ways we could do this, but for
    this example, I’ve chosen a gem called **Faraday**. You can take a look at the
    source code here: [https://github.com/lostisland/faraday](https://github.com/lostisland/faraday).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成为资深Ruby开发者的道路上，应该掌握的一项最有用的技能是将其他gem集成到你的代码中。正如我们之前所看到的，这是通过使用Gemfile来实现的，但我们将探讨一些可以添加到其中的额外选项，并将它们集成到我们自己的脚本中。让我们编写一个脚本，它使用GitHub公共API并列出用户`@PacktPublishing`的所有公共仓库。我们可以用几种方法来做这件事，但在这个例子中，我选择了一个名为**Faraday**的gem。你可以在这里查看源代码：[https://github.com/lostisland/faraday](https://github.com/lostisland/faraday)。
- en: 'Faraday is a client library that can help us make `Net::HTTP` library that
    comes with Ruby. Let’s create a folder called `integrating_gems` and navigate
    to that folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Faraday是一个客户端库，可以帮助我们使用Ruby附带的自带的`Net::HTTP`库。让我们创建一个名为`integrating_gems`的文件夹，并导航到该文件夹：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s create a file called `Gemfile` with the following content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`Gemfile`的文件，其内容如下：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before installing these gems, I’d like to use more options available in the
    Gemfile syntax. We’re going to lock the Faraday version at 2.5, which simply means
    that we install a specific version. So, let’s change the Faraday line to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装这些gem之前，我想使用Gemfile语法中可用的更多选项。我们将锁定Faraday的版本为2.5，这意味着我们安装一个特定的版本。所以，让我们将Faraday行更改为以下内容：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Locking to a version has, of course, its advantages and its disadvantages.
    Among the advantages is that you can be sure that the script will work the same
    way, with usually the same syntax, in several environments. The downside is that
    you probably would be locked to a Ruby version, and you could end up in a scenario
    where you won’t be able to upgrade Ruby until you upgrade the gem. For the `oj`
    gem, we will use the `~` operator and set it to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将版本锁定当然有其优点和缺点。优点之一是你可以确信脚本将以相同的方式，通常使用相同的语法，在多个环境中工作。缺点可能是你可能会被锁定在某个Ruby版本上，你可能会陷入无法升级Ruby直到升级gem的场景。对于`oj`gem，我们将使用`~`运算符并将其设置为以下内容：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `~` operator is used to delimit ranges of versions. In this specific case,
    we tell bundler to get the highest released version between 3.13.0 and 3.14, excluding
    3.14 – in other words, we require a version larger or equal to 3.13 but less than
    3.14\. So, why use this operator? Well, in short, the `~` operator is used to
    increase stability within our dependencies. I won’t go into depth as to why we
    would use this syntax. Just know that you will encounter it sooner or later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`~`运算符用于界定版本范围。在这个特定的情况下，我们告诉bundler获取3.13.0和3.14之间的最高发布版本，不包括3.14 - 换句话说，我们需要一个大于或等于3.13但小于3.14的版本。那么，为什么使用这个运算符呢？简而言之，`~`运算符用于在我们依赖关系中增加稳定性。我不会深入解释为什么我们会使用这种语法。只需知道你迟早会遇到它。'
- en: 'Should you want to dig deeper into this topic, please refer to the following
    links:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解这个话题，请参考以下链接：
- en: '[https://thoughtbot.com/blog/rubys-pessimistic-operator](https://thoughtbot.com/blog/rubys-pessimistic-operator)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://thoughtbot.com/blog/rubys-pessimistic-operator](https://thoughtbot.com/blog/rubys-pessimistic-operator)'
- en: '[https://guides.rubygems.org/patterns/#declaring_dependencies](https://guides.rubygems.org/patterns/#declaring_dependencies)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://guides.rubygems.org/patterns/#declaring_dependencies](https://guides.rubygems.org/patterns/#declaring_dependencies)'
- en: 'Our Gemfile will now look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的Gemfile将看起来像这样：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s install our dependencies again with bundler. On a shell, type in
    the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次使用bundler安装我们的依赖项。在shell中输入以下命令：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll get output similar to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似以下的输出：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, with our gems ready, we can use them in our script. Let’s create a script
    called `faraday_example.rb` with the following content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了我们的gem准备就绪，我们可以在脚本中使用它们。让我们创建一个名为`faraday_example.rb`的脚本，内容如下：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s take a step back and see what we are doing. We’re importing the `faraday`
    and `oj` gems. Then, we’re creating a client that will connect to the GitHub API.
    The client object requires a URL and some headers, which we provided. So far,
    we have not called the API yet. Let’s do that. At the end of the file, add the
    call to the API and output the response with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步看看我们在做什么。我们正在导入`faraday`和`oj`gem。然后，我们创建了一个将连接到GitHub API的客户端。客户端对象需要一个URL和一些头信息，我们已经提供了。到目前为止，我们还没有调用API。让我们这样做。在文件末尾添加对API的调用，并使用以下内容输出响应：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s try to execute this script with the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用以下内容执行此脚本：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will output a lot of text, so I’m going to include only an excerpt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出大量文本，所以我只会包括一个摘录：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With that output, we can confirm that we have successfully connected to the
    GitHub API. For the last part of the exercise, let’s use the `oj` gem to convert
    the JSON text to a Ruby hash and output the names of all of the responses that
    the API returned. So, let’s remove the `puts` command and replace it with an `oj`
    object. Our code will look like this now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个输出，我们可以确认我们已经成功连接到GitHub API。对于练习的最后部分，让我们使用`oj`gem将JSON文本转换为Ruby哈希，并输出API返回的所有响应的名称。所以，让我们删除`puts`命令，并用`oj`对象替换它。我们的代码现在将如下所示：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, we’ve taken the response from the GitHub API service and converted it to
    a Ruby hash. Lastly, let’s output the names of the repos by adding the following
    to the end of the script:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经从GitHub API服务中获取了响应并将其转换为Ruby哈希。最后，让我们通过在脚本末尾添加以下内容来输出repo的名称：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the script one last time, an excerpt from the output will look like
    this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行脚本，输出的一部分将看起来像这样：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With that, we’ve successfully connected to an API with the Faraday gem and
    processed the output with the `oj` gem. For reference, this is what the code should
    ultimately look like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功使用Faraday gem连接到API，并使用`oj`gem处理了输出。为了参考，代码最终应该看起来像这样：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is the starting point for how to share code to be run in other environments.
    Should we want others to be able to run our script, we should include both the
    script and the Gemfile with our shared code so that others know what needs to
    be installed before running the scripts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在其他环境中运行代码的起点。如果我们想让其他人能够运行我们的脚本，我们应该将脚本和Gemfile一起包含在我们的共享代码中，这样其他人就知道在运行脚本之前需要安装什么。
- en: Also, just so you know, this was merely an exercise to learn how to include
    and use gems within our code. The syntax on the Gemfile was only procured for
    learning purposes. You should always aspire to have the latest version of a gem.
    However, locking to a version is useful when you want to have control of when
    and where you do upgrades.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，只是让您知道，这仅仅是一个练习，目的是学习如何在代码中包含和使用gem。Gemfile上的语法只是为了学习目的而获取的。您应该始终追求拥有gem的最新版本。然而，锁定到一个版本在您想要控制升级的时间和地点时是有用的。
- en: Now that we’ve established how gems work and their usage, we can now move on
    to object-oriented programming in Ruby.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了gem的工作原理及其使用方法，现在我们可以继续学习Ruby中的面向对象编程。
- en: Declaring classes in Ruby
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中声明类
- en: Both PHP and Ruby are languages that use the **Object-Oriented Programming**
    (**OOP**) paradigm, Ruby by design and PHP by its own evolution. By now, serious
    developers should be very familiar with the paradigm. In PHP, all frameworks use
    OOP. While we are not going to go in depth into how this paradigm is implemented
    in Ruby, we will go through the basics of class syntax.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PHP和Ruby都是使用**面向对象编程**（**OOP**）范式的语言，Ruby是设计如此，PHP则是通过其自身的发展。到目前为止，严肃的开发者应该非常熟悉这种范式。在PHP中，所有框架都使用OOP。虽然我们不会深入探讨这种范式在Ruby中的实现方式，但我们会介绍类语法的基础知识。
- en: 'A class is basically an abstraction of a real-world entity. It is the blueprint
    of this abstraction. Let’s start by creating a simple class representing a person,
    some attributes for this person, and an action (or method) for them. Let’s create
    a file called `class_syntax.rb` with the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类基本上是对现实世界实体的抽象。它是这个抽象的蓝图。让我们先创建一个简单的类来表示一个人，为这个人定义一些属性，以及为他们定义一个动作（或方法）。让我们创建一个名为
    `class_syntax.rb` 的文件，并包含以下内容：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is as simple as it gets, but this by itself is not very useful. For this
    to be useful, we need to add attributes that represent the characteristics of
    a person. So, let’s add some attributes such as their first name and their last
    name. Our code will now look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的了，但仅凭这一点并不很有用。为了使其有用，我们需要添加代表人的特征的属性。所以，让我们添加一些属性，比如他们的名字和姓氏。我们的代码现在将看起来像这样：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that we have defined our attributes by prepending them with `@`. These
    are called instance variables and can only be accessed by a method. Now, let’s
    define a method to print out the full name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过在它们前面加上 `@` 来定义我们的属性。这些被称为实例变量，并且只能通过方法来访问。现在，让我们定义一个方法来打印出全名：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the exception of the instance variable, note that we are not doing anything
    we have not learned before. We defined a method (or function), and we included
    the first and last name variables on the string to be printed by the method. One
    last thing we will do to this blueprint is add a constructor. In OOP, a constructor
    is a method that can be customized to add behaviors and attributes when we create
    an object with a class definition. In other words, when we take the blueprint,
    we define and use it to create a specific object, and we can control certain values
    at the time of creation of the object. In PHP, this method is implemented by simply
    naming the method `__constructor()`. Its equivalent in Ruby is naming the method
    `initialize()`. Let’s now include it in our class definition. Our class definition
    should look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例变量之外，注意我们之前没有做过任何我们没有学过的事情。我们定义了一个方法（或函数），并在方法要打印的字符串上包含了名字和姓氏变量。我们最后要做的最后一件事是添加一个构造函数。在面向对象编程中，构造函数是一个可以在使用类定义创建对象时自定义以添加行为和属性的方法。换句话说，当我们拿蓝图时，我们定义并使用它来创建一个特定的对象，我们可以在对象创建时控制某些值。在PHP中，这个方法是通过简单地命名方法为
    `__constructor()` 来实现的。在Ruby中的等效方法是命名方法为 `initialize()`。现在让我们将其包含在我们的类定义中。我们的类定义应该看起来像这样：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we no longer need the instance variable definition, as this is done
    on the constructor (initializer). Congratulations! Our first class is ready to
    be used. Let’s now move on to the next section to create our first object using
    this class definition.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再需要实例变量定义，因为这是在构造函数（初始化器）中完成的。恭喜！我们的第一个类已经准备好使用了。现在让我们继续到下一节，使用这个类定义来创建我们的第一个对象。
- en: Objects in Ruby
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的对象
- en: 'In the previous section, we defined what our abstraction of a person should
    look like. It is a person that will have a first name and a last name, and we
    will be able to print out their full name. In parallel to the construction business,
    since we now have a blueprint, we are now ready to erect our building with these
    specifications. This creation is what we call an instance or an object of a class.
    The class definition is generic and the instance is specific. Without going too
    deep into this relationship between a class definition and an object, we’ll take
    a look at what this relationship looks like in code and how this will help us
    make better and more readable code. Let’s take our previous code and create our
    first object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们定义了我们的抽象人应该是什么样子。这是一个将有一个名字和一个姓氏的人，我们将能够打印出他们的全名。与建筑业务并行，因为我们现在有了蓝图，我们现在可以按照这些规格建造我们的建筑了。这种创建就是我们所说的类的实例或对象。类定义是通用的，而实例是具体的。不深入探讨类定义和对象之间的关系，我们将看看代码中这种关系看起来是什么样子，以及这将如何帮助我们编写更好、更易读的代码。让我们用我们之前的代码创建我们的第一个对象：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’ve now created a specific person based on our class, and we are now ready
    to call some of the methods for that person. We can now call the `full_name()`
    method. Let’s do that by adding the following line to the end of our file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在根据我们的类创建了一个特定的人，我们现在可以调用这个人的某些方法了。我们现在可以调用 `full_name()` 方法。让我们通过在文件的末尾添加以下行来实现这一点：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s run our script again from the shell with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在shell中再次运行我们的脚本，如下所示：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we should get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该得到以下输出：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And voilà! We’ve finally given our class a more practical use. We are now able
    to create as many objects (persons) as we want with the class definition. However,
    we still have an issue. Our class only lets us create persons that are named James
    Raynor. We wanted specificity, but this turned out to be too specific. We need
    to modify our class so that we can create more generic objects. So, let’s do that
    by adding parameters to our constructor. Our code will now look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们终于给了我们的类一个更实用的用途。现在，我们可以使用类定义来创建任意数量的对象（人）。然而，我们仍然有一个问题。我们的类只允许我们创建名为James
    Raynor的人。我们想要的是具体性，但结果却过于具体。我们需要修改我们的类，以便我们可以创建更通用的对象。所以，让我们通过向构造函数添加参数来实现这一点。我们的代码现在将看起来像以下这样：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’ve added two parameters to our constructor method. The first name we pass
    to our class will be assigned to our instance variable, `@first_name`, so that
    it will be available to other methods. The same goes for the last name. An additional
    adjustment that we must make now is to pass the first and last names to our constructor.
    So, let’s do that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向构造函数方法添加了两个参数。我们传递给类的第一个名字将被分配给我们的实例变量`@first_name`，这样它就可以供其他方法使用。对于姓氏也是如此。我们现在必须做出的额外调整是将第一个和最后一个名字传递给构造函数。所以，让我们这么做：
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can create as many instances (or objects) as we want. Let’s add two
    more people:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建任意数量的实例（或对象）。让我们再添加两个人：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s run our script on our shell:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的shell上运行我们的脚本：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output will be the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是以下内容：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve made our blueprint more generic, and we can now create different characters
    from that blueprint.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使我们的蓝图更通用，现在我们可以从这个蓝图创建不同的角色。
- en: Before moving on to our next topic inheritance, I want us to take a look at
    a class tool that you will encounter in the future and that you’ll find extremely
    useful – attribute accessors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个主题继承之前，我想让我们看看你将来会遇到的一个非常有用的类工具——属性访问器。
- en: Attribute accessors
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性访问器
- en: 'In our class definition, we have the `first_name` and `last_name` attributes,
    and we also have a `full_name()` method. However, what if we wanted to output
    the person’s first name? We might be tempted to try the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类定义中，我们拥有`first_name`和`last_name`属性，同时还有一个`full_name()`方法。然而，如果我们想输出一个人的名字呢？我们可能会尝试以下做法：
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, this would fail miserably with the following error:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会以以下错误惨败：
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is where Ruby deviates from how PHP would look or behave. Ruby can apparently
    have a method and an attribute with the same name. While this is not technically
    true, let’s for argument’s sake say that it is so that we can momentarily move
    forward with the exercise. Let’s create a method called `first_name`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Ruby与PHP在外观或行为上的不同之处。Ruby显然可以有一个方法和一个具有相同名称的属性。虽然这从技术上讲并不正确，但为了辩论的需要，让我们假设这是真的，这样我们就可以暂时继续这个练习。让我们创建一个名为`first_name`的方法：
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The method looks strange, but let’s remember that Ruby doesn’t need us to explicitly
    return a value as it does it automatically. So, the method is simply returning
    the value contained in `@first_name`. While useful, we would have to do this for
    every attribute we defined. Additionally, we only created the method to obtain
    the value. We would also need to create a method to set the value. However, I
    have some good news for you. Ruby has already solved this issue with attribute
    accessors. An attribute accessor automatically creates the methods to get and
    set the value. We only need to indicate which attribute we want this “magic” to
    have. Let’s define the attribute accessors and then exploit them. Our final code
    should look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法看起来很奇怪，但让我们记住，Ruby不需要我们显式地返回一个值，因为它会自动完成。所以，这个方法只是返回`@first_name`中包含的值。虽然很有用，但我们必须为每个定义的属性都这样做。此外，我们只创建了方法来获取值。我们还需要创建一个方法来设置值。然而，我有好消息要告诉你。Ruby已经通过属性访问器解决了这个问题。属性访问器会自动创建获取和设置值的方法。我们只需要指出我们想要这个“魔法”作用于哪个属性。让我们定义属性访问器，然后利用它们。我们的最终代码应该看起来像这样：
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s run it again with the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用以下命令运行它：
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should get the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下输出：
- en: '[PRE50]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note how we did not have to define the `last_name` method, and yet it’s available.
    At some point in your path towards learning Ruby, I guarantee you will encounter
    the `attr_accessor` tool. Ruby also has `attr_reader` and `attr_writer`, which
    separate into two methods what `attr_accessor` does by itself. Should you want
    to go more in depth into attribute accessors, what they do exactly, and see other
    examples, you may want to visit [https://www.rubyguides.com/2018/11/attr_accessor/](https://www.rubyguides.com/2018/11/attr_accessor/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不需要定义`last_name`方法，但它仍然可用。在你学习Ruby的道路上，我保证你会在某个时候遇到`attr_accessor`工具。Ruby还有`attr_reader`和`attr_writer`，它们将`attr_accessor`本身做的两件事分开成两个方法。如果你想更深入地了解属性访问器，了解它们的确切作用，并查看其他示例，你可能想访问[https://www.rubyguides.com/2018/11/attr_accessor/](https://www.rubyguides.com/2018/11/attr_accessor/)。
- en: Are you ready to make more powerful classes? Then, let’s hop to the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好创建更强大的类了吗？那么，让我们跳到下一节。
- en: Inheritance in Ruby
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的继承
- en: So far, we’ve looked at a few features that come with Ruby’s implementation
    of the OOP paradigm, but we have neglected to look at one of the core features
    that help us recycle code. Inheritance can be simplified as the practice of passing
    the features of a class to create a brand-new child class. With this new class,
    we can use any of the features from the parent class, create new features, or
    customize the features that come from the parent class. The syntax for inheritance
    can be quite different than in PHP, but the behavior is quite similar. With that
    in mind, let’s take a look at a few use cases and see it in action.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了Ruby实现面向对象范式的一些特性，但我们忽略了一个核心特性，它有助于我们重用代码。继承可以简化为将一个类的特性传递给创建一个新的子类。有了这个新类，我们可以使用父类中的任何特性，创建新的特性，或者自定义从父类继承的特性。继承的语法可能和PHP中的语法大不相同，但行为却非常相似。考虑到这一点，让我们看看一些用例，并看看它是如何工作的。
- en: Let’s say we wanted a class that would let us connect to a database. Instead
    of having to write all the functionality to connect to a database, we could get
    an already created database class, create a new one that inherited all the database
    functionality, and then focus on creating just the features that we need. This
    is one way to reuse code with inheritance, but let’s use a simpler example so
    that we can see inheritance in practice. Let’s say we wanted to make an abstraction
    of a user. The user must have first name, last name, age, and email details. We
    can take the `Person` class, defined in the previous section, inherit the features
    in our new `User` class, and just focus on the missing pieces.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个可以让我们连接到数据库的类。而不是必须编写所有连接到数据库的功能，我们可以获取一个已经创建的数据库类，创建一个新的类，它继承了所有的数据库功能，然后只专注于创建我们需要的特性。这是使用继承重用代码的一种方式，但让我们用一个更简单的例子来展示继承的实际应用。假设我们想要创建一个用户抽象。用户必须具有名字、姓氏、年龄和电子邮件详情。我们可以从上一节中定义的`Person`类继承特性，并在新的`User`类中只关注缺失的部分。
- en: 'So, let’s take our `Person` class and create a file called `inheritance_example.rb`
    with the following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们将我们的`Person`类取名为`inheritance_example.rb`并创建一个包含以下内容的文件：
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let’s create a new class below our original class called `User` and inherit
    from the `Person` class. We’ll do this with the `<` operator. Let’s add this to
    the end of our `Person` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在原始类下面创建一个新的类，名为`User`，并从`Person`类继承。我们将使用`<`操作符来完成这个操作。让我们将以下内容添加到`Person`类的末尾：
- en: '[PRE52]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With just two lines of code, we’ve made a brand-new class that behaves (for
    now) in the exact same way as the `Person` class. Let’s confirm that by creating
    a new `User` object. Let’s now add the following to the end of our file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 只用两行代码，我们就创建了一个全新的类，它现在（暂时）的行为与`Person`类完全相同。让我们通过创建一个新的`User`对象来确认这一点。现在，让我们将以下内容添加到文件的末尾：
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s try to run this script from our shell:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在我们的shell中运行这个脚本：
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This should output the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our script failed, but why? As we read through the message, it states that
    the constructor expected two parameters, but none were given. From our previous
    execution example, we can infer that we have to give our constructor the parameters
    for the first name and last name. So, let’s add those parameters, and let’s also
    call the `full_name()` method. Our code will now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本失败了，但为什么呢？当我们阅读错误信息时，它指出构造函数期望两个参数，但一个都没有提供。从我们之前的执行示例中，我们可以推断出我们必须给构造函数提供名字和姓氏的参数。所以，让我们添加这些参数，同时也要调用`full_name()`方法。我们的代码现在看起来是这样的：
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s run this script:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个脚本：
- en: '[PRE57]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The script will output the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将输出以下内容：
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So, we have confirmed that, out of the box, this newly created class has inherited
    all of its functionality from the `Person` class. Nowhere did we have to define
    the `full_name()` method, as it’s already available. Additionally, the constructor
    automatically assigned the first and last name to our `@first_name` and `@last_name`
    instance variables, respectively. Again, we only had to have this class inherit
    from the `Person` class. However, using the example that we provided at the beginning
    of this section, we want to add an additional attribute called `email`. So first,
    we will add an attribute accessor for the `email` attribute. Our `User` class
    now looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经确认，这个新创建的类已经从`Person`类继承了所有功能。我们根本不需要定义`full_name()`方法，因为它已经可用。此外，构造函数自动将名字和姓氏分配给了我们的`@first_name`和`@last_name`实例变量。再次强调，我们只需要让这个类从`Person`类继承。然而，使用本节开头提供的示例，我们想要添加一个额外的属性，称为`email`。所以首先，我们将为`email`属性添加一个属性访问器。现在我们的`User`类看起来是这样的：
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can now assign the `em.ail` attribute from our object with the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下方式为我们的对象分配`em.ail`属性：
- en: '[PRE60]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, what we want to do is include this assignment in the new `User` constructor.
    This is not as easy as it seems, but it’s not that difficult either. So, we first
    have to define a constructor for our new `User` class. Let’s do just that. Our
    `User` class will look like this now:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想要做的是将这个分配包含在新的`User`构造函数中。这并不像看起来那么容易，但也不是那么困难。所以，我们首先必须为我们的新`User`类定义一个构造函数。让我们就这样做。现在我们的`User`类看起来是这样的：
- en: '[PRE61]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, by doing this, we’ve overwritten the original constructor method (initializer).
    But do not despair, as the original constructor is still available via the `super()`
    method. The `super()` method calls the original constructor, but you must provide
    the original number of arguments. So, to finish this example, let’s again add
    the first name, last name, and email to our constructor and, finally, call the
    `super()` method. Our final code will look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过这样做，我们已经覆盖了原始的构造函数方法（初始化器）。但不要绝望，因为原始构造函数仍然可以通过`super()`方法访问。`super()`方法调用原始构造函数，但你必须提供原始的参数数量。所以，为了完成这个例子，我们再次将名字、姓氏和电子邮件添加到我们的构造函数中，并最终调用`super()`方法。我们的最终代码将如下所示：
- en: '[PRE62]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ve successfully used inheritance to reuse our `Person` class functionality
    and built a new class called `User`. When talking about classes using inheritance,
    you’ll hear the term hierarchy. When talking about hierarchy, we’re referring
    to the position on an imaginary structure of our classes where on the top, we
    will have the most generic class and on the bottom the most specific class. For
    this example, the hierarchical relationship between the `Person` class and the
    `User` class may start to make sense, with the `Person` class being the most generic
    class and thus the one on top. In other words, a user is a person; thus, the person
    must have the attributes of a user and a person. The opposite is not true. A person
    may no necessarily be a user. A person could be a client and have a different
    use case where we don’t need the email attribute. While designing your Ruby classes,
    if you take into account this hierarchy, it will be easier for you to determine
    what functionality should go where to write less code and not have issues with
    repeating unnecessary code. While this example is extremely simplified, it showed
    us how easy it is to build reusable classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用继承重用了`Person`类的功能，并创建了一个名为`User`的新类。当谈论使用继承的类时，你会听到术语“层次结构”。当我们谈论层次结构时，我们指的是我们类在想象中的结构中的位置，在最上面，我们将有最通用的类，在最下面是最具体的类。对于这个例子，`Person`类和`User`类之间的层次关系可能开始变得有意义，其中`Person`类是最通用的类，因此位于顶部。换句话说，用户是人；因此，人必须具有用户和人的属性。反之则不然。一个人不一定是用户。一个人可能是客户，并且有一个不同的用例，我们不需要电子邮件属性。在设计你的Ruby类时，如果你考虑到这个层次结构，这将使你更容易确定应该将哪些功能放在哪里，以编写更少的代码，并且不会出现重复不必要的代码的问题。虽然这个例子非常简化，但它向我们展示了构建可重用类是多么容易。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how Ruby libraries are installed, used, and named
    (gems). We also learned to use the bundler tool to install gems, creating environments
    for our scripts and programs to function correctly. Lastly, we learned the most
    basic OOP syntax to both create, instantiate, and inherit classes. Now, we are
    ready to start debugging.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何安装、使用和命名（gem）Ruby库。我们还学习了如何使用bundler工具安装gem，为我们的脚本和程序创建正确运行的环境。最后，我们学习了最基本的面向对象编程（OOP）语法，用于创建、实例化和继承类。现在，我们已准备好开始调试。
