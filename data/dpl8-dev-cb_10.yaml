- en: The Entity API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体 API
- en: 'In this chapter, we will explore the Entity API to create custom entities and
    see how they are handled and cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Entity API 以创建自定义实体，并了解它们是如何被处理和覆盖以下菜谱：
- en: Creating a configuration entity type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置实体类型
- en: Creating a content entity type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建内容实体类型
- en: Creating a bundle for a content entity type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为内容实体类型创建捆绑包
- en: Implementing custom access control for an entity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为实体实现自定义访问控制
- en: Providing a custom storage handler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供自定义存储处理程序
- en: Creating a route provider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建路由提供者
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In Drupal, entities are a representation of data that has a specific structure.
    There are specific entity types, which have different bundles and fields attached
    to those bundles. Bundles are implementations of entities that can have fields
    attached to themselves. In terms of programming, you can consider an entity that
    supports bundles as an abstract class and each bundle as a class that extends
    that abstract class. The fields are added to bundles. This is part of the reasoning
    for the terminology: an entity type can contain a *bundle* of fields.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 中，实体是具有特定结构的数据的表示。存在特定的实体类型，它们具有不同的捆绑包和附加到这些捆绑包的字段。捆绑包是实体的实现，可以附加字段。从编程的角度来看，可以将支持捆绑包的实体视为一个抽象类，每个捆绑包作为一个扩展该抽象类的类。字段被添加到捆绑包中。这也是术语的推理部分：实体类型可以包含一个
    *捆绑包* 的字段。
- en: 'An entity is an instance of an entity type defined in Drupal. Drupal 8 provides
    two entity types: `configuration` and `content`. Configuration entities are not
    fieldable and represent a configuration within a site. Content entities are fieldable
    and can have bundles. Bundles are, most commonly, controlled through configuration
    entities.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是 Drupal 中定义的实体类型的实例。Drupal 8 提供了两种实体类型：`configuration` 和 `content`。配置实体不可字段化，代表网站内的配置。内容实体可字段化，并且可以有捆绑包。捆绑包通常通过配置实体进行控制。
- en: In Drupal 8, there is an **Entity API** module. It was created in Drupal 7 to
    expand the entity subsystem; most of its functionalities from Drupal 7 are now
    in its core. The goal of the module is to develop improvements for the developer
    experience around entities by merging more functionalities into the Drupal core
    during each minor release cycle (8.1.x, 8.2.x, and so on). There will be a *There's
    more...* section in each recipe that relates to how the Entity API module can
    simplify the recipe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，有一个 **Entity API** 模块。它是在 Drupal 7 中创建的，用于扩展实体子系统；其大部分功能现在都已集成到
    Drupal 核心中。该模块的目标是通过在每个小版本发布周期（8.1.x、8.2.x 等）中将更多功能合并到 Drupal 核心中，来为开发者体验中的实体开发改进。每个菜谱中都会有一个
    *还有更多...* 部分，介绍如何使用 Entity API 模块简化菜谱。
- en: Creating a configuration entity type
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置实体类型
- en: Drupal 8 harnesses the entity API for configuration to provide configuration
    validation and extended functionality. Using the underlying entity structure,
    the configuration has a proper **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) process that can be managed. Configuration entities are not fieldable.
    All the attributes of a configuration entity are defined in its configuration
    schema definition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 利用实体 API 为配置提供配置验证和扩展功能。使用底层实体结构，配置有一个适当的 **创建**、**读取**、**更新** 和 **删除**（**CRUD**）过程，可以对其进行管理。配置实体不可字段化。配置实体的所有属性都定义在其配置架构定义中。
- en: Most common configuration entities interact with Drupal core's `config_object`
    type, as discussed in [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml),
    *Extending Drupal*, and [*Chapter 9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml),
    *Configuration Management - Deploying in Drupal 8*, to store and manage a site's
    configuration. There are other uses of configuration entities, such as menus,
    view displays, form displays, and contact forms, which are all configuration entities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的配置实体与 Drupal 核心的 `config_object` 类型交互，如在第 [*第 4 章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)
    “扩展 Drupal” 和 [*第 9 章*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml) “配置管理 - 在
    Drupal 8 中部署” 中所述，用于存储和管理网站的配置。配置实体还有其他用途，例如菜单、视图显示、表单显示和联系表单，这些都是配置实体。
- en: In this recipe, we will create a new configuration entity type called `SiteAnnouncement`.
    This will provide a simple configuration entity that allows you to create, edit,
    and delete simple messages that can be displayed on the site for important announcements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个新的配置实体类型，称为 `SiteAnnouncement`。这将提供一个简单的配置实体，允许您创建、编辑和删除可以在网站上显示的重要公告的简单消息。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a custom module to place code into to implement a configuration
    entity type. Let's create an `src` directory for your classes. Refer to the *Creating
    a module* recipe of [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml),
    *Extending Drupal*, for information on creating a custom module.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个自定义模块来放置代码以实现配置实体类型。让我们为你的类创建一个`src`目录。有关创建自定义模块的信息，请参阅[*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)的*创建模块*配方，*扩展Drupal*。
- en: Do not use a module that is currently installed, otherwise Drupal will not install
    your new entity type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用当前已安装的模块，否则Drupal将无法安装您的新实体类型。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In our module''s base directory, let''s create a `config` directory with a
    `schema` subdirectory. In the subdirectory, create a file named `mymodule.schema.yml`
    that will hold your configuration entity''s schema:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的模块的基本目录中，让我们创建一个`config`目录，并在其中创建一个名为`schema`的子目录。在子目录中，创建一个名为`mymodule.schema.yml`的文件，该文件将包含您的配置实体模式：
- en: '![](img/7f681496-40ae-46eb-adbe-0b7fbcfa1c68.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f681496-40ae-46eb-adbe-0b7fbcfa1c68.png)'
- en: 'In our `mymodule.schema.yml`, add a definition to `mymodule.announcement.*:`
    to provide our label and message storage:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`mymodule.schema.yml`中，为`mymodule.announcement.*:`添加一个定义以提供我们的标签和消息存储：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will define the configuration entity's namespace as an announcement, which
    we will provide to Drupal in the entity's annotation block. We will then tell
    Drupal that this is a `config_entity` and provide a label for the schema.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义配置实体命名空间为公告，我们将将其提供给Drupal的实体注解块。然后我们将告诉Drupal这是一个`config_entity`并提供模式标签。
- en: Using the mapping array, we will provide the attributes that make up our entity
    and the data that will be stored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射数组，我们将提供构成我们的实体和将要存储的数据的属性。
- en: 'Create an `Entity` directory in our module''s `src` folder. First, we will
    create an interface for our entity by creating a `SiteAnnouncementInterface.php`
    file. The `SiteAnnouncementInterface` interface will extend the `\Drupal\Core\Config\Entity\ConfigEntityInterface`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的模块的`src`文件夹中创建一个`Entity`目录。首先，我们将通过创建一个`SiteAnnouncementInterface.php`文件来为我们的实体创建一个接口。`SiteAnnouncementInterface`接口将扩展`\Drupal\Core\Config\Entity\ConfigEntityInterface`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will be implemented by our entity, and will provide the method requirements.
    It is best practice to provide an interface for entities. This allows you to provide
    the required methods if another developer extends your entity or if you are doing
    advanced testing and need to mock an object. We also provide a method to return
    our custom attribute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过我们的实体来实现，并提供方法要求。为实体提供一个接口是最佳实践。这允许你在其他开发者扩展你的实体或在进行高级测试并需要模拟一个对象时提供所需的方法。我们还提供了一个返回我们自定义属性的方法。
- en: 'Let''s create `SiteAnnouncement.php` in our `src/Entity` directory. This file
    will contain the `SiteAnnouncement` class, which extends `\Drupal\Core\Config\Entity\ConfigEntityBase`
    and implements our entity''s interface:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src/Entity`目录中创建`SiteAnnouncement.php`。此文件将包含`SiteAnnouncement`类，该类扩展`\Drupal\Core\Config\Entity\ConfigEntityBase`并实现我们的实体接口：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we added the `message` property defined in our schema
    as a class property. Our method defined in the entity's interface is used to return
    that value and interact with our configuration entity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了在模式中定义的`message`属性作为类属性。我们在实体接口中定义的方法用于返回该值并与我们的配置实体交互。
- en: 'Entities use annotation documentation blocks. We will start our annotation
    block by providing the entity''s ID, label, configuration prefix, and configuration
    export key names:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体使用注解文档块。我们将从提供实体ID、标签、配置前缀和配置导出键名称开始我们的注解块：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The annotation document block tells Drupal that this is an instance of the `ConfigEntityType`
    plugin. The `id` is the internal machine name identifier for the entity type,
    and the `label` is its human-readable version. The `config_prefix` matches how
    we defined our schema with `mymodule.announcement`. The entity keys definition
    tells Drupal the attributes that represent our identifiers and labels.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注解文档块告诉Drupal这是一个`ConfigEntityType`插件的实例。`id`是实体类型的内部机器名标识符，而`label`是其可读版本。`config_prefix`与我们使用`mymodule.announcement`定义的模式相匹配。实体键定义告诉Drupal代表我们的标识符和标签的属性。
- en: When specifying `config_export`, we are telling the configuration management
    system what properties are exportable when exporting our entity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定`config_export`时，我们正在告诉配置管理系统在导出我们的实体时哪些属性是可导出的。
- en: 'Next, we will add `handlers` to our entity''s annotation. We will define the
    class that will display the available entity entries and forms to work with our
    entity:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的实体注释添加`handlers`。我们将定义一个将显示可用实体条目和表单的类，以处理我们的实体：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `handlers` array specifies classes that provide the interaction functionality
    with our entity. The `list_builder` class will be created to show you a table
    of our entities. The `form` array provides classes for forms to be used when creating,
    editing, or deleting our configuration entity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers`数组指定了提供与我们的实体交互功能的类。`list_builder`类将被创建以显示我们的实体表。`form`数组提供了用于创建、编辑或删除我们的配置实体的表单的类。'
- en: 'Lastly, for our entity''s annotation, we will need to define routes for our
    `delete`, `edit`, and `collection` (list) pages. Drupal will automatically build
    the routes based on our annotation:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了我们的实体注释，我们需要为我们的`delete`、`edit`和`collection`（列表）页面定义路由。Drupal将根据我们的注释自动构建路由：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a routing service for entities that will automatically provide Drupal
    a route with the proper controllers based on this annotation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一个为实体提供路由服务的路由服务，它将自动根据此注释为Drupal提供具有适当控制器的路由。
- en: Create the `SiteAnnouncementListBuilder` class defined in our `list_builder`
    handler by creating a `SiteAnnouncementListBuilder.php` file in the module's `src`
    directory and extending the
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在模块的`src`目录中创建一个`SiteAnnouncementListBuilder.php`文件并扩展`\Drupal\Core\Config\Entity\ConfigEntityListBuilder`来创建在`list_builder`处理程序中定义的`SiteAnnouncementListBuilder`类：
- en: '`\Drupal\Core\Config\Entity\ConfigEntityListBuilder`:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Entity\EntityForm`:'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our list builder handler, we override the `buildHeader` and `builderRow`
    methods so that we can add our configuration entity's properties to the table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的列表构建器处理程序中，我们重写`buildHeader`和`builderRow`方法，以便我们可以将配置实体属性添加到表中。
- en: 'Now, we will need to create an entity form, as defined in our form handler
    array, to handle our add and edit functionalities. Create `SiteAnnouncementForm.php`
    in the `src` directory to provide the `SiteAnnouncementForm` class that extends
    the `\Drupal\Core\Entity\EntityForm` class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个实体表单，如我们的表单处理程序数组中定义的那样，以处理我们的添加和编辑功能。在`src`目录中创建`SiteAnnouncementForm.php`以提供扩展`\Drupal\Core\Entity\EntityForm`类的`SiteAnnouncementForm`类：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We override the `form` method to add Form API elements to our `label` and `message`
    properties. We also override the `save` method to provide user messages about
    the changes that are made. We utilize the entity's `toUrl` method to redirect
    it to the `collection` (list) page. We use the transliteration service to generate
    a machine name based on the label for our entity's identifier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`form`方法以向我们的`label`和`message`属性添加表单API元素。我们还重写`save`方法以提供关于所做的更改的用户消息。我们利用实体的`toUrl`方法将其重定向到`collection`（列表）页面。我们使用转写服务根据标签生成我们实体的标识符的机器名。
- en: 'Next, we will create a `mymodule.links.action.yml` file in our module''s directory.
    This will allow us to define action links on a route. We will be adding an `Add
    announcement` link to our entity''s add form on its collection route:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在模块目录中创建一个`mymodule.links.action.yml`文件。这将允许我们在路由上定义操作链接。我们将在实体的集合路由上添加一个`添加公告`链接到我们的实体添加表单：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will instruct Drupal to render the `entity.announcement.add_form` link
    on the specified routes in the `appears_on` value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示Drupal在`appears_on`值中指定的路由上渲染`entity.announcement.add_form`链接。
- en: 'To have our site announcement''s accessible from the main administrative pages,
    we will need to create a `mymodule.links.menu.yml` file in our module''s directory:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的网站公告可以从主管理页面访问，我们需要在模块目录中创建一个`mymodule.links.menu.yml`文件：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our module structure should look like the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模块的结构应该看起来像以下截图：
- en: '![](img/14dc493f-5880-49e2-9275-efc5dfe455c3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14dc493f-5880-49e2-9275-efc5dfe455c3.png)'
- en: Install the module and check out the Configuration page. You can now manage
    the `Site Announcement` entries from the Site Announcement link.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装模块并检查配置页面。现在，您可以从网站公告链接管理`Site Announcement`条目。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When creating a configuration schema definition, one of the first properties
    used for the configuration namespace is `type`. This value can be `config_object`
    or `config_entity`. When the type is `config_entity`, the definition will be used
    to create a database table rather than to structure the serialized data for the
    `config` table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建配置架构定义时，用于配置命名空间的第一个属性之一是`type`。此值可以是`config_object`或`config_entity`。当类型为`config_entity`时，定义将用于创建数据库表，而不是为`config`表结构化序列化数据。
- en: Entities are powered by the plugin system in Drupal, which means that there
    is a plugin manager. The default `\Drupal\Core\Entity\EntityTypeManager` provides
    discovery and handling of entities. The `ConfigEntityType` class for the entity
    type's plugin class will force the setting of the `uuid` and `langcode` in the
    `entity_keys` definition. The storage handler for configuration entities defaults
    to `\Drupal\Core\Config\Entity\ConfigEntityStorage`. The `ConfigEntityStorage`
    class interacts with the configuration management system to load, save, and delete
    custom configuration entities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实体由 Drupal 的插件系统提供支持，这意味着存在一个插件管理器。默认的`\Drupal\Core\Entity\EntityTypeManager`提供实体的发现和处理。实体类型的插件类的`ConfigEntityType`类将强制在`entity_keys`定义中设置`uuid`和`langcode`。配置实体的存储处理程序默认为`\Drupal\Core\Config\Entity\ConfigEntityStorage`。`ConfigEntityStorage`类与配置管理系统交互，以加载、保存和删除自定义配置实体。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Drupal 8 introduces a typed data system that configuration entities and fields
    use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 引入了一种类型化数据系统，配置实体和字段都使用该系统。
- en: Available data types for schema definitions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用于模式定义的数据类型
- en: 'Drupal core provides its own configuration information. There is a `core.data_types.schema.yml`
    file located at `core/config/schema`. These are the base types of data that the
    core provides and can be used when making configuration schema. The file contains
    YAML definitions of data types and the class that represents them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 核心提供自己的配置信息。在`core/config/schema`位置有一个`core.data_types.schema.yml`文件。这些是核心提供的基本数据类型，可以在创建配置模式时使用。该文件包含数据类型的
    YAML 定义以及表示它们的类：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When a configuration schema definition specifies an attribute that has an email
    for its type, that value is then handled by the `\Drupal\Core\TypedData\Plugin\DataType\Email`
    class. Data types are a form of plugins, and each plugin's annotation specifies
    constraints for validation. This is built around the Symfony **Validator** component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置模式定义指定一个具有电子邮件类型的属性时，该值将由`\Drupal\Core\TypedData\Plugin\DataType\Email`类处理。数据类型是一种插件形式，每个插件的注释指定了验证约束。这是围绕
    Symfony **Validator** 组件构建的。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to [*Chapter 6*](18026cd1-b8f0-48c0-9626-568ffd225eb5.xhtml)*, Creating
    Forms with the Form API*
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第[*第6章*](18026cd1-b8f0-48c0-9626-568ffd225eb5.xhtml)*，使用 Form API 创建表单*
- en: Refer to *[Chapter 4](a634af62-2148-4382-9121-b8500df169ed.xhtml), Extending
    Drupal*
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第*[第4章](a634af62-2148-4382-9121-b8500df169ed.xhtml)*，扩展 Drupal*
- en: Refer to *[Chapter 9](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), Confiuration
    Management - Deploying in Drupal 8*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第*[第9章](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml)，配置管理 - 在 Drupal 8 中部署*
- en: Refer to configuration schema/metadata at [https://www.drupal.org/node/1905070](https://www.drupal.org/node/1905070)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考配置模式/元数据在 [https://www.drupal.org/node/1905070](https://www.drupal.org/node/1905070)
- en: Creating a content entity type
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建内容实体类型
- en: Content entities provide base field definitions and configurable fields through
    the Field module. There is also support for revisions and translations with content
    entities. Display modes, both form and view, are available for content entities
    to control how the fields are edited and displayed. When an entity does not specify
    bundles, there is automatically one bundle instance with the same name as the
    entity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体提供基础字段定义和可配置字段，通过字段模块实现。内容实体还支持修订和翻译。内容实体有显示模式，包括表单和视图，用于控制字段的编辑和显示。当一个实体没有指定包时，会自动有一个与实体同名的包实例。
- en: In this recipe, we will create a custom content entity that does not specify
    a bundle. We will create a `Message` entity that can serve as a content entity
    for generic messages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个自定义内容实体，不指定任何包。我们将创建一个`Message`实体，它可以作为通用消息的内容实体。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a custom module to place code into to implement a configuration
    entity type. Create an `src` directory for your classes. Refer to the *Creating
    a module* recipe of [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml),
    *Extending Drupal*, for information on creating a custom module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个自定义模块来放置代码以实现配置实体类型。为您的类创建一个`src`目录。有关创建自定义模块的信息，请参考第[*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)，*扩展
    Drupal*中的*创建模块*食谱。
- en: Do not use a module which is currently installed, otherwise Drupal will not
    install your new entity type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用当前已安装的模块，否则 Drupal 不会安装您的新实体类型。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create an `Entity` directory in our module''s `src` folder. First, we
    will create an interface for our entity by creating a `MessageInterface.php` file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模块的`src`文件夹中创建一个`Entity`目录。首先，我们将通过创建一个`MessageInterface.php`文件来为我们的实体创建一个接口：
- en: '![](img/9dc5892d-f44c-44b7-a872-1c2ec9110aae.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dc5892d-f44c-44b7-a872-1c2ec9110aae.png)'
- en: 'The `MessageInterface` will extend `\Drupal\Core\Entity\ContentEntityInterface`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MessageInterface`将扩展`\Drupal\Core\Entity\ContentEntityInterface`：'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will be implemented by our entity and will provide the method requirements.
    It is best practice to provide an interface for entities. This allows you to provide
    required methods if another developer extends your entity or if you are doing
    advanced testing and need to mock an object. We also provide a method to return
    our main base field definition (to be defined).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将由我们的实体实现，并提供方法要求。为实体提供一个接口是最佳实践。这允许你在其他开发者扩展你的实体或在进行高级测试并需要模拟对象时提供所需的方法。我们还提供了一个方法来返回我们的主要基础字段定义（待定义）。
- en: 'Then, let''s create `Message.php` in our `Entity` directory in `src`. This
    file will contain the `Message` class, which extends `\Drupal\Core\Entity\ContentEntityBase`
    and implements our entity''s interface:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们在`src`目录中的`Entity`目录下创建`Message.php`。此文件将包含`Message`类，它扩展自`\Drupal\Core\Entity\ContentEntityBase`并实现了我们实体的接口：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will need to create an annotation document block on our class to provide
    information about our entity, such as its `id`, `label`, and `entity` keys:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的类上创建一个注解文档块，以提供有关我们实体的信息，例如其`id`、`label`和`entity`键：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `id` is the internal machine name identifier for the entity type, and the
    `label` is its human-readable version. The entity keys definition tells Drupal
    the attributes that represent our identifier and label.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`是实体类型的内部机器名称标识符，而`label`是其可读版本。实体键定义告诉Drupal哪些属性代表我们的标识符和标签。'
- en: The `base_table` defines the database table in which the entity will be stored,
    and `fieldable` allows custom fields to be configured through the Field UI module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_table`定义了实体将存储的数据库表，而`fieldable`允许通过Field UI模块配置自定义字段。'
- en: 'Next, we will add `handlers` to our entity. We will use the default handlers
    provided by Drupal:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的实体添加`handlers`。我们将使用Drupal提供的默认处理器：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `handlers` array specifies classes that provide the interaction functionality
    with our entity. The list builder class will be created to show you a table of
    our entities. The form array provides classes for forms to be used when creating,
    editing, or deleting our content entity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers`数组指定了提供与我们的实体交互功能的类。将创建一个列表构建器类来显示我们的实体表。表单数组提供了用于创建、编辑或删除我们的内容实体时使用的表单的类。'
- en: 'An additional `handler`, the `route_provider`, can be added to dynamically
    generate our canonical (view), `edit`, `add`, `delete`, and `collection` (list)
    routes:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以添加一个额外的`handler`，即`route_provider`，它可以动态生成我们的规范（查看）、`edit`、`add`、`delete`和`collection`（列表）路由：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is a routing service for entities that will automatically provide Drupal
    a route with the proper controllers based on this annotation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为实体存在一个路由服务，它将自动为Drupal提供基于此注解的正确控制器路由。
- en: 'We will then define an administration permission property in our entity''s
    annotation, which the system checks, by default, for all create, update, and delete
    operations:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在实体的注解中定义一个管理权限属性，系统默认会检查所有创建、更新和删除操作：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will need to implement the `baseFieldDefinitions` method to satisfy the
    `FieldableEntityInterface` interface, which will provide our field definitions
    to the entity''s base table. Add the following method to your class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现`baseFieldDefinitions`方法以满足`FieldableEntityInterface`接口，这将为我们提供字段定义到实体的基础表中。将以下方法添加到你的类中：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `FieldableEntityInterface` is implemented by the `ContentEntityBase` class
    using the `ContentEntityInterface`. The method needs to return an array of `BaseFieldDefinitions`
    for typed data definitions. The parent class provides field definitions for most
    of the `entity_keys` value in our entity's annotation. We must provide the label
    field and any specific fields for our implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`FieldableEntityInterface`接口是通过`ContentEntityBase`类使用`ContentEntityInterface`实现的。该方法需要返回一个`BaseFieldDefinitions`数组，用于类型化数据定义。父类为我们实体注解中的大多数`entity_keys`值提供了字段定义。我们必须提供标签字段以及我们实现中的任何特定字段。'
- en: The `content` base field definition will hold the actual text of the message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`基础字段定义将保存消息的实际文本。'
- en: 'Next, we will implement the `getMessage` method in our class to satisfy our
    interface and provide a means to retrieve our message''s text value:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的类中实现 `getMessage` 方法以满足我们的接口，并提供一种检索消息文本值的方式：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method provides a wrapper around the defined base field's value and returns
    it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了一个围绕定义的基本字段值的包装，并返回它。
- en: 'Create the `MessageListBuilder` class defined in our `list_builder` handler
    by creating a `MessageListBuilder.php` file and extending `\Drupal\Core\Entity\EntityListBuilder`.
    We will need to override the default implementation to display our base field
    definitions:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个 `MessageListBuilder.php` 文件并扩展 `\Drupal\Core\Entity\EntityListBuilder`
    来定义我们列表构建器处理程序中的 `MessageListBuilder` 类。我们需要覆盖默认实现以显示我们的基本字段定义：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In our list builder handler, we override the `buildHeader` and `builderRow`
    methods so that we can add our configuration entity's properties to the table.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的列表构建器处理程序中，我们覆盖了 `buildHeader` 和 `builderRow` 方法，以便我们可以将配置实体属性添加到表中。
- en: 'Before we move on, we must create a `mymodule.permissions.yml` file in the
    module''s root directory. We will need to provide the permission definition for
    `administer message`, as provided in our annotation:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须在模块的根目录中创建一个 `mymodule.permissions.yml` 文件。我们需要提供 `administer message`
    的权限定义，正如我们在注解中所提供的：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our module''s structure should resemble the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模块的结构应该类似于以下截图：
- en: '![](img/6d41126a-ca11-4dc5-b575-1e586a49e447.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d41126a-ca11-4dc5-b575-1e586a49e447.png)'
- en: 'Install the module. Go to `/messages/add` to create our first custom content
    entity entry and then view it on `/admin/content/messages`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装模块。转到 `/messages/add` 创建我们的第一个自定义内容实体条目，然后在 `/admin/content/messages` 上查看：
- en: '![](img/6e08b985-9f9f-41c1-9351-a2edf7cf6930.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e08b985-9f9f-41c1-9351-a2edf7cf6930.png)'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Content entities are a version of the `EntityType` plugin. When you define a
    content entity type, the annotation block begins with `@ContentEntityType`. This
    declaration and the properties in it represent the definition to initiate an instance
    of the `\Drupal\Core\Entity\ContentEntityType`, class just like all other plugin
    annotations. The `ContentEntityType` plugin class implements a constructor to
    provide default `storage` and `view_builder` handlers, forcing us to implement
    the `list_builder` and `form` handler arrays.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体是 `EntityType` 插件的一种版本。当你定义内容实体类型时，注解块以 `@ContentEntityType` 开始。这个声明以及其中的属性代表了初始化
    `\Drupal\Core\Entity\ContentEntityType` 类实例的定义，就像所有其他的插件注解一样。`ContentEntityType`
    插件类实现了一个构造函数来提供默认的 `storage` 和 `view_builder` 处理程序，这迫使我们实现 `list_builder` 和 `form`
    处理程序数组。
- en: The plugin manager for entity types lives under the `entity_type.manager` service
    name and is provided through `\Drupal\Core\Entity\EntityTypeManager` by default.
    However, while the annotation defines the plugin information, our `Message` class
    that extends `ContentEntityBase` provides a means to manipulate the data it represents.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型的插件管理器位于 `entity_type.manager` 服务名称下，默认通过 `\Drupal\Core\Entity\EntityTypeManager`
    提供。然而，虽然注解定义了插件信息，但扩展 `ContentEntityBase` 的 `Message` 类提供了操作它所表示数据的方式。
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will discuss how to add an additional functionality to your entity and use
    the Entity module to simplify the developer expedience.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何为你的实体添加额外的功能，并使用实体模块来简化开发过程。
- en: Using the AdminHtmlRouteProvider provider
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AdminHtmlRouteProvider 提供者
- en: Our `Message` entity type implements the `DefaultHtmlRouteProvider` class. There
    is also the `\Drupal\Core\Entity\Routing\AdminHtmlRouteProvider` class. This overrides
    the `getEditFormRoute` and `getDeleteFormRoute` and marks them with `_admin_route`.
    This will cause these forms to be rendered in the administration theme.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Message` 实体类型实现了 `DefaultHtmlRouteProvider` 类。还有一个 `\Drupal\Core\Entity\Routing\AdminHtmlRouteProvider`
    类。这个类覆盖了 `getEditFormRoute` 和 `getDeleteFormRoute` 方法，并用 `_admin_route` 标记它们。这将导致这些表单在管理主题中渲染。
- en: Making the collection route a local task tab
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集合路由作为本地任务标签
- en: In this recipe, we specified the message collection route as `/admin/content/messages`.
    Without implementing this route as a local task under the `/admin/content` route,
    it will not show up as a tab. This can be done by creating a `links.task.yml`
    file for the module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们指定了消息集合路由为 `/admin/content/messages`。如果不将此路由作为 `/admin/content` 路由下的本地任务实现，它将不会作为标签显示。这可以通过为模块创建一个
    `links.task.yml` 文件来完成。
- en: 'In `mymodule.links.task.yml`, add the following YAML content:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mymodule.links.task.yml` 中，添加以下 YAML 内容：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This instructs Drupal to use the `entity.message.collection` route, defined
    in our `routing.yml` file, to be based under the `system.admin_content` route:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示Drupal使用在`routing.yml`文件中定义的`entity.message.collection`路由，作为`system.admin_content`路由的子路由：
- en: '![](img/c97ca917-6934-431a-90f8-3578a3f7fc01.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c97ca917-6934-431a-90f8-3578a3f7fc01.png)'
- en: See also
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml), *Extending
    Drupal*
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)，*扩展Drupal*
- en: Creating a bundle for a content entity type
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为内容实体类型创建一个捆绑包
- en: Bundles allow you to have different variations of a content entity. All bundles
    share the same base field definitions but not configured fields. This allows each
    bundle to have its own custom fields. Display modes are also dependent on a specific
    bundle. This allows each bundle to have its own configuration for the form mode
    and view mode.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑包允许你拥有内容实体不同变体的内容。所有捆绑包共享相同的基字段定义，但不配置字段。这允许每个捆绑包拥有自己的自定义字段。显示模式也依赖于特定的捆绑包。这允许每个捆绑包为表单模式和查看模式拥有自己的配置。
- en: Using the custom entity from the preceding recipe, we will add a configuration
    entity to act as the bundle. This will allow you to have different message types
    for multiple custom field configurations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个菜谱中的自定义实体，我们将添加一个配置实体作为捆绑包。这将允许你为多个自定义字段配置有不同的消息类型。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need a custom module to place the code into to implement a configuration
    entity type. Create an `src` directory for your classes. We need a custom content
    entity type to be implemented, such as the one in the *Creating a content entity
    type* recipe of this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个自定义模块来放置代码以实现配置实体类型。为你的类创建一个`src`目录。我们需要实现一个自定义内容实体类型，例如本章*创建内容实体类型*菜谱中的那个。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since content entity bundles are configuration entities, we will need to define
    our configuration entity schema. Create a `config/schema` directory and `mymodule.schema.yml`
    file that will contain the configuration entity''s schema:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于内容实体捆绑包是配置实体，我们需要定义我们的配置实体模式。创建一个`config/schema`目录和`mymodule.schema.yml`文件，该文件将包含配置实体的模式：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will define the configuration entity's config prefix as `message_type`, which
    we will provide to Drupal in the entity's annotation block. We will tell Drupal
    that this is a `config_entity` and provide a label for the schema.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义配置实体的配置前缀为`message_type`，并将其提供给Drupal在实体的注释块中。我们将告诉Drupal这是一个`config_entity`，并为模式提供标签。
- en: With the mapping array, we provide the attributes that make up our entity and
    the data that will be stored.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过映射数组，我们提供构成我们的实体的属性和将要存储的数据。
- en: 'In our module''s `src/Entity` directory, let''s create an interface for our
    bundle by creating a `MessageTypeInterface.php` file. The `MessageTypeInterface`
    will extend the `\Drupal\Core\Config\Entity\ConfigEntityInterface`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们模块的`src/Entity`目录中，让我们通过创建一个`MessageTypeInterface.php`文件为我们的捆绑包创建一个接口。`MessageTypeInterface`将扩展`\Drupal\Core\Config\Entity\ConfigEntityInterface`：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will be implemented by our entity and will provide the method requirements.
    It is best practice to provide an interface for entities. This allows you to provide
    required methods if another developer extends your entity or if you are doing
    advanced testing and need to mock an object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将由我们的实体实现，并提供方法要求。为实体提供一个接口是最佳实践。这允许你在其他开发者扩展你的实体或在进行高级测试并需要模拟对象时提供所需的方法。
- en: We will be implementing a very basic bundle. It is still wise to provide an
    interface in the event of future enhancements and mocking ability in tests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常基础的捆绑包。即使在未来的增强和测试中的模拟能力，提供接口也是明智的。
- en: 'Create a `MessageType.php` file in `src/Entity`. This will hold the `MessageType`
    class, which will extend `\Drupal\Core\Config\Entity\ConfigEntityBundleBase` and
    implement our bundle''s interface:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Entity`中创建一个`MessageType.php`文件。这将持有`MessageType`类，该类将扩展`\Drupal\Core\Config\Entity\ConfigEntityBundleBase`并实现我们捆绑包的接口：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In most use cases, the bundle entity class can be an empty class that does not
    provide any properties or methods. If a bundle provides additional attributes
    in its schema definition, they would also be provided here, like any other configuration
    entity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数用例中，捆绑实体类可以是一个空类，不提供任何属性或方法。如果捆绑包在其模式定义中提供了额外的属性，它们也会在这里提供，就像任何其他配置实体一样。
- en: 'Entities need to be annotated. Create a base annotation for the `id`, `label`,
    `entity` keys, and `config_export` keys:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体需要被注释。为`id`、`label`、`entity`键和`config_export`键创建一个基本注释：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The annotation document block tells Drupal that this is an instance of the `ConfigEntityType`
    plugin. The `id` is the internal machine name identifier for the entity type and
    the `label` is its human-readable version. The `config_prefix` matches how we
    defined our schema using `mymodule.message_type`. The entity keys definition tells
    Drupal which attributes represent our identifiers and labels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注释文档块告诉Drupal这是一个`ConfigEntityType`插件的实例。`id`是实体类型的内部机器名称标识符，而`label`是其可读版本。`config_prefix`与我们使用`mymodule.message_type`定义的模式相匹配。实体键定义告诉Drupal哪些属性代表我们的标识符和标签。
- en: When specifying `config_export`, we are telling the configuration management
    system what properties are to be exported when exporting our entity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定`config_export`时，我们正在告诉配置管理系统在导出我们的实体时要导出哪些属性。
- en: 'We will then add handlers, which will interact with our entity:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加处理程序，这些处理程序将与我们的实体交互：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `handlers` array specifies classes that provide the interaction functionality
    with our entity. The list builder class will be created to show you a table of
    our entities. The form array provides classes for forms to be used when creating,
    editing, or deleting our configuration entity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers`数组指定了提供与我们的实体交互功能的类。列表构建器类将被创建以显示我们的实体表。表单数组提供了用于创建、编辑或删除我们的配置实体的表单的类。'
- en: 'An additional handler, the `route_provider`, can be added to dynamically generate
    our canonical (view), `edit`, `delete`, and `collection` (list) routes:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以添加另一个处理程序，即`route_provider`，以动态生成我们的规范（视图）、`编辑`、`删除`和`集合`（列表）路由：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is a routing service for entities that will automatically provide Drupal
    a route with the proper controllers based on this annotation. The add form route
    is not yet supported and needs to be manually added.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一个用于实体的路由服务，它将自动根据此注释为Drupal提供带有适当控制器的路由。添加表单路由尚未支持，需要手动添加。
- en: 'We will need to modify our content entity to use the bundle configuration entity
    that we defined. Edit the `src/Entity/Message.php` file and adjust the entity
    annotation:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改我们的内容实体以使用我们定义的捆绑配置实体。编辑`src/Entity/Message.php`文件并调整实体注释：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `bundle_entity_type` key specifies the entity type used as the bundle. The
    plugin validates this as an actual entity type and marks it for configuration
    dependencies. With the `field_ui_base_route` key pointed to the bundle's main
    edit form, it will generate the `Manage Fields`, `Manage Form Display`, and `Manage
    Display` tabs on the bundles. Finally, the `bundle` entity key instructs Drupal
    on the field definition to be used to identify the entity's bundle, which is created
    in the next step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`bundle_entity_type`键指定了用作捆绑的实体类型。插件将其验证为实际的实体类型，并标记为配置依赖项。通过`field_ui_base_route`键指向捆绑的主要编辑表单，它将在捆绑中生成`管理字段`、`管理表单显示`和`管理显示`选项卡。最后，`bundle`实体键指示Drupal使用字段定义来识别实体捆绑，该捆绑将在下一步创建。'
- en: With the `bundle` entity key added, the `ContentEntityBase` class will automatically
    add an entity reference base field called `type` to our entity, referencing the
    bundle configuration entity type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`bundle`实体键后，`ContentEntityBase`类将自动将一个名为`type`的实体引用基础字段添加到我们的实体中，该字段引用捆绑配置实体类型。
- en: 'Create the `MessageTypeListBuilder` class defined in our `list_builder` handler
    in a `MessageTypeListBuilder.php` file and extend `\Drupal\Core\Config\Entity\ConfigEntityListBuilder`.
    We will need to override the default implementation to display our configuration
    entity properties:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`list_builder`处理程序中创建`MessageTypeListBuilder`类，在`MessageTypeListBuilder.php`文件中，并扩展`\Drupal\Core\Config\Entity\ConfigEntityListBuilder`。我们需要覆盖默认实现以显示我们的配置实体属性：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our list builder handler, we will override the `buildHeader` and `builderRow`
    methods so that we can add our configuration entity''s properties to the table:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的列表构建器处理程序中，我们将覆盖`buildHeader`和`builderRow`方法，以便我们可以将配置实体属性添加到表中：
- en: '![](img/e30411a0-e45d-4be6-b57e-cea480150d15.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e30411a0-e45d-4be6-b57e-cea480150d15.png)'
- en: 'Our module''s structure should resemble the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模块的结构应该类似于以下截图：
- en: '![](img/caa1aee5-905e-4814-9524-4bfb9b2c81ef.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caa1aee5-905e-4814-9524-4bfb9b2c81ef.png)'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Bundles are most utilized in the configured field levels via the `Field` and
    `Field UI` modules. When you create a new field, it has a base storage item for
    its global settings. Once a field is added to a bundle, there is a new field configuration
    that is created and assigned to the bundle. Fields can then have their own settings
    for a specific bundle along with form and view display configurations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑包主要通过`Field`和`Field UI`模块在配置的字段级别得到最广泛的应用。当你创建一个新的字段时，它有一个用于其全局设置的基存储项。一旦字段被添加到捆绑包中，就会创建一个新的字段配置并将其分配给捆绑包。字段可以为特定捆绑包设置自己的设置，以及表单和视图显示配置。
- en: Content entity bundles work just like any other configuration entity implementation,
    but they extend the usability of the Field API for your content entity types.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体捆绑包的工作方式与任何其他配置实体实现一样，但它们扩展了Field API在内容实体类型中的可用性。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We will discuss how to add additional functionality to our entity bundle and
    use the Entity module to simplify the developer expedience.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何向我们的实体捆绑包添加更多功能，并使用实体模块简化开发者的工作流程。
- en: Provide action links for adding new bundles
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供添加新捆绑包的动作链接
- en: There are special links called **action links** in Drupal. These appear at the
    top of the page and are generally used for links that allow the creation of an
    item by creating a `links.action.yml` file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal中有一些称为**动作链接**的特殊链接。它们出现在页面顶部，通常用于创建`links.action.yml`文件以允许创建项目的链接。
- en: 'In your `mymodule.links.action.yml`, each action link defines the route it
    will link to, titles, and the routes it appears on:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`mymodule.links.action.yml`中，每个动作链接定义了它将链接到的路由、标题以及它出现在哪些路由上：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `appears_on` key accepts multiple values that will allow this route link
    to appear on multiple pages:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`appears_on` 键接受多个值，这将允许此路由链接出现在多个页面上：'
- en: '![](img/be9b8b23-4d9a-4cbe-bbaa-231140a75855.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be9b8b23-4d9a-4cbe-bbaa-231140a75855.png)'
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml), *Extending
    Drupal*
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)，*扩展Drupal*
- en: Refer to [*Chapter 9*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml), *Configuration
    Management - Deploying in Drupal 8*
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[*第9章*](b2659986-a8dc-4503-a043-6071ab7b6722.xhtml)，*配置管理 - 在Drupal 8中部署*
- en: Refer to the *Creating a Configuration Entity type* recipe in *[Chapter 10](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml)*,
    *The Entity API*
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考*[第10章](2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml)*中的*创建配置实体类型*配方，*实体API*
- en: Implementing custom access control for an entity
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为实体实现自定义访问控制
- en: All entities have a set of handlers that control specific pieces of functionalities.
    One handler handles access control. When the access handler is not specified,
    the base `\Drupal\Core\Entity\EntityType` module will implement `\Drupal\Core\Entity\EntityAccessControlHandler`
    as the access handler. By default, this will check whether any modules have implemented
    `hook_entity_create_access` or `hook_entity_type_create_access` and use their
    opinions. Otherwise, it defaults to the admin permission for the entity type,
    if implemented.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实体都有一组处理程序，用于控制特定的功能。一个处理程序处理访问控制。当未指定访问处理程序时，基础 `\Drupal\Core\Entity\EntityType`
    模块将实现 `\Drupal\Core\Entity\EntityAccessControlHandler` 作为访问处理程序。默认情况下，这将检查是否有模块实现了
    `hook_entity_create_access` 或 `hook_entity_type_create_access` 并使用它们的意见。否则，如果实现了实体类型的默认管理权限，则默认为该权限。
- en: In this recipe, we will provide an admin permission for our entity and implement
    the access handler and permission provider available through the Entity API module.
    We will base this on an entity called **Message**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将为我们的实体提供一个管理权限，并实现通过实体API模块提供的访问处理程序和权限提供程序。我们将基于一个名为**消息**的实体来实现。
- en: This recipe specifically uses the functionality from the Entity API module because
    it has been tested and thoroughly reviewed and reduces boilerplate code. Ideally,
    this will be part of an upcoming minor release of Drupal core.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方特别使用实体API模块的功能，因为它已经过测试和彻底审查，并减少了样板代码。理想情况下，这将作为Drupal核心即将推出的一个小版本的一部分。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need a custom module to place the code into to implement a configuration
    entity type. Let's create an `src` directory for our PSR-4 style classes. We will
    need to implement a custom content entity type, such as the one in the *Creating
    a content entity type* recipe of this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个自定义模块来放置代码以实现配置实体类型。让我们为我们的PSR-4风格类创建一个`src`目录。我们需要实现一个自定义内容实体类型，例如本章中*创建内容实体类型*配方中的那个。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we will need to define an administration permission for the entity.
    This is done by ensuring that the `admin_permission` key is present in the entity''s
    annotation document block:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为实体定义一个管理权限。这是通过确保实体注释文档块中存在`admin_permission`键来完成的：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The entity access handler provided by the core will check whether entities implement
    this option. If it is provided, it will be used as the basis for access checks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 核心提供的实体访问处理器将检查实体是否实现了此选项。如果提供了，它将作为访问检查的基础。
- en: 'Next, we will want to specify permissions that are granular per bundle:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将想要指定按捆绑包粒度指定的权限：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `permission_granularity` key will tell the system what permissions should
    be generated and how the access should be checked. This way, one user could create
    *Announcement* messages but not *Bulletin* messages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`permission_granularity`键将告诉系统应该生成哪些权限以及如何检查访问。这样，一个用户可以创建*公告*消息但不能创建*公告板*消息。'
- en: 'Then, we define the `permission_provider` handler, which will generate our
    permissions:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`permission_provider`处理器，它将生成我们的权限：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final adjustment to our entity annotation is to change the default access
    handler:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对实体注释的最终调整是更改默认的访问处理器：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rebuild Drupal's caches, or install the module if it is not yet installed.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建Drupal的缓存，或者如果尚未安装，则安装该模块。
- en: 'Verify that the permissions are available on the permission''s overview page:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在权限概述页面上验证权限是否可用：
- en: '![](img/42a5048e-fff5-4531-b45e-275aa72498c5.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42a5048e-fff5-4531-b45e-275aa72498c5.png)'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Entities are powered by the plugin system in Drupal, which means that there
    is a plugin manager. The default `\Drupal\Core\Entity\EntityTypeManager` provides
    the discovery and handling of entities. Both the `ContentEntityType` and `ConfigEntityType`
    entity types and classes extend the base `\Drupal\Core\Entity\EntityType` class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实体由Drupal的插件系统提供支持，这意味着存在一个插件管理器。默认的`\Drupal\Core\Entity\EntityTypeManager`提供实体的发现和处理。`ContentEntityType`和`ConfigEntityType`实体类型和类都扩展了基`\Drupal\Core\Entity\EntityType`类。
- en: The `EntityType` class constructor provides a default `access` handler if it
    is not provided through the `\Drupal\Core\Entity\EntityAccessControlHandler` class.
    Every core module that provides an entity type implements this to override at
    least `checkAccess` and `checkCreateAccess`. Meanwhile, the Entity API access
    handler extends this to support bundle granular permissions and owner-based permissions
    if an entity implements `EntityOwnerInterface` in a reusable fashion.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityType`类构造函数提供了一个默认的`access`处理器，如果未通过`\Drupal\Core\Entity\EntityAccessControlHandler`类提供，则提供。每个提供实体类型的核心模块都实现此接口以覆盖至少`checkAccess`和`checkCreateAccess`。同时，实体API访问处理器扩展此接口以支持捆绑包粒度权限和基于所有者的权限，如果实体以可重用的方式实现了`EntityOwnerInterface`。'
- en: The `\Drupal\Core\Access\AccessibleInterface` defines an `access` method, and
    all the entities inherit this interface. The default implementation in `\Drupal\Core\Entity\Entity`
    will invoke `checkCreateAccess` if the operation is `create`; otherwise, it invokes
    the generic `access` method of the access controller, which will invoke entity
    access hooks and the class' `checkAccess` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Access\AccessibleInterface`定义了一个`access`方法，所有实体都继承了这个接口。在`\Drupal\Core\Entity\Entity`中的默认实现将如果操作是`create`则调用`checkCreateAccess`，否则调用访问控制器的通用`access`方法，这将调用实体访问钩子和类的`checkAccess`方法。'
- en: When Drupal generates available permissions, the Entity API module finds entity
    definitions that define the `permission_provider` handler and then invokes that
    class to generate permissions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当Drupal生成可用权限时，实体API模块会找到定义了`permission_provider`处理器的实体定义，然后调用该类来生成权限。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will discuss how to implement custom access control for an entity and use
    the Entity to simplify the controlling access.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何实现实体的自定义访问控制，并使用实体来简化访问控制。
- en: Controlling access to entity fields
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制实体字段的访问
- en: 'The `checkFieldAccess` method in the core''s entity access control handler
    can be overridden to control access to specific entity fields when modifying an
    entity. Without being overridden by a child class, the `\Drupal\Core\Entity\EntityAccessControlHandler::checkFieldAccess`
    will always return an allowed access result. The method receives the following
    parameters:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 核心实体访问控制处理器中的`checkFieldAccess`方法可以被覆盖，以在修改实体时控制对特定实体字段的访问。如果没有被子类覆盖，`\Drupal\Core\Entity\EntityAccessControlHandler::checkFieldAccess`将始终返回允许的访问结果。该方法接收以下参数：
- en: The view and edit operations
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看和编辑操作
- en: The current field's definition
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前字段的定义
- en: The user session to check access against
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查访问的用户会话
- en: A possible list of field item values
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段项值的一个可能列表
- en: Entity types can implement their own access control handlers and override this
    method to provide granular control over the modification of their base fields.
    A good example would be the `User` module and its `\Drupal\user\UserAccessControlHandler`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型可以实现自己的访问控制处理程序并覆盖此方法，以提供对其基本字段修改的细粒度控制。一个很好的例子是 `User` 模块及其 `\Drupal\user\UserAccessControlHandler`。
- en: User entities have a `pass` field that is used for the user's current password.
    There is also a `created` field that records when the user was added to the site.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 用户实体有一个 `pass` 字段，用于用户的当前密码。还有一个 `created` 字段，记录用户何时被添加到网站。
- en: 'For the `pass` field, it returns `denied` if the operation is `view`, but allows
    access if the operation is `edit`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `pass` 字段，如果操作是 `view`，则返回 `denied`，但如果操作是 `edit`，则允许访问：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `created` field uses the opposite logic. When a user logs in, the site
    can be viewed but cannot be edited:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`created` 字段使用相反的逻辑。当用户登录时，可以查看网站但不能编辑：'
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml), *Extending
    Drupal*
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 [*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)，*扩展 Drupal*
- en: Providing a custom storage handler
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供自定义存储处理程序
- en: Storage handlers control the loading, saving, and deleting of an entity. The
    `\Drupal\Core\Entity\ContentEntityType` provides the base entity type definition
    for all content entity types. If it is not specified, then the default storage
    handler is `\Drupal\Core\Entity\Sql\SqlContentEntityStorage`. This class can be
    extended to implement alternative `load` methods or adjustments on saving.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 存储处理程序控制实体的加载、保存和删除。`\Drupal\Core\Entity\ContentEntityType` 为所有内容实体类型提供基本实体类型定义。如果没有指定，则默认存储处理程序是
    `\Drupal\Core\Entity\Sql\SqlContentEntityStorage`。这个类可以扩展以实现替代的 `load` 方法或保存时的调整。
- en: In this recipe, we will implement a method that supports loading an entity by
    a specific property instead of having to write a specific `loadByProperties` method
    call.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个方法，支持通过特定的属性来加载实体，而不是必须编写特定的 `loadByProperties` 方法调用。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a custom module to place the code into to implement a configuration
    entity type. Create an `src` directory for your PSR-4 style classes. A custom
    content entity type needs to be implemented, such as the one in the *Creating
    a content entity type* recipe of this chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个自定义模块来放置代码以实现配置实体类型。为您的 PSR-4 风格类创建一个 `src` 目录。需要实现一个自定义内容实体类型，例如本章 *创建内容实体类型*
    菜谱中的那个。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a `MessageStorage` class in the module''s `src` directory. This class
    will extend the default `\Drupal\Core\Entity\Sql\SqlContentEntityStorage` class:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的 `src` 目录中创建一个 `MessageStorage` 类。这个类将扩展默认的 `\Drupal\Core\Entity\Sql\SqlContentEntityStorage`
    类：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By extending the default storage class for our entity type, we can simply add
    new methods that are relevant to our requirements rather than implementing the
    extra business logic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们实体类型的默认存储类，我们可以简单地添加与我们的需求相关的新方法，而不是实现额外的业务逻辑。
- en: 'Create a `loadMultipleByType` method; using this method, we will provide a
    simple way to load all messages of a specific bundle:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `loadMultipleByType` 方法；使用这个方法，我们将提供一个简单的方式来加载特定捆绑包的所有消息：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We pass the `type` property so that we can query it based on the message bundle
    and return all matching message entities.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递 `type` 属性，这样我们就可以根据消息捆绑包来查询它，并返回所有匹配的消息实体。
- en: 'Update the entity''s annotation block to have the new storage handler defined:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新实体的注解块以包含新的存储处理程序定义：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can now programmatically interact with your message entities using the
    following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用以下代码以编程方式与您的消息实体交互：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When defining a content entity type, the annotation block begins with `@ContentEntityType`.
    This declaration, and the properties in it represents the definition to initiate
    an instance of the
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义内容实体类型时，注解块以 `@ContentEntityType` 开始。这个声明以及其中的属性代表了初始化实体实例的定义
- en: '`\Drupal\Core\Entity\ContentEntityType` class just like all other plugin annotations.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Entity\ContentEntityType` 类就像所有其他插件注解一样。'
- en: In the class constructor, there is a merge to provide default handlers for the
    `storage` handler if it is not provided. This will always default to `\Drupal\Core\Entity\Sql\SqlContentEntityStorage`,
    as it provides methods and logic to help its parent class, `ContentEntityStorageBase`,
    interact with the SQL-based storage.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，有一个合并操作，如果未提供，将为 `storage` 处理程序提供默认处理程序。这始终默认为 `\Drupal\Core\Entity\Sql\SqlContentEntityStorage`，因为它提供了帮助其父类
    `ContentEntityStorageBase` 与基于SQL的存储交互的方法和逻辑。
- en: Configuration entities can have their default `\Drupal\Core\Config\Entity\ConfigEntityStorage`
    as well. However, for configuration entities, the configuration management utilizes
    the `\Drupal\Core\Config\StorageInterface` implementations for storage rather
    than classes, which extend `ConfigEntityStorage`. This logic resides in the configuration
    factory service.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体也可以有它们的默认 `\Drupal\Core\Config\Entity\ConfigEntityStorage`。然而，对于配置实体，配置管理使用
    `\Drupal\Core\Config\StorageInterface` 实现进行存储，而不是扩展 `ConfigEntityStorage` 的类，这个逻辑位于配置工厂服务中。
- en: Extending `SqlContentEntityStorage` reuses methods required for default Drupal
    implementations and provides an easy method to create custom methods to interact
    with loading, saving, and so on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `SqlContentEntityStorage` 重新使用默认Drupal实现所需的方法，并提供了一种创建与加载、保存等交互的自定义方法的简单方法。
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: We will discuss the custom storage handler and utilization of different storage
    backends.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论自定义存储处理程序以及不同存储后端的利用。
- en: Utilizing a different storage backend for an entity
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为实体使用不同的存储后端
- en: Drupal provides mechanisms to support different database storage backends that
    are not provided by the Drupal core, such as MongoDB. Although it is not stable
    for Drupal 8 at the time of writing this book, there is a MongoDB module that
    provides storage interaction.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal提供了支持不同数据库存储后端的机制，这些后端不是Drupal核心提供的，例如MongoDB。尽管在撰写本书时它对Drupal 8来说还不稳定，但有一个MongoDB模块提供了存储交互。
- en: The module provides `\Drupal\mongodb\Entity\ContentEntityStorage`, which extends
    `\Drupal\Core\Entity\ContentEntityStorageBase`. This class overrides the methods
    used to create, save, and delete, to write them to a MongoDB collection.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块提供了 `\Drupal\mongodb\Entity\ContentEntityStorage`，它扩展了 `\Drupal\Core\Entity\ContentEntityStorageBase`。这个类覆盖了用于创建、保存和删除的方法，将它们写入MongoDB集合。
- en: The project can be found at [https://www.drupal.org/project/mongodb](https://www.drupal.org/project/mongodb).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以在 [https://www.drupal.org/project/mongodb](https://www.drupal.org/project/mongodb)
    找到。
- en: While there are much more steps to provide a custom storage backend for content
    entities and their fields, this serves as an example for how you can choose to
    place a custom entity in different storage backends.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为内容实体及其字段提供自定义存储后端还有更多步骤，但这作为如何选择将自定义实体放置在不同存储后端的示例。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [*Chapter 4*](a634af62-2148-4382-9121-b8500df169ed.xhtml), *Extending
    Drupal*
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参阅 [*第4章*](a634af62-2148-4382-9121-b8500df169ed.xhtml)，*扩展Drupal*
- en: Refer to [*Chapter 7*](3994173f-3d31-4f01-b808-99e01368564b.xhtml), *Plug and
    Play with Plugins*
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参阅 [*第7章*](3994173f-3d31-4f01-b808-99e01368564b.xhtml)，*使用插件即插即用*
- en: Creating a route provider
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由提供者
- en: Entities can implement a route provider that will create the route definitions
    for the entity's canonical (view), edit, delete, and collection (list) routes.
    As of Drupal 8.3.0, all the normally required routes are generated (this was not
    the case in 8.0.0). The provider takes the path for a specific link definition
    and turns that into a route and accessible path.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以实现一个路由提供者，为实体的规范（查看）、编辑、删除和集合（列表）路由创建路由定义。截至Drupal 8.3.0，所有通常所需的路由都已生成（在8.0.0中并非如此）。提供者接受特定链接定义的路径，并将其转换为路由和可访问路径。
- en: In this recipe, we will extend the default `\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider`
    and override the canonical route to be the same as the edit route, because we
    assume that messages will always be embedded.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将扩展默认的 `\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider` 并覆盖规范路由以与编辑路由相同，因为我们假设消息总是嵌入的。
- en: This is related to a bug that is fixed in 8.4, where the Content Translation
    module caused errors by assuming that all entities have a canonical link, when
    they may only support edit--refer to [https://www.drupal.org/node/2479377](https://www.drupal.org/node/2479377).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在8.4中修复的错误有关，内容翻译模块通过假设所有实体都有一个规范链接来导致错误，而它们可能只支持编辑--请参阅 [https://www.drupal.org/node/2479377](https://www.drupal.org/node/2479377)。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a custom module to place the code into to implement a configuration
    entity type. Create an `src` directory for your classes. A custom content entity
    type needs to be implemented, such as the one in the *Creating a content entity
    type* recipe of this chapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个自定义模块来放置代码以实现配置实体类型。为你的类创建一个`src`目录。需要实现一个自定义内容实体类型，例如本章中*创建内容实体类型*配方中的那个。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create a `MessageHtmlRouteProvider` class in the `src` directory that extends
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录中创建一个`MessageHtmlRouteProvider`类，该类扩展了
- en: '`\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider`:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider`：'
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Override the provided `getCanonicalRoute` method and return the value from
    `getEditFormRoute`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖提供的`getCanonicalRoute`方法并返回`getEditFormRoute`的值：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Rebuild Drupal's caches for the change to take effect and routes to be rebuilt.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建Drupal的缓存以使更改生效并重新构建路由。
- en: Navigating to `/message/{message}` will now load the edit form, just as `/message/{message}/edit`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/message/{message}`现在将加载编辑表单，就像`/message/{message}/edit`一样。
- en: How it works...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Entities are powered by the plugin system in Drupal, which means that there
    is a plugin manager. The default `\Drupal\Core\Entity\EntityTypeManager` provides
    discovery and handling of entities. The `\Drupal\Core\Entity\EntityTypeManagerInterface`
    specifies a `getRouteProviders` method that is expected to return an array of
    strings that provide the fully qualified class name of an implementation of the
    `\Drupal\Core\Entity\Routing\EntityRouteProviderInterface` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实体由Drupal中的插件系统提供支持，这意味着存在一个插件管理器。默认的`\Drupal\Core\Entity\EntityTypeManager`提供了实体的发现和处理。`\Drupal\Core\Entity\EntityTypeManagerInterface`指定了一个`getRouteProviders`方法，该方法预期返回一个字符串数组，提供`\Drupal\Core\Entity\Routing\EntityRouteProviderInterface`接口实现的完全限定类名。
- en: There is an event subscriber defined in `core.services.yml` called the `entity_route_subscriber`.
    This service subscribes to the dynamic route event. When this happens, it uses
    the entity type manager to retrieve all entity type implementations, which provide
    route subscribers. It then aggregates all the `\Symfony\Component\Routing\RouteCollection`
    instances received and merges them into the main route collection for the system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core.services.yml`中定义了一个事件订阅者，名为`entity_route_subscriber`。这个服务订阅了动态路由事件。当发生这种情况时，它使用实体类型管理器来检索所有实体类型实现，这些实现提供路由订阅者。然后，它将接收到的所有`\Symfony\Component\Routing\RouteCollection`实例聚合起来，并将它们合并到系统的主路由集合中。
- en: There's more...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Drupal 8 introduces router types and provide the add routes for our entity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8引入了路由类型，并为我们的实体提供了添加路由的功能。
- en: The Entity API module provides additional providers
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体API模块提供了额外的提供者
- en: The Entity module provides two new route providers aimed specifically for entities
    that support revisions and a bulk delete form option.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实体模块提供了两个针对支持修订和批量删除表单选项的实体的新路由提供者。
- en: 'If you have an entity that implements the `RevisionLogInterface` interface,
    the revision route provider generates a user interface for managing revisions.
    You then add a `revision` entry for the `router_providers` array pointing to the
    new route provider:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个实现了`RevisionLogInterface`接口的实体，修订路由提供者会生成用于管理修订的用户界面。然后，你为`router_providers`数组添加一个`revision`条目，指向新的路由提供者：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, you just need to define additional items in your entity''s `links` definition:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你只需在你的实体`links`定义中定义额外的项：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This reduces the amount of boilerplate code required to implement an `Entity`.
    For an implementation example, refer to the `EnhancedEntity` class in the Entity
    API's test module `entity_module_test`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了实现`Entity`所需的样板代码量。对于实现示例，请参考实体API测试模块`entity_module_test`中的`EnhancedEntity`类。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to *[Chapter 4](a634af62-2148-4382-9121-b8500df169ed.xhtml)*, *Extending
    Drupal*
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第*4章*，*扩展Drupal*
- en: Refer to the routing system in Drupal 8 at [https://www.drupal.org/developing/api/8/routing](https://www.drupal.org/developing/api/8/routing)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考Drupal 8的路由系统，见[https://www.drupal.org/developing/api/8/routing](https://www.drupal.org/developing/api/8/routing)
