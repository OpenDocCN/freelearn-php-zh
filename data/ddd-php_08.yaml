- en: Aggregates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合（Aggregates）
- en: 'Aggregates are probably the most difficult building blocks of Domain-Driven
    Design. They''re hard to understand, and they''re even harder to properly design.
    But don''t worry; we''re here to help you. However, before jumping into Aggregates,
    there are some key concepts we need to go through first: transactions and concurrency
    strategies.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合（Aggregates）可能是领域驱动设计（Domain-Driven Design）中最难构建的模块。它们难以理解，而且设计起来更加困难。但别担心；我们在这里帮助你。然而，在深入研究聚合之前，我们需要先了解一些关键概念：事务和并发策略。
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: If you've worked with e-commerce applications, it's likely you've faced bugs
    related to data inconsistencies in your database. For example, consider a shopping
    order with a total amount of $99.99, which doesn't match with the sum of the amounts
    of each line in the order, $89.99\. Where did that extra $10 come from?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾与电子商务应用程序合作，那么你很可能遇到过与数据库中数据不一致相关的错误。例如，考虑一个总金额为$99.99的购物订单，而这个金额并不等于订单中每行金额的总和，$89.99。那额外的$10是从哪里来的？
- en: Or, consider a website that sells tickets for the cinema. There's a movie theater
    with 100 available seats, and after a successful movie promotion, everyone is
    on the website waiting for the tickets to become available for purchase. Once
    you open the sales, everything happens fast and you somehow end up selling 102
    tickets. You may have specified that there are only 100 seats, but for some reason
    you exceeded that threshold.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑一个销售电影票的网站。有一个电影院有100个可用座位，在成功的电影推广之后，每个人都登录网站等待购票。一旦开始销售，一切发生得很快，你不知怎么就卖出了102张票。你可能已经指定只有100个座位，但不知何故你超过了这个限制。
- en: You might even have experience with tracking systems such as JIRA or Redmine.
    Think about a team of Developers, QAs, and a Product Owner. What could happen
    if everyone sorts and moves around user stories during a planning meeting and
    then saves? The final backlog or sprint prioritization would be the one from the
    team member who saved last.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能有过使用JIRA或Redmine等跟踪系统的经验。想想一个由开发者、质量保证（QAs）和产品负责人组成的团队。如果在规划会议期间每个人都对用户故事进行排序和移动，然后保存，会发生什么？最终的待办事项列表或冲刺优先级将是最后保存的团队成员的。
- en: In general, data inconsistencies occur when we deal with our persistence mechanism
    in a non-atomic way. An example of this is when you send three queries to a database
    and some of them work and some don't. The final state of the database is inconsistent.
    Sometimes, you want these three queries to succeed or fail all together, and that
    can be fixed with transactions. However, be careful, because as you will see in
    this chapter, not all inconsistencies are fixed with transactions. In fact, sometimes
    other data inconsistencies need locking or concurrency strategies. These kinds
    of tools might come up against your application performance, so be aware that
    there's a tradeoff involved.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们以非原子方式处理持久化机制时，会出现数据不一致。一个例子是当你向数据库发送三个查询时，其中一些成功而另一些失败。数据库的最终状态是不一致的。有时，你希望这三个查询全部成功或全部失败，这可以通过事务来解决。然而，请注意，正如你将在本章中看到的，并非所有的不一致性都可以通过事务来解决。实际上，有时其他数据不一致需要锁定或并发策略。这类工具可能会影响你的应用程序性能，因此请注意，这里存在权衡。
- en: You may think that these kinds of data inconsistencies only occur in databases,
    but that's not true. For example, if we use a document-oriented database such
    as Elasticsearch, we can have data inconsistency between two documents. Furthermore,
    most of the NoSQL persistence storage systems don't support ACID transactions.
    This means you can't persist or update more than one document in a single operation.
    So, if we make different requests to Elasticsearch, one may fail, leaving the
    data persisted in Elasticsearch inconsistent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这类数据不一致只发生在数据库中，但这并不正确。例如，如果我们使用文档型数据库，如Elasticsearch，我们可能会在两个文档之间出现数据不一致。此外，大多数NoSQL持久化存储系统不支持ACID事务。这意味着你无法在一次操作中持久化或更新多个文档。因此，如果我们向Elasticsearch发送不同的请求，其中一个可能会失败，导致Elasticsearch中持久化的数据不一致。
- en: Keeping data consistent is a challenge. Not leaking infrastructure issues into
    the Domain is a bigger challenge. Aggregates aim to help you with both of these
    things.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 保持数据一致性是一个挑战。不让基础设施问题渗透到领域模型中是一个更大的挑战。聚合（Aggregates）旨在帮助你解决这两个问题。
- en: Key Concepts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键概念
- en: 'Persistence engines — and databases in particular — have some features for
    fighting data inconsistencies: ACID, constraints, referential integrity, locking,
    concurrency controls, and transactions. Let''s review these concepts before working
    with Aggregates.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性引擎——特别是数据库——有一些用于对抗数据不一致性的功能：ACID、约束、引用完整性、锁定、并发控制和事务。在处理聚合之前，让我们回顾这些概念。
- en: Most of these concepts are on the Internet and available to the public. We want
    to thank the people at Oracle, PostgreSQL, and Doctrine for doing amazing work
    with their documentation. They have carefully defined and explained these important
    terms, and rather than reinvent the wheel, we've compiled some of these official
    explanations to share with you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念中的大多数都可以在互联网上找到，对公众开放。我们想感谢Oracle、PostgreSQL和Doctrine团队，他们为他们的文档做了惊人的工作。他们仔细定义并解释了这些重要术语，我们不想重复造轮子，所以我们收集了一些这些官方解释与您分享。
- en: ACID
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID
- en: 'As discussed in a previous section, **ACID** stands for **atomicity**, **consistency**,
    **isolation**, and **durability**. According to the [MySQL Glossary](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_acid):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**ACID**代表**原子性**、**一致性**、**隔离性**和**持久性**。根据[MySQL 术语表](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_acid)：
- en: These properties are all desirable in a database system, and are all closely
    tied to the notion of a transaction. For example, the transactional features of
    MySQL InnoDB engine adhere to the ACID principles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性在数据库系统中都是可取的，并且都与事务的概念紧密相关。例如，MySQL InnoDB引擎的事务功能遵循ACID原则。
- en: Transactions are *atomic* units of work that can be committed or rolled back.
    When a transaction makes multiple changes to the database, either all the changes
    succeed when the transaction is committed, or all the changes are undone when
    the transaction is rolled back.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是可以提交或回滚的工作的**原子**单元。当事务对数据库进行多项更改时，要么在事务提交时所有更改都成功，要么在事务回滚时所有更改都被撤销。
- en: The database remains in a *consistent* state at all times, after each commit
    or rollback, and while transactions are in progress. If related data is being
    updated across multiple tables, queries see either all old values or all new values,
    not a mix of old and new values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库在每次提交或回滚后，以及事务进行期间，始终保持**一致**状态。如果相关数据正在多个表中更新，查询将看到所有旧值或所有新值，而不是旧值和新值的混合。
- en: Transactions are protected *isolated* from each other while they are in progress.
    They cannot interfere with each other or see each other's uncommitted data. This
    isolation is achieved through the locking mechanism. Experienced users can adjust
    the isolation level, trading off less protection in favor of increased performance
    and concurrency, when they can be sure that the transactions really do not interfere
    with each other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行过程中，事务是**隔离**的，彼此之间不会相互干扰或看到对方未提交的数据。这种隔离是通过锁定机制实现的。经验丰富的用户可以在确信事务之间不会相互干扰的情况下，调整隔离级别，以牺牲较少的保护来换取更高的性能和并发性。
- en: 'The results of transactions are *durable*: once a commit operation succeeds,
    the changes made by that transaction are safe from power failures, system crashes,
    race conditions, or other potential dangers that many non-database applications
    are vulnerable to. Durability typically involves writing to disk storage, with
    a certain amount of redundancy to protect against power failures or software crashes
    during write operations.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的结果是**持久**的：一旦提交操作成功，该事务所做的更改就安全免受电源故障、系统崩溃、竞态条件或其他许多非数据库应用程序易受其害的潜在危险的影响。持久性通常涉及写入磁盘存储，并在写入操作期间具有一定的冗余来防止电源故障或软件崩溃。
- en: Transactions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: 'According to the [PostgreSQL 8.2.23 Documentation](https://www.postgresql.org/docs/8.2/static/tutorial-transactions.html):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[PostgreSQL 8.2.23 文档](https://www.postgresql.org/docs/8.2/static/tutorial-transactions.html)：
- en: Transactions are a fundamental concept of all database systems. The essential
    point of a transaction is that it bundles multiple steps into a single, all-or-nothing
    operation. The intermediate states between the steps are not visible to other
    concurrent transactions, and if some failure occurs that prevents the transaction
    from completing, then none of the steps affect the database at all.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是所有数据库系统的基本概念。事务的基本点是它将多个步骤捆绑成一个单一的全有或全无的操作。步骤之间的中间状态对其他并发事务不可见，如果发生某些故障阻止事务完成，则没有任何步骤会影响数据库。
- en: 'For example, consider a bank database that contains balances for various customer
    accounts, as well as total deposit balances for branches. Suppose that we want
    to record a payment of $100.00 from Alice''s account to Bob''s account. Simplifying
    outrageously, the SQL commands for this might look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个包含各种客户账户余额以及分支总存款余额的银行数据库。假设我们想要记录从爱丽丝账户到鲍勃账户的 100.00 美元的付款。极度简化地，这个操作的
    SQL 命令可能如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The details of these commands are not important here. The important point is
    that there are several separate updates involved to accomplish this rather simple
    operation. Our bank''s officers will want to be assured that either all these
    updates happen, or none of them happen. It would certainly not do for a system
    failure to result in Bob receiving $100.00 that was not debited from Alice. Nor
    would Alice long remain a happy customer if she was debited without Bob being
    credited. We need a guarantee that if something goes wrong partway through the
    operation, none of the steps executed so far will take effect. Grouping the updates
    into a transaction gives us this guarantee. A transaction is said to be atomic:
    from the point of view of other transactions, it either happens completely or
    not at all.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的细节在这里并不重要。重要的是，涉及几个单独的更新来完成这个相对简单的操作。我们的银行官员将希望得到保证，要么所有这些更新都发生，要么一个都不发生。如果系统故障导致鲍勃收到本应从爱丽丝账户扣除的
    100.00 美元，那就绝对不行。如果爱丽丝在没有为鲍勃贷记的情况下被扣除，她也不会长期成为满意的客户。我们需要保证，如果在操作过程中出现问题，到目前为止执行的任何步骤都不会生效。将更新分组到事务中给我们这个保证。一个事务被称为原子性的：从其他事务的角度来看，它要么完全发生，要么根本不发生。
- en: 'We also want a guarantee that once a transaction is completed and acknowledged
    by the database system, it has indeed been permanently recorded and won''t be
    lost even if a crash ensues shortly thereafter. For example, if we are recording
    a cash withdrawal by Bob, we do not want any chance that the debit to his account
    will disappear in a crash just after he walks out the bank door. A transactional
    database guarantees that all the updates made by a transaction are logged in permanent
    storage (That is: on disk) before the transaction is reported complete.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有一个保证，一旦交易完成并被数据库系统确认，它确实已经被永久记录，即使在之后不久发生崩溃也不会丢失。例如，如果我们正在记录鲍勃的现金取款，我们不希望在他走出银行大门后，他的账户扣除发生崩溃，导致扣除消失。事务型数据库保证在事务报告完成之前，所有由事务做出的更新都记录在永久存储（即磁盘）中。
- en: 'Another important property of transactional databases is closely related to
    the notion of atomic updates: when multiple transactions are running concurrently,
    each one should not be able to see the incomplete changes made by others. For
    example, if one transaction is busy totalling all the branch balances, it would
    not do for it to include the debit from Alice''s branch but not the credit to
    Bob''s branch, nor vice versa. So transactions must be all-or-nothing not only
    in terms of their permanent effect on the database, but also in terms of their
    visibility as they happen. The updates made so far by an open transaction are
    invisible to other transactions until the transaction completes, whereupon all
    the updates become visible simultaneously.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事务型数据库的另一个重要属性与原子更新的概念密切相关：当多个事务同时运行时，每个事务都不应该能够看到其他事务做出的不完整更改。例如，如果一个事务正在忙于汇总所有分支余额，它不应该包括爱丽丝分支的借记，但不包括鲍勃分支的贷记，反之亦然。因此，事务必须在数据库的永久影响以及它们发生时的可见性方面都是全有或全无。一个打开事务到目前为止做出的更新对其他事务是不可见的，直到事务完成，此时所有更新将同时可见。
- en: 'In PostgreSQL, for example, a transaction is set up by surrounding the SQL
    commands of the transaction with `BEGIN` and `COMMIT` commands. So our banking
    transaction would actually look like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 PostgreSQL 中，通过将事务的 SQL 命令用 `BEGIN` 和 `COMMIT` 命令包围来设置事务。因此，我们的银行交易实际上看起来可能如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If, partway through the transaction, we decide we do not want to commit (perhaps
    we just noticed that Alice's balance went negative), we can issue the command
    `ROLLBACK` instead of `COMMIT`, and all our updates so far will be canceled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在事务进行过程中我们决定不想提交（也许我们只是注意到爱丽丝的余额变成了负数），我们可以发出 `ROLLBACK` 命令而不是 `COMMIT`，我们到目前为止的所有更新将被取消。
- en: PostgreSQL actually treats every SQL statement as being executed within a transaction.
    If you do not issue a `BEGIN` command, then each individual statement has an implicit
    `BEGIN` and (if successful) `COMMIT` wrapped around it. A group of statements
    surrounded by `BEGIN` and `COMMIT` is sometimes called a transaction block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL实际上将每个SQL语句都视为在事务中执行。如果你没有发出`BEGIN`命令，那么每个单独的语句都有一个隐式的`BEGIN`和（如果成功）`COMMIT`包围它。由`BEGIN`和`COMMIT`包围的一组语句有时被称为事务块。
- en: All this is happening within the transaction block, so none of it is visible
    to other database sessions. When and if you commit the transaction block, the
    committed actions become visible as a unit to other sessions, while the rolled-back
    actions never become visible at all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都在事务块内进行，因此对其他数据库会话不可见。当你提交事务块时，提交的操作作为一个单元对其他会话可见，而回滚的操作永远不会可见。
- en: Isolation Levels
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离级别
- en: 'According to the [MySQL Glossary](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level),
    transaction isolation is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[MySQL术语表](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level)，事务隔离是：
- en: One of the foundations of database processing. Isolation is the "I" in the acronym
    ACID. The isolation level is the setting that fine-tunes the balance between performance
    and reliability, consistency, and reproducibility of results when multiple transactions
    are making changes and performing queries at the same time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库处理的基础之一。隔离是ACID缩写中的“I”。隔离级别是调整多个事务同时进行更改和执行查询时性能与可靠性、一致性和结果可重复性之间平衡的设置。
- en: 'From highest amount of consistency and protection to the least, the isolation
    levels supported by InnoDB, for example, are: `SERIALIZABLE`, `REPEATABLE READ`,
    `READ COMMITTED`, and `READ UNCOMMITTED`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从最高的一致性和保护程度到最低，InnoDB支持的隔离级别，例如，有：`SERIALIZABLE`、`REPEATABLE READ`、`READ COMMITTED`和`READ
    UNCOMMITTED`。
- en: With InnoDB tables, many users can keep the default isolation level `REPEATABLE
    READ` for all operations. Expert users might choose the read committed level as
    they push the boundaries of scalability with OLTP processing, or during data warehousing
    operations where minor inconsistencies do not affect the aggregate results of
    large amounts of data. The levels on the edges (`SERIALIZABLE` and `READ UNCOMMITTED`)
    change the processing behavior to such an extent that they are rarely used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在InnoDB表中，许多用户可以将所有操作的默认隔离级别设置为`REPEATABLE READ`。专家用户可能会选择`READ COMMITTED`级别，因为他们通过OLTP处理推动可扩展性的边界，或者在数据仓库操作期间，其中轻微的不一致性不会影响大量数据的汇总结果。边缘级别（`SERIALIZABLE`和`READ
    UNCOMMITTED`）会改变处理行为，以至于它们很少被使用。
- en: Referential Integrity
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参照完整性
- en: 'According to the [MySQL Glossary](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_referential_integrity),
    referential integrity is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[MySQL术语表](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_referential_integrity)，参照完整性是：
- en: The technique of maintaining data always in a consistent format, part of the
    ACID philosophy. In particular, data in different tables is kept consistent through
    the use of foreign key constraints, which can prevent changes from happening or
    automatically propagate those changes to all related tables. Related mechanisms
    include the unique constraint, which prevents duplicate values from being inserted
    by mistake, and the `NOT NULL` constraint, which prevents blank values from being
    inserted by mistake.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保持数据始终处于一致格式的技术，是ACID哲学的一部分。特别是，通过使用外键约束来保持不同表中数据的一致性，这可以防止更改发生或自动将更改传播到所有相关表中。相关的机制包括唯一约束，它可以防止错误地插入重复值，以及`NOT
    NULL`约束，它可以防止错误地插入空值。
- en: Locking
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定
- en: 'According to the [MySQL Glossary](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking),
    locking is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[MySQL术语表](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking)，锁定是：
- en: The system of protecting a transaction from seeing or changing data that is
    being queried or changed by other transactions. The locking strategy must balance
    reliability and consistency of database operations (the principles of the ACID
    philosophy) against the performance needed for good concurrency. Fine-tuning the
    locking strategy often involves choosing an isolation level and ensuring all your
    database operations are safe and reliable for that isolation level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保护事务免受其他事务查询或更改的数据查看或更改的系统。锁定策略必须在数据库操作的可靠性、一致性（ACID哲学的原则）和良好并发性所需性能之间取得平衡。微调锁定策略通常涉及选择一个隔离级别，并确保所有数据库操作都适用于该隔离级别，且安全可靠。
- en: Concurrency
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: 'According to the [MySQL Glossary](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_concurrency),
    concurrency is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[MySQL 术语表](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_concurrency)，并发性是：
- en: The ability of multiple operations (in database terminology, transactions) to
    run simultaneously, without interfering with each other. Concurrency is also involved
    with performance, because ideally the protection for multiple simultaneous transactions
    works with a minimum of performance overhead, using efficient mechanisms for locking.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 多个操作（在数据库术语中称为事务）能够同时运行，而不相互干扰的能力。并发性也与性能有关，因为理想情况下，对多个同时进行的事务的保护应具有最小的性能开销，并使用高效的锁定机制。
- en: Pessimistic Concurrency Control (PCC)
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悲观并发控制（PCC）
- en: 'The book [Elasticsearch: The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc) by
    Clinton Gormley and Zachary Tong discusses PCC, saying that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '由克林顿·戈姆利和扎卡里·汤格合著的[《Elasticsearch: The Definitive Guide》](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc)一书讨论了PCC，说：'
- en: Widely used by relational databases, this approach assumes that conflicting
    changes are likely to happen and so blocks access to a resource in order to prevent
    conflicts. A typical example is locking a row before reading its data, ensuring
    that only the thread that placed the lock is able to make changes to the data
    in that row.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中广泛使用的方法，它假设冲突更改很可能发生，因此阻止对资源的访问以防止冲突。一个典型的例子是在读取数据之前锁定一行，确保只有放置锁的线程能够更改该行中的数据。
- en: With Doctrine
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Doctrine 中
- en: 'According to the [Doctrine 2 ORM Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#locking-support) on
    locking support:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[Doctrine 2 ORM 文档](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#locking-support)中对锁定支持的解释：
- en: Doctrine 2 offers support for Pessimistic- and Optimistic-locking strategies
    natively. This allows to take very fine-grained control over what kind of locking
    is required for your Entities in your application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 2 本地支持悲观锁定和乐观锁定策略。这允许对应用程序中实体的锁定类型进行非常细粒度的控制。
- en: 'According to the [Doctrine 2 ORM Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#pessimistic-locking) on
    pessimistic locking:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[Doctrine 2 ORM 文档](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#pessimistic-locking)中对悲观锁的解释：
- en: Doctrine 2 supports Pessimistic Locking at the database level. No attempt is
    being made to implement pessimistic locking inside Doctrine, rather vendor-specific
    and ANSI-SQL commands are used to acquire row-level locks. Every Doctrine Entity
    can be part of a pessimistic lock, there is no special metadata required to use
    this feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 2 在数据库级别支持悲观锁定。没有尝试在 Doctrine 内部实现悲观锁定，而是使用供应商特定的和 ANSI-SQL 命令来获取行级锁。每个
    Doctrine 实体都可以成为悲观锁的一部分，无需特殊元数据即可使用此功能。
- en: However for Pessimistic Locking to work you have to disable the Auto-Commit
    Mode of your Database and start a transaction around your pessimistic lock use-case
    using the *Explicit Transaction Demarcation*. Doctrine 2 will throw an Exception
    if you attempt to acquire an pessimistic lock and no transaction is running.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使悲观锁定工作，您必须禁用数据库的自动提交模式，并在使用悲观锁的场景周围启动一个事务，使用*显式事务界定*。如果您尝试获取悲观锁而没有正在运行的事务，Doctrine
    2 将抛出异常。
- en: 'Doctrine 2 currently supports two pessimistic lock modes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 2 当前支持两种悲观锁定模式：
- en: Pessimistic Write `Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE`, locks the underlying
    database rows for concurrent Read and Write Operations.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悲观写 `Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE`，锁定底层数据库行以进行并发读和写操作。
- en: Pessimistic Read `Doctrine\DBAL\LockMode::PESSIMISTIC_READ`, locks other concurrent
    requests that attempt to update or lock rows in write mode.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悲观读 `Doctrine\DBAL\LockMode::PESSIMISTIC_READ`，锁定其他尝试以写模式更新或锁定行的并发请求。
- en: 'You can use pessimistic locks in three different scenarios:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在三种不同的场景中使用悲观锁：
- en: Using `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)`
    or `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)`
    或 `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
- en: Using `EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)`
    or `EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)`
    或 `EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
- en: Using `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)` or `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)` 或 `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
- en: Optimistic Concurrency Control
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悲观并发控制
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/Optimistic_concurrency_control):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [维基百科](https://en.wikipedia.org/wiki/Optimistic_concurrency_control)：
- en: '**Optimistic concurrency control** (**OCC**) is a concurrency control method
    applied to transactional systems such as relational database management systems
    and software transactional memory. OCC assumes that multiple transactions can
    frequently complete without interfering with each other. While running, transactions
    use data resources without acquiring locks on those resources. Before committing,
    each transaction verifies that no other transaction has modified the data it has
    read. If the check reveals conflicting modifications, the committing transaction
    rolls back and can be restarted. Optimistic concurrency control was first proposed
    by H.T. Kung.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**乐观并发控制** (**OCC**) 是一种应用于事务系统（如关系数据库管理系统和软件事务内存）的并发控制方法。OCC 假设多个事务可以频繁完成而不会相互干扰。在运行过程中，事务使用数据资源而不锁定这些资源。在提交之前，每个事务都会验证是否有其他事务修改了它所读取的数据。如果检查发现冲突修改，提交事务将回滚并可以重新启动。乐观并发控制最初由
    H.T. Kung 提出。'
- en: OCC is generally used in environments with low data contention. When conflicts
    are rare, transactions can complete without the expense of managing locks and
    without having transactions wait for other transactions' locks to clear, leading
    to higher throughput than other concurrency control methods. However, if contention
    for data resources is frequent, the cost of repeatedly restarting transactions
    hurts performance significantly; it is commonly thought that other concurrency
    control methods have better performance under these conditions. However, locking-based
    "pessimistic" methods also can deliver poor performance because locking can drastically
    limit effective concurrency even when deadlocks are avoided.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OCC 通常用于数据竞争较低的环境。当冲突很少时，事务可以在不管理锁和事务等待其他事务的锁释放的情况下完成，从而比其他并发控制方法具有更高的吞吐量。然而，如果数据资源竞争频繁，重复重启事务的成本会显著损害性能；通常认为在这些条件下，其他并发控制方法具有更好的性能。然而，基于锁定的“悲观”方法也可能导致性能不佳，因为即使避免了死锁，锁定也会极大地限制有效并发。
- en: With Elasticsearch
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elasticsearch
- en: 'According to [Elasticsearch: The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc),
    when OCC is used by Elasticsearch:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '根据 [Elasticsearch: The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc)，当
    Elasticsearch 使用 OCC 时：'
- en: This approach assumes that conflicts are unlikely to happen and doesn't block
    operations from being attempted. However, if the underlying data has been modified
    between reading and writing, the update will fail. It is then up to the application
    to decide how it should resolve the conflict. For instance, it could reattempt
    the update, using the fresh data, or it could report the situation to the user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法假设冲突不太可能发生，不会阻止操作尝试。然而，如果在读取和写入之间底层数据已被修改，更新将失败。然后应用程序需要决定如何解决冲突。例如，它可以重新尝试更新，使用新鲜的数据，或者它可以向用户报告这种情况。
- en: Elasticsearch is distributed. When documents are created, updated, or deleted,
    the new version of the document has to be replicated to other nodes in the cluster.
    Elasticsearch is also asynchronous and concurrent, meaning that these replication
    requests are sent in parallel, and may arrive at their destination out of sequence.
    Elasticsearch needs a way of ensuring that an older version of a document never
    overwrites a newer version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 是分布式的。当文档被创建、更新或删除时，文档的新版本必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求是并行发送的，并且可能以错误的顺序到达目的地。Elasticsearch
    需要一种确保旧版本的文档永远不会覆盖新版本的方法。
- en: Every document has a _version number that is incremented whenever a document
    is changed. Elasticsearch uses this _version number to ensure that changes are
    applied in the correct order. If an older version of a document arrives after
    a new version, it can simply be ignored.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档都有一个 _版本号，每当文档被更改时都会递增。Elasticsearch 使用这个 _版本号来确保更改按正确的顺序应用。如果一个旧版本的文档在新的版本之后到达，它可以直接被忽略。
- en: We can take advantage of the _version number to ensure that conflicting changes
    made by our application do not result in data loss. We do this by specifying the
    version number of the document that we wish to change. If that version is no longer
    current, our request fails.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 _版本号来确保我们的应用程序所做的冲突更改不会导致数据丢失。我们通过指定我们希望更改的文档的版本号来实现这一点。如果该版本已不再是最新的，我们的请求将失败。
- en: 'Let''s create a new blog post:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的博客文章：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The response body tells us that this newly created document has _version number
    1\. Now imagine that we want to edit the document: we load its data into a web
    form, make our changes, and then save the new version.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体告诉我们这个新创建的文档的 _版本号是 1。现在想象一下，如果我们想编辑这个文档：我们将它的数据加载到一个网页表单中，进行更改，然后保存新的版本。
- en: 'First we retrieve the document:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索文档：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The response body includes the same _version number of 1:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体包含相同的 _版本号 1：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, when we try to save our changes by reindexing the document, we specify
    the version to which our changes should be applied. We want this update to succeed
    only if the current _version of this document in our index is version 1:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试通过重新索引文档来保存我们的更改时，我们指定了更改应该应用到的版本。我们希望这次更新只在我们索引中此文档的当前 _版本是版本 1 的情况下成功：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This request succeeds, and the response body tells us that the _version has
    been incremented to 2:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求成功了，响应体告诉我们 _版本号已经增加到 2：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, if we were to rerun the same index request, still specifying `version=1`,
    Elasticsearch would respond with a `409` Conflict HTTP response code, and a body
    like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们重新运行相同的索引请求，仍然指定 `version=1`，Elasticsearch 将会响应一个 `409` 冲突 HTTP 响应代码，以及如下所示的响应体：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells us that the current _version number of the document in Elasticsearch
    is 2, but that we specified that we were updating version 1.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，在 Elasticsearch 中的文档当前 _版本号是 2，但我们指定了我们在更新版本 1。
- en: What we do now depends on our application requirements. We could tell the user
    that somebody else has already made changes to the document, and to review the
    changes before trying to save them again. Alternatively, as in the case of the
    widget `stock_count` previously, we could retrieve the latest document and try
    to reapply the change.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的一切都取决于我们的应用程序需求。我们可以告诉用户，其他人已经对文档进行了更改，在尝试再次保存之前需要审查这些更改。或者，就像之前 `stock_count`
    小部件的情况一样，我们可以检索最新的文档并尝试重新应用更改。
- en: All APIs that update or delete a document accept a version parameter, which
    allows you to apply optimistic concurrency control to just the parts of your code
    where it makes sense.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有更新或删除文档的 API 都接受一个版本参数，这允许你仅在你代码的合理部分应用乐观并发控制。
- en: With Doctrine
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Doctrine
- en: 'According to the [Doctrine 2 ORM Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#optimistic-locking)
    on optimistic locking:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [Doctrine 2 ORM 文档](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#optimistic-locking)中关于乐观锁的说明：
- en: Database transactions are fine for concurrency control during a single request.
    However, a database transaction should not span across requests, the so-called
    "user think time". Therefore a long-running "business transaction" that spans
    multiple requests needs to involve several database transactions. Thus, database
    transactions alone can no longer control concurrency during such a long-running
    business transaction. Concurrency control becomes the partial responsibility of
    the application itself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库事务在单个请求期间的并发控制中是可行的。然而，数据库事务不应跨越请求，即所谓的“用户思考时间”。因此，跨越多个请求的长时间运行的“业务事务”需要涉及多个数据库事务。因此，仅靠数据库事务本身已无法在如此长时间运行的业务事务中控制并发。并发控制变成了应用程序自身的部分责任。
- en: 'Doctrine has integrated support for automatic optimistic locking via a version
    field. In this approach any entity that should be protected against concurrent
    modifications during long-running business transactions gets a version field that
    is either a simple number (mapping type: `integer`) or a timestamp (mapping type:
    `datetime`). When changes to such an entity are persisted at the end of a long-running
    conversation the version of the entity is compared to the version in the database
    and if they don''t match, an `OptimisticLockException` is thrown, indicating that
    the entity has been modified by someone else already.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 通过版本字段集成了对自动乐观锁的支持。在这种方法中，任何在长时间运行的业务事务期间应防止并发修改的实体都会获得一个版本字段，该字段可以是简单的数字（映射类型：`integer`）或时间戳（映射类型：`datetime`）。当在长时间对话结束时持久化对这种实体的更改时，会将实体的版本与数据库中的版本进行比较，如果它们不匹配，则会抛出
    `OptimisticLockException` 异常，表明实体已被其他人修改。
- en: 'You designate a version field in an entity as follows. In this example we''ll
    use an integer:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在实体中指定一个版本字段，如下所示。在这个例子中，我们将使用整数：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When a version conflict is encountered during `EntityManager#flush()`, an `OptimisticLockException`
    is thrown and the active transaction rolled back (or marked for rollback). This
    exception can be caught and handled. Potential responses to an `OptimisticLockException`
    are to present the conflict to the user or to refresh or reload objects in a new
    transaction and then retrying the transaction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `EntityManager#flush()` 过程中遇到版本冲突时，会抛出 `OptimisticLockException` 异常，并回滚（或标记为回滚）活动事务。这个异常可以被捕获和处理。对
    `OptimisticLockException` 的潜在响应包括向用户展示冲突，或者在新的事务中刷新或重新加载对象，然后重试事务。
- en: 'With PHP promoting a share-nothing architecture, the time between showing an
    update form and actually modifying the entity can in the worst scenario be as
    long as your applications session timeout. If changes happen to the entity in
    that time frame you want to know directly when retrieving the entity that you
    will hit an optimistic locking exception:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 PHP 推崇无共享架构，从显示更新表单到实际修改实体之间的时间，在最坏的情况下可能长达你的应用程序会话超时时间。如果在那个时间段内实体发生了变化，你希望在检索实体时直接知道你会遇到乐观锁异常：
- en: 'You can always verify the version of an entity during a request either when
    calling `EntityManager#find()`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在请求期间验证实体的版本，无论是调用 `EntityManager#find()`：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or you can use `EntityManager#lock()` to find out:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `EntityManager#lock()` 来找出：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'According to [Doctrine 2 ORM](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes)
    [Document](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes)[ation''s](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes) important
    implementation notes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [Doctrine 2 ORM](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes)
    [文档](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes)[的](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/transactions-and-concurrency.html#important-implementation-notes)重要实现说明：
- en: 'You can easily get the optimistic locking workflow wrong if you compare the
    wrong versions. Say you have Alice and Bob editing a hypothetical blog post:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较了错误的版本，很容易出错。比如说，Alice 和 Bob 正在编辑一个假设的博客文章：
- en: Alice reads the headline of the blog post being "Foo", at optimistic lock version
    1 (`GET` Request)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 在乐观锁版本 1 (`GET` 请求) 时阅读了标题为 "Foo" 的博客文章
- en: Bob reads the headline of the blog post being "Foo", at optimistic lock version
    1 (`GET` Request)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 在乐观锁版本 1 (`GET` 请求) 时阅读了标题为 "Foo" 的博客文章
- en: Bob updates the headline to "Bar", upgrading the optimistic lock version to
    2 (`POST` Request of a Form)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob将标题更新为"Bar"，将乐观锁定版本升级到2（表单的`POST`请求）
- en: Alice updates the headline to "Baz", ... (`POST` Request of a Form)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice将标题更新为"Baz"，...（表单的`POST`请求）
- en: Now at the last stage of this scenario the blog post has to be read again from
    the database before Alice's headline can be applied. At this point you will want
    to check if the blog post is still at version 1 (which it is not in this scenario).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景的最后阶段，在Alice应用标题之前，必须再次从数据库中读取博客文章。此时，你将想要检查博客文章是否仍然是版本1（在这个场景中它不是）。
- en: Using optimistic locking correctly, you have to add the version as an additional
    hidden field (or into the `SESSION` for more safety). Otherwise you cannot verify
    the version is still the one being originally read from the database when Alice
    performed her `GET` request for the blog post. If this happens you might see lost
    updates you wanted to prevent with Optimistic Locking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用乐观锁定，你必须将版本作为额外的隐藏字段添加（或者为了更安全地将其放入`SESSION`）。否则，你无法验证版本是否仍然是Alice执行博客文章`GET`请求时从数据库中最初读取的那个。如果发生这种情况，你可能会看到你想要通过乐观锁定防止丢失的更新。
- en: 'See the example code, The form (`GET` Request):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看示例代码，表单（`GET` 请求）：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And the change headline action (`POST` Request):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更改标题的动作（`POST` 请求）：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wow — that was a lot of information to take in. However, don't worry if you
    don't completely understand everything. The more you work with Aggregates and
    Domain-Driven Design, the more you'll encounter moments when transactionality
    has to be considered in designing your Application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哇——这真是太多信息要吸收了。然而，如果你不完全理解一切，请不要担心。你与聚合和领域驱动设计工作得越多，你将越会遇到在设计应用程序时必须考虑事务性的时刻。
- en: To summarize, if you want to keep your data consistent, use transactions. However,
    be careful about overusing transactions or locking strategies because these can
    slow your Application down or make it unusable. If you want to have a really fast
    Application, optimistic concurrency can help you. Last but not least, some data
    can eventually be consistent. This means that we allow our data to not be consistent
    for a particular window of time. During that time, some inconsistencies are acceptable.
    Eventually, an asynchronous process will perform the final task to remove such
    inconsistencies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你想保持数据的一致性，请使用事务。然而，要注意不要过度使用事务或锁定策略，因为这些可能会减慢你的应用程序速度或使其无法使用。如果你想拥有一个真正快速的应用程序，乐观并发可以帮助你。最后但同样重要的是，某些数据最终可能是一致的。这意味着我们允许我们的数据在特定的时间窗口内不一致。在这段时间内，一些不一致是可以接受的。最终，异步进程将执行最终任务以消除这种不一致。
- en: What Is an Aggregate?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是聚合？
- en: 'Aggregates are Entities that hold other Entities and Value Objects that help
    keep data consistent. From Vaughn Vernon''s [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是包含其他实体和值对象以帮助保持数据一致的实体。从Vaughn Vernon的[实现领域驱动设计](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)：
- en: Aggregates are carefully crafted consistency boundaries that cluster Entities
    and Value Objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是精心设计的用于聚集实体和值对象的一致性边界。
- en: 'Another amazing book that you should definitely buy and read is [NoSQL Distilled:
    A Brief Guide to the Emerging World of Polyglot Persistence](https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620?) by
    Pramod J. Sadalage and Martin Fowler. This book says that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '另一本你绝对应该购买并阅读的精彩书籍是Pramod J. Sadalage和Martin Fowler合著的[NoSQL Distilled: A Brief
    Guide to the Emerging World of Polyglot Persistence](https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620?)。这本书说：'
- en: In Domain-Driven Design, an aggregate is a collection of related objects that
    we wish to treat as a unit. In particular, it is a unit for data manipulation
    and management of consistency. Typically, we like to update aggregates with atomic
    operations and communicate with our data storage in terms of aggregates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计中，聚合是我们希望将其视为单一实体的相关对象的集合。特别是，它是数据操作和一致性管理的一个单元。通常，我们喜欢使用原子操作更新聚合，并以聚合的形式与我们的数据存储进行通信。
- en: What Martin Fowler Says...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 马丁·福勒怎么说...
- en: 'From [http://martinfowler.com/bliki/DDD_Aggregate.html](http://martinfowler.com/bliki/DDD_Aggregate.html):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[http://martinfowler.com/bliki/DDD_Aggregate.html](http://martinfowler.com/bliki/DDD_Aggregate.html)：
- en: Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster
    of domain objects that can be treated as a single unit. An example may be an order
    and its line-items, these will be separate objects, but it is useful to treat
    the order (together with its line items) as a single aggregate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是领域驱动设计中的一个模式。DDD 集合是一组可以被视为单一单元的领域对象。一个例子可能是一个订单及其行项目，这些将是单独的物体，但将订单（及其行项目）作为一个单一集合来处理是有用的。
- en: An aggregate will have one of its component objects be the aggregate root. Any
    references from outside the aggregate should only go to the aggregate root. The
    root can thus ensure the integrity of the aggregate as a whole.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合将有一个组件对象作为集合根。来自集合外部的任何引用都应该只指向集合根。因此，根可以确保整个集合的完整性。
- en: Aggregates are the basic element of transfer of data storage you request to
    load or save whole aggregates. Transactions should not cross aggregate boundaries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是您请求加载或保存整个集合的数据存储传输的基本元素。事务不应跨越集合边界。
- en: 'DDD Aggregates are sometimes confused with collection classes (lists, maps,
    and so on). DDD aggregates are domain concepts (order, clinic visit, playlist),
    while collections are generic. An aggregate will often contain multiple collections,
    together with simple fields. The term *aggregate* is a common one, and is used
    in various different contexts (example: UML), in which case it does not refer
    to the same concept as a DDD aggregate.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 集合有时会与集合类（列表、映射等）混淆。DDD 集合是领域概念（订单、诊所访问、播放列表），而集合是通用的。一个集合通常会包含多个集合，以及简单的字段。术语“集合”是一个常见的术语，在不同的上下文中使用（例如：UML），在这种情况下，它并不指代与
    DDD 集合相同的概念。
- en: What Wikipedia Says...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维基百科上是这样说的...
- en: 'From [https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD](https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '来自 [https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD](https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD):'
- en: 'Aggregate: A collection of objects that are bound together by a root entity,
    otherwise known as an aggregate root. The aggregate root guarantees the consistency
    of changes being made within the aggregate by forbidding external objects from
    holding references to its members.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 集合：一组通过根实体（也称为集合根）绑定在一起的物体。集合根通过禁止外部对象持有其成员的引用来保证集合内更改的一致性。
- en: 'Example: When you drive a car, you do not have to worry about moving the wheels
    forward, making the engine combust with spark and fuel, etc.; you are simply driving
    the car. In this context, the car is an aggregate of several other objects and
    serves as the aggregate root to all of the other systems.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：当你开车时，你不必担心如何让车轮向前移动，让发动机通过火花和燃料燃烧等；你只是在开车。在这个背景下，汽车是几个其他物体的集合，并作为所有其他系统的集合根。
- en: Why Aggregates?
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要集合？
- en: 'The avid reader will probably be wondering what all of this has to do with
    Aggregates and Aggregate Design. And actually, that''s a pretty good question.
    There''s a direct relation, so let''s explore it. The Relational Model uses tables
    to store data. Those tables are composed of rows, where each row usually represents
    an instance of a concept of the application''s interest. Additionally, each row
    can point to other rows on other tables of the same database, and the consistency
    between this relationship can be kept by the use of referential integrity. This
    model is fine; however, it lacks a very basic word: the *object* word.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 热心的读者可能会想知道所有这些与集合和集合设计有什么关系。实际上，这是一个很好的问题。它们之间有直接的关系，所以让我们来探讨一下。关系模型使用表来存储数据。这些表由行组成，其中每一行通常代表应用程序感兴趣的概念的一个实例。此外，每一行可以指向同一数据库中其他表的行，这种关系的一致性可以通过使用引用完整性来保持。这个模型是好的；然而，它缺少一个非常基本的词：*对象*这个词。
- en: Indeed, when we talk about the Relational Model, we're namely talking about
    tables, rows, and relationships between rows. And when we talk about the Object-Oriented
    Model, we're talking mainly about compositions of objects. So every time we fetch
    data — a set of rows — from a relational database, we run a translation process
    responsible for building an in-memory representation we can operate with. The
    same applies to the opposite direction. Every time we need to store an object
    in the database, we should run the other translation process to translate that
    object to a given set of rows or tables. This translation, from object to rows
    or tables, means that you may run different queries against your database. As
    such, without using any specific tool, such as transactions, it's impossible to
    guarantee the data will be persisted consistently. This problem is the so-called
    **impedance mismatch**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们谈论关系模型时，我们实际上是在谈论表、行以及行之间的关系。而当我们谈论面向对象模型时，我们主要是在谈论对象的组合。所以每次我们从关系型数据库中检索数据——一组行——时，我们都会运行一个转换过程，负责构建一个我们可以操作的内存表示。同样的情况也适用于相反的方向。每次我们需要在数据库中存储一个对象时，我们都应该运行另一个转换过程，将该对象转换为一个特定的行集或表。这种从对象到行或表的转换意味着你可能需要对数据库运行不同的查询。因此，不使用任何特定的工具，如事务，不可能保证数据的一致性。这个问题就是所谓的**阻抗不匹配**。
- en: Impedance Mismatch
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 阻抗不匹配
- en: The object-relational impedance mismatch is a set of conceptual and technical
    difficulties that are often encountered when a **relational database management
    system** (**RDBMS**) is being used by a program written in an object-oriented
    programming language or style, particularly when objects or class definitions
    are mapped in a straightforward way to database tables or relational schemata.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象关系阻抗不匹配是一组概念和技术困难，当使用面向对象编程语言或风格的程序编写时，尤其是在对象或类定义直接映射到数据库表或关系模式时，经常会遇到这些问题。
- en: Extracted from [Wikipedia](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提取自 [维基百科](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)
- en: The impedance mismatch [is not an easy problem to solve](http://martinfowler.com/bliki/OrmHate.html),
    so we highly discourage trying to solve it on your own. It would be a huge undertaking,
    and it's simply not worth the effort. Luckily, there are some libraries out there
    that take care of this translation process. They're commonly known as Object-Relational
    Mappers (which we've discussed in earlier chapters) and their primary concern
    is to ease the process of translating from the Relational Model to the Object-Oriented
    Model, and vice versa.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 阻抗不匹配[不是一个容易解决的问题](http://martinfowler.com/bliki/OrmHate.html)，所以我们强烈建议不要自己尝试解决它。这将是一项巨大的任务，而且根本不值得付出努力。幸运的是，有一些库可以处理这个转换过程。它们通常被称为对象关系映射器（我们在前面的章节中讨论过），它们的主要关注点是简化从关系模型到面向对象模型以及相反方向的转换过程。
- en: This is an issue that also affects NoSQL persistence engines and not just databases.
    Most NoSQL engines use documents. An Entity is translated into a document representation
    such as JSON, XML, binary, and so on. and then persisted. The main difference
    with RDBMS databases is that if a main Entity (such as `Order`) has other related
    Entities (such as `OrderLines`), you can more easily design a single JSON document
    that will contain all the information. With this approach, with a single request
    to your NoSQL engine, you don't need transactions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个也会影响NoSQL持久化引擎，而不仅仅是数据库的问题。大多数NoSQL引擎使用文档。实体被转换为一个文档表示，如JSON、XML、二进制等，然后进行持久化。与RDBMS数据库的主要区别在于，如果一个主实体（如`Order`）有其他相关实体（如`OrderLines`），你可以更容易地设计一个包含所有信息的单一JSON文档。采用这种方法，通过向你的NoSQL引擎发送一个单一请求，你不需要事务。
- en: Nevertheless, if you're using NoSQL or RDBMS for fetching and persisting your
    Entities, you'll need one or more queries. In order to ensure data consistency,
    those queries or requests need to be executed as a single operation. Running as
    a single operation can guarantee that data will be consistent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用NoSQL或RDBMS来检索和持久化你的实体，你需要一个或多个查询。为了确保数据一致性，这些查询或请求需要作为一个单一操作执行。作为一个单一操作执行可以保证数据的一致性。
- en: What does consistent mean? It means that all data persisted into our database
    must be compliant with all business rules, also known as invariants. An example
    of a business invariant could be how on GitHub, a user is able to have unlimited
    public repositories but no private repositories. However, if this user pays $12
    per month, then they're able to have up to 10 private repositories.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性意味着什么？这意味着所有持久化到我们数据库中的数据都必须符合所有业务规则，也称为不变量。一个业务不变量的例子可能是GitHub上，一个用户能够拥有无限数量的公共仓库但没有私有仓库。然而，如果这个用户每月支付12美元，那么他们可以拥有多达10个私有仓库。
- en: 'Relational databases provide three main tools for helping us with data consistency:
    * **Referential** integrity: Foreign keys, nullable checks, and so on. * **Transactions**:
    Run multiple queries as a single operation. The problem with transactions is the
    same as that of branches and merges in your code repository. Keeping a branch
    has a performance cost (memory, CPU, storage, indexing, and so on.). If too many
    people (concurrency) are touching the same data, conflicts will occur and transaction
    commits will fail. * **Locking**: Block rows or tables. Other queries around the
    same tables and rows must wait for the block to be removed. Locking has a negative
    impact on the performance of your application.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库提供了三个主要工具来帮助我们实现数据一致性：* **引用完整性**：外键、可空性检查等。* **事务**：将多个查询作为一个单一操作运行。事务的问题与你的代码仓库中的分支和合并相同。保持分支有性能成本（内存、CPU、存储、索引等）。如果太多人（并发）正在接触相同的数据，将发生冲突，事务提交将失败。*
    **锁定**：阻塞行或表。围绕相同表和行的其他查询必须等待锁定被移除。锁定对你的应用程序性能有负面影响。
- en: 'Suppose we have an e-commerce application we want to expand to other countries
    and regions, and suppose the release goes fairly well and sales increase. A pretty
    evident side effect of the release is that the database should be able to handle
    the additional load increase. As seen earlier, there are two scaling methods:
    up or out.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个电子商务应用程序，我们希望将其扩展到其他国家地区，并且假设发布进展顺利，销售额增加。发布的一个明显副作用是数据库应该能够处理额外的负载增加。如前所述，有两种扩展方法：向上或向外。
- en: 'Scaling up means we improve the hardware infrastructure we have (For example:
    better CPU, more memory, better hard disks). Scaling out means adding more machines
    that will organize in a cluster for doing specific work. In this case, we could
    have a cluster of databases.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着我们改进我们已有的硬件基础设施（例如：更好的CPU、更多的内存、更好的硬盘）。扩展意味着添加更多的机器，这些机器将组织成集群以执行特定的工作。在这种情况下，我们可能有一个数据库集群。
- en: But relational databases aren't designed to scale horizontally, since we can't
    configure them to save one set of rows to a given machine and another set of rows
    to a different one. Relational databases are easy to scale up, but **the Relational
    Model doesn't scale horizontally**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但关系数据库并不是为了横向扩展而设计的，因为我们无法配置它们将一组行保存到一台机器上，而另一组行保存到另一台机器上。关系数据库很容易向上扩展，但**关系模型无法横向扩展**。
- en: 'In the NoSQL world, data consistency is a bit more difficult: transactions
    and referential integrity aren''t generally supported, while locking is supported
    but generally not encouraged.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL世界中，数据一致性要困难一些：事务和引用完整性通常不支持，而锁定是支持的，但通常不鼓励。
- en: NoSQL databases aren't affected as drastically by the impedance mismatch. They
    match perfectly with Aggregate Design because they enable us to easily store and
    retrieve single units atomically. For example, when using a key-value store such
    as Redis, an Aggregate could be serialized and stored on a specific key. On a
    document-oriented store such as Elasticsearch, an Aggregate would be serialized
    into a JSON and persisted as a document. As mentioned before, the problem comes
    when multiple documents must be updated at once.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库不会受到阻抗不匹配的严重影响。它们与聚合设计完美匹配，因为它们使我们能够轻松地原子性地存储和检索单个单元。例如，当使用像Redis这样的键值存储时，一个聚合可以被序列化并存储在特定的键上。在一个面向文档的存储，如Elasticsearch上，一个聚合会被序列化为JSON并作为文档持久化。正如之前提到的，问题出现在必须同时更新多个文档时。
- en: For that reason, when persisting any object with a single representation (one
    document, so no multiple queries needed), it's easy to distribute those single
    units across several machines, called nodes, which make up a cluster of NoSQL
    databases. It's common knowledge that these databases are easy to distribute,
    which means that the style of databases is easy to scale horizontally.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当持久化具有单一表示（一个文档，因此不需要多个查询）的任何对象时，很容易将这些单一单元分布到多个机器上，这些机器被称为节点，构成了一个NoSQL数据库集群。众所周知，这些数据库易于分布，这意味着数据库的风格易于横向扩展。
- en: A Bit of History
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史
- en: 'Around the beginning of the 21st century, companies such as Amazon and Google
    grew massively. In order to consolidate their growth, they used clustering techniques:
    not only did they have better servers, but they also relied on many more of them
    working together.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在21世纪初，像亚马逊和谷歌这样的公司迅速增长。为了巩固他们的增长，他们使用了聚类技术：他们不仅拥有更好的服务器，而且依赖更多的服务器协同工作。
- en: In a scenario such as this, deciding how to store your data is key. If you take
    an Entity and spread its information throughout multiple servers, in multiple
    nodes of a cluster, the effort needed to control transactions is high. The same
    thing applies if you want to fetch an Entity. So if you can design your Entity
    in a way that is persisted in the node of a cluster, it makes things much easier.
    That's one of the reasons why Aggregate Design is so important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的场景中，决定如何存储你的数据是关键。如果你将一个实体分散到多个服务器，多个集群节点中，控制事务所需的工作量就很高。如果你想要获取一个实体，也是如此。所以，如果你能以某种方式设计你的实体，使其在集群的节点中持久化，那么事情就会容易得多。这就是为什么聚合设计如此重要的原因之一。
- en: 'If you want to know more about the history of Aggregate Design outside of Domain-Driven
    Design, take a look at [NoSQL Distilled: A Brief Guide to the Emerging World of
    Polyglot Persistence](https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620?).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解关于聚合设计在领域驱动设计之外的更多历史，请查看[《NoSQL精粹：多语言持久性新兴世界的简要指南》](https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620?).
- en: Anatomy of an Aggregate
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合的解剖
- en: An Aggregate is an Entity that may hold other Entities and Value Objects. The
    parent Entity is known as the root Entity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一个可能包含其他实体和值对象的实体。父实体被称为根实体。
- en: A single Entity without any child Entities or Value Objects is also an Aggregate
    by itself. That's why in some books, the term Aggregates is used instead of the
    term Entity. When we use them here, Entity and Aggregate mean the same thing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有子实体或值对象的单一实体本身也是一个聚合。这就是为什么在某些书中，使用聚合这个词而不是实体这个词。当我们在这里使用它们时，实体和聚合意味着同一件事。
- en: The main goal of an Aggregate is to keep your Domain Model consistent. Aggregates
    centralize most of the business rules. Aggregates are persisted atomically in
    your persistence mechanism. No matter how many child Entities and Value Objects
    live inside the root Entity, all of them will be persisted atomically, as a single
    unit. Let's see an example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的主要目标是保持你的领域模型一致。聚合集中了大部分业务规则。聚合在你的持久化机制中原子性地持久化。无论根实体内部有多少子实体和值对象，它们都将作为一个单一单元原子性地持久化。让我们看看一个例子。
- en: Consider an e-commerce application, website, and so on. Users can place orders,
    which have multiple lines that define what product was bought, the price, the
    quantity, and the line total amount. An order has a total amount too, which is
    the sum of all line amounts.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个电子商务应用程序、网站等。用户可以下订单，订单包含多个行，定义了购买的产品、价格、数量和行总金额。订单也有一个总金额，它是所有行金额的总和。
- en: 'What could happen if you update a line amount but not the order amount? Data
    inconsistency. To fix this, any modification to any Entity or Value Object within
    the Aggregate is performed through the root Entity. Most PHP developers we''ve
    worked with are more comfortable building objects and then handling their relationships
    from the client code, rather than pushing the business logic inside the Entities:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更新了行金额但没有更新订单金额会发生什么？数据不一致。为了解决这个问题，对聚合内任何实体或值对象的任何修改都通过根实体执行。我们合作过的大多数PHP开发者更习惯于先构建对象，然后从客户端代码中处理它们的关系，而不是将业务逻辑推入实体中：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As seen in the previous code example, newbie or even average developers generally
    build child objects first and then relate them to the parent object using a setter.
    Consider the following approach:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码示例所示，新手甚至普通开发者通常会先构建子对象，然后使用设置器将它们与父对象相关联。考虑以下方法：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or, consider this approach:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑这种方法：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These approaches are very interesting because they follow two Software Design
    principles: Tell-Don''t-Ask and Law of Demeter.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法非常有趣，因为它们遵循两个软件设计原则：告诉而非询问（Tell-Don't-Ask）和迪米特法则（Law of Demeter）。
- en: 'According to [Martin Fowler](http://martinfowler.com/bliki/TellDontAsk.html):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [Martin Fowler](http://martinfowler.com/bliki/TellDontAsk.html)：
- en: Tell-Don't-Ask is a principle that helps people remember that object-orientation
    is about bundling data with the functions that operate on that data. It reminds
    us that rather than asking an object for data and acting on that data, we should
    instead tell an object what to do. This encourages to move behavior into an object
    to go with the data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉而非询问（Tell-Don't-Ask）是一个原则，它帮助人们记住面向对象是关于将数据与其操作数据的功能捆绑在一起。它提醒我们，而不是询问一个对象数据并对其数据进行操作，我们应该告诉一个对象要做什么。这鼓励将行为移动到对象中，以与数据一起。
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/Law_of_Demeter):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [Wikipedia](https://en.wikipedia.org/wiki/Law_of_Demeter)：
- en: 'The **Law of Demeter** (**LoD**) or principle of least knowledge is a design
    guideline for developing software, particularly object-oriented programs. In its
    general form, the LoD is a specific case of loose coupling...and can be succinctly
    summarized in each of the following ways:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪米特法则（LoD**）或最小知识原则是软件开发的设计指南，尤其是面向对象程序的开发。在其一般形式中，LoD 是松耦合的一个特例...并且可以用以下方式简洁地总结：'
- en: 'Each unit should have only limited knowledge about other units: only units
    "closely" related to the current unit.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元应该只对其他单元有有限的知识：只有与当前单元“紧密”相关的单元。
- en: Each unit should only talk to its friends; don't talk to strangers.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元应该只与其朋友交流；不要和陌生人说话。
- en: Only talk to your immediate friends.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只和你的直接朋友交流。
- en: The fundamental notion is that a given object should assume as little as possible
    about the structure or properties of anything else (including its subcomponents),
    in accordance with the principle of "information hiding".
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念是，给定的对象应该尽可能少地假设其他任何东西的结构或属性（包括其子组件），这符合“信息隐藏”的原则。
- en: Let's continue with the order example. You've already learned how to run operations
    through the root Entity. Now let's update a product quantity of a line in an order.
    This increases the quantity, the line total amount, and the order amount. Great!
    Now it's time to persist the order with the changes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以订单为例。你已经学会了如何通过根实体运行操作。现在让我们更新订单中某行的产品数量。这增加了数量、行总额和订单总额。太棒了！现在，是时候将更改后的订单持久化了。
- en: 'If you''re using MySQL, you can imagine that we''ll need two `UPDATE` statements:
    one for the orders table, and another one for the `order_lines` table. What could
    happen if these two queries aren''t performed inside a transaction?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 MySQL，你可以想象我们需要两个 `UPDATE` 语句：一个用于订单表，另一个用于 `order_lines` 表。如果这两个查询不在一个事务中执行，可能会发生什么？
- en: Let's assume that the `UPDATE` statement that updates the line order works properly.
    However, the `UPDATE` on the order total amount fails due to network connectivity
    issues. In such a scenario, you would end up with a data inconsistency in your
    Domain Model. Transactions help you keep this consistency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设更新行订单的 `UPDATE` 语句正常工作。然而，由于网络连接问题，对订单总额的 `UPDATE` 失败。在这种情况下，你会在你的领域模型中遇到数据不一致。事务可以帮助你保持这种一致性。
- en: If you're using Elasticsearch, the situation is a bit different. You can map
    the order with a JSON document that holds order lines internally, so just a single
    request is needed. However, if you decide to map the order with one JSON document
    and each of its order lines with another JSON document, you're in trouble, as
    Elasticsearch doesn't support transactions. Ouch!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Elasticsearch，情况略有不同。你可以使用一个包含内部订单行的 JSON 文档来映射订单，因此只需要一个请求。然而，如果你决定用一个
    JSON 文档来映射订单，并为每个订单行使用另一个 JSON 文档，那么你将遇到麻烦，因为 Elasticsearch 不支持事务。哎呀！
- en: An Aggregate is fetched and persisted using its own [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories*.
    If two Entities don't belong to the same Aggregate, both will have their own Repository.
    If a true business invariant exists and two Entities belong to the same Aggregate,
    you'll only have one Repository. This Repository will be the one for the root
    Entity.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是通过其自己的[第10章](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)，*存储库*来检索和持久化的。如果两个实体不属于同一个聚合，它们各自都会有自己的存储库。如果存在真实业务不变量，并且两个实体属于同一个聚合，你将只有一个存储库。这个存储库将是根实体的存储库。
- en: What are the cons of Aggregates? The problem when dealing with transactions
    is the possibility of performance issues and operation errors. We'll explore this
    in depth soon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的缺点是什么？处理事务时的问题在于可能出现性能问题和操作错误。我们将在不久的将来深入探讨这个问题。
- en: Aggregate Design Rules
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合设计规则
- en: When designing an Aggregate, there are some rules and considerations to follow
    in order to get all the benefits and minimize the negative effects. Don't worry
    too much if you don't understand everything now; as an example, we'll show you
    a small application where we'll be referencing the rules we introduce you to.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计聚合时，有一些规则和考虑事项需要遵循，以便获得所有好处并最大限度地减少负面影响。如果你现在不理解一切，请不要担心；作为一个例子，我们将向你展示一个小型应用程序，我们将在这个应用程序中引用我们向你介绍的规则。
- en: Design Aggregates Based in Business True Invariants
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于业务真实不变量设计聚合
- en: 'First of all, what''s an invariant? An invariant is a rule that must be true
    and consistent during code execution. For example, a [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is
    a **LIFO** (**Last In, First Out**) data structure that we can *push* items into
    and *pop* items out of. We can also ask how many items are inside of the stack;
    this is what''s called the size of the stack. Consider a pure PHP implementation
    without using any specific PHP array functions such as `array_pop`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是不变量？不变量是在代码执行期间必须始终为真且一致的规则。例如，[栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))是一个**后进先出**（LIFO）的数据结构，我们可以向其中*推送*项目，并从中*弹出*项目。我们还可以询问栈中有多少个项目；这就是所谓的栈的大小。考虑一个不使用任何特定PHP数组函数（如
    `array_pop`）的纯PHP实现：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Consider the previous `size` method implementation. It''s far from perfect,
    but it works. However, as it''s implemented in the code above, it''s a CPU-intensive
    and high-cost call. Luckily, there''s an option to improve this method, by introducing
    a private attribute to keep track of the number of elements in the internal array:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑之前的 `size` 方法实现。它远非完美，但它是可行的。然而，如上代码所示，它是一个CPU密集型且成本高昂的调用。幸运的是，有一个选项可以改进这个方法，通过引入一个私有属性来跟踪内部数组中的元素数量：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With these changes, the `size` method is now a fast operation, as it just returns
    the value of the `size` field. To accomplish this, we introduced a new integer
    attribute called `size`. When a new `Stack` is created, the value of `size` is
    `0`, and there's no element in the Stack. When we add a new element into the Stack
    using the `push` method, we also increase the value of the `size` field. Similarly,
    we reduce the value of `size` when we remove a value from the Stack using the
    `pop` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，`size` 方法现在是一个快速操作，因为它只是返回 `size` 字段的值。为了实现这一点，我们引入了一个新的整数属性，称为 `size`。当创建一个新的
    `Stack` 时，`size` 的值为 `0`，栈中没有元素。当我们使用 `push` 方法向栈中添加新元素时，我们也会增加 `size` 字段的值。同样，当我们使用
    `pop` 方法从栈中移除值时，我们会减少 `size` 的值。
- en: By incrementing and decreasing the value of size, we keep it consistent with
    the real number of elements that are inside the `Stack`. The size value is consistent
    right before and right after calling any public method in the `Stack` class. As
    a result, the size value is always equal to the number of elements in the `Stack`.
    That's an invariant! We could write it down as `$this->size === count($this->data)`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加和减少 `size` 的值，我们使其与 `Stack` 中实际元素的数量保持一致。在调用 `Stack` 类中的任何公共方法之前和之后，`size`
    值都是一致的。因此，`size` 值始终等于 `Stack` 中的元素数量。这是一个不变量！我们可以将其写成 `$this->size === count($this->data)`。
- en: A true business invariant is a business rule that must always be true and transactionally
    consistent within an Aggregate. By transactionally consistent, we mean that updating
    an aggregate must be an atomic operation. All the data contained inside an Aggregate
    must be persisted atomically. If we don't follow this rule, we could persist data
    representing a non-valid Aggregate.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的业务不变性是一个必须始终为真并且在聚合体中事务一致的业务规则。通过事务一致，我们指的是更新聚合体必须是一个原子操作。聚合体内部包含的所有数据都必须原子性地持久化。如果我们不遵循这个规则，我们可能会持久化表示非有效聚合体的数据。
- en: 'According to [Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)的说法：
- en: A properly designed Aggregate is one that can be modified in any way required
    by the business with its invariants completely consistent within a single transaction.
    And a properly designed Bounded Context modifies only one Aggregate instance per
    transaction in all cases. What is more, we cannot correctly reason on Aggregate
    design without applying transactional analysis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计得当的聚合体是可以按照业务需求进行修改的，其不变性在单个事务中保持完全一致。而一个设计得当的边界上下文在所有情况下每次事务只修改一个聚合体实例。更重要的是，如果不应用事务分析，我们无法正确地推理聚合体的设计。
- en: As discussed in the introduction, in an e-commerce application, the amount of
    an order must match the sum of the amounts of every line in that order. That's
    an invariant, or business rule. We have to persist the `Order` and its `OrderLines`
    into the database in the same transaction. This forces us to make `Order` and
    `OrderLine` be part of the same Aggregate, where `Order` would be the Aggregate
    Root. Because `Order` is the root, all operations related to `OrderLines` must
    go through the Order. So no more instantiating `OrderLine` objects outside of
    an `Order` and then using a setter method to add `OrderLines` to the `Order`.
    Instead, we must use Factory Methods on the `Order`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如引言中所述，在一个电子商务应用中，订单的金额必须与该订单中每行金额的总和相匹配。这是一个不变性，或业务规则。我们必须在同一个事务中将`Order`及其`OrderLines`持久化到数据库中。这迫使我们让`Order`和`OrderLine`成为同一个聚合体的一部分，其中`Order`是聚合根。因为`Order`是根，所以所有与`OrderLines`相关的操作都必须通过`Order`进行。因此，不再在`Order`之外实例化`OrderLine`对象，然后使用setter方法将`OrderLines`添加到`Order`中。相反，我们必须使用`Order`上的工厂方法。
- en: 'With this approach, we have a single entry point to perform operations on the
    Aggregate: the `Order`. It means there''s no chance of invoking a method to break
    such a rule. Each time you add or update an `OrderLine` through the `Order`, the
    `Order` amount gets recalculated internally. Making all operations go through
    the root help us keep the Aggregate consistent. In this way, it''s more difficult
    to break any invariant.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们有一个单一的入口点来对聚合体执行操作：`Order`。这意味着没有机会调用一个方法来违反这样的规则。每次你通过`Order`添加或更新一个`OrderLine`时，`Order`的金额都会在内部重新计算。让所有操作都通过根进行有助于我们保持聚合体的一致性。这样，就更加难以破坏任何不变性。
- en: Small Aggregates Vs. Big Aggregates
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小聚合体与大型聚合体
- en: For most of the websites and projects where we've worked, almost 95 percent
    of Aggregates were formed by one single root Entity and some Value Objects. No
    other Entities were required to be in the same Aggregate. So in most cases, there
    was no real true business invariant to keep consistent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们参与的大多数网站和项目中，几乎95%的聚合体都是由一个单一的根实体和一些值对象组成的。不需要其他实体存在于同一个聚合体中。因此，在大多数情况下，没有真正的业务不变性需要保持一致。
- en: Be careful with the has-a/has-many relations that don't necessarily make two
    Entities become one Aggregate, with one of those being the root. Relations, as
    we will see, can be handled by referencing Entity Identities.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理那些不一定使两个实体成为同一个聚合体（其中一个为根实体）的has-a/has-many关系时，要小心。正如我们将看到的，这些关系可以通过引用实体标识来处理。
- en: As explained in the introduction, an Aggregate is a transactional boundary.
    The smaller the boundary is, the fewer chances there are for conflicts when committing
    multiple concurrent transactions. When designing Aggregates, you should strive
    to create them small. If there's no true invariant to protect, that means all
    single Entities form an Aggregate by themselves. That's great, because it's the
    best scenario for achieving the best performance. Why? Because locking issues
    and failed transaction issues are minimized.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，聚合（Aggregate）是一个事务边界。边界越小，在提交多个并发事务时发生冲突的机会就越少。在设计聚合时，你应该努力使它们尽可能小。如果没有真正的不变量来保护，这意味着所有单个实体（Entity）本身就是一个聚合。这很好，因为这是实现最佳性能的最佳场景。为什么？因为锁定问题和事务失败问题都得到了最小化。
- en: If you decide to go for big Aggregates, keeping data consistent can be easier
    but is probably impractical. When applications with big Aggregates run in production,
    they start to experience issues when multiple users perform operations. When using
    optimistic concurrency, the main problem is transactional failures. When using
    locking, the problem is slowness and timeouts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定采用大的聚合，保持数据一致性可能更容易，但可能不太实用。当具有大聚合的应用程序在生产环境中运行时，当多个用户执行操作时，它们开始遇到问题。当使用乐观并发时，主要问题是事务失败。当使用锁定时，问题是速度慢和超时。
- en: Let's consider some radical examples. When using optimistic concurrency, imagine
    that the whole Domain is versioned, and each operation on any Entity creates a
    new version for the whole Domain. With this scenario, if two users were performing
    different operations on different Entities that couldn't be related at all, the
    second request would experience a transaction failure because of a different version.
    On the other hand, when using pessimistic concurrency, imagine a scenario where
    we lock the database on each operation. That would block all the users until the
    lock is released. This means many requests would be waiting, and at some point,
    probably timed out. Both of these examples keep data consistent, but the application
    can't be used by more than one user.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些极端的例子。当使用乐观并发（optimistic concurrency）时，想象一下整个领域（Domain）被版本化了，并且对任何实体的任何操作都会为整个领域创建一个新的版本。在这种情况下，如果有两个用户在完全不同的实体上执行不同的操作，第二个请求会因为版本不同而经历事务失败。另一方面，当使用悲观并发（pessimistic
    concurrency）时，想象一下在每个操作上锁定数据库的场景。这将阻止所有用户直到锁被释放。这意味着许多请求会等待，并且可能在某个时刻超时。这两个例子都保持了数据的一致性，但应用程序不能被多个用户使用。
- en: Last but not least, when designing big Aggregates, because they may hold collections
    of Entities, it's important to consider the performance implications of loading
    such collections in memory. Even using an ORM such as Doctrine, which can lazy
    load collections (load collections only when they are needed), if a collection
    is too big, it can't fit into memory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，当设计大聚合时，因为它们可能持有实体的集合，所以考虑在内存中加载此类集合的性能影响是很重要的。即使使用像Doctrine这样的ORM（对象关系映射），它可以延迟加载集合（仅在需要时加载集合），如果集合太大，它可能无法适应内存。
- en: Reference Other Entities by Identity
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过身份引用其他实体
- en: When two Entities don't form an Aggregate but are related, the best option to
    have Entities reference one another is by using *Identities*. Identities were
    already explained in the [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml),
    *Entities*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个实体不形成聚合但相关时，最佳选项是通过使用*身份（Identities）*使实体相互引用。身份已经在[第4章](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml)，*实体*中解释过了。
- en: Consider a `User` and their `Orders`, and assume we haven't found any true invariant.
    `User` and `Order` wouldn't be part of the same Aggregate. If you need to know
    which `User` owns a specific `Order`, you can probably ask the `Order` what its
    `UserId` is. `UserId` is a Value Object that holds the `User` Identity. We get
    the whole `User` by using its Repository, the `UserRepository`. This code generally
    lives in the Application Service.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`用户`和他们的`订单`，并假设我们还没有找到任何真正的不变量。`用户`和`订单`不会是同一个聚合的一部分。如果你需要知道哪个`用户`拥有特定的`订单`，你可能会询问`订单`它的`UserId`是什么。`UserId`是一个值对象（Value
    Object），它持有`用户`的身份。我们通过使用它的存储库，即`UserRepository`来获取整个`用户`。这段代码通常位于应用程序服务（Application
    Service）中。
- en: As a general explanation, each Aggregate has its own Repository. If you've fetched
    a specific Aggregate and you need to fetch another related Aggregate, you'll do
    it in your Application Services or Domain Services. The Application Service will
    depend on Repositories to fetch the Aggregates needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般解释，每个聚合都有自己的仓储。如果你已经获取了一个特定的聚合，并且需要获取另一个相关的聚合，你将在你的应用程序服务或领域服务中这样做。应用程序服务将依赖于仓储来获取所需的聚合。
- en: Jumping from one Aggregate to another is what's generally called traversing
    or navigating your Domain. With ORMs, it's easy to do it by mapping all the relations
    between your Entities. However, it's also really dangerous, as you can easily
    end up running countless queries in a specific feature. As a rule, you shouldn't
    do this. Don't map all the relations between your Entities because you can. Instead,
    only map the relations between Entities inside an Aggregate in your ORM if two
    Entities form an Aggregate. If this isn't the case, you'll use Repositories to
    get referenced Aggregates.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个聚合跳转到另一个聚合通常被称为遍历或导航你的领域。使用对象关系映射（ORMs），通过映射你实体之间所有的关系来做这件事很容易。然而，这也非常危险，因为你很容易在特定的功能中运行无数个查询。作为规则，你不应该这样做。不要映射你实体之间所有的关系，因为你可以。相反，如果你的ORM中两个实体构成一个聚合，只映射聚合内部实体之间的关系。如果不是这种情况，你将使用仓储来获取引用的聚合。
- en: Modify One Aggregate Per Transaction and Request
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个事务和请求修改一个聚合
- en: 'Consider the following scenario: you make a request, it gets into your controller,
    and it intends to update two different Aggregates. Each Aggregate keeps the data
    consistent within that Aggregate. However, what would happen if the request goes
    well over the first Aggregate update but suddenly stops (server restarted, reloaded,
    out of memory, and so on.) and the second Aggregate isn''t updated? Is that a
    data consistency issue? It may be. Let''s consider some solutions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：你发起一个请求，它进入你的控制器，并打算更新两个不同的聚合。每个聚合在其内部保持数据的一致性。然而，如果请求在第一个聚合更新之后顺利执行，但突然停止（服务器重启、重新加载、内存不足等），而第二个聚合没有更新，这会是一个数据一致性的问题吗？可能是的。让我们考虑一些解决方案。
- en: 'From Vaughn Vernon''s [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Vaughn Vernon的[实现领域驱动设计](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)：
- en: In a properly designed Bounded Context modifies only one Aggregate instance
    per transaction in all cases. What is more, we cannot correctly reason on Aggregate
    design without applying transactional analysis. Limiting modification to one Aggregate
    instance per transaction may sound overly strict. However, it is a rule of thumb
    and should be the goal in most cases. It addresses the very reason to use Aggregates.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个设计良好的边界上下文中，在所有情况下每个事务只修改一个聚合实例。更重要的是，没有应用事务分析，我们无法正确地推理聚合设计。将修改限制为每个事务一个聚合实例可能听起来过于严格。然而，这是一个经验法则，在大多数情况下应该是目标。它解决了使用聚合的真正原因。
- en: If, in a single request, you need to update two Aggregates, it may just be that
    those two Aggregates are a single one and they need to both be updated in the
    same transaction. If not, you can wrap the entire request in a transaction, but
    we wouldn't recommend this as the main option because of the performance issues
    and the transaction errors involved.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个单独的请求中，你需要更新两个聚合，那么这两者可能实际上是一个单一的聚合，并且它们需要在同一个事务中同时更新。如果不是这样，你可以将整个请求包裹在一个事务中，但我们不推荐这样做，因为这样做会涉及性能问题和事务错误。
- en: If both updates on different Aggregates don't need to be wrapped into a transaction,
    this means we can assume some delay between one update and the other. In such
    a scenario, a more Domain-Driven Design approach is to use Domain Events. When
    doing so, the first Aggregate update will fire a Domain Event. That event will
    be persisted in the same transaction as the Aggregate update and then published
    into our message queue. Later, a worker will take the event from the queue and
    perform the second Aggregate update. Such an approach pushes for Eventual Consistency,
    reduces the size of the transaction boundaries, improves performance, and reduces
    transaction errors.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同聚合上的更新不需要包裹在一个事务中，这意味着我们可以假设一次更新和另一次更新之间存在一些延迟。在这种情况下，一个更领域驱动的设计方法是使用领域事件。这样做时，第一个聚合更新将触发一个领域事件。该事件将与聚合更新保存在同一个事务中，然后发布到我们的消息队列。稍后，一个工作进程将从队列中取出事件并执行第二个聚合的更新。这种方法推动最终一致性，减少了事务边界的规模，提高了性能，并减少了事务错误。
- en: 'Sample Application Service: User and Wishes'
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用服务：用户和愿望
- en: Now you know the basic rules for Aggregate Design.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了聚合设计的基本规则。
- en: 'The best way to learn about Aggregates is by seeing code. So let''s consider
    the scenario of a web application where users can make wishes to be granted if
    something happens to them, similar to a will. For example, I would like to send
    an email to my wife explaining what to do with my GitHub account if I die in a
    horrible accident, or maybe I want to send an email telling her how much I loved
    her. The way to check that I''m still alive is to answer emails the platform sends
    to me. (If you want to know more about [this application](https://github.com/dddinphp/last-wishes),
    you can visit our [GitHub](https://github.com/dddinphp) account. So we have users
    and their wishes. Let''s consider only one use case: "As a `User`, I want to make
    a Wish." How could we model this? Using good practices when designing Aggregates,
    let''s try to push for small Aggregates. In this case, that means using two different
    Aggregates of one Entity each, `User` and `Wish`. For the relationship between
    them, we should use an identifier, such as `UserId`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 了解聚合的最佳方式是通过查看代码。所以让我们考虑一个网络应用程序的场景，用户可以提出愿望，如果发生某些事情，这些愿望将被实现，类似于遗嘱。例如，我想要给我妻子发一封邮件，解释如果我发生可怕的事故，应该如何处理我的GitHub账户，或者我可能想要发一封邮件告诉她我有多么爱她。检查我是否仍然活着的方法是回答平台发送给我的邮件。（如果你想了解更多关于[这个应用程序](https://github.com/dddinphp/last-wishes)的信息，你可以访问我们的[GitHub](https://github.com/dddinphp)账户。因此，我们有用户和他们的愿望。让我们考虑一个用例：“作为一个`User`，我想提出一个愿望。”我们该如何建模呢？在设计和聚合时使用良好的实践，让我们尝试推动小型聚合。在这种情况下，这意味着使用两个不同的聚合，每个聚合包含一个实体，`User`和`Wish`。对于它们之间的关系，我们应该使用一个标识符，例如`UserId`。
- en: No Invariant, Two Aggregates
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无不变性，两个聚合
- en: 'We''ll discuss Application Services in the following chapters, but for now,
    let''s check different approaches for making a Wish. The first approach, particularly
    for a novice, would likely be something similar to this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论应用服务，但就目前而言，让我们检查实现愿望的不同方法。对于初学者来说，第一个方法可能类似于以下内容：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code probably allows for the best performance possible. You can almost
    see the `INSERT` statement behind the scenes; the minimum number of operations
    for such a use case is one, which is good. With the current implementation, we
    can create as many wishes as we want, according to the business requirements,
    which is also good.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能允许实现最佳性能。你几乎可以看到幕后发生的`INSERT`语句；对于此类用例，所需的最小操作数是一个，这是好的。根据业务需求，我们可以创建尽可能多的愿望，这也是好的。
- en: 'However, there may be a potential issue: we can create wishes for a user who
    may not exist in the Domain. This is a problem, regardless of what technology
    we''re using for persisting Aggregates. Even if we''re using an in-memory implementation,
    we can create a Wish without its corresponding User.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在一个潜在问题：我们可以为可能不在域中存在的用户创建愿望。无论我们使用什么技术来持久化聚合，这都是一个问题。即使我们使用内存实现，我们也可以创建一个没有对应用户的愿望。
- en: This is broken business logic. Of course, this can be fixed using a foreign
    key in the database, from `wish (user_id)` to `user`(`id`), but what happens if
    we're not using a database with foreign keys? And what happens if it's a NoSQL
    database, such as Redis or Elasticsearch?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的企业逻辑。当然，这可以通过在数据库中使用外键来修复，从`wish (user_id)`到`user(id)`，但如果我们不使用带有外键的数据库呢？如果它是一个如Redis或Elasticsearch这样的NoSQL数据库呢？
- en: 'If we want to fix this issue so that the same code can work properly in different
    infrastructures, we need to check if the user exists. It''s likely that the easiest
    approach is in the same Application Service:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要修复这个问题，使得相同的代码可以在不同的基础设施中正常工作，我们需要检查用户是否存在。最简单的方法可能是在同一个应用服务中：
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That could work, but there''s a problem performing the check in the Application
    Service: this check is high in the delegation chain. If any other code snippet
    that isn''t this Application Service — such as a Domain Service or another Entity
    — wants to create a `Wish` for a non-existing User, it can do it. Take a look
    at the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能可行，但在应用服务中进行检查时存在一个问题：这个检查在委托链中位置较高。如果任何其他代码片段（如域服务或另一个实体）想要为不存在的用户创建一个`Wish`，它可以做到。看看下面的代码：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you've already read [Chapter 9](a4032fdc-34d9-48ab-bbee-ba3bd1225600.xhtml),
    *Factories*, then you have the solution. Factories help us keep the business invariants,
    and that's exactly what we need here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了第9章[工厂](a4032fdc-34d9-48ab-bbee-ba3bd1225600.xhtml)，那么你已经有了解决方案。工厂帮助我们保持业务不变量，这正是我们在这里需要的。
- en: 'There''s an implicit invariant saying that we''re not allowed to make a wish
    without a valid user. Let''s see how a factory can help us:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个隐含的不变量表示，我们不允许在没有有效用户的情况下做出愿望。让我们看看工厂如何帮助我们：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, `Users` make `Wishes`, and so does our code. `makeWish` is
    a Factory Method for building Wishes. The method returns a new `Wish` built with
    the `UserId` from the owner:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Users`创建`Wishes`，我们的代码也是如此。`makeWish`是一个工厂方法，用于构建愿望。该方法返回一个使用所有者的`UserId`构建的新`Wish`：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why are we returning a `Wish` and not just adding the new `Wish` to an internal
    collection as we would do with Doctrine? To summarize, in this scenario, `User`
    and `Wish` don't conform to an Aggregate because there's no true business invariant
    to protect. A `User` can add and remove as many `Wishes` as they want. `Wishes`
    and their `User` can be updated independently in the database in different transactions,
    if needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们返回一个`Wish`而不是像使用Doctrine那样仅仅将新的`Wish`添加到内部集合中呢？总结来说，在这种情况下，`User`和`Wish`并不符合聚合体的定义，因为没有真正的业务不变量需要保护。`User`可以添加和删除他们想要的任意数量的`Wishes`。如果需要，`Wishes`及其`User`可以在不同的事务中独立地在数据库中更新。
- en: 'Following the rules about Aggregate Design explained before, we should aim
    for small Aggregates, and that''s the result here. Each Entity has its own Repository.
    Wish references its owning `User` using Identities — `UserId` in this case. Getting
    all the wishes of a user can be performed by a finder in the `WishRepository`
    and paginated easily without any performance issues:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循之前解释的聚合设计规则，我们应该追求小的聚合体，这就是结果。每个实体都有自己的仓库。愿望使用身份引用其拥有的`User`——在这种情况下是`UserId`。可以通过`WishRepository`中的查找器执行获取用户的全部愿望，并且可以轻松分页而不会出现任何性能问题：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An interesting aspect of this approach is that we don''t have to map the relation
    between `User` and `Wish` in our favorite ORM. Because we reference the `User`
    from the `Wish` using the `UserId`, we just need the Repositories. Let''s consider
    how the mapping of such Entities using Doctrine might appear:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个有趣方面是，我们不需要在我们的首选ORM中映射`User`和`Wish`之间的关系。因为我们使用`UserId`从`Wish`引用`User`，所以我们只需要仓库。让我们考虑一下使用Doctrine映射此类实体可能看起来如何：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'No relation is defined. After making a new wish, let''s write some code for
    updating an existing one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义任何关系。在创建一个新的愿望之后，让我们编写一些代码来更新现有的一个：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because `User` and `Wish` don''t form an Aggregate, in order to update the
    `Wish`, we need first to retrieve it using the `WishRepository`. Some extra checks
    ensure that only the owner can update the wish. As you may have seen, `$wish`
    is already an existing Entity in our Domain, so there''s no need to add it back
    again using the Repository. However, in order to make changes durable, our ORM
    must be aware of the information updated and flush any remaining changes to the
    database after the work is done. Don''t worry; we''ll take a look closer at this
    in [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*. In
    order to complete the example, let''s take a look at how to remove a wish:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`User`和`Wish`不构成一个聚合体，为了更新`Wish`，我们首先需要使用`WishRepository`检索它。一些额外的检查确保只有所有者才能更新愿望。正如你可能已经看到的，`$wish`已经是我们的领域中的一个现有实体，因此没有必要再次使用仓库添加它。然而，为了使更改持久化，我们的ORM必须知道更新的信息，并在工作完成后将任何剩余的更改刷新到数据库中。不用担心；我们将在第11章[应用](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)中更详细地探讨这一点。为了完成这个例子，让我们看看如何删除一个愿望：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you may have seen, you could refactor some parts of the code, such as the
    constructor and the ownership checks, to reuse them in both Application Services.
    Feel free to consider how you would do that. Last but not least, how could we
    get all the wishes of a specific user:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能看到的，你可以重构一些代码部分，比如构造函数和所有权检查，以便在应用程序服务中重用。请随意考虑你将如何做。最后但同样重要的是，我们如何能够获取特定用户的全部愿望：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is quite straightforward. However, we'll go deeper into how to render and
    return information from Application Services in the corresponding chapter. For
    now, returning a collection of Wishes will do the job.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。然而，我们将在相应的章节中更深入地探讨如何在应用程序服务中渲染和返回信息。现在，返回一个愿望集合就能完成这项工作。
- en: Let's sum up this non-Aggregate approach. We couldn't find any true business
    invariant to consider `User` and `Wish` as an Aggregate, which is why each of
    them is an Aggregate. `User` has its own `Repository`, `UserRepository`. `Wish`
    has its own Repository too, `WishRepository`. Each `Wish` holds a `UserId` reference
    to owner, `User`. Even so, we didn't require a transaction. That's the best scenario
    in terms of performance and scalability issues. However, life is not always so
    wonderful. Consider what could happen with a true business invariant.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下这种非聚合方法。我们找不到任何真正的业务不变量来将`User`和`Wish`视为一个聚合体，这就是为什么它们各自都是一个聚合体。`User`有自己的存储库，即`UserRepository`。`Wish`也有自己的存储库，即`WishRepository`。每个`Wish`都持有指向所有者`User`的`UserId`引用。即便如此，我们也没有要求进行事务处理。这是在性能和可扩展性方面最好的情况。然而，生活并不总是如此美好。考虑一下在真正的业务不变量下可能会发生什么。
- en: No More Than Three Wishes Per User
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个用户不超过三个愿望
- en: Our application is a huge success and now it's time to get some money from it.
    We want new users to have a maximum of three wishes available. As a user, if you
    want to have more wishes, you'll probably have to pay for a premium account in
    the future. Let's see how we could change our code to follow the new business
    rule about the maximum number of wishes (in this instance, don't consider the
    premium user).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序取得了巨大的成功，现在是时候从中获取一些收益了。我们希望新用户最多只能有三个愿望。作为一个用户，如果你想拥有更多的愿望，你将来可能需要支付一个高级账户的费用。让我们看看我们如何修改代码以遵循关于最大愿望数量的新业务规则（在这个例子中，不考虑高级用户）。
- en: 'Consider the following code for a moment. Apart from what was explained in
    the previous section about pushing logic into our Entities, could the following
    code work:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片刻。除了上一节中解释的将逻辑推入我们的实体之外，以下代码能工作吗？
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It looks like it could. That was easy — probably too easy. And here we come
    across different problems. The first is that Application Services must coordinate
    but shouldn't contain business logic. Instead, a better place is to put the check
    for the maximum three wishes into the `User`, where we could have more control
    of the relationship between `User` and `Wish`. However, for the approach shown
    here, the code seems to work.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来可以。这很简单——可能太简单了。而且我们遇到了不同的问题。第一个问题是应用程序服务必须协调，但不应该包含业务逻辑。相反，更好的地方是将检查最大三个愿望的逻辑放入`User`中，这样我们就可以更好地控制`User`和`Wish`之间的关系。然而，对于这里展示的方法，代码似乎可以工作。
- en: The second problem is that it **doesn't work under race conditions**. Forget
    about Domain-Driven Design for a moment. What's the problem with this code under
    heavy traffic? Think for a minute. Is it possible to break the rule of a `User`
    to have more than three wishes? Why will your QA be so happy after running some
    stress tests?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是它**在竞争条件下无法工作**。暂时忘记领域驱动设计。在重负载下，这段代码有什么问题？思考一下。是否有可能打破一个`User`拥有超过三个愿望的规则？为什么在运行一些压力测试后，你的质量保证（QA）人员会如此高兴？
- en: Your QA tries making a wish feature two times and ends up with a user with two
    wishes. That's correct. Your QA carries on testing the feature. Imagine for a
    second that they open two tabs in their browser, fill out each of the forms in
    each tab, and manage to submit the two buttons at the same time. Suddenly, after
    two requests, the user ends up with four wishes in the database. That's wrong!
    What happened?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你的质量保证（QA）人员尝试两次制作愿望功能，结果是一个用户有两个愿望。这是正确的。你的质量保证（QA）人员继续测试这个功能。想象一下，他们同时在浏览器中打开两个标签页，在每个标签页中填写每个表单，并设法同时提交两个按钮。突然，在两个请求之后，用户在数据库中有四个愿望。这是错误的！发生了什么？
- en: Think as a debugger and consider two different requests getting the `if ($count
    > 3) {` line at the same time. Both of the requests will return false because
    the user has just two wishes. So both requests will create the `Wish` and both
    of the requests will add it into the database. The result is four wishes for one
    `User`. That's an inconsistency!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以调试器的角度思考，考虑两个不同的请求同时获取到`if ($count > 3) {`这一行。这两个请求都会返回false，因为用户只有两个愿望。所以这两个请求都会创建一个`Wish`，并且两个请求都会将其添加到数据库中。结果是，一个`User`有四个愿望。这是不一致的！
- en: 'We know what you''re thinking. It''s because we missed putting everything into
    a transaction. Well, imagine that a user with id 1 already has two wishes, so
    there''s one remaining. Two HTTP requests to create two different wishes arrive
    at the same time. We start one database transaction per request (we''ll review
    how to deal with transactions and requests in [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml),
    *Application*). Consider all the queries that the previous PHP code is going to
    run against our database. Remember that you need to disable any auto-commit flag
    if you''re using any Visual Database Tool:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道你在想什么。那是因为我们遗漏了将所有内容放入事务中。想象一下，用户ID为1的用户已经有两个愿望，所以还剩下一个。两个创建不同愿望的HTTP请求同时到达。我们对每个请求启动一个数据库事务（我们将在[第11章](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)，*应用*）中回顾如何处理事务和请求）。考虑之前PHP代码将要运行的所有查询。记住，如果你使用任何可视数据库工具，你需要禁用任何自动提交标志：
- en: '![](img/Code1P.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/Code1P.png)'
- en: '![](img/code2P-1.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code2P-1.png)'
- en: How many wishes does the user with id `1` have? That's right, four. How did
    this happen? If you take this SQL block and execute it line by line in two different
    connections, you'll see how the wishes table is going to have four rows at the
    end of both executions. So it looks like it's not about protecting with a transaction.
    How could we fix this issue? As explained in the introduction, a concurrency control
    could help.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用户ID为`1`有多少个愿望？没错，四个。这是怎么发生的？如果你将这个SQL块在不同的连接中逐行执行，你会看到愿望表在两次执行结束时都将有四行。所以看起来这并不是关于用事务保护的问题。我们如何解决这个问题？如介绍中所述，并发控制可以帮助解决这个问题。
- en: For those developers more advanced in database techniques, tweaking the isolation
    level could work. However, we consider that option too complex, as the problem
    could be solved with other approaches, and we're not always dealing with databases.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在数据库技术方面更为高级的开发者，调整隔离级别可能有效。然而，我们认为这个选项过于复杂，因为问题可以用其他方法解决，而且我们并不总是处理数据库。
- en: Pessimistic Concurrency Control
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悲观并发控制
- en: 'There''s an important consideration when placing locks: any other connection
    trying to update or query the same data is going to hang until the lock is released.
    Locks can easily generate most of the performance problems. In MySQL, for example,
    there are different options for placing locks: explicit locking tables `UN/LOCK
    tables`, and locking reads `SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE
    MODE`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置锁时有一个重要的考虑因素：任何尝试更新或查询相同数据的其他连接都将挂起，直到锁被释放。锁很容易产生大部分的性能问题。例如，在MySQL中，放置锁有不同的选项：显式锁定表
    `UN/LOCK tables`，以及锁定读取 `SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE`。
- en: 'As we already shared above in the beginning, according to the book *Elasticsearch:*
    [The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc) by
    Clinton Gormley and Zachary Tong:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在一开始就分享的那样，根据克林顿·戈姆利和扎卡里·汤的书籍 *Elasticsearch:* [《 definitive guide》](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc)：
- en: Widely used by relational databases, this approach assumes that conflicting
    changes are likely to happen and so blocks access to a resource in order to prevent
    conflicts. A typical example is locking a row before reading its data, ensuring
    that only the thread that placed the lock is able to make changes to the data
    in that row.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛应用于关系型数据库，这种方法假设冲突性更改很可能会发生，因此会阻止对资源的访问以防止冲突。一个典型的例子是在读取数据之前锁定一行，确保只有放置锁的线程能够更改该行中的数据。
- en: We could [`LOCK`](http://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) the
    table, but we consider such an approach complex and risky. When using locks, you
    have to be careful because you can end up with situations where two threads or
    requests are waiting for the other one to release the lock. This is what's called
    a deadlock.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以 `LOCK` 表，但我们认为这种方法复杂且风险较大。在使用锁时，你必须小心，因为你可能会陷入两个线程或请求都在等待对方释放锁的情况。这就是所谓的死锁。
- en: 'Based on our experience, some developers use `SELECT ... FOR UPDATE` approaches.
    Let''s see the same two request scenarios with this option:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，一些开发者使用 `SELECT ... FOR UPDATE` 方法。让我们看看使用这个选项的相同两个请求场景：
- en: '![](img/Code3P-1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/Code3P-1.png)'
- en: 'As you can see, after the `COMMIT` of the first request, the count of the number
    of wishes of the second request is three. That''s consistent, but the second request
    was waiting while the lock wasn''t released. That means that in an environment
    with a lot of requests, it may generate performance issues. If the first request
    takes too much time to release the lock, the second request may fail due to a
    timeout:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在第一个请求的`COMMIT`之后，第二个请求的愿望数量为三。这是一致的，但第二个请求在锁未释放时等待。这意味着在一个有很多请求的环境中，它可能会产生性能问题。如果第一个请求花费太多时间释放锁，第二个请求可能会因为超时而失败：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The above looks like it's a valid option, but we need to be aware of the possible
    performance issues. Is there any other alternative?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上述看起来像是一个有效的选项，但我们需要意识到可能存在的性能问题。有没有其他替代方案？
- en: Optimistic Concurrency Control
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乐观并发控制
- en: 'There''s another alternative: not using locks at all. Consider adding a version
    attribute to our Aggregates. When we persist them, the persistence engine sets
    1 as the version of the persisted Aggregate. Later, we retrieve the same Aggregate
    and perform some changes to it. We persist the Aggregate. The persistence engine
    checks that the version we have is the same as the one that''s currently persisted,
    version 1\. The persistence engine persists the Aggregate with the new state and
    updates its version to 2\. If multiple requests retrieve the same Aggregate, make
    some changes to it, and then try to persist it, the first request will work, and
    the second will experiment and error. The last request just changed an outdated
    version, so the persistence engine throws an error. However, the second request
    can try to retrieve the Aggregate again, merge the new status, attempt to perform
    the changes, and then persist the Aggregate.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案：完全不使用锁。考虑给我们的聚合添加一个版本属性。当我们持久化它们时，持久化引擎将1设置为持久化聚合的版本。稍后，我们检索相同的聚合并对其进行一些更改。我们持久化聚合。持久化引擎检查我们拥有的版本是否与当前持久化的版本相同，即版本1。持久化引擎以新状态持久化聚合并更新其版本为2。如果有多个请求检索相同的聚合，对其进行一些更改，然后尝试持久化，第一个请求将成功，第二个请求将尝试并出错。最后一个请求只是更改了一个过时的版本，因此持久化引擎抛出错误。然而，第二个请求可以再次尝试检索聚合，合并新状态，尝试执行更改，然后持久化聚合。
- en: 'According to [Elasticsearch: The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '根据[Elasticsearch: The Definitive Guide](https://github.com/elastic/elasticsearch-definitive-guide/blob/master/030_Data/40_Version_control.asciidoc)：'
- en: This approach assumes that conflicts are unlikely to happen and does not block
    operations from being attempted. However, if the underlying data has been modified
    between reading and writing, the update will fail. It is then up to the application
    to decide how it should resolve the conflict. For instance, it could reattempt
    the update, using the fresh data, or it could report the situation to the user.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法假设冲突不太可能发生，并且不会阻止尝试操作。然而，如果在读取和写入之间底层数据已被修改，更新将失败。然后应用程序必须决定如何解决冲突。例如，它可以重新尝试更新，使用新鲜的数据，或者它可以向用户报告这种情况。
- en: This idea was covered before, but it bears repeating. If you try to apply Optimistic
    Concurrency to this scenario where we're checking maximum wishes in the Application
    Service, it's not going to work. Why? We're making a new wish, so two requests
    would create two different wishes. How can we make it work? Well, we need an object
    to centralize adding the wishes. We could apply the Optimistic Concurrency trick
    on that object, so it looks like we need a parent object that will hold wishes.
    Any ideas?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法之前已经讨论过，但值得再次强调。如果你尝试将乐观并发应用于我们检查应用程序服务中最大愿望的场景，它将不会工作。为什么？我们正在创建一个新的愿望，所以两个请求将创建两个不同的愿望。我们如何让它工作？嗯，我们需要一个对象来集中添加愿望。我们可以在该对象上应用乐观并发技巧，所以看起来我们需要一个将持有愿望的父对象。有什么想法吗？
- en: 'To summarize, after reviewing concurrency controls, there''s a pessimistic
    option working, but there are some concerns about performance impact. There''s
    an optimistic option, but we need to find a parent object. Let''s consider the
    final `MakeWishService`, but with some modifications:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在审查并发控制后，有一个悲观选项正在工作，但关于性能影响有一些担忧。有一个乐观选项，但我们需要找到一个父对象。让我们考虑最终的`MakeWishService`，但进行一些修改：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We don''t pass the `WishId` because it should be something internal to the
    User. `makeWish` doesn''t return a `Wish` either; it stores the new wish internally.
    After the execution of the Application Service, our ORM will flush the changes
    performed on the `$user` to the database. Depending on how good our ORM is, we
    may need to explicitly add our `User` Entity again using the Repository. What
    changes to the `User` class are needed? First of all, there should be a collection
    that could hold all the wishes inside a user:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有传递 `WishId`，因为它应该是用户内部的东西。`makeWish` 也不返回一个 `Wish`；它将新的愿望内部存储。在应用程序服务的执行之后，我们的
    ORM 将将 `$user` 上执行的所有更改刷新到数据库。根据我们的 ORM 多么好，我们可能需要再次使用存储库显式地添加我们的 `User` 实体。`User`
    类需要哪些更改？首先，应该有一个可以容纳用户内部所有愿望的集合：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `wishes` property must be initialized in the `User` constructor. We could
    use a plain PHP array, but we''ve chosen to use an `ArrayCollection`. `ArrayCollection`
    is a PHP array with some extra features provided by the Doctrine Common Library,
    and it can be used separate from the ORM. We know that some of you may think that
    this could be a boundary leaking and that no references to any infrastructure
    should be here, but we really believe that''s not the case. In fact, the same
    code works using plain PHP arrays. Let''s see how the `makeWish` implementation
    is affected:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`wishes` 属性必须在 `User` 构造函数中初始化。我们可以使用一个普通的 PHP 数组，但我们选择了使用 `ArrayCollection`。`ArrayCollection`
    是一个带有 Doctrine Common Library 提供的一些额外功能的 PHP 数组，并且可以独立于 ORM 使用。我们知道有些人可能认为这可能是边界泄漏，并且不应该有任何对基础设施的引用在这里，但我们真的相信这不是问题。事实上，相同的代码使用普通的
    PHP 数组也能工作。让我们看看 `makeWish` 实现是如何受到影响的：'
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So far, so good. Now, it's time to review how the rest of the operations are
    implemented.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，是时候回顾其他操作是如何实现的。
- en: '**Pushing for Eventual Consistency**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**推动最终一致性**'
- en: 'It looks like the business doesn''t want a user to have more than three wishes.
    That''s going to force us to consider `User` as the root Aggregate with `Wish`
    inside. This will affect our design, performance, scalability issues, and so on.
    Consider what would happen if we could just let users add as many wishes as they
    wanted, beyond the limit. We could check who is exceeding that limit and let them
    know they need to purchase a premium account. Allowing a user to go over the limit
    and warning them by telephone afterward would be a really nice commercial strategy.
    That might even allow the developers on your team to avoid designing `User` and
    `Wish` as part of the same Aggregate, with User as its root. You''ve already seen
    the benefits of not designing a single Aggregate: maximum performance.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来业务逻辑不希望用户拥有超过三个愿望。这将迫使我们考虑将 `User` 作为包含 `Wish` 的根聚合。这将影响我们的设计、性能、可扩展性问题等等。考虑一下如果我们允许用户添加超过限制的愿望会发生什么。我们可以检查谁超出了这个限制，并通知他们需要购买高级账户。允许用户超过限制并在之后通过电话警告他们，将是一个非常好的商业策略。这甚至可能让你们团队的开发者避免将
    `User` 和 `Wish` 设计为同一个聚合的一部分，以 `User` 作为其根。你已经看到了不设计单个聚合的好处：最大性能。
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because `User` and `Wish` now form an Aggregate, the `Wish` to be updated is
    no longer retrieved using the `WishRepository`. We fetch the user using the `UserRepository`.
    The operation of updating a `Wish` is performed via the root Entity, which is
    the `User` in this case. The `WishId` is necessary in order to identify which
    `Wish` we want to update:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `User` 和 `Wish` 现在形成了一个聚合，所以需要更新的 `Wish` 已不再通过 `WishRepository` 获取。我们使用 `UserRepository`
    来获取用户。更新 `Wish` 的操作是通过根实体来执行的，在这个例子中是 `User`。为了识别我们想要更新的哪个 `Wish`，`WishId` 是必要的：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Depending on the features of your framework, this task may or may not be cheaper
    to perform. Iterating through all the wishes could mean making too many queries,
    or even worse, fetching too many rows, which will create a huge impact on memory.
    In fact, that''s one of the main problems of having big Aggregates. So let''s
    consider how to remove a Wish:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你框架的特性，这个任务可能更便宜或更贵。遍历所有愿望可能意味着执行太多的查询，或者更糟糕的是，获取太多的行，这将对内存产生巨大影响。实际上，这是拥有大型聚合的主要问题之一。所以，让我们考虑如何删除一个愿望：
- en: '[PRE35]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As seen before, `WishRepository` is no longer necessary. We fetch the `User`
    using its Repository and perform the action of removing a `Wish`. In order to
    remove a `Wish`, we need to remove it from the inner collection. An option would
    be iterating through all the elements and matching the one with the same `WishId`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`WishRepository`不再必要。我们使用其Repository获取`User`并执行移除`Wish`的操作。为了移除一个`Wish`，我们需要从内部集合中移除它。一个选择是遍历所有元素并匹配具有相同`WishId`的一个：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That''s probably the most ORM-agnostic code possible. However, behind the scenes,
    Doctrine is fetching all the wishes and iterating through all of them. A more
    specific approach to fetch only the Entity needed that isn''t so ORM agnostic
    would be the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是可能的最不依赖于ORM的代码。然而，在幕后，Doctrine正在检索所有愿望并遍历它们。要获取所需实体而不那么不依赖于ORM的更具体的方法如下：
- en: 'Doctrine mapping must also be updated in order to make all the magic work as
    expected. While the Wish mapping remains the same, the `User` mapping has the
    new `oneToMany` unidirectional relationship:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有魔法按预期工作，必须更新Doctrine映射。虽然愿望映射保持不变，但`User`映射有了新的单向`oneToMany`关系：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the code above, there are two important configurations: `orphanRemoval`
    and cascade. According to the Doctrine 2 ORM Documentation on [orphan removal](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html#orphan-removal) and
    [transitive persistence / cascade operations](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html#transitive-persistence-cascade-operations):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有两个重要的配置：`orphanRemoval`和级联。根据Doctrine 2 ORM文档中的[孤儿移除](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html#orphan-removal)和[传递性持久化/级联操作](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html#transitive-persistence-cascade-operations)：
- en: If an Entity of type A contains references to privately owned Entities B then
    if the reference from A to B is removed the entity B should also be removed, because
    it is not used anymore. `OrphanRemoval` works with one-to-one, one-to-many and
    many-to-many associations. When using the `orphanRemoval=true` option Doctrine
    makes the assumption that the entities are privately owned and will `NOT` be reused
    by other entities. If you neglect this assumption your entities will get deleted
    by Doctrine even if you assigned the orphaned entity to another one.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型A的实体包含对私有实体B的引用，那么如果从A到B的引用被移除，实体B也应该被移除，因为它不再被使用。`OrphanRemoval`与一对一、一对多和多对多关联一起工作。当使用`orphanRemoval=true`选项时，Doctrine假设实体是私有拥有的，并且`不会`被其他实体重用。如果你忽略了这一假设，你的实体可能会被Doctrine删除，即使你将孤儿实体分配给了另一个实体。
- en: Persisting, removing, detaching, refreshing and merging individual entities
    can become pretty cumbersome, especially when a highly interweaved object graph
    is involved. Therefore Doctrine 2 provides a mechanism for transitive persistence
    through cascading of these operations. Each association to another entity or a
    collection of entities can be configured to automatically cascade certain operations.
    By default, no operations are cascaded.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化、删除、分离、刷新和合并单个实体可能会变得相当繁琐，尤其是在涉及高度交织的对象图时。因此，Doctrine 2提供了一种通过级联这些操作来实现传递性持久化的机制。每个关联到另一个实体或实体集合的关联都可以配置为自动级联某些操作。默认情况下，没有操作被级联。
- en: For more information, please take a closer look at the Doctrine 2 ORM 2 Documentation
    on [working with associations](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请仔细阅读Doctrine 2 ORM 2文档中的[关联操作](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/working-with-associations.html)。
- en: 'Finally, let''s see how we can get the wishes from a user:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何从用户那里获取愿望：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As mentioned before, especially in this scenario using Aggregates, returning
    a collection of Wishes is not the best solution. You should never return Domain
    Entities, as this will prevent code outside of your Application Services — such
    as Controllers or your UI — from unexpectedly modifying them. With Aggregates,
    it makes even more sense. Entities that aren't root — the ones that belong to
    the Aggregate but aren't root  — should appear private to others outside.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，特别是在使用聚合的这种场景中，返回一个愿望集合（Wishes）并不是最佳解决方案。你永远不应该返回领域实体，因为这会阻止应用程序服务之外（如控制器或你的UI）意外地修改它们。使用聚合，这一点更加明显。非根实体——即属于聚合但不是根的实体——应该对其他外部人员保持私有。
- en: 'We''ll go deeper into this in the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml),
    *Application*. For now, to summarize, you have different options:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章[应用](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)中更深入地探讨这一点。现在，为了总结，你有不同的选择：
- en: The Application Service returns a DTO build accessing Aggregates information.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务返回通过访问聚合信息构建的DTO。
- en: The Application Service returns a DTO returned by the Aggregate.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务返回由聚合返回的DTO。
- en: The Application Service uses an Output dependency where it writes the Aggregate.
    Such an Output dependency will handle the transformation to a DTO or other format.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务使用一个输出依赖项来写入聚合。这种输出依赖项将处理转换为DTO或其他格式的转换。
- en: Render the Number of Wishes  As an exercise, consider that we want to render
    the number of wishes a user has made on their account page. How would you implement
    this, considering User and Wish don't form an Aggregate? How would you implement
    it if User and Wish did form an Aggregate? Consider how Eventual Consistency could
    help in your solutions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将愿望数量渲染为练习，考虑我们想要在用户账户页面上渲染用户所提出的愿望数量。你会如何实现这个功能，考虑到用户和愿望不形成一个聚合？如果用户和愿望形成一个聚合，你会如何实现它？考虑最终一致性如何帮助你解决问题。
- en: Transactions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: We haven't shown `beginTransaction`, `commit`, or `rollback` in any of the examples.
    This is because transactions are handled at Application Service level. Don't worry
    for now; you'll find more details about this in [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中没有展示`beginTransaction`、`commit`或`rollback`。这是因为事务是在应用程序服务级别处理的。现在不用担心；你将在第11章[应用](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)中找到更多关于这个问题的细节。
- en: Wrap Up
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Aggregates are all about persistence and transactions. In fact, you can''t
    design Aggregates without thinking about how they''re going to be persisted. The
    basic rules to design proper Aggregates are: make them small, find true business
    invariants, push for eventual consistency using Domain Events, reference other
    Aggregates by Identity, and modify one Aggregate per request. Review how the code
    changes if two Entities form a single Aggregate or not. Use factories to enrich
    your Entities. Finally, relax. In most of the PHP applications we''ve seen, only
    five percent of the Entities were Aggregates formed by two Entities or more. Discuss
    with your workmates when designing and implementing Aggregates.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合（Aggregates）的核心是持久性和事务。实际上，在设计聚合时，你必须考虑它们如何被持久化。设计合适的聚合的基本规则是：使它们保持小巧，找到真正的业务不变量，通过领域事件推动最终一致性，通过标识符引用其他聚合，并且每个请求只修改一个聚合。回顾一下，如果两个实体形成一个单一的聚合，代码会有怎样的变化。使用工厂来丰富你的实体。最后，放松一下。在我们所见到的大多数PHP应用程序中，只有大约五分的实体是由两个或更多实体组成的聚合。在设计实现聚合时，与你的同事讨论。
