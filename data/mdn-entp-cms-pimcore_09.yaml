- en: '*Chapter 9*: Configuring Entities and Rendering Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：配置实体和渲染数据'
- en: In the previous chapter, we learned how the **model-view-controller** (**MVC**)
    development pattern works and then learned what views and model controllers are.
    We have also seen how the Pimcore routing system works and how to create relationships
    between elements. Finally, we saw how to modify the content of our entities, adding
    images, text, and date fields.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了**模型-视图-控制器**（**MVC**）开发模式的工作原理，然后学习了视图和模型控制器是什么。我们还看到了Pimcore路由系统的工作原理以及如何创建元素之间的关系。最后，我们看到了如何修改我们实体的内容，添加图片、文本和日期字段。
- en: 'In this chapter, we''re going to create a blog, and we will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个博客，我们将涵盖以下主题：
- en: Defining blog classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义博客类
- en: Creating blog Users and Roles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建博客用户和角色
- en: Routing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Editing the Controller for our blog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑我们博客的控制器
- en: Rendering blog views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染博客视图
- en: Differences between Pimcore and WordPress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pimcore与WordPress之间的区别
- en: By the end of this chapter, we will have built our first blog with Pimcore,
    with articles grouped by categories and authors. We will have also learned how
    to create suitable templates for each page, inserting the necessary code to display
    the content created.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将使用Pimcore构建我们的第一个博客，文章按类别和作者分组。我们还将学习如何为每个页面创建合适的模板，并插入必要的代码以显示创建的内容。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, there is a demonstration that you can find on
    our GitHub repository, which you can access here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，有一个可以在我们的GitHub仓库中找到的演示，你可以在这里访问：
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/)'
- en: All you need to do to run the demo connected with this chapter is to navigate
    to the `Full Demo` folder and start the Docker environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行与本章相关的演示，你只需要导航到`Full Demo`文件夹并启动Docker环境。
- en: To read this chapter, the only requirement is to have an up-and-running Pimcore
    installation and be able to access it via the command line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读本章，唯一的要求是拥有一个运行中的Pimcore安装，并且能够通过命令行访问它。
- en: 'If you have installed Pimcore with Docker, just run these simple instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Docker安装了Pimcore，只需运行以下简单指令：
- en: 'Run Docker with the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Restore the local installation settings by running this command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行此命令恢复本地安装设置：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Navigate to `http://localhost/admin` and log in with your admin/pimcore credentials.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost/admin`并使用你的管理员/pimcore凭据登录。
- en: You are now ready to put into practice all the aspects related to this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好将本章相关的所有方面付诸实践。
- en: Defining blog classes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义博客类
- en: 'As we said, a blog is made up of articles and categories, so the first step
    we need to do is to create two classes relating to these. In addition to these
    two classes, we have to create a third class: `BlogAuthor`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，一个博客由文章和类别组成，因此我们首先需要做的步骤是创建两个与这些相关的类。除了这两个类之外，我们还需要创建第三个类：`BlogAuthor`。
- en: All the field types that we are going to use in our classes have already been
    seen and described in depth in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, so what interests us in this chapter is to define
    them with their name and type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的类中使用的所有字段类型已经在[*第5章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)，“探索对象和类”中看到并详细描述，因此在本章中我们感兴趣的是用它们的名称和类型来定义它们。
- en: The only new element we use is the `slug` field, which for this reason we will
    briefly describe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一使用的新元素是`slug`字段，因此我们将简要描述它。
- en: A `/slug`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`/slug`。'
- en: Using a slug thus allows us to identify a page through a readable and more identifiable
    text, compared—for example—to its numeric **identifier** (**ID**). Furthermore,
    this improves the indexing of a page by search engines, which prefer text-based
    URLs rather than URLs with numbers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短横线（slug）因此允许我们通过一个可读性和可识别性更强的文本来识别一个页面，例如，与它的数字**标识符**（**ID**）相比。此外，这也有助于提高搜索引擎对页面的索引，因为搜索引擎更喜欢基于文本的URL而不是数字URL。
- en: Let's take a look at each class we plan to create now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们现在计划创建的每个类。
- en: Defining a BlogArticle class
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义BlogArticle类
- en: 'The `BlogArticle` class is where we will generate articles for our blog. The
    creation of this class has already been discussed in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083),
    *Creating Documents in Pimcore*; the fields in the following list are standard
    for any article, but nothing prevents you from adding more as needed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlogArticle` 类是我们为博客生成文章的地方。这个类的创建已经在[*第4章*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)中讨论过，即*在Pimcore中创建文档*；以下列表中的字段是任何文章的标准字段，但您可以根据需要添加更多：'
- en: '`Title`: An input field'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Title`：输入字段'
- en: '`Content`: A **what you see is what you get** (**WYSIWYG**) component'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`：所见即所得（**WYSIWYG**）组件'
- en: '`Category`: A many-to-one relation of the `BlogCategory` class'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`：`BlogCategory`类的多对一关系'
- en: '`Slug`: A slug field'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slug`：别名字段'
- en: '`Author`: A many-to-one relation with the `BlogAuthor` class'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Author`：与`BlogAuthor`类的多对一关系'
- en: '`Image`: An image component'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：图像组件'
- en: 'Let''s jump directly to what our created class will look like. For convenience,
    we have grouped the fields in tabs, to make data entry more linear. In the next
    screenshot, here''s what the newly created class looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳到我们创建的类将是什么样子。为了方便，我们将字段分组到标签页中，以便使数据输入更加线性。在下一个截图中，这里展示了新创建的类的样子：
- en: '![Figure 9.1: BlogArticle class'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：BlogArticle类'
- en: '](img/Figure_9.01_B17073.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B17073.jpg)'
- en: 'Figure 9.1: BlogArticle class'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：BlogArticle类
- en: As you can see in the preceding screenshot, all fields are organized and are
    easy to recognize thanks to their respective icons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，所有字段都组织得很好，并且由于各自的图标，很容易识别。
- en: Defining a BlogCategory class
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义BlogCategory类
- en: 'The category class is relatively simple—it is, as we said, a container of articles.
    It is used to group articles by topic, so only a few simple fields will be needed,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类别类相对简单——正如我们所说的，它是一个文章的容器。它用于按主题分组文章，因此只需要几个简单的字段，如下所示：
- en: '`Title`: An input field'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Title`：输入字段'
- en: '`Slug`: A slug field'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slug`：别名字段'
- en: '`Description`: A text-area field'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`：文本区域字段'
- en: '`Image`: An image component'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：图像组件'
- en: We will see how to link articles with categories in the *Putting it all together*
    section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*整合一切*部分中看到如何将文章与类别链接起来。
- en: Defining a BlogAuthor class
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义BlogAuthor类
- en: As we said, an article is written by a person—or user, in computer terms—so,
    each article will have an author; that is, it must be associated with the user
    who wrote it. And in fact, in the `Article` class, we created an `Author` relationship
    field for just that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，文章是由人——或者说是计算机术语中的用户——撰写的，因此，每篇文章都将有一个作者；也就是说，它必须与撰写它的用户相关联。实际上，在`Article`类中，我们创建了一个`Author`关系字段就是为了这个目的。
- en: In Pimcore, on the other hand, user management is minimal and does not allow
    us to extend the user directly. Instead, it allows us to create a relation between
    a user and one or more Pimcore objects. This can be used to add information to
    a user or to associate one or more objects directly with a system user.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pimcore中，另一方面，用户管理是最基本的，不允许我们直接扩展用户。相反，它允许我们创建用户与一个或多个Pimcore对象之间的关系。这可以用来向用户添加信息，或者将一个或多个对象直接与系统用户关联。
- en: To do this, we then create an additional class, `BlogAuthor`, so that we can
    extend the Pimcore user with other properties, such as `FirstName` and `LastName`,
    a photo, and a biography.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们随后创建了一个额外的类，`BlogAuthor`，这样我们就可以通过其他属性扩展Pimcore用户，例如`FirstName`和`LastName`、照片和传记。
- en: 'The `BlogAuthor` class is composed of the following fields, whose names are
    already self-describing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlogAuthor`类由以下字段组成，字段名称已经具有自描述性：'
- en: '`FirstName`: A text field'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstName`：文本字段'
- en: '`LastName`: A text field'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LastName`：文本字段'
- en: '`User`: A user field'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：用户字段'
- en: '`Slug`: A slug field'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slug`：别名字段'
- en: '`Bio`: A text-area field'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bio`：文本区域字段'
- en: '`Photo`: An image component'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Photo`：图像组件'
- en: '`User`: A user field'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：用户字段'
- en: 'A small clarification should be made for the `User` field. This field uses
    a component of Pimcore—the `User` type. In the next screenshot, we thus see what
    the `User` field looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`User`字段，应该进行一个小澄清。此字段使用Pimcore的一个组件——`User`类型。因此，在下一个截图中，我们可以看到`User`字段的外观：
- en: '![Figure 9.2: User type field'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：用户类型字段'
- en: '](img/Figure_9.02_B17073.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B17073.jpg)'
- en: 'Figure 9.2: User type field'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：用户类型字段
- en: As you can see from the preceding screenshot, the configuration is not particularly
    complicated, and in fact, the only fields that we can populate will be the name
    and title of the field itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，配置并不特别复杂，实际上，我们唯一需要填写的是字段本身的名称和标题。
- en: 'When creating an object instance of the member class, you can see the input
    widget for the user property. This is a combo box where a user can be selected
    from all available Pimcore users. Let''s see how to associate an author with a
    Pimcore user. The following screenshot illustrates the process:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建成员类的对象实例时，您可以看到用户属性的输入小部件。这是一个组合框，用户可以从所有可用的Pimcore用户中选择。让我们看看如何将作者与Pimcore用户关联起来。以下截图说明了这个过程：
- en: '![Figure 9.3: Linking author to Pimcore system use'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3：将作者链接到Pimcore系统使用'
- en: '](img/Figure_9.03_B17073.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.03_B17073.jpg)'
- en: 'Figure 9.3: Linking author to Pimcore system use'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：将作者链接到Pimcore系统使用
- en: In this example, the user `Bob` was selected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，选择了用户`Bob`。
- en: Now that we have created all the necessary classes for our blog, we still have
    to configure Pimcore with the users and roles necessary to ensure that the articles
    can be associated with their respective authors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的博客创建了所有必要的类，我们仍然需要配置Pimcore，使用必要的用户和角色来确保文章可以与相应的作者关联。
- en: Creating blog Users and Roles
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建博客用户和角色
- en: The creation of users and roles has already been explained in [*Chapter 7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129),
    *Administrating Pimcore Sites*, so we just have to go back to the notions learned
    in that chapter to create the necessary users and roles.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和角色的创建已经在[*第7章*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)，*管理Pimcore站点*中解释过了，所以我们只需要回顾一下那章中学到的概念来创建必要的用户和角色。
- en: For this example, we can create two users, our dear `Bob` and `Tom` (our authors),
    and an author role to be assigned to our users.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们可以创建两个用户，我们亲爱的`Bob`和`Tom`（我们的作者），以及一个要分配给我们的用户的作者角色。
- en: Creating an Author Role
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建作者角色
- en: 'First, we will create a role for the authors. The role configuration is shown
    in the next screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为作者创建一个角色。角色配置在下一张截图中显示：
- en: '![Figure 9.4: BlogAuthor role configuration'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4：博客作者角色配置'
- en: '](img/Figure_9.04_B17073.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.04_B17073.jpg)'
- en: 'Figure 9.4: BlogAuthor role configuration'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：博客作者角色配置
- en: 'As you can see from the preceding screenshot, we have assigned the creation
    permission for the three classes of the blog: `BlogArticle`, `BlogCategory`, and
    `BlogAuthor`. This is because we need to allow users who are part of this role
    to manage these objects. In the **Permissions** section (which in *Figure 9.4*
    is compressed for reasons of space), we have selected the following items: **Assets**,
    **Classes**, **Objects**, and **Users**. This will allow users to upload images
    for their articles, and view the categories and articles created.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前一张截图中所见，我们已经为博客的三个类：`BlogArticle`、`BlogCategory`和`BlogAuthor`分配了创建权限。这是因为我们需要允许属于此角色的用户管理这些对象。在**权限**部分（在*图
    9.4*中由于空间原因被压缩），我们选择了以下项目：**资产**、**类**、**对象**和**用户**。这将允许用户上传文章的图片，并查看创建的分类和文章。
- en: 'A final configuration for the role, as you can see in the next screenshot,
    is the permissions for each class inside the **Workspaces** tab:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下一张截图中所见，角色的最终配置是在**工作空间**选项卡中的权限：
- en: '![Figure 9.5: BlogAuthors role workspace configuration'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5：博客作者角色工作空间配置'
- en: '](img/Figure_9.05_B17073.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.05_B17073.jpg)'
- en: 'Figure 9.5: BlogAuthors role workspace configuration'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：博客作者角色工作空间配置
- en: As you can see in the preceding screenshot, which represents the configuration
    of the role for each class, it will be necessary to set the permissions for users—in
    particular, for the possibility of creating articles, uploading or selecting images,
    or being able to see a list of authors and categories.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一张截图中所见，它代表了每个类的角色配置，将需要设置用户的权限——特别是创建文章、上传或选择图片或能够查看作者和分类列表的权限。
- en: Creating Users
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户
- en: Now that the configuration is complete, we can move on to create the actual
    entities, based on the classes we created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置完成后，我们可以继续创建实际的实体，基于我们创建的类。
- en: First, we need to create users `Bob` and `Tom` and assign them the author role.
    We have already learned how to create users and roles in [*Chapter 7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129),
    *Administrating Pimcore Sites*, so all we have to do is repeat the same operations
    already done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建用户`Bob`和`Tom`，并将作者角色分配给他们。我们已经学会了如何在[*第7章*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)，*管理Pimcore站点*中创建用户和角色，所以我们只需要重复之前已经完成的相同操作。
- en: Once that's done, let's create authors. The creation of an author, as well as
    an article or a category, is done from the Pimcore interface, in the **Data Objects**
    section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们创建作者。作者的创建，以及文章或类别的创建，都是在Pimcore界面的**数据对象**部分完成的。
- en: 'For convenience, we have grouped the created objects into folders and subfolders,
    as you can see in the next screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们已经将创建的对象分组到文件夹和子文件夹中，如下一个屏幕截图所示：
- en: '![Figure 9.6: List of data objects and author Bob configuration'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6：数据对象列表和作者Bob配置'
- en: '](img/Figure_9.06_B17073.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.06_B17073.jpg)'
- en: 'Figure 9.6: List of data objects and author Bob configuration'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：数据对象列表和作者Bob配置
- en: As you can see in the preceding screenshot, we have created three folders that
    must contain the objects we are going to create. In particular, the `Blog`/`Authors`
    folder will contain all the authors we will create, the `Blog`/`Categories` folder
    will contain all the blog categories, and the `Blog`/`Articles` folder will contain
    all the articles written by the authors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中所见，我们已经创建了三个文件夹，必须包含我们将要创建的对象。特别是，`Blog`/`Authors`文件夹将包含我们将创建的所有作者，`Blog`/`Categories`文件夹将包含所有博客类别，而`Blog`/`Articles`文件夹将包含作者所写的所有文章。
- en: In *Figure 9.6*, we can also see that the `User` field is a selection box, where
    it is possible to associate a user, and in our case, we have selected the system
    user `Bob`. We then finished filling in the `FirstName`, `LastName`, `Slug`, and
    `Photo` fields and completed a short biography in the `Bio` field. These fields
    will be displayed on the author page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.6*中，我们还可以看到`User`字段是一个选择框，其中可以关联一个用户，在我们的案例中，我们选择了系统用户`Bob`。然后我们完成了`FirstName`、`LastName`、`Slug`和`Photo`字段的填写，并在`Bio`字段中完成了一段简短的传记。这些字段将在作者页面上显示。
- en: Putting it all together
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'Once we have created classes for the blog, user, and author, we need to create
    data objects to represent on the pages: categories and articles. The creation
    of objects has already been seen in detail in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)*,*
    *Creating Documents in Pimcore,* and [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, so it will not be necessary on this occasion
    to go into detail on how to do this. For our blog, however, we have created author
    categories and also uploaded the necessary images for the categories and articles.
    In the following example screenshot, we see the creation of a first article, with
    the necessary information and relationships:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为博客、用户和作者创建了类，我们就需要创建数据对象来在页面上表示：类别和文章。对象的创建已经在[*第4章*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)*，*在Pimcore中创建文档*和[*第5章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)*，*探索对象和类*中详细说明，因此在此场合不需要详细说明如何进行此操作。然而，对于我们的博客，我们已经创建了作者类别，并且还上传了类别和文章所需的图片。在下面的示例屏幕截图中，我们可以看到创建第一篇文章的过程，包括必要的信息和关系：
- en: '![Figure 9.7: Creating our first article'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：创建我们的第一篇文章'
- en: '](img/Figure_9.07_B17073.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.07_B17073.jpg)'
- en: 'Figure 9.7: Creating our first article'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：创建我们的第一篇文章
- en: As you can see in the previous screenshot, all the elements have been created,
    and therefore it is possible to create an article and assign it an author, a category,
    and an image previously loaded into the asset. The arrow drawn in *Figure 9.7*
    identifies the drag-and-drop operation of the category in the `Category` field
    of the article. The same drag-and-drop method can also be used to link the author
    and image to the corresponding fields in the article.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中所见，所有元素都已创建，因此可以创建一篇文章并为其分配作者、类别和之前已加载到资产的图片。*图9.7*中绘制的箭头标识了文章“类别”字段中的类别拖放操作。相同的拖放方法也可以用来将作者和图片链接到文章的相应字段。
- en: 'It is also possible to see how we have grouped objects and assets in different
    folders. Organizing the directory structure is not mandatory, but it certainly
    helps to keep the objects we create grouped by type. As you can see from the next
    screenshot, it is possible to create folders to organize our items by right-clicking
    on **Home** or any other folder already created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到我们如何将对象和资产分组到不同的文件夹中。组织目录结构不是强制性的，但它确实有助于按类型将创建的对象分组。如下一个屏幕截图所示，可以通过在**主页**或任何其他已创建的文件夹上右键单击来创建文件夹以组织我们的项目：
- en: '![Figure 9.8: Creating our first article'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：创建我们的第一篇文章'
- en: '](img/Figure_9.08_B17073.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.08_B17073.jpg)'
- en: 'Figure 9.8: Creating our first article'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：创建我们的第一篇文章
- en: In the preceding screenshot, you see how we organized our folders, starting
    from the `Blog` folder, and inside it creating folders for articles, authors,
    and categories.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到我们是如何从 `Blog` 文件夹开始组织文件夹的，并在其中创建文章、作者和分类的文件夹。
- en: The next step we must do is define the rules for navigation around our blog—or,
    in other words, the routing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的下一步是定义博客中导航的规则——换句话说，就是路由。
- en: Routing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Routing is a key part of setting up our blog and was discussed in detail in
    the previous chapter, [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139),
    *Creating Custom CMS Pages*. We will therefore go on to create hardcoded routes,
    going directly to the `routing.yml` file to modify this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是我们设置博客的关键部分，在上一章中已经详细讨论过，[*第 8 章*](B17073_08_ePub_RK.xhtml#_idTextAnchor139)，*创建自定义
    CMS 页面*。因此，我们将继续创建硬编码的路由，直接修改 `routing.yml` 文件。
- en: Let's create a set of rules that are needed in order to identify articles, categories,
    and author pages. In addition, we want pages to be accessed by using either our
    ID or our slug.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一组必要的规则，以便识别文章、分类和作者页面。此外，我们希望页面可以通过使用我们的 ID 或 slug 来访问。
- en: 'As an example, we report the two routing rules related to the article, in this
    following piece of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们报告了与文章相关的两个路由规则，在下面的代码片段中：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the preceding code snippet, we have defined a path for the
    display of an article, and we have also set the controller and the parameters
    needed to identify the article by the ID (`blog_article_by_id`) or by the slug
    (`blog_article_by_slug`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码片段中所看到的，我们已经定义了一个显示文章的路径，我们还设置了控制器和识别文章所需的参数，无论是通过 ID (`blog_article_by_id`)
    还是通过 slug (`blog_article_by_slug`)。
- en: By analyzing the two rules, we can see that they differ only in the `path` parameter.
    In the case of the rule to identify the article by ID, in the path we have to
    search for an integer, which is the ID of the article. This is possible through
    the use of `\d+`. In the case of the rule that identifies the page through its
    slug, we must identify a string, and to do this we use the regex defined as `[\w-]+`.
    This last regex filters all strings composed of words, divided by the minus sign.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析这两个规则，我们可以看到它们只在 `path` 参数上有所不同。在通过 ID 识别文章的规则中，在路径中我们必须搜索一个整数，即文章的 ID。这是通过使用
    `\d+` 实现的。在通过 slug 识别页面的规则中，我们必须识别一个字符串，为此我们使用定义为 `[\w-]+` 的正则表达式。这个最后的正则表达式过滤了所有由单词组成并由连字符分隔的字符串。
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A regular regular expression, also called a regex is a method of matching patterns
    in text—for example, a regular expression can describe the pattern of email addresses,
    URLs, telephone numbers, employee identification numbers, social security numbers,
    or credit card numbers, and of course routes to pages on a site. The use of regular
    expressions is standard practice in many system and scripting languages. Regular
    expressions can be simple or very complex. There are hundreds of guides on the
    subject, easily available on the internet, simply by looking for `regex` on any
    web search engine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，也称为 regex，是一种在文本中匹配模式的方法——例如，正则表达式可以描述电子邮件地址、URL、电话号码、员工识别号、社会保险号或信用卡号的模式，当然还有网站上的页面路由。在许多系统和脚本语言中，正则表达式的使用是标准做法。正则表达式可以是简单的，也可以非常复杂。关于这个主题有成百上千的指南，在互联网上很容易找到，只需在任何搜索引擎上搜索
    `regex` 即可。
- en: We have seen how the rules for articles are defined. The `routing.yml` file
    also contains routing rules for categories and authors, which are defined in exactly
    the same way, except for the actions to be called on the `BlogController` controller.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了文章规则的定义方式。`routing.yml` 文件还包含了针对分类和作者的路线规则，这些规则的定义方式完全相同，只是要在 `BlogController`
    控制器上调用不同的操作。
- en: Now that we have completed the routing configuration, we must create actions
    on the controller so that our pages can contain and display the data that interests
    us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了路由配置，我们必须在控制器上创建操作，以便我们的页面可以包含和显示我们感兴趣的数据。
- en: Let's go now to see how `BlogController` and its actions are written, which
    we have up to now seen in the routing rules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在去看看 `BlogController` 及其操作是如何编写的，这些操作我们之前在路由规则中已经看到了。
- en: Editing the Controller for our blog
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑我们的博客控制器
- en: Everything about the controller has been explained in the previous chapter,
    [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139), *Creating Custom CMS
    Pages*, and therefore in this chapter, we limit the scope to just see which changes
    we need to make for the blog to work properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于控制器的内容在上一章中已经解释过，[*第8章*](B17073_08_ePub_RK.xhtml#_idTextAnchor139)，*创建自定义CMS页面*，因此在本章中，我们只关注我们需要对博客进行哪些更改才能使其正常工作。
- en: What we are interested in doing now is to create actions that correspond to
    the rules we have just finished configuring in the previous section. In fact,
    if we look at the configuration, we can see that the `Controller` field contains
    the name of the bundle (`BlogBundle`), followed by the `Controller` keyword, followed
    by the name of the controller (`BlogController`). The last part is the name of
    the action (`articleAction`) to be called when the browser URL matches the routing
    rule.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在感兴趣的是创建与上一节中刚刚配置的规则相对应的操作。实际上，如果我们查看配置，我们可以看到`Controller`字段包含捆绑名称（`BlogBundle`），后面跟着`Controller`关键字，然后是控制器名称（`BlogController`）。最后一部分是当浏览器URL与路由规则匹配时要调用的操作名称（`articleAction`）。
- en: 'To clarify these ideas, imagine we write this URL in our browser: [https://myblog.com/blog/article/my-first-article](https://myblog.com/blog/article/my-first-article).
    We uniquely identify a `blog_article_by_slug` rule. This rule, written in the
    configuration, indicates that the `articleAction` action is called in the `BlogController`
    controller of the `BlogBundle` bundle. So, with the URL that we have just written,
    we have identified an action that is called, which is the `ArticleAction` action.
    So, let''s see how this action is written.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明这些想法，想象我们在浏览器中写下这个URL：[https://myblog.com/blog/article/my-first-article](https://myblog.com/blog/article/my-first-article)。我们唯一地标识了一个`blog_article_by_slug`规则。这个规则在配置中编写，表明在`BlogBundle`捆绑的`BlogController`控制器中调用`articleAction`操作。因此，通过我们刚刚写下的URL，我们已经标识了一个要调用的操作，即`ArticleAction`操作。所以，让我们看看这个操作是如何编写的。
- en: Action for an article (ArticleAction)
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章操作（ArticleAction）
- en: 'As we have just mentioned, this action is called when the URL identifies the
    route that must display an article, by the ID or the slug. The first thing to
    do, therefore, will be to retrieve the article, based on the input parameter,
    as illustrated in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，当URL通过ID或别名标识出必须显示文章的路径时，将执行此操作。因此，首先要做的事情就是根据输入参数检索文章，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see from the preceding code snippet, the `articleAction` function
    takes two parameters: `request` and `page`. The `page` parameter is what interests
    us, to understand whether we have an ID or a slug in the URL.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，`articleAction`函数接受两个参数：`request`和`page`。我们感兴趣的参数是`page`，为了理解URL中是否有ID或别名。
- en: First of all, we need to check whether the input parameter in the `$page` variable
    is of the integer type and retrieve the value it represents. To read an integer
    from a string, we can use the `intval` function of the PHP language, which gets
    the integer value of a variable. If the `intval` function returns us an integer
    value, it means we have an ID. To retrieve an object through its ID, you can use
    the `getById` function, which Pimcore makes available in all objects. If instead,
    the `$page` variable is not an integer, then free text has been entered in the
    URL, which can be the slug of the article. We must then retrieve the object ID
    via the slug, and once retrieved, we are able to retrieve the object via its ID,
    exactly as we have just done.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查`$page`变量中的输入参数是否为整数类型，并检索它所代表的值。要从字符串中读取整数，我们可以使用PHP语言的`intval`函数，该函数获取变量的整数值。如果`intval`函数返回一个整数值，这意味着我们有一个ID。要通过ID检索对象，可以使用Pimcore在所有对象中提供的`getById`函数。如果`$page`变量不是整数，那么在URL中输入了自由文本，这可能是文章的别名。然后我们必须通过别名检索对象ID，一旦检索到，我们就可以通过其ID检索对象，就像我们刚才所做的那样。
- en: 'Once the object has been retrieved, we verify that it is an object of type
    `article`. This is done with the following `if` statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到对象，我们验证它是否是类型为`article`的对象。这是通过以下`if`语句完成的：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first part, the `instanceof` construct, is useful for checking whether
    an object is of the `BlogArticle` type; the second part of the `if` statement
    uses a specific Pimcore function, `isPublished()`, which checks whether the document
    is published. At this point, if everything is correct, we just have to call the
    `RenderTemplate` function, a function that accepts two parameters: first, the
    path of the Twig template file, and second, an array of objects to pass to the
    view. In our example, we passed the path to the article page template (`@Blog/Blog/article.html.twig`)
    and an array with the two objects necessary for rendering the page view: the article
    and the list of categories (we will see shortly how to use these variables in
    the view). For further details on how the MVC pattern works, and about the passage
    of data from routing to the controller and from the controller to the view, please
    read [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139), *Creating Custom
    CMS Pages*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，`instanceof`构造，用于检查一个对象是否为`BlogArticle`类型；`if`语句的第二部分使用一个特定的Pimcore函数`isPublished()`，该函数用于检查文档是否已发布。在此阶段，如果一切正常，我们只需调用`RenderTemplate`函数，这是一个接受两个参数的函数：首先，Twing模板文件的路径，其次，传递给视图的对象数组。在我们的示例中，我们传递了文章页面模板的路径（`@Blog/Blog/article.html.twig`）以及一个包含渲染页面视图所需两个对象的数组：文章和类别列表（我们很快将看到如何在视图中使用这些变量）。有关MVC模式如何工作以及数据从路由到控制器再到视图的传递的更多详细信息，请参阅[*第8章*](B17073_08_ePub_RK.xhtml#_idTextAnchor139)，*创建自定义CMS页面*。
- en: Other Actions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他动作
- en: We have just seen how to write an `ArticleAction` action, linked to the routing
    rules. The other rules that are present in the `routing.yml` file, which identify
    the categories and authors, will have their actions, which are written exactly
    like the action article just seen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何编写一个与路由规则链接的`ArticleAction`动作，`routing.yml`文件中存在的其他规则，用于识别类别和作者，将会有它们自己的动作，这些动作的编写方式与刚刚看到的`article`动作完全相同。
- en: Inspecting the `BlogController` code, we can easily see that all actions have
    the same structure because they perform the same operations. The purpose of these
    operations is to identify an object by its ID. The only thing that changes is
    the object that is recovered, which in one case is the article, in another the
    category, and in yet another, the author.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`BlogController`代码，我们可以很容易地看到所有动作具有相同的结构，因为它们执行相同的操作。这些操作的目的在于通过ID识别一个对象。唯一改变的是恢复的对象，在一个案例中是文章，在另一个案例中是类别，在另一个案例中是作者。
- en: 'Since the code for each action is very similar between actions, it is not necessary
    to see in detail the other actions, but we only report a list of actions that
    must be present in the controller, outlined as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个动作之间的代码非常相似，因此没有必要详细查看其他动作，我们只需报告控制器中必须存在的动作列表，如下所示：
- en: '`blogAction`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogAction`'
- en: '`articleAction`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`articleAction`'
- en: '`categoryAction`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categoryAction`'
- en: '`authorAction`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorAction`'
- en: 'All the files used for this demo—such as `routing.yml`, `BlogController.php`,
    and all the `*.html.twig` files of the views—can be downloaded from our Git repository
    related to this book: [https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此演示的所有文件（如`routing.yml`、`BlogController.php`和所有视图的`*.html.twig`文件）都可以从与本书相关的Git仓库下载：[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/)。
- en: We have seen how routes are defined and what the actions related to them are
    within the controller. Now, let's go through the files and the code needed to
    view the data we have recovered in this section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在控制器中定义路由以及与之相关的动作。现在，让我们查看所需的文件和代码，以便查看本节中恢复的数据。
- en: Rendering blog views
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染博客视图
- en: Once we have identified which page a visitor requested, through the routing
    rules seen before, and after the data has been extracted and passed to the view
    through the controller, it remains for this to be displayed correctly on the page.
    In Pimcore, this can be done using a templating system called **Twig**, which
    as we said in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083), *Creating
    Documents in Pimcore*, is the solution with which Pimcore keeps the business logic
    separate from the presentation logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过之前看到的路由规则确定了访客请求的页面，并且数据已经被提取并通过控制器传递到视图后，剩下的工作就是正确地在页面上显示。在Pimcore中，这可以通过一个名为**Twig**的模板系统来完成，正如我们在[*第4章*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)中提到的，*在Pimcore中创建文档*，这是Pimcore将业务逻辑与表示逻辑分离的解决方案。
- en: 'Briefly, Twig is a modern template engine for PHP supported by Symfony (and
    therefore by Pimcore) that allows you to process code directly in the view page,
    through its own syntax. The official page of the project, from which it is possible
    to read the complete documentation, can be reached here: [https://twig.symfony.com/](https://twig.symfony.com/).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Twig是PHP的现代模板引擎，由Symfony（因此也是由Pimcore）支持，它允许你通过其自己的语法在视图页面中直接处理代码。项目的官方页面，你可以从这里阅读完整的文档，可以访问：[https://twig.symfony.com/](https://twig.symfony.com/)。
- en: The template is useful and necessary because it is possible to create a single
    view for different content. In other words, the templating allows us to create
    a single HTML page to view all the articles of our blog, whether they are a few
    or in the millions. The view of the page will be the same for everyone—only the
    content will change. This saves us from having to create a page for each article,
    which would be a long and useless job.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是有用且必要的，因为我们可以为不同的内容创建单个视图。换句话说，模板化允许我们创建一个HTML页面来查看我们博客的所有文章，无论它们是几篇还是数百万篇。页面的视图对每个人都是相同的——只有内容会改变。这使我们免去了为每篇文章创建页面的麻烦，那将是一项漫长且无用的工作。
- en: 'So, there are four templates we need to create, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建四个模板，如下所示：
- en: '`blog`: This is the main page of the blog, which will contain a list of categories.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`博客`: 这是博客的主页，其中将包含一系列分类。'
- en: '`category`: This is the category page, which will contain all the articles
    under this category.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`分类`: 这是分类页面，其中将包含该分类下的所有文章。'
- en: '`article`: The actual article page, where the user can read the article content.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`文章`: 这是实际的文章页面，用户可以在这里阅读文章内容。'
- en: '`author`: A page containing information about the author, with a name and photo,
    and a list of their articles.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`作者`: 一个包含作者信息、姓名和照片以及他们文章列表的页面。'
- en: We will talk about these four templates shortly; however, first, we will mention
    how the pages were created in HTML and **Cascading Style Sheets** (**CSS**).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快讨论这四个模板；然而，首先，我们将提到这些页面是如何在HTML和**层叠样式表**（**CSS**）中创建的。
- en: Stylization and layout of HTML pages with Bootstrap
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bootstrap对HTML页面进行样式化和布局
- en: 'Before talking about the blog template page, we need to understand how the
    pages were made. The pages were written in **HTML**, with some Twig code snippets,
    while using Bootstrap for graphic styles and layouts. **Bootstrap** is a collection
    of graphic, stylistic, and layout tools that allow you to have a large number
    of features and styles that can be modified and adapted according to your needs.
    You can learn more about this framework on the official project page here: [https://getbootstrap.com/](https://getbootstrap.com/).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论博客模板页面之前，我们需要了解页面是如何制作的。页面是用**HTML**编写的，其中包含一些Twig代码片段，同时使用Bootstrap进行图形样式和布局。**Bootstrap**是一组图形、样式和布局工具的集合，它允许你拥有大量可修改和根据需要调整的功能和样式。你可以在官方项目页面上了解更多关于这个框架的信息：[https://getbootstrap.com/](https://getbootstrap.com/)。
- en: The main component of Bootstrap is the **Grid System**. This component allows
    you to create layouts, dividing the space into **rows** and **columns**. These
    layouts will be the starting point for building our template. In addition to the
    classes for creating a layout, Bootstrap provides a set of CSS classes that stylize
    the elements of the HTML, such as titles, paragraphs, tables, buttons, and so
    on. Then, there are the other JavaScript components—that is, elements such as
    drop-down menus, tab interfaces, tooltips, alerts, accordion menus, sliders, and
    navigation banners.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的主要组件是**网格系统**。该组件允许您创建布局，将空间分割成**行**和**列**。这些布局将是构建我们模板的起点。除了用于创建布局的类之外，Bootstrap还提供了一套CSS类，用于美化HTML元素，如标题、段落、表格、按钮等。然后，还有其他JavaScript组件——即下拉菜单、标签界面、工具提示、警报、手风琴菜单、滑块和导航横幅等元素。
- en: 'After this brief but necessary introduction to Bootstrap, let''s get back to
    our blog. Using the Bootstrap system grid, we have created some layouts, dividing
    the pages into columns. In the next screenshot, you can see the three types of
    layouts we used:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Bootstrap进行简短但必要的介绍之后，让我们回到我们的博客。使用Bootstrap系统网格，我们创建了一些布局，将页面分割成列。在下一张屏幕截图中，您可以看到我们使用的三种布局类型：
- en: '![Figure 9.9: Template layouts'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：模板布局](img/Figure_9.09_B17073.jpg)'
- en: '](img/Figure_9.09_B17073.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种布局，我们有以下内容：
- en: 'Figure 9.9: Template layouts'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'As you can see, we have three different layouts for the page, outlined as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为页面设计了三种不同的布局，概述如下：
- en: In the first layout, the content has not been divided, and therefore we have
    a column that occupies twelve-twelfths of the space.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种布局中，内容尚未被分割，因此我们有一个占据空间十二分之一的列。
- en: In the second layout, the content has been divided into two columns—one with
    four-twelfths of space and the other with eight-twelfths.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种布局中，内容已被分割成两列——一列占四分之一的空间，另一列占八分之一的空间。
- en: In the third layout, as in the previous layout, the content is divided into
    two columns of different sizes, but in reverse order compared to the second layout.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图9.9：模板布局
- en: We used the first layout with no division for the main blog page, the second
    with the small column on the left for the author page, and the third for the article
    and category pages.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了第一种没有分割的布局来制作主要博客页面，第二种布局在左侧有小列的作者页面，第三种用于文章和分类页面。
- en: 'Let''s see how this was done in the HTML page. To make the layout, we used
    Bootstrap classes to define the size of the columns. For the first layout, we
    have the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何在HTML页面中实现的。为了制作布局，我们使用了Bootstrap类来定义列的大小。对于第一种布局，我们有以下内容：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the second layout, we have the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种布局中，与之前的布局一样，内容被分割成不同大小的两列，但与第二种布局的顺序相反。
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, for the third layout, we have the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于第三种布局，我们有以下内容：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we have briefly but clearly seen how the layouts for our template
    were created. In the next section, we will see how to write the code inside the
    view files that make up our template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要但清晰地了解了我们的模板布局是如何创建的。在下一节中，我们将看到如何编写构成模板的视图文件中的代码。
- en: Templating
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板化
- en: 'The template files are `*.html.twig` files, and with Twig, we are able to insert
    the data coming from the controller. The layout and graphic style part is done
    via Bootstrap, as we saw in the previous section. We can report the four templates
    we have already defined as the following list, with the route to which they respond
    and the corresponding template file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文件是`*.html.twig`文件，通过Twig，我们能够插入来自控制器中的数据。布局和图形风格部分是通过Bootstrap完成的，正如我们在上一节中看到的。我们可以报告我们已定义的四个模板，如下所示，以及它们响应的路由和相应的模板文件：
- en: 'Blog:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 博客：
- en: 'Route: `/blog`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：`/blog`
- en: 'Twig file path: `BlogBundle/Resources/views/Blog/blog.html.twig`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twig文件路径：`BlogBundle/Resources/views/Blog/blog.html.twig`
- en: 'Category:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分类：
- en: 'Route: `/blog/category/{page}`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：`/blog/category/{page}`
- en: 'Twig file path: `BlogBundle/Resources/views/Blog/category.html.twig`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twig文件路径：`BlogBundle/Resources/views/Blog/category.html.twig`
- en: 'Article:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文章：
- en: 'Route: `/blog/article/{page}`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：`/blog/article/{page}`
- en: 'Twig file path: `BlogBundle/Resources/views/Blog/article.html.twig`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twig文件路径：`BlogBundle/Resources/views/Blog/article.html.twig`
- en: 'Author:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者：
- en: 'Route: `/blog/author/{page}`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：`/blog/author/{page}`
- en: 'Twig file path: `BlogBundle/Resources/views/Blog/author.html.twig`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twig文件路径：`BlogBundle/Resources/views/Blog/author.html.twig`
- en: So, let's see how a complete template is made. As an example, we will take the
    template of the article.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看一个完整的模板是如何制作的。作为一个例子，我们将采用文章模板。
- en: Inspecting the Article view
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文章视图
- en: 'In order to understand how the template was made, the best thing is to report
    the code and describe the parts one piece at a time. So, let''s start with the
    complete template code of the `article.html.twig` file, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解模板是如何制作的，最好的办法是报告代码并逐部分描述各个部分。因此，让我们从 `article.html.twig` 文件的完整模板代码开始，如下所示：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s start with the first line: the `extends` command indicates to Twig that
    the page extends the page identified by the `@Blog/Layout/layout.html.twig` path.
    Extending a page is like saying that the current page is somehow included within
    the page it extends. In this case, the `layout.html.twig` file contains the definition
    of the `block` `content` that we find in the `article.html.twig` file we are analyzing.
    We''ve already talked about blocks in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083),
    *Creating Documents in Pimcore*, so we can go further and describe the next lines.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一行开始：`extends` 命令指示 Twig，页面扩展了由 `@Blog/Layout/layout.html.twig` 路径标识的页面。扩展一个页面就像说当前页面以某种方式包含在它扩展的页面中。在这种情况下，`layout.html.twig`
    文件包含了我们在 `article.html.twig` 文件中分析时找到的 `block` `content` 的定义。我们已经在 [*第 4 章*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)，*在
    Pimcore 中创建文档* 中讨论了块，因此我们可以进一步描述下一行。
- en: Immediately after the start of the content block, we have another `include`
    statement, which is used to load the content of the `@Blog/Layout/header.html.twig`
    file. In this file, we find the HTML for the construction of the site header—that
    is, the image at the top and the title.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容块开始后，我们还有另一个 `include` 语句，它用于加载 `@Blog/Layout/header.html.twig` 文件的内容。在这个文件中，我们找到了构建网站头部（即顶部图像和标题）的
    HTML 代码。
- en: 'Scrolling the file, we see the data relating to the article in the main column:
    this data is retrieved through the `getTitle()`, `getAuthor()`, `getModificationDate()`,
    `getSlug()`, and `getImage()` functions. These elements are rendered using Twig
    commands, which we will see in more detail in the next section of this chapter.
    However, we can see how all the data is extracted from the `article` variable,
    which as we recall was passed to the view by the controller in the `RenderTemplate`
    command.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动文件，我们看到主列中与文章相关的数据：这些数据是通过 `getTitle()`、`getAuthor()`、`getModificationDate()`、`getSlug()`
    和 `getImage()` 函数检索的。这些元素使用 Twig 命令进行渲染，我们将在本章下一节中更详细地了解这些命令。然而，我们可以看到所有数据都是从
    `article` 变量中提取的，正如我们回忆的那样，这个变量是在 `RenderTemplate` 命令中由控制器传递给视图的。
- en: The other templates differ slightly from this one just seen, and therefore we
    will not describe them, but all the files are available in the repository related
    to this book, at [https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模板与刚刚看到的这个模板略有不同，因此我们不会对其进行描述，但所有相关文件都可在本书的仓库中找到，网址为[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore)。
- en: Rendering the Categories Widget
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染分类小部件
- en: 'As we saw in *Figure 9.9*, we have created three types of layouts, two of which
    have two columns of different sizes. We thought of inserting a component in the
    narrower columns, called a **widget**, which would contain a list of categories.
    In the next screenshot, you can see how the **Categories** widget is displayed
    on the right of the page:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *图 9.9* 中看到的，我们创建了三种类型的布局，其中两种有两个不同大小的列。我们考虑在较窄的列中插入一个组件，称为 **小部件**，它将包含一个分类列表。在下一张屏幕截图中，你可以看到
    **分类** 小部件如何在页面右侧显示：
- en: '![Figure 9.10: Template layouts'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10：模板布局'
- en: '](img/Figure_9.10_B17073.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B17073.jpg)'
- en: 'Figure 9.10: Template layouts'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：模板布局
- en: As you can see from the preceding screenshot, the **Categories** widget contains
    a list of all the blog categories, with the number of articles within each category
    in parentheses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的屏幕截图中看到的，**分类** 小部件包含所有博客分类的列表，每个分类中的文章数量用括号表示。
- en: 'The `Widget` folder. The inclusion of the widget is done through Twig''s `include`
    command. The `include` command expects at least one parameter, which is the path
    of the file to include, as you can see in the following code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget` 文件夹。小部件的包含是通过 Twig 的 `include` 命令完成的。`include` 命令至少需要一个参数，即要包含的文件路径，如下面的代码片段所示：'
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function to retrieve the list of categories is written in the `BlogController`
    controller, as can be seen in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 获取分类列表的功能是在 `BlogController` 控制器中编写的，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the widget file, we created a bulleted list of all the categories through
    the `for` Twig statement, as illustrated in the following code snippet:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件文件中，我们通过`for`Twig语句创建了一个所有类别的项目符号列表，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To get the data, we used the `getTitle()` function, and we read the `ArticleCount`
    property we created and passed to the view in the controller. We have not used
    the **Category Description** field, but we leave this as an exercise to you to
    retrieve this field and display it on the page.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取数据，我们使用了`getTitle()`函数，并读取了我们在控制器中创建并传递到视图中的`ArticleCount`属性。我们没有使用**类别描述**字段，但我们将此作为一项练习留给你，以检索此字段并在页面上显示它。
- en: Understanding Twig filters
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Twig过滤器
- en: 'Filters are functions that change the value of a variable—for example, think
    of all those PHP functions that transform the value of a string: `strtoupper`,
    `strtolower`, and so on. In Twig, they are used through the `pipe, |`, and some
    arguments are accepted. Here are some examples:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是改变变量值的函数——例如，想想所有那些转换字符串值的PHP函数：`strtoupper`、`strtolower`等等。在Twig中，它们通过`pipe,
    |`（管道符）使用，并接受一些参数。以下是一些示例：
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first example converts the value of the string to lowercase, while the
    second prints the contents of the `arrayOfStrings` array by separating the elements
    with a comma. You can consult a list of filters in the official documentation
    here: [https://twig.symfony.com/doc/](https://twig.symfony.com/doc/).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例将字符串的值转换为小写，而第二个示例通过逗号分隔元素来打印`arrayOfStrings`数组的所有内容。您可以在官方文档中查看过滤器列表：[https://twig.symfony.com/doc/](https://twig.symfony.com/doc/)。
- en: Now, let's see in detail the filters we used to create our templates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看我们用来创建模板的过滤器。
- en: Formatting dates with the date filter
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用日期过滤器格式化日期
- en: 'The `date` filter formats a date to a given format. Here''s how we used this
    filter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`过滤器将日期格式化为指定的格式。以下是使用此过滤器的示例：'
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the preceding code snippet, we used an `F jS \\a\\t g:`
    `ia` date format. The `F jS` part indicates how we want to format the date, while
    `g:` `ia` indicates the time format. The middle text, `\\a\\t`, is just there
    to write "*at*" between the date and time. For all possible formatting types for
    the date and time, you can consult the PHP online guide at [https://www.php.net/manual/en/datetime.format.php](https://www.php.net/manual/en/datetime.format.php).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们使用了`F jS \\a\\t g:` `ia`日期格式。`F jS`部分表示我们希望如何格式化日期，而`g:` `ia`表示时间格式。中间的文本`\\a\\t`只是用来在日期和时间之间写上"*at*"。对于日期和时间的所有可能的格式化类型，您可以在PHP在线指南中查看：[https://www.php.net/manual/en/datetime.format.php](https://www.php.net/manual/en/datetime.format.php)。
- en: Content ellipsed with the slice filter
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用切片过滤器省略内容
- en: 'In some cases, the text we have to display is too long, such as in the article
    list, where we want to display only an image of the article and the first two
    or three lines of the content. What we would like is to truncate the text and
    replace the cut text with three ellipses, to make the visitor understand that
    the article is not complete. To do this, we use the `slice` filter. The `slice` filter
    extracts a slice of a sequence, an array, or a string. Here''s how we used this
    filter:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们必须显示的文本太长，例如在文章列表中，我们只想显示文章的图片和内容的前两行或三行。我们希望截断文本，并用三个省略号替换被截断的文本，以便访客理解文章并不完整。为此，我们使用`slice`过滤器。`slice`过滤器从序列、数组或字符串中提取一段。以下是使用此过滤器的示例：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see from the preceding code snippet, we have set a `content` variable,
    which we will then use in the content of the template, with the value of the article
    content, applying a condition and a filter on the length. In particular, if the
    text exceeds `100` characters, we apply the `slice` filter and take the first
    `100` characters, and concatenate the three continuation points to the string.
    If instead, the content is not more than `100` characters, we take it in its entirety.
    We also used the `length` filter to get the length of the string in characters.
    One last trick: we used the tilde character (`~`) to concatenate the string.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们设置了一个`content`变量，然后将其用于模板的内容中，其值为文章内容，对长度应用条件过滤。特别是，如果文本超过`100`个字符，我们应用`slice`过滤器并取前`100`个字符，并将三个省略号连接到字符串上。如果内容不超过`100`个字符，我们则完整地取它。我们还使用了`length`过滤器来获取字符串的字符长度。最后一个技巧：我们使用了波浪号字符（`~`）来连接字符串。
- en: Rendering text with the raw filter
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原始过滤器渲染文本
- en: 'The `raw` filter marks the value as being "safe," which means that in an environment
    with automatic escaping enabled, this variable will not be escaped if `raw` is
    the last filter applied to text. As we have just seen, we used the `raw` filter
    to view the article content, as illustrated here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw`过滤器将值标记为“安全”，这意味着在自动转义启用的环境中，如果`raw`是应用到最后一个文本过滤器，则此变量不会被转义。正如我们刚才看到的，我们使用了`raw`过滤器来查看文章内容，如下所示：'
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want to see exactly how the `raw` filter behaves, you can try removing
    the `raw` filter from the content of an article, and see the result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确切了解`raw`过滤器的工作方式，您可以尝试从文章内容中移除`raw`过滤器，并查看结果。
- en: 'Filters are very useful tools because they allow us to modify data directly
    during the presentation phase. In this section, we have seen some of the filters
    available and how to use them. For all the other filters, it is possible to go
    to the official page of the Twig project, following this link: [https://twig.symfony.com/doc/](https://twig.symfony.com/doc/).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是非常有用的工具，因为它们允许我们在展示阶段直接修改数据。在本节中，我们看到了一些可用的过滤器以及如何使用它们。对于所有其他过滤器，您可以通过以下链接访问Twig项目的官方页面：[https://twig.symfony.com/doc/](https://twig.symfony.com/doc/).
- en: Differences between Pimcore and WordPress
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pimcore与WordPress之间的差异
- en: We have seen how to create a blog with Pimcore. However, some may wonder whether
    making a blog using Pimcore is the right choice. There are many **content management
    systems** (**CMSes**) that already do this job—WordPress, above all.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用Pimcore创建一个博客。然而，有些人可能会想知道使用Pimcore创建博客是否是正确的选择。已经有许多**内容管理系统**（**CMSes**）可以完成这项工作——WordPress最为著名。
- en: We mentioned WordPress because, for those who don't know of it yet, this is
    a powerful open source software solution that you can use easily and freely to
    create blogs. It is certainly the most popular CMS, due to its ease of installation
    and configuration. Almost all website-hosting solutions offer the option of having
    WordPress pre-installed in your domain. Even the use of it does not require any
    special knowledge—it is very intuitive and comes with a simple and effective administration
    page. It is also possible to extend its functionality through the installation
    of plugins, and for the frontend, it is possible to download and install thousands
    of graphic themes with nothing more than a click. All these features have made
    WordPress the preferred choice for 40% of the sites currently online on the web.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到WordPress是因为，对于那些还不了解它的人来说，这是一个强大的开源软件解决方案，您可以轻松自由地使用它来创建博客。它无疑是最受欢迎的CMS，因为它的安装和配置简单。几乎所有的网站托管解决方案都提供在您的域名中预先安装WordPress的选项。甚至使用它也不需要任何特殊知识——它非常直观，并附带一个简单有效的管理页面。您还可以通过安装插件来扩展其功能，对于前端，您只需点击一下就可以下载和安装数千个图形主题。所有这些功能都使WordPress成为目前网络上40%的网站的优先选择。
- en: So, why use Pimcore to create a blog, instead of WordPress? If, as we said,
    WordPress is the reference blog CMS, what are the reasons that can lead us to
    use Pimcore? Let's try to analyze the advantages and disadvantages (if any) of
    this choice.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么使用Pimcore来创建博客，而不是WordPress呢？如果我们说WordPress是参考博客CMS，那么是什么原因让我们选择使用Pimcore呢？让我们尝试分析这个选择的优势和劣势（如果有）。
- en: Unlike WordPress, Pimcore is based on an MVC development pattern, and this allows
    the decoupling of business logic with presentation logic. In the view part, in
    addition, Pimcore uses a rendering engine (Twig) that facilitates the insertion
    of data into the pages, without having to use PHP code. Among other things, this
    simplifies **user interface** (**UI**) changes (with a much lower development
    cost) because the data is passed to the view by the controller, rather than extracted
    and processed inside the view itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与WordPress不同，Pimcore基于MVC开发模式，这允许业务逻辑与展示逻辑解耦。在视图部分，此外，Pimcore使用一个渲染引擎（Twig），它简化了数据插入到页面中的过程，无需使用PHP代码。例如，这也简化了**用户界面**（**UI**）的更改（开发成本大大降低），因为数据是由控制器传递到视图的，而不是在视图内部提取和处理。
- en: Another aspect in favor of Pimcore is the fact of being able to have structured
    data, while in WordPress, the metadata linked to entities (articles, categories,
    users...) is not typed. In order to have typed data, it is necessary to install
    one of the many plugins available. The downside is that plugins store data and
    typing configuration in their metadata, so if—for example—we want to change or
    remove a plugin, we will also lose the data we saved with it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Pimcore的另一个优点是能够拥有结构化数据，而在WordPress中，与实体（文章、分类、用户等）关联的元数据是没有类型的。为了拥有类型化的数据，需要安装许多可用的插件之一。缺点是插件将数据及其类型配置存储在其元数据中，因此——例如——如果我们想更改或删除一个插件，我们也会丢失与之相关的数据。
- en: Another thing to take into consideration in our choice is that Pimcore is a
    complete framework, so it is possible to create features inside it. In WordPress,
    everything is feasible too, but only with the use of plugins.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择时需要考虑的另一件事是，Pimcore是一个完整的框架，因此可以在其中创建功能。在WordPress上，一切也是可行的，但只能通过使用插件来实现。
- en: 'Someone will rightly think: *But WordPress already has all the elements to
    create a blog—articles, users, categories, tags.* True. But it is also true that
    the effort to create the same structure of a blog in Pimcore, seen in this chapter,
    is minimal. And once you invest the time it takes to create a blog, the rewards
    become substantial because at this point, we will have the functionality of WordPress,
    but with the ability to customize and modify every aspect at will to make it suitable
    for our needs. Let''s take an example: if we want to add the `work` field to the
    user, what should we do? Well, on Pimcore, as we created the other fields, we
    just have to add one, and we did. On WordPress? It is obviously possible to do
    this on WordPress, but by installing a plugin.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会正确地想：**“但WordPress已经具备了创建博客的所有元素——文章、用户、分类、标签。”** 确实如此。但同样真实的是，在本章中看到的在Pimcore中创建相同博客结构的努力是微不足道的。一旦你投入了创建博客所需的时间，回报就会变得丰厚，因为在这个时候，我们将拥有WordPress的功能，但能够随意自定义和修改每个方面，使其满足我们的需求。让我们举一个例子：如果我们想向用户添加`工作`字段，我们应该怎么做？嗯，在Pimcore上，就像我们创建其他字段一样，我们只需要添加一个，我们就做到了。在WordPress上？显然，在WordPress上也可以做到这一点，但需要安装一个插件。
- en: We have talked several times about plugins for WordPress. We don't need to know
    how they work, but what we are interested in saying is that there are thousands
    of plugins, suitable for all purposes. Many of them are paid, almost all will
    do many more things than needed, and in general, installing plugins on WordPress
    requires attention to any conflicts between plugins, as well as configuration,
    updating, and maintenance. Being created by third-party developers, a plugin is
    not necessarily up to date; maybe it is not compatible with the latest version
    of WordPress, or a developer may decide to abandon it. In other words, it is always
    better and more advantageous to do the development directly inside the platform
    than to use external third-party tools.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次讨论过WordPress的插件。我们不需要了解它们是如何工作的，但我们感兴趣的是指出，有数千种插件，适用于所有目的。其中许多是付费的，几乎所有的插件都会做比所需更多的事情，总的来说，在WordPress上安装插件需要注意插件之间的任何冲突，以及配置、更新和维护。由于是由第三方开发者创建的，插件不一定是最新的；也许它不兼容WordPress的最新版本，或者开发者可能决定放弃它。换句话说，直接在平台上进行开发总是更好、更有优势，而不是使用外部第三方工具。
- en: Now, let's see the additional features that Pimcore offers. First of all, it
    is possible to create multilingual sites. WordPress still does not allow this,
    so to do this it is necessary once again to install a plugin.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Pimcore提供的附加功能。首先，可以创建多语言站点。WordPress仍然不允许这样做，因此为了做到这一点，又需要安装一个插件。
- en: Pimcore allows you to create multisites—that is, manage multiple sites and multiple
    domains in the same Pimcore installation. Even on WordPress, it is possible to
    create multisites but only on third levels, so not on different domains. For example,
    in a multisite WordPress installation, it is possible to manage `mysite.domain.com`
    and `mysite2.domain.com`, but it is not possible to manage `mysite.com` and `mysite2.com`
    in the same WordPress installation—a limitation that could be annoying for the
    management of a site with many connected domains.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Pimcore允许你创建多站点——即在同一个Pimcore安装中管理多个站点和多个域名。即使在WordPress上，也可以创建多站点，但仅限于第三级，因此不是在不同的域名上。例如，在一个多站点WordPress安装中，可以管理`mysite.domain.com`和`mysite2.domain.com`，但无法在同一个WordPress安装中管理`mysite.com`和`mysite2.com`——这可能对管理拥有许多连接域的站点来说是一个令人烦恼的限制。
- en: Pimcore allows you to easily create perspectives, to limit access to parts of
    the administrative backend, based on the profile or roles of the user who accesses
    them. On WordPress, this is not possible, and often access to the administrative
    area by users must be done through ad hoc views, and therefore without being able
    to reuse the WordPress backend.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Pimcore允许您轻松创建视角，根据访问它们的用户配置文件或角色限制对管理后端部分访问。在WordPress上，这是不可能的，并且通常用户必须通过专门视图来访问管理区域，因此无法重用WordPress后端。
- en: The advantages of having Pimcore, regardless of whether we will use it as a
    blog or not, will still be greater than using WordPress because with Pimcore,
    we will have support for business functions such as **product information management**
    (**PIM**), which we will see in [*Chapter 12*](B17073_12_ePub_RK.xhtml#_idTextAnchor211),
    *Implementing Product Information Management,* or **digital asset management**
    (**DAM**), seen in [*Chapter 6*](B17073_06_ePub_RK.xhtml#_idTextAnchor112), *Using
    Digital Asset Management*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否将其用作博客，拥有Pimcore的优势都将大于使用WordPress，因为使用Pimcore，我们将拥有对诸如**产品信息管理**（PIM）等商业功能的支持，我们将在[*第12章*](B17073_12_ePub_RK.xhtml#_idTextAnchor211)“实施产品信息管理”中看到，或者**数字资产管理**（DAM），在第[*第6章*](B17073_06_ePub_RK.xhtml#_idTextAnchor112)“使用数字资产管理”中看到。
- en: With this, we are not saying that Pimcore is better than WordPress, but we are
    just evaluating and comparing the two systems and what they can do. This will
    surely help the end user in adopting the most suitable platform for their purposes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样说并不是说Pimcore比WordPress更好，我们只是在评估和比较这两个系统以及它们能做什么。这无疑将帮助最终用户选择最适合他们目的的平台。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to build a blog, which classes we need to
    create, how to create files for the pages, how they should be structured as HTML,
    and how it is possible to render the data thanks to the Twig framework. We have
    also seen how the routes of a site are built and how it is possible to choose
    which content to display based on the request, through the use of the `routing.yml`
    file and the `BlogController` controller. Finally, we learned how to build Bootstrap
    layouts for our site and learned how to create templates with the Bootstrap framework.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何构建一个博客，需要创建哪些类，如何为页面创建文件，它们应该如何以HTML的结构来组织，以及如何通过Twig框架渲染数据。我们还学习了如何构建网站的路线，以及如何通过使用`routing.yml`文件和`BlogController`控制器，根据请求选择要显示的内容。最后，我们学习了如何为我们的网站构建Bootstrap布局，以及如何使用Bootstrap框架创建模板。
- en: In the next chapter, we will learn how to build reusable components called **Bricks**
    that can be placed in CMS or **Multiple Virtual Storage** (**MVS**) pages and,
    moreover, can be ported from project to project using bundles.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何构建可重用的组件，称为**砖块**，这些组件可以放置在CMS或**多虚拟存储**（MVS）页面上，并且还可以通过包从项目转移到项目。
