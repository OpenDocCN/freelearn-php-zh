- en: Chapter 2. Translating and Mail Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 翻译和邮件处理
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Translating your application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译您的应用程序
- en: Localizing your application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化您的应用程序
- en: Sending mail
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送邮件
- en: Receiving mail
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收邮件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An application wouldn't be an application if it couldn't react to the users.
    One simple but effective way of reacting is obviously displaying text and sending
    e-mails. Over the last couple of years internationalization (i18n) and localization
    (l10n) have become increasingly important. Nowadays users expect to be greeted
    in their language, and even receive automated e-mails from applications in a normal
    day's work.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序如果不能响应用户，那就不是一个真正的应用程序。显然，一个简单而有效的方法是显示文本和发送电子邮件。在过去的几年里，国际化（i18n）和本地化（l10n）变得越来越重要。如今，用户期望以他们的语言被问候，甚至在日常工作中从应用程序中收到自动化的电子邮件。
- en: Translating your application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译您的应用程序
- en: In this recipe we will be using the **Zend Framework 2** skeleton as a base,
    but we will create a new module to show how it all works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **Zend Framework 2** 框架作为基础，但我们将创建一个新的模块来展示它是如何工作的。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we assume that you have a working Zend Framework 2 application/skeleton
    in place. To ensure that we can actually run the code that we produce in the recipe,
    we need to make sure that the `intl` and `gettext` extensions in PHP are enabled.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们假设您已经有一个运行的 Zend Framework 2 应用程序/框架。为了确保我们可以实际运行在菜谱中产生的代码，我们需要确保 PHP
    中的 `intl` 和 `gettext` 扩展已被启用。
- en: For translating the strings we will be using **Poedit**, a cross-platform open
    source application used for translating `gettext` catalogs. The current version
    is 1.5.5 and can be found at [http://www.poedit.net/](http://www.poedit.net/)
    website. We are using gettext as this is a widely used internationalization and
    localization system for writing multilingual applications. The files generated
    by Poedit have the extensions `.po` or `.mo`. The `.po` file is used for editing;
    let's say this is an uncompiled translation file. The `.mo` file is the compiled
    translation file, which is used in our application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译字符串时，我们将使用 **Poedit**，这是一个跨平台的开源应用程序，用于翻译 `gettext` 目录。当前版本是 1.5.5，可以在 [http://www.poedit.net/](http://www.poedit.net/)
    网站找到。我们使用 gettext，因为这是一个广泛使用的国际化本地化系统，用于编写多语言应用程序。由 Poedit 生成的文件扩展名为 `.po` 或 `.mo`。`.po`
    文件用于编辑；让我们假设这是一个未编译的翻译文件。`.mo` 文件是编译后的翻译文件，用于我们的应用程序。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe we will talk about getting our application translated, something
    that is of much use in applications nowadays.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何将我们的应用程序翻译成其他语言，这在当今的应用程序中非常有用。
- en: Setting up and checking the essentials
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和检查基本要素
- en: We will assume that we have at least a basic module set up, containing a simple
    `IndexController` that outputs a simple View.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们至少设置了一个基本的模块，其中包含一个简单的 `IndexController`，它输出一个简单的视图。
- en: 'First thing we want to do is make sure we have a language directory in our
    module structure as shown in the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是确保在我们的模块结构中有一个语言目录，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this directory all the `gettext` files will be stored, which will make it
    easier for us to control them. Now, we have set up a simple folder structure,
    we need to make sure the module configuration also knows what we are doing. Now,
    we open up the `module.config.php` and add the following lines to the array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，所有 `gettext` 文件都将被存储，这将使我们更容易控制它们。现在，我们已经设置了一个简单的文件夹结构，我们需要确保模块配置也知道我们在做什么。现在，我们打开
    `module.config.php` 并向数组中添加以下行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the above configuration we have set up our module exactly the way we need
    it to look That's it; our module is now set up to use i18n.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述配置，我们已经将我们的模块设置成我们需要的样子。就这样；我们的模块现在已设置好以使用国际化。
- en: Translating strings in the controller
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在控制器中翻译字符串
- en: 'Once we have set up the translator, translating strings couldn''t be simpler.
    In the following example (file: `/module/Application/src/Application/Controller/IndexController.php`)
    we will translate the strings in the controller, but this is not good practice
    if used in the real world and is only shown here as an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了翻译器，翻译字符串将变得非常简单。在以下示例（文件：`/module/Application/src/Application/Controller/IndexController.php`）中，我们将翻译控制器中的字符串，但在实际应用中这样做并不好，这里仅作为示例展示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Translating strings in the View
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在视图中翻译字符串
- en: 'Translation in the view is even simpler than the controller (and that was pretty
    simple already). The only thing we need is the string that we want to translate,
    and that''s it. We do the following alterations to the `index.phtml` file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 视图中的翻译甚至比控制器（已经很简单了）还要简单。我们只需要我们想要翻译的字符串，就是这样。我们对`index.phtml`文件进行以下修改：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Translating strings with Poedit
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Poedit 翻译字符串
- en: Once we have installed Poedit, we need to set a couple of settings before we
    can start translating strings. Gettext works with files that are called catalogs.
    Catalogs are files that represent the source and translated text for one specific
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装 Poedit 后，在开始翻译字符串之前，我们需要设置一些设置。Gettext 与称为目录的文件一起工作。目录是表示特定语言的源文本和翻译文本的文件。
- en: First of all we should create a new catalog. After typing the first tab with
    the project name and language we want to translate (for example, nl-NL), we should
    go to the second tab called sources paths. That path should contain the path to
    the sources we would like to translate and is most likely per module, which means
    the base path should be the module directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该创建一个新的目录。在输入项目名称和要翻译的语言（例如，nl-NL）的第一个标签后，我们应该转到名为“源路径”的第二个标签。该路径应包含我们想要翻译的源路径，并且很可能是按模块划分的，这意味着基本路径应该是模块目录。
- en: In the third tab there should be a couple of identifiers to which Poedit can
    identify which strings should be translated or not. Because we will be using the
    `translate()` method, we need to make sure that at least the word 'translate'
    is in the list, we can keep the rest in there however as they won't do any harm.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个标签中，应该有一些标识符，Poedit 可以通过这些标识符识别哪些字符串应该翻译或不应翻译。因为我们将会使用`translate()`方法，我们需要确保至少单词“translate”在列表中，我们可以保留其余的，因为它们不会造成任何伤害。
- en: After we have done all that we can, click on **OK** and choose a location to
    save our file. This file needs to be saved in the languages directory within the
    module, and should have a name pattern, for example, `nl_NL.po`, `en_GB.po`, `en_US.po`.
    The naming convention for the file is `[language]_[COUNTRY]`; some countries (for
    example, Belgium and Canada) have multiple state languages which also need to
    be defined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成所有能做的事情后，点击**确定**并选择一个保存文件的位置。此文件需要保存在模块的语言目录中，并且应该有一个命名模式，例如，`nl_NL.po`，`en_GB.po`，`en_US.po`。文件的命名约定是`[language]_[COUNTRY]`；一些国家（例如，比利时和加拿大）有多个州语言，也需要定义。
- en: Once saved, press the **Update** button, which will result in the code being
    scanned for translatable strings. Now a new list appears with all the strings
    that can be translated. We can easily put our translation in the **Translation**
    box and save.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，点击**更新**按钮，这将导致代码被扫描以查找可翻译的字符串。现在出现了一个新列表，列出了所有可翻译的字符串。我们可以轻松地将我们的翻译放入**翻译**框中并保存。
- en: 'If we have done all that, our screen might look similar to the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们完成了所有这些，我们的屏幕可能看起来类似于以下截图：
- en: '![Translating strings with Poedit](img/4841OS_02_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Poedit 翻译字符串](img/4841OS_02_01.jpg)'
- en: Congratulations, we have now successfully created an i18n application!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们现在已经成功创建了一个国际化应用程序！
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are multiple ways of translating strings in ZF2, and all of them are relatively
    easy to do.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ZF2 中翻译字符串有多种方式，而且它们都相对容易实现。
- en: Basic set up of translation in your module
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的模块中基本设置翻译
- en: Although the `Application` module has an already set up translation functionality,
    this might not be what we want to use throughout our application. For instance,
    if we are (and we will be) using different modules, we wouldn't like to use the
    translation file in the `Application` module as that would make it less dynamic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序模块已经设置了翻译功能，但这可能不是我们想要在整个应用程序中使用的。例如，如果我们（我们将这样做）使用不同的模块，我们不想使用应用程序模块中的翻译文件，因为这会使它变得不那么动态。
- en: If we would use the same `gettext` file in all our modules, and store that in
    the `Application` module, this would mean that if we don't use a specific module,
    the translations would be loaded in anyway. Of course this would mean more memory
    use which we shouldn't have used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在所有模块中使用相同的`gettext`文件，并将其存储在应用程序模块中，这意味着如果我们没有使用特定的模块，翻译仍然会被加载。当然，这将意味着更多的内存使用，而这本不应该发生。
- en: That is why it is a good idea to set up translation for every module separately.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为每个模块单独设置翻译是一个好主意。
- en: Translation within ZF2 works, obviously, because of the `Zend\I18n\Translator\Translator`
    class. This class then looks at the configuration and loads up the relevant `Zend\I18n\Translator\Loader`
    which we require. If found, it will look what the current selected locale, (which
    we have set through `setLocale()`) is (for example, `nl_NL`, `en_GB`, `en_US`,
    and so on) and then parse the relevant translation file—`.mo` for gettext, `.ini`
    for INI, `.php` for PHP Array, and so on—and let is parse through the loader.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在ZF2中，翻译工作显然是因为有`Zend\I18n\Translator\Translator`类。这个类然后查看配置并加载我们需要的相关`Zend\I18n\Translator\Loader`。如果找到，它将查看当前选定的区域设置（例如，通过`setLocale()`设置的`nl_NL`、`en_GB`、`en_US`等）然后解析相关的翻译文件——对于gettext是`.mo`，对于INI是`.ini`，对于PHP数组是`.php`等——并让加载器解析。
- en: Once we call the `translate()` or `translatePlural()` method, the translator
    will search for the relevant untranslated string in the session. If found, it
    can easily return the translated string, but in the case of a string which isn't
    translated, it will just return the untranslated string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用`translate()`或`translatePlural()`方法，翻译器将在会话中搜索相关的未翻译字符串。如果找到，它可以轻松返回翻译后的字符串，但如果是未翻译的字符串，它将只返回未翻译的字符串。
- en: There's more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Instead of using gettext, there are also several other methods that can be
    used as translation files. By default ZF2 has the option to use one of the following
    formats:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用gettext，还有其他几种方法可以作为翻译文件使用。默认情况下，ZF2有选项使用以下格式之一：
- en: PHP array
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP数组
- en: Although this is a viable and easy method of translating, personally I wouldn't
    recommend it. My personal experience is that the usage of this method limits the
    use of the translation files to PHP. For example, gettext is an industry standard,
    which can be used by many platforms and applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种可行且易于翻译的方法，但就我个人而言，我不会推荐它。我的个人经验是，使用这种方法限制了翻译文件的使用范围仅限于PHP。例如，gettext是一个行业标准，可以被许多平台和应用使用。
- en: 'In the language directory we would name the PHP files in the format `[language]_[COUNTRY].php`,
    for example `nl_NL.php`. Our `module.config.php` would need an entry as shown
    in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言目录中，我们将PHP文件命名为`[language]_[COUNTRY].php`的格式，例如`nl_NL.php`。我们的`module.config.php`需要如以下代码所示的条目：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When this is defined in the `module.config.php` file, the translation itself
    will work exactly the same, the translation files (for example, `nl_NL.php`) will
    look similar as in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当这在`module.config.php`文件中定义时，翻译本身将完全相同，翻译文件（例如，`nl_NL.php`）将类似于以下代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Gettext
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gettext
- en: We used this format in the preceding examples, and as we could see they are
    easily editable by an application such as Poedit. According to Wikipedia, the
    most commonly used implementation of gettext is GNU gettext. Editing a gettext
    file is done in a so-called `.po` file where po stands for **portable object**
    , and once the files are compiled for use they will be placed in a `.mo` file
    where mo stands for **machine object**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的例子中使用了这种格式，正如我们所见，它们可以通过像Poedit这样的应用程序轻松编辑。根据维基百科，gettext最常用的实现是GNU gettext。编辑gettext文件是在所谓的`.po`文件中完成的，其中po代表**可移植对象**，一旦文件编译用于使用，它们将被放置在`.mo`文件中，其中mo代表**机器对象**。
- en: We can find the translation tool Poedit on the [http://www.poedit.net/](http://www.poedit.net/)
    website.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[http://www.poedit.net/](http://www.poedit.net/)网站上找到翻译工具Poedit。
- en: Ini
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ini
- en: 'The way this `ini` works is basically the same as any other method described
    earlier. The files in the language directory can be named `[locale].ini` (for
    example, `nl_NL.ini`), and in the `module.config.php` we would have an entry something
    like shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`ini`文件的工作方式基本上与之前描述的任何其他方法相同。语言目录中的文件可以命名为`[locale].ini`（例如，`nl_NL.ini`），在`module.config.php`中，我们会有一个类似于以下代码的条目：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see we have defined two locales in our configuration, which means
    that these two are our available i18n''s, but our `en_US` is our fallback locale.
    The fallback locale is used when no suitable locale can be found. Our translation
    files (`nl_NL.ini`) would then be looking something like the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们在配置中定义了两个区域设置，这意味着这两个是我们的可用i18n，但我们的`en_US`是我们的后备区域设置。后备区域设置在找不到合适的区域设置时使用。我们的翻译文件（`nl_NL.ini`）将类似于以下示例：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We would always start a translation with `translation.X`, where `X` is a number
    which isn't used before. We should think of this as an INI array, similar to how
    it would work in PHP.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从一个翻译开始，使用`translation.X`，其中`X`是一个之前未使用的数字。我们应该将其视为一个INI数组，类似于它在PHP中的工作方式。
- en: Localizing your application
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化您的应用程序
- en: In this recipe, we will explain localization and its uses. Localization differs
    from internationalization in the way that localization refers to, for example,
    numeric, date and time formats, and the use of currency.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将解释本地化及其用途。本地化与国际化的区别在于，本地化指的是例如数字、日期和时间格式，以及货币的使用。
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe we will be discussing the ever so important localization of our
    application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论我们应用程序本地化的重要过程。
- en: So it begins
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 因此，故事开始了
- en: When a user hits our website, we most likely want the user to automatically
    go to the right language. Although, there are several methods of doing this, we
    will be using a manual check to see if the language the user prefers is also in
    our list of languages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问我们的网站时，我们很可能希望用户自动跳转到正确的语言。尽管有几种实现方法，但我们将使用手动检查来查看用户偏好的语言是否也在我们的语言列表中。
- en: 'We do this by a couple of simple tricks:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过几个简单的技巧来实现这一点：
- en: First, we are getting the `Accept-Language` headers from the HTTP request
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们从HTTP请求中获取`Accept-Language`头
- en: Then we iterate through them and see if one of the languages mentioned in the
    header matches the language we have
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们遍历它们，看看标题中提到的语言中是否有与我们所拥有的语言相匹配的
- en: Lastly, we set the language to the language we have found, or if nothing is
    found, the fallback language is set
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将语言设置为找到的语言，或者如果没有找到，则设置为回退语言
- en: 'Let''s see how this looks in our `Module.php` code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在我们的`Module.php`代码中的样子：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we need to start off by declaring the namespace (in our case `Application`)
    as we want the framework to know where to find our code. We then want to make
    sure we always put all the required classes in the use declaration so that we
    preload these before we go further in the code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明命名空间（在我们的情况下是`Application`），因为我们希望框架知道我们的代码在哪里。然后我们想要确保我们总是将所有必需的类放在使用声明中，这样我们就可以在代码进一步之前预加载这些类。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `retrieveLocales()` method we are parsing through the languages directory
    and assume our filenames are called `en_GB.ext`. This way we can parse all the
    languages easily into one array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`retrieveLocales()`方法中，我们正在解析语言目录，并假设我们的文件名为`en_GB.ext`。这样我们就可以轻松地将所有语言解析到一个数组中：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see in the previous code, what we try to achieve is to see if we have
    an exact match with any of the language (`en_GB`, `nl_NL`) that we support. If
    we don't have an exact match we already made sure our fallback language (`en_US`)
    is being used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，我们试图实现的是查看我们是否与支持的语言（`en_GB`、`nl_NL`）中的任何一个完全匹配。如果没有找到完全匹配，我们已经确保正在使用回退语言（`en_US`）。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please make sure that the `intl` extension of PHP is enabled in the configuration,
    otherwise this example will not work correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在配置中启用了PHP的`intl`扩展，否则此示例将无法正确工作。
- en: Localizing currencies
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化货币
- en: 'In Zend Framework 2 localizing currencies within a View can be done through
    the i18n view helper, which comes standard with ZF2\. The view helper, which is
    called `CurrencyFormat`, can easily be used in the view by the following method
    call. We do the following alterations to the `sometemplate.phtml` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zend Framework 2中，可以通过i18n视图助手在视图中本地化货币，该助手是ZF2的标准功能。可以通过以下方法调用轻松在视图中使用名为`CurrencyFormat`的视图助手。我们对`sometemplate.phtml`文件进行了以下修改：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This piece of code will give the output `45.312,56 €`, as we specified to localize
    to a Euro currency symbol with a Dutch localization format, which in this case
    is dot for thousands and a comma for decimal separation. We can also leave the
    locale `nl_NL` out, and then the `CurrencyFormat` view helper will automatically
    select the default locale of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出`45.312,56 €`，因为我们指定了使用荷兰本地化格式本地化欧元货币符号，在这种情况下是千位点的逗号和十位点的分隔符。我们也可以省略`nl_NL`，然后`CurrencyFormat`视图助手将自动选择应用程序的默认区域设置。
- en: Localizing date/times
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化日期/时间
- en: To format any dates and times in our applications we can use the `DateFormat`
    view helper, which is just as easy to use as the currency view helper, but has
    a few more options to use. We do the following alterations to the `sometemplate.phtml`
    file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中格式化任何日期和时间，我们可以使用 `DateFormat` 视图助手，它就像货币视图助手一样容易使用，但有一些额外的选项可以使用。我们对
    `sometemplate.phtml` 文件进行了以下修改。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code will only display the date, which is going to be formatted
    as `Monday, May 14, 2012 AD`. We can omit giving any parameters, but then nothing
    will be displayed as the default options are `IntlDateFormatter::NONE`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只会显示日期，它将被格式化为 `Monday, May 14, 2012 AD`。我们可以省略提供任何参数，但这样将不会显示任何内容，因为默认选项是
    `IntlDateFormatter::NONE`。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Localization (l10n) is like internationalization (i18n), a very important aspect
    of a public application. We spoke about how to make sure your application can
    be translatable in the last recipe, but now it is time to make sure that we are
    able to find out how to use any l10n.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化（l10n）就像国际化（i18n）一样，是公共应用程序的一个重要方面。我们在上一个食谱中讨论了如何确保你的应用程序可以翻译，但现在我们需要确保我们能够找到使用任何
    l10n 的方法。
- en: Zend Framework 2 works closely together with the i18n/l10n functionality that
    is already built in PHP. Although, we could use the `Locale` class of PHP separately
    of the ZF2 classes, it is not recommended as the ZF2 already use the Locale from
    PHP itself, but provide a much nicer and quicker interface to it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2 与 PHP 内置的 i18n/l10n 功能紧密协作。尽管我们可以单独使用 PHP 的 `Locale` 类而不依赖于
    ZF2 类，但并不推荐这样做，因为 ZF2 已经使用了 PHP 自身的 Locale，但它提供了一个更优雅、更快捷的接口。
- en: In the background, however, ZF2 communicates directly with the `Locale` of PHP
    itself, but if we want to use the more robust functionalities, we should use the
    ZF2 libraries (which are handy when we are creating multilingual web applications).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在幕后，ZF2 直接与 PHP 的 `Locale` 进行通信，但如果我们想使用更强大的功能，我们应该使用 ZF2 库（这在创建多语言 Web 应用程序时非常有用）。
- en: Identifying the client language
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别客户端语言
- en: The previous example code relies on the client browser sending the `Accept-Language`
    header. Although most modern browsers do this, it's still something that might
    not always work. Overall it is a pretty good tool to preselect any languages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码依赖于客户端浏览器发送 `Accept-Language` 头部。尽管大多数现代浏览器都会这样做，但这仍然可能不是总是可行的。总的来说，这是一个相当好的工具，可以预先选择任何语言。
- en: Instead of making everything ourselves like shown previously, there is also
    a very nifty module called `SlmLocale` made by *Jurian Sluiman* ([https://github.com/juriansluiman/SlmLocale](https://github.com/juriansluiman/SlmLocale))
    which we can recommend for detecting and selecting the default locale.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前展示的自行构建一切不同，还有一个非常巧妙的模块叫做 `SlmLocale`，由 *Jurian Sluiman* 创建（[https://github.com/juriansluiman/SlmLocale](https://github.com/juriansluiman/SlmLocale)），我们推荐用于检测和选择默认区域设置。
- en: Localizing currencies and dates
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化货币和日期
- en: Localizing currencies and dates are usually done in View, as it basically is
    only formatting a piece of information. You can do it somewhere else but we should
    always be wary to make sure we won't localize anything in, for example, models,
    as they only should contain logic. In most cases the language is not part of the
    logic, but simply a nice way of making the view a bit more user friendly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化货币和日期通常在视图中完成，因为这基本上只是格式化信息的一部分。你可以在其他地方做，但我们应该始终小心，确保我们不会在例如模型中本地化任何内容，因为它们只应包含逻辑。在大多数情况下，语言不是逻辑的一部分，而是一种使视图更用户友好的简单方式。
- en: Sending mail
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送邮件
- en: Sending e-mail through `sendmail` is usually a pretty standard way of working,
    as it is probably one of the most used ways of transporting e-mail (or proxying
    the e-mail to an SMTP server) on a Linux-based system. On most Linux servers `sendmail`
    is already installed and therefore it's very easy to start sending e-mail with
    that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `sendmail` 发送电子邮件通常是一种相当标准的操作方式，因为它可能是 Linux 系统上传输电子邮件（或代理电子邮件到 SMTP 服务器）最常用的方式之一。在大多数
    Linux 服务器上，`sendmail` 已经安装好了，因此使用它来发送电子邮件非常简单。
- en: That is why we will be discussing this method of sending e-mail first, so that
    we can start off easy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将首先讨论这种发送电子邮件的方法，这样我们可以从简单开始。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe we will discuss the method of sending mail from within our application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论在应用程序内部发送邮件的方法。
- en: Transport\Sendmail
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Transport\Sendmail
- en: 'Let''s take a look at the following example of sending an e-mail through `sendmail`,
    and although this functionality is placed in a controller, in real life this needs
    to stay far away from that and be placed safely away in a model:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下通过`sendmail`发送电子邮件的示例，尽管这个功能被放置在控制器中，但在现实生活中，这需要远离控制器，安全地放置在模型中：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: No configuration is usually required for setting up e-mail to be sent through
    `sendmail`, as it is a mail transport application on the local host only.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，设置通过`sendmail`发送的电子邮件不需要配置，因为它仅是本地主机上的邮件传输应用程序。
- en: Transport\Smtp
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Transport\Smtp
- en: 'We can easily send our e-mail through SMTP if we want (if we know our SMTP
    server details obviously):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过SMTP发送电子邮件（如果我们知道SMTP服务器的详细信息的话）：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Transport\File
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Transport\File
- en: Let's take a look at an example of how to send our e-mail in to files…
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们的电子邮件发送到文件的示例…
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After sending the e-mail the file transporter will create a file which might
    look something like `mail_453421020.txt`. We have given `/tmp` as the directory
    to where this file should be saved, we should look there to see if our file exists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件后，文件传输器将创建一个可能看起来像`mail_453421020.txt`的文件。我们指定了`/tmp`作为文件应该保存的目录，我们应该在那里查看我们的文件是否存在。
- en: Of course we can do anything in the callback function, for example, we can check
    if a certain file exists, or pull a name from the database. The options are endless.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在回调函数中做任何事情，例如，我们可以检查某个文件是否存在，或者从数据库中拉取一个名称。选项是无限的。
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Zend Framework 2 needs a minimum of two objects to make the sending of e-mails
    work. First is the `Zend\Mail\Message` object, which is used to completely define
    the message that needs to be sent. We can define `to`, `cc`, `bcc`, and `from`
    addresses in this object. The object is also used to set the body of the message;
    this can be either HTML or plain-text, completely depending on our own requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2需要至少两个对象来使电子邮件发送工作。首先是`Zend\Mail\Message`对象，用于完全定义需要发送的消息。我们可以在该对象中定义`to`、`cc`、`bcc`和`from`地址。该对象还用于设置消息正文；这可以是HTML或纯文本，完全取决于我们的需求。
- en: Then as a second object we need a class that implements the `Zend\Mail\Transport\TransportInterface`
    class that handles the actual sending of the e-mail. This class only (at the moment
    anyway) has a `send(Mail\Message $message)` method defined that needs to be added
    when we implement the transport.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个对象，我们需要一个类来实现`Zend\Mail\Transport\TransportInterface`类，该类负责处理电子邮件的实际发送。这个类目前（至少现在）只定义了一个`send(Mail\Message
    $message)`方法，在我们实现传输时需要添加。
- en: What happens after defining the two objects is that we give our `Message` object
    to our `Transport` object and tell it to send it off. How the sending is handled,
    is obviously determined by the `Transport` object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义两个对象之后，我们将`Message`对象交给`Transport`对象，并告诉它发送。发送是如何处理的，显然是由`Transport`对象决定的。
- en: Sending mail through SMTP
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SMTP发送邮件
- en: Transporting mail through SMTP might not sound familiar to us, but it is a common
    method of sending e-mail through another system. Think about a desktop e-mail
    client that retrieves our e-mail from another server. When we send off an e-mail
    from that same e-mail client, it could very well be that we will be using SMTP
    to send it off. In a nutshell, SMTP is sending an e-mail to another mail server
    that then handles our mail transportation for us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SMTP传输邮件可能对我们来说不熟悉，但它是通过另一个系统发送电子邮件的常用方法。想想看，桌面电子邮件客户端从另一个服务器检索我们的电子邮件。当我们从这个相同的电子邮件客户端发送电子邮件时，我们可能会使用SMTP来发送它。简而言之，SMTP是将电子邮件发送到另一个邮件服务器，然后由该服务器为我们处理邮件传输。
- en: Sending mail through files
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过文件发送邮件
- en: Although not used often, there are e-mail senders that simply pick up clear
    text files with the complete message which needs sending from a specific directory,
    and send them off. And obviously if we have no way of testing our actual e-mail
    sending, this is also a great way of testing if the system works.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常用，但有一些电子邮件发送者会简单地从特定目录中提取需要发送的完整消息的纯文本文件，并将它们发送出去。显然，如果我们没有测试实际电子邮件发送的方法，这也是测试系统是否工作的一种很好的方式。
- en: Receiving mail
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收邮件
- en: Now, let's deal with the part of receiving mails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理接收邮件的部分。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we will be giving examples on the different methods of connecting
    to mailbox through ZF2, and therefore it would be nice if we had access to a mailbox
    we connect to. Of course this is not required, but it sure adds to the fun to
    have an actual working mailbox.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将给出通过 ZF2 连接到邮箱的不同方法的示例，因此如果我们能访问我们连接到的邮箱那就太好了。当然，这不是必需的，但有一个实际工作的邮箱确实增加了乐趣。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will now discuss receiving e-mail within an application, which can be useful
    on some occasions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论在应用程序内接收电子邮件，这在某些场合可能很有用。
- en: Connecting to an IMAP mail server
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到 IMAP 邮件服务器
- en: The first method of connecting to a mail server is through IMAP. The protocol
    basically lets us connect to the mail server, and looking in the different folders
    on the server if there are unread e-mails.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到邮件服务器的第一种方法是使用 IMAP。该协议基本上允许我们连接到邮件服务器，并在服务器上的不同文件夹中查找是否有未读电子邮件。
- en: 'Let''s take a look at our example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的示例：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Connecting to a POP3 mail server
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到 POP3 邮件服务器
- en: 'Let''s take a look at our simple connection example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的简单连接示例：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Working with flags on IMAP or Maildir connections
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 IMAP 或 Maildir 连接上处理标志
- en: Flags are attributes that are attached to a message in which we can see the
    specific property of a message. To put it simpler, it can tell us, for example,
    if a message is read or answered. We can either get the flags from a message by
    using the `getFlags()` method, or by using the `hasFlag()` method. The flags that
    can be used are to be found in the `Zend\Mail\Storage` class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 标志是附加到消息上的属性，我们可以从中看到消息的特定属性。简单来说，它可以告诉我们，例如，消息是否已阅读或回复。我们可以通过使用 `getFlags()`
    方法或 `hasFlag()` 方法从消息中获取标志。可用的标志可以在 `Zend\Mail\Storage` 类中找到。
- en: Maildir++ Quota system
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Maildir++ 配额系统
- en: 'Let''s take a look at the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下示例：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keeping a connection alive
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持连接活跃
- en: 'The following is an example of the use of NOOP:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 NOOP 的示例：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The tricky part here is when to use `noop()`, as sometimes it is really hard
    to predict which process is taking the longest. That is why we created a special
    example to show you how easy it is to make sure that `noop()` is being carried
    out regularly, until we are done with our process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里棘手的部分是何时使用 `noop()`，因为有时很难预测哪个进程耗时最长。这就是为什么我们创建了一个特殊的示例来向您展示确保 `noop()` 定期执行有多容易，直到我们完成我们的进程。
- en: 'We can do this by utilizing `register_tick_function`, which enables us to call
    a specific process on every tick. What we''ll do is create a class that handles
    `noop()`, and executes it every 5 minutes until we say it should stop:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用 `register_tick_function` 来实现这一点，它使我们能够在每个 tick 上调用一个特定的进程。我们将创建一个处理
    `noop()` 的类，并每 5 分钟执行一次，直到我们说它应该停止：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we now are at a piece of code that requires us to execute for a long time,
    we can easily call the `start()` method to do the NOOP''ing for us as shown in
    the following line of code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在遇到一段需要长时间执行的代码，我们可以轻松地调用 `start()` 方法来为我们执行 NOOP，如下面的代码行所示：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And when we are done, we simply `stop()` the NOOP''ing again as shown in the
    following line of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们只需再次 `stop()` NOOP'ing，如下面的代码行所示：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Mailboxes are being connected to; however we will see them in ZF2 as storage
    objects. Because of this we can easily parse through all the messages, and in
    some cases are able to manipulate messages on the storage, such as copying or
    moving them. We need to remember that messages are always read only, and storages
    are the ones that can be manipulated. It is possible, for example, to create and
    delete a folder, but never edit an existing message.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 邮箱正在连接；然而，在 ZF2 中我们将它们视为存储对象。正因为如此，我们可以轻松地遍历所有消息，在某些情况下，我们甚至能够操纵存储中的消息，例如复制或移动它们。我们需要记住，消息始终是只读的，而存储是可以被操纵的。例如，我们可以创建和删除文件夹，但永远不能编辑现有的消息。
- en: The only writeable functionality we have for manipulating a message is `appendMessage()`,
    which appends a message to the storage. But when it is stored, we are not able
    to edit it again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于操作消息的唯一可写功能是 `appendMessage()`，它将消息追加到存储中。但是，当它被存储后，我们就无法再次编辑它。
- en: Connecting to a POP3 server
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到 POP3 服务器
- en: Connecting with a POP3 server is very similar to using an IMAP server (handy,
    isn't it?). The only major difference is normally with a POP3 server the messages
    disappear from the mail server after retrieving them, unless we specifically tell
    the server otherwise.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用POP3服务器连接与使用IMAP服务器非常相似（方便，不是吗？）。唯一的重大区别通常在于，使用POP3服务器，在检索消息后，消息会从邮件服务器上消失，除非我们明确告诉服务器否则。
- en: About the Maildir++ Quota system
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于Maildir++配额系统
- en: Maildir++ is an extended version of Maildir, but still compatible with the normal
    Maildir routine and supports quota systems. This is a very useful system because
    of its quota and how it stores messages (on filesystem). This is used in a lot
    of companies, but obviously it comes with its own troubles. For example, when
    trying to write/copy a message on a Maildir++ server, it can be that this will
    throw an exception because we are over the system quota.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Maildir++是Maildir的扩展版本，但仍然与正常的Maildir程序兼容，并支持配额系统。这是一个非常有用的系统，因为它有配额以及如何存储消息（在文件系统上）。这个系统在许多公司中被使用，但显然它也伴随着自己的问题。例如，当尝试在Maildir++服务器上写入/复制消息时，可能会抛出异常，因为我们已经超过了系统配额。
- en: That is why that – unless you know for certain Maildir++ isn't used – to implement
    a check for the quota before trying to do any write-based functionality.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，除非你确定Maildir++没有被使用，否则在尝试执行任何基于写入的功能之前，实施一个配额检查是明智的。
- en: Keeping the connection alive
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持连接活跃
- en: Once a connection has been opened and parsing through messages is instantiated,
    the connection has a fair chance of closing once too much time has passed. At
    that point it is always wise to implement a `No Operation` command, or NOOP. This
    will tell the mail server that we are still there, but are just doing something
    else at the moment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了连接并且解析消息被实例化，如果时间过长，连接有很大可能会关闭。在那个时刻，实施一个“无操作”命令，或称NOOP，总是明智的。这将告诉邮件服务器我们还在那里，但此刻正在做其他事情。
- en: There's more…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There is obviously a lot more to tell about retrieving e-mails from a mail
    server, and it would be a great adventure to find them all out. Unfortunately,
    going in for all the advanced details would almost be a book in itself, so we
    have put down a couple of subjects which are worth exploring:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，关于从邮件服务器检索电子邮件还有很多可以说的，找到所有这些内容将是一次伟大的冒险。不幸的是，详细讲解所有高级细节几乎可以写成一本书，所以我们只列出了一些值得探索的主题：
- en: Caching instances (see also [Chapter 8](ch08.html "Chapter 8. Optimizing Performance"),
    *Optimizing Performance*)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存实例（参见第8章[优化性能](ch08.html "第8章。优化性能")，*优化性能*）
- en: Reading HTML messages, or multi part messages with attachments
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取HTML消息，或带有附件的多部分消息
- en: Advanced use of folders on IMAP/Maildir/Mbox
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IMAP/Maildir/Mbox上的文件夹的高级使用
- en: Protocol class extensions
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议类扩展
- en: Setting up e-mail box settings through the configuration
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过配置设置电子邮件箱设置
