- en: Chapter 2. Kick-Starting OOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：启动OOP
- en: In this chapter we will learn how to create objects, define their attributes
    (or properties) and methods. Objects in PHP are always created using a "class"
    keyword. In this chapter we will learn the details of classes, properties, and
    methods. We will also learn the scope of methods and about modifiers and the benefits
    of using interfaces This chapter will also introduce us to other basic OOP features
    in PHP. As a whole, this chapter is one of the better resources for you to kick-start
    OOP in PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建对象，定义它们的属性（或属性）和方法。PHP中的对象总是使用“class”关键字创建的。在本章中，我们将学习类、属性和方法的具体细节。我们还将学习方法的范围以及修饰符和使用接口的好处。本章还将介绍PHP中其他基本面向对象编程（OOP）特性。总的来说，本章是你在PHP中启动OOP的较好资源之一。
- en: Let's Bake Some Objects
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们制作一些对象
- en: 'As I said before, you can create an object in PHP using the `class` keyword.
    A class consists of some properties and methods, either public or private. Let''s
    take the `Emailer` class that we have seen in our first chapter. We will discuss
    here what it actually does:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，你可以在PHP中使用`class`关键字创建一个对象。一个类由一些属性和方法组成，可以是公开的或私有的。让我们以我们在第一章中看到的`Emailer`类为例。在这里，我们将讨论它实际上做了什么：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we started with `class` `Emailer`, which means that the name of
    our class is `Emailer`. While naming a class, follow the same naming convention
    as variables, i.e. you can't start with a numeric letter, etc.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们以`class` `Emailer`开始，这意味着我们类的名字是`Emailer`。在命名类时，遵循与变量相同的命名约定，即你不能以数字字母开头等。
- en: After that we declared the properties of this class. There are four properties
    here, namely, `$sender`, `$recipient`, `$subject`, and `$body`. Please note that
    we declare each of them with a keyword `private`. A private property means that
    this property can only be accessed internally from this class. Properties are
    nothing but variables inside a class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们声明了这个类的属性。这里有四个属性，分别是`$sender`、`$recipient`、`$subject`和`$body`。请注意，我们用关键字`private`声明了它们。私有属性意味着这个属性只能从这个类内部访问。属性不过是类内部的变量。
- en: If you remember what a method is, it is just a function inside the class. In
    this class there are five functions, `__construct()`, `addRecipient()`, `setSubject()`,
    `setBody()`, and `sendEmail()`. Please note that the last four methods are declared
    public. That means when someone instantiates this object, they can access these
    methods.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得方法是什么，它只是类内部的一个函数。在这个类中，有五个函数，`__construct()`、`addRecipient()`、`setSubject()`、`setBody()`和`sendEmail()`。请注意，最后四个方法被声明为公开的。这意味着当有人实例化这个对象时，他们可以访问这些方法。
- en: The `__construct()` is a special method inside a class which is called constructor
    method. Whenever a new object is created from this class, this method will execute
    automatically. So if we have to perform some preliminary tasks in our object while
    initiating it, we will do from this constructor method. For example, in the constructor
    method of this `Emailer` class we just set the `$recipients` as a blank array
    and we also set the sender name.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`__construct()`是一个类内的特殊方法，称为构造方法。每当从这个类创建一个新的对象时，这个方法将自动执行。所以如果我们需要在初始化对象时执行一些初步任务，我们将从构造方法中执行。例如，在这个`Emailer`类的构造方法中，我们只设置了`$recipients`为一个空数组，我们还设置了发件人姓名。'
- en: Accessing Properties and Methods from Inside the Class
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类内部访问属性和方法
- en: 'Are you wondering how a function can access the class properties from inside
    its content? Let''s see using the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道函数是如何从其内容内部访问类属性的吗？让我们用以下代码看看：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is a private property named `$body` inside our class, and if we want to
    access it from within the function, we must refer to it with `$this`. `$this`
    means a reference to current instance of this object. So we can access the `body`
    property with `$this->body`. Please note that we have to access the properties
    (i.e class variables) of a class using a "->" following the instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中有一个名为`$body`的私有属性，如果我们想从函数内部访问它，我们必须用`$this`来引用它。`$this`意味着对当前对象实例的引用。因此，我们可以通过`$this->body`访问`body`属性。请注意，我们必须使用一个跟在实例后面的"->"来访问类的属性（即类变量）。
- en: Similarly, like properties, we can access any member method from inside another
    member method in this format. For example, we can evoke `setSubject` method as
    `$this->setSubject()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像属性一样，我们可以在这种格式中从另一个成员方法内部访问任何成员方法。例如，我们可以调用`setSubject`方法为`$this->setSubject()`。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that `$this` keyword is only valid inside the scope of a method,
    as long as it is not declared as static. You can not use `$this` keyword from
    outside the class. We will learn about this "static", "private", "public" keywords
    more in the *Modifiers* section later this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$this`关键字仅在方法的作用域内有效，只要它没有被声明为静态。你不能从类外部使用`$this`关键字。我们将在本章后面的“修饰符”部分更详细地学习“静态”、“私有”、“公共”这些关键字。
- en: Using an Object
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象
- en: 'Let''s use the newly created `Emailer` object from inside our PHP code. We
    must note some things before using an object. You must initiate an object before
    using it. After initiating, you can access all its public properties and methods
    using "->" after the instance. Let''s see using the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在PHP代码内部使用新创建的`Emailer`对象。在使用对象之前，我们必须注意一些事项。在使用对象之前，你必须初始化它。初始化之后，你可以使用"->"符号来访问其实例的所有公共属性和方法。让我们通过以下代码来看一下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the above code piece, we first created an instance of `Emailer` class to
    a variable name `$emailerobject` in the first line. Here, there is something important
    to note: We are supplying a sender address while instantiating this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们首先在第一行创建了一个`Emailer`类的实例，并将其赋值给变量`$emailerobject`。在这里，有一点很重要：我们在实例化这个对象时提供了一个发送地址：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember we had a constructor method in our class as `__construct($sender)`.
    When initiating an object, we said that the constructor method is called automatically.
    So while initiating this `Emailer` class we must supply the proper arguments as
    declared in the constructor method. For example the following code will create
    a warning:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们类中有一个构造函数方法，名为`__construct($sender)`。当我们初始化对象时，我们说构造函数会自动调用。所以，当我们初始化这个`Emailer`类时，我们必须提供构造函数方法中声明的正确参数。例如，以下代码将创建一个警告：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you execute the above code, it shows the warning as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行上述代码时，会显示如下警告：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See the difference? If your class had no constructor method or a constructor
    with no arguments, you can instantiate it with the above code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看到区别了吗？如果你的类没有构造函数方法，或者有一个不带参数的构造函数，你可以使用上述代码来实例化它。
- en: Modifiers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: You have seen that we used some keywords like `private` or `public` in our class.
    So what are these and why do we need to use them? Well, these keywords are called
    modifier and introduced in PHP5\. They were *not* available in PHP4\. These keywords
    help you to define how these variables and properties will be accessed by the
    user of this class. Let's see what these modifiers actually do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到我们在类中使用了`private`或`public`等关键字。那么这些是什么，为什么我们需要使用它们呢？好吧，这些关键字被称为修饰符，并在PHP5中引入。它们在PHP4中是不可用的。这些关键字帮助你定义这些变量和属性将如何被类的用户访问。让我们看看这些修饰符实际上做了什么。
- en: '**Private**: Properties or methods declared as private are not allowed to be
    called from outside the class. However any method inside the same class can access
    them without a problem. In our `Emailer` class we have all these properties declared
    as private, so if we execute the following code we will find an error.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有（Private）**：声明为私有的属性或方法不允许从类外部调用。然而，同一类内的任何方法都可以无问题地访问它们。在我们的`Emailer`类中，我们把这些属性都声明为私有，所以如果我们执行以下代码，我们会发现一个错误。'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The above code upon execution gives a fatal error as shown below:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，会显示如下所示的致命错误：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That means you can't access any private property or method from outside the
    class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不能从类外部访问任何私有属性或方法。
- en: '**Public**: Any property or method which is not explicitly declared as private
    or protected is a public method. You can access a public method from inside or
    outside the class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共（Public）**：任何未明确声明为私有或受保护的属性或方法都是公共方法。你可以从类内部或外部访问公共方法。'
- en: '**Protected:** This is another modifier which has a special meaning in OOP.
    If any property or method is declared as protected, you can only access the method
    from its subclass. We will learn details about subclass later in this chapter.
    But to see how a protected method or property actually works, we''ll use the following
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护（Protected）**：这是另一个在面向对象编程中有特殊意义的修饰符。如果任何属性或方法被声明为受保护，你只能从其子类中访问该方法。我们将在本章后面的部分详细学习子类。但为了看到受保护的属性或方法实际上是如何工作的，我们将使用以下示例：'
- en: 'To start, let''s open `class.emailer.php` file (the `Emailer` class) and change
    the declaration of the `$sender` variable. Make it as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开`class.emailer.php`文件（`Emailer`类）并更改`$sender`变量的声明。让它如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now create another file name `class.extendedemailer.php` with the following
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建另一个名为`class.extendedemailer.php`的文件，并包含以下代码：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now use this object like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用这个对象这样使用：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now if you look carefully at the code of the `ExtendedEmailer` class, you will
    find that we accessed the `$sender` property of its parent (which is actually
    `Emailer` class). We have been able to access that property only because it was
    declared as protected. One more benefit we get here, is that the property `$sender`
    is still inaccessible directly from outside the scope of these two classes. That
    means if we execute the following code, it will generate a fatal error.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你仔细查看`ExtendedEmailer`类的代码，你会发现我们访问了其父类（实际上是`Emailer`类）的`$sender`属性。我们之所以能够访问这个属性，仅仅是因为它被声明为受保护的。在这里我们得到的另一个好处是，属性`$sender`仍然不能直接从这两个类的作用域之外直接访问。这意味着如果我们执行以下代码，它将生成一个致命错误。
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon execution, it gives the following error:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，它给出以下错误：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Constructors and Destructors
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: 'We discussed earlier in this chapter about the constructor method. A constructor
    method is the method that executes automatically while creating instances of the
    class. In PHP5, there are two ways you can write a constructor method inside a
    class. The first one is to create a method with the name `__construct()` inside
    the class. The second is to create a method naming exactly the same as class name.
    For example if your class name is `Emailer`, the name of the constructor method
    will be `Emailer()`. Let''s take a look at the following class which calculates
    the factorial of any number:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面讨论了构造方法。构造方法是在创建类的实例时自动执行的方法。在PHP5中，你可以在类内部以两种方式编写构造方法。第一种是在类内部创建一个名为`__construct()`的方法。第二种是创建一个与类名完全相同名称的方法。例如，如果你的类名是`Emailer`，构造方法的名称将是`Emailer()`。让我们看看以下这个计算任何数字阶乘的类：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the code above, we used `__construct()` as our constructor function. The
    behaviour will be same if you rename the `__construct()` function as `factorial()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了`__construct()`作为我们的构造函数。如果你将`__construct()`函数重命名为`factorial()`，行为将是相同的。
- en: Now, you may ask if a class can have constructors in both styles? This means
    a function named `__construct()` and a function named the same as class name.
    So which constructor will execute, or will they both execute? This is a good question.
    Actually there is no chance of executing both. If there is a constructor in both
    styles, PHP5 will give preference to the `__construct()` function and the other
    one will be ignored. Let's take a look using the following example
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道一个类是否可以同时以两种风格拥有构造方法？这意味着一个名为`__construct()`的函数和一个与类名相同的函数。那么哪个构造方法会执行，或者它们都会执行吗？这是一个好问题。实际上，没有机会同时执行。如果有两种风格的构造方法，PHP5将优先选择`__construct()`函数，另一个将被忽略。让我们通过以下示例来看看：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if you use this class as shown below:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你像下面这样使用这个类：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will find that the output is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现输出是：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to the constructor method, there is a **destructor** method which actually
    works upon destroying an object. You can explicitly create a destructor method
    by naming it `__destruct()`. This method will be invoked automatically by PHP
    at the end of the execution of your script. To test this, let''s add the following
    code in our factorial class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造方法类似，还有一个**析构**方法，它实际上是在销毁对象时工作的。你可以通过将其命名为`__destruct()`来显式创建析构方法。这个方法将在你的脚本执行结束时由PHP自动调用。为了测试这一点，让我们在我们的阶乘类中添加以下代码：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now execute the usage script again, you will see the following output this
    time:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次执行使用脚本，这次你会看到以下输出：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Class Constants
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类常量
- en: 'Hopefully, you will already know that you can create constants in your PHP
    scripts using the **define** keyword to define (constant name, constant value).
    But to create constants in the class you have to use the `const` keyword. These
    constants actually work like static variables, the only difference is that they
    are read-only. Let''s see how we can create constants and use them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经知道，你可以使用**define**关键字在你的PHP脚本中创建常量。但要在类中创建常量，你必须使用`const`关键字。这些常量实际上就像静态变量一样工作，唯一的区别是它们是只读的。让我们看看我们如何创建常量并使用它们：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This `WordCounter` class counts the frequency of words in any given file. Here
    we define two constant names `ASC` and `DESC` whose values are 1 and 2 respectively.
    To access these constants from within the class, we reference them with the `self`
    keyword. Please note that we are accessing them with the `::` operator, not a
    `->` operator, because these constants act like a static member.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `WordCounter` 类可以计算任何给定文件中单词的频率。这里我们定义了两个常量名称 `ASC` 和 `DESC`，它们的值分别是 1 和
    2。要访问类内的这些常量，我们使用 `self` 关键字来引用它们。请注意，我们使用 `::` 操作符来访问它们，而不是 `->` 操作符，因为这些常量就像静态成员一样。
- en: 'Finally to use this class, let''s create a snippet as shown below. In this
    snippet we are also accessing those constants:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用这个类，让我们创建一个如下所示的片段。在这个片段中，我们也在访问那些常量：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please note that we are accessing the class constants from outside the class
    by following the `::` operator right after the class name, not after the instance
    of the class. Now let''s test the script, please create a file named `words.txt`
    with the following content in the same directory where you placed the above script:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过在类名后直接跟随 `::` 操作符来从类外部访问类常量，而不是在类的实例之后。现在让我们测试脚本，请创建一个名为 `words.txt`
    的文件，其内容如下，并将其放在放置上述脚本的同一目录中：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if you execute the usage script, this time, you will see the following
    output.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你执行使用脚本，这次，你会看到以下输出。
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Nice utility, what do you think?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的实用工具，您觉得呢？
- en: Extending a Class [Inheritance]
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类 [继承]
- en: One of the greatest features in OOP is that you can extend a class and create
    a completely new object. The new object can retain all the functionality of the
    parent object from which it is extended or can override. The new object can also
    introduce some features. Let's extend our `Emailer` class and override the `sendEmail`
    function so that it can send HTML mails.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中最伟大的特性之一是你可以扩展一个类并创建一个全新的对象。新的对象可以保留从其扩展的父对象的所有功能，或者可以覆盖。新的对象也可以引入一些特性。让我们扩展我们的
    `Emailer` 类并覆盖 `sendEmail` 函数，以便它可以发送 HTML 邮件。
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As this class extends the `Emailer` class and introduces a new function, `sendHTMLEmail()`,
    you can still have all the methods from its parent. That means the following code
    is fully valid:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类扩展了 `Emailer` 类并引入了一个新函数 `sendHTMLEmail()`，你仍然可以拥有其父类中的所有方法。这意味着以下代码是完全有效的：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want to access any method of the parent class (or you may say superclass)
    from which it is derived, you can call using the `parent` keyword. For example,
    if you want to access a method named `sayHello`, you should write `parent::sayHello();`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要访问从父类（或者你可能称之为超类）继承的任何方法，你可以使用 `parent` 关键字来调用。例如，如果你想访问一个名为 `sayHello`
    的方法，你应该写 `parent::sayHello();`
- en: Please note that we didn't write any function named `sendEmail()` in `HtmlEmailer`
    class, but that method is working from its parent, `Emailer` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在 `HtmlEmailer` 类中编写任何名为 `sendEmail()` 的函数，但该方法是从其父类 `Emailer` 中工作的。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the above example, `HtmlEmailer` is a subclass of `Emailer` class and `Emailer`
    class is a superclass of `HtmlEmailer`. You must remember that if the subclass
    has no constructor in it, the constructor from superclass will be invoked. At
    the time of writing this book, there is no support for multiple inheritances at
    class level. This means you can't extend more than one class at a time. However
    multiple inheritance is supported in interfaces. An interface can extend an arbitrary
    number of other interfaces at a time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`HtmlEmailer` 是 `Emailer` 类的子类，而 `Emailer` 类是 `HtmlEmailer` 的超类。你必须记住，如果子类中没有构造函数，将调用超类的构造函数。在撰写本书时，类级别上没有多重继承的支持。这意味着你一次不能扩展多个类。然而，接口支持多重继承。一个接口可以一次扩展任意数量的其他接口。
- en: Overriding Methods
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖方法
- en: In an extended object you can override any method (either declared as protected
    or public) and perform anything as you wish. So how can you override any method?
    Simply create a function with the same name that you want to override. For example,
    if you create a function name `sendEmail` in `HtmlEmailer` class, it will override
    the `sendEmail()` method of its parent, `Emailer` class. If you declare any variable
    in subclass which is also available in superclass, then when you access that variable,
    the one from subclass will be accessed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展对象中，您可以覆盖任何方法（无论是声明为 `protected` 还是 `public`），并按您的意愿执行任何操作。那么您如何覆盖任何方法呢？只需创建一个与您想要覆盖的名称相同的函数即可。例如，如果您在
    `HtmlEmailer` 类中创建一个名为 `sendEmail` 的函数，它将覆盖其父类 `Emailer` 中的 `sendEmail()` 方法。如果您在子类中声明任何在超类中也存在的变量，那么当您访问该变量时，将访问子类中的变量。
- en: Preventing from Overriding
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止覆盖
- en: 'If you declare any method as a `final` method, it can''t be overridden in any
    of its subclass. So if you don''t want someone to override your class methods,
    declare it as final. Let''s take a look at the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将任何方法声明为 `final` 方法，它就不能在其任何子类中被覆盖。所以如果您不希望有人覆盖您的类方法，请将其声明为 `final`。让我们看看以下示例：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you execute the above code, it will generate a fatal error because class
    `SubClass` tried to override a method in `SuperClass` which was declared as `final`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行上述代码，它将生成一个致命错误，因为类 `SubClass` 尝试覆盖 `SuperClass` 中声明为 `final` 的方法。
- en: Preventing from Extending
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止扩展
- en: Similar to a final method, you can declare a class as final, which will prevent
    anyone from extending it. So if you declare any class, as shown in following example,
    it is no more extensible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与最终方法类似，您可以将一个类声明为 `final`，这将阻止任何人扩展它。所以如果您声明任何类，如以下示例所示，它就不再可扩展了。
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you execute the code above, it will trigger the following error:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行上面的代码，它将触发以下错误：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Polymorphism
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: As we explained before, polymorphism is the process of creating several objects
    from specific base classes. For example, take a look at the following case in
    point. We need the three classes that we created earlier in this chapter, `Emailer`,
    `ExtendedEmailer` and `HtmlEmailer`. Let's take a look at the following code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，多态是从特定的基类创建多个对象的过程。例如，看看以下案例。我们需要本章中创建的三个类，`Emailer`、`ExtendedEmailer`
    和 `HtmlEmailer`。让我们看看以下代码。
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you execute the script above, you will find the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行上面的脚本，您将找到以下输出：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is an example of polymorphism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多态的例子。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can always check if a class is derived from another class by using the `instanceof`
    operator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `instanceof` 操作符始终检查一个类是否从另一个类派生。
- en: Interface
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interface is an empty class which contains only the declaration of methods.
    So any class which implements this interface must contain the declared functions
    in it. So, interface is nothing but a strict ruling, which helps to extend any
    class and strictly implement all methods defined in interface. A class can use
    any interface by using the `implements` keyword. Please note that in interface
    you can only declare methods, but you cannot write their body. That means the
    body of all methods must remain blank.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一个只包含方法声明的空类。所以任何实现这个接口的类都必须包含这些声明函数。所以，接口不过是一种严格的规则，它有助于扩展任何类并严格实现接口中定义的所有方法。一个类可以通过使用
    `implements` 关键字使用任何接口。请注意，在接口中您只能声明方法，但不能编写它们的主体。这意味着所有方法的主体都必须保持空白。
- en: So why is an interface necessary, you might ask? One of the reasons is it implies
    strict rules while creating a class. For example, we know that we need to create
    some driver classes in our application, which can handle DB operations. For MySQL,
    there will be one class, for PostgreSQL there will be another, For SQLite, another
    one and so forth. Now your developer team has three developers, who will separately
    create these three classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么接口是必要的呢？其中一个原因是它在创建类时隐含了严格的规则。例如，我们知道我们需要在我们的应用程序中创建一些处理数据库操作的驱动类。对于 MySQL，将有一个类，对于
    PostgreSQL 将会有另一个，对于 SQLite，又会有另一个，以此类推。现在您的开发团队有三个开发者，他们将分别创建这三个类。
- en: 'Now how will it be if each of them implements their own style in their own
    classes? The developers who are going to use those driver classes will have to
    check how they define their methods and following that, the way they have to write
    their code, which is too boring and hard to maintain. So if you define that, all
    driver class must have two methods named `connect()` and `execute()`. Now developers
    need not worry while changing the driver, because they know that all these classes
    have the same method definition. Interface helps in this scenario. Let''s create
    the interface here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果每个驱动程序都在自己的类中实现自己的风格会怎样呢？将要使用这些驱动程序类的开发者将不得不检查它们如何定义它们的方法，然后根据这些方法编写它们的代码，这既无聊又难以维护。所以如果你定义了，所有驱动程序类都必须有两个名为
    `connect()` 和 `execute()` 的方法。现在开发者不需要担心在更改驱动程序时，因为他们知道所有这些类都有相同的方法定义。接口有助于这种情况。让我们在这里创建接口：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Did you notice that the functions are empty in an interface? Now let''s create
    our `MySQLDriver` class, which implements this interface:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到接口中的函数是空的吗？现在让我们创建我们的 `MySQLDriver` 类，它实现了这个接口：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now if you execute the code above, it will give the following error because
    `MySQLDriver` class has no `connect()` and `execute()` function as defined in
    the interface. Let''s run the code and read the error:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你执行上面的代码，它将给出以下错误，因为 `MySQLDriver` 类没有接口中定义的 `connect()` 和 `execute()` 函数。让我们运行代码并读取错误：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Well, now we have to add those two methods in our `MySQLDriver` class. Let''s
    see the code below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们得在我们的 `MySQLDriver` 类中添加这两种方法。让我们看看下面的代码：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we run the code now, we get the following error message again:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行代码，我们再次得到以下错误信息：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The error message is saying that our `execute()` method is not compatible with
    the `execute()` method structure that was defined in the interface. If you now
    take a look at the interface, you will find that `execute()` method should have
    one argument. So that means whenever we implement an interface in our class, every
    method structure must exactly be the same as defined in the interface. Let''s
    rewrite our `MySQLDriver` class as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息表明我们的 `execute()` 方法与接口中定义的 `execute()` 方法结构不兼容。如果你现在查看接口，你会发现 `execute()`
    方法应该有一个参数。这意味着每次我们在类中实现接口时，每个方法结构都必须与接口中定义的完全相同。让我们按照以下方式重写我们的 `MySQLDriver` 类：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Abstract Class
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'An abstract class is almost the same as interface, except that now the methods
    can contain body. An abstract class must also be "extended", not "implemented".
    So if the extended classes have some methods with common functionalities, then
    you can define those functions in an abstract class. Let''s see the example below:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类几乎与接口相同，但现在方法可以包含主体。抽象类也必须被“扩展”，而不是“实现”。所以如果扩展的类有一些具有共同功能的方法，那么你可以在抽象类中定义这些函数。让我们看看下面的示例：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our abstract class we have a method named `generateReport`, which takes a
    multidimensional array as argument and then generates an HTML report using it.
    Now, why did we put this method in an abstract class? Because generating a report
    will be a common function to all DB Drivers and it doesn't affect the code because
    it is taking only one array as an argument, not anything relevant to DB itself.
    Now we can use this abstract class in our `MySQLDriver` class as shown below.
    Please note that all the code to generate the report is already written, so we
    need not write code for that method in our driver class again as we did for interfaces.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的抽象类中有一个名为 `generateReport` 的方法，它接受一个多维数组作为参数，然后使用它生成一个 HTML 报告。现在，为什么我们要在这个抽象类中放置这个方法呢？因为生成报告将是所有数据库驱动程序的一个通用功能，它不会影响代码，因为它只接受一个数组作为参数，而不是与数据库本身相关的任何内容。现在我们可以在下面的
    `MySQLDriver` 类中使用这个抽象类。请注意，生成报告的所有代码已经编写好了，所以我们不需要在我们的驱动程序类中再次为该方法编写代码，就像我们为接口所做的那样。
- en: '[PRE37]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note that we can use the abstract class and implement an interface concurrently
    as shown in the above example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们可以在上面的示例中同时使用抽象类和实现接口。 '
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot declare an abstract class as final, because abstract class means
    it has to be extended and final class means it can't be extended. So it's totally
    meaningless to use these two keywords together. PHP won't allow you to use them
    together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能声明一个抽象类为 `final`，因为抽象类意味着它必须被扩展，而 `final` 类意味着它不能被扩展。所以这两个关键字一起使用是完全没有意义的。PHP
    不会允许你这样使用它们。
- en: 'Similar to declaring a class as abstract, you can also declare any method as
    abstract. When a method is declared as abstract, it means that the subclass must
    override that method. An abstract method should not contain any body where it
    is defined. An abstract method can be declared as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明抽象类类似，你也可以声明任何方法为抽象方法。当一个方法被声明为抽象方法时，这意味着子类必须重写该方法。抽象方法在其定义的地方不应该包含任何方法体。抽象方法可以像下面这样声明：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Static Method and Properties
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法和属性
- en: A `static` keyword is very important in object oriented programming. Static
    methods and properties play a vital role in application design and also in design
    patterns. So what are static methods and properties?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，`static` 关键字非常重要。静态方法和属性在应用程序设计和设计模式中起着至关重要的作用。那么静态方法和属性是什么呢？
- en: You have already seen that to access any method or attribute in a class you
    must create an instance (i.e. using `new` keyword, like `$object` `=` `new` `emailer()`),
    otherwise you can't access them. But there is a difference for static methods
    and properties. You can access a static method or property directly without creating
    any instance of that class. A static member is like a global member for that class
    and all instances of that class. Also, static properties persist the last state
    of what it was assigned, which is very useful in some cases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，要访问类中的任何方法或属性，你必须创建一个实例（即使用 `new` 关键字，如 `$object` `=` `new` `emailer()`），否则你不能访问它们。但是静态方法和属性有所不同。你可以直接访问静态方法或属性，而无需创建该类的任何实例。静态成员就像该类的全局成员，以及该类的所有实例。此外，静态属性会持久化其被分配的最后状态，这在某些情况下非常有用。
- en: You might ask why someone uses a static method. Well, most of the static methods
    are similar to utility methods. They perform a very specific task, or return a
    specific object (static properties and methods are used significantly in design
    patterns, we will learn that later). So declaring a new object every time for
    those works might be considered resource extensive. Let's see an example of static
    methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么有人使用静态方法。嗯，大多数静态方法类似于实用方法。它们执行一个非常特定的任务，或者返回一个特定的对象（静态属性和方法在设计中使用得非常广泛，我们将在以后学习）。所以为这些工作每次都声明一个新的对象可能被认为是资源密集型的。让我们看看静态方法的例子。
- en: Consider that in our application we keep support for all three databases, MySQL,
    PostgreSQL, and SQLite. Now we need to use one particular driver at a time. For
    that, we are designing a `DBManager` class, which can instantiate any driver on
    demand and return that to us.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在我们的应用程序中我们支持所有三种数据库，MySQL、PostgreSQL 和 SQLite。现在我们需要一次使用一个特定的驱动程序。为此，我们正在设计一个
    `DBManager` 类，它可以根据需要实例化任何驱动程序并将其返回给我们。
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'How do we use this class? You can access any static property using a `::` operator
    and not using the `->` operator. Let''s see the example below:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个类？你可以使用 `::` 操作符而不是 `->` 操作符来访问任何静态属性。让我们看看下面的例子：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that we didn't create any instance of `DBManager` object like `$dbmanager`
    `=` `new` `DBManager()`. Rather we directly access one of its methods using the
    `::` operator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们没有创建任何 `DBManager` 对象的实例，比如 `$dbmanager` `=` `new` `DBManager()`。相反，我们直接使用
    `::` 操作符访问其方法之一。
- en: So how does this benefit us? Well, we just need a driver object, so no need
    to create a new `DBManager` object and commit it to memory as long as our scripts
    are executing. Static methods usually perform a specific task and finish it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来什么好处呢？嗯，我们只需要一个驱动程序对象，所以不需要创建一个新的 `DBManager` 对象并将其提交到内存中，只要我们的脚本在执行。静态方法通常执行一个特定的任务并完成它。
- en: Here are some important things to note. You can't use `$this` pseudo object
    inside a static method. As the class is not instantiated, `$this` doesn't exist
    inside a static method. You should rather use the `self` keyword.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的重要事项。在静态方法内部不能使用 `$this` 伪对象。因为类没有被实例化，所以 `$this` 在静态方法内部不存在。你最好使用
    `self` 关键字。
- en: 'Let''s take a look at the following example. It shows how a static property
    actually works:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的例子。它展示了静态属性实际上是如何工作的：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will see the output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到输出如下：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whenever we create a new instance, it affects all the instances as the variable
    is declared as static. Using this special facility, a special design pattern "Singleton"
    works perfectly in PHP.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个新的实例时，它都会影响所有实例，因为变量被声明为静态。使用这个特殊功能，一个特殊的设计模式“单例”在 PHP 中可以完美工作。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Caution: Using Static Members**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：使用静态成员**'
- en: Static members make object oriented much like old procedural programming; without
    creating instances, you can directly call any function, like the old days. That's
    why we use static method with caution. Excessive static methods make no use at
    all. Unless you have any specific purpose, don't use static members.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员使面向对象编程与旧的过程式编程非常相似；不创建实例，你可以直接调用任何函数，就像过去一样。这就是为什么我们谨慎地使用静态方法。过多的静态方法毫无用处。除非你有任何特定的目的，否则不要使用静态成员。
- en: Accessor Methods
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器方法
- en: Accessor methods are simply methods that are solely devoted to get and set the
    value of any class properties. It's a good practice to access class properties
    using accessor methods instead of directly setting or getting their value. Though
    accessor methods are the same as other methods, there are some conventions writing
    them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器方法只是专门用于获取和设置任何类属性值的简单方法。使用访问器方法而不是直接设置或获取它们的值来访问类属性是一种良好的实践。尽管访问器方法与其他方法相同，但在编写它们时有一些约定。
- en: 'There are two types of accessor methods. One is called `getter`, whose purpose
    is returning value of any class property. The other is setter that sets a value
    into a class property. Let''s see how to write the `getter` and `setter` methods
    for class properties:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器方法有两种类型。一种被称为`getter`，其目的是返回任何类的属性值。另一种是`setter`，它将值设置到类的属性中。让我们看看如何为类属性编写`getter`和`setter`方法：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the above example there are two `getter` methods and two `setter` methods.
    There is a convention in writing `accessor` methods. A `setter` method should
    start with `set` and the property name with the first character capitalized. A
    `getter` method should start with `get` followed by the variable name with the
    first letter capitalized. That means if we have a property named `email`, the
    getter method should be named as `getEmail` and the setter method should be named
    as `setEmail`. That's it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，有两个`getter`方法和两个`setter`方法。在编写`accessor`方法时有一个约定。`setter`方法应该以`set`开头，属性名以第一个字母大写。`getter`方法应该以`get`开头，然后是变量名，第一个字母大写。这意味着如果我们有一个名为`email`的属性，则`getter`方法应该命名为`getEmail`，而`setter`方法应该命名为`setEmail`。就是这样。
- en: So you might ask why someone does these extra jobs, when they can easily set
    these variables as public and leave everything else as is. Aren't all these the
    same? Well, no. Using accessor methods, you get some extra benefits. You will
    have full control while setting or retrieving the value of any property. "So what?"
    You might ask. Let's use a scenario where you need to filter users' input and
    set into properties. In this case, a `setter` can help you to filter the input
    before setting them into work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么有人要做这些额外的工作，当他们可以轻松地将这些变量设置为公共的，并且让其他一切都保持原样。难道这些不都是一样的吗？嗯，不是的。使用访问器方法，你将获得一些额外的好处。在设置或检索任何属性的值时，你将拥有完全的控制权。“那又怎样？”你可能会问。让我们用一个场景来说明，你需要过滤用户的输入并将其设置到属性中。在这种情况下，一个`setter`可以帮助你在将它们设置到工作状态之前过滤输入。
- en: Does this mean we have to write 100 `getter` and `setter` methods if my class
    contains 100 properties? You ask as good question. PHP is kind enough to relieve
    you from this boredom. How? Let us see the next section where we discuss using
    magic methods for setting and getting property values dynamically. Those methods
    will reduce the stress up to 90%. Don't you believe me? Let's see.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着如果我们类中有100个属性，我们就必须编写100个`getter`和`setter`方法？你提出了一个好问题。PHP足够仁慈，可以让你摆脱这种无聊。如何？让我们看看下一节，我们将讨论使用魔法方法动态设置和获取属性值。这些方法可以将压力减少到90%。你不相信我吗？让我们看看。
- en: Using Magic Methods to Set/Get Class Properties
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用魔法方法设置/获取类属性
- en: We discussed in the previous section that writing accessor method for a number
    of properties will be a real nightmare. To avoid that boredom, you can use magic
    methods. This process is called property overloading.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了为许多属性编写访问器方法将是一场真正的噩梦。为了避免这种无聊，你可以使用魔法方法。这个过程被称为属性重载。
- en: 'PHP5 introduced some magic methods in classes to reduce the pain of OOP in
    some cases. Two of those magic methods are introduced to set and get dynamic property
    values in a class. These two magic methods are named as `__get()` and `__set()`.
    Let us see how to use them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5在类中引入了一些魔法方法，以减少在某些情况下面向对象编程的痛苦。其中两种魔法方法被引入以在类中设置和获取动态属性值。这两个魔法方法分别命名为`__get()`和`__set()`。让我们看看如何使用它们：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let us see the code in action. Use the class above with the following script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码的实际应用。使用上面的类，使用以下脚本：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When you execute the preceding code, PHP recognizes immediately that no property
    named `name` or `roll` exists in the class. Since the named property doesn''t
    exist, the `__set()` method is called, which then assigns the value to the newly-created
    property of the class, allowing you to see the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行前面的代码时，PHP会立即识别出在类中不存在名为`name`或`roll`的属性。由于没有命名属性存在，`__set()`方法被调用，然后它将值分配给类的新创建的属性，这样你就能看到以下输出：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Seems quite interesting, huh? Using magic methods you still have full control
    over setting and retrieving property values in classes. However, you have one
    limitation if you use magic methods. While using reflection API, you can't investigate
    class properties (we will discuss about reflection API in a later chapter). Moreover,
    your class lost the "readability" and "maintainability" quite a lot. Why? See
    the code of previous `Student` class and new `Student` class and you will understand
    that for yourself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很有趣，不是吗？使用魔法方法，你仍然可以完全控制类中设置和检索属性值。然而，如果你使用魔法方法，你有一个限制。当使用反射API时，你无法调查类属性（我们将在后面的章节中讨论反射API）。此外，你的类在“可读性”和“可维护性”方面损失了很多。为什么？请看之前`Student`类和新`Student`类的代码，你就会自己理解。
- en: Magic Methods for Overloading Class Methods
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于重载类方法的魔法方法
- en: Like overloading, and using the accessor methods, there are magic methods to
    overload any method call in a class. If you are still not familiar with method
    overloading, then this is a process of accessing any method that doesn't even
    exist in the class. Sounds funny, right? Let's take a closer look.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与重载和访问器方法一样，还有魔法方法可以重载类中的任何方法调用。如果你还不熟悉方法重载，那么这是一个访问任何甚至不存在于类中的方法的进程。听起来很有趣，对吧？让我们更仔细地看看。
- en: 'There is a magic method, which helps to overload any method call in PHP5 class
    context. The name of that magic method is `__call()`. This allows you to provide
    actions or return values when undefined methods are called on an object. It can
    be used to simulate method overloading, or even to provide smooth error handling
    when an undefined method is called on an object. `__call` takes two arguments:
    the name of the method and an array of the arguments passed to the undefined method.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个魔法方法，它有助于在PHP5类上下文中重载任何方法调用。这个魔法方法的名称是`__call()`。这允许你在对象上调用未定义的方法时提供操作或返回值。它可以用来模拟方法重载，甚至在对象上调用未定义方法时提供平滑的错误处理。`__call`接受两个参数：方法的名称和传递给未定义方法的参数数组。
- en: 'For example see the code below:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请看下面的代码：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you see the code above, then you will see that there is no method called
    `access` and `notAnyMethod`. So therefore, it should raise an error, right? However,
    the method overloader still helps you to call any non existing method. If you
    execute the code above, you will get the following output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到上面的代码，那么你会看到没有名为`access`和`notAnyMethod`的方法。所以因此，它应该引发错误，对吧？然而，方法重载器仍然可以帮助你调用任何不存在的方法。如果你执行上面的代码，你会得到以下输出。
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That means you will get all arguments as an array. There are many more magic
    methods, which you will learn step-by-step in this book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将作为一个数组获取所有参数。这本书中你将逐步学习到更多魔法方法。
- en: Visually Representing a Class
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以视觉方式表示类
- en: In OOP, sometimes you have to visually represent your class. Let's learn how
    to visually represent a class. For this, we will use our `Emailer` class this
    time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，有时你必须以视觉方式表示你的类。让我们学习如何以视觉方式表示一个类。为此，我们这次将使用我们的`Emailer`类。
- en: '![Visually Representing a Class](img/2561_01_01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![以视觉方式表示类](img/2561_01_01.jpg)'
- en: In this graphical representation, there are three sections. At the top most
    section a class name should be written. In the second section all methods with
    or without parameters are written. And in the third box all the properties are
    written. That's it!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图形表示中，有三个部分。在最上面的部分应该写上类名。在第二部分写上所有带参数或不带参数的方法。在第三部分写上所有属性。就是这样！
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have learned how to create objects and interact between them.
    PHP5 brings amazing improvements in object models when compared to PHP4\. Zend
    Engine 2, which is at the core of PHP5, is also very efficient in handling these
    features with great performance optimization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建对象以及它们之间的交互。与PHP4相比，PHP5在对象模型方面带来了惊人的改进。作为PHP5核心的Zend Engine 2，在处理这些特性时也非常高效，具有出色的性能优化。
- en: In the next chapter we will go through more details and the core features of
    OOP in PHP. But before starting next chapter, please practice everything discussed
    here, otherwise you may get confused in some topics. Practice them as much as
    you can, try to refactor all your previous code in OOP. The more you practice,
    the more efficient you become.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解 PHP 中面向对象编程（OOP）的更多细节和核心特性。但在开始下一章之前，请务必练习这里讨论的所有内容，否则你可能会在某些主题上感到困惑。尽可能多地练习，尝试重构你之前所有的面向对象代码。你练习得越多，效率就越高。
