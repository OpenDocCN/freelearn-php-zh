- en: Hexagonal Architecture with PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP的六边形架构
- en: The following article was posted in php|architect magazine in June 2014 by Carlos
    Buenosvinos.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章由Carlos Buenosvinos于2014年6月发布在php|architect杂志上。
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With the rise of **Domain-Driven Design** (**DDD**), architectures promoting
    domain centric designs are becoming more popular. This is the case with **Hexagonal
    Architecture**, also known as **Ports and Adapters**, that seems to have being
    rediscovered just now by PHP developers. Invented in 2005 by Alistair Cockburn,
    one of the Agile Manifesto authors, the Hexagonal Architecture allows an application
    to be equally driven by users, programs, automated tests or batch scripts, and
    to be developed and tested in isolation from its eventual run-time devices and
    databases. This results into agnostic infrastructure web applications that are
    easier to test, write and maintain. Let's see how to apply it using real PHP examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着领域驱动设计（**DDD**）的兴起，促进以领域为中心设计的架构变得越来越流行。这就是六边形架构（也称为**端口和适配器**）的情况，它似乎刚刚被PHP开发者重新发现。由敏捷宣言的作者之一Alistair
    Cockburn于2005年发明，六边形架构允许应用程序由用户、程序、自动化测试或批处理脚本同等驱动，并且可以在与最终运行时设备和数据库隔离的情况下开发和测试。这导致出现无依赖的基础设施Web应用程序，这些应用程序更容易测试、编写和维护。让我们看看如何使用真实的PHP示例来应用它。
- en: Your company is building a brainstorming system called *Idy*. Users add and
    rate ideas so the most interesting ones can be implemented in a company. It is
    Monday morning, another sprint is starting and you are reviewing some user stories
    with your team and your Product Owner. **As a not logged in user, I want to rate
    an idea and the author should be notified by email**, that's a really important
    one, isn't it?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您的公司正在构建一个名为*Idy*的头脑风暴系统。用户添加和评分想法，以便最有趣的想法可以在公司中实施。这是周一早晨，另一个冲刺即将开始，您正在与您的团队和产品负责人审查一些用户故事。**作为一个未登录的用户，我想对想法进行评分，并且作者应该通过电子邮件通知**，这是一个非常重要的用例，不是吗？
- en: First Approach
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一种方法
- en: As a good developer, you decide to divide and conquer the user story, so you'll
    start with the first part, *I want to rate an idea*. After that, you will face
    *the author should be notified by email*. That sounds like a plan.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名优秀的开发者，您决定分而治之用户故事，所以您将从第一部分开始，*我想对想法进行评分*。之后，您将面临*作者应该通过电子邮件通知*。这听起来像是个计划。
- en: In terms of business rules, rating an idea is as easy as finding the idea by
    its identifier in the ideas repository, where all the ideas live, add the rating,
    recalculate the average and save the idea back. If the idea does not exist or
    the repository is not available we should throw an exception so we can show an
    error message, redirect the user or do whatever the business asks us for.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务规则方面，对想法进行评分就像在想法存储库中通过标识符找到想法一样简单，所有想法都存储在那里，添加评分，重新计算平均值，并将想法保存回存储库。如果想法不存在或存储库不可用，我们应该抛出异常，以便我们可以显示错误消息，重定向用户或执行业务要求我们做的任何事情。
- en: In order to *execute* this *UseCase*, we just need the idea identifier and the
    rating from the user. Two integers that would come from the user request.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了*执行*这个*用例*，我们只需要用户的想法标识符和评分。这两个整数将来自用户请求。
- en: Your company web application is dealing with a Zend Framework 1 legacy application.
    As most of companies, probably some parts of your app may be newer, more SOLID,
    and others may just be a big ball of mud. However, you know that it does not matter
    at all which framework you are using, it is all about writing clean code that
    makes maintenance a low cost task for your company.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您的公司网络应用程序正在处理一个Zend Framework 1遗留应用程序。像大多数公司一样，您的应用程序可能某些部分较新，更符合SOLID原则，而其他部分可能只是一团糟。然而，您知道您使用的框架并不重要，关键是编写干净的代码，使维护成为公司低成本的作业。
- en: You're trying to apply some Agile principles you remember from your last conference,
    how it was, yeah, I remember "make it work, make it right, make it fast". After
    some time working you get something like Listing 1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您试图应用您在上次会议中记得的一些敏捷原则，是的，我记得“先让它工作，再让它正确，最后让它快速”。经过一段时间的工作，您得到了类似于列表1的内容。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I know what readers are thinking: *Who is going to access data directly from
    the controller? This is a 90''s example!*, ok, ok, you''re right. If you are already
    using a framework, it is likely that you are also using an ORM. Maybe done by
    yourself or any of the existing ones such as Doctrine, Eloquent, Zend, and so
    on. If this is the case, you are one step further from those who have some Database
    connection object but don''t count your chickens before they''re hatched.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道读者在想什么：*谁会直接从控制器访问数据？这是一个90年代的做法！* 好吧，好吧，你说得对。如果你已经在使用框架，那么你很可能也在使用ORM。可能是你自己做的，或者是现有的任何一个，比如Doctrine、Eloquent、Zend等等。如果是这种情况，你比那些只有一些数据库连接对象但没有实际操作的人更进一步。但在孵化之前不要过早地计算你的小鸡。
- en: For newbies, Listing 1 code just works. However, if you take a closer look at
    the Controller, you'll see more than business rules, you'll also see how your
    web framework routes a request into your business rules, references to the database
    or how to connect to it. So close, you see references to your **infrastructure**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手来说，列表1的代码可以正常工作。然而，如果你仔细看看控制器，你会发现不仅仅是业务规则，你还会看到你的Web框架如何将请求路由到业务规则，对数据库的引用或如何连接到它。非常接近，你看到了对你的
    **基础设施** 的引用。
- en: Infrastructure is the **detail that makes your business rules work**. Obviously,
    we need some way to get to them (API, web, console apps, and so on.) and effectively
    we need some physical place to store our ideas (memory, database, NoSQL, and so
    on.). However, we should be able to exchange any of these pieces with another
    that behaves in the same way but with different implementations. What about starting
    with the Database access?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施是使你的业务规则生效的 **细节**。显然，我们需要某种方式来访问它们（API、Web、控制台应用程序等等），并且实际上我们需要一个物理位置来存储我们的想法（内存、数据库、NoSQL等等）。然而，我们应该能够用另一个以相同方式但具有不同实现的行为的组件来交换这些组件。那么从数据库访问开始怎么样？
- en: All those `Zend_DB_Adapter` connections (or straight MySQL commands if that's
    your case) are asking to be promoted to some sort of object that encapsulates
    fetching and persisting Idea objects. They are begging for being a Repository.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那些 `Zend_DB_Adapter` 连接（或者如果你是直接使用MySQL命令，那么就是直接MySQL命令）都在请求提升为某种封装了获取和持久化想法对象的对象。它们在恳求成为仓库。
- en: Repositories and the Persistence Edge
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库和持久化优势
- en: 'Whether there is a change in the business rules or in the infrastructure, we
    must edit the same piece of code. Believe me, in CS, you don''t want many people
    touching the same piece of code for different reasons. Try to make your functions
    do one and just one thing so it is less probable having people messing around
    with the same piece of code. You can learn more about this by having a look at
    the **Single Responsibility Principle** (**SRP**). For more information about
    this principle: [http://www.objectmentor.com/resources/articles/srp.pdf](http://www.objectmentor.com/resources/articles/srp.pdf)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论业务规则还是基础设施是否有变化，我们都必须编辑相同的代码。相信我，在计算机科学中，你不想让很多人出于不同的原因触摸相同的代码。尽量让你的函数只做一件事，这样人们就不太可能对相同的代码进行干扰。你可以通过查看
    **单一职责原则**（**SRP**）来了解更多关于这一点。有关此原则的更多信息：[http://www.objectmentor.com/resources/articles/srp.pdf](http://www.objectmentor.com/resources/articles/srp.pdf)
- en: Listing 1 is clearly this case. If we want to move to Redis or add the author
    notification feature, you'll have to update the `rateAction` method. Chances to
    affect aspects of the `rateAction` not related with the one updating are high.
    Listing 1 code is fragile. If it is common in your team to hear *If it works,
    don't touch it*, SRP is missing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1明显是这种情况。如果我们想迁移到Redis或添加作者通知功能，你将不得不更新 `rateAction` 方法。影响与更新无关的 `rateAction`
    方面的可能性很高。列表1的代码很脆弱。如果你的团队中经常听到 *如果它工作，就不要动它*，那么就缺少了SRP。
- en: 'So, we must decouple our code and encapsulate the responsibility for dealing
    with fetching and persisting ideas into another object. The best way, as explained
    before, is using a Repository. Challenged accepted! Let''s see the results in
    Listing 2:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须解耦我们的代码，并将处理获取和持久化想法的责任封装到另一个对象中。正如之前解释的，最好的方式是使用仓库。挑战接受！让我们看看列表2中的结果：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is nicer. The `rateAction` of the `IdeaController` is more understandable.
    When read, it talks about business rules. `IdeaRepository` is a **business concept**.
    When talking with business guys, they understand what an `IdeaRepository` is:
    A place where I put Ideas and get them.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结果更令人满意。`IdeaController` 的 `rateAction` 方法更易于理解。当阅读时，它讨论的是业务规则。`IdeaRepository`
    是一个 **业务概念**。当与业务人员交谈时，他们理解 `IdeaRepository` 是什么：一个存放想法并获取它们的地方。
- en: A Repository *mediates between the domain and data mapping layers using a collection-like
    interface for accessing domain objects*. as found in Martin Fowler's pattern catalog.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库*通过使用类似集合的接口来访问领域对象，在领域和数据映射层之间进行调解*，正如在马丁·福勒的模式目录中找到的那样。
- en: If you are already using an ORM such as Doctrine, your current repositories
    extend from an `EntityRepository`. If you need to get one of those repositories,
    you ask Doctrine `EntityManager` to do the job. The resulting code would be almost
    the same, with an extra access to the `EntityManager` in the controller action
    to get the `IdeaRepository`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用了一个如Doctrine的ORM，你的当前存储库是从一个`EntityRepository`扩展出来的。如果你需要获取这些存储库之一，你要求Doctrine的`EntityManager`来完成这项工作。生成的代码几乎相同，只是在控制器动作中额外访问了`EntityManager`以获取`IdeaRepository`。
- en: At this point, we can see in the landscape one of the edges of our hexagon,
    the *persistence* edge. However, this side is not well drawn, there is still some
    relationship between what an `IdeaRepository` is and how it is implemented.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以在六边形的景观中看到其中一条边，即*persistence*边。然而，这一边画得并不好，`IdeaRepository`是什么以及它是如何实现的之间仍然存在一些关系。
- en: In order to make an effective separation between our *application boundary*
    and the *infrastructure boundary* we need an additional step. We need to explicitly
    decouple behavior from implementation using some sort of interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在*应用程序边界*和*基础设施边界*之间进行有效的分离，我们需要额外的步骤。我们需要使用某种形式的接口显式地解耦行为和实现。
- en: Decoupling Business and Persistence
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦业务和持久化
- en: Have you ever experienced the situation when you start talking to your Product
    Owner, Business Analyst or Project Manager about your issues with the Database?
    Can you remember their faces when explaining how to persist and fetch an object?
    They had no idea what you were talking about.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经遇到过这样的情况：当你开始与你的产品负责人、业务分析师或项目经理谈论你的数据库问题时？你能记得他们解释如何持久化和检索对象时的表情吗？他们对你所说的毫无头绪。
- en: The truth is that they don't care, but that's ok. If you decide to store the
    ideas in a MySQL server, Redis or SQLite it is your problem, not theirs. Remember,
    from a business standpoint, **your infrastructure is a detail**. Business rules
    are not going to change whether you use Symfony or Zend Framework, MySQL or PostgreSQL,
    REST or SOAP, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，他们并不关心，但这没关系。如果你决定在MySQL服务器、Redis或SQLite中存储想法，那是你的问题，不是他们的。记住，从业务角度来看，**你的基础设施是一个细节**。业务规则不会因为使用Symfony或Zend
    Framework、MySQL或PostgreSQL、REST或SOAP等而改变。
- en: That's why it is important to decouple our `IdeaRepository` from its implementation.
    The easiest way is to use a proper interface. How can we achieve that? Let's take
    a look at Listing 3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么将我们的`IdeaRepository`与其实现解耦很重要。最简单的方法是使用一个合适的接口。我们如何实现这一点？让我们看看列表3。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Easy, isn't it? We have extracted the `IdeaRepository` behavior into an interface,
    renamed the `IdeaRepository` into `MySQLIdeaRepository` and updated the `rateAction`
    to use our `MySQLIdeaRepository`. But what's the benefit?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？我们已经将`IdeaRepository`的行为提取到一个接口中，将`IdeaRepository`重命名为`MySQLIdeaRepository`，并将`rateAction`更新为使用我们的`MySQLIdeaRepository`。但有什么好处呢？
- en: We can now exchange the repository used in the controller with any implementing
    the same interface. So, let's try a different implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用任何实现相同接口的存储库来替换控制器中使用的存储库。那么，让我们尝试一个不同的实现。
- en: Migrating our Persistence to Redis
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的持久化迁移到Redis
- en: 'During the sprint and after talking to some mates, you realize that using a
    NoSQL strategy could improve the performance of your feature. Redis is one of
    your best friends. Go for it and show me your Listing 4:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在冲刺阶段和与一些伙伴交谈之后，你意识到采用NoSQL策略可以提高你功能的性能。Redis是你的好朋友之一。去做吧，并给我展示你的列表4：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Easy again. You've created a `RedisIdeaRepository` that implements `IdeaRepository`
    interface and we have decided to use Predis as a connection manager. Code looks
    smaller, easier and faster. But what about the controller? It remains the same,
    we have just changed which repository to use, but it was just one line of code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次简单。你已经创建了一个实现`IdeaRepository`接口的`RedisIdeaRepository`，我们决定使用Predis作为连接管理器。代码看起来更小、更简单、更快。但控制器呢？它保持不变，我们只是更改了使用的存储库，但这只是一行代码。
- en: As an exercise for the reader, try to create the `IdeaRepository` for SQLite,
    a file or an in-memory implementation using arrays. Extra points if you think
    about how ORM Repositories fit with Domain Repositories and how ORM *@annotations* affect
    this architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对读者的练习，尝试创建SQLite、文件或使用数组的内存实现`IdeaRepository`。如果你考虑ORM存储库如何与领域存储库相匹配以及ORM
    `@annotations`如何影响这种架构，那么你将获得额外的分数。
- en: Decouple Business and Web Framework
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦业务和Web框架
- en: We have already seen how easy it can be to changing from one persistence strategy
    to another. However, the persistence is not the only edge from our Hexagon. What
    about how the user interacts with the application?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到从一种持久化策略切换到另一种策略是多么容易。然而，持久化并不是我们六边形架构的唯一优势。用户如何与应用程序交互呢？
- en: 'Your CTO has set up in the roadmap that your team is moving to Symfony2, so
    when developing new features in you current ZF1 application, we would like to
    make the incoming migration easier. That''s tricky, show me your Listing 5:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您的CTO在路线图中已经设定，您的团队将迁移到Symfony2，因此当您在当前的ZF1应用程序中开发新功能时，我们希望使即将到来的迁移更加容易。这有点棘手，请展示您的列表5：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's review the changes. Our controller is not having any business rules at
    all. We have pushed all the logic inside a new object called `RateIdeaUseCase`
    that encapsulates it. This object is also known as Controller, Interactor or Application
    Service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下变化。我们的控制器根本没有任何业务规则。我们已经将所有逻辑推入一个名为`RateIdeaUseCase`的新对象中，该对象封装了它。这个对象也被称为控制器、交互器或应用程序服务。
- en: The magic is done by the `execute` method. All the dependencies such as the
    `RedisIdeaRepository` are passed as an argument to the constructor. All the references
    to an `IdeaRepository` inside our UseCase are pointing to the interface instead
    of any concrete implementation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法是由`execute`方法完成的。所有依赖项，如`RedisIdeaRepository`，都作为参数传递给构造函数。我们UseCase内部对`IdeaRepository`的所有引用都指向接口，而不是任何具体实现。
- en: That's really cool. If you take a look inside `RateIdeaUseCase`, there is nothing
    talking about MySQL or Zend Framework. No references, no instances, no annotations,
    nothing. It is like your infrastructure does not mind. It just talks about business
    logic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很酷。如果你看看`RateIdeaUseCase`内部，没有任何关于MySQL或Zend Framework的提及。没有引用，没有实例，没有注解，什么都没有。就像你的基础设施不在乎一样。它只是谈论业务逻辑。
- en: Additionally, we have also tuned the Exceptions we throw. Business processes
    also have exceptions. `NotAvailableRepository` and `IdeaDoesNotExist` are two
    of them. Based on the one being thrown we can react in different ways in the framework
    boundary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还调整了我们抛出的异常。业务流程也有异常。`NotAvailableRepository`和`IdeaDoesNotExist`是其中两个。根据抛出的异常，我们可以在框架边界中采取不同的反应。
- en: 'Sometimes, the number of parameters that a UseCase receives can be too many.
    In order to organize them, it is quite common to build a *UseCase request* using
    a **Data Transfer Object** (**DTO**) to pass them together. Let''s see how you
    could solve this in Listing 6:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个UseCase接收的参数数量可能太多。为了组织它们，使用**数据传输对象**（**DTO**）构建一个*UseCase请求*来一起传递是很常见的。让我们看看如何在列表6中解决这个问题：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The main changes here are introducing two new objects, a Request and a Response.
    They are not mandatory, maybe a UseCase has no request or response. Another important
    detail is how you build this request. In this case, we are building it getting
    the parameters from ZF request object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要变化是引入了两个新对象，一个请求和一个响应。它们不是强制的，也许一个UseCase没有请求或响应。另一个重要细节是如何构建这个请求。在这种情况下，我们是通过从ZF请求对象获取参数来构建它的。
- en: Ok, but wait, what's the real benefit? it is easier to change from one framework
    to other, or execute our UseCase from another *delivery mechanism*. Let's see
    this point.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但等等，真正的益处是什么？从一种框架切换到另一种框架，或者通过另一种*交付机制*执行我们的UseCase，这更容易。让我们看看这个观点。
- en: Rating an Idea Using the API
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API对想法进行评分
- en: 'During the day, your Product Owner comes to you and says: *by the way, a user
    should be able to rate an idea using our mobile app. I think we will need to update
    the API, could you do it for this sprint?*. Here''s the PO again. *No problem!*.
    Business is impressed with your commitment.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在白天，你的产品负责人来到你面前说：“顺便说一句，用户应该能够使用我们的移动应用对想法进行评分。我想我们需要更新API，你能在这个冲刺中完成吗？”PO又来了。“没问题！”业务对你的承诺印象深刻。
- en: 'As Robert C. Martin says: <q>The Web is a delivery mechanism [...] Your system
    architecture should be as ignorant as possible about how it is to be delivered.
    You should be able to deliver it as a console app, a web app, or even a web service
    app, without undue complication or any change to the fundamental architecture</q>.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如罗伯特·C·马丁所说：<q>网络是一种交付机制 [...] 你的系统架构应该尽可能不了解它如何交付。你应该能够以控制台应用程序、Web应用程序或甚至是Web服务应用程序的形式交付它，而不会造成不必要的复杂性或对基本架构的任何更改</q>。
- en: 'Your current API is built using Silex, the PHP micro-framework based on the
    Symfony2 Components. Let''s go for it in Listing 7:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你当前的API是使用基于Symfony2组件的PHP微框架Silex构建的。让我们在列表7中看看：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Is there anything familiar to you? Can you identify some code that you have
    seen before? I''ll give you a clue:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么熟悉的东西吗？你能识别出你之前见过的某些代码吗？我会给你一个提示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Man! I remember those 3 lines of code. They look exactly the same as the web
    application*. That''s right, because the UseCase encapsulates the business rules
    you need to prepare the request, get the response and act accordingly.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*哇！我记得这三行代码。它们看起来和Web应用程序一模一样*。没错，因为用例封装了你准备请求、获取响应并相应行动所需的企业规则。'
- en: We are providing our users with another way for rating an idea; another *delivery
    mechanism*. The main difference is where we created the `RateIdeaRequest` from.
    In the first example, it was from a ZF request and now it is from a Silex request
    using the parameters matched in the route.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为用户提供了一种对想法进行评分的另一种方式；另一种*交付机制*。主要区别在于我们从哪里创建了`RateIdeaRequest`。在第一个例子中，它来自ZF请求，现在它来自使用路由中匹配的参数的Silex请求。
- en: Console App Rating
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台应用程序 评分
- en: Sometimes, a UseCase is going to be executed from a Cron job or the command
    line. As examples, batch processing or some testing command lines to accelerate
    the development. While testing this feature using the web or the API, you realize
    that it would be nice to have a command line to do it, so you don't have to go
    through the browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用例将从Cron作业或命令行执行。例如，批量处理或一些测试命令行以加速开发。在通过Web或API测试这个功能时，你会发现有一个命令行来做这件事会很好，这样你就不必通过浏览器了。
- en: 'If you are using shell scripts files, I suggest you to check the Symfony Console
    component. What would the code look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用shell脚本文件，我建议你检查Symfony Console组件。代码会是什么样子：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again those 3 lines of code. As before, the UseCase and its business logic remain
    untouched, we are just providing a new *delivery mechanism.* Congratulations,
    you've discovered the *user side* hexagon edge.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次是这三行代码。和之前一样，用例及其业务逻辑保持不变，我们只是提供了一个新的*交付机制*。恭喜你，你已经发现了*用户端*六边形边缘。
- en: There is still a lot to do. As you may have heard, a real craftsman does TDD.
    We have already started our story so we must be ok with just testing after.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有好多事情要做。正如你可能听说的，真正的工匠会做TDD。我们已经开始了我们的故事，所以我们必须接受只是测试。
- en: Testing Rating an Idea UseCase
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 评估一个想法 用例
- en: Michael Feathers introduced a definition of legacy code as *code without tests*.
    You don't want your code to be legacy just born, do you?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·费瑟斯给遗留代码下了一个定义，即*没有测试的代码*。你不想你的代码一出生就是遗留的，对吧？
- en: 'In order to unit test this UseCase object, you decide to start with the easiest
    part, what happens if the repository is not available? How can we generate such
    behavior? Do we stop our Redis server while running the unit tests? No. We need
    to have an object that has such behavior. Let''s use a *mock* object in Listing
    9:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对这一用例对象进行单元测试，你决定从最容易的部分开始，如果仓库不可用会发生什么？我们如何生成这种行为？我们在运行单元测试时停止我们的Redis服务器吗？不。我们需要一个具有这种行为的对象。让我们在列表9中使用一个*模拟*对象：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nice. `NotAvailableRepository` has the behavior that we need and we can use
    it with `RateIdeaUseCase` because it implements `IdeaRepository` interface.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。`NotAvailableRepository`具有我们需要的特性，我们可以使用它与`RateIdeaUseCase`一起，因为它实现了`IdeaRepository`接口。
- en: 'Next case to test is what happens if the idea is not in the repository. Listing
    10 shows the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要测试的情况是如果想法不在仓库中会发生什么。列表10显示了代码：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we use the same strategy but with an `EmptyIdeaRepository`. It also implements
    the same interface but the implementation always returns null regardless which
    identifier the find method receives.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用相同的策略，但使用了一个`EmptyIdeaRepository`。它也实现了相同的接口，但实现总是返回null，无论find方法接收哪个标识符。
- en: 'Why are we testing these cases?, remember Kent Beck''s words: *Test everything
    that could possibly break*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要测试这些情况？记住肯特·贝克的这句话：*测试所有可能出错的东西*。
- en: 'Let''s carry on with the rest of the feature. We need to check a special case
    that is related with having a read available repository where we cannot write
    to. Solution can be found in Listing 11:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续其他功能的剩余部分。我们需要检查一个与有一个可读但不可写的存储库相关的特殊情况。解决方案可以在列表 11 中找到：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Ok, now the key part of the feature is still remaining. We have different ways
    of testing this, we can write our own mock or use a mocking framework such as
    Mockery or Prophecy. Let''s choose the first one. Another interesting exercise
    would be to write this example and the previous ones using one of these frameworks:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在这个功能的要点仍然存在。我们有不同的测试方式，我们可以编写自己的模拟或使用模拟框架，如 Mockery 或 Prophecy。让我们选择第一个。另一个有趣的练习将是使用这些框架之一编写这个示例和前面的示例：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bam! 100% Coverage for the UseCase. Maybe, next time we can do it using TDD
    so the test will come first. However, testing this feature was really easy because
    of the way decoupling is promoted in this architecture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 嘭！UseCase 的 100% 覆盖率。也许，下次我们可以使用 TDD 来实现，这样测试就会先进行。然而，由于这种架构中推广了解耦的方式，测试这个功能实际上非常简单。
- en: 'Maybe you are wondering about this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对此感到好奇：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need a way to guarantee that the update method has been called during the
    UseCase execution. This does the trick. This *test double* object is called a
    *spy*, *mocks* cousin.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来确保在 UseCase 执行期间已经调用了更新方法。这个方法就做到了这一点。这个 *测试替身* 对象被称为 *间谍*，*模拟*的表亲。
- en: When to use mocks? As a general rule, use mocks when crossing boundaries. In
    this case, we need mocks because we are crossing from the domain to the persistence
    boundary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用模拟？作为一个一般规则，当跨越边界时使用模拟。在这种情况下，我们需要模拟，因为我们正在从领域跨越到持久性边界。
- en: What about testing the infrastructure?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试基础设施，怎么办？
- en: Testing Infrastructure
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试基础设施
- en: If you want to achieve 100% coverage for your whole application you will also
    have to test your infrastructure. Before doing that, you need to know that those
    unit tests will be more coupled to your implementation than the business ones.
    That means that the probability to be broken with implementation details changes
    is higher. So it is a trade-off you will have to consider.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为整个应用程序实现 100% 的覆盖率，你也必须测试你的基础设施。在这样做之前，你需要知道，这些单元测试将比业务测试更多地与你的实现相关联。这意味着，随着实现细节的变化而出现问题的概率更高。因此，这是一个你必须考虑的权衡。
- en: 'So, if you want to continue, we need to do some modifications. We need to decouple
    even more. Let''s see the code in Listing 13:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想继续，我们需要做一些修改。我们需要进一步解耦。让我们看看列表 13 中的代码：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we want to 100% unit test `RedisIdeaRepository` we need to be able to pass
    the `Predis\Client` as a parameter to the repository without specifying TypeHinting
    so we can pass a mock to force the code flow necessary to cover all the cases.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要 100% 单元测试 `RedisIdeaRepository`，我们需要能够将 `Predis\Client` 作为参数传递给存储库，而不指定类型提示，这样我们就可以传递一个模拟来强制执行必要的代码流，以覆盖所有情况。
- en: This forces us to update the Controller to build the Redis connection, pass
    it to the repository and pass the result to the UseCase.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使我们更新控制器以建立 Redis 连接，将其传递给存储库，并将结果传递给 UseCase。
- en: Now, it is all about creating mocks, test cases and having fun doing asserts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都关于创建模拟、测试用例，并在断言中享受乐趣。
- en: Arggg, So Many Dependencies!
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哎呀，这么多依赖项！
- en: Is it normal that I have to create so many dependencies by hand? No. It is common
    to use a Dependency Injection component or a Service Container with such capabilities.
    Again, Symfony comes to the rescue, however, you can also check [PHP-DI 4](http://php-di.org/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动创建这么多依赖项是正常的吗？不。使用具有这种功能的依赖注入组件或服务容器是常见的。再次，Symfony 来拯救我们，然而，你也可以检查 [PHP-DI
    4](http://php-di.org/)。
- en: 'Let''s see the resulting code in Listing 14 after applying Symfony Service
    Container component to our application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在将 Symfony 服务容器组件应用于我们的应用程序后，列表 14 中产生的代码：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The controller has been modified to have access to the container, that''s why
    it is inheriting from a new base controller `ContainerAwareController` that has
    a `get` method to retrieve each of the services contained:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器已被修改以访问容器，这就是为什么它继承自一个新的基控制器 `ContainerAwareController`，该控制器有一个 `get` 方法来检索每个包含的服务：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Listing 15, you can also find the XML file used to configure the Service
    Container. It is really easy to understand but if you need more information, take
    a look to the Symfony Service Container Component [site](http://symfony.com/doc/current/book/service_container.html)
    in.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表15中，你还可以找到用于配置服务容器的XML文件。它真的很容易理解，但如果你需要更多信息，请查看Symfony服务容器组件[网站](http://symfony.com/doc/current/book/service_container.html)。
- en: Domain Services and Notification Hexagon Edge
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域服务和通知六角边缘
- en: 'Are we forgetting something? *the author should be notified by email*, yeah!
    That''s true. Let''s see in Listing 16 how we have updated the UseCase for doing
    the job:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是不是忘记了什么？*作者应该通过电子邮件通知*，是的！这是真的。让我们看看在列表16中我们是如何更新UseCase来完成这项工作的：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you realize, we have added a new parameter for passing `AuthorNotifier` Service
    that will send the email to the author. This is the *port* in the *Ports and Adapters* naming.
    We have also updated the business rules in the execute method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所意识到的那样，我们添加了一个新参数来传递`AuthorNotifier`服务，该服务将发送电子邮件给作者。这是*端口*在*端口和适配器*命名中的*端口*。我们还更新了执行方法中的业务规则。
- en: Repositories are not the only objects that may access your infrastructure and
    should be decoupled using interfaces or abstract classes. Domain Services can
    too. When there is a behavior not clearly owned by just one Entity in your domain,
    you should create a Domain Service. A typical pattern is to write an abstract
    Domain Service that has some concrete implementation and some other abstract methods
    that the *adapter* will implement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库不是唯一可能访问你的基础设施的对象，应该使用接口或抽象类进行解耦。领域服务也可以。当你的领域中有一个行为不是由一个实体明确拥有时，你应该创建一个领域服务。一个典型的模式是编写一个具有一些具体实现和一些其他抽象方法的抽象领域服务，这些方法将由*适配器*实现。
- en: As an exercise, define the implementation details for the `AuthorNotifier` abstract
    service. Options are SwiftMailer or just plain `mail` calls. It is up to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，定义`AuthorNotifier`抽象服务的实现细节。选项有SwiftMailer或直接使用`mail`调用。这取决于你。
- en: Let's Recap
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们回顾一下
- en: In order to have a *clean architecture* that helps you create easy to write
    and test applications, we can use Hexagonal Architecture. To achieve that, we
    encapsulate user story business rules inside a UseCase or Interactor object. We
    build the UseCase request from our framework request, instantiate the UseCase
    and all its dependencies and then execute it. We get the response and act accordingly
    based on it. If our framework has a Dependency Injection component you can use
    it to simplify the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个*清晰的架构*，帮助你创建易于编写和测试的应用程序，我们可以使用六角架构。为了实现这一点，我们将用户故事的业务规则封装在UseCase或Interactor对象中。我们根据框架请求构建UseCase请求，实例化UseCase及其所有依赖项，然后执行它。我们得到响应并根据它采取相应的行动。如果我们的框架有一个依赖注入组件，你可以使用它来简化代码。
- en: The same UseCase objects can be used from different *delivery mechanisms* in
    order to allow users access the features from different clients (web, API, console,
    and so on.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的UseCase对象可以从不同的*交付机制*中使用，以便用户可以从不同的客户端（Web、API、控制台等）访问功能。
- en: For testing, play with mocks that behave like all the interfaces defined so
    special cases or error flows can also be covered. Enjoy the good job done.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，可以玩一些模拟所有定义的接口的模拟，这样也可以覆盖特殊案例或错误流程。享受这份出色的工作吧。
- en: Hexagonal Architecture
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六角架构
- en: In almost all the blogs and books you will find drawings about concentric circles
    representing different areas of software. As Robert C. Martin explains in his
    *Clean Architecture* post, the outer circle is where your infrastructure resides.
    The inner circle is where your Entities live. The overriding rule that makes this
    architecture work is **The Dependency Rule**. This rule says that source code
    dependencies can only point inwards. Nothing in an inner circle can know anything
    at all about something in an outer circle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有的博客和书中，你都会找到关于软件不同区域的同心圆的插图。正如罗伯特·C·马丁在他的*Clean Architecture*帖子中解释的那样，外圈是你的基础设施所在的地方。内圈是你的实体所在的地方。使这种架构发挥作用的主要规则是**依赖规则**。这个规则说，源代码依赖只能指向内。内圈中的任何东西都不能知道外圈中的任何东西。
- en: Key Points
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键点
- en: Use this approach if 100% unit test code coverage is important to your application.
    Also, if you want to be able to switch your storage strategy, web framework or
    any other type of third-party code. The architecture is especially useful for
    long-lasting applications that need to keep up with changing requirements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果100%的单元测试覆盖率对你的应用程序非常重要，或者你想要能够切换你的存储策略、Web框架或其他任何类型的第三方代码，请使用这种方法。这种架构对于需要跟上不断变化的需求的长期应用程序特别有用。
- en: What's Next?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: If you are interested in learning more about Hexagonal Architecture and other
    near concepts you should review the related URLs provided at the beginning of
    the article, take a look at CQRS and Event Sourcing. Also, don't forget to subscribe
    to google groups and RSS about DDD such as [http://dddinphp.org](http://dddinphp.org)
    and follow on Twitter people like `@VaughnVernon`, and `@ericevans0`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于六边形架构以及其他相关概念，你应该回顾文章开头提供的相关网址，看看CQRS和事件源。此外，别忘了订阅关于领域驱动设计（DDD）的谷歌群组和RSS，例如[http://dddinphp.org](http://dddinphp.org)，并在Twitter上关注像`@VaughnVernon`和`@ericevans0`这样的人。
