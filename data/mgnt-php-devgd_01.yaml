- en: Chapter 1. Magento Fundamentals for Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 开发者必备的 Magento 基础知识
- en: In this chapter, we will cover the fundamental concepts of working with Magento.
    We will learn how Magento is structured, and go over the source of Magento's flexibility,
    that is, its modular architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍与 Magento 一起工作的基本概念。我们将学习 Magento 的结构，并探讨 Magento 灵活性的来源，即其模块化架构。
- en: Magento is a flexible and powerful system. Unfortunately, this adds some level
    of complexity as well. Currently, a clean installation of Magento has around 20,000
    files and over 1.2 million lines of code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 是一个灵活且强大的系统。不幸的是，这也增加了一些复杂性。目前，一个干净的 Magento 安装大约有 20,000 个文件和超过 1.2
    百万行代码。
- en: With all that power and complexity, Magento can be daunting for new developers;
    but don't worry. This chapter is designed to give new developers all the fundamental
    concepts and tools they need to use and extend Magento, and in the next chapter,
    we will dive deep into Magento models and data collection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些功能和复杂性面前，Magento 对于新开发者来说可能会有些令人畏惧；但别担心。本章旨在为新开发者提供所有他们需要的基本概念和工具来使用和扩展
    Magento，而在下一章中，我们将深入探讨 Magento 模型和数据收集。
- en: Zend Framework – the base of Magento
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zend Framework – Magento 的基础
- en: As you probably know, Magento is the most powerful e-commerce platform in the
    market. What you might not know about Magento is that it is also an object-oriented
    (OO) PHP framework developed on top of **Zend Framework**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Magento 是市场上最强大的电子商务平台。你可能不知道的是，Magento 还是一个基于 **Zend Framework** 开发的面向对象（OO）PHP
    框架。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Zend Framework 2 has been available since 2013, but Magento still relies on
    Zend Framework 1.11.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2 自 2013 年以来就已经可用，但 Magento 仍然依赖于 Zend Framework 1.11。
- en: 'Here''s how Zend''s official site describes the framework:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Zend 官方网站对框架的描述：
- en: '*"We designed Zend Framework with simplicity in mind. To provide a lightweight,
    loosely-coupled component library simplified to provide 4/5s of the functionality
    everyone needs and that lets you customize the other 20% to meet your specific
    business needs. By focusing on the most commonly needed functionality, we retain
    the simplified spirit of PHP programming, while dramatically lower the learning
    curve – and your training costs – so developers get up-to-speed quickly."*'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"我们设计 Zend Framework 时考虑了简洁性。为了提供一个轻量级、松散耦合的组件库，简化到提供每个人需要的 4/5 功能，并允许你自定义其他
    20% 来满足你特定的业务需求。通过关注最常用的功能，我们保留了 PHP 编程的简化精神，同时大幅降低了学习曲线——以及你的培训成本——这样开发者可以快速上手。"*'
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://files.zend.com/help/Zend-Server-5/zend_framework.htm](http://files.zend.com/help/Zend-Server-5/zend_framework.htm)'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://files.zend.com/help/Zend-Server-5/zend_framework.htm](http://files.zend.com/help/Zend-Server-5/zend_framework.htm)'
- en: 'What exactly is Zend Framework? Zend Framework is an OO framework developed
    on PHP that implements the **Model-View-Controller** (MVC) paradigm. When **Varien**
    (now Magento Inc.) started developing Magento, they decided to do it on top of
    Zend because of some components, some of which are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Zend Framework 究竟是什么呢？Zend Framework 是一个在 PHP 上开发的面向对象（OO）框架，实现了 **模型-视图-控制器**（MVC）范式。当
    **Varien**（现在为 Magento Inc.）开始开发 Magento 时，他们决定基于 Zend 来开发，因为一些组件，其中一些如下：
- en: '`Zend_Cache`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Cache`'
- en: '`Zend_Acl`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Acl`'
- en: '`Zend_Locale`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Locale`'
- en: '`Zend_DB`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_DB`'
- en: '`Zend_Pdf`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Pdf`'
- en: '`Zend_Currency`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Currency`'
- en: '`Zend_Date`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Date`'
- en: '`Zend_Soap`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Soap`'
- en: '`Zend_Http`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend_Http`'
- en: In total, Magento uses around 15 different Zend components. The Varien library
    extends several of the Zend components mentioned before directly. For example,
    `Varien_Cache_Core` extends from `Zend_Cache_Core`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Magento 使用了大约 15 个不同的 Zend 组件。Varien 库直接扩展了之前提到的几个 Zend 组件。例如，`Varien_Cache_Core`
    扩展自 `Zend_Cache_Core`。
- en: 'Using Zend Framework, Magento was built with the following principles in mind:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Zend Framework，Magento 考虑以下原则进行构建：
- en: '**Maintainable**: By using code pools to keep the core code separate from local
    customizations and third-party modules'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：通过使用代码池将核心代码与本地定制和第三方模块分开'
- en: '**Upgradable**: Magento modularity allows extensions and third-party modules
    to be updated independently from the rest of the system'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可升级性**：Magento 的模块化允许扩展和第三方模块独立于系统其他部分进行更新'
- en: '**Flexible**: Allows seamless customization and simplifies the development
    of new features'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：允许无缝定制并简化新功能的开发'
- en: Although experience of using Zend Framework or even understanding it are not
    requirements to develop Magento, having at least some basic understanding of the
    Zend components, usage, and interaction can be invaluable information as we start
    digging deeper into the core of Magento.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Zend Framework的经验或对其的理解不是开发Magento的要求，但至少对Zend组件、用法和交互有一些基本了解，在我们开始深入研究Magento核心时，这可能非常有价值的信息。
- en: You can learn more about Zend Framework at [http://framework.zend.com/](http://framework.zend.com/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://framework.zend.com/](http://framework.zend.com/)了解更多关于Zend Framework的信息。
- en: The Magento folder structure
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Magento的文件夹结构
- en: 'The Magento folder structure is slightly different from other MVC applications.
    Let''s take a look at the directory tree, and each directory and its functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Magento的文件夹结构与其他MVC应用程序略有不同。让我们看看目录树，以及每个目录及其功能：
- en: '`app`: This folder is the core of Magento and is subdivided into three important
    directories:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`：这个目录是Magento的核心，并细分为三个重要的子目录：'
- en: '`code`: This contains all our application code divided into three code pools,
    namely core, community, and local'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`：这个目录包含我们所有应用程序代码，分为三个代码池，即核心、社区和本地。'
- en: '`design`: This contains all the templates and layouts for our application'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`design`：这个目录包含我们应用程序的所有模板和布局。'
- en: '`locale`: This contains all the translation and e-mail template files used
    for the store'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale`：这个目录包含用于商店的所有翻译和电子邮件模板文件。'
- en: '`js`: This contains all the JavaScript libraries that are used in Magento'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js`：这个目录包含在Magento中使用的所有JavaScript库。'
- en: '`media`: This contains all the images and media files for our products and
    CMS pages, as well the product image cache'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media`：这个目录包含我们产品和CMS页面所用的所有图像和媒体文件，以及产品图像缓存。'
- en: '`lib`: This contains all the third-party libraries used in Magento (such as
    Zend and PEAR) as well as the custom libraries developed by Magento, which reside
    under the `Varien` and `Mage` directories'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这个目录包含所有在Magento中使用的三方库（例如Zend和PEAR）以及由Magento开发的自定义库，这些库位于`Varien`和`Mage`目录下。'
- en: '`skin`: This contains all CSS, images and JavaScript used by the corresponding
    theme'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skin`：这个目录包含对应主题使用的所有CSS、图像和JavaScript。'
- en: '`var`: This contains our temporary data, such as the cache file, index lock
    files, sessions, import/export files, and in the case of the Enterprise edition,
    the full page cache folders'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`：这个目录包含我们的临时数据，例如缓存文件、索引锁定文件、会话、导入/导出文件，以及在企业版中，完整的页面缓存文件夹。'
- en: 'Magento is a modular system. This means the application, including the core,
    is divided into smaller modules. For this reason, the folder structure plays a
    key role in the organization of each module. A typical Magento module folder structure
    would look something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Magento是一个模块化系统。这意味着应用程序，包括核心，被划分为更小的模块。因此，文件夹结构在组织每个模块中起着关键作用。一个典型的Magento模块文件夹结构可能看起来像这样：
- en: '![The Magento folder structure](img/4195OS_01_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![The Magento folder structure](img/4195OS_01_01.jpg)'
- en: 'Let''s review each folder further:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步审查每个文件夹：
- en: '`Block`: In Magento, blocks form an additional layer of logic between the controllers
    and views'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Block`：在Magento中，块形成控制器和视图之间的额外逻辑层。'
- en: '`controllers`: These are formed by actions that process webserver requests'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`：这些由处理web服务器请求的动作组成。'
- en: '`Controller`: Classes in this folder can be abstract classes and they can be
    extended by the `controller` class under the `controllers` folder'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controller`：这个目录下的类可以是抽象类，并且可以被`controllers`目录下的`controller`类扩展。'
- en: '`etc`: In this we can find the module-specific configuration in the form of
    XML files such as `config.xml` and `system.xml`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etc`：在这个目录中，我们可以找到以XML文件形式存在的模块特定配置，例如`config.xml`和`system.xml`。'
- en: '`Helper`: This contains auxiliary classes that encapsulate a common module
    functionality and make them available to a class of the same module and to other
    modules classes as well'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Helper`：这个目录包含封装常见模块功能并使其对同一模块的类以及其他模块的类可用的辅助类。'
- en: '`Model`: This contains models that support the controllers in the module to
    interact with data'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`：这个目录包含支持模块中的控制器与数据交互的模型。'
- en: '`sql`: These contain the installation and upgrade files for each specific module'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql`：这些包含每个特定模块的安装和升级文件。'
- en: '`data`: This folder was introduced in Magento 1.6 CE and it is used in a manner
    similar to SQL scripts, but data scripts are only concerned about inserting data'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这个目录在Magento 1.6 CE中引入，其用法类似于SQL脚本，但数据脚本只关注插入数据。'
- en: As we will see later in this chapter, Magento makes heavy use of factory names
    and factory methods. This is why the folder structure is so important.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，Magento 大量使用工厂名称和工厂方法。这就是为什么文件夹结构如此重要的原因。
- en: Modular architecture
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化架构
- en: Rather than being a large application, Magento is built by smaller modules,
    each adding specific functionality to Magento.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与大型应用程序不同，Magento 是由较小的模块构建的，每个模块都为 Magento 添加特定的功能。
- en: One of the advantages of this approach is the ability to enable and disable
    specific module functionality with ease as well as adding new functionality by
    adding new modules.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是能够轻松地启用和禁用特定模块的功能，以及通过添加新模块来添加新功能。
- en: Autoloader
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动加载器
- en: Magento is a huge framework composed by close to 20,000 files. Requiring every
    single file when the application starts would make it incredibly slow and resource
    intensive. Hence, Magento makes use of an autoloader class to require the files
    each time a factory method is called.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 是一个由近 20,000 个文件组成的庞大框架。在应用程序启动时要求每个文件将使其运行极其缓慢且资源密集。因此，Magento 使用自动加载器类在每次调用工厂方法时包含文件。
- en: So what exactly is an autoloader? PHP5 includes a function called `__autoload()`.
    When instantiating a class, the `__autoload()` function is automatically called.
    Inside this function, the custom logic is defined to parse the class name and
    require the file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，自动加载器究竟是什么呢？PHP5 包含一个名为 `__autoload()` 的函数。当实例化一个类时，`__autoload()` 函数会自动被调用。在这个函数内部，定义了自定义逻辑来解析类名并包含文件。
- en: 'Let''s take a closer look at the Magento Bootstrap code located in `app/Mage.php`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看位于 `app/Mage.php` 的 Magento Bootstrap 代码：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Bootstrap file takes care of defining the include paths and initializing
    the Varien autoloader, which will in turn define its own autoload function as
    the default function to call. Let''s take a look under the hood and see what the
    Varien''s autoload function is doing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 文件负责定义包含路径并初始化 Varien 自动加载器，该自动加载器反过来定义其自己的自动加载函数作为默认要调用的函数。让我们深入了解并看看
    Varien 的自动加载函数在做什么：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `autoload` class takes a single parameter called `$class`, which is an alias
    provided by the factory method. This alias is processed to generate a matching
    class name that is then included.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoload` 类接受一个名为 `$class` 的单个参数，这是由工厂方法提供的别名。这个别名被处理以生成匹配的类名，然后被包含。'
- en: As we mentioned before, Magento's directory structure is important due to the
    fact that Magento derives its class names from the directory structure. This convention
    is the core principle behind factory methods, which we will be reviewing later
    in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，由于 Magento 从目录结构中派生其类名，因此 Magento 的目录结构非常重要。这是工厂方法背后的核心原则，我们将在本章后面进行回顾。
- en: Code pools
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码池
- en: 'As mentioned before, inside our `app/code` folder, we have our application
    code divided into the following three different directories known as code pools:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在我们的 `app/code` 文件夹中，我们的应用程序代码被分为以下三个不同的目录，称为代码池：
- en: '`core`: This is where the Magento Core modules that provide the base functionality
    reside. The golden rule among Magento developers is that you should never, under
    any circumstance, modify any files under the core code pool.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`：这是提供基本功能的 Magento 核心模块所在的位置。在 Magento 开发者中有一条黄金法则，那就是在任何情况下都不要修改核心代码池下的任何文件。'
- en: '`community`: This is the location where third-party modules are placed. They
    are either provided by third parties or installed through Magento Connect.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community`：这是第三方模块放置的位置。它们要么由第三方提供，要么通过 Magento Connect 安装。'
- en: '`local`: This is where all the modules and code developed specifically for
    this instance of Magento reside.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`：这是所有为这个 Magento 实例开发的具体模块和代码所在的位置。'
- en: 'The code pools identify where the module came from and in which order they
    should be loaded. If we take another look at the `Mage.php` Bootstrap file, we
    can see the order in which code pools are loaded:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码池识别模块的来源以及它们应该加载的顺序。如果我们再次查看 `Mage.php` Bootstrap 文件，我们可以看到代码池加载的顺序：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means, for each class request, Magento will look in the `local` folder,
    then in the community and `core` folders, and finally inside the `lib` folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于每个类请求，Magento 将在 `local` 文件夹中查找，然后是社区和 `core` 文件夹，最后在 `lib` 文件夹中查找。
- en: This also produces an interesting behavior that can easily be used to override
    core and community classes by just copying the directory structure and matching
    the class name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这也产生了一种有趣的行为，可以很容易地通过复制目录结构和匹配类名来覆盖核心和社区类。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Needless to say, this is a terrible practice, but it is still useful to know
    about, just in case someday you have to take care of a project that exploits this
    behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这是一个糟糕的做法，但了解这一点仍然很有用，以防万一有一天你必须处理利用这种行为的项目。
- en: Routing and request flow
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和请求流程
- en: Before going into more detail about the different components that form a part
    of Magento, it is important that we understand how these components interact together
    and how Magento processes requests coming from the web server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨构成Magento不同部分的组件之前，了解这些组件如何相互作用以及Magento如何处理来自Web服务器的请求非常重要。
- en: As with any other PHP application, we have a single file as an entry point for
    every request. In the case of Magento, this file is `index.php`, which is in charge
    of loading the `Mage.php` Bootstrap class and starting the request cycle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他PHP应用程序一样，我们有一个单独的文件作为每个请求的入口点。在Magento的情况下，这个文件是`index.php`，负责加载`Mage.php`引导类并启动请求周期。
- en: The web server receives the request and Magento is instantiated by calling the
    Bootstrap file `Mage.php`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收请求并通过调用引导文件`Mage.php`实例化Magento。
- en: The frontend controller is instantiated and initialized. During this controller
    initialization, Magento searches for the web routes and instantiates them.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端控制器被实例化和初始化。在控制器初始化期间，Magento搜索网络路由并将它们实例化。
- en: Magento then iterates through each of the routers and calls the match. The match
    method is responsible for processing the URL and generating the corresponding
    controller and action.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Magento遍历每个路由器并调用match。match方法负责处理URL并生成相应的控制器和动作。
- en: Instantiates the matching controller and corresponding action.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化匹配的控制器和相应的动作。
- en: 'Routers are especially important in this process. Router objects are used by
    the frontend controller to match a requested URL (route) to a module controller
    and action. By default, Magento comes with the following routers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 路由在这个过程中特别重要。路由器对象被前端控制器用来将请求的URL（路由）匹配到模块控制器和动作。默认情况下，Magento附带以下路由器：
- en: '`Mage_Core_Controller_Varien_Router_Admin`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage_Core_Controller_Varien_Router_Admin`'
- en: '`Mage_Core_Controller_Varien_Router_Standard`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage_Core_Controller_Varien_Router_Standard`'
- en: '`Mage_Core_Controller_Varien_Router_Cms`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage_Core_Controller_Varien_Router_Cms`'
- en: '`Mage_Core_Controller_Varien_Router_Default`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage_Core_Controller_Varien_Router_Default`'
- en: The action controller will then load and render the layout, which in turn will
    load the corresponding blocks, models, and templates.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 动作控制器随后将加载并渲染布局，该布局反过来将加载相应的块、模型和模板。
- en: Let's analyze how Magento will handle a request to a category page. We will
    use `http://localhost/catalog/category/view/id/10` as an example. The Magento
    URI comprises three parts, namely `FrontName/ControllerName/ActionName`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下Magento将如何处理对分类页面的请求。我们将使用`http://localhost/catalog/category/view/id/10`作为示例。Magento
    URI由三部分组成，即`FrontName/ControllerName/ActionName`。
- en: 'Hence, for our example URL, the breakdown is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的示例URL，分解如下：
- en: '`FrontName`: This is a catalog'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontName`: 这是一个目录'
- en: '`ControllerName`: This is a category'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControllerName`: 这是一个分类'
- en: '`ActionName`: This is a view'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionName`: 这是一个视图'
- en: 'Let''s take a look at the Magento router class `Mage_Core_Controller_Varien_Router_Standard`
    match function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Magento路由器类`Mage_Core_Controller_Varien_Router_Standard`的match函数：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the previous code, we can see that the first thing the router tries to
    do is parse the URI into an array. Based on our example URL, the corresponding
    array will be similar to the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到路由器首先尝试做的事情是将URI解析成数组。根据我们的示例URL，相应的数组将类似于以下代码：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next part of the function will first try to check if the request has the
    module name specified. If not, then it tries to determine the module name, based
    on the first element of our array. If a module name can''t be provided, then the
    function will return false. Let''s take a look at this part of the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分将首先尝试检查请求是否指定了模块名称。如果没有，那么它将根据我们数组的第一个元素尝试确定模块名称。如果无法提供模块名称，则函数将返回false。让我们看看这段代码：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, the `match` function will iterate through each of the available modules
    and try to match the controller and action using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`match` 函数将遍历每个可用的模块，并尝试使用以下代码匹配控制器和动作：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that looks like an awful lot of code! Let's break it down further. The first
    part of the loop will check if the request has a controller name. If it is not
    set, it will check our parameter array's (`$p`) second value and try to determine
    the controller name. Then, it will try to do the same for the action name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来代码很多！让我们进一步分解它。循环的第一部分将检查请求是否有控制器名称。如果没有设置，它将检查我们的参数数组（`$p`）的第二个值，并尝试确定控制器名称。然后，它将尝试对动作名称做同样的事情。
- en: 'If we get this far in the loop, we should have a module name, a controller
    name, and an action name. Magento will now use these to try and get matched with
    the Controller class name by calling the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环中走到这一步，我们应该有一个模块名称、一个控制器名称和一个动作名称。现在，Magento 将使用这些名称尝试通过调用以下代码与控制器类名称进行匹配：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function will not only generate a matching class name, but it will also
    validate its existence. In our example case, this function should return `Mage_Catalog_CategoryController`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不仅会生成一个匹配的类名，还会验证其存在。在我们的例子中，这个函数应该返回 `Mage_Catalog_CategoryController`。
- en: As we now have a valid class name, we can proceed to instantiate our controller
    object. You may probably notice that so far we haven't done anything with our
    action yet, and that's precisely the next step on our loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有一个有效的类名，我们可以继续实例化我们的控制器对象。你可能已经注意到，到目前为止，我们还没有对我们的动作做任何事情，这正是我们循环中的下一步。
- en: Now, our instantiated controller comes with a very handy function called `hasAction()`.
    In essence, all this function does is call a PHP function called `is_callable()`,
    which will check if our current controller has a public function matching the
    action name. In our case this will be `viewAction()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的实例化控制器附带一个非常有用的函数，称为 `hasAction()`。本质上，这个函数所做的只是调用一个名为 `is_callable()`
    的 PHP 函数，该函数将检查我们的当前控制器是否有一个与动作名称匹配的公共函数。在我们的例子中，这将是一个 `viewAction()`。
- en: 'The reason behind this elaborate matching process and the use of a `foreach`
    loop is that it is possible for several modules to use the same `frontName`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种详尽的匹配过程和使用 `foreach` 循环的原因是，可能存在多个模块使用相同的 `frontName`：
- en: '![Routing and request flow](img/4195OS_01_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![路由和请求流程](img/4195OS_01_03.jpg)'
- en: Now, `http://localhost/catalog/category/view/id/10` is not a very user-friendly
    URL. Fortunately, Magento has its own URL rewrite system that allows us to use
    `http://localhost/books.html`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`http://localhost/catalog/category/view/id/10` 并不是一个非常用户友好的 URL。幸运的是，Magento
    有自己的 URL 重写系统，允许我们使用 `http://localhost/books.html`。
- en: 'Let''s dig a little deeper into the URL rewrite system and see how Magento
    gets the controller and action names from our URL alias. Inside our `Varien/Front.php`
    controller dispatch function, Magento will call the following action:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 URL 重写系统，看看 Magento 是如何从我们的 URL 别名中获取控制器和动作名称的。在我们的 `Varien/Front.php`
    控制器调度函数中，Magento 将调用以下动作：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before actually looking into the inner working of the rewrite function, let''s
    take a look at the structure of the `core/url_rewrite` model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际查看重写函数的内部工作原理之前，让我们先看看 `core/url_rewrite` 模型的结构：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the rewrite module comprises several properties, but only two
    of them are of particular interest to us, namely `request_path` and `target_path`.
    Simply put, the job of the rewrite module is to modify the request object path
    information with the matching values of `target_path`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，重写模块包含几个属性，但其中只有两个对我们特别感兴趣，即 `request_path` 和 `target_path`。简单来说，重写模块的工作是使用
    `target_path` 的匹配值修改请求对象的路径信息。
- en: The Magento version of MVC
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Magento 版本的 MVC
- en: If you are familiar with traditional MVC implementations such as CakePHP or
    Symfony, you may know that the most common implementation is called a convention-based
    MVC. With a convention-based MVC to add a new Model, or let's say a Controller,
    you only need to create the file/class (following the framework conventions);
    the system will pick it up automatically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉传统的 MVC 实现，如 CakePHP 或 Symfony，你可能知道最常见的一种实现方式被称为基于约定的 MVC。在基于约定的 MVC 中，要添加一个新的模型，或者让我们说一个控制器，你只需要创建一个文件/类（遵循框架约定）；系统会自动将其拾取。
- en: Magento on the other hand uses a configuration-based MVC pattern, which means
    creating our file/class is not enough; we have to tell Magento explicitly that
    we have added a new class using configuration files written in XML.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Magento使用基于配置的MVC模式，这意味着创建我们的文件/类是不够的；我们必须明确告诉Magento我们已经添加了一个新类，使用的是XML编写的配置文件。
- en: 'Each Magento module has a `config.xml` file that is located under the module''s
    `etc/` directory and contains all the relevant module configurations. For example,
    if we want to add a new module that includes a new model, we need to define a
    node in the configuration file that tells Magento where to find our model. Here''s
    an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Magento模块都有一个位于模块`etc/`目录下的`config.xml`文件，其中包含所有相关的模块配置。例如，如果我们想添加一个包含新模型的新模块，我们需要在配置文件中定义一个节点，告诉Magento在哪里可以找到我们的模型。以下是一个示例：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although this might look like additional work, it also gives us a huge amount
    of flexibility and power. For example, we can rewrite another class by using the
    rewrite node:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是额外的工作，但它也给我们带来了巨大的灵活性和功能。例如，我们可以通过使用重写节点来重写另一个类：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Magento will then load all the `config.xml` files and merge them at runtime,
    creating a single configuration tree.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Magento将加载所有`config.xml`文件并在运行时合并它们，创建一个单一的配置树。
- en: 'Additionally, modules can also have a `system.xml` file that is used to specify
    configuration options in the Magento backend, which end users can in turn use
    to configure the module functionality. A snippet of a `system.xml` file will look
    like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模块还可以有一个`system.xml`文件，该文件用于在Magento后端指定配置选项，最终用户可以使用这些选项来配置模块功能。一个`system.xml`文件的片段看起来如下所示：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s break down each node function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析每个节点的功能：
- en: '`section_name`: This is just an arbitrary name that we use to identify our
    configuration section. Inside this node, we will specify all the fields and groups
    for the configuration section.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`section_name`：这只是一个任意的名称，我们用它来识别我们的配置部分。在这个节点内部，我们将指定配置部分的全部字段和组。'
- en: '`group`: Groups, as the name implies, are used to group configuration options
    and display them inside an accordion section.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`：正如其名所示，组用于分组配置选项并在手风琴部分中显示它们。'
- en: '`label`: This defines the title or label to be used on the field/section/group.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这定义了字段/部分/组上要使用的标题或标签。'
- en: '`tab`: This defines the tab on which the section should be displayed.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab`：这定义了应显示该部分的标签页。'
- en: '`frontend_type`: This node allows us to specify which renderer to use for our
    custom option field. Some of the available options are as follows:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_type`：此节点允许我们指定用于自定义选项字段的渲染器。一些可用的选项如下：'
- en: Button
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Checkboxes
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: Checkbox
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: Date
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: File
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Hidden
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏
- en: Image
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Label
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Link
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接
- en: Multiline
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行
- en: Multiselect
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多选
- en: Password
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Radio
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮
- en: Radios
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮
- en: Select
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: Submit
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交
- en: Textarea
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本区域
- en: Text
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Time
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: '`sort_order`: This specifies the position of the field, group, or section.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_order`：这指定了字段、组或部分的位置。'
- en: '`source_model`: Certain type of fields, such as a select field, can take options
    from a source model. Magento already provides several useful classes under `Mage/Adminhtml/Model/System/Config/Source`.
    Some of the classes we can find are as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source_model`：某些类型的字段，如选择字段，可以从源模型中获取选项。Magento已经在`Mage/Adminhtml/Model/System/Config/Source`下提供了几个有用的类。我们可以找到的一些类如下：'
- en: '`YesNo`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YesNo`'
- en: '`Country`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country`'
- en: '`Currency`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Currency`'
- en: '`AllRegions`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllRegions`'
- en: '`Category`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`'
- en: '`Language`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Language`'
- en: Just by using XML, we can build complex configuration options for our modules
    right on the Magento backend without having to worry about setting up templates,
    populating fields, or validating data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过使用XML，我们就可以在Magento后端直接为我们的模块构建复杂的配置选项，而无需担心设置模板、填充字段或验证数据。
- en: 'Magento is also kind enough to provide a comprehensive amount of form field
    validation models that we can use with the `<validate>` tag. Among the field validators
    we have the following options:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Magento还非常慷慨地提供了一套全面的表单字段验证模型，我们可以使用`<validate>`标签。在字段验证器中，我们有以下选项：
- en: '`validate-email`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate-email`'
- en: '`validate-length`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate-length`'
- en: '`validate-url`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate-url`'
- en: '`validate-select`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate-select`'
- en: '`validate-password`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate-password`'
- en: As with any other part of Magento, we can extend `source_models`, `frontend_types`,
    and validators, and even create new ones. We will be tackling this task in a later
    chapter, where we will create a new type of each. For now, we will explore the
    concepts of models, views, file layouts, and controllers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Magento 的任何其他部分一样，我们可以扩展 `source_models`、`frontend_types` 和验证器，甚至创建新的。我们将在后面的章节中处理这个任务，我们将创建每种类型的新模型。现在，我们将探讨模型、视图、文件布局和控制器等概念。
- en: Models
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'Magento makes use of the ORM approach, although we can still use `Zend_Db`
    to access the database directly. We will be using models to access our data most
    of the time. For this type of task, Magento provides the following two types of
    models:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 使用 ORM 方法，尽管我们仍然可以使用 `Zend_Db` 直接访问数据库。我们大多数时候将使用模型来访问我们的数据。对于这类任务，Magento
    提供以下两种类型的模型：
- en: '**Simple models**: These model implementations are a simple mapping of one
    object to one table, meaning our object attributes match each field and our table
    structure'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单模型**：这些模型实现是将一个对象映射到一个表上，意味着我们的对象属性与每个字段匹配，我们的表结构'
- en: '**Entity Attribute Value (EAV) models**: These type of models are used to describe
    entities with a dynamic number of attributes'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体属性值（EAV）模型**：这类模型用于描述具有动态属性数量的实体'
- en: 'Magento splits the model layer in two parts: a model handling the business
    logic and a resource handling the database interaction. This design decision allows
    Magento to support multiple database platforms without having to change any of
    the logic inside the models.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 将模型层分为两部分：一个处理业务逻辑的模型和一个处理数据库交互的资源。这种设计决策使 Magento 能够支持多个数据库平台，而无需更改模型内部的任何逻辑。
- en: Magento ORM uses one of PHP's magic class methods to provide dynamic access
    to object properties. In the next chapter, we will look into models, the Magento
    ORM, and the data collections in more detail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Magento ORM 使用 PHP 的一个魔法类方法来提供对对象属性的动态访问。在下一章中，我们将更详细地探讨模型、Magento ORM 和数据集合。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Magento models don't necessarily have to be related to any type table in the
    database or an EAV entity. Observers, which we will be reviewing later, are perfect
    examples of these type of Magento models.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 模型不一定必须与数据库中的任何类型表或 EAV 实体相关联。观察者，我们将在后面进行审查，是这类 Magento 模型的完美例子。
- en: Views
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'The view layer is one of the areas where Magento truly sets itself apart from
    other MVC applications. Unlike traditional MVC systems, Magento''s view layer
    is divided into three different components:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 视图层是 Magento 真正与其他 MVC 应用程序区分开来的领域之一。与传统 MVC 系统不同，Magento 的视图层分为三个不同的组件：
- en: '**Layouts**: These are XML files that define block structures and properties,
    such as name and which template file to use. Each Magento module has its own set
    of layout files.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**：这些是定义块结构和属性（如名称和要使用的模板文件）的 XML 文件。每个 Magento 模块都有自己的布局文件集。'
- en: '**Blocks**: These are used in Magento to reduce the burden on the controller
    by moving most of the logic into blocks.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块**：这些在 Magento 中用于通过将大部分逻辑移动到块中来减轻控制器负担。'
- en: '**Templates**: These are PHTML files that contain the HTML code and PHP tags
    required.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：这些是包含所需 HTML 代码和 PHP 标签的 PHTML 文件。'
- en: Layouts give the Magento frontend an amazing amount of flexibility. Each module
    has its own layout XML files that tell Magento what to include and render on each
    page request. By using the layouts, we can move, add, or remove blocks from our
    store, without worrying about changing anything else other than our XML files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 布局为 Magento 前端提供了惊人的灵活性。每个模块都有自己的布局 XML 文件，告诉 Magento 在每个页面请求中包含和渲染什么。通过使用布局，我们可以移动、添加或从我们的商店中删除块，而不用担心改变任何其他东西，除了我们的
    XML 文件。
- en: Dissecting a layout file
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析布局文件
- en: 'Let''s examine one of the Magento core layout files, in this case, the `catalog.xml`
    file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个 Magento 核心布局文件，在这种情况下，是 `catalog.xml` 文件：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Layout blocks comprise three main XML nodes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 布局块由三个主要的 XML 节点组成：
- en: '**Handle**: Each page request will have several unique handles. The layout
    uses these handles to tell Magento which blocks to load and render on a per page
    basis. The most commonly used handles are the default handle and the `[frontname]_[controller]_[action]`
    handle.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：每个页面请求将具有几个唯一的处理程序。布局使用这些处理程序来告诉 Magento 在每个页面上加载和渲染哪些块。最常用的处理程序是默认处理程序和
    `[frontname]_[controller]_[action]` 处理程序。'
- en: The default handle is especially useful to set global blocks, for example, adding
    CSS or JavaScript to all pages on the header block.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认处理程序特别有用，可以设置全局块，例如，在页眉块中向所有页面添加 CSS 或 JavaScript。
- en: '**Reference**: A `<reference>` node is use to make references to a block. It
    is useful for the specification of nested blocks or modifying an already existing
    block. In our example, we can see how a new child blocks being specified inside
    `<reference name="left">`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考**：`<reference>` 节点用于引用一个块。这对于指定嵌套块或修改已存在的块非常有用。在我们的例子中，我们可以看到如何在 `<reference
    name="left">` 内部指定新的子块。'
- en: '**Block**: The `<block>` node is used to load our actual blocks. Each block
    node can have the following properties:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块**：`<block>` 节点用于加载我们的实际块。每个块节点可以有以下属性：'
- en: '`type`: This is the identifier for the actual block class. For example, `catalog/product_list`
    makes reference to the `Mage_Catalog_Block_Product_List`.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是实际块类的标识符。例如，`catalog/product_list` 指的是 `Mage_Catalog_Block_Product_List`。'
- en: '`name`: This is the name used by other blocks to make a reference to this block.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是其他块用来引用此块的名字。'
- en: '`before/after`: These properties can be used to position the blocks relative
    to other block position. Both properties can use a hyphen as value to specify
    if the module should appear at the very top or the very bottom.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before/after`：这些属性可以用来定位块相对于其他块的位置。这两个属性都可以使用连字符作为值来指定模块应该出现在最顶部或最底部。'
- en: '`template`: This property determines the `.phtml` template file that will be
    used to render the block.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这个属性决定了将用于渲染块的 `.phtml` 模板文件。'
- en: '`action`: Each block type has specific actions that affect the frontend functionality.
    For instance, the `page/html_head` block has actions to add CSS and `js` (`addJs`
    and `addCss`).'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：每个块类型都有特定的动作，这些动作会影响前端功能。例如，`page/html_head` 块有添加 CSS 和 `js`（`addJs`
    和 `addCss`）的动作。'
- en: '`as`: This is used to specify the unique identifier that we will be using to
    call the block from the template. For example, calling a child block by using
    `getChildHtml(''block_name'')`.'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as`：这用于指定我们将用于从模板调用块的唯一标识符。例如，通过使用 `getChildHtml(''block_name'')` 调用一个子块。'
- en: Blocks are a new concept that Magento implements in order to reduce the controller
    load. They are basically data resources that communicate directly with the models
    that manipulate the data if needed and then pass it to the views.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 块是 Magento 实施的一个新概念，旨在减少控制器负载。它们基本上是数据资源，可以直接与需要操作数据的模型通信，然后将数据传递到视图中。
- en: 'Finally, we have our `.phtml` files. Templates contain HTML and PHP tags and
    are in charge of formatting and displaying the data from our models. Let''s take
    a look at a snippet from the product view template:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的 `.phtml` 文件。模板包含 HTML 和 PHP 标签，负责格式化和显示模型中的数据。让我们看看产品视图模板的一个片段：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is a diagram displaying the MVC model:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示 MVC 模型的图示：
- en: '![Dissecting a layout file](img/4195OS_01_02.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![剖析布局文件](img/4195OS_01_02.jpg)'
- en: Controllers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'The Magento MVC controllers are designed to be thin controllers. Thin controllers
    have little business logic and are mostly used to drive the application requests.
    A basic Magento controller action will just load and render the layout:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Magento MVC 控制器被设计成瘦控制器。瘦控制器具有很少的业务逻辑，主要用于驱动应用程序请求。基本的 Magento 控制器动作只是加载和渲染布局：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From here, it is the job of the blocks to handle the *display logic* to get
    the data from our models, prepare the data, and send it to the views.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，块的工作是处理 *显示逻辑*，从我们的模型中获取数据，准备数据，并将其发送到视图中。
- en: Websites and store scopes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网站和商店作用域
- en: One of Magento's core features is the ability to handle multiple websites and
    stores with a single Magento installation. Internally, Magento refers to each
    of these instances as scopes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 的核心特性之一是能够通过单个 Magento 安装处理多个网站和商店。内部，Magento 将这些实例称为作用域。
- en: '![Websites and store scopes](img/4195OS_01_06.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![网站和商店作用域](img/4195OS_01_06.jpg)'
- en: Values for certain elements such as products, categories, attributes, and configuration
    are scope-specific and can differ on different scopes. This gives Magento tremendous
    flexibility. For example, a product can be set up on two different websites with
    different prices but still share the rest of the attribute configuration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 产品、类别、属性和配置等某些元素的值是作用域特定的，并且在不同作用域中可能不同。这为 Magento 提供了巨大的灵活性。例如，一个产品可以在两个不同的网站上设置，具有不同的价格，但仍然共享其余的属性配置。
- en: 'As developers, one of the areas where we will be using scopes the most is when
    working with configuration. The different configuration scopes available in Magento
    are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们在处理配置时最常使用的作用域之一就是与配置一起工作。在 Magento 中可用的不同配置作用域如下：
- en: '**Global**: As the name implies, this applies across all scopes.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**：正如其名所示，这适用于所有作用域。'
- en: '**Website**: These are defined by a domain name and are composed by one or
    more stores. Websites can be set up to share customer data or be completely isolated.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：这些由域名定义，由一个或多个商店组成。网站可以设置为共享客户数据或完全隔离。'
- en: '**Store**: These are used to manage products and categories and to group store
    views. Stores also have a root category that allows us to have separated catalogs
    per store.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商店**：这些用于管理产品和类别，以及分组商店视图。商店还有一个根类别，允许我们为每个商店拥有分开的目录。'
- en: '**Store view**: By using store views, we can set up multiple languages on our
    store frontend.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商店视图**：通过使用商店视图，我们可以在商店前端设置多个语言。'
- en: 'Configuration options in Magento can store values on three scopes (global,
    website, and store views). By default, all the values are set on the global scope.
    Using `system.xml` on our modules, we can specify the scopes on which the configuration
    options can be set. Let''s revisit our previous `system.xml` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 中的配置选项可以在三个作用域（全局、网站和商店视图）上存储值。默认情况下，所有值都设置在全局作用域上。通过在我们的模块中使用 `system.xml`，我们可以指定配置选项可以设置的作用域。让我们回顾一下我们之前的
    `system.xml` 文件：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Factory names and functions
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂名称和函数
- en: Magento makes use of factory methods to instantiate models, helpers, and block
    classes. A factory method is a design pattern that allows us to instantiate an
    object without using the exact class name and using a class alias instead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 使用工厂方法来实例化模型、助手和块类。工厂方法是一种设计模式，它允许我们通过使用类别名而不是确切的类名来实例化对象。
- en: 'Magento implements the following factory methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 实现了以下工厂方法：
- en: '`Mage::getModel()`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::getModel()`'
- en: '`Mage::getResourceModel()`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::getResourceModel()`'
- en: '`Mage::helper()`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::helper()`'
- en: '`Mage::getSingleton()`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::getSingleton()`'
- en: '`Mage::getResourceSingleton()`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::getResourceSingleton()`'
- en: '`Mage::getResourceHelper()`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mage::getResourceHelper()`'
- en: 'Each of these methods takes a class alias that is used to determine the real
    class name of the object that we are trying to instantiate. For example, if we
    want to instantiate a product object, we can do so by calling the `getModel()`
    method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都接受一个用于确定我们试图实例化的对象的实际类名的类别名。例如，如果我们想实例化一个产品对象，我们可以通过调用 `getModel()`
    方法来实现：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice that we are passing a factory name composed of `group_classname`/`model_name`.
    Magento will resolve this to the actual class name of `Mage_Catalog_Model_Product`.
    Let''s take a closer look at the inner workings of `getModel()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递了一个由 `group_classname`/`model_name` 组成的工厂名称。Magento 将解析为 `Mage_Catalog_Model_Product`
    的实际类名。让我们更详细地看看 `getModel()` 的内部工作原理：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In return, `getModelInstance()` calls the `getModelClassName()` method that
    takes a class alias as a parameter. Then, it tries to validate the existence of
    the returned class, and if the class exists, it creates a new instance of that
    class and returns it to our `getModel()` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，`getModelInstance()` 调用 `getModelClassName()` 方法，该方法接受一个类别名作为参数。然后，它尝试验证返回的类的存在性，如果类存在，它就创建该类的新实例并将其返回给我们的
    `getModel()` 方法：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `getModelClassName()` method calls the `getGroupedClassName()` method, which
    is actually in charge of returning the real class name of our model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`getModelClassName()` 方法调用 `getGroupedClassName()` 方法，实际上负责返回我们模型的实际类名。'
- en: 'The `getGroupedClassName()` method takes two parameters, namely `$groupType`
    and `$classId`. The `$groupType` parameter refers to the type of object that we
    are trying to instantiate. Currently, only models, blocks, and helpers are supported.
    The `$classId` that we are trying to instantiate is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGroupedClassName()` 方法接受两个参数，即 `$groupType` 和 `$classId`。`$groupType` 参数指的是我们试图实例化的对象的类型。目前，仅支持模型、块和助手。我们试图实例化的
    `$classId` 如下：'
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, `getGroupedClassName()` is actually doing all the work. It grabs
    our class alias catalog/product and creates an array by exploding the string on
    the slash character.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`getGroupedClassName()` 实际上做了所有的工作。它获取我们的类别名目录/产品，并通过斜杠字符拆分字符串来创建一个数组。
- en: Then, it loads an instance of `Varien_Simplexml_Element` and passes the first
    value in our array (`group_classname`). It also checks if the class has been rewritten,
    and if it has, we will use the corresponding group name.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它加载 `Varien_Simplexml_Element` 的一个实例，并将我们数组中的第一个值（`group_classname`）传递给它。它还检查类是否已被重写，如果是，我们将使用相应的组名。
- en: Magento also uses a custom version of the `uc_words()` function that will capitalize
    the first letters and convert separators of the class alias if needed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 还使用了一个自定义版本的 `uc_words()` 函数，该函数会在需要时将类别名的分隔符和首字母大写。
- en: 'Finally, the function will return the real class name to the `getModelInstance()`
    function. In our example case, this will return `Mage_Catalog_Model_Product`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数将实际类名返回给 `getModelInstance()` 函数。在我们的示例案例中，这将返回 `Mage_Catalog_Model_Product`：
- en: '![Factory names and functions](img/4195OS_01_04.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![工厂名称和函数](img/4195OS_01_04.jpg)'
- en: Events and observers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和观察者
- en: The event and observer pattern is probably one of Magento's more interesting
    features, as it allows developers to extend Magento in critical parts of the application
    flow.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和观察者模式可能是 Magento 中更有趣的特性之一，因为它允许开发者在应用程序流程的关键部分扩展 Magento。
- en: In order to provide more flexibility and facilitate interaction between the
    different modules, Magento implements an **Event**/**Observer** pattern. This
    pattern allows modules to be loosely coupled.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多灵活性和促进不同模块之间的交互，Magento 实现了一个 **事件**/**观察者** 模式。这种模式允许模块松散耦合。
- en: 'There are two parts to this system, an **Event** dispatch with the object and
    event information and an **Observer** listening to a particular event:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统有两个部分，一个是带有对象和事件信息的 **事件** 分发，另一个是监听特定事件的 **观察者**：
- en: '![Events and observers](img/4195OS_01_05.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![事件和观察者](img/4195OS_01_05.jpg)'
- en: Event dispatch
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件分发
- en: 'Events are created or dispatched using the `Mage::dispatchEvent()` function.
    The core team has already created several events on critical parts of the core.
    For example, the Model abstract class `Mage_Core_Model_Abstract` calls two protected
    functions every time a model is saved: `_beforeSave()` and `_afterSave()` on each
    of these methods two event are fired.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Mage::dispatchEvent()` 函数创建或分发事件。核心团队已经在核心的关键部分创建了几个事件。例如，模型抽象类 `Mage_Core_Model_Abstract`
    在每次保存模型时都会调用两个受保护的函数：`_beforeSave()` 和 `_afterSave()`，在这些方法上分别触发两个事件。
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each function fires a generic `model_save_after` event, and then a dynamic version
    based on the type of object being saved. This gives us a wide range of possibilities
    to manipulate objects through observers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都会触发一个通用的 `model_save_after` 事件，然后基于正在保存的对象类型触发一个动态版本。这为我们通过观察者操作对象提供了广泛的可能性。
- en: The `Mage::dispatchEvent()` method takes two parameters, the first is the event
    name and the second is an array of data that is received by the observer. We can
    pass values or objects in this array. This comes in handy if we want to manipulate
    the objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mage::dispatchEvent()` 方法接受两个参数，第一个是事件名称，第二个是观察者接收到的数据数组。我们可以在数组中传递值或对象。如果我们想操作对象，这会很有用。'
- en: 'In order to understand the details of the event system, let''s take a look
    at the `dispatchEvent()` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解事件系统的细节，让我们看看 `dispatchEvent()` 方法：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function is actually an alias to the `dispatchEvent()` function inside
    the App core class, located in `Mage_Core_Model_App`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实际上是 App 核心类内部 `dispatchEvent()` 函数的一个别名，位于 `Mage_Core_Model_App`：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `dispatchEvent()` method actually does all the work on the **Event**/**Observer**
    model:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatchEvent()` 方法实际上在 **事件**/**观察者** 模型上做了所有的工作：'
- en: It gets the Magento configuration object.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取 Magento 配置对象。
- en: Then, it walks through the observer's node children, checking if the defined
    observer is listening to the current event.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它遍历观察者的节点子代，检查定义的观察者是否正在监听当前事件。
- en: For each of the available observers, the dispatch event tries to instantiate
    the observer object.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个可用的观察者，事件分发尝试实例化观察者对象。
- en: Lastly, Magento tries to call the corresponding observer function mapped to
    this particular event.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Magento 尝试调用映射到该特定事件的相应观察者函数。
- en: Observer bindings
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者绑定
- en: 'Now, dispatching an event is only part of the equation. We also need to tell
    Magento which observer is listening to each event. Not to our surprise, observers
    are specified through the `config.xml` file. As we saw before, the `dispatchEvent()`
    function queries the configuration object for available observers. Let''s take
    a look at an example `config.xml` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分发事件只是方程的一部分。我们还需要告诉 Magento 哪个观察者正在监听每个事件。不出所料，观察者是通过 `config.xml` 文件指定的。正如我们之前看到的，`dispatchEvent()`
    函数查询配置对象以获取可用的观察者。让我们看看一个示例 `config.xml` 文件：
- en: '[PRE24]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The event node can be specified in each of the configuration sections (admin,
    global, frontend, and so on) and we can specify multiple `event_name` children
    nodes. The `event_name` node has to match the event name used in the `dispatchEvent()`
    function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 事件节点可以在每个配置部分（admin、global、frontend 等）中指定，并且我们可以指定多个 `event_name` 子节点。`event_name`
    节点必须与 `dispatchEvent()` 函数中使用的的事件名称匹配。
- en: Inside each `event_name` node, we have a single observer node that can contain
    multiple observers, each with a unique identifier.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 `event_name` 节点内部，我们有一个单独的观察者节点，它可以包含多个观察者，每个观察者都有一个唯一的标识符。
- en: 'Observer nodes have two properties, `<class>`, which points to our observer
    model class, and `<method>`, which points to the actual method inside the observer
    class. Let''s analyze an example observer class definition:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者节点有两个属性，`<class>`，它指向我们的观察者模型类，以及 `<method>`，它指向观察者类中的实际方法。让我们分析一个示例观察者类定义：
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One interesting thing about observer models is that they don't extend to any
    other Magento class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模型的一个有趣之处在于，它们并不扩展到任何其他 Magento 类。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered many important and fundamental topics about Magento:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了关于 Magento 的许多重要和基本主题：
- en: Architecture
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: Folder structure
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: Routing system
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由系统
- en: MVC patterns
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 模式
- en: Events and observers
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件和观察者
- en: Configuration scope
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置范围
- en: While this may seem overwhelming at first sight, it is just the tip of the iceberg.
    There is a lot more to learn about each of these topics and Magento. The purpose
    of this chapter is to make developers aware of all the important components of
    the platform, from the configuration object to the way the event/object pattern
    is implemented.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看可能觉得令人压倒，但这只是冰山一角。关于这些主题以及 Magento，还有很多东西要学习。本章的目的是让开发者了解平台的所有重要组件，从配置对象到事件/对象模式实现的方式。
- en: Magento is a powerful and flexible system and much more than an e-commerce platform.
    The core team has put a lot of effort in making Magento a powerful framework.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 是一个强大且灵活的系统，远不止是一个电子商务平台。核心团队投入了大量努力，使 Magento 成为一个强大的框架。
- en: In later chapters, we will not only review all these concepts in more detail,
    but we will also apply them in a practical manner by building our own extensions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们不仅将更详细地回顾所有这些概念，而且将通过构建我们自己的扩展来以实际的方式应用它们。
