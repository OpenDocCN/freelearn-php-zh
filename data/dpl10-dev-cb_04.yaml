- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Extending Drupal with Custom Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义代码扩展Drupal
- en: The greatest component of Drupal is its extensibility through modules. In this
    chapter, we will explore how to create a custom module that can be installed on
    your Drupal site. This chapter will explain how PSR-4 autoloading works with extensions
    and how to leverage class autoloading. You will be able to create a controller
    for a custom page and specify additional permissions to check whether the user
    has them. You will also understand what hooks and events in Drupal are, and how
    to interact with them. This chapter also lays the foundations for the following
    chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal最伟大的组成部分是通过模块的可扩展性。在本章中，我们将探讨如何创建一个可以在你的Drupal站点上安装的自定义模块。本章将解释PSR-4自动加载如何与扩展一起工作，以及如何利用类自动加载。你将能够为自定义页面创建控制器并指定额外的权限以检查用户是否拥有它们。你还将了解Drupal中的钩子和事件是什么，以及如何与之交互。本章还为后续章节奠定了基础。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating a module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模块
- en: Providing configuration settings for your module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的模块提供配置设置
- en: Defining permissions and checking whether a user has access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义权限并检查用户是否有访问权限
- en: Hooking into Drupal to react to entity changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩入Drupal以响应实体更改
- en: Creating an event subscriber to react to events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个事件订阅者以响应事件
- en: Creating a custom Drush command
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义Drush命令
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the full code used in this chapter on GitHub: [https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的完整代码：[https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04)
- en: Creating a module
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模块
- en: The first step to extending Drupal is to create a custom module. Although the
    task sounds daunting, it can be accomplished in a few simple steps. Modules can
    provide functionalities and customizations for functionalities provided by other
    modules, or they can be used as a way to contain the configuration and a site’s
    state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Drupal的第一步是创建一个自定义模块。尽管这项任务听起来令人畏惧，但可以通过几个简单的步骤完成。模块可以提供其他模块提供的功能性和定制，或者它们可以用作包含配置和站点状态的方式。
- en: In this recipe, we will create a module by defining its `modulename.info.yml`
    file, a file containing information that Drupal uses to discover extensions and
    install the module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过定义其`modulename.info.yml`文件来创建一个模块，这是一个包含Drupal用于发现扩展和安装模块的信息的文件。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In your `web/modules` directory, create a new directory called `custom` and
    then another directory named `mymodule` inside it. This will be your module’s
    directory. Using the command line, you may create the directory with the following
    command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`web/modules`目录中，创建一个名为`custom`的新目录，然后在其中创建一个名为`mymodule`的子目录。这将是你模块的目录。使用命令行，你可以使用以下命令创建目录：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create the required directories.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建所需的目录。
- en: Create a `mymodule.info.yml` file in your module’s directory. This will contain
    the metadata that identifies the module to Drupal.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的模块目录中创建一个名为`mymodule.info.yml`的文件。这将包含标识模块给Drupal的元数据。
- en: 'Add a line to the `mymodule.info.yml` file to provide a name for the module
    with the `name` key:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mymodule.info.yml`文件中添加一行，使用`name`键为模块提供名称：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We must define the type of extension with the key type. Drupal does not assume
    the extension type just by directory location alone:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须使用键`type`定义扩展的类型。Drupal不会仅通过目录位置来假设扩展类型：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `description` key allows you to provide extra information about your module,
    which will be displayed on the module’s list page:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`description`键允许你提供有关模块的额外信息，这些信息将在模块列表页面上显示：'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Extensions are required to provide a `core_version_requirement` that identifies
    what versions of Drupal core the module is compatible with, using a semantic versioning
    constraint:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展需要提供一个`core_version_requirement`，以使用语义化版本控制约束来标识模块与哪些版本的Drupal核心兼容：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the `mymodule.info.yml` file, which looks as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`mymodule.info.yml`文件，其内容如下：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, create a file named `mymodule.module` in your `module` file. This is the
    extension file that will allow us to add hook definitions. It is a regular PHP
    file, but the file extension matches its extension type of module.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你的`module`文件中创建一个名为`mymodule.module`的文件。这是允许我们添加钩子定义的扩展文件。它是一个普通的PHP文件，但文件扩展名与其扩展类型匹配。
- en: 'For this example, we will provide a hook that renders a message on each payload:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将提供一个在每次有效载荷上渲染消息的钩子：
- en: '[PRE11]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This implements `hook_page_top`, which is called whenever a page is rendered.
    It uses the messenger service to add a status message to the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了 `hook_page_top`，每当页面被渲染时都会被调用。它使用消息传递服务向页面添加状态消息。
- en: 'Install your module using Drush:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Drush 安装您的模块：
- en: '[PRE18]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Visit your Drupal site. The `Hello world!` message will be added to each page:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您的 Drupal 网站。`Hello world!` 消息将被添加到每个页面：
- en: '![Figure 4.1 – Drupal page displaying Hello world!](img/Figure_4.01_B18548.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 显示“Hello world!”的 Drupal 页面](img/Figure_4.01_B18548.jpg)'
- en: Figure 4.1 – Drupal page displaying Hello world!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 显示“Hello world!”的 Drupal 页面
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Drupal utilizes `info.yml` files to define extensions. Drupal has an extension
    discovery system that locates these files and parses them to discover modules.
    The extension discovery will scan your entire Drupal code base, giving the Drupal
    core directory priority.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 利用 `info.yml` 文件来定义扩展。Drupal 有一个扩展发现系统，它会定位这些文件并解析它们以发现模块。扩展发现将扫描您的整个
    Drupal 代码库，并将 Drupal 核心目录优先考虑。
- en: In this recipe, we provided `>=10` for the `core_version_requirement` constraint.
    This constraint allows your module to work with a minimum of Drupal 10.0.0 but
    also be compatible with Drupal 11 or greater, simplifying maintenance when the
    next major version of Drupal core is released. If you know your code is not compatible
    with a previous minor version, it could be updated to `>=10.1.0` or even a specific
    patch value of `>=10.2.1`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们为 `core_version_requirement` 约束提供了 `>=10`。这个约束允许您的模块与最低的 Drupal 10.0.0
    版本兼容，同时也与 Drupal 11 或更高版本兼容，简化了在下一个 Drupal 核心主要版本发布时的维护工作。如果您知道您的代码与之前的次要版本不兼容，它可能需要更新到
    `>=10.1.0` 或甚至特定的补丁值 `>=10.2.1`。
- en: One method to integrate with Drupal is through its hook system. During runtime,
    other modules may invoke a hook that other modules can implement to perform actions
    or modify data. Our recipe implemented the `hook_page_top` hook. This hook is
    part of the page rendering life cycle and allows you to add renderable content
    at the very top of the page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一种与 Drupal 集成的方法是使用其钩子系统。在运行时，其他模块可能会调用其他模块可以实现的钩子，以执行操作或修改数据。我们的配方实现了 `hook_page_top`
    钩子。这个钩子是页面渲染生命周期的一部分，允许您在页面的最顶部添加可渲染内容。
- en: Module namespaces
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块命名空间
- en: Drupal uses the PSR-4 standard developed by the **PHP Framework Interoperability
    Group** (**PHP-FIG**). The PSR-4 standard is for package-based PHP namespace autoloading
    of classes and is used by most libraries and frameworks, including Laravel and
    Symfony. It defines a standard to understand how to automatically include classes
    based on a namespace and class name. Drupal modules have their own namespaces
    under the Drupal root namespace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 使用由 **PHP 框架互操作性小组**（**PHP-FIG**）开发的 PSR-4 标准。PSR-4 标准是针对基于包的 PHP 命名空间自动加载类的，并被大多数库和框架使用，包括
    Laravel 和 Symfony。它定义了一个标准，以了解如何根据命名空间和类名自动包含类。Drupal 模块在 Drupal 根命名空间下有自己的命名空间。
- en: Using the module from the recipe, our PHP namespace will be `Drupal\mymodule`,
    which represents the `web/modules/mymodule/src` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配方中的模块，我们的 PHP 命名空间将是 `Drupal\mymodule`，这代表 `web/modules/mymodule/src` 文件夹。
- en: With PSR-4, files need to contain only one class, interface, or trait. These
    files need to have the same filename as the containing class, interface, or trait
    name. This allows a class loader to resolve a namespace as a directory path and
    know the class’s filename. The file can then be automatically loaded when it is
    used in a file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PSR-4，文件只需要包含一个类、接口或特质。这些文件需要与包含的类、接口或特质的名称具有相同的文件名。这允许类加载器将命名空间解析为目录路径，并知道类的文件名。当文件在文件中使用时，它将被自动加载。
- en: Creating a composer.json file
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 composer.json 文件
- en: If you are writing a custom module that will only be used on your site, this
    is not necessary. However, if you plan to contribute your code to Drupal.org and
    distribute it, you should provide a `composer.json` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个仅将在您的网站上使用的自定义模块，这并不是必需的。然而，如果您计划将您的代码贡献给 Drupal.org 并分发它，您应该提供一个 `composer.json`
    文件。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Projects on Drupal.org are not required to create a `composer.json` file. If
    a project does not, one will be automatically generated for it based on the contents
    of its `info.yml` file. That is why it is recommended to create one: to be explicit.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal.org 上的项目不需要创建 `composer.json` 文件。如果没有，将根据其 `info.yml` 文件的内容自动为其生成一个。这就是为什么建议创建一个的原因：为了明确。
- en: 'Create a `composer.json` file in your module directory. It will look similar
    to the `mymodule.info.yml` file but as JSON:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的模块目录中创建一个 `composer.json` 文件。它看起来与 `mymodule.info.yml` 文件类似，但格式为 JSON：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `name` key should be prefixed with `drupal/` to identify it is in the Drupal
    package namespace. The type is prefixed with `drupal-` for compatibility with
    the Composer Installers package, which we covered in [*Chapter 1*](B18548_01.xhtml#_idTextAnchor020),
    *Up and Running* *with Drupal*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 键应该以 `drupal/` 前缀开头，以标识它位于 Drupal 包命名空间中。类型以 `drupal-` 前缀开头，以与我们在 [*第
    1 章*](B18548_01.xhtml#_idTextAnchor020) 中介绍的 *Up and Running with Drupal* 的 Composer
    安装程序包兼容。'
- en: '`core_version_requirement` is converted into Composer’s dependency definition
    and targets the `drupal/core` package.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`core_version_requirement` 被转换为 Composer 的依赖定义，并针对 `drupal/core` 包。'
- en: There’s more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are more details about Drupal modules and the module `info.yml` files
    that we can explore.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Drupal 模块和模块 `info.yml` 文件，我们可以探索更多细节。
- en: Module dependencies
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块依赖项
- en: Modules can define dependencies to ensure that those modules are installed before
    your module can be installed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以定义依赖项以确保在安装你的模块之前安装那些模块。
- en: 'Here is an example from the `info.yml` file for the `Pathauto` module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `Pathauto` 模块的 `info.yml` 文件的一个示例：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `dependencies` key specifies that the `ctools` path from Drupal core and
    `token` module must be installed first before the `Pathauto` module can be installed.
    In the *Adding and managing modules and themes with Composer* recipe from [*Chapter
    1*](B18548_01.xhtml#_idTextAnchor020), *Up and Running with Drupal*, they were
    automatically installed when we installed the `Pathauto` module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies` 键指定在安装 `Pathauto` 模块之前必须先安装来自 Drupal 核心的 `ctools` 路径和 `token`
    模块。在 [*第 1 章*](B18548_01.xhtml#_idTextAnchor020) 的 *Up and Running with Drupal*
    中，当我们安装 `Pathauto` 模块时，它们会自动安装。'
- en: Drupal has always supported modules that contain additional submodules, an uncommon
    practice in other systems. As Drupal adopted Composer, it enforced namespaced
    dependencies in the `info.yml` file. This identifies the root package and the
    specific module it contains to be installed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 一直支持包含附加子模块的模块，这在其他系统中是不常见的做法。随着 Drupal 采用了 Composer，它强制在 `info.yml`
    文件中实施命名空间依赖。这标识了根包以及它包含要安装的特定模块。
- en: If your module has dependencies and you plan to contribute it, remember to create
    a `composer.json` file and define your dependencies so that they will be downloaded
    with Composer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块有依赖项并且你打算贡献它，请记住创建一个 `composer.json` 文件并定义你的依赖项，这样它们就会与 Composer 一起下载。
- en: See more…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: 'Refer to the *PSR-4: Autoloading* *specification*: [https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参考关于 *PSR-4: 自动加载* 的 *规范*：[https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)'
- en: 'Changing a record by adding `core_version_requirement` and the reasonings behind
    its addition: [https://www.drupal.org/node/3070687](https://www.drupal.org/node/3070687)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加 `core_version_requirement` 和其添加的原因来更改记录：[https://www.drupal.org/node/3070687](https://www.drupal.org/node/3070687)
- en: '[Drupal.org](http://Drupal.org) documentation for creating a module: [https://www.drupal.org/docs/creating-custom-modules](https://www.drupal.org/docs/creating-custom-modules)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Drupal.org](http://Drupal.org) 的模块创建文档：[https://www.drupal.org/docs/creating-custom-modules](https://www.drupal.org/docs/creating-custom-modules)'
- en: Providing configuration settings for your module
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的模块提供配置设置
- en: Modules can leverage configuration settings to allow end users to modify how
    they operate. These pieces of configuration are YAML files. Modules can also provide
    default configuration for other modules when they are installed. Once the module
    has been installed, the default configuration it provides is imported into Drupal.
    Modules may also modify existing configurations programmatically through an installation
    hook or update hooks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以利用配置设置来允许最终用户修改它们的工作方式。这些配置项是 YAML 文件。模块还可以在安装时为其他模块提供默认配置。一旦模块被安装，它提供的默认配置就会被导入到
    Drupal 中。模块还可以通过安装钩子或更新钩子程序化地修改现有配置。
- en: In this recipe, we will provide a configuration that creates a new contact form
    and then manipulates it through an update hook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将提供一个配置，创建一个新的联系表单，然后通过更新钩子来操作它。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires a custom module, like the one created in the first recipe.
    We will refer to the module as `mymodule` throughout this recipe. Use your module’s
    appropriate name where necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要一个自定义模块，就像第一个菜谱中创建的那样。在这个菜谱中，我们将把这个模块称为 `mymodule`。在需要的地方使用你模块的适当名称。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a `config` folder in your module’s directory. Then, in that directory,
    create an `install` directory. Drupal looks for YAML configuration in this installation
    directory:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的模块目录中创建一个 `config` 文件夹。然后，在那个目录中创建一个 `install` 目录。Drupal 在这个安装目录中查找 YAML
    配置：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `install` directory, create a `contact.form.contactus.yml` file to store
    the YAML definition of the contact form, `Contact Us`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `install` 目录中创建一个 `contact.form.contactus.yml` 文件来存储联系表单的 YAML 定义，即 `Contact
    Us`。
- en: 'Add the following YAML content to the `contact.form.contactus.yml` file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 YAML 内容添加到 `contact.form.contactus.yml` 文件中：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This YAML file represents the exported configuration object for a contact form.
    `id` is the contact form’s machine name and `label` is the human display name
    for the user interface. The `recipients` key is a YAML array of valid email addresses.
    The `reply` key is a string of text for the `Auto-reply` message. Finally, `weight`
    defines the ordering of the form on the administrative list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 YAML 文件代表了一个联系表单的导出配置对象。`id` 是联系表单的机器名，`label` 是用户界面的显示名称。`recipients` 键是一个有效的电子邮件地址的
    YAML 数组。`reply` 键是用于 `自动回复` 消息的文本字符串。最后，`weight` 定义了表单在管理列表中的顺序。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Normally, you do not manually write configuration YAML like this. You will generally
    export it individually from the Drupal site if needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会手动编写像这样的配置 YAML。如果需要，你通常将从 Drupal 网站中单独导出它。
- en: 'Install the module using Drush:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Drush 安装模块：
- en: '[PRE31]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The **Contact Us** form will now be located on the **Contact forms** overview
    page, located under **Structure**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 **联系我们** 表单将位于 **联系表单** 概览页上，位于 **结构** 之下。
- en: Create a `mymodule.post_update.php` file in the module’s directory. This file
    contains update hooks to be run after schema changes.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的目录中创建一个 `mymodule.post_update.php` 文件。这个文件包含在架构更改后要运行的更新钩子。
- en: 'We will create a function called `mymodule_post_update_change_contactus_reply()`
    that will be executed by the update system to modify the contact form’s configuration:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `mymodule_post_update_change_contactus_reply()` 的函数，该函数将由更新系统执行以修改联系表单的配置：
- en: '[PRE32]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This function uses the entity’s class to load the contact form entity object.
    It loads the **Contact Us** contact form, which our module has provided, and sets
    the reply property to its new value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用实体的类来加载联系表单实体对象。它加载了 **联系我们** 的联系表单，这是我们的模块提供的，并将回复属性设置为新的值。
- en: 'Run updates for the Drupal site using Drush:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Drush 为 Drupal 网站运行更新：
- en: '[PRE44]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Drush will list the updates to be applied, including the one you just wrote.
    The function comment of an `update` function will be output in the list of updates
    to be applied. After reviewing the changes, you can tell Drush to proceed by entering
    `yes` on the command line.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Drush 将列出要应用的所有更新，包括你刚刚编写的更新。更新函数的注释将被输出到要应用更新的列表中。在审查更改后，你可以在命令行中输入 `yes` 来告诉
    Drush 继续执行。
- en: Review the **Contact Us** form settings and verify that the reply message has
    been set.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查 **联系我们** 表单设置并验证回复消息是否已设置。
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Drupal’s `moduler_installer` service, provided through `\Drupal\Core\Extension\ModuleInstaller`,
    ensures that configuration items defined in the module’s `config` folder are processed
    on installation. When a module is installed, the `config.installer` service, provided
    through `\Drupal\Core\Config\ConfigInstaller`, is called to process the module’s
    default configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 的 `moduler_installer` 服务，通过 `\Drupal\Core\Extension\ModuleInstaller`
    提供，确保在安装时处理模块的 `config` 文件夹中定义的配置项。当安装模块时，通过 `\Drupal\Core\Config\ConfigInstaller`
    提供的 `config.installer` 服务被调用以处理模块的默认配置。
- en: If the `config.installer` service attempts to import configuration from a module’s
    `config/install` folder that already exists, an exception will be thrown. Modules
    cannot provide duplicated configuration or modify existing configuration objects
    via the YAML files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `config.installer` 服务尝试从模块的 `config/install` 文件夹导入已存在的配置，将抛出异常。模块不能通过 YAML
    文件提供重复的配置或修改现有的配置对象。
- en: 'Since modules cannot adjust configuration objects through YAML files provided
    to Drupal, they can utilize the update system to modify the configuration. The
    update system has two update processes: schema updates and post updates. Since
    we did not make schema-level changes, we used the post-update process. This allows
    us to make modifications to existing configuration objects.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块不能通过提供给Drupal的YAML文件调整配置对象，它们可以利用更新系统来修改配置。更新系统有两个更新过程：模式更新和后续更新。由于我们没有进行模式级别的更改，我们使用了后续更新过程。这允许我们对现有配置对象进行修改。
- en: In [*Chapter 7*](B18548_07.xhtml#_idTextAnchor240), *Creating Forms with the
    Form API*, we will create a form for modifying configuration settings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18548_07.xhtml#_idTextAnchor240)《使用表单API创建表单》中，我们将创建一个用于修改配置设置的表单。
- en: There’s more…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We will now dive into some important notes when working with modules and configurations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨在处理模块和配置时的一些重要注意事项。
- en: Configuration subdirectories
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置子目录
- en: 'There are three directories that the configuration management system will inspect
    in a module’s `config` folder, which are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理系统将在模块的`config`文件夹中检查三个目录，具体如下：
- en: '`install`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install`'
- en: '`optional`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可选`'
- en: '`schema`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema`'
- en: 'The `install` folder specifies the configuration that will be imported. If
    the configuration object exists, the installation will fail. The `optional` folder
    contains the configuration that will be installed if the following conditions
    are met:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`文件夹指定要导入的配置。如果配置对象存在，安装将失败。`optional`文件夹包含在满足以下条件时将安装的配置：'
- en: The configuration does not already exist
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置尚不存在
- en: It is a configuration entity
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个配置实体
- en: Its dependencies can be met
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的依赖关系可以满足
- en: If any one of the conditions fails, the configuration will not be installed,
    but it will not halt the module’s installation process. The `schema` folder provides
    configuration object definitions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个条件失败，配置将不会安装，但不会停止模块的安装过程。`schema`文件夹提供配置对象定义。
- en: Modifying the existing configuration on installation
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在安装时修改现有配置
- en: The configuration management system does not allow modules to provide configuration
    on an installation that already exists. For example, if a module tries to provide
    `system.site` and defines the site’s name, it would fail to install. This is because
    the `system` module provides this configuration object when you first install
    Drupal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理系统不允许模块在已存在的安装上提供配置。例如，如果模块尝试提供`system.site`并定义站点名称，它将无法安装。这是因为当您首次安装Drupal时，`system`模块提供了这个配置对象。
- en: Modules may also have a `.install` file, such as `mymodule.install` for our
    recipe’s module. This file is where modules may implement the `hook_install` hook
    provided by Drupal, along with schema update hooks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可能有一个`.install`文件，例如我们食谱模块的`mymodule.install`。这个文件是模块可能实现Drupal提供的`hook_install`钩子和模式更新钩子的地方。
- en: '`hook_install()` is executed during the module’s installation process. The
    following code will update the site’s title to `Drupal Development Cookbook`!
    on the module’s installation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`hook_install()`在模块的安装过程中执行。以下代码将在模块安装时将站点标题更新为`Drupal Development Cookbook`！'
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Configurable objects are immutable by default, meaning they cannot be changed
    or saved when loaded by the default `config` service. To modify a configuration
    object, you will need to use the configuration factory to receive an editable
    instance of a configuration object. This object can have `set` and `save` methods
    that are executed to update the configuration in a configuration object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置对象默认是不可变的，这意味着当通过默认的`config`服务加载时，它们不能被更改或保存。要修改配置对象，您需要使用配置工厂来接收一个可编辑的配置对象实例。这个对象可以有`set`和`save`方法，这些方法被执行以更新配置对象中的配置。
- en: Schema update hooks
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式更新钩子
- en: This recipe mentioned schema update hooks. These are intended to be used to
    make changes to any database schema or entity field definitions. When the update
    system runs, the schema hooks are run first; then, post-updates are executed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱提到了模式更新钩子。这些钩子旨在用于更改任何数据库模式或实体字段定义。当更新系统运行时，首先运行模式钩子；然后执行后续更新。
- en: The schema update hooks are defined as `hook_update_N`, where `N` is a numeric
    schema version value. When schema update hooks are executed, they are run in order
    of their schema version. Generally, the base schema version is based on the major
    version of Drupal core or the module’s versioning. In custom code, it can be anything
    you wish.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 架构更新钩子被定义为 `hook_update_N`，其中 `N` 是一个数字架构版本值。当架构更新钩子被执行时，它们将按照它们的架构版本顺序运行。通常，基本架构版本基于
    Drupal 核心的主版本或模块的版本。在自定义代码中，它可以是你想要的任何东西。
- en: 'The naming conventions for schema updates have been under discussion since
    Drupal 8 regarding the support of semantic versioning in contributed projects.
    These naming conventions are discussed in the following issues:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 架构更新的命名约定自 Drupal 8 以来一直在讨论中，涉及对贡献项目的语义版本支持。以下问题中讨论了这些命名约定：
- en: '[https://www.drupal.org/project/drupal/issues/3106712](https://www.drupal.org/project/drupal/issues/3106712)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.drupal.org/project/drupal/issues/3106712](https://www.drupal.org/project/drupal/issues/3106712)'
- en: '[https://www.drupal.org/project/drupal/issues/3010334](https://www.drupal.org/project/drupal/issues/3010334)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.drupal.org/project/drupal/issues/3010334](https://www.drupal.org/project/drupal/issues/3010334)'
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Update API documentation on Drupal.org: [https://www.drupal.org/docs/drupal-apis/update-api](https://www.drupal.org/docs/drupal-apis/update-api)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Drupal.org 上更新 API 文档：[https://www.drupal.org/docs/drupal-apis/update-api](https://www.drupal.org/docs/drupal-apis/update-api)
- en: '[*Chapter 7*](B18548_07.xhtml#_idTextAnchor240), *Creating Forms with the*
    *Form API*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B18548_07.xhtml#_idTextAnchor240)，*使用表单 API 创建表单*'
- en: Defining permissions and checking whether a user has access
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义权限和检查用户是否有权访问
- en: In Drupal, roles and permissions are used to define robust access control lists
    for users. Modules use permissions to check whether the current user has access
    to perform an action, view specific items, or do other operations. Modules then
    define the permissions that are used so that Drupal is aware of them. Developers
    can then construct roles, which are made up of enabled permissions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 中，角色和权限被用来定义用户强大的访问控制列表。模块使用权限来检查当前用户是否有权执行操作、查看特定项目或执行其他操作。然后模块定义了使用的权限，以便
    Drupal 能够了解它们。开发者可以构建角色，这些角色由启用的权限组成。
- en: In this recipe, we will define new permission(s) in a module that is used to
    check if the user can mark content as promoted to the front page or sticky at
    the top of lists. This permission will be used in an entity field access hook
    to deny access to the fields if the user is missing the permission.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将在一个模块中定义新的权限，该模块用于检查用户是否可以将内容标记为推广到首页或粘性在列表顶部。此权限将用于实体字段访问钩子，如果用户缺少权限，则拒绝访问字段。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new module, as we did in the first recipe. We will refer to the module
    as `mymodule` throughout this recipe. Use your module’s name in the following
    recipe as appropriate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模块，就像我们在第一个配方中所做的那样。在这个配方中，我们将把这个模块称为 `mymodule`。在以下配方中，根据需要使用你的模块名称。
- en: Create a new Drupal user with the Content editor role. Drupal bypasses access
    checks for the first user. The secondary user will be required to demonstrate
    the permission.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的具有内容编辑角色的 Drupal 用户。Drupal 会绕过第一个用户的访问检查。次要用户将需要展示权限。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Permissions are stored in a `permissions.yml` file. Add a `mymodule.permissions.yml`
    file to the base directory of your module.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 权限存储在 `permissions.yml` 文件中。在你的模块基本目录中添加一个 `mymodule.permissions.yml` 文件。
- en: 'First, we will need to define the internal string used to identify this permission,
    such as `can` `promote nodes`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义用于识别此权限的内部字符串，例如 `can` `promote nodes`：
- en: '[PRE46]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each permission is a YAML array of data. We will need to provide a `title`
    key that will be displayed on the permissions page:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个权限都是一个包含数据的 YAML 数组。我们需要提供一个 `title` 键，它将在权限页面上显示：
- en: '[PRE47]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Permissions have a `description` key to provide details of the permission on
    the permissions page:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 权限有一个 `description` 键，用于在权限页面上提供权限的详细信息：
- en: '[PRE49]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Save your `mymodule.permissions.yml` file and edit the module’s `mymodule.module`
    file so that we may write our hook to use the permission.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的 `mymodule.permissions.yml` 文件，并编辑模块的 `mymodule.module` 文件，以便我们可以编写钩子来使用权限。
- en: 'In your `mymodule.module` file, add a function named `mymodule_entity_field_access`
    to implement `hook_entity_field_access`. This is invoked to control access at
    a granular level per field on entity forms:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `mymodule.module` 文件中，添加一个名为 `mymodule_entity_field_access` 的函数来实现 `hook_entity_field_access`。这将用于在实体表单的每个字段上以细粒度控制访问：
- en: '[PRE53]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Drupal uses access result value objects to handle access results. Access results
    may be neutral, forbidden, or allowed. Hooks implementing `hook_entity_field_access`
    must return an access result and cannot return `null`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal使用访问结果值对象来处理访问结果。访问结果可能是中立的、禁止的或允许的。实现`hook_entity_field_access`钩子的插件必须返回一个访问结果，并且不能返回`null`。
- en: 'In our hook, we will check the field name being checked. If the field name
    is `promote` or `sticky`, we will check whether the user has the `can promote
    nodes` permission and return that access result:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的钩子中，我们将检查正在检查的字段名称。如果字段名称是`promote`或`sticky`，我们将检查用户是否有`can promote nodes`权限，并返回该访问结果：
- en: '[PRE61]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The access result object has an `allowedIf` method that returns an appropriate
    result based on the parameter provided. In this case, it will return `AccessResult::allowed()`
    if the user has the permission or `AccessResult::neutral()` if not.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 访问结果对象有一个`allowedIf`方法，根据提供的参数返回适当的结果。在这种情况下，如果用户有权限，它将返回`AccessResult::allowed()`，如果没有，则返回`AccessResult::neutral()`。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Drupal’s access system requires explicit allowance. If an access result is neutral,
    the system will keep processing access results. If an access result is returned
    as forbidden or allowed, the access checks stop, and that result is used. If the
    ending result is neutral, access is not granted since it was not explicitly allowed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal的访问系统需要明确的允许。如果一个访问结果是中立的，系统将继续处理访问结果。如果一个访问结果被返回为禁止或允许，访问检查将停止，并使用该结果。如果最终结果是中立的，由于没有明确允许，访问将不被授予。
- en: 'New permissions are not granted to roles automatically. In another browser
    or guest tab, log in as a user with the Content editor role and create a piece
    of content. The **Promotion options** section of the sidebar will be missing since
    we do not have field access:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新权限不会自动授予角色。在另一个浏览器或访客标签页中，以具有内容编辑角色的用户身份登录，并创建一个内容项。由于我们没有字段访问权限，侧边栏的**推广选项**部分将缺失：
- en: '![Figure 4.2 – Promotion options are hidden due to missing permissions](img/Figure_4.02_B18548.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 由于缺少权限，推广选项被隐藏](img/Figure_4.02_B18548.jpg)'
- en: Figure 4.2 – Promotion options are hidden due to missing permissions
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 由于缺少权限，推广选项被隐藏
- en: 'As your administrative user, go to **People** and then to **Permissions** to
    add your permission for the Content editor role in the **My** **Module** section:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为您的管理用户，请前往**人员**然后进入**权限**，在**我的****模块**部分添加您对内容编辑角色的权限：
- en: '![Figure 4.3 – Adding the permission to the Content editor role](img/Figure_4.03_B18548.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 向内容编辑角色添加权限](img/Figure_4.03_B18548.jpg)'
- en: Figure 4.3 – Adding the permission to the Content editor role
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 向内容编辑角色添加权限
- en: 'Using your Content editor user, try and create a piece of content once more.
    The **Promotion options** section in the sidebar will be present:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的内容编辑用户，再次尝试创建一个内容项。侧边栏中的**推广选项**部分将出现：
- en: '![Figure 4.4 – The Promotion options section appears once the permission has
    been granted](img/Figure_4.04_B18548.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 授予权限后，推广选项部分出现](img/Figure_4.04_B18548.jpg)'
- en: Figure 4.4 – The Promotion options section appears once the permission has been
    granted
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 授予权限后，推广选项部分出现
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Permissions and roles are provided by the `User` module. The `user.permissions`
    service discovers the `permissions.yml` file provided by installed modules. By
    default, the service is defined through the `\``Drupal\user\PermissionHandler`
    class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 权限和角色由`User`模块提供。`user.permissions`服务发现由安装的模块提供的`permissions.yml`文件。默认情况下，服务是通过`\Drupal\user\PermissionHandler`类定义的。
- en: Drupal does not save a list of all available permissions. The permissions for
    a system are loaded when the permissions page is loaded. Roles contain an array
    of permissions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal不会保存所有可用权限的列表。当加载权限页面时，系统的权限被加载。角色包含一个权限数组。
- en: When checking a user’s access for permission, Drupal checks all the user’s roles
    to see whether they support that permission.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查用户的权限访问时，Drupal会检查所有用户角色，以查看它们是否支持该权限。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can pass undefined permissions to a user access check and not receive an
    error. The access check will simply fail unless the user is UID 1, which bypasses
    access checks. In Drupal, user UID 1 is the root user and is not beholden to security
    checks or permissions. Be careful when granting access to that account or using
    user 1 in testing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将未定义的权限传递给用户访问检查，而不会收到错误。除非用户是UID 1，否则访问检查将简单地失败。在Drupal中，UID 1是根用户，不受安全检查或权限的约束。在授予该账户访问权限或使用用户1进行测试时要小心。
- en: There’s more…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We will cover more ways to work with permissions in your modules in the upcoming
    sections.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍更多在您的模块中处理权限的方法。
- en: Restricting access flag for permissions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权限的访问限制标志
- en: 'Permissions can be flagged as having a security risk if enabled; this can be
    done via the restrict access flag. When this flag is set to `restrict access:
    TRUE`, it will add a warning to the permission’s description.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '如果启用，权限可以标记为具有安全风险；这可以通过设置访问限制标志来完成。当此标志设置为`restrict access: TRUE`时，它将在权限的描述中添加一个警告。'
- en: 'This allows module developers to provide more context regarding the amount
    of control a permission may give a user:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许模块开发者提供更多关于权限可能赋予用户的控制量的背景信息：
- en: '![Figure 4.5 – Example of permissions with the restrict access flag](img/Figure_4.05_B18548.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 带有访问限制标志的权限示例](img/Figure_4.05_B18548.jpg)'
- en: Figure 4.5 – Example of permissions with the restrict access flag
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 带有访问限制标志的权限示例
- en: 'The permission definition from our recipe would look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从配方中定义的权限看起来会是这样：
- en: '[PRE77]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Defining permissions programmatically
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过编程定义权限
- en: Permissions can be defined by a module programmatically or statically in a YAML
    file. A module needs to provide a `permission_callbacks` key in its `permissions.yml`
    file that contains either an array of callable methods or functions to define
    permissions dynamically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以通过模块以编程方式或静态方式在YAML文件中定义。模块需要在它的`permissions.yml`文件中提供一个`permission_callbacks`键，该键包含一个可调用的方法或函数数组，以动态定义权限。
- en: 'For example, the `Filter` module provides granular permissions based on the
    different text filters created in Drupal:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Filter`模块根据在Drupal中创建的不同文本过滤器提供细粒度的权限：
- en: '[PRE78]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This tells the `user_permissions` service to execute the permissions method
    of the `\Drupal\Filter\FilterPermissions` class. The method is expected to return
    an array that matches the same structure as that of the `permissions.yml` file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`user_permissions`服务执行`\Drupal\Filter\FilterPermissions`类的权限方法。该方法预期返回一个与`permissions.yml`文件相同结构的数组。
- en: See also…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: '[*Chapter 5*](B18548_05.xhtml#_idTextAnchor172), *Creating* *Custom Pages*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18548_05.xhtml#_idTextAnchor172)，*创建* *自定义页面*'
- en: Hooking into Drupal to react to entity changes
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Drupal钩入以响应实体更改
- en: One of the most common integration points is hooking into Drupal to react to
    the create, read, update, and delete operations of an entity. The entity system
    also has hooks to provide default values when instantiating a new entity and modifying
    it before it is saved.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的集成点之一是将Drupal钩入以响应实体的创建、读取、更新和删除操作。实体系统还有钩子，在实例化新实体并在保存之前修改它时提供默认值。
- en: In this recipe, we will create a hook that runs whenever new content is published
    and send an email to the site’s email address as a notification of the new content.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个钩子，每当新内容发布时都会运行，并发送一封电子邮件到网站的电子邮件地址作为新内容的通知。
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: First, create a file called `mymodule.module` in your `module` file. This is
    the module extension file that stores hook implementations.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的`module`文件中创建一个名为`mymodule.module`的文件。这是模块扩展文件，用于存储钩子实现。
- en: 'Next, we will implement a hook to listen for new node entities being inserted.
    Create a function named `mymodule_node_insert`, which is an implementation of
    the `hook_ENTITY_TYPE_insert` hook:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个钩子来监听新节点实体被插入。创建一个名为`mymodule_node_insert`的函数，它是`hook_ENTITY_TYPE_insert`钩子的实现：
- en: '[PRE79]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In our `insert` hook, we will check if the node was saved as published. If
    it was, we will send an email notification:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`insert`钩子中，我们将检查节点是否被保存为已发布。如果是，我们将发送电子邮件通知：
- en: '[PRE83]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: First, we check if the node has been published. The node entity type implements
    `EntityPublishedInterface`, which provides the `isPublished` method. If the node
    has been published, we fetch the site’s email address from the configuration.
    To send an email, we need to fetch the mail manager service. With the mail manager
    service, we invoke the `mail` method. The `module` and `key` parameters are used
    to invoke another hook in the module to generate the email’s content. The `to`
    parameter is where the email should be sent. `langcode` represents what language
    the email should be sent in. Finally, the `params` parameter provides context
    values to the hook, which generates the email content.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查节点是否已发布。节点实体类型实现了`EntityPublishedInterface`接口，该接口提供了`isPublished`方法。如果节点已发布，我们从配置中获取网站的电子邮件地址。要发送电子邮件，我们需要获取邮件管理器服务。使用邮件管理器服务，我们调用`mail`方法。`module`和`key`参数用于在模块中调用另一个钩子以生成电子邮件内容。`to`参数是电子邮件应发送的位置。`langcode`表示电子邮件应发送的语言。最后，`params`参数为生成电子邮件内容的钩子提供上下文值。
- en: 'We want to add a hook that listens when nodes are updated, as they may have
    first been saved as unpublished. Create a function named `mymodule_node_update`
    so that we can implement the `hook_ENTITY_TYPE_update` hook:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望添加一个钩子，监听节点更新时的情况，因为它们可能最初被保存为未发布。创建一个名为`mymodule_node_update`的函数，以便我们可以实现`hook_ENTITY_TYPE_update`钩子：
- en: '[PRE102]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In our `update` hook, we will check if the unchanged version of the node was
    published or not. We do not want to send duplicate emails. We only send an email
    if the node was previously unpublished and then became published:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`update`钩子中，我们将检查节点未更改的版本是否已发布。我们不希望发送重复的电子邮件。只有当节点之前未发布然后变为发布时，我们才发送电子邮件：
- en: '[PRE105]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: As you can see, this hook is nearly the same as our `insert` hook, but we check
    the values of the original node object. The entity storage sets the original property
    on an entity that has unchanged values from the database. This allows us to compare
    the previous values to the newly modified ones. In our hook, we verify that the
    original node was not already published before sending our email.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此钩子几乎与我们的`insert`钩子相同，但我们检查原始节点对象的值。实体存储在具有从数据库中未更改的值的实体上设置原始属性。这允许我们比较先前值和新的修改值。在我们的钩子中，我们在发送电子邮件之前验证原始节点尚未发布。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This hook uses the `node_published_update` key so that we can use different
    email text.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子使用`node_published_update`键，这样我们就可以使用不同的电子邮件文本。
- en: 'Now, we need to create a function named `mymodule_mail` that implements `hook_mail`.
    This will allow us to define the content for our email notifications:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为`mymodule_mail`的函数，该函数实现`hook_mail`。这将允许我们定义电子邮件通知的内容：
- en: '[PRE127]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `key` and `params` parameters are the values we passed to the mail manager’s
    `mail` method and how we can identify what content to generate. The `message`
    property is an array that represents the email to be sent, such as who the email
    is being sent to and its content.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`和`params`参数是我们传递给邮件管理器`mail`方法的值，以及我们如何识别要生成的内容。`message`属性是一个表示要发送的电子邮件的数组，例如收件人和内容。'
- en: 'In our `mail` hook, we will provide a different subject based on whether the
    email is sent for a newly published node or an `update` node that became published,
    along with a message:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`mail`钩子中，我们将根据电子邮件是针对新发布的节点还是变为发布的`update`节点提供不同的主题，以及一条消息：
- en: '[PRE129]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: We check the `key` value and set an appropriate email subject based on the keys
    we have defined. The `body` key in the message expects an array of text, which
    Drupal will convert into new lines.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`key`值，并根据我们定义的键设置适当的电子邮件主题。消息中的`body`键期望一个文本数组，Drupal将将其转换为新行。
- en: Now, whenever nodes are published, an email will be sent to the site’s email
    address, notifying the site administrator of the newly published content.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每当节点发布时，都会向网站的电子邮件地址发送电子邮件，通知网站管理员新发布的内容。
- en: How it works…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The entity system in Drupal has various hooks that it triggers to interact with
    entities when they are loaded, created (instantiation for a new entity), saved,
    or deleted. In this recipe, we listened to two post-save hooks. Once an entity
    has been saved, the entity storage’s post-save process invokes the `insert` hook
    for new entities or the `update` hook for existing entities.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal中的实体系统具有各种触发钩子，用于在实体加载、创建（新实体的实例化）、保存或删除时与实体交互。在本配方中，我们监听了两个保存后钩子。一旦实体已保存，实体存储的保存后过程将调用新实体的`insert`钩子或现有实体的`update`钩子。
- en: In this recipe, we used hooks that targeted a specific entity type. This allowed
    us to be more concise in our code and also type-hint the appropriate entity interface
    in our hooks. Each entity operation hook can also be implemented generically.
    If we were to use `hook_entity_insert` or `hook_entity_update`, they would be
    fired for any entity type, such as taxonomy terms or blocks. When using the more
    generic hook implementation, you need to use `\Drupal\Entity\EntityInterface`
    for your type hint and use the `getEntityTypeId` method to check the entity’s
    type.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了针对特定实体类型的钩子。这使我们能够在代码中更加简洁，并在钩子中使用适当的实体接口进行类型提示。每个实体操作钩子也可以通用实现。如果我们使用
    `hook_entity_insert` 或 `hook_entity_update`，它们将针对任何实体类型触发，例如分类术语或块。当使用更通用的钩子实现时，您需要使用
    `\Drupal\Entity\EntityInterface` 进行类型提示，并使用 `getEntityTypeId` 方法来检查实体的类型。
- en: 'The available hooks for the create, read, update, and delete operations of
    entities are documented on Drupal.org, along with details about each hook and
    examples: [https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的创建、读取、更新和删除操作的可用钩子已在 Drupal.org 上文档化，包括每个钩子的详细信息以及示例：[https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x).
- en: There’s more…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe covered hooking into the post-save hooks. In the following section,
    we will explore the other hooks that are available.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方涵盖了挂钩到后保存钩子。在下一节中，我们将探讨其他可用的钩子。
- en: Changing values before an entity is saved
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在保存实体之前更改值
- en: The `insert` and `update` hooks are triggered after an entity has been saved.
    There is also a pre-save hook that allows you to manipulate the entity before
    it is saved.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 和 `update` 钩子在实体保存后触发。还有一个预保存钩子，允许你在保存实体之前对其进行操作。'
- en: This hook is often used to populate empty values or ensure values match an expected
    state. For example, in the *Creating an editorial workflow with content moderation*
    recipe in [*Chapter 2*](B18548_02.xhtml#_idTextAnchor059), *Content Building Experience*,
    we used the `Content Moderation` module. The `Content Moderation` module uses
    the `hook_entity_presave()` hook to ensure the content is marked as published
    or unpublished based on the workflow’s state.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子通常用于填充空值或确保值与预期的状态相匹配。例如，在 *使用内容审核创建编辑工作流程* 的配方中，位于 [*第2章*](B18548_02.xhtml#_idTextAnchor059)，*内容构建体验*，我们使用了
    `Content Moderation` 模块。`Content Moderation` 模块使用 `hook_entity_presave()` 钩子来确保内容根据工作流程的状态被标记为已发布或未发布。
- en: Creating an event subscriber to react to events
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建事件订阅者以响应事件
- en: 'Drupal has two ways of integrating various parts of the system: using hooks
    or events. Hooks have been a part of Drupal for its entire lifespan and events
    were introduced in Drupal 8\. Unlike the hook system, which has implicit registration,
    the event dispatch system uses explicit registration for an event.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 有两种方式来集成系统的各个部分：使用钩子或事件。钩子一直是 Drupal 生命周期的一部分，而事件是在 Drupal 8 中引入的。与具有隐式注册的钩子系统不同，事件调度系统使用显式注册来注册事件。
- en: The events dispatcher system comes from the Symfony framework and allows components
    to easily interact with one another. Within Drupal, and integrated Symfony components,
    events are dispatched, and event subscribers can listen to the events and react
    to changes or other processes.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 事件调度器系统来自 Symfony 框架，允许组件轻松地相互交互。在 Drupal 中，以及集成的 Symfony 组件中，事件被调度，事件订阅者可以监听事件并对更改或其他过程做出反应。
- en: In this recipe, we will subscribe to the `RequestEvent` event, which fires when
    a request is first handled. If the user is not logged in, we will navigate them
    to the login page.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将订阅 `RequestEvent` 事件，该事件在请求首次处理时触发。如果用户未登录，我们将将其导航到登录页面。
- en: How to do it…
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create `src/EventSubscriber/RequestSubscriber.php` in your module.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的模块中创建 `src/EventSubscriber/RequestSubscriber.php`。
- en: 'Define the `RequestSubscriber` class, which implements the `EventSubscriberInterface`
    interface:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `RequestSubscriber` 类，该类实现了 `EventSubscriberInterface` 接口：
- en: '[PRE151]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'To satisfy the interface requirements, we must add a `getSubscribedEvents`
    method. This tells the system which events we are subscribing to and the method
    that needs to be invoked:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了满足接口要求，我们必须添加一个 `getSubscribedEvents` 方法。这告诉系统我们正在订阅哪些事件以及需要调用的方法：
- en: '[PRE158]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Event names are derived from the PHP class name for the event object. In the
    `getSubscribedEvent` method, we construct an associative array to be returned.
    The event class name is the key and our class method to invoke when that event
    is dispatched.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称是从事件对象的 PHP 类名派生出来的。在 `getSubscribedEvent` 方法中，我们构建一个关联数组以返回。事件类名是键，当分发该事件时将调用的我们的类方法。
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Priorities will be discussed in the *How it works...* section. It is provided
    in the example to resolve possible conflicts when the `dynamic_page_cache` module
    is enabled.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级将在 *如何工作...* 部分中讨论。它提供在 `dynamic_page_cache` 模块启用时解决可能冲突的示例。
- en: 'Create the `doAnonymousRedirect` method we specified, which will receive the
    `RequestEvent` object for the current request:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们指定的 `doAnonymousRedirect` 方法，它将接收当前请求的 `RequestEvent` 对象：
- en: '[PRE175]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: To prevent a redirect loop, we will use the `RouteMatch` service to get the
    current route object and verify that we are not already on the `user.login` route
    page.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止重定向循环，我们将使用 `RouteMatch` 服务来获取当前路由对象，并验证我们是否已经在 `user.login` 路由页面。
- en: Then, we check whether the user is anonymous and, if they are, set the event’s
    response to a redirect response.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查用户是否是匿名用户，如果是，将事件的响应设置为重定向响应。
- en: Now that we have created our class, create a `mymodule.services.yml` file in
    your module’s directory.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的类，在你的模块目录中创建一个 `mymodule.services.yml` 文件。
- en: 'We must register our class with the service container so that Drupal recognizes
    that it will act as an event subscriber:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将我们的类注册到服务容器中，以便 Drupal 识别它将作为事件订阅者：
- en: '[PRE219]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The `event_subscriber` tag tells the container to invoke the `getSubscribedEvents`
    method and register its methods.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`event_subscriber` 标签告诉容器调用 `getSubscribedEvents` 方法并注册其方法。'
- en: Install the module or rebuild Drupal’s caches if it has been already installed.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块已经安装，请安装模块或重建 Drupal 的缓存。
- en: Navigate to any page as an anonymous user – you will be redirected to the login
    form.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以匿名用户身份导航到任何页面 - 你将被重定向到登录表单。
- en: How it works…
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Throughout Drupal and Symfony, component events can be passed to the event dispatcher.
    The `event_dispatcher` service in Drupal is an optimized version of the one provided
    by Symfony but is completely interoperable and provides backward compatibility
    layers with Symfony. When the container is built, all services tagged as `event_subscriber`
    are gathered. They are then registered into the `event_dispatcher` service, keyed
    by the events returned in the `getSubscribedEvents` method.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 和 Symfony 中，组件事件可以传递给事件分发器。Drupal 中的 `event_dispatcher` 服务是 Symfony
    提供的优化版本，但完全兼容，并提供与 Symfony 的向后兼容层。当容器构建时，所有标记为 `event_subscriber` 的服务都会被收集。然后，它们被注册到
    `event_dispatcher` 服务中，键是 `getSubscribedEvents` 方法返回的事件。
- en: Note
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Symfony 4.3 changed how events are dispatched. Previously, events were identified
    only by name, with the event object serving as a value object. With Symfony 4.3,
    the event name was made optional. This also aligns with the PSR-14 Event Dispatcher
    by the PHP-FIG.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony 4.3 改变了事件分发的机制。以前，事件仅通过名称标识，事件对象作为值对象。在 Symfony 4.3 中，事件名称被设置为可选的。这也与
    PHP-FIG 的 PSR-14 事件分发器相一致。
- en: When the `event_dispatcher` service is told to dispatch an event, it invokes
    the registered methods on all subscribed services. Drupal still primarily uses
    named events over event objects, as many events leverage the same event object
    class.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `event_dispatcher` 服务被告知分发一个事件时，它将调用所有已订阅服务上注册的方法。Drupal 仍然主要使用命名事件而不是事件对象，因为许多事件利用了相同的事件对象类。
- en: The `\Symfony\Component\HttpKernel\KernelEvents` class documents the events
    available to interact with the request life cycle to become a response and even
    after the response is sent, as we did with `RequestEvent`. Then, there are events,
    such as `ConfigEvents::SAVE` and `ConfigEvents::DELETE`, that are dispatched and
    allow you to react to a configuration being saved or deleted but are not able
    to adjust the configuration entity directly through the event object.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Symfony\Component\HttpKernel\KernelEvents` 类记录了可用于与请求生命周期交互的事件，以成为响应，甚至在响应发送后，就像我们使用
    `RequestEvent` 一样。然后，还有诸如 `ConfigEvents::SAVE` 和 `ConfigEvents::DELETE` 之类的其他事件被触发，允许你对配置的保存或删除做出反应，但不能直接通过事件对象调整配置实体。'
- en: There’s more…
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Event subscribers require knowledge of creating services, registering them,
    and even dependency injection. We’ll discuss this some more in the next section.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 事件订阅者需要了解创建服务、注册它们以及甚至依赖注入。我们将在下一节中进一步讨论这一点。
- en: Using dependency injection
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用依赖注入
- en: Drupal utilizes a service container that allows you to declare classes and services
    and define their dependencies. For services, a dependency is an argument that
    must be passed to its constructor. Dependency injection is a software design concept,
    and at its base level, it provides a means to use a class without having to directly
    reference it. In our example, we retrieved services multiple times using the `\Drupal`
    global static class. This is convenient but is a bad practice within services.
    It can make testing more difficult.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 利用一个服务容器，允许您声明类和服务并定义它们的依赖关系。对于服务，依赖关系是一个必须传递给其构造函数的参数。依赖注入是一种软件设计概念，在其基本层面上，它提供了一种使用类而无需直接引用它的方法。在我们的示例中，我们多次使用
    `\Drupal` 全局静态类检索服务。这很方便，但在服务中是一种不良做法。它可能会使测试变得更加困难。
- en: 'To implement dependency injection, first, we will add a constructor to our
    class that accepts the services used (`current_route_match` and `current_user`)
    and matches protected properties to store them:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现依赖注入，首先，我们将向我们的类添加一个构造函数，该构造函数接受使用的服务（`current_route_match` 和 `current_user`）并将它们与受保护的属性匹配以存储它们：
- en: '[PRE225]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'We can then replace any calls to `\Drupal::` with `$this->`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以替换任何对 `\Drupal::` 的调用为 `$this->`：
- en: '[PRE226]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Finally, we will update `mymodule.services.yml` to specify our constructor
    arguments so that they will be injected when the container runs our event subscriber:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新 `mymodule.services.yml` 文件以指定我们的构造函数参数，以便在容器运行我们的事件订阅者时注入：
- en: '[PRE227]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Dependency injection feels and seems magical at first. However, with use and
    practice, it will begin to make more sense and become second nature when developing
    with Drupal.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入一开始感觉和看起来很神奇。然而，随着使用和实践，它将开始变得更有意义，并在使用 Drupal 进行开发时变得习以为常。
- en: See also
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'PSR-14 Event Dispatcher by PHP-FIG: [https://www.php-fig.org/psr/psr-14/](https://www.php-fig.org/psr/psr-14/)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-14 事件调度器由 PHP-FIG：[https://www.php-fig.org/psr/psr-14/](https://www.php-fig.org/psr/psr-14/)
- en: Creating a custom Drush command
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 Drush 命令
- en: Throughout this book, we have used Drush to perform operations on a Drupal site
    from the command line. Custom commands for Drush can be provided by modules. This
    allows developers to create commands that help them manage their Drupal sites.
    Drush requires modules to provide a `composer.json` file that instructs them where
    to load a services file that will register Drush commands.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已使用 Drush 从命令行对 Drupal 网站执行操作。模块可以提供自定义 Drush 命令。这允许开发者创建帮助管理他们 Drupal
    网站的命令。Drush 需要模块提供一个 `composer.json` 文件，该文件指示它们在哪里加载一个将注册 Drush 命令的服务文件。
- en: In this recipe, we will create a new Drush command for a custom module that
    prints the location of where Drupal is installed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个新的 Drush 命令，用于打印 Drupal 安装的位置。
- en: How to do it…
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Drush provides a command to generate the required files for creating a command
    file for custom commands. To begin, run the following command:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Drush 提供了一个命令来生成创建自定义命令所需的文件。首先，运行以下命令：
- en: '[PRE228]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: You will be prompted to provide a value for the `Module` machine name; type
    `mymodule` for the name of our module.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示提供 `Module` 机器名称的值；请输入 `mymodule` 作为我们模块的名称。
- en: Next, press *Enter* to skip converting a legacy Drush command file.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按 *Enter* 键跳过转换旧版 Drush 命令文件。
- en: 'The command output will display the files that have been created or updated:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令输出将显示已创建或更新的文件：
- en: '![Figure 4.6 – Output from the command file generator](img/Figure_4.06_B18548.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 命令文件生成器的输出](img/Figure_4.06_B18548.jpg)'
- en: Figure 4.6 – Output from the command file generator
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 命令文件生成器的输出
- en: The `composer.json` file contains information about `drush.services.yml`. The
    `drush.services.yml` file is a service definition file that contains classes and
    their arguments. It has an initial definition for the created `MymoduleCommands`
    class. The `MymoduleCommands` class is generated with sample commands as well.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`composer.json` 文件包含有关 `drush.services.yml` 的信息。`drush.services.yml` 文件是一个服务定义文件，其中包含类及其参数。它为创建的
    `MymoduleCommands` 类提供了一个初始定义。`MymoduleCommands` 类是用示例命令生成的。'
- en: 'The `drush.services.yml` file is important. It is a services definition file
    that tags services as `drush.command` so that classes are collected by Drush:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drush.services.yml` 文件很重要。它是一个服务定义文件，将服务标记为 `drush.command`，以便 Drush 收集类：'
- en: '[PRE229]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Commands are defined as class methods in a command file. Open the `src/Commands/MymoduleCommands.php`
    file to create a new command.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令在命令文件中定义为类方法。打开 `src/Commands/MymoduleCommands.php` 文件以创建一个新的命令。
- en: 'Create a new method called `helloWorld`, which we will use to provide the `hello-world`
    command:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`helloWorld`的新方法，我们将使用它来提供`hello-world`命令：
- en: '[PRE234]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Next, add the following code to the command to output a message and display
    the directory of the Drupal site:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到命令中，以输出消息并显示Drupal站点的目录：
- en: '[PRE236]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: This method uses the `io()` method to get the input/output helper to write content
    back to the terminal. The code then gets the current site alias from the alias
    manager. Drush supports using aliases to connect to remote Drupal sites, with
    the “self” alias being the current local Drupal site. The code then calls the
    `root` method to display the directory of the Drupal code base.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`io()`方法来获取输入/输出辅助工具，以便将内容写回终端。然后代码从别名管理器获取当前站点别名。Drush支持使用别名连接到远程Drupal站点，其中“self”别名是当前本地Drupal站点。然后代码调用`root`方法来显示Drupal代码库的目录。
- en: 'Finally, we need to provide annotations in the document block of the method.
    This is how Drush interprets the command name:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在方法的文档块中提供注解。这是Drush解释命令名的方式：
- en: '[PRE244]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Now, we can execute the command. First, we must clear the cache so that Drupal
    and Drush can register the new command. Then, we can execute it:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以执行命令。首先，我们必须清除缓存，以便Drupal和Drush可以注册新的命令。然后，我们可以执行它：
- en: '[PRE255]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: How it works…
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Drush command line bootstraps Drupal when it is launched. During that launch,
    it takes the Drupal service container and adds and registers the `\Drush\Drupal\FindCommandsCompilerPass`
    compiler pass. This compiler pass scans the `services.yml` files collected by
    Drupal and finds services tagged with `drush.command`. This is why modules must
    have a `drush.services.yml` file. This defines the services and tags them appropriately
    to be discovered by Drush.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 当Drush启动时，它会引导Drupal。在启动过程中，它获取Drupal服务容器，并添加并注册`\Drush\Drupal\FindCommandsCompilerPass`编译器传递。这个编译器传递扫描Drupal收集的`services.yml`文件，并找到带有`drush.command`标签的服务。这就是为什么模块必须有一个`drush.services.yml`文件。这定义了服务，并适当地标记它们以便Drush发现。
- en: 'Since Drush wraps around Drupal, command files may also have other services
    injected into them as dependencies. Here is an example of a `drush.services.yml`
    file using dependency injection from the `Pathauto` module:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Drush围绕Drupal构建，命令文件也可能被注入其他服务作为依赖。以下是一个使用`Pathauto`模块依赖注入的`drush.services.yml`文件示例：
- en: '[PRE257]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: See also
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Drush command authoring documentation: [https://www.drush.org/latest/commands/](https://www.drush.org/latest/commands/)'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drush命令编写文档：[https://www.drush.org/latest/commands/](https://www.drush.org/latest/commands/)
