- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Automated Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'If you’ve read all the chapters of this book from the very beginning, you’ll
    have not only an idea of the theoretical background but also a good set of tools
    at hand that will help you write great **PHP: Hypertext Preprocessor** (**PHP**)
    code. Of course, you can just go and refactor all the code there is, probably
    using some automated code manipulation capabilities our tools offer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这本书的第一章开始就阅读了所有的章节，你不仅会有一个理论背景的概念，而且还会手头有一套很好的工具，这些工具将帮助你编写出色的**PHP：超文本预处理器**（**PHP**）代码。当然，你也可以直接去重构现有的所有代码，可能使用我们工具提供的某些自动化代码操作功能。
- en: 'You will not write perfect code on the first try—it usually takes several iterations
    until you are satisfied. And since you never stop learning, you will refactor
    parts of your code even months or years later. Yet even the most sophisticated
    code quality tools will not prevent you from having to do one tedious task: testing
    your code after you’ve made changes to ensure that it still works as expected.
    That is why in this chapter, we want to introduce you to **automated testing**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能第一次就写出完美的代码——通常需要多次迭代才能让你满意。而且由于你永远不会停止学习，你甚至几个月或几年后还会重构你的代码。然而，即使是最复杂的代码质量工具也无法阻止你不得不进行一项繁琐的任务：在你对代码进行更改后，确保它仍然按预期工作。这就是为什么在本章中，我们想向你介绍**自动化测试**。
- en: Through automated testing, you will be able to verify that your improvements
    to the code did not break its functionality in a fast and reliable way. This is
    one of the cornerstones of writing clean code since it enables you to refactor
    code with confidence.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化测试，你将能够快速且可靠地验证你的代码改进没有破坏其功能。这是编写干净代码的一个基石，因为它使你能够有信心地重构代码。
- en: The topic of automated testing deserves a whole book or two, so we can only
    scratch the surface here. Yet since we are convinced you will greatly benefit
    from it in your daily work, we hope that this chapter will make you want to learn
    more about this exciting topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试这个话题值得一本或两本书来讨论，所以我们只能触及表面。然而，既然我们确信你将在日常工作中从中受益匪浅，我们希望这一章能让你想要了解更多关于这个令人兴奋的话题。
- en: 'The following sections will give you a good overview:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将为你提供一个良好的概述：
- en: Why you need automated tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要自动化测试
- en: Types of automated tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试的类型
- en: About code coverage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于代码覆盖率
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Additional to the technical requirements of the previous chapters, you will
    need to install the **Xdebug** PHP extension. We will provide you with more information
    on that topic in the corresponding section, *About code coverage*, later in this
    chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章的技术要求之外，你还需要安装**Xdebug** PHP扩展。我们将在本章后面的相应部分，*关于代码覆盖率*，提供更多关于这个主题的信息。
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)
- en: Why you need automated tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你需要自动化测试
- en: 'Although **PHPUnit**, the standard unit testing framework for PHP, has existed
    since 2006, automated tests are still not used in all PHP projects today. A lot
    of potential is wasted here because automated tests have many benefits, such as
    the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PHP的标准单元测试框架**PHPUnit**自2006年以来就已经存在，但时至今日，并非所有PHP项目都使用自动化测试。在这里，许多潜力都被浪费了，因为自动化测试具有许多好处，例如以下这些：
- en: '**Speed and reliability**: Imagine you need to execute the same testing steps
    over and over. Soon enough, you would make mistakes, or just skip the tests at
    some point. Automated tests, however, do the boring work for you in a much faster
    and more reliable way—and they do not complain.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度和可靠性**：想象一下，你需要反复执行相同的测试步骤。很快，你可能会犯错，或者在某些时候跳过测试。然而，自动化测试会以更快、更可靠的方式为你完成这些枯燥的工作——而且它们不会抱怨。'
- en: '**Documentation**: With automated tests, you can indirectly document the functionality
    of code through assertions, which explain what the code is expected to do. Compared
    to comments or articles in a wiki, you will immediately be notified by the failing
    tests when something has changed significantly. We will discuss this topic again
    in [*Chapter 13*](B19050_13.xhtml#_idTextAnchor195)*, Creating Effective Documentation,*
    when we talk about creating effective documentation.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：通过断言，您可以使用自动化测试间接记录代码的功能，这些断言解释了代码预期要做什么。与注释或维基百科中的文章相比，当某些内容发生重大变化时，您会立即通过失败的测试得到通知。我们将在[*第13章*](B19050_13.xhtml#_idTextAnchor195)“创建有效的文档”中再次讨论这个主题，当我们讨论创建有效的文档时。'
- en: '**Onboarding**: A test suite with good coverage of our code will help new developers
    to get productive on a project faster. Not only do the tests act as additional
    documentation, but they also let the developers make changes or add features with
    confidence. They can verify that their changes do not break anything before they
    get deployed to any staging or production environment.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入职**：一个覆盖我们代码的良好测试套件将帮助新开发者更快地在一个项目中变得高效。测试不仅作为额外的文档，还让开发者有信心进行更改或添加功能。他们可以在将更改部署到任何预发布或生产环境之前验证他们的更改不会破坏任何东西。'
- en: '**Continuous integration/continuous deployment (CI/CD)**: Be it CI or CD, if
    your tests are automated, you can trust through your build pipeline that the code
    you merge is not broken, which enables you to push code to production faster,
    and thus more often. In the next chapter, we will have an in-depth look at this
    topic.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成/持续部署（CI/CD）**：无论是CI还是CD，如果您的测试是自动化的，您就可以通过构建管道信任合并的代码没有错误，这使您能够更快地将代码推送到生产环境，从而更频繁地推送。我们将在下一章深入探讨这个主题。'
- en: '**Better code**: You do not strictly have to follow the infamous **test-driven
    development** (**TDD**) approach to benefit from tests already in development.
    Writing unit-testable code even improves your code. To be able to test code in
    isolation (for example, without having a real database running in the background),
    you need to write your code with separation in mind. If external dependencies
    are injected using **dependency injection** (**DI**), they are much easier to
    replace with test objects than if you instantiate them in the class functions.
    We will have a closer look at the **DI pattern** in [*Chapter 12*](B19050_12.xhtml#_idTextAnchor174)*,
    Working in a Team*. Additionally, long and complex functions are equally hard
    to test as short ones (think of—for example—the **NPath complexity** here, which
    we discussed in [*Chapter 8*](B19050_08.xhtml#_idTextAnchor100)), so you will
    very soon start to write shorter functions to reduce the number of decision paths
    in your code.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的代码**：您不必严格遵循臭名昭著的**测试驱动开发**（**TDD**）方法，就可以从开发中的测试中受益。编写可单元测试的代码甚至可以提高您的代码质量。为了能够独立测试代码（例如，在没有后台运行真实数据库的情况下），您需要考虑代码的分离。如果使用**依赖注入**（**DI**）注入外部依赖项，它们比在类函数中实例化它们更容易用测试对象替换。我们将在[*第12章*](B19050_12.xhtml#_idTextAnchor174)“团队合作”中更详细地探讨**DI模式**。此外，长而复杂的函数与短函数一样难以测试（例如，考虑一下我们在这里讨论的**NPath复杂性**，它出现在[*第8章*](B19050_08.xhtml#_idTextAnchor100)中），因此您很快就会开始编写更短的函数，以减少代码中的决策路径数量。'
- en: '**Easier refactoring**: Automated tests are an invaluable tool when you want
    to refactor a project based on the results of the static code analyzers we introduced
    back in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084). You can apply their recommendations
    or even the automated code fixes, and just after running the tests, you will know
    if this introduced any side effects or not. Since refactoring is the most important
    use case for us in the context of this book, we will discuss it in more detail
    in the next section.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的重构**：当您想根据我们在[*第7章*](B19050_07.xhtml#_idTextAnchor084)中介绍过的静态代码分析器的结果重构项目时，自动化测试是无价之宝。您可以使用它们的建议或甚至自动化的代码修复，只需运行测试后，您就会知道这是否引入了任何副作用。由于重构是我们在这本书的上下文中最重要的用例，我们将在下一节中更详细地讨论它。'
- en: TDD
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TDD
- en: 'TDD is a way of developing code that combines writing tests and the actual
    code at the same time. The basic idea is simple and often referred to as **red/green/refactor**:
    before you write any code for a new feature or even a bug fix, the first step
    is to write a test that checks the expected outcome. Since you have no actual
    code written yet, the tests will fail (indicated by the color red). In the second
    step, you write the code, without paying too much attention to making it perfect,
    until the tests pass (green). Since you now already have working tests, you can
    easily improve (refactor) the code until you are satisfied.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种同时编写测试和实际代码的编码方式。基本思想很简单，通常被称为**红/绿/重构**：在为新的功能或甚至是一个错误修复编写任何代码之前，第一步是编写一个检查预期结果的测试。由于你还没有编写任何实际代码，测试将失败（用红色表示）。在第二步中，你编写代码，不必过于关注使其完美，直到测试通过（绿色）。既然你现在已经有了工作的测试，你可以轻松地改进（重构）代码，直到你满意。
- en: 'The TDD paradigm ensures that you will have all your code covered with tests
    and that the code is already written in a fully testable way. Do not take things
    too seriously, though: there are times when you just want to experiment without
    having a clear goal in mind—for example when you play around with a new **application
    programming interface** (**API**). In this case, you do not need to follow TDD.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TDD范式确保你的所有代码都将被测试覆盖，并且代码已经以完全可测试的方式编写。不过，不要过于认真：有时你只是想在没有明确目标的情况下进行实验——例如，当你玩一个新的**应用程序编程接口**（**API**）时。在这种情况下，你不需要遵循TDD。
- en: Easier refactoring with tests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有测试的简化重构
- en: If you start a project *on the green* (that is, you write it from scratch),
    you can have the comfort of getting immediate feedback from your code quality
    tools as soon as you start coding it. This is a great help, yet even the best
    tools will not prevent you from making bad decisions and writing code that you
    will want to undo at some point.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从**绿色**开始一个项目（也就是说，从头开始编写），你可以在开始编写代码时立即从代码质量工具中获得反馈的舒适感。这是一个很大的帮助，但即使是最好的工具也无法阻止你做出错误的决定，并编写你将来想要撤销的代码。
- en: That happens to everyone and should not discourage you at all. You learn something
    new every day, and while your personal skills evolve, so will your code. If you
    look at your code from 1 year ago, you’ll probably want to refactor it right away.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这对每个人来说都是常态，而且绝对不应该让你气馁。你每天都在学习新东西，随着你个人技能的发展，你的代码也会发展。如果你看看你一年前的代码，你可能会想立即重构它。
- en: And of course, not only your skills, but the whole PHP ecosystem constantly
    improves. Many things that are standard today were simply non-existent back in
    the day. New packages or language features are constantly being introduced, and
    you want to use them in your projects to not stick with the old techniques forever.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不仅仅是你的技能，整个PHP生态系统也在不断进步。今天被认为是标准的东西，在以前可能根本不存在。新的包或语言特性不断被引入，你希望在项目中使用它们，而不是永远停留在旧的技术上。
- en: So, code changes over time—that is completely normal, and we as developers should
    embrace change; no piece of our code will ever be final. We refer to changing
    existing code as **refactoring**. The interesting part about refactoring is that
    code gets changed, but the software appears unchanged to the user. All work happens
    “under the hood”. If you—for example—updated the framework of your project to
    the latest version, and the users noticed no direct changes, then you did your
    job well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码随着时间的推移而改变——这是完全正常的，我们作为开发者应该接受变化；我们代码的任何部分永远不会是最终的。我们将更改现有代码称为**重构**。关于重构有趣的部分是代码被更改了，但软件对用户来说看起来没有变化。所有的工作都在“引擎盖下”完成。例如，如果你更新了项目的框架到最新版本，而用户没有注意到任何直接的变化，那么你就做得很好。
- en: Refactoring has benefits; otherwise, we would not do it. If done right, it can
    lead—for example—to improved performance, increased security, or generally allows
    an application to be scalable in the cloud. And yet, refactoring often comes with
    a bad connotation. Managers in particular tend to think that refactoring means
    changing code just because there is yet another hype in the web development world
    the engineers want to follow, and precious working hours are wasted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重构有好处；否则，我们不会去做。如果做得正确，它可以带来——例如——性能改进、安全性提高，或者通常允许应用程序在云中可扩展。然而，重构往往带有负面含义。特别是管理者往往认为重构意味着仅仅因为网络开发世界中又有新的炒作，工程师们想要追随，宝贵的工时就被浪费了。
- en: 'Let us be honest: of course, this happens too. The line is often difficult
    to draw. For example, imagine your duty is to maintain an old but perfectly working
    PHP application that uses the **Singleton pattern** for object instantiation.
    If you only have to do small changes occasionally, there actually is no need to
    refactor it to use DI. However, if you are required to implement ongoing changes,
    such as adding new modules and tests for it, it might be a good choice to do so.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坦诚地说：当然，这种情况也会发生。界限往往难以划分。例如，假设你的职责是维护一个老旧但运行完美的PHP应用程序，该应用程序使用**单例模式**进行对象实例化。如果你只是偶尔需要做些小改动，实际上没有必要将其重构为使用依赖注入。然而，如果你需要实施持续性的改动，比如添加新模块和测试，那么这样做可能是个不错的选择。
- en: 'Often, you will have to justify your refactoring work. It is then helpful to
    rather speak of **system health maintenance** on the code instead. Everybody is
    completely fine with the fact that machines require maintenance: parts get replaced,
    the lubricant must be renewed, and so on. Yet, for some reason, our software ought
    to work forever.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将不得不为你的重构工作提供合理的解释。这时，将代码的维护称为**系统健康维护**可能更有帮助。每个人对机器需要维护的事实都感到完全正常：部件需要更换，润滑剂必须更新，等等。然而，不知何故，我们的软件似乎应该永远工作。
- en: Having good arguments for refactoring now, we want to understand how testing
    can help us here. To accomplish that, let us have a closer look at the different
    test types there are in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现在有了良好的重构理由之后，我们想要了解测试如何帮助我们。为了实现这一点，让我们在下一节中更详细地看看存在哪些不同的测试类型。
- en: Types of automated tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试类型
- en: 'Although **unit tests** are probably the most known type of automated testing,
    there is more to discover. In this section, we will introduce the most common
    (and important) test types. A well-known testing concept is the **testing pyramid**,
    which is shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试可能是最广为人知的自动化测试类型，但其中还有更多值得探索的内容。在本节中，我们将介绍最常见（且最重要的）测试类型。一个著名的测试概念是**测试金字塔**，如下所示：
- en: '![Figure 10.1: Testing pyramid'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：测试金字塔'
- en: '](img/Figure_10.1_B19050.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B19050.jpg)'
- en: 'Figure 10.1: Testing pyramid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：测试金字塔
- en: This concept basically shows three types of tests—namely, **end-to-end tests**
    (or **E2E tests** in short), **integration tests**, and **unit tests**. We will
    explain each test type and its position in the testing pyramid in the following
    sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念基本上展示了三种测试类型——即**端到端测试**（简称**E2E测试**）、**集成测试**和**单元测试**。我们将在接下来的章节中解释每种测试类型及其在测试金字塔中的位置。
- en: Unit tests
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: As the name implies, **unit tests** are about testing small units of code. It
    is best practice to write one test for each functionality of an object only; otherwise,
    the tests will become bigger and harder to understand and maintain. This keeps
    the tests small as well, and that is why there is usually a lot of them. Depending
    on the project size, having hundreds or thousands of unit tests is completely
    normal, so it is important to keep them executing as fast as possible. Usually,
    they should not take longer than a few microseconds each.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，**单元测试**是关于测试代码的小单元。最佳实践是为一个对象的功能编写一个测试；否则，测试将变得更大，更难以理解和维护。这也使得测试保持小巧，这也是为什么通常会有很多测试。根据项目规模的不同，拥有数百或数千个单元测试是完全正常的，因此保持它们尽可能快速执行非常重要。通常，它们不应该每个测试超过几微秒。
- en: Unit tests should run in isolation, which means that in the tests, the tested
    objects do not interact with any other external services, such as databases or
    APIs. This is achieved by faking the external dependencies, which is called **mocking**
    in unit testing jargon. Simply speaking, we replace external objects—such as services
    or repositories that are used within our test object—with **mock objects** (or
    **mocks**, in short). These objects simulate the behavior of the dependencies
    they replace during the runtime of the unit tests. This ensures that a test does
    not suddenly fail just because—for example—some data in the database, which our
    test was relying on, has changed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应在隔离状态下运行，这意味着在测试中，被测试的对象不会与任何其他外部服务交互，例如数据库或API。这是通过模拟外部依赖项来实现的，在单元测试术语中称为**模拟**。简单来说，我们用**模拟对象**（或简称**mocks**）替换了外部对象——例如，在测试对象内部使用的服务或存储库。这些对象在单元测试的运行时模拟了它们所替代的依赖项的行为。这确保了测试不会因为——例如——数据库中某些数据（我们的测试所依赖的数据）发生了变化而突然失败。
- en: Because tests of this type are small, fast, and do not rely on external dependencies,
    it is relatively easy to create a test setup for them. They are extremely helpful
    because they can tell you within seconds if your last changes to the code caused
    any problems or not. That is why they are the foundation of the testing pyramid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种类型的测试很小、速度快，且不依赖于外部依赖，因此为它们创建测试设置相对容易。它们非常有帮助，因为它们可以在几秒钟内告诉你你的代码的最后更改是否导致了任何问题。这就是为什么它们是测试金字塔的基础。
- en: If you are new to testing, it makes sense to start with **PHPUnit**, as it is
    the industry standard in the PHP world. If you start on a new project, it is most
    likely that PHPUnit will be used. There are other testing frameworks that have
    their unique advantages, such as **Pest** ([https://pestphp.com](https://pestphp.com)).
    Once you have grasped the concept of unit testing with PHPUnit, we encourage you
    to give them a try as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触测试，从 **PHPUnit** 开始是有意义的，因为它是 PHP 世界的行业标准。如果你开始一个新的项目，很可能PHPUnit将会被使用。还有其他具有独特优势的测试框架，例如
    **Pest** ([https://pestphp.com](https://pestphp.com))。一旦你掌握了使用 PHPUnit 进行单元测试的概念，我们鼓励你也尝试一下它们。
- en: A drawback of unit tests is the fact that they do not interact with each other.
    This may even lead to having all your tests passing while your application is
    broken, just because the interaction between the classes was not tested properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个缺点是它们之间不交互。这甚至可能导致所有测试都通过，而你的应用程序却出了问题，仅仅是因为类之间的交互没有经过适当的测试。
- en: To illustrate this problem, we create an elementary demo application. Let us
    have a look at the most important parts of it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，我们创建了一个基本的演示应用程序。让我们看看它的最重要的部分。
- en: Demo application source code
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序源代码
- en: 'You will find the full source code in the GitHub repository to this book:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到完整的源代码：
- en: https://github.com/PacktPublishing/Clean-Code-in-PHP
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Clean-Code-in-PHP
- en: 'First, we create a rudimentary class, called `MyApp`, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个基本的类，称为 `MyApp`，如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `MyRepository` method gets injected through the constructor. The only method,
    `run`, uses the repository to fetch data and concatenate it. It is important to
    note that `MyClass` expects a certain array structure to be returned by `MyRepository`.
    This is not recommended to do, but you will still find this a lot “in the wild”.
    Therefore, it serves perfectly as a demonstration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyRepository` 方法通过构造函数注入。唯一的方法 `run` 使用仓库来获取数据并将其连接起来。需要注意的是，`MyClass` 期望
    `MyRepository` 返回一个特定的数组结构。这并不推荐这样做，但你仍然会发现这在“野外”很常见。因此，它完美地作为一个演示。'
- en: '`MyRepository` looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyRepository` 看起来是这样的：'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In real life, `MyRepository` would fetch the data from an external data source,
    such as a database. For our example, it returns a hardcoded array. If the `run`
    method of `MyClass` gets executed, it will return a `some data...and some more
    data` string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，`MyRepository` 会从外部数据源，如数据库中获取数据。在我们的例子中，它返回一个硬编码的数组。如果 `MyClass` 的 `run`
    方法被执行，它将返回一个 `some data...and some more data` 字符串。
- en: 'Of course, we also added tests (using PHPUnit) for the preceding classes. For
    brevity, we will only show the test cases in the following code snippet, not the
    whole test classes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也为前面的类添加了测试（使用 PHPUnit）。为了简洁，我们只会在以下代码片段中展示测试案例，而不是整个测试类：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Arrange-Act-Assert (AAA) pattern
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安排-行动-断言（AAA）模式
- en: 'You may have noticed that we added three lines of comments to both of our test
    cases: `Arrange`, `Act`, and `Assert`. We did that to demonstrate the most used
    pattern to write unit tests: the **AAA pattern**. Even without having ever written
    a single unit test yourself, it helps you to understand how they work.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在两个测试案例中都添加了三行注释：`Arrange`、`Act` 和 `Assert`。我们这样做是为了演示编写单元测试最常用的模式：**AAA
    模式**。即使你从未自己编写过任何单元测试，它也能帮助你理解它们是如何工作的。
- en: Firstly, the test objects and required prerequisites such as mock objects get
    prepared (`Arrange`). Secondly, the actual work of the object under test is executed
    (`Act`). Finally, we ensure that the results of the test meet our expectations
    (`Assert`). If one of the assertions is not met, the whole test fails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，准备测试对象和所需的先决条件，如模拟对象（`Arrange`）。其次，执行被测试对象的实际工作（`Act`）。最后，我们确保测试结果符合我们的预期（`Assert`）。如果任何一个断言未满足，整个测试将失败。
- en: 'Two things are noteworthy here, as set out next:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点值得注意，如下所述：
- en: In `testRun()`, we create a `$repositoryMock` mock instead of using the actual
    `MyRepository` method. This is because we assume that `MyRepository` would normally
    fetch the data from an external data source, and we do not want to write unit
    tests that have external dependencies.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`testRun()`中，我们创建一个`$repositoryMock`模拟对象而不是使用实际的`MyRepository`方法。这是因为我们假设`MyRepository`通常会从外部数据源获取数据，我们不希望编写具有外部依赖的单元测试。
- en: '`testGetDataReturnsAnArray()` does not test the repository very well. We just
    check if the result is an array and that it has two entries, but not which array
    keys are returned.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testGetDataReturnsAnArray()`并没有很好地测试仓库。我们只是检查结果是否为数组，并且它有两个条目，但没有检查返回的数组键。'
- en: 'Now, imagine that for whatever reason, one fellow developer decided that the
    `value_1` and `value_2` array keys were too long, and renamed them `val1` and
    `val2`. If we now execute our application, it will of course break, as illustrated
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设由于某种原因，一位开发人员决定`value_1`和`value_2`数组键名太长，并将它们重命名为`val1`和`val2`。如果我们现在运行我们的应用程序，它当然会崩溃，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, if you execute the tests, they will still pass, as we see here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你执行这些测试，它们仍然会通过，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This illustrates that having unit tests is important, but it does not necessarily
    mean that we will not introduce bugs anymore because they can be faulty or they
    test the wrong things, as in our example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明拥有单元测试很重要，但这并不意味着我们不会再引入错误，因为它们可能存在缺陷或测试了错误的内容，就像我们的例子中那样。
- en: Often enough, objects such as **repositories** that interact with external systems
    are not tested at all because it requires a more complex test setup—for example,
    using an additional test database with fake data. If we just replace such an object
    with a mock, the test will work correctly. If there are significant changes on
    the original object later and the mock does not get updated to reflect those changes,
    we can end up in a situation like we just described.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，像**仓库**这样的与外部系统交互的对象根本不会被测试，因为这需要更复杂的测试设置——例如，使用带有伪造数据的附加测试数据库。如果我们只是用一个模拟对象替换这样的对象，测试将正确执行。如果原始对象后来有重大变化，而模拟对象没有更新以反映这些变化，我们可能会陷入我们刚才描述的情况。
- en: To overcome this problem, we need a way to additionally test our classes without
    replacing dependencies with mocks. For that, we will introduce the second test
    type of the testing pyramid—integration tests—in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们需要一种方法来额外测试我们的类，而无需用模拟对象替换依赖。为此，我们将在下一节介绍测试金字塔的第二个测试类型——集成测试。
- en: Integration tests
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The second types of test we want to look at are **integration tests**. Unlike
    unit tests, which are supposed to not use any external dependencies, with this
    test type we want to do the opposite: we want to test code as it would normally
    run, without replacing anything with mocks.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的第二种测试类型是**集成测试**。与单元测试不同，单元测试不应该使用任何外部依赖，而在这个测试类型中，我们想要做相反的事情：我们想要测试代码的正常运行，而不用模拟对象替换任何内容。
- en: You might have already witnessed unit test suites that made use of a test database
    or some external API. Technically speaking, these tests are not unit tests anymore,
    but integration tests (or **functional tests**, as they are also called). We could
    theoretically use PHPUnit for these tests as well, or use particular testing tools
    that take over a lot of groundwork for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经见证过使用测试数据库或某些外部API的单元测试套件。从技术上讲，这些测试不再是单元测试，而是集成测试（或者也称为**功能测试**）。理论上，我们也可以使用PHPUnit进行这些测试，或者使用特定的测试工具，这些工具为我们处理了很多基础工作。
- en: 'The following code snippet shows an example of an integration test:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了集成测试的一个示例：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding function shows what an integration test could look like if we
    used the `$tester` gets passed into the test that is a `Helper` object that offers
    the functionality we need to perform—for example, database checks. After executing
    the `save` method on the `$product` test object, we use this `Helper` object to
    validate if the data we would expect has actually been written into the database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数展示了如果我们使用了`$tester`，一个传递给测试的`Helper`对象，它提供了我们执行测试所需的功能——例如，数据库检查。在执行`$product`测试对象的`save`方法之后，我们使用这个`Helper`对象来验证我们预期写入数据库的数据实际上是否已经写入。
- en: Codeception
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Codeception
- en: Codeception ([https://codeception.com](https://codeception.com)) combines a
    variety of test types, such as unit, integration, and even E2E tests in one tool.
    Under the hood, it is based on existing tools such as PHPUnit. It offers modules
    for all major frameworks and thus integrates well into most PHP projects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Codeception ([https://codeception.com](https://codeception.com)) 结合了多种测试类型，如单元测试、集成测试，甚至端到端测试，在一个工具中。在底层，它基于现有的工具，如PHPUnit。它为所有主要框架提供模块，因此可以很好地集成到大多数PHP项目中。
- en: Using integration tests makes the test setup more complex because we must make
    sure that the external dependencies we use are always in a reliable state. For
    example, if you need to rely on a certain user in your database, you must make
    sure that it always has the same data, such as the user **identifier** (**ID**)
    you test for; otherwise, your tests will fail. This usually requires creating
    a fresh test database before every test run, to make sure no leftovers from previous
    test runs disturb our test. Furthermore, we need to run **database migrations**
    to ensure that the test database schema is up to date. Finally, we have to fill
    it with test data, which is called **seeding**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集成测试使得测试设置更加复杂，因为我们必须确保我们使用的所有外部依赖始终处于可靠状态。例如，如果你需要依赖于数据库中的某个特定用户，你必须确保它始终具有相同的数据，例如你测试的用户**标识符（ID**）；否则，你的测试将会失败。这通常需要在每次测试运行之前创建一个新的测试数据库，以确保之前的测试运行留下的任何残留物不会干扰我们的测试。此外，我们需要运行**数据库迁移**，以确保测试数据库模式是最新的。最后，我们必须填充测试数据，这被称为**播种（seeding**）。
- en: 'The main drawback of this test type is the execution speed. Database transactions
    are slow (compared to using mock objects), and we need to prepare the test database
    upon every test run. Integration tests also tend to break easier, or they become
    flaky (unstable) because the interaction with other dependencies quickly becomes
    very complex: if the previous test changed the database in a way the next test
    did not expect, your test run fails, although the code has not changed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试类型的主要缺点是执行速度。数据库事务速度慢（与使用模拟对象相比），并且我们需要在每次测试运行时准备测试数据库。集成测试也更容易出错，或者变得不可靠（不稳定），因为与其他依赖项的交互很快变得非常复杂：如果上一个测试以下一个测试未预料到的方式更改了数据库，你的测试运行将会失败，尽管代码没有变化。
- en: For example, a new test is added to the test suite that checks if a class updates
    a dataset in a certain way. Since this is an integration test, it will use the
    test database for it and change that particular dataset. After the execution of
    this test, however, the changed data will still be in the test database. If another
    test that runs *after* this new test is relying on the previous data, it will
    fail. Despite the added complexity of your test setup, integration tests ensure
    that the integration of tested objects within the application context works fine.
    That is why they should be an integral part of your test strategy, being the second
    layer in the testing pyramid.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试套件中添加了一个新的测试，用于检查一个类是否以某种方式更新数据集。由于这是一个集成测试，它将使用测试数据库进行操作并更改特定的数据集。然而，在执行此测试之后，更改后的数据仍然保留在测试数据库中。如果另一个在新的测试之后运行的测试依赖于之前的数据，它将会失败。尽管测试设置增加了复杂性，但集成测试确保了测试对象在应用程序上下文中的集成工作正常。这就是为什么它们应该是测试策略的一个组成部分，成为测试金字塔的第二层。
- en: You will find a lot of integration tests when it comes to testing repositories,
    models, or controllers. However, they cannot test the interaction between PHP
    and the browser. Since we use PHP mainly to build web applications, this is an
    aspect that we should not forget about. Luckily, the last test type from the testing
    pyramid covers exactly this problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试仓库、模型或控制器时，你会找到大量的集成测试。然而，它们无法测试PHP和浏览器之间的交互。由于我们主要使用PHP来构建Web应用程序，这是一个我们不应该忘记的方面。幸运的是，测试金字塔中的最后一种测试类型正好解决了这个问题。
- en: E2E tests
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: For this test type, we will leave the realm of PHP for a moment. With **E2E
    tests**, we want to ensure that the whole flow from the server to the client (for
    example, the browser) and back again to the server is working alright. We basically
    simulate a user sitting in front of the computer and clicking through our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种测试类型，我们将暂时离开PHP领域。使用**端到端测试（E2E tests**），我们想要确保从服务器到客户端（例如，浏览器）以及再次返回服务器的整个流程运行良好。我们基本上模拟一个坐在电脑前点击我们应用程序的用户。
- en: To achieve this, we first need a reproducible testing environment. Just as for
    integration tests, we must ensure that the application we want to test is always
    in the same state. This means that we need to ensure that the same set of data
    (for example, blog posts, or articles in a shop) is available on every test run.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们首先需要一个可重复的测试环境。就像集成测试一样，我们必须确保我们想要测试的应用程序始终处于相同的状态。这意味着我们需要确保在每次测试运行中都可用相同的集合数据（例如，博客文章或商店中的文章）。
- en: 'Secondly, we need to automate the user interaction with our testing environment.
    Here is where things get interesting: we not only need the application, but also
    a local web server and a browser to run it in and simulate the user interaction.
    The web server adds more complexity to the test setup but is usually not a blocker.
    For user interaction, we need to use a so-called **headless browser**. Such a
    browser can interact with a server without having to open a browser window. This
    is an extremely useful feature because we can use it on the command line without
    having to install a full-fledged operating system with a **graphical user interface**
    (**GUI**) such as Ubuntu Desktop or Windows. This saves us a lot of installation
    time and helps us not to increase the complexity even further.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要自动化用户与我们的测试环境之间的交互。这里事情变得有趣：我们不仅需要一个应用程序，还需要一个本地Web服务器和一个浏览器来运行它并模拟用户交互。Web服务器增加了测试设置的复杂性，但通常不会成为障碍。对于用户交互，我们需要使用所谓的**无头浏览器**。这样的浏览器可以在不打开浏览器窗口的情况下与服务器交互。这是一个极其有用的功能，因为我们可以在命令行中使用它，而无需安装带有**图形用户界面**（**GUI**）的完整操作系统，例如Ubuntu桌面或Windows。这为我们节省了大量安装时间，并帮助我们不会进一步增加复杂性。
- en: 'At the time of writing, **Google Chrome** is the preferred choice, as it is
    not only the most widely used browser engine nowadays, but also provides a **Headless**
    mode, or in other words, it can act like a headless browser. With modern frameworks
    such as **Cypress**, it is effortless to automate user interaction with our application.
    Think of it as a script that tells the browser which **Uniform Resource Locator**
    (**URL**) to open, which button to click, and so on. The following example shows
    a simplified Cypress test:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，**Google Chrome**是首选选择，因为它不仅是当今最广泛使用的浏览器引擎，还提供了**无头**模式，换句话说，它可以像无头浏览器一样工作。使用现代框架如**Cypress**，自动化与我们的应用的用户交互变得轻而易举。把它想象成一个脚本，告诉浏览器打开哪个**统一资源定位符**（**URL**），点击哪个按钮等等。以下是一个简化的Cypress测试示例：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cypress
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress
- en: The Cypress testing framework ([https://www.cypress.io/](https://www.cypress.io/))
    makes writing E2E tests very easy, as it handles the setup of and communication
    with the headless browser for you. Yes—the tests are to be written in JavaScript,
    but that should not stop you from giving it a try.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress测试框架([https://www.cypress.io/](https://www.cypress.io/))使得编写端到端测试变得非常容易，因为它为您处理了无头浏览器的设置和通信。是的——测试将用JavaScript编写，但这不应该阻止你尝试一下。
- en: The `cy` object represents the tester, which executes certain steps. In the
    preceding code example, it firstly opens the login page of a fictive application,
    fills out the `#username` and `#password` fields in a login form, and submits
    it by clicking on the **#submit** button. As the last step, it checks whether
    the login was successful and if the tester has been forwarded to the home screen.
    All these actions are then executed in a real browser, running in the background.
    Using this technology, it is possible to write test suites that literally click
    through our application, just as a human being would. They do not just test the
    PHP code but also the frontend code—a JavaScript error, for example, will quickly
    break the tests. Even if you cannot fix the bug yourself, you can still inform
    the frontend engineers in your team that there is a problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`cy`对象代表测试者，它执行某些步骤。在先前的代码示例中，它首先打开一个虚构应用的登录页面，填写登录表单中的`#username`和`#password`字段，并通过点击**#submit**按钮提交。作为最后一步，它检查登录是否成功以及测试者是否被转发到主页。所有这些操作都是在后台运行的实时浏览器中执行的。使用这项技术，我们可以编写测试套件，这些套件可以像人类一样逐字点击我们的应用。它们不仅测试PHP代码，还测试前端代码——例如，一个JavaScript错误会迅速中断测试。即使你自己无法修复错误，你仍然可以向团队中的前端工程师报告存在问题。'
- en: The modern frameworks make it much easier to write tests than was the case with
    older technologies, such as Selenium. In fact, it is so comfortable nowadays that
    also people who are not developers but have a solid technical foundation, such
    as **quality assurance** (**QA**) engineers, can easily write their own test suites.
    This approach takes a lot of pressure from the teams because the developers have
    to write fewer tests, and the QA people can set up their tests as they need them
    without having to wait for the developers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现代框架使得编写测试比使用旧技术，如Selenium，要容易得多。事实上，现在它非常舒适，甚至不是开发者但拥有坚实的专业技术基础的人，如**质量保证**（**QA**）工程师，也可以轻松编写他们自己的测试套件。这种方法从团队中减轻了压力，因为开发者需要编写的测试更少，QA人员可以按照需要设置测试，而无需等待开发者。
- en: 'Of course, E2E tests have some drawbacks, which is why they are just the third
    layer of tests in the testing pyramid: the test environment is more complex and
    needs more work to set up, especially if a database or any external API is used.
    This test type is also the slowest since it involves the browser in addition to
    the test setups of the previous test types. Lastly, these tests can easily break
    because usually, the testing frameworks use `id` and `class` attributes, or even
    **Document Object Model** (**DOM**) selectors, to navigate through the DOM and
    find elements to interact with. Thus, a small change on the DOM can quickly break
    your whole test suite.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，端到端测试有一些缺点，这也是为什么它们只是测试金字塔的第三层：测试环境更复杂，需要更多的工作来设置，尤其是在使用数据库或任何外部API的情况下。这种测试类型也是最快的，因为它除了前一种测试类型的设置外，还涉及到浏览器。最后，这些测试很容易出错，因为通常测试框架使用`id`和`class`属性，甚至**文档对象模型**（**DOM**）选择器来在DOM中导航并找到要与之交互的元素。因此，DOM上的微小变化可能会迅速破坏你的整个测试套件。
- en: Page objects
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象
- en: If you are interested in creating maintainable E2E tests, you should check out
    the concept of **page objects** ([https://www.martinfowler.com/bliki/PageObject.html](https://www.martinfowler.com/bliki/PageObject.html)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于创建可维护的端到端测试，你应该检查**页面对象**的概念（[https://www.martinfowler.com/bliki/PageObject.html](https://www.martinfowler.com/bliki/PageObject.html)）。
- en: The testing pyramid in practice
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的测试金字塔
- en: With unit, integration, and E2E tests, you now know the three most important
    test types, and their pros and cons. The suggested approach of having unit tests
    as a huge foundation, a fair amount of integration tests, and—finally—some E2E
    tests is a good starting point.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单元测试、集成测试和端到端测试，你现在知道了三种最重要的测试类型，以及它们的优缺点。建议的方法是将单元测试作为巨大的基础，适量的集成测试，最后是一些端到端测试，这是一个好的起点。
- en: 'However, you do not have to strictly follow it all the time, since every project
    is different: if you, for example, want to start testing a yet completely untested
    application, introducing unit tests would require a lot of refactoring effort
    to make the classes testable. This refactoring will most likely introduce more
    bugs in the beginning than it will solve.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不必始终严格遵循它，因为每个项目都是不同的：例如，如果你想开始测试一个尚未完全测试的应用程序，引入单元测试将需要大量的重构工作来使类可测试。这种重构在开始时可能会引入比解决的问题更多的错误。
- en: In this case, starting with a good E2E test coverage will be quicker and safer.
    Once the main parts of the application can be automatically tested, you can safely
    start with the refactoring and introduce unit and/or integration tests. If your
    application breaks because of the necessary refactoring, your E2E tests have you
    covered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从良好的端到端测试覆盖率开始将更快、更安全。一旦应用程序的主要部分可以自动测试，你就可以安全地开始重构并引入单元测试和/或集成测试。如果你的应用程序因为必要的重构而崩溃，你的端到端测试会为你提供保障。
- en: At the end of this chapter, we will list some more test types for you to evaluate
    if you are interested. For now, the three test types we covered in this chapter
    are the most important ones and should be enough for you to get started.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前，我们将列出一些更多的测试类型供你评估，如果你感兴趣的话。现在，本章中我们讨论的三个测试类型是最重要的，应该足以让你开始。
- en: 'There is one important question that we have not really covered yet, though:
    how much of your code do you really need to test? We will discuss this in the
    next section.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的问题我们还没有真正涉及，那就是：你真正需要测试多少代码？我们将在下一节讨论这个问题。
- en: About code coverage
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于代码覆盖率
- en: Now we’ve explored the different test types, you probably want to start writing
    tests right away. But before you put this book away to get coding, let us finish
    this chapter with the question of how much of your code you should test.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了不同的测试类型，你可能想立即开始编写测试。但在你把这本书收起来开始编码之前，让我们以这样一个问题结束本章：你应该测试多少代码？
- en: A part of the answer lies within the concept of code coverage, which we already
    briefly mentioned in [*Chapter 8*](B19050_08.xhtml#_idTextAnchor100)*, Code Quality
    Metrics* when we talked about code quality metrics. Let us have a closer look
    at it now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 部分答案在于代码覆盖率的概念，我们已经在[*第8章*](B19050_08.xhtml#_idTextAnchor100)*代码质量指标*中简要提到了，当我们讨论代码质量指标时。现在让我们更深入地了解一下。
- en: Understanding code coverage
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码覆盖率
- en: '**Code coverage** measures the proportion of code that is covered with tests.
    The higher the code coverage, the better—if there are more tests, the software
    is less likely to contain bugs, and it will be harder to introduce new ones unnoticed.
    Higher code coverage is also a possible indicator of better code quality—as we
    discussed in a previous section of this chapter, tested code must be written in
    a certain way, which usually leads to better quality.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖率**衡量的是被测试覆盖的代码比例。覆盖率越高，越好——如果有更多的测试，软件中包含的bug就越少，而且更难在不被发现的情况下引入新的bug。更高的代码覆盖率也可能是更好的代码质量的指标——正如我们在本章前面的一个部分所讨论的，经过测试的代码必须以某种方式编写，这通常会导致更好的质量。'
- en: Generally, the degree of coverage is expressed simply using the percentage of
    tested code—that is, from 0% (fully untested) to 100% (complete code coverage).
    But how can we measure code coverage? For that, we will use PHPUnit, as it can
    create a code coverage report for us. However, it requires an additional PHP extension
    for the code coverage functionality. For this chapter, we decided to use **Xdebug**,
    the standard PHP **debugger** and **profiler**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，覆盖率程度简单地用测试代码的百分比来表示——也就是说，从0%（完全未测试）到100%（完全代码覆盖率）。但我们如何衡量代码覆盖率？为此，我们将使用PHPUnit，因为它可以为我们生成代码覆盖率报告。然而，它需要一个额外的PHP扩展来实现代码覆盖率功能。对于本章，我们决定使用**Xdebug**，这是标准的PHP**调试器**和**性能分析器**。
- en: Setting up Xdebug
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Xdebug
- en: Xdebug is an extension for PHP, so it requires to be loaded as a module. Since
    its installation is a bit more complex and mainly depends on the operating system
    you are running PHP on, please refer to the official documentation at [https://xdebug.org](https://xdebug.org)
    on how to install and configure it. There are also plenty of tutorials available
    on the internet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Xdebug是一个PHP扩展，因此需要将其作为模块加载。由于其安装相对复杂，主要取决于你运行PHP的操作系统，请参阅[https://xdebug.org](https://xdebug.org)上的官方文档，了解如何安装和配置它。互联网上也有大量的教程。
- en: If you refactor your code, you probably want to know what performance implications
    the changes had. Did you improve the execution time, or did it get even worse?
    With a so-called **profiler**, you can measure the execution time of each function
    in detail and see where bottlenecks are hidden.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重构了代码，你可能想知道这些更改的性能影响是什么。你的执行时间是否有所改善，或者变得更糟？使用所谓的**性能分析器**，你可以详细测量每个函数的执行时间，并查看瓶颈隐藏在哪里。
- en: 'We cannot cover this topic in our book, but since over the course of this chapter
    we already worked with Xdebug, you might want to check out its profiling capabilities
    as well: [https://xdebug.org/docs/profiler](https://xdebug.org/docs/profiler).
    Other commercial services that offer more comfort are—for example—**Tideways**
    ([https://tideways.com](https://tideways.com)) or **Blackfire** ([https://www.blackfire.io](https://www.blackfire.io)).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在我们的书中涵盖这个主题，但既然在本章的过程中我们已经使用了Xdebug，你可能还想检查它的性能分析功能：[https://xdebug.org/docs/profiler](https://xdebug.org/docs/profiler)。其他提供更多便利的商业服务包括——例如——**Tideways**
    ([https://tideways.com](https://tideways.com))或**Blackfire** ([https://www.blackfire.io](https://www.blackfire.io))。
- en: Xdebug alternatives
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Xdebug替代方案
- en: Please note that you can use other extensions for this, such as **PCOV** ([https://github.com/krakjoe/pcov](https://github.com/krakjoe/pcov)),
    which performs better if you only want to do code coverage reports. However, Xdebug
    is an incredibly useful debugger that you should know—if you do not, we encourage
    you to check out some tutorials about it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以使用其他扩展来完成这项工作，例如**PCOV** ([https://github.com/krakjoe/pcov](https://github.com/krakjoe/pcov))，如果你只想做代码覆盖率报告，它的性能会更好。然而，Xdebug是一个极其有用的调试器，你应该了解它——如果你不了解，我们鼓励你查看一些关于它的教程。
- en: How to generate code coverage reports
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何生成代码覆盖率报告
- en: To demonstrate how to create a code coverage report, we will use our little
    demo application from the previous section of this chapter. To follow up on the
    example, check it out from GitHub, run `composer install`, and make sure you have
    Xdebug installed with `mode` set to `coverage`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何创建代码覆盖率报告，我们将使用本章前一部分中的小演示应用程序。为了跟进这个例子，请从 GitHub 上检出它，运行 `composer install`，并确保你已经安装了
    `mode` 设置为 `coverage` 的 Xdebug。
- en: Before we start generating a report, let us see which report formats PHPUnit
    has to offer. It can generate reports in a variety of formats that you will most
    likely not need right now, such as `Clover`, `Cobertura`, `Crap4J`, or the `PHPUnit`
    XML format. They can get more relevant, though, when you start integrating PHPUnit
    with other tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始生成报告之前，让我们看看 PHPUnit 提供哪些报告格式。它可以生成各种格式的报告，你可能现在不需要，例如 `Clover`、`Cobertura`、`Crap4J`
    或 `PHPUnit` XML 格式。然而，当你开始将 PHPUnit 与其他工具集成时，它们可能会变得更加相关。
- en: 'However, we do not want to do this in this book, so we are only interested
    in the two most accessible formats: text and HTML. The text format can directly
    be printed on the command line, which is useful when you want instant results
    or to integrate PHPUnit in your build pipeline, while the HTML format offers more
    information.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想在这本书中这样做，所以我们只对两种最易访问的格式感兴趣：文本和 HTML。文本格式可以直接在命令行上打印，这在你想立即得到结果或集成 PHPUnit
    到你的构建管道时非常有用，而 HTML 格式提供了更多信息。
- en: 'For our example, we want to write both report formats into a new folder called
    `reports` in the project root. Although you can generate them using the many PHPUnit
    runtime options, we want to use the `phpunit.xml` configuration file to define
    what to generate upon every test run. The following code snippet shows a minimal
    version, reduced for readability. In our GitHub repository, you will find the
    full `phpunit.xml` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们希望将两种报告格式都写入项目根目录下名为 `reports` 的新文件夹中。虽然你可以使用许多 PHPUnit 运行时选项来生成它们，但我们希望使用
    `phpunit.xml` 配置文件来定义每次测试运行时要生成的内容。以下代码片段显示了一个最小版本，为了可读性进行了简化。在我们的 GitHub 仓库中，你可以找到完整的
    `phpunit.xml` 文件：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Besides the basic configuration, which includes a definition of the `tests`
    folder we need for the regular test runs, we added the `<coverage>` node. This
    contains two child nodes: `<includes>` and `<report>`. It is important to specify
    when using the `<includes>` node which directory and file extension should be
    used for collecting code coverage information. Otherwise, PHPUnit will not generate
    any reports, but also will not complain about missing information. This can be
    quite confusing at times.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的配置之外，这包括定义我们需要的 `tests` 文件夹以进行常规测试运行，我们还添加了 `<coverage>` 节点。这个节点包含两个子节点：`<includes>`
    和 `<report>`。在使用 `<includes>` 节点时，指定用于收集代码覆盖率信息的目录和文件扩展名非常重要。否则，PHPUnit 不会生成任何报告，也不会对缺失的信息提出抱怨。这有时可能会相当令人困惑。
- en: Furthermore, we need to tell PHPUnit where to write which reports. We use the
    `<report>` node for this, and as you can see, we specified both the HTML and text
    reports to be written into the `reports` folder in our project root, which will
    be created if it does not exist.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要告诉 PHPUnit 将哪些报告写入何处。我们使用 `<report>` 节点来完成这项工作，正如你所看到的，我们指定了 HTML 和文本报告都应写入项目根目录下的
    `reports` 文件夹中，如果它不存在，将会被创建。
- en: 'PHPUnit expects the configuration file to be named `phpunit.xml` and to be
    in the project root. If this has been done, you can quickly execute the generation
    of the reports by running the following command without any further options or
    arguments:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 预期配置文件命名为 `phpunit.xml` 并位于项目根目录。如果已经完成，你可以通过运行以下命令快速执行报告的生成，无需任何其他选项或参数：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the execution of the preceding command, you will find a `reports` folder
    generated in your project root. It should contain two things: first, a `coverage.txt`
    file that contains a report in text format, and second, a `coverage` folder that
    contains an HTML report.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的命令之后，你将在项目根目录下找到一个名为 `reports` 的文件夹。它应该包含两样东西：首先，一个包含文本格式报告的 `coverage.txt`
    文件，其次，一个包含 HTML 报告的 `coverage` 文件夹。
- en: Code coverage is costly
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是昂贵的
- en: Using Xdebug to generate code coverage reports will slow down the execution
    of your test suite because Xdebug has to collect a lot of data, and it was not
    built for performance. We therefore recommend you enable Xdebug and the report
    generation only if necessary but keep it disabled during your regular test runs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Xdebug生成代码覆盖率报告将减慢你的测试套件的执行速度，因为Xdebug需要收集大量数据，而且它并不是为了性能而构建的。因此，我们建议仅在必要时启用Xdebug和报告生成，但在常规测试运行期间保持禁用。
- en: 'The text report is short, but already tells you how well your tests cover your
    application, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 文本报告虽然简短，但已经告诉你你的测试如何覆盖你的应用程序，如下面的截图所示：
- en: '![Figure 10.2: Text code coverage report'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：文本代码覆盖率报告'
- en: '](img/Figure_10.2_B19050.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B19050.jpg)'
- en: 'Figure 10.2: Text code coverage report'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：文本代码覆盖率报告
- en: 'To get more details, please open the `reports/coverage/index.html` file in
    your browser. It should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多详细信息，请打开浏览器中的`reports/coverage/index.html`文件。它应该看起来像这样：
- en: '![Figure 10.3: HTML code coverage report'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：HTML代码覆盖率报告'
- en: '](img/Figure_10.3_B19050.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B19050.jpg)'
- en: 'Figure 10.3: HTML code coverage report'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：HTML代码覆盖率报告
- en: 'You will find the same information from the text report there, but with a better
    visualization. Furthermore, the report is interactive. For example, if you click
    on the `MyOtherClass.php` link on the left, you will be taken to a detailed report
    for that class, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在那里找到相同的文本报告信息，但可视化效果更好。此外，报告是交互式的。例如，如果你点击左侧的`MyOtherClass.php`链接，你将被带到该类的详细报告，如下面的截图所示：
- en: '![Figure 10.4: HTML code coverage report – class view'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：HTML代码覆盖率报告 – 类视图'
- en: '](img/Figure_10.4_B19050.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B19050.jpg)'
- en: 'Figure 10.4: HTML code coverage report – class view'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：HTML代码覆盖率报告 – 类视图
- en: 'Two things are noteworthy here: firstly, in the **Functions and Methods** section,
    you might have already recognized the CRAP metric which we introduced in [*Chapter
    8*](B19050_08.xhtml#_idTextAnchor100)*, Code Quality Metrics*. Here, you can finally
    see it in action.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点值得关注：首先，在**函数和方法**部分，你可能已经认出了我们在[*第8章*](B19050_08.xhtml#_idTextAnchor100)*，代码质量指标*中引入的CRAP指标。在这里，你终于可以看到它在实际中的应用。
- en: Secondly, the report shows you in detail which lines have been accessed during
    the test (green background), and which have not (red background). If there had
    been any lines that were inaccessible at all (for example, another statement after
    the last `return` statement), it would have been displayed as **Dead Code** (yellow
    background). Dead code can safely be removed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，报告详细显示了在测试期间哪些行被访问过（绿色背景），哪些没有被访问过（红色背景）。如果有任何行完全无法访问（例如，在最后一个`return`语句之后的另一个语句），它将显示为**死代码**（黄色背景）。死代码可以安全地删除。
- en: You now have a nice overview of the code coverage of your project. If files
    appear with a red bar, they have not been executed during the test run at all,
    so this is where you could improve your test suite.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你对项目的代码覆盖率有了很好的概述。如果文件以红色条形图显示，这意味着在测试运行期间根本没有执行，所以你可以在那里改进你的测试套件。
- en: Using the @covers annotation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@covers注解
- en: 'There is one problem with code coverage: it tells you which code has been *executed*
    during the test, but that does not mean that the executed code has also been *tested*
    (that is, using assertions). This is something that PHPUnit cannot determine automatically.
    This means that even if your code coverage reports show 100% and green bars everywhere,
    it does not mean that your code is well tested. It was just executed during the
    run of your test suite.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率存在一个问题：它告诉你测试期间哪些代码已被*执行*，但这并不意味着执行的代码也已被*测试*（即使用断言）。这是PHPUnit无法自动确定的事情。这意味着即使你的代码覆盖率报告显示100%并且到处都是绿色条形图，这也并不意味着你的代码得到了良好的测试。它只是在测试套件的运行过程中被执行了。
- en: 'To overcome this problem, it is recommended to use the `@covers` annotation
    at the class level, as illustrated here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，建议在类级别使用`@covers`注解，如下所示：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This improves the accuracy of our tests because by using the `@covers` annotation,
    we explicitly declare which code is meant to be tested by our tests. For example,
    let us say the class under test uses an external service. You only want to test
    that one class, not the service it uses, so you solely write assertions that check
    the class under test. Without the `@covers` annotation, though, PHPUnit would
    still include the external service in the code coverage report because it was
    executed during the test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这提高了我们测试的准确性，因为我们通过使用 `@covers` 注解，明确声明了我们的测试要测试哪些代码。例如，假设我们要测试的类使用了一个外部服务。你只想测试这个类，而不是它所使用的服务，因此你只编写检查要测试的类的断言。然而，如果没有
    `@covers` 注解，PHPUnit 仍然会将外部服务包含在代码覆盖率报告中，因为它是测试过程中执行的一部分。
- en: You can use `@covers` also on a method level; however, this could cause problems
    if— for example—you refactor a class and extract methods to some other class.
    If you forget to adjust the `@covers` annotation on the method level here, the
    coverage report will not be accurate anymore.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在方法级别上使用 `@covers`；然而，如果你——例如——重构一个类并将方法提取到另一个类中，这可能会引起问题。如果你忘记调整这里方法级别的
    `@covers` 注解，覆盖率报告将不再准确。
- en: To force usage of the `@covers` annotation, use the `forceCoversAnnotation`
    option in the `phpunit.xml` file. If it is set to `true`, tests that do not use
    the annotation will be marked as risky; they do not fail, but they appear separately
    in the reports as something to be improved. This way, your fellow developers (and
    you) will not forget to use it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制使用 `@covers` 注解，请在 `phpunit.xml` 文件中使用 `forceCoversAnnotation` 选项。如果它设置为
    `true`，则未使用注解的测试将被标记为有风险；它们不会失败，但在报告中会单独列出，作为需要改进的内容。这样，你的同事（以及你自己）就不会忘记使用它。
- en: What to test
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要测试的内容
- en: We now know how to get detailed information about how much of our code is tested.
    So, should you strive for complete code coverage now? Should 100% be your goal?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何获取有关我们代码测试程度的详细信息。那么，你现在是否应该追求完整的代码覆盖率？是否应该将 100% 作为目标？
- en: 'As we saw in the tests of our example application in a previous part of this
    chapter, writing tests for a class does not automatically mean that you really
    test every aspect of it. Here, unfortunately, even measuring the code coverage
    will not help. However, it can help you identify tests that do not test anything.
    Especially when a lot of mocks are used in a test case, it can happen that only
    the mock gets tested, but no “real code”. Consider the following test case, which
    is a valid test that would pass:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面部分对示例应用程序的测试中看到的，为一个类编写测试并不意味着你真的测试了它的每个方面。在这里，遗憾的是，即使测量代码覆盖率也无法帮助。然而，它可以帮助你识别那些没有测试任何内容的测试。特别是在测试用例中使用了大量模拟时，可能会发生只有模拟被测试，而没有“真实代码”的情况。考虑以下测试用例，这是一个有效的测试，将会通过：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example is simplified, but it demonstrates how code coverage reports can
    help because this test would not add a single tested line to our code coverage
    ratio. Unfortunately, no tool can tell you (yet) which tests are well written
    and which should be improved or are even useless, as in our example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子虽然简化了，但它说明了代码覆盖率报告如何有助于我们，因为这个测试不会为我们的代码覆盖率比率增加任何已测试的行。不幸的是，目前还没有任何工具能告诉你哪些测试写得很好，哪些应该改进，甚至是有用的，就像我们的例子一样。
- en: Following the **Pareto principle**, aiming for 80% code coverage should already
    vastly improve your code base, and this can be achieved with a reasonable amount
    of effort. Put your focus on the code that makes your application special—often
    referred to as **business logic**. This is the code that requires most of your
    attention.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**帕累托法则**，目标是 80% 的代码覆盖率应该已经极大地改善了你的代码库，而且这可以通过合理的努力实现。将你的重点放在使你的应用程序特殊的那部分代码上——通常被称为**业务逻辑**。这是需要你大部分注意力的代码。
- en: Pareto principle
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 帕累托法则
- en: The Pareto principle states that 80% of results are achieved with 20% of the
    total effort. The remaining 20% of the results require the quantitatively most
    work, with 80% of the total effort.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 帕累托法则指出，80% 的结果是通过 20% 的总努力实现的。剩下的 20% 的结果需要量化的最大工作量，占用了 80% 的总努力。
- en: There is also trivial code that does not really need to be tested. A common
    example is testing for getters and setters. If these methods contain further logic,
    it makes sense to test them, of course. But if they are just simple functions
    that set or return the value of a property, it is a waste of time to write tests
    for them. Still, you would need to do this if you would like to strive for 100%
    code coverage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有那些实际上并不需要测试的简单代码。一个常见的例子是测试获取器和设置器。如果这些方法包含进一步的逻辑，当然有测试它们的道理。但如果它们只是设置或返回属性值的简单函数，为它们编写测试就是浪费时间。尽管如此，如果你想要追求100%的代码覆盖率，你仍然需要这样做。
- en: Other examples are configuration files, factories, or route definitions. It
    is sufficient to use E2E or integration tests, which ensure that the application
    works in general. They implicitly (that is, without using concrete assertions)
    test all the **glue code**, which is all the code that keeps your application
    together but is tedious to test.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子包括配置文件、工厂或路由定义。使用端到端（E2E）或集成测试就足够了，这些测试确保应用程序总体上能正常工作。它们隐式地（即，不使用具体的断言）测试了所有**粘合代码**，这些代码是保持你的应用程序在一起的所有代码，但测试起来却很繁琐。
- en: Particularly, E2E tests are usually not counted into the code coverage metric
    because it is technically difficult to do so. If you have them, though, they will
    add an extra layer of test coverage that cannot be measured. You cannot brag about
    100% code coverage, but you know that all the different test types have your back,
    and that should be our number one goal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是端到端（E2E）测试通常不计入代码覆盖率指标，因为技术上很难做到这一点。尽管如此，如果你有这些测试，它们将增加一个额外的测试覆盖率层，这是无法测量的。你不能吹嘘100%的代码覆盖率，但你清楚所有不同的测试类型都在支持你，而这应该是我们的首要目标。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed why you should use automated testing and how it
    improves your code quality. We covered the main three testing types, which are
    unit testing, integration testing, and E2E testing, with their pros and cons,
    potential pitfalls, and our recommendations on how to use them. Finally, you learned
    about the concept of code coverage, and how to use it in your own projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为什么你应该使用自动化测试以及它是如何提高你的代码质量的。我们涵盖了主要的三个测试类型，即单元测试、集成测试和端到端（E2E）测试，包括它们的优缺点、潜在陷阱以及我们关于如何使用它们的建议。最后，你了解了代码覆盖率的概念，以及如何在你的项目中使用它。
- en: Together with the knowledge from the previous chapter about code quality tools
    and how to organize them, in the next chapter, we can finally start combining
    all these tools together into a process that helps to run all of them in structured
    and reliable ways—build pipelines.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 结合前一章关于代码质量工具及其组织方式的知识，在下一章中，我们终于可以开始将这些工具组合成一个流程，帮助以结构化和可靠的方式运行所有这些工具——构建管道。
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are more test types out there than we could cover in this chapter. If
    you find the world of automated testing as fascinating as the authors do, you
    might want to check out other test types as well, such as the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖的测试类型远多于我们所能讨论的范围。如果你觉得自动化测试的世界像作者们一样迷人，你可能还想了解其他测试类型，例如以下这些：
- en: '**Mutation testing** is about modifying the code to be tested in tiny changes
    (so-called mutants). If your tests can catch these mutants, they are usually well
    written; otherwise, they will let the mutant escape. **Infection** is currently
    the best-known tool for this test type in the PHP world ([https://infection.github.io](https://infection.github.io)).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变测试**涉及对要测试的代码进行微小的更改（所谓的突变）。如果你的测试能够捕捉到这些突变，它们通常写得很好；否则，它们将让突变逃逸。**Infection**是目前PHP世界中这个测试类型最知名的工具体([https://infection.github.io](https://infection.github.io))。'
- en: '**Visual regression testing** literally compares screenshots of the application
    made during tests with original screenshots to catch problems in **Cascading Style
    Sheets** (**CSS**). While this is not directly PHP-related, it could be interesting
    for you if you want to keep the styling of your web project perfect. A good candidate
    to check is **BackstopJS** ([https://github.com/garris/BackstopJS](https://github.com/garris/BackstopJS)).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉回归测试**字面上比较测试期间生成的应用程序截图与原始截图，以捕捉**层叠样式表**（**CSS**）中的问题。虽然这并不是直接与PHP相关，但如果你想保持你的Web项目的样式完美，这可能会对你很有趣。一个值得检查的好选择是**BackstopJS**([https://github.com/garris/BackstopJS](https://github.com/garris/BackstopJS))。'
- en: '**API testing** can be considered E2E testing, but just for the API your application
    might provide. Since the tests are based on **Hypertext Transfer Protocol** (**HTTP**)
    requests, a headless browser is not needed, which makes the setup easier. A good
    choice to start with API testing is **Codeception** (https://codeception.com).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API测试**可以被视为端到端测试，但仅限于您应用程序可能提供的API。由于测试基于**超文本传输协议**（**HTTP**）请求，因此不需要无头浏览器，这使得设置更加简单。开始API测试的一个好选择是**Codeception**（https://codeception.com）。'
- en: '**Behavior-driven development** (**BDD**) is a very interesting approach because
    it focuses on the communication between stakeholders (for example, the project
    manager), QA (if there is any), and the developers. This is done by a special
    way of writing tests in a language called **Gherkin**, which basically enables
    non-technical people to write test suites. The BDD tool for PHP is called **Behat**
    ([https://github.com/Behat/Behat](https://github.com/Behat/Behat)).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是一个非常有趣的方法，因为它关注利益相关者（例如，项目经理）、QA（如果有）和开发者之间的沟通。这是通过在名为**Gherkin**的语言中以特殊方式编写测试来实现的，这基本上使非技术人员能够编写测试套件。PHP的BDD工具称为**Behat**（[https://github.com/Behat/Behat](https://github.com/Behat/Behat)）。'
