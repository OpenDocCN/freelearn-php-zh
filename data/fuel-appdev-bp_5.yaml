- en: Chapter 5. Building Your Own Restful API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 构建自己的RESTful API
- en: 'In this chapter, we will create our own microblogging application similar to
    Twitter. The social component will be fairly simple: users will post on their
    walls messages containing up to 140 characters. The real input of this chapter
    will reside in setting up a JSON API that can be accessed by external applications
    and adding automated tests that will allow you to track regressions. In order
    to limit the amount of data exchanged, we will make our application use this API
    as often as possible.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建自己的类似于Twitter的微型博客应用程序。社交组件将相当简单：用户将在他们的墙上发布最多140个字符的消息。本章的实际输入将在于设置一个可以通过外部应用程序访问的JSON
    API，并添加自动测试，这将允许你跟踪回归。为了限制交换的数据量，我们将尽可能让我们的应用程序使用此API。
- en: 'By the end of the chapter, you should know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该知道：
- en: How to create a signup form
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建注册表单
- en: How to implement a JSON API without duplicating any code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个不重复任何代码的JSON API
- en: What is the `Parser` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parser`包是什么'
- en: What are language-agnostic template systems and why use such systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是语言无关的模板系统以及为什么使用这样的系统
- en: What is the Mustache engine and how to implement views using it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mustache引擎是什么以及如何使用它实现视图
- en: What is a magic migration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是魔法迁移
- en: How to implement unit tests and run them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现单元测试并运行它们
- en: Specifications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规格
- en: It is possible for visitors to subscribe to our micro blogging application.
    Once they do, they are able to write small posts of 140 characters which will
    be displayed on their profile page. Anyone, even non-users, can see a user's profile
    page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者可以订阅我们的微型博客应用程序。一旦他们这样做，他们就能写140个字符的小帖子，这些帖子将显示在他们的个人资料页面上。任何人，即使是非用户，也可以看到用户的个人资料页面。
- en: In order to avoid authentication issues and keep this project simple, we will
    only provide a read-only JSON API. Also, we won't track applications using our
    API and therefore no limitations will be implemented (this could be an important
    point if you are thinking of publishing your own API). Therefore, only the users'
    profile information (username, creation date, and so on) and published posts will
    be available through the API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免认证问题并保持项目简单，我们只提供只读的JSON API。此外，我们不会跟踪使用我们API的应用程序，因此不会实施任何限制（如果您正在考虑发布自己的API，这可能是一个重要的点）。因此，只有用户的个人资料信息（用户名、创建日期等）和发布的帖子将通过API提供。
- en: Conception
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: 'We will need the following two models:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下两个模型：
- en: '![Conception](img/5401OS_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![概念](img/5401OS_05_01.jpg)'
- en: Entity Relationship diagram (Min-Max notation)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实体关系图（Min-Max表示法）
- en: '**User**: Since the model''s table will be generated from the `Auth` package''s
    migration, the columns will already be generated. The columns we need are `username`
    and `password`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：由于模型的表将由`Auth`包的迁移生成，因此列已经生成。我们需要的是`username`和`password`列。'
- en: '**Post**: Each post has a `content` and a `created_at` property. Since each
    post can only be published by a single user and each user can publish many posts,
    there is a `belongs_to` relationship between posts and users and a `has_many`
    relationship between users and posts. Thus, an additional `user_id` property must
    be added for the relationship.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子**：每篇帖子都有一个`content`和`created_at`属性。由于每篇帖子只能由单个用户发布，每个用户可以发布多篇文章，因此帖子与用户之间存在`belongs_to`关系，用户与帖子之间存在`has_many`关系。因此，必须添加一个额外的`user_id`属性来表示这种关系。'
- en: FuelPHP installation and configuration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FuelPHP的安装和配置
- en: 'You first need to perform the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要执行以下步骤：
- en: Install a new FuelPHP instance.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装新的FuelPHP实例。
- en: Configure Apache and the host file to handle it. In this chapter, we will access
    our application by requesting the `http://mymicroblog.app` URL.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Apache和主机文件以处理它。在本章中，我们将通过请求`http://mymicroblog.app` URL来访问我们的应用程序。
- en: Update Composer if necessary.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，更新Composer。
- en: Create a new database for your application.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建一个新的数据库。
- en: Finally, configure FuelPHP in order to allow your application to access this
    database.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，配置FuelPHP以允许您的应用程序访问此数据库。
- en: 'This project will also need the `ORM`, the `Auth`, and the `Parser` packages.
    We used the `ORM` and the `Auth` packages in previous chapters, but we never used
    the `Parser` package; we will explain its role later in *The Parser package and
    template engines* section. Since they are already installed, we just need to enable
    them. For doing this, simply open the `APPPATH/config/config.php` file and insert
    the following lines of code at the end of the returned array:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目还需要`ORM`、`Auth`和`Parser`包。我们在前面的章节中使用了`ORM`和`Auth`包，但从未使用过`Parser`包；我们将在*《Parser包和模板引擎》*部分解释其作用。由于它们已经安装，我们只需要启用它们。为此，只需打开`APPPATH/config/config.php`文件，并在返回数组的末尾插入以下代码行：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, you can uncomment the appropriate lines. This will load the `ORM`,
    the `Auth`, and the `Parser` package every time a FuelPHP instance is loaded.
    We also need to change a few configuration items for the `Auth` package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以取消注释适当的行。这将每次加载FuelPHP实例时加载`ORM`、`Auth`和`Parser`包。我们还需要为`Auth`包更改一些配置项。
- en: First, copy the file located at `PKGPATH/auth/config/auth.php` to `APPPATH/config/auth.php`
    and `PKGPATH/auth/config/simpleauth.php` to `APPPATH/config/simpleauth.php`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将位于`PKGPATH/auth/config/auth.php`的文件复制到`APPPATH/config/auth.php`，并将`PKGPATH/auth/config/simpleauth.php`复制到`APPPATH/config/simpleauth.php`。
- en: Then, open the configuration file `APPPATH/config/auth.php` and change the `salt`
    value to a random string (this is a security precaution). We will use the `Simpleauth`
    driver here, as we don't need many features in our authentication system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开配置文件`APPPATH/config/auth.php`，将`salt`值更改为随机字符串（这是一种安全预防措施）。在这里，我们将使用`Simpleauth`驱动程序，因为我们不需要在认证系统中使用很多功能。
- en: 'Then, open the file `APPPATH/config/simpleauth.php` and set the value of `login_hash_salt`
    to a random string (again, for security precaution). Install the `Auth` tables
    by executing their migration files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`APPPATH/config/simpleauth.php`文件，将`login_hash_salt`的值设置为随机字符串（再次，出于安全考虑）。通过执行迁移文件来安装`Auth`表：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you take a look at the database, you should see that several tables have
    been generated:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看数据库，你应该会看到已经生成了几个表：
- en: '`users`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`'
- en: '`users_clients`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_clients`'
- en: '`users_providers`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_providers`'
- en: '`users_scopes`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_scopes`'
- en: '`users_sessions`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_sessions`'
- en: '`users_sessionscopes`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_sessionscopes`'
- en: However, as expected, there are much fewer tables generated than for the `Ormauth`
    driver.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如预期的那样，生成的表比`Ormauth`驱动程序少得多。
- en: The Parser package and template engines
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器包和模板引擎
- en: You may notice that we added the `parser` package into the `always_load.package`
    key. Thanks to this package, instead of writing our view in PHP, we are able to
    use template engines. For those of you that are not familiar with template engines,
    they allows us to write our view files in a different syntax.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们已将`parser`包添加到`always_load.package`键中。多亏了这个包，我们不再需要用PHP编写视图，而是能够使用模板引擎。对于那些不熟悉模板引擎的人来说，它们允许我们使用不同的语法编写视图文件。
- en: 'For instance, a list of items might be displayed by writing the following code
    in PHP:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过在PHP中编写以下代码来显示项目列表：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But, using the HAML template engine, it can be written like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用HAML模板引擎，可以写成这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, by using the Mustache template engine, it can be written like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用Mustache模板引擎，可以写成这样：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are various reasons you might want to use template engines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有各种原因想要使用模板引擎：
- en: It allows you to write much more concise and elegant code, for example as in
    the HAML language.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你编写更简洁、更优雅的代码，例如在HAML语言中。
- en: It allows you to keep a consistent code format.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你保持一致的代码格式。
- en: It forces you to separate logic from presentation. Thus, you can easily hand
    your code to a designer who can change it without having to understand any PHP.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使你将逻辑与表示分离。因此，你可以轻松地将代码交给设计师，设计师可以更改它而无需理解任何PHP。
- en: For our project, we are going to use the Mustache template engine, but for none
    of the preceding reasons.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将使用Mustache模板引擎，但并非出于上述任何原因。
- en: A major benefit of language-agnostic template engines
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言无关模板引擎的主要好处
- en: 'If you open the main web page of the Mustache template engine ([http://mustache.github.io/](http://mustache.github.io/)),
    you are going to see that the engine is available in many different languages
    (Ruby, JavaScript, Python, Node.js, PHP, Java, C++, ASP, C#, and so on). However,
    it doesn''t matter which language you are going to use the engine: the syntax
    of the template will remain the same and the language won''t have any influence
    on the code you will write. This is because Mustache is a language-agnostic template
    engine. This is a great advantage if you work with a team using many different
    languages such as PHP, JavaScript, Ruby, or Python; your views can be written
    in the same common markup language. We are going to use this feature to our own
    advantage.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开Mustache模板引擎的主页([http://mustache.github.io/](http://mustache.github.io/))，您会发现该引擎在许多不同的语言中都有可用（Ruby、JavaScript、Python、Node.js、PHP、Java、C++、ASP、C#等等）。然而，您打算使用哪种语言使用该引擎并不重要：模板的语法将保持不变，语言不会对您所编写的代码产生影响。这是因为Mustache是一个语言无关的模板引擎。如果您与使用多种不同语言（如PHP、JavaScript、Ruby或Python）的团队合作，这是一个巨大的优势；您的视图可以使用相同的通用标记语言编写。我们将利用这一特性来发挥我们的优势。
- en: 'The following diagram shows the most common way that websites work right now:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了网站目前最常见的工作方式：
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![语言无关模板引擎的主要优势](img/5401OS_05_02.jpg)'
- en: 'But you often need to dynamically load new content once your webpage is displayed
    in your browser:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但您通常需要在浏览器中显示网页后动态加载新内容：
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![语言无关模板引擎的主要优势](img/5401OS_05_03.jpg)'
- en: 'In order to further illustrate this, let’s say we are displaying a user’s profile
    page, and thus displaying its list of posts. If the user has already published
    1000 posts, we won’t display them all at once. We will first display the last
    30 posts, for instance, using PHP views, so at some point the web page should
    look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们假设我们正在显示一个用户的个人资料页面，因此显示其帖子列表。如果用户已经发布了1000篇帖子，我们不会一次性显示它们。我们首先使用PHP视图显示最后30篇帖子，例如，这样网页在某个时刻应该看起来像这样：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the visitor will scroll through the bottom of the web page, it will send
    an AJAX request to the server API that will replace the 30 previous posts, but
    in JSON format. The returned code should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当访客滚动到网页底部时，它将向服务器API发送AJAX请求，该请求将用JSON格式替换之前的30篇帖子。返回的代码应该看起来像这样：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have all the necessary data, but we need to transform it to HTML code so
    that the user can see it. Whether you use jQuery or direct DOM manipulations,
    you will need to use JavaScript code to do this (that code will act as JavaScript
    views). This will lead to code duplication, in the sense that, if you change the
    way posts are displayed in the PHP views, you will need to change the JavaScript
    code as well. For large projects, this will quickly become unmanageable. However,
    all this can change if we use the mustache template engine
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有必要的数据，但我们需要将其转换为HTML代码，以便用户能够看到。无论您使用jQuery还是直接DOM操作，您都需要使用JavaScript代码来完成这项工作（该代码将充当JavaScript视图）。这会导致代码重复，也就是说，如果您更改PHP视图中帖子显示的方式，您也需要更改JavaScript代码。对于大型项目来说，这会迅速变得难以管理。然而，如果我们使用mustache模板引擎，所有这一切都可以改变。
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![语言无关模板引擎的主要优势](img/5401OS_05_04.jpg)'
- en: 'Nothing exceptional here. However, the process is improved when loading dynamic
    content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。然而，在加载动态内容时，这个过程得到了改进：
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![语言无关模板引擎的主要优势](img/5401OS_05_05.jpg)'
- en: Since the Mustache template engine is language agnostic, it is possible to interpret
    a single template in both PHP and JavaScript. If we want to change, let's say,
    how posts are displayed, all we have to do is to change this one template. No
    duplication always means a more robust and maintainable application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mustache模板引擎是语言无关的，因此可以在PHP和JavaScript中解释同一个模板。如果我们想改变，比如说，帖子显示的方式，我们只需要更改这个模板。没有重复总意味着更健壮和易于维护的应用程序。
- en: Of course, we could always write a full JavaScript application that would load
    data from the API without using any PHP views. This way, no template engine would
    be necessary, as we would only write JavaScript views. However, being able to
    return HTML content directly from the server has two benefits. First, if the client
    doesn't support JavaScript—as is the case for most search engines—it will still
    be able to access the website (so the indexing of your application will be better).
    Secondly, when the client is accessing your website for the first time, you can
    speed up the process by returning the cached HTML code of the requested web page.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们始终可以编写一个完整的JavaScript应用程序，从API加载数据而不使用任何PHP视图。这样，就不需要模板引擎，因为我们只会编写JavaScript视图。然而，能够直接从服务器返回HTML内容有两个好处。首先，如果客户端不支持JavaScript——如大多数搜索引擎的情况——它仍然能够访问网站（因此，您应用程序的索引将更好）。其次，当客户端第一次访问您的网站时，您可以通过返回请求网页的缓存HTML代码来加快这个过程。
- en: 'In order to use the Mustache template engine, we need to install it. In the
    `composer.json` file, add the following line in the `require` list (don''t forget
    to add a comma in the previous line):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Mustache模板引擎，我们需要安装它。在`composer.json`文件中，在`require`列表中添加以下行（别忘了在上一行添加逗号）：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then update Composer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新Composer。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We chose the Mustache engine mainly because of its simplicity, but you have
    a lot of other choices. If you want to use the API strategy we are going to implement
    in a more complex project, I recommend you take a look at more complete solutions.
    For instance, though they are not per se language-agnostic template engines, you
    could take a look at Smarty and its JavaScript port jSmart.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择Mustache引擎主要是因为它的简洁性，但您有很多其他选择。如果您想使用我们将在更复杂的项目中实施的API策略，我建议您查看更完整的解决方案。例如，尽管它们本身不是语言无关的模板引擎，您可以考虑Smarty及其JavaScript端口jSmart。
- en: Subscription and authentication features
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和认证功能
- en: Instead of generating entire scaffolds, we will manually create controllers
    and views as we won't need most CRUD features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会生成整个脚手架，我们将手动创建控制器和视图，因为我们不需要大多数CRUD功能。
- en: Implementing the subscription and authentication forms
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现订阅和认证表单
- en: 'First, let''s create the user controller. Create a file at `APPPATH/classes/controller/user.php`
    and set its contents to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建用户控制器。在`APPPATH/classes/controller/user.php`创建一个文件，并设置其内容为：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The home page, which will be handled by the `index` action of the `User` controller,
    displays the user's posts if the user is logged in, otherwise it will display
    the subscription and authentication forms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 主页，将由`User`控制器的`index`操作处理，如果用户已登录，将显示用户的帖子，否则将显示订阅和认证表单。
- en: Since we have no user in our system, nobody can log in. Thus, we will begin
    the subscription and authentication forms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们系统中没有用户，没有人可以登录。因此，我们将开始订阅和认证表单。
- en: 'First, add the following method in the `User` controller:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`User`控制器中添加以下方法：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will come back to this action later, but so far it should be pretty straightforward
    for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这个操作，但到目前为止，这对您来说应该相当简单。
- en: 'As we are using `Controller_Template`, we need to define a template. Create
    the template view file at `APPPATH/views/template.php` and set its contents to:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`Controller_Template`，我们需要定义一个模板。在`APPPATH/views/template.php`创建模板视图文件，并设置其内容为：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is inspired by the admin template generated in [Chapter 3](ch03.html "Chapter 3. Building
    a Blog Application"), *Building a Blog Application* you can compare it to the
    file used for the scaffold generation located at `PKGPATH/oil/views/admin/template.php`.
    We use the Bootstrap framework to easily structure our web pages in a responsive
    way; we will use its CSS classes from time to time. You can take a look at the
    official documentation for Bootstrap at [http://getbootstrap.com/](http://getbootstrap.com/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它灵感来源于[第3章](ch03.html "第3章。构建博客应用程序")中生成的管理模板，*构建博客应用程序*，您可以将其与位于`PKGPATH/oil/views/admin/template.php`的用于脚手架生成的文件进行比较。我们使用Bootstrap框架以响应式的方式轻松构建我们的网页；我们不时会使用其CSS类。您可以在[http://getbootstrap.com/](http://getbootstrap.com/)查看Bootstrap的官方文档。
- en: 'We will also define some custom CSS classes inside the `website.css` file.
    Since we are already including it in our template, create the style sheet file
    at `public/assets/css/website.css` and set its contents to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`website.css`文件中定义一些自定义CSS类。由于我们已经在模板中包含了它，所以在`public/assets/css/website.css`创建样式表文件，并设置其内容为：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we need to create the `APPPATH/views/user/connect.mustache` view. We need
    to add the sign up and sign in forms there, so no rocket science:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建`APPPATH/views/user/connect.mustache`视图。我们需要在那里添加注册和登录表单，所以这不是什么高难度的任务：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since there are no dynamic parts in our view yet, you can see it is very similar
    to a classic PHP or HTML view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视图中还没有动态部分，你可以看到它与经典的PHP或HTML视图非常相似。
- en: 'Finally, as we want the `index` action of the `User` controller to be our home
    page, we need to define its URI in the `_root_` key of our `routes` configuration
    file. Open the `APPPATH/config/routes.php` configuration file and set its contents
    to:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们希望`User`控制器的`index`操作成为我们的主页，我们需要在`routes`配置文件中的`_root_`键中定义其URI。打开`APPPATH/config/routes.php`配置文件，将其内容设置为：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you request the following URL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求以下URL：
- en: '`http://mymicroblog.app/`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/`'
- en: You should see a simple yet responsive web page with sign up and sign in forms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个简单但响应式的网页，包含注册和登录表单。
- en: 'In the following screenshot, you can see what the web page looks like on large
    screens:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，你可以看到在大屏幕上网页的样子：
- en: '![Implementing the subscription and authentication forms](img/5401OS_05_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![实现订阅和认证表单](img/5401OS_05_06.jpg)'
- en: 'This is what the web page looks like on smaller screens and devices:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是小屏幕和设备上网页的样子：
- en: '![Implementing the subscription and authentication forms](img/5401OS_05_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![实现订阅和认证表单](img/5401OS_05_07.jpg)'
- en: Handling the signup form
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理注册表单
- en: 'As no user exists right now, it is time to create the `signup` action in the
    `User` controller (targeted by the signup form) so that we can create our first
    user. Create the following method and read comments (you should already be familiar
    with all these methods):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前没有用户存在，现在是时候在`User`控制器中创建`signup`操作（由注册表单指向）了，这样我们就可以创建我们的第一个用户。创建以下方法并阅读注释（你应该已经熟悉所有这些方法）：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you now request the home page and fill the signup form correctly, a new
    user should be created in the `users` table. If something goes wrong (you enter
    an incomplete e-mail address or the username already exists for instance), an
    error message will be displayed but the form will be emptied since we go back
    to the home page. This is no big deal, but it could lower your transformation
    ratio. We saved the form data in the signup_form flash variable; therefore, it
    is now accessible in the `index` action. We will pass it to the view by replacing,
    in the `index` action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在请求主页并正确填写注册表单，`users`表中应该会创建一个新的用户。如果出现问题（例如，你输入了不完整的电子邮件地址或用户名已存在），将显示错误消息，但由于我们返回主页，表单将被清空。这没什么大不了的，但它可能会降低你的转化率。我们已经将表单数据保存在`signup_form`闪存变量中；因此，现在它可以在`index`操作中访问。我们将在`index`操作中通过替换以下内容将其传递给视图：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'with:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To autofill the `username` field, open the `APPPATH/views/user/connect.mustache`
    view file and replace the `username` input in the signup form with the following
    code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动填充`username`字段，打开`APPPATH/views/user/connect.mustache`视图文件，并将注册表单中的`username`输入替换为以下代码片段：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we displayed the `$signup_form['username']` variable by writing
    `{{signup_form.username}}`. In a Mustache file, a `$var` variable is displayed
    by writing `{{var}}` and `$var['val_1']` is displayed by writing `{{var.val_1}}`.
    If `$var` is an object, `$var->val_1` is also displayed by writing `{{var.val_1}}`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过写入`{{signup_form.username}}`显示了`$signup_form['username']`变量。在Mustache文件中，通过写入`{{var}}`显示`$var`变量，通过写入`{{var.val_1}}`显示`$var['val_1']`。如果`$var`是一个对象，通过写入`{{var.val_1}}`也可以显示`$var->val_1`。
- en: You can also autofill the `email` field by adding `value="{{signup_form.email}}"`
    in the `email` input of the signup form.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在注册表单的`email`输入中添加`value="{{signup_form.email}}"`来自动填充`email`字段。
- en: Handling the signin form
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理登录表单
- en: 'Now that we can create new users, we need to handle the signin form. We will
    therefore create the `signin` action in the `User` controller:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建新用户了，我们需要处理登录表单。因此，我们将在`User`控制器中创建`signin`操作：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is again very much inspired from the `admin` controller generated by the
    administration panel generator in `oil`; take a look at the `login` action of
    the `admin` controller (used for the administration panel generation) located
    at `PKGPATH/oil/views/admin/orm/controllers/admin.php`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这又非常受`oil`中由管理面板生成器生成的`admin`控制器的影响；查看位于`PKGPATH/oil/views/admin/orm/controllers/admin.php`的`admin`控制器的`login`操作（用于管理面板生成）。
- en: Allowing the user to sign out
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户注销
- en: You probably noticed while testing the form that, once you successfully log
    in, you are unable to log out. Also, unless you have just successfully logged
    in, you don't have any idea whether you are logged in or not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在测试表单时注意到，一旦你成功登录，你就无法注销。除非你刚刚成功登录，否则你没有任何线索表明你是否已登录。
- en: To solve this problem, we will display the username in the navigation bar and
    allow the user to sign out in a dropdown, as we did in the administration panel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在导航栏中显示用户名，并允许用户在下拉菜单中注销，就像我们在管理面板中所做的那样。
- en: 'Open the template file located at `APPPATH/views/template.php`, and replace
    `<div class="navbar-header">...</div>` with the following lines of code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`APPPATH/views/template.php`的模板文件，将`<div class="navbar-header">...</div>`替换为以下代码行：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are logged in, your username should now appear in the upper right side
    of your screen. If you click on your username, the **Sign out** link should appear.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已登录，你的用户名现在应该出现在屏幕的右上角。如果你点击你的用户名，应该出现**注销**链接。
- en: 'We now have to implement this `signout` action inside the `User` controller.
    This step is pretty simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在`User`控制器中实现这个`signout`动作。这一步相当简单：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Allowing the user to create and view posts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户创建和查看帖子
- en: We will now allow users to create their own posts and display them in their
    profile page. Posts will also be the main information displayed by our API.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将允许用户创建他们自己的帖子并在他们的个人资料页中显示它们。帖子也将是我们API显示的主要信息。
- en: Generating the Post model
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成帖子模型
- en: 'We need first to generate the Post model. As usual, we will use `oil`. Enter
    the following command line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要生成帖子模型。像往常一样，我们将使用`oil`。输入以下命令行：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see that we used the `--no-timestamp` parameter here. It simply prevents
    the automatic generation of the `created_at` and `updated_at` columns. Since we
    can have a lot of posts and the `updated_at` column then be useless, we generate
    the `created_at` column manually. As a consequence, we need to specify the `CreatedAt`
    observer ourselves. Open the Post model located at `APPPATH/classes/model/post.php`
    and add the following attribute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在这里使用了`--no-timestamp`参数。它只是阻止自动生成`created_at`和`updated_at`列。由于我们可能有大量的帖子，而`updated_at`列可能变得无意义，我们将手动生成`created_at`列。因此，我们需要自己指定`CreatedAt`观察者。打开位于`APPPATH/classes/model/post.php`的帖子模型，并添加以下属性：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, simply execute your application migrations using `oil`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，简单地使用`oil`执行你的应用程序迁移：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Allowing the user to create new posts
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户创建新帖子
- en: We will begin by implementing the user interface, and then we will implement
    the post creation action.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现用户界面，然后我们将实现帖子创建动作。
- en: Implementing the user interface
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现用户界面
- en: 'First, let''s add a **New post** button in the right side of the navigation
    bar. Open the template file located at `APPPATH/views/template.php` and just after
    `<ul class="nav navbar-nav pull-right">`, add the following lines of code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在导航栏的右侧添加一个**新建帖子**按钮。打开位于`APPPATH/views/template.php`的模板文件，在`<ul class="nav
    navbar-nav pull-right">`之后添加以下代码行：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you refresh the home page and are signed in, you should see the button appear
    with a pencil icon inside it on the right-hand side of the navigation bar. We
    extensively used the Bootstrap framework, so it is recommended that you read the
    official documentation at [http://getbootstrap.com/](http://getbootstrap.com/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新主页并且已经登录，你应该在导航栏的右侧看到带有铅笔图标的按钮。我们广泛使用了Bootstrap框架，因此建议你阅读官方文档[http://getbootstrap.com/](http://getbootstrap.com/)。
- en: 'The important things to notice are the two attributes declared inside the link:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，链接内部声明的两个属性：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means that when we click on the link, we want Bootstrap to display a modal
    window using the content of the `div` element with `id = create_post_modal`. Thus,
    we need to define this `div` element. Before `</body>`, add the following lines
    of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们点击链接时，我们希望Bootstrap使用具有`id = create_post_modal`的`div`元素的内容显示一个模态窗口。因此，我们需要定义这个`div`元素。在`</body>`之前添加以下代码行：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code was inspired from the live demo in the official documentation at [http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是从官方文档[http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals)中的实时演示中获得的灵感。
- en: 'Add the following style in the `website.css` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`website.css`文件中添加以下样式：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On clicking on the **New post** button, you should now see the following modal
    window:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**新建帖子**按钮后，你现在应该看到以下模态窗口：
- en: '![Implementing the user interface](img/5401OS_05_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![实现用户界面](img/5401OS_05_08.jpg)'
- en: However, if you try to click on the **Submit** button, nothing will happen.
    We need to add some JavaScript code to do that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试点击**提交**按钮，什么也不会发生。我们需要添加一些 JavaScript 代码来实现这一点。
- en: Since this won't be very short, first create a new JavaScript file at `public/assets/js/post_form.js`
    and include it in the template by adding `'post_form.js'`, after `'bootstrap.js'`,
    inside the `Asset::js` call in the template.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不会很短，首先在`public/assets/js/post_form.js`中创建一个新的 JavaScript 文件，并通过在模板中添加`'post_form.js'`，在`'bootstrap.js'`之后，在模板的`Asset::js`调用中包含它。
- en: 'Next, open the newly created JavaScript file and set its contents to:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开新创建的 JavaScript 文件，并设置其内容为：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Read the comments in the preceding code. If you refresh the home page and try
    to submit a new post, the message **Sorry, it seems there was an issue somewhere.
    Please try again later.** will appear because we didn't implement the `post`/`create`
    action yet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 读取前面代码中的注释。如果你刷新主页并尝试提交新帖子，将出现消息**抱歉，似乎某个地方出了问题。请稍后再试**，因为我们还没有实现`post`/`create`操作。
- en: 'You might have noticed the following line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到以下行：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This line is problematic, because we are defining here the maximum number of
    characters a post can have, and we will need this information later when implementing
    our action (for validation). The best option is to define this information once
    so that, if we have to change it in the future, we only need to change one line.
    Therefore, we will write this variable in a configuration file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码有问题，因为我们在这里定义了帖子可以拥有的最大字符数，我们将在实现我们的操作（用于验证）时需要这个信息。最好的选择是只定义一次这个信息，这样，如果我们将来需要更改它，我们只需要更改一行。因此，我们将这个变量写入配置文件。
- en: 'Create the configuration file at `APPPATH/config/mymicroblog.php` and set its
    contents to:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`APPPATH/config/mymicroblog.php`中创建配置文件，并设置其内容为：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Its access will be easy later in our action, but the configuration file''s
    content is currently inaccessible by our JavaScript code. In order to solve this
    issue, open the template view file located at `APPPATH/views/template.php`, and
    add the following lines of code after `$(function(){ $(''.topbar'').dropdown();
    });` inside the `script` tag:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的操作中，稍后访问它将很容易，但配置文件的内容目前无法通过我们的 JavaScript 代码访问。为了解决这个问题，打开位于`APPPATH/views/template.php`的模板视图文件，并在`script`标签内的`$(function(){
    $('.topbar').dropdown(); });`之后添加以下代码行：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, go back to the `post_form.js` JavaScript file and replace `var postMaxNbCharacters
    = 140; // will be improved` with the following lines of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到`post_form.js` JavaScript 文件，将`var postMaxNbCharacters = 140; // will be
    improved`替换为以下代码行：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you have some common variables and constants between your JavaScript and
    your PHP code, it is always a good idea to adopt a similar solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 JavaScript 和 PHP 代码之间有一些常见的变量和常量时，始终采用类似的解决方案是一个好主意。
- en: Implementing the post creation action
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现帖子创建操作
- en: We will now handle the AJAX request, check the sent data, and create the post
    if everything is ok.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理 AJAX 请求，检查发送的数据，并在一切正常的情况下创建帖子。
- en: 'First, we will need to create the `Post` controller. Create the `APPPATH/classes/controller/post.php`
    file and, for the moment, set its contents to:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建`Post`控制器。创建`APPPATH/classes/controller/post.php`文件，目前将其内容设置为：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see that we are extending a different controller class here; instead
    of `Controller_Template`, we are extending `Controller_Rest`. It is a basic controller
    with a RESTful support built in. It will allow us to easily implement the JSON
    response we will send, and it will also help us later when we will implement the
    API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在这里扩展了一个不同的控制器类；我们不是扩展`Controller_Template`，而是扩展`Controller_Rest`。它是一个内置了
    RESTful 支持的基本控制器。它将允许我们轻松实现我们将要发送的 JSON 响应，并且它还将帮助我们稍后实现 API。
- en: 'To illustrate this, add the following test action:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，添加以下测试操作：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you request the following URL now:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在请求以下 URL：
- en: '`http://mymicroblog.app/post/test`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/test`'
- en: 'The following output should appear:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应该出现以下输出：
- en: '**The requested REST method returned an array or object:**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求的 REST 方法返回了一个数组或对象：**'
- en: '**{ "test_1": 42, "test_2": "Answer to the Ultimate Question", "test_3": {
    "test_4": [ "test_5", "test_6", "test_7" ], "test_8": true, "test_9": null } }**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**{ "test_1": 42, "test_2": "终极问题的答案", "test_3": { "test_4": [ "test_5", "test_6",
    "test_7" ], "test_8": true, "test_9": null } }**'
- en: 'If you request the following URL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求以下 URL：
- en: '`http://mymicroblog.app/post/test.json`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/test.json`'
- en: 'It will return:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you request the following URL:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求以下 URL：
- en: '`http://mymicroblog.app/post/test.xml`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/test.xml`'
- en: 'It will return:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you request the following URL:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求以下 URL：
- en: '`http://mymicroblog.app/post/test.php`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/test.php`'
- en: 'It will return:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You should have understood by now that, depending on the extension defined in
    the requested URL, the action will return a result in the associated format. I
    recommend you to read the official documentation at [http://fuelphp.com/docs/general/controllers/rest.html#/formats](http://fuelphp.com/docs/general/controllers/rest.html#/formats)
    to see which formats are supported.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解了，根据请求 URL 中定义的扩展名，动作将以相关格式返回结果。我建议你阅读官方文档[http://fuelphp.com/docs/general/controllers/rest.html#/formats](http://fuelphp.com/docs/general/controllers/rest.html#/formats)，以查看支持哪些格式。
- en: The documentation can be accessed by opening the FuelPHP website and navigating
    to **DOCS** | **FuelPHP** | **General** | **Controllers** | **Rest**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过打开 FuelPHP 网站，导航到 **DOCS** | **FuelPHP** | **General** | **Controllers**
    | **Rest** 来访问文档。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A specific property of the REST controllers is that they allow you to implement
    actions that only answer to specific HTTP methods. For instance, if we had named
    our `action_test` method as `get_test`, the `test` action would have only responded
    to `GET` requests. The same is true for `POST`, `PUT`, `DELETE`, and `PATCH` requests;
    you are again recommended to read the official FuelPHP documentation about REST
    controllers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: REST 控制器的一个特定属性是它们允许你实现只对特定 HTTP 方法做出响应的动作。例如，如果我们把 `action_test` 方法命名为 `get_test`，则
    `test` 动作将只响应 `GET` 请求。对于 `POST`、`PUT`、`DELETE` 和 `PATCH` 请求也是如此；再次建议你阅读关于 REST
    控制的官方 FuelPHP 文档。
- en: 'Delete the `test` action and add the following `create` action:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 `test` 动作并添加以下 `create` 动作：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now if you try to add a new valid post, a new row should be added in the `posts`
    table and the following message should appear:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你尝试添加一个新的有效帖子，`posts` 表中应该添加一行，并且应该出现以下消息：
- en: '**Your post has been successfully published!**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的帖子已成功发布！**'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Though we are sending a JSON response, we don't consider the `create` action
    as a part of the application API. As written earlier, our API will only allow
    read-only access and no authentication will be required; the action doesn't observe
    any of those requirements. However, the fact that it returns JSON content (as
    well as other formats) is a good start if you want to integrate it into an API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们发送的是 JSON 响应，但我们不认为 `create` 动作是应用程序 API 的一部分。如前所述，我们的 API 只允许只读访问，并且不需要身份验证；该动作不遵守任何这些要求。然而，如果要将它集成到
    API 中，它返回 JSON 内容（以及其他格式）是一个很好的开始。
- en: Implementing the profile page
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现个人资料页面
- en: Since we can create posts now, it would be great to display them. As we wrote
    in the specification, the user profile page displays the list of published posts,
    so we will implement it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以创建帖子，展示它们将非常棒。正如我们在规范中写的，用户个人资料页面显示已发布的帖子列表，因此我们将实现它。
- en: Configuring the routes
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置路由
- en: 'We would like to display this profile page when requesting the following URL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在请求以下 URL 时显示此个人资料页面：
- en: '`http://mymicroblog.app/USERNAME`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/USERNAME`'
- en: 'We could add a parameter to the `index` action of the `User` controller, but
    that would unnecessarily complicate the action. Instead of doing that, we are
    going to use routes to transparently reroute those URLs to the `show` action of
    the `User` controller:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `User` 控制器的 `index` 动作中添加一个参数，但这将无谓地复杂化动作。而不是这样做，我们将使用路由来透明地重定向这些 URL
    到 `User` 控制器的 `show` 动作：
- en: '`http://mymicroblog.app/user/show/USERNAME`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/user/show/USERNAME`'
- en: 'To do this, open the `APPPATH/config/routes.php` configuration file and add
    the following line at the end of the returned array:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开 `APPPATH/config/routes.php` 配置文件，并在返回数组的末尾添加以下行：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Creating the user model
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: 'Inside the `show` action, we will have to request a user from the database.
    We will create the user model to do this more easily. Create the `APPPATH/classes/model/user.php`
    file and set its contents to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `show` 动作内部，我们将需要从数据库中请求一个用户。我们将创建用户模型以更容易地完成此操作。创建 `APPPATH/classes/model/user.php`
    文件，并将其内容设置为：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Implementing the show action
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现显示动作
- en: 'We will now implement the `show` action inside the `User` controller, as we
    had done previously:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 `User` 控制器内部实现 `show` 动作，就像我们之前做的那样：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are a few more things that we need to do. First, you can see we specified
    `''related'' => ''user''` when finding posts, but we didn''t declare this relation
    inside the Post model. Fix that by opening the Post model and adding the following
    attribute:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做几件事情。首先，你可以看到我们在查找帖子时指定了`'related' => 'user'`，但我们没有在`Post`模型中声明这个关系。通过打开`Post`模型并添加以下属性来修复它：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, in the User model, you might have seen that we get the number of posts
    to load from the configuration `\Config::get(''mymicroblog.pagination_nb_posts'')`.
    We need to specify this configuration item inside the `APPPATH/config/mymicroblog.php`
    file. Inside the returned array, add the following line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在用户模型中，你可能已经看到我们是从配置`\Config::get('mymicroblog.pagination_nb_posts')`中获取要加载的帖子数量。我们需要在`APPPATH/config/mymicroblog.php`文件中指定这个配置项。在返回的数组中，添加以下行：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But there is still an issue; we haven''t loaded the configuration file yet,
    so `\Config::get(''mymicroblog.pagination_nb_posts'')` will return `null`. We
    could load the configuration file in the same action, but since we are going to
    need it elsewhere, we are going to load it in the `before` method. This method
    is called before any action is executed. Add the following line in the beginning
    of the `User` controller:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但仍然存在问题；我们还没有加载配置文件，所以`\Config::get('mymicroblog.pagination_nb_posts')`将返回`null`。我们可以在同一个操作中加载配置文件，但由于我们还需要在其他地方使用它，我们将在`before`方法中加载它。这个方法在执行任何操作之前被调用。在`User`控制器的开头添加以下行：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we want this action to work, we still need to implement the `user/show.mustache`
    view.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这个操作工作，我们仍然需要实现`user/show.mustache`视图。
- en: Implementing views
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现视图
- en: 'First, create the `APPPATH/views/user/show.mustache` view file and set its
    contents to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`APPPATH/views/user/show.mustache`视图文件，并设置其内容为：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The only new syntax that is `{{> post/list}};` it means we want to display
    the `post/list` partial, and its PHP equivalent looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新语法是`{{> post/list}};`，这意味着我们想要显示`post/list`部分，其PHP等价形式如下：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have separated the `post` listing because we will need to display it on
    other actions. Therefore, the next logical step is to implement this partial.
    Create the `APPPATH/views/post/list.mustache` view file and set its contents to:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`post`列表分离出来，因为我们还需要在其他操作中显示它。因此，下一步的逻辑步骤是实现这个部分。创建`APPPATH/views/post/list.mustache`视图文件，并设置其内容为：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We just implemented a simple `div` element and called another partial inside
    it. This new partial will only display the content of the list. Create the `APPPATH/vi`
    `ews/post/inside_list.mustache` view file and set its contents to:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只实现了一个简单的`div`元素，并在其中调用了另一个部分。这个新的部分将只显示列表的内容。创建`APPPATH/views/post/inside_list.mustache`视图文件，并设置其内容为：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To understand this, you need to understand a new Mustache tag. The `{{#posts}}`
    and `{{/posts}}` tags are implemented here to loop over the `posts` array. The
    content within these two tags will be repeated for each post. Variables displayed
    inside this loop will either be previously declared variables, or the properties
    of the current post in the loop; for instance, `{{created_at}}` is the `created_at`
    attribute of the current post in the loop, but we could display `{{independent_variable}}`,
    which would not be an attribute of the current post but of a previously declared
    variable. Take a look at the official documentation to understand how variables
    are resolved (the second link is hosted on the repository of the PHP port of Mustache
    but is quite complete and clear):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，你需要了解一个新的Mustache标签。`{{#posts}}`和`{{/posts}}`标签在这里实现，用于遍历`posts`数组。这两个标签之间的内容将为每个帖子重复。在这个循环中显示的变量将是之前声明的变量，或者是循环中当前帖子的属性；例如，`{{created_at}}`是循环中当前帖子的`created_at`属性，但我们可以显示`{{independent_variable}}`，这不会是当前帖子的属性，而是之前声明的变量。查看官方文档以了解变量是如何解析的（第二个链接托管在Mustache的PHP端口仓库中，但内容相当完整且清晰）：
- en: '[http://mustache.github.io/mustache.5.html](http://mustache.github.io/mustache.5.html)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mustache.github.io/mustache.5.html](http://mustache.github.io/mustache.5.html)'
- en: '[https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution](https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution](https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution)'
- en: 'However, if you now try to access a profile page, only the username will be
    displayed even if this user created posts. This is because Mustache doesn''t know
    where to find partials. To solve this issue, open back the `User` controller and
    add the following lines of code at the end of the `before` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你现在尝试访问个人资料页面，即使这个用户创建了帖子，也只会显示用户名。这是因为 Mustache 不知道在哪里找到部分。为了解决这个问题，请再次打开
    `User` 控制器，并在 `before` 方法的末尾添加以下代码行：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you plan to use Mustache on modules, you will need to set other paths when
    calling the `setPartialsLoader` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在模块中使用 Mustache，调用 `setPartialsLoader` 方法时你需要设置其他路径。
- en: 'We will now add some styles. Open the `public/assets/css/website.css` file
    and append the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一些样式。打开 `public/assets/css/website.css` 文件，并附加以下代码：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you refresh the profile page, the posts' list should appear now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新个人资料页面，现在应该会显示帖子列表。
- en: 'There is still an issue though: no date is displayed. However, you have probably
    read how we displayed `created_at` in the `APPPATH/views/post/inside_list.mustache`
    view file, as shown in the following lines:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然存在一个问题：没有显示日期。然而，你可能已经阅读了如何在 `APPPATH/views/post/inside_list.mustache`
    视图文件中显示 `created_at`，如下所示：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Nothing is visible, but the timestamp can be accessed inside a `span` element
    with the `post_date` class. We want to display those dates in a relative format
    (for example, 5 minutes ago) and regularly update them. We will do this using
    JavaScript and jQuery. As this is a complex operation, we will create a new JavaScript
    file. Create the `public/assets/js/posts_dates.js` file and set its contents to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也看不见，但时间戳可以访问一个带有 `post_date` 类的 `span` 元素中。我们希望以相对格式（例如，5分钟前）显示这些日期，并定期更新它们。我们将使用
    JavaScript 和 jQuery 来完成这项操作。由于这是一个复杂的操作，我们将创建一个新的 JavaScript 文件。创建 `public/assets/js/posts_dates.js`
    文件，并将其内容设置为：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we need to include this script inside the template located at `APPPATH/views/template.php`.
    Add `'posts_dates.js'`, after `'post_form.js'`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将此脚本包含在位于 `APPPATH/views/template.php` 的模板中。在 `'post_form.js'` 之后添加 `'posts_dates.js'`。
- en: Implementing the API
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API
- en: Now that we have developed the first version of the profile pages, we will begin
    to implement the API to access our website data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发了个人资料页面的第一个版本，我们将开始实现访问我们网站数据的 API。
- en: Implementing the base controller
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基控制器
- en: 'As we will need methods on both the `User` and `Post` controllers, we will
    first implement a base controller that will be extended by both controllers. Create
    the `APPPATH/classes/controller/base.php` file and set its contents to:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在 `User` 和 `Post` 控制器上使用方法，我们将首先实现一个基控制器，这两个控制器都将扩展它。创建 `APPPATH/classes/controller/base.php`
    文件，并将其内容设置为：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can see that `Controller_Base` is extending a new native controller named
    `Controller_Hybrid`. As its name suggests, it is a hybrid version implementing
    features from both `Controller_Template` and `Controller_Rest`. It is exactly
    what we need if we want an action to return JSON or HTML, depending on the context.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `Controller_Base` 正在扩展一个名为 `Controller_Hybrid` 的新原生控制器。正如其名所示，它是一个混合版本，实现了
    `Controller_Template` 和 `Controller_Rest` 的功能。如果我们想要一个动作根据上下文返回 JSON 或 HTML，这正是我们需要的。
- en: First, move the `before` method we implemented in the `User` controller inside
    this new `Base` controller.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将我们在 `User` 控制器中实现的 `before` 方法移动到这个新的 `Base` 控制器中。
- en: 'Next, implement the following methods:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现以下方法：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Each time we want a hybrid response (HTML, JSON, or XML depending on the extension
    requested), we will have to call the `hybrid_response` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要一个混合响应（HTML、JSON 或 XML，取决于请求的扩展名），我们都需要调用 `hybrid_response` 方法。
- en: Finally, make the `Post` and the `User` controllers extend this new `Base` controller.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让 `Post` 和 `User` 控制器扩展这个新的 `Base` 控制器。
- en: Implementing your first hybrid action
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现你的第一个混合动作
- en: 'Inside the `show` action of the `User` controller, replace `$this->template->content
    = ...;` with the following lines of code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `User` 控制器的 `show` 动作中，将 `$this->template->content = ...;` 替换为以下代码行：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now if you request the following URL:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你请求以下 URL：
- en: '`http://mymicroblog.app/USERNAME.json`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/USERNAME.json`'
- en: (Or `http://mymicroblog.app/USERNAME.xml`, as browsers generally display this
    format better)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: （或者 `http://mymicroblog.app/USERNAME.xml`，因为浏览器通常显示这个格式更好）
- en: 'You will see that the data is now accessible. The problem is that you can read
    too much information:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到数据现在可以访问了。问题是你可以读取太多的信息：
- en: The most urgent issue is that we display all the attributes for each object.
    It is very problematic for user objects as we display their hashed passwords,
    their login hash, their e-mails, and possibly other confidential information.
    This is a very serious security issue.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最紧迫的问题是，我们显示了每个对象的全部属性。对于用户对象来说，这是一个非常严重的问题，因为我们显示了他们的哈希密码、登录哈希、电子邮件，以及可能的其他机密信息。这是一个非常严重的安全问题。
- en: We don't need to display every time the same attributes of an object. For instance,
    we might want to release more information about a user when displaying its profile
    page, but only its username when displaying the `user` attribute of a post. This
    is less urgent, but still an important issue.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要每次都显示对象的相同属性。例如，当显示用户个人资料页面时，我们可能想发布更多关于用户的信息，但当显示帖子的 `user` 属性时，只显示用户名。这是一个不那么紧急的问题，但仍然是一个重要的问题。
- en: Implementing mappers to control how the information is shared
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现映射器以控制信息共享方式
- en: In order to control which information is sent through the API, we will implement
    mappers that will transform our objects to appropriate associative arrays containing
    only the attributes we want to show. The mappers will map differently objects
    depending on the context.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制通过 API 发送哪些信息，我们将实现映射器，将我们的对象转换为适当的关联数组，只包含我们想要显示的属性。映射器将根据上下文以不同的方式映射对象。
- en: 'Create the `APPPATH/classes/mapper.php` file and set its contents to:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `APPPATH/classes/mapper.php` 文件，并设置其内容为：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will now create the mappers for our Post and User models. First, create
    the `APPPATH/classes/mapper/post.php` file and set its contents to:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为我们的 Post 和 User 模型创建映射器。首先，创建 `APPPATH/classes/mapper/post.php` 文件，并设置其内容为：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, create the `APPPATH/classes/mapper/user.php` file and set its contents
    to:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建 `APPPATH/classes/mapper/user.php` 文件，并设置其内容为：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we just have to use these mappers in our `show` action of the `User` controller.
    Inside the action, replace:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在我们的 `User` 控制器的 `show` 动作中使用这些映射器。在动作内部，替换以下代码：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With the following lines of code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下代码行：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now if you request the following URLs:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你请求以下 URL：
- en: '`http://mymicroblog.app/USERNAME.json`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/USERNAME.json`'
- en: '`http://mymicroblog.app/USERNAME.xml`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/USERNAME.xml`'
- en: You should see that only the useful information appears. You can always access
    `http://mymicroblog.app/USERNAME`, as the Mustache template engine processes objects
    and associative arrays in the same way.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到只有有用的信息出现。你始终可以访问 `http://mymicroblog.app/USERNAME`，因为 Mustache 模板引擎以相同的方式处理对象和关联数组。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some open source libraries provide tools that allow you to do a similar job
    that we did with our `mapper` classes, but in a standardized and more sophisticated
    way. If you are searching for one, I recommend that you take a look at the `fractal`
    library at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开源库提供了工具，允许你以标准化和更复杂的方式执行我们用 `mapper` 类所做的类似工作。如果你正在寻找这样的库，我建议你查看 `fractal`
    库，网址为 [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/)。
- en: Improving the listing
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进列表
- en: The profile web pages are still incomplete as we only show the users' last 20
    posts. It would be great to improve this listing by adding a **See more** button
    that allows us to read older posts.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料网页仍然不完整，因为我们只显示了用户的最后 20 篇帖子。如果能通过添加一个“查看更多”按钮来改进这个列表，以便我们可以阅读更早的帖子，那就太好了。
- en: I recommended you to generate many posts (you could do that programmatically)
    on a profile in order to test our interface.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你生成许多帖子（你可以通过编程方式完成）在一个个人资料中，以便测试我们的界面。
- en: Giving JavaScript access to our Mustache views
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给 JavaScript 访问我们的 Mustache 视图
- en: In this section, we are going to transform JSON data to HTML content using JavaScript.
    Indeed, when you will for instance click on the **See more** button, an AJAX request
    will be sent toward our API that will return JSON data. We need to transform this
    JSON code to HTML content so that the viewer can read it but as we don't want
    any code duplication, we will give the JavaScript code access to our Mustache
    views. This will be done by copying all the Mustache files content into an object
    in the `public/assets/js/templates.js` JavaScript file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JavaScript 将 JSON 数据转换为 HTML 内容。确实，当你点击例如“查看更多”按钮时，将向我们的 API 发送 AJAX
    请求，该请求将返回 JSON 数据。我们需要将此 JSON 代码转换为 HTML 内容，以便观众可以阅读它，但我们不希望有任何代码重复，因此我们将给 JavaScript
    代码访问我们的 Mustache 视图。这将通过将所有 Mustache 文件的内容复制到 `public/assets/js/templates.js`
    JavaScript 文件中的对象来完成。
- en: Generating the templates.js file
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成 templates.js 文件
- en: We will discuss two alternatives to generate the `template.js` file.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论两种生成`template.js`文件的方法。
- en: The easy and dirty way
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单而直接的方法
- en: 'The easy and dirty solution is to regenerate this file each time someone accesses
    your application in development mode. To do this, open a `APPPATH/bootstrap.php`
    file and add the following lines of code at the end:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 简单而直接的方法是在开发模式下每次有人访问您的应用程序时都重新生成此文件。为此，打开`APPPATH/bootstrap.php`文件，并在末尾添加以下代码行：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Even though we generate the file only on development mode, it can become unsustainable
    if you have a big application containing lots of templates; you will have latency
    and memory issues. You also might need to change some permission to allow the
    file to be created. In most cases, you should be ok though, and a good point of
    this solution is that it doesn't require any dependency.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只在开发模式下生成文件，但如果您的应用程序包含大量模板，这可能会变得不可持续；您将遇到延迟和内存问题。您可能还需要更改一些权限，以便创建文件。但在大多数情况下，您应该没问题，并且这个解决方案的一个优点是不需要任何依赖。
- en: Using guard-templates
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用guard-templates
- en: Instead of generating the JavaScript file each time you request your application,
    you could use a utility such as guard-templates. The idea is that you launch this
    utility when you are coding your application, and that utility will track any
    file change and regenerate the JavaScript file when necessary.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在请求应用程序时每次生成JavaScript文件，而不是使用类似于guard-templates的实用程序。这个想法是在您编码应用程序时启动这个实用程序，并且该实用程序将跟踪任何文件更改，并在必要时重新生成JavaScript文件。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Please note that, at the time of writing, this utility doesn''t seem to work
    on Ubuntu: if that is still the case when you read the book, you are recommended
    to use the solution we provided in the last section.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在撰写本文时，此实用程序似乎在Ubuntu上不起作用：如果您在阅读本书时仍然遇到这种情况，建议您使用我们在上一节中提供的解决方案。
- en: 'You first need Ruby and gem installed on your computer. Then, you must install
    the `guard-template` gem by executing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要在您的计算机上安装Ruby和gem。然后，您必须通过执行以下命令来安装`guard-template`gem：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then execute the following command at the root of your website directory (as
    you did for `oil`):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的网站目录根目录下执行以下命令（就像您为`oil`所做的那样）：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Open the generated `Guardfile` file at the root of your website directory;
    it contains a sample configuration of the guard-templates utility. Replace its
    content with:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于您网站目录根目录下的生成的`Guardfile`文件；它包含guard-templates实用程序的示例配置。用以下内容替换其内容：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Understanding this configuration should be fairly easy. If you have any doubt,
    you can always check the official documentation at [https://github.com/thegreatape/guard-templates](https://github.com/thegreatape/guard-templates).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 理解此配置应该相当简单。如果您有任何疑问，您始终可以检查[https://github.com/thegreatape/guard-templates](https://github.com/thegreatape/guard-templates)的官方文档。
- en: 'You can then launch `guard` by executing the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过执行以下命令来启动`guard`：
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It will then generate the JavaScript file and regenerate it each time any Mustache
    template is changed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成JavaScript文件，并在任何Mustache模板更改时重新生成它。
- en: Integrating template.js and Mustache.js
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成template.js和Mustache.js
- en: Now that our Mustache templates are stored into a JavaScript file, we have to
    integrate it into our website.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Mustache模板存储到JavaScript文件中，我们必须将其集成到我们的网站中。
- en: First, we must install `mustache.js`, which is the JavaScript port of Mustache.
    In order to do this, go to the `mustache.js` repository at [https://github.com/janl/mustache.js](https://github.com/janl/mustache.js).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装`mustache.js`，这是Mustache的JavaScript端口。为了做到这一点，请访问[https://github.com/janl/mustache.js](https://github.com/janl/mustache.js)的`mustache.js`存储库。
- en: Clone the repository or download and unzip the archive in the `public/assets/js/mustache`
    folder.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public/assets/js/mustache`文件夹中克隆存储库或下载并解压存档。
- en: 'We will also implement the `render` function, which is inspired from the `render`
    function of FuelPHP (the equivalent of `View::forge(...)->render()`). To do this,
    create the `public/assets/js/view.js` file and set its contents to:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`render`函数，该函数灵感来源于FuelPHP的`render`函数（`View::forge(...)->render()`的等价物）。为此，创建`public/assets/js/view.js`文件，并将其内容设置为：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We now need to include our JavaScript files in the template. Open the `APPPATH/views/template.php`
    file and add the following lines of code after the `''bootstrap.js''`, line:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在模板中包含我们的JavaScript文件。打开`APPPATH/views/template.php`文件，并在`'bootstrap.js'`行之后添加以下代码行：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Refresh your web page. If you open the JavaScript console (in your browser''s
    developer tools) now and execute:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新您的网页。如果您现在打开JavaScript控制台（在浏览器开发者工具中），并执行：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You should see that it returns the correct HTML code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到它返回正确的HTML代码。
- en: Implementing the post/list action
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现post/list动作
- en: 'We will also need to retrieve the posts data from the server. For this, we
    will implement two actions inside the `Post` controller: the `list` and `count`
    actions. Add the following code at the end of the `Post` controller:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从服务器检索帖子数据。为此，我们将在 `Post` 控制器中实现两个动作：`list` 和 `count` 动作。在 `Post` 控制器末尾添加以下代码：
- en: '[PRE70]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `get` and `count` actions call the `static::get_posts_query` method. We
    need to implement this method, and we will do that in the `Base` controller:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 和 `count` 动作调用 `static::get_posts_query` 方法。我们需要实现这个方法，我们将在 `Base` 控制器中完成：'
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, if you request the following URL:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您请求以下URL：
- en: '`http://mymicroblog.app/post/list.json?user_id=ID`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/list.json?user_id=ID`'
- en: It will return the 20 latest posts of the user with `id = ID`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `id = ID` 的用户的最新的20篇帖子。
- en: 'If you request the following URL:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您请求以下URL：
- en: '`http://mymicroblog.app/post/list.json?user_id=ID&before_id=30`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/list.json?user_id=ID&before_id=30`'
- en: It will return the 20 latest posts with an `id` value less than `30` that have
    been published by the user with `id = ID`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `id` 值小于 `30` 的用户 `id = ID` 发布的最近20篇帖子。
- en: 'If you request the following URL:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您请求以下URL：
- en: '`http://mymicroblog.app/post/list.json?user_id=ID&after_id=30`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/list.json?user_id=ID&after_id=30`'
- en: It will return the 20 latest posts with an `id` value greater than `30` that
    have been published by the user with `id = ID`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `id` 值大于 `30` 的用户 `id = ID` 发布的最近20篇帖子。
- en: 'Now, if you request the following URL:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您请求以下URL：
- en: '`http://mymicroblog.app/post/count.json?user_id=ID`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/count.json?user_id=ID`'
- en: It will return the number of posts published by the user with `id = ID`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回用户 `id = ID` 发布的帖子数量。
- en: 'If you request the following URL:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您请求以下URL：
- en: '`http://mymicroblog.app/post/count.json?user_id=ID&before_id=30`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/count.json?user_id=ID&before_id=30`'
- en: It will return the number of posts with an `id` value less than `30` that have
    been published by the user with `id = ID`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `id` 值小于 `30` 的用户 `id = ID` 发布的帖子数量。
- en: 'If you request the following URL:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您请求以下URL：
- en: '`http://mymicroblog.app/post/count.json?user_id=ID&after_id=30`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://mymicroblog.app/post/count.json?user_id=ID&after_id=30`'
- en: It will return the number of posts with an `id` value greater than `30` that
    have been published by the user with `id = ID`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `id` 值大于 `30` 的用户 `id = ID` 发布的帖子数量。
- en: We will use the `count` action later, when we will need to know if any posts
    have been published since we displayed a user profile.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后使用 `count` 动作，当我们需要知道自我们显示用户资料以来是否有任何帖子被发布时。
- en: 'To limit code duplication, in the `show` action of the `User` controller, replace
    `$posts = Model_Post::find(''all'', ...);` with the following lines of code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制代码重复，在 `User` 控制器的 `show` 动作中，将 `$posts = Model_Post::find('all', ...);`
    替换为以下代码行：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Preventing any duplication inside the controllers is ok, but if you need to
    implement a lot of code and methods similar to `get_posts_query` inside a controller,
    something is wrong with your implementation. You should think about moving some
    pieces of code in models, helpers, or libraries. I must say I hesitated a bit
    about where this method should be implemented, but I decided to implement it in
    the `Base` controller since it would be more convenient. In general, be wary of
    long pieces of code inside a controller, as they should not contain too much logic.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器内部防止任何重复是可以的，但如果您需要在控制器内部实现很多与 `get_posts_query` 类似的代码和方法，那么您的实现可能存在问题。您应该考虑将一些代码片段移动到模型、辅助工具或库中。我必须说我对此方法应该在哪里实现犹豫了一下，但最终我决定在
    `Base` 控制器中实现它，因为它会更方便。一般来说，要警惕控制器中的长代码块，因为它们不应该包含太多逻辑。
- en: Implementing the See more button
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现查看更多按钮
- en: 'We will need to do some changes in the views. First, open `APPPATH/views/post/inside_list.mustache`
    and replace `<div class="post">` with the following line:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在视图中做一些更改。首先，打开 `APPPATH/views/post/inside_list.mustache` 并将 `<div class="post">`
    替换为以下行：
- en: '[PRE73]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'It will allow us to identify which posts are already displayed. Then, open
    the `APPPATH/views/post/list.mustache` view and replace `<div class="row post_list">`
    with the following line:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使我们能够识别哪些帖子已经被显示。然后，打开 `APPPATH/views/post/list.mustache` 视图，将 `<div class="row
    post_list">` 替换为以下行：
- en: '[PRE74]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will allow us to know the user identifier when requesting for more posts.
    Then, add the following lines of code after `{{> post/inside_list}}`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在请求更多帖子时知道用户标识符。然后，在`{{> post/inside_list}}`之后添加以下代码行：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that the button is added, we need to specify what will happen when we click
    on it so we will code it on a new JavaScript file. Create the `public/assets/js/posts_list.js`
    file and set its contents to:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按钮已经添加，我们需要指定点击按钮时会发生什么，因此我们将在新JavaScript文件中编写它。创建`public/assets/js/posts_list.js`文件，并将其内容设置为：
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Don't forget to include this JavaScript file in the template. Open the template
    and add `'posts_list.js'`, after `'posts_dates.js'`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在模板中包含此JavaScript文件。打开模板，并在`'posts_dates.js'`之后添加`'posts_list.js'`。
- en: 'Then, add the following CSS code at the end of the `public/assets/css/website.css`
    file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`public/assets/css/website.css`文件的末尾添加以下CSS代码：
- en: '[PRE77]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The **See more** button should now work when you have more than 20 posts in
    a profile page. It could be perfected in many ways. For instance, when there are
    less than 20 posts in a profile, the button is first visible, but if you click
    on it, it will simply disappear as there are no more posts to show. There are
    many easy ways to solve this small problem, so we will leave it to you.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在个人资料页面中有超过20篇文章时，**See more**按钮现在应该可以正常工作。它可以从许多方面进行完善。例如，当个人资料中的文章少于20篇时，按钮首先可见，但如果你点击它，它将简单地消失，因为没有更多的文章可以显示。有许多简单的方法可以解决这个问题，所以我们将把它留给你。
- en: 'One improvement that could come in handy for those readers that are not very
    familiar with JavaScript is infinite scrolling. Open the `public/assets/js/posts_list.js`
    file and replace:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不太熟悉JavaScript的读者来说，一个可能很有用的改进是无限滚动。打开`public/assets/js/posts_list.js`文件，并替换：
- en: '[PRE78]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE79]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Redirecting the home page to the logged user's web page
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将主页重定向到登录用户的网页
- en: 'When the user is connected, we want to redirect the home page to his web page
    so they can take a look at their posts. In order to do this, go to the `index`
    action of the `User` controller and in place of the following line:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户连接时，我们希望将主页重定向到他的网页，这样他们就可以查看他们的帖子。为了做到这一点，请转到`User`控制器的`index`动作，并替换以下行：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Write the following lines:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下行：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That is optional, but you might also want to change and add some `Response::redirect`
    calls inside the `signin` action of the `User` controller to make things a bit
    cleaner (without changing anything the user will be redirected twice when signing
    in).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是必须的，但你可能还想在`User`控制器的`signin`动作中更改和添加一些`Response::redirect`调用，以使事情更加整洁（不会改变用户在登录时将被重定向两次的情况）。
- en: Unit tests
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are particularly suitable for this project, as it is important to
    regularly check if the API is returning the correct data. We will in this section
    quickly introduce you to how unit tests are implemented in FuelPHP. These tests
    will be very superficial as this is just an introduction. If you are not familiar
    with unit tests, you can start by reading the FuelPHP documentation about unit
    testing at [http://fuelphp.com/docs/general/unit_testing.html](http://fuelphp.com/docs/general/unit_testing.html).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试特别适合这个项目，因为定期检查API是否返回正确数据非常重要。在本节中，我们将快速向您介绍如何在FuelPHP中实现单元测试。这些测试将非常基础，因为这只是一个介绍。如果您不熟悉单元测试，可以从阅读FuelPHP关于单元测试的文档开始，文档地址为[http://fuelphp.com/docs/general/unit_testing.html](http://fuelphp.com/docs/general/unit_testing.html)。
- en: The documentation can be accessed at the FuelPHP website by navigating to **DOCS**
    | **FuelPHP** | **General** | **Unit Testing**.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以通过在FuelPHP网站上导航到**DOCS** | **FuelPHP** | **General** | **Unit Testing**来访问。
- en: For more general information, you can look at the Wikipedia web page for more
    references ([http://en.wikipedia.org/wiki/Unit_testing](http://en.wikipedia.org/wiki/Unit_testing)).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更一般的信息，你可以查看维基百科网页以获取更多参考资料([http://en.wikipedia.org/wiki/Unit_testing](http://en.wikipedia.org/wiki/Unit_testing))。
- en: To make things short, unit tests allow you to test individual units in your
    code, such as methods or classes, to check if they work as intended. In most cases,
    they are executed regularly to check if there is no regression in your project.
    In the Test Driven Development process, tests are even written before the code
    and are used as some sort type of unit specification. In that development process,
    developers first define how a method should work in unit tests, and then they
    implement the method and check that it passes all the tests and assertions (assertions
    are conditions that must be met) they have previously written.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，单元测试允许您测试代码中的单个单元（如方法或类），以检查它们是否按预期工作。在大多数情况下，它们会定期执行以检查项目中是否存在回归。在测试驱动开发过程中，测试甚至会在代码编写之前编写，并用作某种类型的单元规范。在该开发过程中，开发者首先在单元测试中定义方法应该如何工作，然后实现该方法并检查它是否通过了之前编写的所有测试和断言（断言是必须满足的条件）。
- en: Unit tests should be separated from Integration tests, that test a group of
    units and how they function together, Functional tests that check that your projects
    follow its functional requirements, and Acceptance tests that check that final
    features accessed by users are working as it is expected.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应与集成测试、测试一组单元及其如何协同工作的功能测试以及检查项目是否遵循其功能要求的验收测试以及检查最终用户访问的功能是否按预期工作的验收测试分开。
- en: 'When writing unit tests, you should try at least to stick with the following
    guidelines:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，您至少应该尝试遵循以下指南：
- en: Each unit test should only test a single code unit (generally methods, but sometimes
    classes) at a time.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元测试应一次只测试单个代码单元（通常是方法，但有时是类）。
- en: Try to write as few assertions as possible to test features, as unnecessary
    assertions lead to less maintainability.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量少写断言来测试功能，因为不必要的断言会导致可维护性降低。
- en: Tests should be independent from each other. For instance, you should not write
    a unit test that supposes another unit test has been run before.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应相互独立。例如，您不应编写一个假设另一个单元测试已经运行的单元测试。
- en: 'Each unit test purpose should be clear: Its name should be explicit and the
    code should be easy to understand (don''t hesitate to use comments).'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元测试的目的都应该是清晰的：其名称应该是明确的，代码应该是易于理解的（不要犹豫使用注释）。
- en: Now let's see in practice how to run unit tests in FuelPHP.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实际看看如何在FuelPHP中运行单元测试。
- en: 'First, you need to install PHPUnit. To do that, enter the following command
    line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装PHPUnit。为此，请输入以下命令行：
- en: '[PRE82]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'While PHPUnit is downloaded and installed, create the `APPPATH/config/oil.php`
    configuration file and set its contents to:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHPUnit下载并安装时，创建`APPPATH/config/oil.php`配置文件，并将其内容设置为：
- en: '[PRE83]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Once PHPUnit is installed, you can launch tests. First, simply execute the
    following command line:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了PHPUnit，您就可以启动测试。首先，只需执行以下命令行：
- en: '[PRE84]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output will be something like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE85]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can see, `375` tests already exist and the `php oil test` command line
    executed all of them. These tests are all in the FuelPHP core and can be found
    in the `fuel/core/tests` directory.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已有`375`个测试存在，并且`php oil test`命令行执行了所有这些测试。这些测试都在FuelPHP核心中，可以在`fuel/core/tests`目录中找到。
- en: 'We are going to create our own tests. Create the `APPPATH/tests/examples.php`
    file and set its contents to:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的测试。创建`APPPATH/tests/examples.php`文件，并将其内容设置为：
- en: '[PRE86]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: All methods beginning with `test` will be executed when running this test file.
    Read the comments in the preceding code and read the official documentation of
    PHPUnit for more information ([https://phpunit.de](https://phpunit.de)).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以`test`开头的所有方法将在运行此测试文件时执行。阅读前述代码中的注释，并阅读PHPUnit的官方文档以获取更多信息([https://phpunit.de](https://phpunit.de))。
- en: When you are running test files, FuelPHP is in the test environment. Therefore,
    you have to configure the database access in the `APPPATH/config/test/db.php`
    file. It is recommended that you create a separate database for unit tests.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行测试文件时，FuelPHP处于测试环境。因此，您必须在`APPPATH/config/test/db.php`文件中配置数据库访问。建议您为单元测试创建一个单独的数据库。
- en: 'Now, run only your application tests by executing the following command line:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过执行以下命令行仅运行您的应用程序测试：
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output will be something like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE88]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The tests have been correctly executed. However, as explained at the beginning
    of this section, we have written very superficial tests. If you want to have good
    test coverage of your application, you will need to write many more tests.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已正确执行。然而，正如本节开头所解释的，我们编写了非常表面的测试。如果您想对您的应用有良好的测试覆盖率，您将需要编写更多的测试。
- en: Possible improvements
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的改进
- en: First, you should protect all your forms from **Cross-Site Request Forgery**
    (**CSRF**) attacks as we did in [Chapter 3](ch03.html "Chapter 3. Building a Blog
    Application"), *Building a Blog Application*. As you are using Mustache templates,
    you will need to do things a little bit differently here (for instance, you will
    need to write your CSRF input in plain HTML). I recommend you read the official
    documentation at [http://fuelphp.com/docs/general/security.html#csrf](http://fuelphp.com/docs/general/security.html#csrf).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该像我们在[第3章](ch03.html "第3章。构建博客应用")中做的那样，保护所有表单免受**跨站请求伪造**（**CSRF**）攻击。由于您正在使用Mustache模板，您在这里需要做一些不同的操作（例如，您需要以纯HTML的形式编写CSRF输入）。我建议您阅读官方文档[http://fuelphp.com/docs/general/security.html#csrf](http://fuelphp.com/docs/general/security.html#csrf)。
- en: The documentation can be accessed on the FuelPHP website by navigating to **DOCS**
    | **FuelPHP** | **General** | **Security**.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到**DOCS** | **FuelPHP** | **通用** | **安全**在FuelPHP网站上访问文档。
- en: Secondly, if you want to make your API easily available using JavaScript on
    an external website, you have to set the Access-Control-Allow-Origin header to
    `*`. This can be done in the `before` method inside the `Base` controller.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果您想在外部网站上使用JavaScript轻松地提供API，您必须将Access-Control-Allow-Origin头设置为`*`。这可以在`Base`控制器中的`before`方法中完成。
- en: Next, we only used the `post/inside_list` partial in the JavaScript side of
    our application, but we could have done much more. For instance, since all the
    data is available, instead of loading the profile page HTML version when we click
    on a username, we could load the JSON data and use our partials to display the
    profile page.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只在应用的JavaScript部分使用了`post/inside_list`部分，但我们本可以做更多。例如，由于所有数据都是可用的，当我们点击用户名时，我们本可以加载JSON数据并使用我们的部分来显示个人资料页面，而不是加载个人资料页面的HTML版本。
- en: Our microblog application is still very basic. However, we could manage subscriptions,
    notifications, mentions, and direct messages; allow the users to search for posts
    and other users; automatically transform URLs in posts; improve the user interface...
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小型微博应用仍然非常基础。然而，我们可以管理订阅、通知、提及和直接消息；允许用户搜索帖子和其他用户；自动转换帖子中的URL；改进用户界面...
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a basic microblogging application that supports several
    features such as user subscription, authentication, post creation, and profile
    pages. We have seen that an API can be implemented without any code duplication
    and much effort, if it is handled correctly. We have also used Mustache, a language-agnostic
    template engine, which allowed us to use the same views in the server (PHP) and
    client (JavaScript) sides. Finally, we have used unit tests to check whether the
    features of our application are behaving as expected.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个基本的微博应用，它支持用户订阅、认证、帖子创建和个人资料页面等几个功能。我们已经看到，如果处理得当，API可以实现而无需任何代码重复和大量努力。我们还使用了Mustache，这是一个与语言无关的模板引擎，它允许我们在服务器（PHP）和客户端（JavaScript）两侧使用相同的视图。最后，我们使用了单元测试来检查我们的应用功能是否按预期运行。
- en: In the next chapter, we will introduce you to Novius OS, a Content Management
    System based on the FuelPHP framework.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您介绍基于FuelPHP框架的内容管理系统Novius OS。
