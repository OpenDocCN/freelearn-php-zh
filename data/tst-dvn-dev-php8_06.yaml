- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Applying Behavior-Driven Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用行为驱动开发
- en: 'In the previous chapter, we learned how to create and use unit tests to our
    advantage. We used unit tests and integration tests to help ensure the stability
    of our solution code. That was probably like learning how to do a basic punch
    on a punching bag. If you go to a boxing class, they’ll probably teach you how
    to use your basic punch more effectively and teach you how to use that basic punch
    to do combinations of punches, as well as how to defend against them. That’s akin
    to what **behavior-driven development** (**BDD**) and **test-driven development**
    (**TDD**) are. We first need to start with the basics: unit and integration testing.
    Now that we have those basics, we can start applying processes or techniques so
    that we can use them more effectively.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建和使用单元测试来发挥我们的优势。我们使用单元测试和集成测试来帮助确保解决方案代码的稳定性。这可能就像学习如何在沙袋上打基本拳一样。如果你去拳击课，他们可能会教你如何更有效地使用你的基本拳，并教你如何使用基本拳进行组合拳，以及如何防御。这与**行为驱动开发**（**BDD**）和**测试驱动开发**（**TDD**）类似。我们首先需要从基础开始：单元和集成测试。现在我们有了这些基础知识，我们可以开始应用流程或技术，以便我们可以更有效地使用它们。
- en: A lot of developers know how to write unit tests and integration tests—after
    all, these tests are just programs that we developers write. From my personal
    experience, what I’ve noticed is that a lot of developers won’t know how to utilize
    their unit tests and integration tests effectively on their projects. Some developers
    know how to write unit tests but could not even write one for their project. So,
    merely having basic or technical knowledge of how to write a unit test is not
    enough to help improve a project. Applying and using it effectively is what counts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都知道如何编写单元测试和集成测试——毕竟，这些测试只是我们开发者编写的程序。根据我的个人经验，我注意到许多开发者不知道如何在他们的项目中有效地利用他们的单元测试和集成测试。有些开发者知道如何编写单元测试，但甚至无法为他们的项目编写一个。所以，仅仅拥有编写单元测试的基本或技术知识是不够的，以帮助改进项目。应用并有效地使用它才是关键。
- en: With BDD and TDD, that’s what we’ll try to do. We will utilize those testing
    skills by following a process to help us build our example project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BDD和TDD，这正是我们想要尝试的。我们将通过遵循一个流程来利用这些测试技能，帮助我们构建我们的示例项目。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What is BDD?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD是什么？
- en: Applying BDD using Behat and Gherkin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Behat和Gherkin应用BDD
- en: Writing PHP code based on Gherkin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Gherkin编写PHP代码
- en: Browser emulators and Mink
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器模拟器和Mink
- en: Why bother with Gherkin, then?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那为什么还要使用Gherkin呢？
- en: By the end of the chapter, you will be able to write behavior-driven features,
    scenarios, and solution code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够编写行为驱动的特性、场景和解决方案代码。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires you to have all the containers, configurations, and testing
    tools we have utilized in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit
    Testing*. You can download the source files from this URL and run the containers:
    [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你拥有我们在[*第5章*](B18318_05.xhtml#_idTextAnchor070)、“单元测试”中使用的所有容器、配置和测试工具。你可以从以下URL下载源文件并运行容器：[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205)。
- en: Preparing the development environment for the chapter
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备本章的开发环境
- en: 'First, get the base code for [*Chapter 6*](B18318_06.xhtml#_idTextAnchor094),
    found in [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd)
    or simply run the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取[*第6章*](B18318_06.xhtml#_idTextAnchor094)的基础代码，位于[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd)，或者简单地运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器并执行本章中的命令，你应该在`docker-server-web-1`容器内部。
- en: 'Run the following command to confirm the container name for our web server:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以确认我们的Web服务器的容器名称：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run the containers, run the following command from the `/phptdd/docker`
    directory from the repository in your host machine:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，请从你的主机机器上的`/phptdd/docker`目录运行以下命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once inside the container, run the following command to install the libraries
    required through Composer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，运行以下命令通过Composer安装所需的库：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What is BDD?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是BDD？
- en: BDD is a way or a process to develop software where the intended behavior of
    a solution is first defined by the business and then translated into automated
    test scenarios, before starting the actual development of the solution code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是一种开发软件的方式或过程，其中解决方案的预期行为首先由商业定义，然后将其翻译成自动化测试场景，在开始实际开发解决方案代码之前。
- en: This development process promotes collaboration among the different departments
    or teams in a software company. It might sound ridiculous, but in my experience,
    understanding exactly “what” needs to be built and what is the actual goal of
    the project is what I always see as the most elusive part when starting a project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发流程促进了软件公司不同部门或团队之间的协作。这可能听起来很荒谬，但根据我的经验，在项目开始时，确切地了解“需要构建什么”以及项目的实际目标，是我看到的最难以捉摸的部分。
- en: There are times when the business or a client doesn’t even know what it wants,
    or maybe the business or client does not know how to express or relay those goals
    effectively. Now, imagine being a software developer for a company—your job is
    to develop solutions to problems to achieve a goal. What if that goal is not defined
    clearly? Or, what if the goal was defined by the business but not relayed properly
    to the software developers? Basically, the developers will end up developing the
    wrong solution and—worse—for the wrong problem! That’s why collaboration among
    different departments in a software company is very important.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，商业或客户甚至不知道他们想要什么，或者可能商业或客户不知道如何有效地表达或传达这些目标。现在，想象一下你是一家软件公司的软件开发者——你的工作是开发解决方案来解决问题以实现目标。如果这个目标没有明确定义呢？或者，如果目标是由商业定义的，但没有正确传达给软件开发者呢？基本上，开发者最终会开发出错误解决方案，更糟糕的是，针对错误的问题！这就是为什么软件公司不同部门之间的协作非常重要。
- en: 'Business analysts, project managers, architects, and developers can define
    what the goals are for a project, and why the project is needed in the first place.
    The test engineers and software developers can then coordinate, debate, and discuss
    with the business analysts to come up with expected or intended behaviors of a
    solution, then break them down into smaller pieces. This is the first step that’s
    needed in BDD: knowing exactly what the goal is, what needs to be built, and knowing
    which behaviors are expected from a solution.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 商业分析师、项目经理、架构师和开发者可以定义项目的目标，以及为什么项目最初是必要的。然后测试工程师和软件开发者可以与商业分析师协调、辩论和讨论，以确定解决方案的预期或期望行为，然后将它们分解成更小的部分。这是BDD（行为驱动开发）的第一个步骤：确切地知道目标是什么，需要构建什么，以及期望从解决方案中获得哪些行为。
- en: Now that we know what BDD is, we can start applying it to our example project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了BDD是什么，我们可以开始将其应用到我们的示例项目中。
- en: Applying BDD using Behat and Gherkin
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Behat和Gherkin应用BDD
- en: To help us easily understand what BDD is and how it is used, we will try to
    apply it to example scenarios in a project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们更容易地理解BDD是什么以及如何使用它，我们将尝试将其应用到项目中的示例场景中。
- en: 'Going back to [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027), *Understanding
    and Organizing the Business Requirements of Our Project*, we have created some
    Jira tickets to help us break down the features that we need to build. Within
    the **Inventory Clerk Solution** epic, we have created a user story with the following
    title:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第二章*](B18318_02.xhtml#_idTextAnchor027)，*理解和组织我们项目的业务需求*，我们已经创建了Jira票据来帮助我们分解需要构建的功能。在**库存管理员解决方案**史诗中，我们创建了一个具有以下标题的用户故事：
- en: '*As an inventory clerk, I want to be able to log in to the system so that I
    can access the* *inventory system.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为一名库存管理员，我希望能够登录到系统中，以便我可以访问库存系统*。'
- en: With this user story, we can deduce that we will need a user for the application
    and that user will need to be able to authenticate themself so that they can access
    a restricted feature.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个用户故事，我们可以推断出我们需要一个应用程序的用户，并且这个用户需要能够进行身份验证，以便他们可以访问受限制的功能。
- en: So, usually, as software developers, we’ll then go ahead and start building
    the solution code for that– write code, then check the results from the controller
    or web page we just created. We won’t be doing that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通常，作为软件开发者，我们接下来会开始构建解决方案代码——编写代码，然后检查我们刚刚创建的控制器或网页的结果。我们不会这样做。
- en: With BDD, we’ll first start with a failing scenario. Sounds familiar? Yes—from
    the previous chapter, it’s just like writing our failing unit test before we write
    the solution code to pass that failing test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 BDD，我们首先从一个失败的场景开始。听起来熟悉吗？是的——从上一章来看，这就像在我们编写解决方案代码通过那个失败的测试之前，先编写我们的失败的单元测试一样。
- en: Before we start writing our BDD test, we’ll need to use some PHP packages to
    let us do this. We’ll use the Behat testing framework to help us build and organize
    our BDD tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写 BDD 测试之前，我们需要使用一些 PHP 包来做到这一点。我们将使用 Behat 测试框架来帮助我们构建和组织我们的 BDD 测试。
- en: What is Behat?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Behat 是什么？
- en: Behat is a PHP framework built for implementing BDD in PHP. It’s a framework
    to help us PHP developers write behavior-driven tests and programs. This will
    help us write better behavior-driven programs quicker so that we won’t have to
    reinvent the wheel in coming up with bootstrap code or skeleton code to write
    these behavior-driven tests. Behat uses Gherkin to describe the actual features
    we want to test.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Behat 是一个为在 PHP 中实现行为驱动开发（BDD）而构建的 PHP 框架。它是一个框架，帮助我们 PHP 开发者编写行为驱动测试和程序。这将帮助我们更快地编写更好的行为驱动程序，这样我们就不必在编写这些行为驱动测试时重新发明轮子，即编写引导代码或骨架代码。Behat
    使用 Gherkin 来描述我们想要测试的实际功能。
- en: What is Gherkin?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gherkin 是什么？
- en: Gherkin is a language used to define business scenarios and goals. It’s in plain
    English text, so anyone in the company—even non-technical staff—will be able to
    understand the business scenario being described.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 是一种用于定义业务场景和目标的语言。它使用纯英文文本，因此公司中的任何人——甚至非技术人员——都能理解所描述的业务场景。
- en: What is Mink?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mink 是什么？
- en: This is where it gets very interesting, at least for a PHP developer like me.
    Mink is a PHP library that will serve as an emulator for a web browser. We web
    application developers develop PHP applications; our users will be using our web
    applications through a web browser. So, it will be very beneficial for us if we
    automate the process of testing our application through a web browser. Instead
    of manually clicking on buttons or filling out forms, and so on, we can just use
    some programs to do this for us. So, think about a robot version of yourself testing
    your program for you through a web browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于像我这样的 PHP 开发者来说非常有趣。Mink 是一个 PHP 库，将作为网络浏览器的模拟器。我们这些网络应用开发者开发 PHP 应用程序；我们的用户将通过网络浏览器使用我们的网络应用程序。因此，如果我们能够通过网络浏览器自动化测试应用程序的过程，这将对我们非常有好处。我们不必手动点击按钮或填写表单等，我们可以使用一些程序来为我们完成这些工作。所以，想象一下，一个机器人版本的你在通过网络浏览器为你测试程序。
- en: In the next section, we will be installing Behat.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将安装 Behat。
- en: Installing Behat and Mink
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Behat 和 Mink
- en: 'Before we start writing our first behavior-driven test programs, we’ll first
    need to install all the libraries and dependencies we need. Let’s get started:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写第一个行为驱动测试程序之前，我们首先需要安装所有需要的库和依赖项。让我们开始吧：
- en: 'Create a new directory named `behat` under the `codebase` directory so that
    we can have a separate installation directory from our Symfony application:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `codebase` 目录下创建一个名为 `behat` 的新目录，这样我们就可以有一个与我们的 Symfony 应用程序分开的安装目录：
- en: '![Figure 6.1 – Behat root directory](img/Figure_6.01_B18318.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – Behat 根目录](img/Figure_6.01_B18318.jpg)'
- en: Figure 6.1 – Behat root directory
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Behat 根目录
- en: After creating the new directory, we can go ahead and start installing the Behat
    PHP package through Composer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新目录后，我们可以继续通过 Composer 安装 Behat PHP 包。
- en: 'Using your terminal, inside the `behat` directory, run the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的终端，在 `behat` 目录中，运行以下命令：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the installation, you can verify whether Behat was successfully installed
    by running the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过运行以下命令来验证 Behat 是否成功安装：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once done, you should then see the Behat version that you just installed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该能看到你刚刚安装的 Behat 版本：
- en: '![Figure 6.2 – Behat installed](img/Figure_6.02_B18318.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Behat 已安装](img/Figure_6.02_B18318.jpg)'
- en: Figure 6.2 – Behat installed
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Behat 已安装
- en: Now, we also need to install Mink so that we can do some frontend testing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要安装 Mink，这样我们才能进行一些前端测试。
- en: 'Run the following command to install Mink:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 Mink：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Great! Now, we need to let Behat create some skeleton files to help us get
    started. Run the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们需要让 Behat 创建一些骨架文件来帮助我们开始。运行以下命令：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should now see a new directory called `features`. This is where we will
    be putting our business feature scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该会看到一个名为 `features` 的新目录。这就是我们将放置我们的业务功能场景的地方。
- en: Creating a Behat feature
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 Behat 功能
- en: Now that we have installed Behat and initialized it, we can create our first
    example feature file. We will use the Gherkin language to define the feature’s
    story. It’s literally like telling a story.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Behat 并初始化了它，我们可以创建我们的第一个示例特性文件。我们将使用 Gherkin 语言来定义特性的故事。这实际上就像讲故事一样。
- en: 'In the `features` directory, create a new file called `home.feature` and add
    the following content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `features` 目录中，创建一个名为 `home.feature` 的新文件，并添加以下内容：
- en: /var/www/html/behat/features/home.feature
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: /var/www/html/behat/features/home.feature
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have created `feature` and `scenario` files using the Gherkin language. They
    are descriptive and very easy to understand. You don’t need a programmer to understand
    what they mean. So, showing them to your colleagues such as business analysts
    or test engineers won’t be an issue; they’ll even be able to help you fine-tune
    or improve your features and scenarios.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Gherkin 语言创建了 `feature` 和 `scenario` 文件。它们是描述性的，并且非常容易理解。你不需要程序员就能理解它们的意思。所以，向你的同事，如业务分析师或测试工程师展示它们不会成为问题；他们甚至能帮助你微调或改进你的特性和场景。
- en: Next, we’ll focus on the `Feature` keyword itself and its content.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注 `Feature` 关键字及其内容。
- en: Feature keyword
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特性关键字
- en: 'As you can see in the preceding code snippet, we have written three sections
    below the `Feature` keyword. The three sections below it are set out here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们在 `Feature` 关键字下方写了三个部分。下面的三个部分如下所示：
- en: '`In order to` <business goal>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`In order to` <business goal>'
- en: '`As` `a/an` <actor>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`As` `a/an` <actor>'
- en: '`I need to be able to` <what the actor defined previously should be able to
    do>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I need to be able to` <actor previously defined should be able to do>'
- en: In the `In order to` section, we define what the business wants to achieve in
    this feature. In our example, we want our site visitors to feel welcomed when
    they land on our home page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `In order to` 部分中，我们定义了在这个特性中业务想要实现的目标。在我们的例子中，我们希望当访客到达我们的主页时，能感受到欢迎。
- en: In the `As a/an` section, we define who is performing the action. In our example,
    this is the site visitor who is accessing the home page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `As a/an` 部分中，我们定义了谁在执行动作。在我们的例子中，这是访问主页的网站访客。
- en: And lastly, in the `I need to be able to` section, we define what the actor
    should be able to do or achieve so that the business can achieve its end goal.
    In our example, we just want the actor or visitor to see the Symfony logo and
    the welcome message.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `I need to be able to` 部分中，我们定义了演员应该能够做什么或达到什么目标，以便业务能够实现其最终目标。在我们的例子中，我们只想让演员或访客看到
    Symfony 标志和欢迎信息。
- en: Next, as a part of a feature, we will need to add scenarios using the `Scenario`
    keyword.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为特性的一部分，我们需要使用 `Scenario` 关键字添加场景。
- en: Scenario keyword
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 场景关键字
- en: 'Inside a feature, we can have one or more scenarios. In the `home.feature`
    file we created, you’ll notice that the `Scenario` tag is indented compared to
    the `Feature` tag above it. A scenario is written in plain English; it is just
    a written outline of a sequence of events. In Gherkin, we will divide a scenario
    into three sections as well:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个特性中，我们可以有一个或多个场景。在我们创建的 `home.feature` 文件中，你会注意到 `Scenario` 标签相对于上面的 `Feature`
    标签是缩进的。场景是用纯英文书写的；它只是事件序列的书面概述。在 Gherkin 中，我们将场景分为三个部分：
- en: '`Given`: Used to declare the existing or current state or value of the system'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Given`: 用于声明系统现有的或当前的状态或值'
- en: '`When`: Used to define verbs or actions performed on the system'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`When`: 用于定义在系统上执行的动作或动词'
- en: '`Then`: The expected result after performing the verbs or actions declared
    in the `When` section'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Then`: 在 `When` 部分声明的动词或动作执行后的预期结果'
- en: Now that we have defined both an example feature and scenario, let’s try to
    run Behat and see what we get.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个示例特性和场景，让我们尝试运行 Behat 看看我们会得到什么。
- en: 'Run the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should then see the following result:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Figure 6.3 – Missing snippets](img/Figure_6.03_B18318.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 缺失的片段](img/Figure_6.03_B18318.jpg)'
- en: Figure 6.3 – Missing snippets
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 缺失的片段
- en: You’ll notice that Behat tried to look for some PHP code that represents the
    scenario we declared earlier, but we did not do that. So, that means that we also
    have to write some PHP code for Behat to execute in relation to the actual `Given`,
    `When`, and `Then` definitions we have created.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 Behat 尝试寻找一些代表我们之前声明的场景的 PHP 代码，但我们没有这样做。所以，这意味着我们还需要为 Behat 编写一些 PHP
    代码，以便在执行实际的 `Given`、`When` 和 `Then` 定义时使用。
- en: Next, we’ll write the PHP code needed to support the features and scenarios
    we just created.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写支持我们刚刚创建的特性场景所需的 PHP 代码。
- en: Writing PHP code based on Gherkin
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据 Gherkin 编写 PHP 代码
- en: 'We will need PHP programs to represent the features and scenarios we created
    using Gherkin. The Behat framework will follow the features and scenarios we created
    in the previous section, but it will also look for PHP code that represents each
    feature and scenario. Within this PHP code, we can add any custom logic we want
    to interpret the features and scenarios into programs. Create the following files
    that the Behat framework needs to run our features and scenarios:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 PHP 程序来表示我们使用 Gherkin 创建的功能和场景。Behat 框架将遵循我们在上一节中创建的功能和场景，但它也会寻找表示每个功能和场景的
    PHP 代码。在这段 PHP 代码中，我们可以添加任何自定义逻辑，以将功能和场景解释为程序。创建 Behat 框架运行我们的功能和场景所需的以下文件：
- en: 'First, we need to create a new context class. A context class is what Behat
    uses to represent Gherkin features into PHP programs.Create the following file
    with the content shown:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的上下文类。上下文类是 Behat 用于将 Gherkin 功能表示为 PHP 程序的东西。创建以下文件，并包含所示内容：
- en: codebase/behat/features/bootstrap/HomeContext.php
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/bootstrap/HomeContext.php
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, after creating the `HomeContext.php` class, we also need to tell Behat
    that we have a new context class. We can do this by creating a configuration file.
    Create the following file with the content shown:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在创建 `HomeContext.php` 类之后，我们还需要告诉 Behat 我们有一个新的上下文类。我们可以通过创建一个配置文件来完成此操作。创建以下文件，并包含所示内容：
- en: codebase/behat/behat.yml
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/behat.yml
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can declare more PHP context classes. By default, you can use the `FeatureContext.php`
    file that’s been automatically created earlier in this chapter, but if we keep
    on adding different steps inside the `FeatureContext.php` class, we’ll end up
    with a mess.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以声明更多的 PHP 上下文类。默认情况下，您可以使用本章前面自动创建的 `FeatureContext.php` 文件，但如果我们在 `FeatureContext.php`
    类中继续添加不同的步骤，最终会变得混乱。
- en: 'Now, let’s try running Behat again, but this time, we’ll use the following
    command to automatically generate the missing snippets for our `Given`, `When`,
    and `Then` steps:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试运行 Behat，但这次，我们将使用以下命令来自动生成我们 `Given`、`When` 和 `Then` 步骤缺失的片段：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You’ll then be prompted to enter which specific context class you want to use:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，系统会提示您输入想要使用的特定上下文类：
- en: '![Figure 6.4 – Selecting a context class](img/Figure_6.04_B18318.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 选择上下文类](img/Figure_6.04_B18318.jpg)'
- en: Figure 6.4 – Selecting a context class
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 选择上下文类
- en: 'Enter `2` into the CLI, then press *Enter*. Now, you should get the following
    result:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CLI 中输入 `2`，然后按 *Enter*。现在，您应该得到以下结果：
- en: '![Figure 6.5 – Automatically generated snippets](img/Figure_6.05_B18318.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 自动生成的片段](img/Figure_6.05_B18318.jpg)'
- en: Figure 6.5 – Automatically generated snippets
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 自动生成的片段
- en: Behat has automatically generated the PHP snippets needed to represent the `Given`,
    `When`, and `Then` steps we have defined inside the `home.feature` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Behat 已经自动生成了表示我们在 `home.feature` 文件中定义的 `Given`、`When` 和 `Then` 步骤所需的 PHP 片段。
- en: 'Open the `HomeContext.php` class we created earlier, and there you should see
    the new automatically generated methods:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的 `HomeContext.php` 类，在那里您应该看到新自动生成的函数：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the `iShouldSeeTheSymfonyLogo()` method, replace the `PendingException` class
    with just an `Exception` class.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `iShouldSeeTheSymfonyLogo()` 方法中，将 `PendingException` 类替换为仅有的 `Exception`
    类。
- en: 'Great! Now, let’s run Behat again, and see what we get:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们再次运行 Behat，看看我们会得到什么：
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since the automatically generated snippets return a `PendingException` object,
    we’ll get the following result from Behat:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动生成的片段返回一个 `PendingException` 对象，我们将从 Behat 获得以下结果：
- en: '![Figure 6.6 – Behat with automatically generated PHP snippets](img/Figure_6.06_B18318.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 使用自动生成的 PHP 片段的 Behat](img/Figure_6.06_B18318.jpg)'
- en: Figure 6.6 – Behat with automatically generated PHP snippets
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 使用自动生成的 PHP 片段的 Behat
- en: We should now see the warm and comforting failed test message. So far, we were
    able to use Gherkin to define our feature. Then, we created a separate context
    class to house the methods that Behat will execute in relation to each of the
    `Given`, `When`, and `Then` steps we have defined using Gherkin. Then, we used
    Behat to automatically generate those methods. Now, how do make all these tests
    pass? Well, we can remove the exception we are throwing from the `iShouldSeeTheSymfonyLogo()`
    method! As you can see, this is all happening inside PHP land. But to really pass
    the test, we have to let Behat fire up a browser, visit the home page URL, and
    verify whether it can see the Symfony logo.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能看到温暖而舒适的失败测试消息。到目前为止，我们已经能够使用 Gherkin 定义我们的功能。然后，我们创建了一个单独的上下文类来存放 Behat
    将执行的与每个 `Given`、`When` 和 `Then` 步骤相关的方法。然后，我们使用 Behat 自动生成这些方法。现在，我们如何让所有这些测试通过呢？嗯，我们可以从
    `iShouldSeeTheSymfonyLogo()` 方法中移除我们抛出的异常！如您所见，这一切都在 PHP 领域内发生。但为了真正通过测试，我们必须让
    Behat 启动一个浏览器，访问主页 URL，并验证它是否可以看到 Symfony 标志。
- en: So, how do we do that? Remember when we installed Mink earlier? We will now
    have to use Mink and a browser emulator to do the browser work for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何做呢？记得我们之前安装 Mink 的时候吗？现在，我们将使用 Mink 和浏览器模拟器来为我们完成浏览器的工作。
- en: Browser emulators and Mink
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器模拟器和 Mink
- en: Browser emulators are programs that emulate or mimic the functionalities and
    behaviors of a web browser. These emulators can then be used by another program,
    such as Behat or Codeception, to simulate what a real user would do on a web browser
    while using your application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器模拟器是模拟或模仿网页浏览器功能和行为的程序。这些模拟器可以被其他程序，如 Behat 或 Codeception，用来模拟真实用户在使用您的应用程序时在网页浏览器上的操作。
- en: 'There are two types of browser emulators:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器模拟器有两种类型：
- en: '**Headless**: These types of emulators fire HTTP requests and simply listen
    for the returned DOM or response from the web application. They will be best suited
    for lightweight testing, without the need for complicated checks such as checking
    for an AJAX response after a mouseover event.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无头**：这类模拟器发送 HTTP 请求，并简单地监听来自 web 应用程序的返回 DOM 或响应。它们最适合轻量级测试，不需要进行复杂的检查，例如在鼠标悬停事件后检查
    AJAX 响应。'
- en: '**Controllers**: These types of emulators use real browsers, and they basically
    act like a person who controls a real browser. The good thing about using these
    types of emulators, in my experience, is that we can set the type of browser we
    want to test with. We can also check for the JavaScript and AJAX results on a
    page.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这类模拟器使用真实浏览器，它们基本上就像一个控制真实浏览器的人。根据我的经验，使用这类模拟器的好处是我们可以设置我们想要测试的浏览器类型。我们还可以检查页面上的
    JavaScript 和 AJAX 结果。'
- en: In our example, we will use the headless browser as we won’t need to do any
    JavaScript/AJAX actions. If you need to use a real browser emulator for your project,
    I highly recommend using Selenium2\. You can read more about Selenium from the
    Selenium website at https://www.selenium.dev.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用无头浏览器，因为我们不需要执行任何 JavaScript/AJAX 操作。如果您需要在项目中使用真实的浏览器模拟器，我强烈推荐使用
    Selenium2。您可以在 Selenium 网站上了解更多关于 Selenium 的信息：[https://www.selenium.dev](https://www.selenium.dev)。
- en: 'Next, to let our Behat application start interacting with a browser emulator,
    in place of a real user, create the following program files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了让我们的 Behat 应用程序能够开始与浏览器模拟器交互，而不是真实用户，创建以下程序文件：
- en: 'Open the `HomeContext.php` class we created earlier and replace it with the
    following content:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的 `HomeContext.php` 类，并将其替换为以下内容：
- en: codebase/behat/features/bootstrap/HomeContext.php
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/bootstrap/HomeContext.php
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the constructor, we have instantiated an instance of Mink, which we injected
    with a `Session` object. We have injected a driver object into the session with
    an instance of the Goutte headless emulator. Mink supports different types of
    browser emulators; you can read more about them here: [https://mink.behat.org/en/latest/at-a-glance.html](https://mink.behat.org/en/latest/at-a-glance.html).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们实例化了一个 Mink 对象，并将其注入了一个 `Session` 对象。我们将一个 Goutte 无头模拟器的实例注入到会话中。Mink
    支持不同类型的浏览器模拟器；您可以在[https://mink.behat.org/en/latest/at-a-glance.html](https://mink.behat.org/en/latest/at-a-glance.html)了解更多相关信息。
- en: 'Next, add the following functions inside the same class. These methods represent
    each of the steps you have defined in your scenarios:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在同一个类中添加以下函数。这些方法代表您在场景中定义的每个步骤：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Within the `iVisitTheHomePage()` method, we retrieved the Goutte-injected session
    we just created, and then we let the emulator visit the URL and click on a link.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iVisitTheHomePage()`方法中，我们检索了我们刚刚创建的Goutte注入的会话，然后我们让模拟器访问URL并点击一个链接。
- en: 'Now, let’s run the test and see whether it works! Run the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行测试看看它是否工作！运行以下命令：
- en: '[PRE43]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should then see the following result:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该看到以下结果：
- en: '![Figure 6.7 – Failed headless browser assertion](img/Figure_6.07_B18318.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 失败的无头浏览器断言](img/Figure_6.07_B18318.jpg)'
- en: Figure 6.7 – Failed headless browser assertion
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 失败的无头浏览器断言
- en: 'We failed the test again, but why is that? Notice that inside the `iVisitTheHomePage()`
    method, we have this line:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次失败了测试，但为什么是那样呢？注意在`iVisitTheHomePage()`方法内部，我们有这样一行：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This line tells the emulator to click on the **Tutorials** option on the home
    page, which uses the **Create your first page** anchor text:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉模拟器点击主页上的**教程**选项，它使用的是**创建你的第一个页面**锚文本：
- en: '![Figure 6.8 – Create your first page link ](img/Figure_6.08_B18318.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 创建你的第一个页面链接](img/Figure_6.08_B18318.jpg)'
- en: Figure 6.8 – Create your first page link
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 创建你的第一个页面链接
- en: What happened was the emulator successfully loaded the Symfony home page, and
    then clicked on the tutorial link, and therefore the browser was redirected to
    a different page! That’s why we failed the test. So, if we update the `iVisitTheHomePage()`
    method and remove the offending line, we should now be able to pass the test!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是模拟器成功加载了Symfony主页，然后点击了教程链接，因此浏览器被重定向到了另一个页面！这就是我们测试失败的原因。所以，如果我们更新`iVisitTheHomePage()`方法并删除有问题的行，我们现在应该能够通过测试！
- en: 'Run the test again by running the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试，运行以下命令：
- en: '[PRE45]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We should then see the following result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下结果：
- en: '![Figure 6.9 – The first Behat test passed](img/Figure_6.09_B18318.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 第一次Behat测试通过](img/Figure_6.09_B18318.jpg)'
- en: Figure 6.9 – The first Behat test passed
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 第一次Behat测试通过
- en: Great! We finally passed our first Behat test! In the `iShouldSeeTheSymfonyLogo()`
    method, you’ll notice that we have two assertions. In the first assertion, we
    wanted to check whether an element exists in the returned DOM, which is the *logo*
    element. We then added another assertion to check for the **Welcome to Symfony
    6** text.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们终于通过了第一次Behat测试！在`iShouldSeeTheSymfonyLogo()`方法中，你会注意到我们有两个断言。在第一个断言中，我们想要检查返回的DOM中是否存在一个元素，即*标志*元素。然后我们添加了另一个断言来检查**欢迎使用Symfony
    6**文本。
- en: 'Open your web browser and visit the following page: `http://127.0.0.1:8081/symfony/public/`.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的网络浏览器并访问以下页面：`http://127.0.0.1:8081/symfony/public/`。
- en: 'Open your element inspector; you should see the logo element. This is what
    we told Mink to look for:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的元素检查器；你应该能看到标志元素。这是我们告诉Mink要查找的内容：
- en: '![Figure 6.10 – Logo element](img/Figure_6.10_B18318.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 标志元素](img/Figure_6.10_B18318.jpg)'
- en: Figure 6.10 – Logo element
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 标志元素
- en: Since both the *logo* element and **Welcome to Symfony 6** text exists when
    the browser emulator visited the home page, it finally passed the test!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当浏览器模拟器访问主页时，*标志*元素和**欢迎使用Symfony 6**文本都存在，它最终通过了测试！
- en: Now, I think you’ll have an idea of how useful and powerful these tools can
    be. This can save you and your team hours of manual testing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想你会有一个想法，这些工具是多么有用和强大。这可以为你和你的团队节省数小时的手动测试时间。
- en: At this stage, you can start writing behaviors represented by features and scenarios
    using the Gherkin language, then use Behat to execute those tests, then develop
    features using PHP to satisfy those tests. If you follow this process, your development
    will be driven by the behaviors that were defined before writing a single line
    of code. Now, your development is behavior driven!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以开始使用Gherkin语言编写由特性表示的行为和场景，然后使用Behat执行这些测试，然后使用PHP开发特性以满足这些测试。如果你遵循这个流程，你的开发将受到在编写任何代码之前定义的行为的驱动。现在，你的开发是行为驱动的！
- en: Why bother with Gherkin, then?
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那为什么还要使用Gherkin呢？
- en: 'The example we used in this chapter is very simple, but you might be tempted
    to think that we can just skip the features written in the Gherkin language. Well,
    I did that too. I thought: it’s not that useful. But when I started working on
    bigger projects, with bigger teams, with different companies working collaboratively
    on the same project and goal, I thought to myself: I wish there were a common
    format that we could share so that we all understand what the business is trying
    to achieve. I was working collaboratively with a third-party company, and I wanted
    to ask them whether I could borrow or get a copy of their test cases, but the
    thing is, they wrote down their test cases directly into their application, which
    is not written in PHP. I then realized how important it is to have some sort of
    a common language that we can use to understand the intended behavior of a system
    that is programming-language agnostic!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用的例子非常简单，但你可能会想，我们完全可以跳过用 Gherkin 语言编写的功能。好吧，我也这么做了。我想：这并不那么有用。但当开始参与更大规模的项目，更大的团队，不同公司合作在同一项目和目标上时，我想：如果有一个我们可以共享的通用格式，那么我们都能够理解企业试图实现的目标，那该多好。我正在与一家第三方公司合作，我想问他们是否可以借用或获取他们的测试用例，但问题是，他们直接将测试用例写入他们的应用程序中，而这个应用程序不是用
    PHP 编写的。然后我意识到，拥有某种通用语言是多么重要，我们可以使用这种语言来理解编程语言无关的系统预期行为！
- en: 'The following diagram represents how useful the Gherkin language is in being
    a platform-agnostic, intermediary language to represent how the intended software
    solution should behave:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Gherkin 语言作为平台无关的中介语言，在表示预期软件解决方案行为方面的有用性：
- en: '![Figure 6.11 – Gherkin features and scenarios](img/Figure_6.11_B18318.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – Gherkin 特性和场景](img/Figure_6.11_B18318.jpg)'
- en: Figure 6.11 – Gherkin features and scenarios
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – Gherkin 特性和场景
- en: By using a common language to define the intended features and scenarios in
    a project, we can easily coordinate with different teams that do not do any software
    programming at all. This is very important for a business. People across different
    teams will be able to collaborate and understand each other easier and quicker,
    and by doing so, the developers can also be more confident and certain that what
    they are building is correct. It might sound ridiculous, but I’ve seen a lot of
    projects go wrong simply because of a breakdown in communication between different
    teams in a business.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一种共同的语言来定义项目中预期功能和场景，我们可以轻松地与完全不进行任何软件编程的不同团队进行协调。这对企业来说非常重要。来自不同团队的人将能够更容易、更快地协作和理解彼此，通过这样做，开发者也可以更有信心和确定性，他们所构建的是正确的。这听起来可能有些荒谬，但我看到很多项目因为企业不同团队之间沟通的破裂而失败。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we defined and explained what BDD is and why we need it. By
    implementing BDD, we will be able to develop our solutions better to properly
    address the actual business goal. We can start defining these business goals using
    features and scenarios, written in the Gherkin language, which is just plain English.
    By doing so, different people from different teams in the company will be able
    to coordinate and understand each other better in defining the system’s intended
    behavior. This will help bridge the gap and language barrier between different
    teams.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义并解释了 BDD 是什么以及为什么我们需要它。通过实施 BDD，我们将能够更好地开发解决方案，以正确地解决实际业务目标。我们可以开始使用
    Gherkin 语言编写的功能和场景来定义这些业务目标，Gherkin 语言只是简单的英语。通过这样做，公司来自不同团队的不同人员将能够在定义系统的预期行为方面更好地协调和理解彼此。这将有助于弥合不同团队之间的差距和语言障碍。
- en: We created a feature and a scenario, then used Behat, Mink, and Goutte to define
    the intended system behavior, open a headless browser, visit the web application,
    and verify the content of the home page.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个功能和场景，然后使用 Behat、Mink 和 Goutte 定义预期系统行为，打开无头浏览器，访问网络应用程序，并验证主页的内容。
- en: This is just the tip of the BDD iceberg. In the next chapter, we will start
    writing solution code while making sure that our code is maintainable and testable
    by using BDD and TDD together.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 BDD 冰山一角。在下一章中，我们将开始编写解决方案代码，同时确保我们的代码通过使用 BDD 和 TDD 一起，是可维护和可测试的。
