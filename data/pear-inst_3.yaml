- en: Chapter 3. Leveraging Full Application Support with the PEAR Installer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：利用PEAR安装程序的全应用支持
- en: In the last chapter we learned a great deal about the internals of `package.xml`.
    In this chapter, we are stepping up the intensity a notch, and exploring the exciting
    new features that enable us to easily distribute PHP applications and manage their
    installation and post-installation customization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于`package.xml`内部的大量知识。在这一章中，我们将强度提高一个档次，探索使我们能够轻松分发PHP应用程序并管理其安装和安装后定制的令人兴奋的新功能。
- en: If you've ever wanted to make it easy to customize an installation of your PHP
    application across multiple platforms, PHP versions, and user setups, then this
    is the chapter for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经想要使在多个平台、PHP版本和用户设置上定制PHP应用程序变得容易，那么这一章就是为你准备的。
- en: 'package.xml Version 2.0: Your Sexy New Friend'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.xml版本2.0：你的新性感伙伴
- en: The title of this section says it all. `package.xml 2.0` is a major improvement
    over `package.xml 1.0`. The implementations of several important new features
    in the PEAR installer such as custom file roles/tasks, enterprise-level dependencies,
    and channels are reflected by new tags in `package.xml 2.0`. In addition, the
    structure is designed to be easily validated using other tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节标题已经说明了所有内容。`package.xml 2.0`比`package.xml 1.0`有重大改进。在PEAR安装程序中实现的一些重要新功能，如自定义文件角色/任务、企业级依赖关系和通道，在`package.xml
    2.0`中的新标签中得到了反映。此外，结构设计得易于使用其他工具进行验证。
- en: 'PEAR Channels: A Revolution in PHP Installation'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEAR通道：PHP安装的革命
- en: 'The smallest addition to `package.xml 2.0` is the`<channel>` tag. Don''t be
    fooled though, channels are the most significant new feature implemented in the
    PEAR installer. Channels are to PEAR what dependencies are to team development.
    By opening up the ease of the PEAR installer to sites other than [pear.php.net](http://pear.php.net),
    a number of free choices have been made available to PHP users. For the first
    time, it is possible to design an application that depends upon packages from
    `pear.php.net`, `pear.example.com`, and any number of sites, and all of them can
    be automatically downloaded, installed, and easily upgraded on the end-user''s
    computer with a single command. Although [Chapter 5](ch05.html "Chapter 5. Releasing
    to the World: PEAR Channels") discusses the minutiae of channels and the `channel.xml`
    channel definition file, it is good to have a basic understanding of how channels
    work when designing your packages.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 2.0`最小的增加是`<channel>`标签。但不要被骗了，通道是PEAR安装程序中实现的最重要的新功能。通道对于PEAR来说，就像依赖关系对于团队开发一样。通过将PEAR安装程序的便利性扩展到[pear.php.net](http://pear.php.net)以外的网站，为PHP用户提供了许多免费选择。第一次，可以设计一个依赖于`pear.php.net`、`pear.example.com`和任何数量网站的程序，并且所有这些都可以通过单个命令自动下载、安装和轻松升级到最终用户的计算机上。尽管[第5章](ch05.html
    "第5章：向世界发布：PEAR通道")讨论了通道的细节和`channel.xml`通道定义文件，但在设计你的包时，了解通道的工作原理是很好的。'
- en: 'There are two problems that channels effectively solve:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通道有效地解决了两个问题：
- en: Distributing application development across multiple development teams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个开发团队之间分配应用程序开发
- en: Preventing conflicting packages from overwriting each other
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止冲突的包相互覆盖
- en: 'A user''s PEAR installer can have knowledge of a channel, in this example,
    [channelserver.example.com](http://channelserver.example.com) via:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户的PEAR安装程序可以了解一个通道，在这个例子中，通过[channelserver.example.com](http://channelserver.example.com)了解通道：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the user''s PEAR installer has this knowledge, packages from [channelserver.example.com](http://channelserver.example.com),
    like a hypothetical package named [Packagename](http://Packagename) can be simply
    installed with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户的PEAR安装程序有了这方面的知识，就可以简单地安装来自[channelserver.example.com](http://channelserver.example.com)的包，例如一个假设的名为[Packagename](http://Packagename)的包，使用以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Users can also install packages that depend on `channelserver.example.com/Packagename`.
    This was impossible before the advent of PEAR channels.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以安装依赖于`channelserver.example.com/Packagename`的包。在PEAR通道出现之前，这是不可能的。
- en: 'When a user simply types the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户简单地输入以下命令时：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'as they would with PEAR version 1.3.6 and older, the installer uses the `default_channel`
    configuration variable, which is usually `pear.php.net` or `pecl.php.net` (for
    the `pecl` command), and then acts as if the user had instead typed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在PEAR版本1.3.6及更早版本中一样，安装程序使用`default_channel`配置变量，通常为`pear.php.net`或`pecl.php.net`（对于`pecl`命令），然后就像用户输入了以下内容一样操作：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In fact, every existing PEAR package Foo has now become `pear.php.net/Foo`,
    effectively acting as a namespace differentiating it from `channelserver.example.com/Foo`.
    This is the mechanism that channels use to prevent conflicting packages from overwriting
    each other. Since `pear.php.net/Foo` is not the same package as `channelserver.example.com/Foo`,
    it is not possible to *upgrade* from `pear.php.net/Foo` to `channelserver.example.com/Foo`.
    For this reason, it is time for an important concept:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现在每个现有的PEAR包Foo都变成了`pear.php.net/Foo`，实际上充当了一个命名空间，将其与`channelserver.example.com/Foo`区分开来。这是频道用来防止冲突包相互覆盖的机制。由于`pear.php.net/Foo`与`channelserver.example.com/Foo`不是同一个包，因此不可能从`pear.php.net/Foo`升级到`channelserver.example.com/Foo`。因此，现在是时候介绍一个重要的概念了：
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even though *channel names* are *server names*, they also function as a classification
    naming scheme to differentiate packages from different sources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管频道名称是服务器名称，但它们也充当了一个分类命名方案，用于区分来自不同来源的包。
- en: 'To understand this, we need to study some of the history behind channels. In
    the original draft proposal describing channels, the name of a channel (as used
    in both installation and dependencies) and the server used to access the channel
    were different. For instance, the [pear.php.net](http://pear.php.net) channel
    was originally named the PEAR channel, so that users would type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，我们需要研究一些频道背后的历史。在描述频道的原始草案提案中，频道名称（用于安装和依赖项）和用于访问频道的服务器是不同的。例如，[pear.php.net](http://pear.php.net)频道最初被命名为PEAR频道，这样用户就会输入：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After a few development releases of PEAR, it became clear that this was a bad
    idea for several reasons, one of them being the fact that if you didn't know where
    to locate a channel, it simply couldn't be located. So, by the first alpha version
    of PEAR, 1.4.0a1, the name of the channel became the same as the server name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几个PEAR的开发版本发布后，很明显，这有几个原因是不好的，其中一个原因就是如果你不知道频道的位置，它就根本无法找到。因此，在PEAR的第一个alpha版本1.4.0a1中，频道的名称与服务器名称相同。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**So Do We Always Have to Type pear.php.net/Package?**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们是否总是必须输入pear.php.net/Package？**'
- en: No, in fact the innovation that made it reasonable to use the server name as
    a channel's name was the idea of a channel alias. From the command line, we can
    type the following and PEAR would install [pear.php.net/Package](http://pear.php.net/Package).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不，事实上，使使用服务器名称作为频道名称合理化的创新是频道别名的想法。从命令行，我们可以输入以下内容，PEAR就会安装[pear.php.net/Package](http://pear.php.net/Package)。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition, if we wish, we can change this alias to anything we want by using
    the `channel-alias` command as shown:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们愿意，我们可以通过使用`channel-alias`命令将其更改为我们想要的任何名称，如下所示：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, in `package.xml's <channel>` and other tags, the full channel server
    name always must be used, aliases are never allowed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`package.xml`的`<channel>`和其他标签中，必须始终使用完整的频道服务器名称，不允许使用别名。
- en: The switch to using the server name as the channel name has another desirable
    consequence. Originally, it was possible to change the server associated with
    the channel transparently. This is a bad idea on many levels! Firstly, this meant
    that a malicious coder could quite easily override the conflict protections in
    the PEAR channel simply by changing the server that the PEAR channel uses to get
    package information. Secondly, by supplying identically-named packages to the
    ones available at [pear.php.net](http://pear.php.net) with malevolent code hidden
    inside, it would even be possible to fool the user into using malicious code without
    their knowledge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器名称作为频道名称的转换还有一个期望的结果。最初，可以透明地更改与频道关联的服务器。这在很多层面上都是个坏主意！首先，这意味着一个恶意程序员可以通过简单地更改PEAR频道使用的服务器来绕过PEAR频道的冲突保护。其次，通过提供与[pear.php.net](http://pear.php.net)上可用的同名包相同名称的包，并在其中隐藏恶意代码，甚至可能欺骗用户在不了解的情况下使用恶意代码。
- en: By using the server name as the channel name, this is no longer possible without
    an old-fashioned hacking attack against the original channel server, something
    that is bound to be noticed pretty quickly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器名称作为频道名称，这不再可能，除非对原始频道服务器进行老式的黑客攻击，而这种攻击很快就会被发现。
- en: In short, the strength of channels lies not just in their ease of use for the
    end user and flexibility for the developer, but in the extensive security considerations
    that have gone into their design. As evidenced by recent security flaws in major
    PHP packages such as XML_RPC and phpBB, one cannot be too careful. At PEAR, security
    is deadly serious, and the developers have gone to great lengths to ensure that
    PEAR is hack-proof.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通道的强大之处不仅在于其对最终用户的易用性和对开发者的灵活性，还在于其设计中考虑到的广泛安全性。正如最近在主要PHP包（如XML_RPC和phpBB）中出现的安全漏洞所证明的那样，我们不能过于小心。在PEAR中，安全性是至关重要的，开发者们已经竭尽全力确保PEAR无懈可击。
- en: Application Support
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用支持
- en: 'So far, we have learned that the PEAR installer was designed to support libraries
    first, and then application support was added in PEAR version 1.4.0\. Let''s take
    a closer look at what that specifically means by examining four exciting new features:
    custom file roles, custom file tasks, post-installation scripts, and the ability
    to bundle several packages into a single archive.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到PEAR安装程序最初是为了支持库而设计的，然后在PEAR版本1.4.0中添加了应用支持。让我们通过检查四个令人兴奋的新功能来更详细地了解这意味着什么：自定义文件角色、自定义文件任务、安装后脚本以及将多个包捆绑成一个单一存档的能力。
- en: In this section, we will explore the details of these features by creating a
    new custom file role `chiaramdb2schema`, a custom file task `chiara-managedb`,
    a post-install script to populate needed data, and a sample application. We'll
    then distribute the role and task in a single archive.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个新的自定义文件角色`chiaramdb2schema`、一个自定义文件任务`chiara-managedb`、一个用于填充所需数据的安装后脚本和一个示例应用程序来探索这些功能的细节。然后我们将把角色和任务捆绑在一个单一存档中分发。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Before we begin, you need to examine one vital point:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要检查一个重要的点：
- en: What problem are you solving? Should you use a custom file role, custom file
    task, post-install script, or something else?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你在解决什么问题？你应该使用自定义文件角色、自定义文件任务、安装后脚本还是其他什么？
- en: Custom file roles are designed to group related file classes together. If, for
    instance, you wish to install all web-based image files in a different way from
    web-based JavaScript files, custom file roles are the best way to do this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义文件角色旨在将相关的文件类分组在一起。例如，如果你希望以不同于基于Web的JavaScript文件的方式安装所有基于Web的图像文件，自定义文件角色是完成这一点的最佳方式。
- en: Custom file tasks are designed to manipulate the contents of individual files
    prior to installation or prior to packaging. If you need to convert a generic
    template into a machine-specific file (such as a generic database creation SQL
    file into a MySQL-specific or Oracle-specific SQL file), custom tasks are a very
    good choice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义文件任务旨在在安装之前或打包之前操作单个文件的内容。如果你需要将通用模板转换为特定机器的文件（例如，将通用数据库创建SQL文件转换为MySQL特定或Oracle特定SQL文件），自定义任务是很好的选择。
- en: Post-installation scripts are designed to allow any other advanced configuration
    that the user must perform before the package will be ready for use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后脚本旨在允许用户在包准备就绪使用之前执行任何其他高级配置。
- en: Our sample file role and task are designed for a single-user situation. On a
    shared host, this must be done with a post-installation script, and so we will
    provide one to allow systems administrators to maintain multiple database installs
    of a package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例文件角色和任务是为单用户情况设计的。在共享主机上，这必须通过安装后脚本来完成，因此我们将提供一个脚本，以便系统管理员可以维护多个数据库安装的包。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Naming Conventions for Custom File Roles/Tasks**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义文件角色/任务的命名约定**'
- en: It is a very good idea to use a custom prefix for all functionality that extends
    the PEAR Installer. In our examples, if we were to name the role `sql` instead
    of `chiara_sql` and the task `updatedb` instead of `chiara_updatedb`, there is
    a risk of conflicting with an official custom role or task distributed from [pear.php.net](http://pear.php.net).
    In particular, should any role or task be deemed useful enough to be implemented
    as a default part of the PEAR installer, users of your custom role/task would
    be unable to upgrade their PEAR installations unless they uninstalled the role
    and every package that depends on it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有扩展PEAR安装程序的功能，使用自定义前缀是一个非常不错的选择。在我们的示例中，如果我们把角色命名为`sql`而不是`chiara_sql`，任务命名为`updatedb`而不是`chiara_updatedb`，那么存在与官方自定义角色或任务冲突的风险，这些角色或任务是从[pear.php.net](http://pear.php.net)分发的。特别是，如果任何角色或任务被认为足够有用，足以成为PEAR安装程序默认部分，那么使用你自定义角色/任务的用户将无法升级他们的PEAR安装，除非他们卸载该角色及其依赖的所有包。
- en: Introduction to Custom File Roles
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义文件角色的介绍
- en: File roles are used to group related files together to handle installation.
    The standard file roles are `php, data, doc, test, script, src`, and `ext`. Each
    of these roles is handled differently by the installer. A file specified by a
    tag such as this one in a package named `My_Package` will be installed in `My/Package/foo.php`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 文件角色用于将相关文件分组在一起以处理安装。标准文件角色有 `php, data, doc, test, script, src` 和 `ext`。安装程序会以不同的方式处理每个角色。在名为`My_Package`的包中指定此类标签的文件将被安装到`My/Package/foo.php`。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, the same tag with a role of `data` prompts the installer to act very
    differently. Instead of being installed in `My/Package/foo.php`, this file will
    be installed in `My_Package/foo.php`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有`data`角色的相同标签会提示安装程序采取非常不同的行动。这个文件不会安装到`My/Package/foo.php`，而是安装到`My_Package/foo.php`。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `baseinstalldir` attribute is ignored by the `data, doc`, and `test` roles,
    which are instead installed into`<package name>/path/to/file` as defined by the
    relative path in `package.xml`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseinstalldir`属性被`data, doc`和`test`角色忽略，这些角色将根据`package.xml`中定义的相对路径安装到`<package
    name>/path/to/file`。'
- en: 'In addition, each role determines where to install files from a different `config`
    variable. The `role: configuration` variable mapping is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，每个角色都通过不同的`config`变量确定文件安装的位置。`role: configuration`变量映射如下：'
- en: '`php: php_dir`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php: php_dir`'
- en: '`data: data_dir`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data: data_dir`'
- en: '`doc: doc_dir`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc: doc_dir`'
- en: '`test: test_dir`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test: test_dir`'
- en: '`script: bin_dir`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script: bin_dir`'
- en: '`ext: ext_dir`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext: ext_dir`'
- en: '`src: <none>` (not installed)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src: <none>`（不安装）'
- en: 'Generally speaking, configuration variables are the same as the file role with
    `_dir` appended, with the exception of `role="script"`, which is to be appended
    with `bin_dir`. In addition, note that files with `role="src"` are not actually
    installed. Instead, these files are extracted and then compiled to create extension
    binaries, and then discarded. Each of these roles has a set of characteristics
    that differentiate it from other roles:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，配置变量与带有`_dir`后缀的文件角色相同，但`role="script"`除外，它应该附加`bin_dir`。此外，注意带有`role="src"`的文件实际上并没有安装。相反，这些文件会被提取出来，然后编译成扩展二进制文件，之后被丢弃。每个角色都有一组特性，使其与其他角色区分开来：
- en: Some are valid for PHP packages, others for extension packages
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些适用于PHP包，而有些适用于扩展包
- en: Some are installed, others are not
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些被安装，而有些则没有
- en: Installable roles have a configuration variable that determines where they should
    be installed
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可安装的角色有一个配置变量，用于确定它们应该安装的位置
- en: Some honor the `baseinstalldir` attribute, others don't
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些遵守`baseinstalldir`属性，而有些则不遵守
- en: Some install into`<packagename>/path` and others don't
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些角色安装到`<packagename>/path`，而有些则不是
- en: Some represent PHP scripts
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些代表PHP脚本
- en: Some represent executable files (like scripts)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些代表可执行文件（如脚本）
- en: Some represent PHP extension binaries
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些代表PHP扩展二进制文件
- en: 'These characteristics are all that is needed to define customized file roles.
    In fact, the existing file roles are defined using these traits and special objects.
    For instance, the code to define the PHP role is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性就是定义自定义文件角色所需的所有内容。实际上，现有的文件角色就是使用这些特性和特殊对象定义的。例如，定义PHP角色的代码如下：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For most roles, this is the only code that needs to be defined! In addition
    to this PHP code, however, an XML file should be installed that documents the
    properties of a role. The XML file for the PHP role is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数角色来说，这可能是唯一需要定义的代码！然而，除了这段PHP代码之外，还应安装一个XML文件，用于记录角色的属性。PHP角色的XML文件如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The various tags are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 各种标签如下：
- en: '`<releasetypes>:` This tag works like an array, whose contents define which
    release types are allowed to contain this role. The list of possible release types
    is `php, extsrc, extbin`, or `bundle`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<releasetypes>:` 这个标签的作用类似于数组，其内容定义了哪些发布类型可以包含此角色。可能的发布类型列表为 `php, extsrc,
    extbin` 或 `bundle`。'
- en: '`<installable>:` This Boolean value determines whether a role is installed
    to disk or not.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<installable>:` 这个布尔值确定角色是否安装到磁盘上。'
- en: '`<locationconfig>:` For installable roles, this string value determines which
    configuration variable to use for installing the file.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<locationconfig>:` 对于可安装的角色，这个字符串值确定用于安装文件的配置变量。'
- en: '`<honorsbaseinstall>:` This Boolean value (represented as 1 or an empty tag)
    determines whether `baseinstalldir` is used in calculating the final installation
    location.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<honorsbaseinstall>:` 这个布尔值（表示为1或空标签）确定是否在计算最终安装位置时使用`baseinstalldir`。'
- en: '`<unusualbaseinstall>:` This Boolean value (represented as 1 or an empty tag)
    determines whether the package name is prepended to the installation path.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<unusualbaseinstall>:` 这个布尔值（表示为1或一个空标签）决定了包名是否被添加到安装路径之前。'
- en: '`<phpfile>:` This Boolean value (represented as 1 or an empty tag) determines
    whether a file is treated as a PHP file (analyzed at packaging time for valid
    PHP/class names/function names).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<phpfile>:` 这个布尔值（表示为1或一个空标签）决定了文件是否被视为PHP文件（在打包时分析有效的PHP/类名/函数名）。'
- en: '`<executable>:` This Boolean value (represented as 1 or an empty tag) determines
    whether a file is installed with the executable attribute on UNIX-based systems.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<executable>:` 这个布尔值（表示为1或一个空标签）决定了在基于UNIX的系统上是否将文件与可执行属性一起安装。'
- en: '`<phpextension>:` This Boolean value (represented as 1 or an empty tag) determines
    whether the installer will display a helpful error message if overwriting an existing
    extension binary fails due to file locking.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<phpextension>:` 这个布尔值（表示为1或一个空标签）决定了在覆盖现有扩展二进制文件失败（由于文件锁定）时，安装程序是否会显示一个有用的错误消息。'
- en: Creating PEAR_Installer_Role_Chiaramdb2schema Custom Role
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 PEAR_Installer_Role_Chiaramdb2schema 自定义角色
- en: First, it is important to understand how this role is used in `package.xml`.
    In order to implement a custom role, `package.xml` validation should be able to
    tell a user where to download and install it, as dependency validation occurs
    only after the `package.xml` file has been validated from a basic structural standpoint.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要理解这个角色在`package.xml`中的使用方式。为了实现自定义角色，`package.xml`验证应该能够告诉用户在哪里下载和安装它，因为依赖验证仅在`package.xml`文件从基本结构角度验证之后才会发生。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As such, in addition to a package dependency `package.xml` should also contain
    the`<usesrole>` tag describing the name of a custom file role that is used, and
    the remote location of the package containing this role. For our example this
    will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了包依赖`package.xml`外，还应包含`<usesrole>`标签，描述所使用的自定义文件角色名称以及包含此角色的包的远程位置。在我们的例子中，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This tag will prompt the installer to first check if the `pear.chiaraquartet.net/Role_Chiaramdb2schemaql`
    package is installed. If not, the installer will issue a warning:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签将提示安装程序首先检查`pear.chiaraquartet.net/Role_Chiaramdb2schemaql`包是否已安装。如果没有，安装程序将发出警告：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why Use <usesrole>/<usestask> in Addition to a Dependency?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么在依赖关系之外还要使用<usesrole>/<usestask>？**'
- en: The PEAR installer cannot successfully configure roles or tasks once installation
    has begun. They must be installed and configured prior to any attempt to install
    a package that uses them. For this reason, installation of custom roles or tasks
    must be performed in a separate process from the packages that use them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始安装，PEAR安装程序就无法成功配置角色或任务。它们必须在尝试安装使用它们的包之前安装和配置。因此，自定义角色或任务的安装必须在与使用它们的包分开的过程中进行。
- en: To use a custom role inside the`<file>` tag is no different from any regular
    role.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<file>`标签内使用自定义角色与任何常规角色没有区别。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All custom file roles are implemented in a single PHP file that is installed
    into the `PEAR/Installer/Role/` directory. So, for instance, the `data` role is
    located in `PEAR/Installer/Role/Data.php`. Unlike custom tasks, custom file roles
    cannot be in subdirectories, so prefixing should be done without underscores to
    match the PEAR naming conventions. In addition, every custom role must extend
    the `PEAR_Installer_Role_Common` class, which is found in `PEAR/Installer/Role/Common.php`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自定义文件角色都实现在一个PHP文件中，该文件安装到`PEAR/Installer/Role/`目录。例如，`data`角色位于`PEAR/Installer/Role/Data.php`。与自定义任务不同，自定义文件角色不能在子目录中，因此前缀应该不带下划线，以匹配PEAR命名约定。此外，每个自定义角色都必须扩展`PEAR_Installer_Role_Common`类，该类位于`PEAR/Installer/Role/Common.php`。
- en: 'Our custom file role uses the `data_dir` configuration variable to determine
    installation location, and so in terms of installation it acts exactly like the
    `data` role. However, it does a magical thing through this XML in the `Chiaramdb2schema.xml`
    file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制文件角色使用`data_dir`配置变量来确定安装位置，因此在安装方面，它表现得就像`data`角色一样。然而，它通过`Chiaramdb2schema.xml`文件中的此XML执行了神奇的事情：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By defining the`<config_vars>` tag in this way, three entirely new configuration
    variables will be added to the PEAR configuration. They are manipulated in the
    same manner as any other configuration variable, and provide the information that
    will make our `chiaramdb2schema` role something special.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式定义`<config_vars>`标签，将向PEAR配置添加三个全新的配置变量。它们以与其他配置变量相同的方式操作，并提供将使我们的`chiaramdb2schema`角色变得特殊的信息。
- en: 'Our role takes advantage of the fact that MDB2-based schema files are a special
    sub-class of data files by directly extending the `PEAR_Installer_Role_Data` class.
    Here is the complete source code for our example role:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色利用了基于MDB2的架构文件是数据文件的特殊子类这一事实，通过直接扩展`PEAR_Installer_Role_Data`类。以下是我们的示例角色的完整源代码：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And the `Chiaramdb2schema.xml` file that accompanies this role:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随此角色的`Chiaramdb2schema.xml`文件：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's it! Now that we've seen how to implement a simple role, let's examine
    the range of possibility built into the design of custom file roles.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在我们已经看到了如何实现一个简单的角色，让我们来探讨自定义文件角色设计内置的可能性的范围。
- en: Full Range of Possible Custom File Roles
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的自定义文件角色全范围
- en: 'Most custom file roles will only need to specify configuration variables and
    attributes as described in previous sections. However, sometimes this is not enough,
    and some unusual setup is required. The protected `setup()` method of the base
    class `PEAR_Installer_Role_Common` is provided specifically to allow file roles
    to perform any unusual setup functionality needed. The method signature is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数自定义文件角色只需要指定如前几节所述的配置变量和属性。然而，有时这还不够，需要一些不寻常的设置。基类`PEAR_Installer_Role_Common`提供的受保护的`setup()`方法专门用于允许文件角色执行任何所需的不寻常设置功能。方法签名如下：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters are pretty straightforward:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 参数相当直接：
- en: '`PEAR_Installer $installer:` This allows any specialized installation tasks
    to be done through the public API of the `PEAR_Installer` class.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_Installer $installer:` 这允许通过`PEAR_Installer`类的公共API完成任何专门的安装任务。'
- en: '`PEAR_PackageFile_v2 $pkg:` This allows retrieval of any information from the
    `package.xml` that may be useful to the custom role. Note that the `PEAR_PackageFile_v2`
    class''s public API is read-only.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_PackageFile_v2 $pkg:` 这允许从`package.xml`检索对自定义角色可能有用的任何信息。请注意，`PEAR_PackageFile_v2`类的公共API是只读的。'
- en: '`array $atts:` This is the file attribute as parsed from `package.xml`, in
    a format similar to the following:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array $atts:` 这是从`package.xml`解析出的文件属性，格式类似于以下内容：'
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`string $file:` This is the file name.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string $file:` 这是文件名。'
- en: Note that the `setup()` method is called for every role just prior to any installation
    location calculations. In addition, the current `PEAR_Config` configuration object
    is available via the `$this->config` member.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setup()`方法在计算任何安装位置之前为每个角色调用。此外，当前`PEAR_Config`配置对象可通过`$this->config`成员访问。
- en: Also important to explore is the manner in which custom file roles's configuration
    variables are defined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要探索的是自定义文件角色的配置变量定义方式。
- en: 'The`<config_vars>` tag defines configuration variables. Each configuration
    variable is declared using a tag with its name. If you wish to create a simple
    configuration variable named `foo`, you would use this XML:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`<config_vars>`标签定义配置变量。每个配置变量都使用其名称的标签进行声明。如果您想创建一个名为`foo`的简单配置变量，您将使用以下XML：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Legal configuration types are `string, directory, file, set`, and `password`.
    If you wish to limit possible input to specified values, you also need to define
    the set of valid values using the`<valid_set>` tag:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 合法的配置类型是`string, directory, file, set`和`password`。如果您希望将可能的输入限制到指定的值，您还需要使用`<valid_set>`标签定义有效值的集合：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Take a look in the `PEAR/Config.php` file for examples of existing configuration
    variable groups. This variable is for informational purposes, and can be anything
    you wish it to be.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PEAR/Config.php`文件中查看现有配置变量组的示例。此变量仅用于信息目的，可以是您想要的任何内容。
- en: 'The`<default>` tag, on the other hand, has a large range of possibilities.
    There are three kinds of values that can be accessed to set the default value
    of a configuration variable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`<default>`标签有大量的可能性。可以访问三种类型的值来设置配置变量的默认值：
- en: Default values of existing configuration variables
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有配置变量的默认值
- en: PHP constants
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP常量
- en: Any text
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何文本
- en: 'In order to retrieve the default value of the `php_dir` configuration variable,
    you would use this tag:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索`php_dir`配置变量的默认值，您将使用此标签：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Only built-in configuration variables may be accessed for their default values.
    To access a PHP constant like the `PHP_OS` constant, use this tag:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只有内置配置变量可以访问其默认值。要访问像`PHP_OS`这样的 PHP 常量，请使用此标签：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that any constant defined in `PEAR/Common.php` or `PEAR/Config.php` will
    also be available for use as a default value. Finally, straight text may be used
    like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`PEAR/Common.php`或`PEAR/Config.php`中定义的任何常量也将可用作默认值。最后，可以直接使用纯文本，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to combine several of these, simply use them in the desired sequence:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组合这些任务中的几个，只需按所需顺序使用它们即可：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you wish to use multiple constants or multiple texts, append a number to
    the end of the tag name like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用多个常量或多个文本，可以在标签名末尾附加一个数字，如下所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Introduction to Custom File Tasks
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义文件任务简介
- en: 'There are three custom file tasks bundled with PEAR and one script task (post-install
    scripts are discussed in the next section). The tasks are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 随带三个自定义文件任务和一个脚本任务（下一节将讨论安装后脚本）。任务如下：
- en: '`<tasks:replace/>:` Performs a basic `str_replace` on installed or packaged
    files. Possible replacement values are information from `package.xml`, information
    from PEAR''s configuration such as the value of `php_dir`, or PHP constants like
    `PHP_OS`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tasks:replace/>:` 在已安装或打包的文件上执行基本的`str_replace`操作。可能的替换值来自`package.xml`的信息，来自
    PEAR 的配置信息，如`php_dir`的值，或 PHP 常量如`PHP_OS`。'
- en: '`<tasks:windowseol/>:` This converts all line endings to Windows`"\r\n"` line
    endings.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tasks:windowseol/>:` 这将所有行结束转换为 Windows 的`"\r\n"`行结束符。'
- en: '`<tasks:unixeol/>:` This converts all line endings to UNIX`"\n"` line endings'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tasks:unixeol/>:` 这将所有行结束转换为 UNIX 的`"\n"`行结束符。'
- en: In this section, we will examine how these tasks are defined inside the PEAR
    code, and how to create your own custom file tasks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查这些任务如何在 PEAR 代码内部定义，以及如何创建你自己的自定义文件任务。
- en: File tasks are generally used to manipulate the contents of files prior to installation.
    However, this is only limited by your imagination. In our example, we will use
    a task to create and update a database's structure on upgrade using the `chiaramdb2schema`
    file role that we created earlier. This task is a very advanced task, performing
    sophisticated processing, and as such shows the versatility of such a system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 文件任务通常用于在安装前操作文件的內容。然而，这仅受限于你的想象力。在我们的例子中，我们将使用一个任务来创建和更新数据库结构，在升级时使用我们之前创建的`chiaramdb2schema`文件角色。这个任务是一个非常高级的任务，执行复杂的处理，因此展示了这种系统的多功能性。
- en: The only constraint on the XML content of custom tasks is that the task's namespace
    (normally `tasks)` must prefix each tag. Validation is controlled with the PHP
    code for each task. A custom file task must extend `PEAR_Task_Common`, and must
    reside in the `PEAR/Task/` subdirectory of PEAR. Unlike custom file roles, custom
    file tasks can support subdirectories directly by using underscores. In our example
    file task, `chiara-managedb`, the class name is `PEAR_Task_Chiara_Managedb`, and
    this is found in file `PEAR/Task/Chiara/Managedb.php`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务的 XML 内容的唯一约束是任务的命名空间（通常为`tasks`）必须作为每个标签的前缀。验证由每个任务的 PHP 代码控制。自定义文件任务必须扩展`PEAR_Task_Common`，并且必须位于
    PEAR 的`PEAR/Task/`子目录中。与自定义文件角色不同，自定义文件任务可以直接通过使用下划线支持子目录。在我们的示例文件任务`chiara-managedb`中，类名为`PEAR_Task_Chiara_Managedb`，这可以在文件`PEAR/Task/Chiara/Managedb.php`中找到。
- en: 'There are three kinds of custom file tasks: single, **multiple, and script.
    Single tasks** perform their operations on a single file, and are executed just
    prior to installation of the file. Multiple tasks operate on every file containing
    the task, and are executed after installation is completed. Script tasks are executed
    after installation using the `run-scripts` command, and are covered in detail
    in the next section on post-installation scripts. In addition, the order in which
    tasks appear in a file tag is important. The following possible but illogical
    task ordering will result in occurrences of `@blah@` within `foo.php` being replaced
    with the contents of the `data_dir` configuration variable.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种自定义文件任务：单个、**多个和脚本**。单个任务在其操作上对单个文件执行，并在文件安装前执行。多个任务在包含任务的每个文件上操作，并在安装完成后执行。脚本任务在安装后使用`run-scripts`命令执行，将在下一节详细说明安装后脚本。此外，任务在文件标签中出现的顺序也很重要。以下可能的但逻辑上不合理的任务顺序会导致`foo.php`中的`@blah@`出现被替换为`data_dir`配置变量的内容。
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, the opposite ordering will result in occurrences of `@blah@` within
    `foo.php` being replaced with the contents of the`<version>` tag from `package.xml`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相反的顺序会导致`foo.php`中的`@blah@`出现，并用`package.xml`中的`<version>`标签的内容替换。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, single tasks can be executed when packaging. In other words, some
    tasks do not depend on the state of the client machine in order to execute. An
    example is the `replace` task. The `package-info` replacement only depends on
    the contents of the `package.xml` file, which is known at the time of `pear package`.
    The time at which a task is executed is referred to as the install phase of the
    task. Currently recognized install phases are install and package. A custom task
    can control its install phase with the `$phase` property. There are three constants
    defined:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在打包过程中可以执行单个任务。换句话说，有些任务不需要依赖于客户端机器的状态来执行。一个例子是`replace`任务。`package-info`替换仅依赖于`package.xml`文件的内容，该内容在`pear
    package`时已知。任务执行的时间被称为任务的安装阶段。目前识别的安装阶段有安装和打包。自定义任务可以使用`$phase`属性来控制其安装阶段。定义了三个常量：
- en: '`PEAR_TASK_INSTALL:` Installation phase'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_INSTALL:` 安装阶段'
- en: '`PEAR_TASK_PACKAGE:` Packaging phase'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_PACKAGE:` 打包阶段'
- en: '`PEAR_TASK_PACKAGEANDINSTALL:` Both installation and packaging phase'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_PACKAGEANDINSTALL:` 安装和打包阶段'
- en: 'So, for instance, the phase declaration for the `windowseol` task is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，`windowseol`任务的阶段声明如下：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The actual installation phase is set by the constructor of `PEAR_Task_Common`,
    and can be accessed through the `$installphase` property. The only legal values
    are `PEAR_TASK_INSTALL` and `PEAR_TASK_PACKAGE`. This member is used, for instance,
    to determine which replacements should occur. For instance, if `$this->installphase`
    is `PEAR_TASK_PACKAGE`, then `pear-config` and `php-const` replacements are not
    performed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的安装阶段由`PEAR_Task_Common`的构造函数设置，可以通过`$installphase`属性访问。唯一合法的值是`PEAR_TASK_INSTALL`和`PEAR_TASK_PACKAGE`。此成员用于确定哪些替换应该发生。例如，如果`$this->installphase`是`PEAR_TASK_PACKAGE`，则不会执行`pear-config`和`php-const`替换。
- en: 'Perhaps the best introduction to custom file tasks is with some of the simpler
    tasks distributed in the PEAR package itself. The simplest tasks are the`<tasks:windowseol/>`
    and`<tasks:unixeol/>` tasks. These will process the contents of their file and
    convert line endings to Windows format, or to UNIX format. Here is the complete
    source code for the `windowseol` task:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好的自定义文件任务的介绍是使用在PEAR包本身中分发的某些简单任务。最简单的任务是`<tasks:windowseol/>`和`<tasks:unixeol/>`任务。这些将处理其文件的内容并将行结束转换为Windows格式或UNIX格式。以下是`windowseol`任务的完整源代码：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, the primary operation performed is in the `startSession()` method.
    For most tasks, this is sufficient. Next, let's create our own custom file task!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要操作是在`startSession()`方法中执行的。对于大多数任务来说，这已经足够了。接下来，让我们创建我们自己的自定义文件任务！
- en: Creating the PEAR_Task_Chiara_Managedb Custom Task
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建PEAR_Task_Chiara_Managedb自定义任务
- en: The first step in creating our task is to determine the desired purpose of the
    task. In our case, we can sum up the desired purpose with a problem that needs
    to be solved.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的任务的第一步是确定任务期望的目的。在我们的情况下，我们可以用一个需要解决的问题来总结期望的目的。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: THE PROBLEM:Installing and updating a database used by the package is a tedious
    process that should be automated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：安装和更新包使用的数据库是一个繁琐的过程，应该自动化。
- en: 'More specifically, we need a solution that can perform these tasks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们需要一个能够执行以下任务的解决方案：
- en: Create a database from scratch on a fresh installation of the package
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包的新安装上从头创建数据库
- en: Update an existing database structure to reflect any changes in a new version
    of the package upon upgrading the package
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在升级包时更新现有的数据库结构以反映包新版本中的任何更改
- en: Operate with a large variety of databases, and easily manage migration to a
    different database at a future date
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够操作大量不同的数据库，并轻松管理在未来日期迁移到不同的数据库
- en: Operate on different databases for different packages, as controlled by the
    user
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的控制，为不同的包操作不同的数据库
- en: 'In order to satisfy these constraints, we will be taking advantage of the MDB2_Schema
    package, available at [http://pear.php.net/MDB2_Schema](http://pear.php.net/MDB2_Schema).
    This package provides a number of distinct advantages over any custom solution
    we could design from scratch:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些约束，我们将利用可从[http://pear.php.net/MDB2_Schema](http://pear.php.net/MDB2_Schema)获取的MDB2_Schema包。此包提供了一些相对于我们从头开始设计的任何自定义解决方案的独特优势：
- en: MDB2 supports a wide variety of database drivers.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB2支持广泛的数据库驱动程序。
- en: The XML schema format used to describe a database structure is database-independent,
    allowing users of any database MDB2 supports to use a package that uses this task.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于描述数据库结构的XML模式格式是数据库无关的，允许使用MDB2支持的任何数据库的用户使用使用此任务的包。
- en: There is a wide user base and several active maintainers helping to ensure that
    the package performs as advertised.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个广泛的用户基础和几个活跃的维护者，他们帮助确保该包按预期运行。
- en: The `MDB2_Schema::updateDatabase()` method is capable of performing a sophisticated
    update of a database by comparing two schema files.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MDB2_Schema::updateDatabase()`方法能够通过比较两个模式文件来执行数据库的复杂更新。'
- en: 'In addition, we will rely upon a less-than-optimal solution to satisfy the
    need for different databases per package: we will use a required format for the
    configuration variables provided by the `chiaramdb2schema` role.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将依赖于一个不太理想的解决方案来满足每个包需要不同数据库的需求：我们将使用`chiaramdb2schema`角色提供的配置变量的所需格式。
- en: 'In order to determine whether the task needs a unique database for the package,
    we will add an optional attribute named `unique` to the XML. As such, the three
    legal possibilities for our task in `package.xml` will be:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定任务是否需要为包提供一个唯一的数据库，我们将在XML中添加一个名为`unique`的可选属性。因此，在`package.xml`中，我们的任务有三个合法的可能性：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**PEAR 1.5.0a1 or Newer Is Needed to Run this Task**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要1.5.0a1或更高版本的PEAR才能运行此任务**'
- en: Unfortunately, a serious bug in PEAR versions prior to 1.5.0a1 prevents proper
    usage of this task, so if you want to try it, make sure you have the latest version
    of PEAR installed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在1.5.0a1之前的PEAR版本中的一个严重错误阻止了此任务的正确使用，因此如果您想尝试它，请确保您已安装了最新的PEAR版本。
- en: 'In addition, as we require the `chiaramdb2schema` role in order to be sure
    that our configuration variables are installed and ready to use, we will require
    that the task is contained with a file of role `chiaramdb2schema` like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们需要`chiaramdb2schema`角色以确保我们的配置变量已安装并准备好使用，因此我们将要求任务包含一个名为`chiaramdb2schema`的角色的文件，如下所示：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the XML validation method for our task:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的任务的XML验证方法：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When running the task, we will use the value of the `unique` attribute to control
    the database DSN (Data Source Name) used to connect to the database. As such,
    here is our initialization method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任务时，我们将使用`unique`属性的值来控制用于连接数据库的数据库DSN（数据源名称）。因此，以下是我们的初始化方法：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, this is pretty simple, isn't it? The next step is to determine which
    database to use, and how to connect. To do this, we will be using a combination
    of the `chiaramdb2schema_driver` configuration variable, the `chiaramdb2schema_dsn`
    variable, and the `chiara_mdb2schema_password` variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这很简单，不是吗？下一步是确定要使用哪个数据库以及如何连接。为此，我们将结合使用`chiaramdb2schema_driver`配置变量、`chiaramdb2schema_dsn`变量和`chiara_mdb2schema_password`变量。
- en: 'First of all, we will define a method to construct the data source name (DSN)
    from these configuration variables. Before analyzing the source, let''s see it
    in all of its glory:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个方法来从这些配置变量中构建数据源名称（DSN）。在分析源代码之前，让我们看看它的全貌：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First, the configuration variables are retrieved using the `$config` member,
    which is set in the constructor:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用构造函数中设置的`$config`成员检索配置变量：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In order to make things simpler on the user's end, we will also attempt to retrieve
    configuration data for the package's channel, and then default to the [pear.php.net](http://pear.php.net)
    channel configuration.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户端简化事情，我们还将尝试检索包的通道配置数据，然后默认使用[pear.php.net](http://pear.php.net)通道配置。
- en: Next, we will split the `DSN` variable on its separator ";" and the `Passwords`
    variable on its separator ":". By iterating over the `DSN` variable, we can then
    insert the appropriate password for each DSN. For instance, for a DSN "user:pass@localhost/databasename",
    the DSN will be stored as "user@localhost/databasename", so we will need to insert
    ":pass" right before the "@". In addition, the first DSN is the default DSN to
    be used if a non-package-specific DSN is found, so there is a special case for
    this DSN (which is found via `$allDSN[0]`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据其分隔符";"拆分`DSN`变量，并根据其分隔符":"拆分`Passwords`变量。通过遍历`DSN`变量，我们可以为每个DSN插入适当的密码。例如，对于DSN
    "user:pass@localhost/databasename"，DSN将存储为"user@localhost/databasename"，因此我们需要在"@"之前插入":pass"。此外，第一个DSN是默认DSN，如果找到非包特定的DSN，则使用该DSN（通过`$allDSN[0]`找到），所以这是一个特殊情况。
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, we will determine whether the package requires a specific database
    connection string for the package using `$this->_unique`, which as you recall,
    was set in the `init()` method. Package-specific DSNs are prefixed with the package
    name as in "Packagename::user:password@localhost/databasename" or with a specific
    file within a package like "Packagename#file::user:password@localhost/databasename",
    so we will search through the parsed DSNs until we either find one or fail.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将确定包是否需要使用`$this->_unique`指定的特定数据库连接字符串，正如你回忆的那样，这是在`init()`方法中设置的。包特定的DSN以包名称为前缀，例如"Packagename::user:password@localhost/databasename"，或者在一个包内的特定文件中，例如"Packagename#file::user:password@localhost/databasename"，因此我们将搜索解析的DSN，直到找到或失败。
- en: Finally, after determining which DSN to use, we need to prepend the kind of
    database that should be connected to. For instance, this could be MySQL, MySQLi,
    OCI, Firebird, pgSQL, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在确定要使用哪个DSN之后，我们需要在前面加上应该连接到的数据库类型。例如，这可以是MySQL、MySQLi、OCI、Firebird、pgSQL等等。
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you find your eyes glazing over, don't fear. What is important is to realize
    that at the end of the experience, the method will either return a `PEAR_Error`
    with a detailed error message, or a string like **"mysqli://user:pass@localhost/databasename"**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的眼睛开始发花，不要害怕。重要的是要意识到，在体验结束时，该方法将返回一个包含详细错误信息的`PEAR_Error`，或者一个像**"mysqli://user:pass@localhost/databasename"**这样的字符串。
- en: The final portion of our custom task is the `startSession()` method, which actually
    performs the task, as this is a task of type single.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义任务的最后一部分是`startSession()`方法，它实际上执行任务，因为这是一个类型为单的任务。
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`MDB2_Schema::updateDatabase()` requires two schema files in order to upgrade
    a database. While upgrading the database, we will use the final installation destination
    `$dest` to determine whether we are replacing an existing schema file. If so,
    then this is passed to `updateDatabase()`. Otherwise, we will simply call `updateDatabase()`
    to create the new database structure.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`MDB2_Schema::updateDatabase()`需要两个模式文件才能升级数据库。在升级数据库时，我们将使用最终的安装目标`$dest`来确定我们是否正在替换现有的模式文件。如果是这样，则将其传递给`updateDatabase()`。否则，我们只需调用`updateDatabase()`来创建新的数据库结构。'
- en: Note that at this point, the contents of the file have *not* been written to
    disk yet, as the tasks are to operate on a file prior to installation. As such,
    we will write out the schema file to a temporary location created using the `System`
    class, which is bundled with the PEAR package.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在此阶段，文件内容尚未写入磁盘，因为任务是在安装之前对文件进行操作的。因此，我们将使用包含在PEAR包中的`System`类创建的临时位置写入模式文件。
- en: The bulk of the task's work is performed by the `MDB2_Schema` class. After completing
    the task, the user's database is automatically configured on installation and
    upgrade.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的大部分工作由`MDB2_Schema`类执行。在完成任务后，用户的数据库将在安装和升级时自动配置。
- en: The Full Range of Possible Custom File Tasks
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的所有自定义文件任务的全范围
- en: 'The methods that are available to a custom task are:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于自定义任务的方法有：
- en: '`true|array validXml($pkg, $xml, &$config, $fileXml):` Validates task `XML`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true|array validXml($pkg, $xml, &$config, $fileXml):` 验证任务`XML`'
- en: '`void init($xml, $fileAttributes, $lastVersion):` Initializes a task'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void init($xml, $fileAttributes, $lastVersion):` 初始化任务'
- en: '`true|PEAR_Error startSession($pkg, $contents, $dest):` Starts (and generally
    finishes) task handling'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true|PEAR_Error startSession($pkg, $contents, $dest):` 开始（通常完成）任务处理'
- en: '`true|PEAR_Error run($tasks):` For tasks of type "multiple" only, processes
    all tasks and performs the needed actions'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true|PEAR_Error run($tasks):` 仅对类型为"multiple"的任务，处理所有任务并执行所需操作'
- en: validXml($pkg, $xml, &$config, $fileXml)
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`validXml($pkg, $xml, &$config, $fileXml)`'
- en: This method is called for all three types of task during `package.xml` validation
    to validate the XML of a specific task. `$pkg` is a `PEAR_PackageFile_v2` object
    representing the `package.xml` containing the task. This is read-only, and should
    simply be used to retrieve information. `$xml` is the parsed contents of the file
    task, `$config` is a `PEAR_Config` object representing the current configuration,
    and `$fileXml` is the parsed contents of the file tag from `package.xml`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在`package.xml`验证期间用于所有三种类型的任务，以验证特定任务的XML。`$pkg`是一个表示包含任务的`package.xml`的`PEAR_PackageFile_v2`对象。这是只读的，应该仅用于检索信息。`$xml`是文件任务的解析内容，`$config`是一个表示当前配置的`PEAR_Config`对象，而`$fileXml`是`package.xml`文件标签的解析内容。
- en: 'Here is a simple mapping of some sample task XML and the contents of the `$xml`
    variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例任务XML和`$xml`变量内容的简单映射：
- en: '| XML | Parsed Contents |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| XML | 解析内容 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<tasks:something/>` | `''''` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something/>` | `''''` |'
- en: '| `<tasks:something att="blah"/>` | `array(''attribs'' => array(''att'' =>
    ''blah''))` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something att="blah"/>` | `array(''attribs'' => array(''att'' =>
    ''blah''))` |'
- en: '| `<tasks:something>blah</tasks:something>` | `''blah''` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something>blah</tasks:something>` | `''blah''` |'
- en: '| `<tasks:something att="blah">blah2</tasks:something>` | `array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''blah2'')` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something att="blah">blah2</tasks:something>` | `array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''blah2'')` |'
- en: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> </tasks:something>` |
    `array(''tasks:subtag'' => ''hi'')` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> </tasks:something>` |
    `array(''tasks:subtag'' => ''hi'')` |'
- en: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> <tasks:subtag att="blah">again</tasks:subtag>
    </tasks:something>` | `array(''tasks:subtag'' => array(0 => ''hi'', 1 => array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''again''))))` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> <tasks:subtag att="blah">again</tasks:subtag>
    </tasks:something>` | `array(''tasks:subtag'' => array(0 => ''hi'', 1 => array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''again''))))` |'
- en: The `$fileXml` parameter will consist of an array of this format containing
    all of the attributes defined in the`<file>` tag.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`$fileXml` 参数将包含一个此格式的数组，其中包含在 `<file>` 标签中定义的所有属性。'
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Error should be returned as an array. The first index must be one of the following
    error codes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 错误应返回为数组。第一个索引必须是以下错误代码之一：
- en: '`PEAR_TASK_ERROR_NOATTRIBS:` The array should be returned as: `array(PEAR_TASK_ERROR_NOATTRIBS)`;'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_ERROR_NOATTRIBS:` 数组应返回为：`array(PEAR_TASK_ERROR_NOATTRIBS)`;'
- en: '`PEAR_TASK_ERROR_MISSING_ATTRIB:` The array should be returned as: `array(PEAR_TASK_ERROR_MISSING_ATTRIB,
    ''attributename'')`;'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_ERROR_MISSING_ATTRIB:` 数组应返回为：`array(PEAR_TASK_ERROR_MISSING_ATTRIB,
    ''attributename'')`;'
- en: '`PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE:` The array should be returned as: `array(PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE,
    ''attributename'', ''actualvalue'', [''expectedvalue''|array(''expectedvalue1'',
    ''expectedvalue2'',...)])`;'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE:` 数组应返回为：`array(PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE,
    ''attributename'', ''actualvalue'', [''expectedvalue''|array(''expectedvalue1'',
    ''expectedvalue2'',...)])`;'
- en: '`PEAR_TASK_ERROR_INVALID:` The array should be returned as: `array(PEAR_TASK_ERROR_INVALID,
    ''unusual error message'')`;'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_TASK_ERROR_INVALID:` 数组应返回为：`array(PEAR_TASK_ERROR_INVALID, ''unusual
    error message'')`;'
- en: init($xml, $fileAttributes, $lastVersion)
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: init($xml, $fileAttributes, $lastVersion)
- en: 'The `init()` method is called to initialize all non-script tasks, and can be
    used for any purpose. The three parameters are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 方法被调用以初始化所有非脚本任务，并且可用于任何目的。三个参数是：'
- en: '`mixed $xml:` An array representing the task''s XML from `package.xml`. This
    is the same format as the `$xml` parameter passed to `validXml()`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mixed $xml:` 表示 `package.xml` 中任务的 XML 的数组。这与传递给 `validXml()` 的 `$xml` 参数的格式相同。'
- en: '`array $fileAttributes:` An array representing the file attributes. This is
    in the same format as the `$fileXml` parameter to `validXml()`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array $fileAttributes:` 表示文件属性的数组。这与传递给 `validXml()` 的 `$fileXml` 参数的格式相同。'
- en: '`string|NULL $lastVersion:` The last installed version of the package if the
    package is being upgraded, or `NULL` if this package is being installed for the
    first time. This can be used for tasks that rely upon previously installed configuration
    to operate.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string|NULL $lastVersion:` 如果正在升级包，则为包的最后一个安装版本，如果这是第一次安装此包，则为 `NULL`。这可以用于依赖于先前安装配置的任务。'
- en: Any return value from `init()` is discarded.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 的任何返回值都将被丢弃。'
- en: startSession($pkg, $contents, $dest)
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: startSession($pkg, $contents, $dest)
- en: The `startSession()` method is called to execute a task, and is called after
    the `init()` method. It is important to note that this method is expected to return
    the exact contents of the file, as it should be installed to disk. No modification
    of files on disk should be performed. If there is any error running the task,
    a `PEAR_Error` object should be returned with a clear error message describing
    the problem, and containing information on the file that contains the task.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`startSession()` 方法被调用以执行任务，并在 `init()` 方法之后调用。需要注意的是，此方法预期返回文件的精确内容，因为它应该被安装到磁盘上。不应在磁盘上修改文件。如果在运行任务时发生任何错误，应返回一个包含描述问题的清晰错误消息的
    `PEAR_Error` 对象，并包含包含任务的文件信息。'
- en: If the task determines that this file should not be installed, returning `FALSE`
    will prompt the installer to skip installation of this file. Note that only the
    literal `FALSE` will cause skipping of installation; an empty string, the number
    0, and any other literal that can be used as a false condition will not affect
    installation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务确定此文件不应安装，返回 `FALSE` 将提示安装程序跳过此文件的安装。请注意，只有字面量 `FALSE` 会导致跳过安装；空字符串、数字 0
    和任何其他可以用作假条件的字面量都不会影响安装。
- en: After successful performance of a task, the complete file contents *must* be
    returned. The return value is used to write out the file contents to disk. For
    instance, the `windowseol` task returns the value of `$contents` after converting
    all new lines into `\r\n`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务成功执行后，必须返回完整的文件内容。返回值用于将文件内容写入磁盘。例如，`windowseol` 任务在将所有新行转换为 `\r\n` 后返回 `$contents`
    的值。
- en: 'The parameters passed to `startSession()` are:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `startSession()` 的参数是：
- en: '`PEAR_PackageFile_v2 $pkg:` The packagefile object representing the complete
    `package.xml` containing this task.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEAR_PackageFile_v2 $pkg:` 代表包含此任务的完整 `package.xml` 的包文件对象。'
- en: '`string $contents:` The complete contents of the file, which can be operated
    on and must be returned upon successful completion of the task.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string $contents:` 文件的完整内容，可以在任务成功完成后对其进行操作并返回。'
- en: '`string $dest:` The full path of the final installation location of the file.
    This is for informational use only.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string $dest:` 文件最终安装位置的完整路径。这仅用于信息用途。'
- en: run($tasks)
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: run($tasks)
- en: This method is only called for tasks of type multiple. The `$tasks` parameter
    is an array of each of the multiple tasks in `package.xml`. For instance, if `package.xml`
    contains tasks of type multiple`<tasks:foo/>` and`<tasks:bar/>`, the `run()` method
    will be called for all `foo` tasks and the `$tasks` parameter will contain an
    array of each `foo` task. Then, the same procedure will be repeated for the `bar`
    tasks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅对类型为多重的任务调用。`$tasks` 参数是 `package.xml` 中每个多重任务的数组。例如，如果 `package.xml` 包含类型为多重的
    `<tasks:foo/>` 和 `<tasks:bar/>` 任务，`run()` 方法将为所有 `foo` 任务调用，并且 `$tasks` 参数将包含每个
    `foo` 任务的数组。然后，相同的程序将重复用于 `bar` 任务。
- en: The `run()` method is called after installation has been successfully completed,
    and as such, can manipulate the installed contents of a package.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法在安装成功完成后被调用，因此可以操作包的已安装内容。'
- en: Upon error, the `run()` method should return a `PEAR_Error` object with an error
    message containing detailed information on the cause of task failure. All other
    return values are ignored.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在出错时，`run()` 方法应返回一个包含有关任务失败原因的详细信息的 `PEAR_Error` 对象。所有其他返回值都被忽略。
- en: Post-Installation Scripts for Ultimate Customization
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于终极定制的安装后脚本
- en: 'The third and final task type is post-installation scripts. These are the most
    powerful and customizable tasks, and can quite literally be used to perform any
    needed customization of an installation. The PEAR installer implements post-installation
    scripts by defining sets of questions to ask the user in the `package.xml` file,
    and by passing the answers a user gives to a special PHP file. Here is a simple
    set of questions and a post-install script to match:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个任务是安装后脚本。这些是最强大和可定制的任务，可以字面意义上用于执行安装所需的任何定制。PEAR 安装程序通过在 `package.xml`
    文件中定义一系列问题来实施安装后脚本，并通过传递用户给出的答案到一个特殊的 PHP 文件中来执行。以下是一组简单的问题和相应的安装后脚本：
- en: First, the XML from `package.xml:`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`package.xml` 中的 XML：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, the post-installation script (contents of `rolesetup.php` ):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装后脚本（`rolesetup.php` 的内容）：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Post-installation scripts interact intimately with the different front ends
    that PEAR provides. There are many possibilities available to a script. In addition
    to using data provided by the user, a post-installation script can interactively
    modify prompts based on the user's previous answers, and can dynamically skip
    entire`<tasks:paramgroup>` sections. These capabilities allow significant customization
    of the actual script.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后脚本与 PEAR 提供的不同前端紧密交互。脚本有许多可用可能性。除了使用用户提供的数据外，安装后脚本可以基于用户的先前答案交互式地修改提示，并且可以动态地跳过整个
    `<tasks:paramgroup>` 部分。这些功能允许对实际脚本的显著定制。
- en: Components of a Post-Install Script
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装后脚本的组成部分
- en: 'Every post-installation script must define two methods, `init()` and `run()`.
    The `init()` method should be defined somewhat like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安装后脚本必须定义两个方法，`init()` 和 `run()`。`init()` 方法应定义得类似于这样：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note the use of `$this->_ui = &PEAR_Frontend::singleton():` This line of code
    opens up a huge array of possibilities. In addition to exposing the entire public
    API available to display text, such as:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`$this->_ui = &PEAR_Frontend::singleton():` 这行代码打开了一个巨大的可能性。除了公开可用的整个公共API以显示文本外，还包括：
- en: '`Void outputData(string $text):` Displays information to the user'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Void outputData(string $text):` 向用户显示信息'
- en: '`string bold(string $text):` Takes the text and returns a bold-face-transformed
    version of that text, which can then be passed to `outputData()`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string bold(string $text):` 接受文本并返回该文本的粗体转换版本，然后可以将其传递给`outputData()`'
- en: this makes available the `skipParamGroup(string $id)` method. The `$id` parameter
    should be the ID of a paramgroup yet to be executed (contents of a`<tasks:id>`
    tag from a`<tasks:paramgroup>`).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`skipParamGroup(string $id)`方法可用。`$id`参数应该是尚未执行的paramgroup的ID（来自`<tasks:paramgroup>`标签的`<tasks:id>`标签的内容）。
- en: 'Modifying the prompt or default value of a parameter is accomplished through
    the creation of a method named `postProcessPrompts()`, like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个名为`postProcessPrompts()`的方法来修改提示或参数的默认值，如下所示：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `$prompts` parameter will be the parsed contents of a`<tasks:paramgroup>`
    tag.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`$prompts`参数将是`<tasks:paramgroup>`标签的解析内容。'
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For this `paramgroup` the `$prompts` variable would be as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个`paramgroup`，`$prompts`变量如下所示：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `postProcessPrompts()` method should return the `$prompts` array with modifications
    only to the prompt and default fields. If anything else is modified, it will cause
    the post-install script to simply fail.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`postProcessPrompts()`方法应该返回经过修改的`$prompts`数组，仅修改提示和默认字段。如果修改了其他内容，将导致安装后脚本直接失败。'
- en: 'For instance, after determining that the user is using the pgSQL driver, the
    return value from `postProcessPrompts()` could be:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在确定用户正在使用pgSQL驱动程序后，`postProcessPrompts()`的返回值可能是：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In addition, the entire prompt can be replaced. This could be a simple way
    to handle internationalization as well. For example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以替换整个提示。这可能是处理国际化的简单方法。例如：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `run()` method should accept two kinds of parameters. In normal operation,
    the first parameter will be an array containing the user''s answers, and the second
    parameter will be the ID of the paramgroup. For this`<tasks:paramgroup>`, sample
    values might be:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法应接受两种类型的参数。在正常操作中，第一个参数将是一个包含用户答案的数组，第二个参数是paramgroup的ID。对于这个`<tasks:paramgroup>`，示例值可能如下：'
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And the ID would be (as you might imagine)`'databaseSetup'`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，ID将是`'databaseSetup'`。
- en: In addition to these features designed for success, sometimes, it is necessary
    to abort a post-installation script on error. In these cases, the `run()` method
    is also called with two parameters, but the second is`'_undoOnError'`, and the
    first is an array of completed paramgroup IDs in reverse order, to facilitate
    iteration for rolling back changes made by the post-install script.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些旨在成功的功能外，有时在出错时需要中止安装后脚本。在这些情况下，`run()`方法也带有两个参数，但第二个是`'_undoOnError'`，第一个是按逆序排列的已完成的paramgroup
    ID数组，以方便迭代回滚安装后脚本所做的更改。
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**_undoOnError is the Error Header and not Another Paramgroup ID?**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**_undoOnError是错误头而不是另一个paramgroup ID吗？**'
- en: A Paramgroup ID cannot begin with an underscore, it may only contain alphanumeric
    characters. Hence, `_undoOnError` is the error header and not another paramgroup
    ID.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Paramgroup ID不能以下划线开头，它只能包含字母数字字符。因此，`_undoOnError`是错误头，而不是另一个paramgroup ID。
- en: Bundling Several Packages into a Single Archive
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个包打包成一个单独的存档
- en: 'Often, it is a desired feature to bundle a package and its dependencies into
    a single installable archive. There are two ways of doing this. The simplest way
    is to use a `package.xml` file similar to this one:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将包及其依赖项打包成一个可安装的存档是一个期望的功能。有两种方法可以实现这一点。最简单的方法是使用一个类似于下面的`package.xml`文件：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This simple `package.xml` can then be packaged into `PEAR_all-1.4.2.tgz`, and
    distributed as a single archive that users can use to upgrade all packages from
    a non-internet location via:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`package.xml`可以打包成`PEAR_all-1.4.2.tgz`，并作为单个存档分发，用户可以使用它从非互联网位置升级所有包：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The other way of distributing dependencies is a clever mixture of the old bundle-all-dependencies
    approach and the PEAR way of distributing dependencies.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 分发依赖项的另一种方法是旧版bundle-all-dependencies方法和PEAR分发依赖项方法的巧妙混合。
- en: 'Backwards Compatibility: Using package.xml 1.0 and 2.0'
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向后兼容性：使用package.xml 1.0和2.0
- en: One of the most important new features of PEAR version 1.4.0 and newer that
    comes with the advent of `package.xml 2.0` is the ability to make a package installable
    by older PEAR versions. The package command, invoked with the following historically
    takes a `package.xml` and spits out a GZIP-compressed tar (`.tgz`) file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 版本 1.4.0 及更高版本最重要的新特性之一是，随着 `package.xml 2.0` 的出现，能够使包适用于较旧的 PEAR 版本。使用以下命令调用的包命令，将
    `package.xml` 作为输入，并输出一个 GZIP 压缩的 tar 文件（`.tgz`）。
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the package name is `Foo`, and the version is `1.0.0`, the `.tgz` file will
    be named `Foo-1.0.0.tgz`. New in version 1.4.0, if there is a second `package.xml`
    named `package2.xml`, the package command will attempt to include it in the archive.
    When PEAR downloads a package for installation, it first looks for a `package2.xml`
    file, which is always in version 2.0 format, and then falls back to `package.xml`.
    In this way, older versions of PEAR are supported, because they always look for
    `package.xml` first.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包名为 `Foo`，版本为 `1.0.0`，`.tgz` 文件将被命名为 `Foo-1.0.0.tgz`。从版本 1.4.0 开始，如果有第二个名为
    `package2.xml` 的 `package.xml`，包命令将尝试将其包含在存档中。当 PEAR 下载包进行安装时，它首先寻找一个 `package2.xml`
    文件，该文件始终以 2.0 格式，然后回退到 `package.xml`。这样，就支持了较旧的 PEAR 版本，因为它们总是首先寻找 `package.xml`。
- en: 'For this to work, PEAR does a very strict comparison of the contents of the
    `package.xml` files. `package.xml` version 1.0 and `package.xml` version 2.0,
    must satisfy the following list of constraints to be considered equivalent, otherwise
    validation will fail:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能正常工作，PEAR 对 `package.xml` 文件的内容进行非常严格的比较。`package.xml` 版本 1.0 和 `package.xml`
    版本 2.0 必须满足以下约束列表才能被认为是等效的，否则验证将失败：
- en: Same package name
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的包名称
- en: Same package summary
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的包摘要
- en: Same package description
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的包描述
- en: Same package version (release version)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的包版本（发布版本）
- en: Same package stability (release stability/state)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的包稳定性（发布稳定性/状态）
- en: Same license
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的许可证
- en: Same release notes
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的发布说明
- en: Same maintainers
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的维护者
- en: All files in `package.xml 1.0` must be present in `package.xml 2.0 <contents>`
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.xml 1.0` 中的所有文件都必须存在于 `package.xml 2.0 <contents>`'
- en: Note that because `package.xml 2.0` allows files to be present but ignored during
    installation using the`<ignore>` tag, `package.xml 2.0` can be used to provide
    an archive that is both PEAR-installable as well as unzip-and-go.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 `package.xml 2.0` 允许使用 `<ignore>` 标签在安装期间忽略文件的存在，因此 `package.xml 2.0`
    可以用来提供既可由 PEAR 安装，又可解压后直接使用的存档。
- en: Why Support Old and Crusty package.xml 1.0?
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么支持过时的 `package.xml` 1.0？
- en: This is a common debate in the PHP world. Why support backwards compatibility?
    These are old, buggy versions of PEAR, right? Yes, they are old and buggy versions
    and anyone using them is asking for trouble, but people may not find a compelling
    reason to upgrade their PEAR installer just so that they can use your package
    because what they have already "works for them". It is (or should be) your goal
    as a package distributor to make the process of upgrading as painless as possible.
    You should only drop `package.xml` version 1.0 support if you are in fact using
    new features of PEAR itself in the PHP code, or your package is a new one without
    an installed userbase.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 PHP 界是一个常见的争议。为什么支持向后兼容性？这些是过时且存在错误的 PEAR 版本，对吧？是的，它们是过时且存在错误的版本，任何使用它们的人都在寻求麻烦，但人们可能找不到一个令人信服的理由去升级他们的
    PEAR 安装器，仅仅是为了使用你的包，因为对他们来说“已经足够好”。作为包分发者，你的目标应该是使升级过程尽可能无痛。只有在你实际上在 PHP 代码中使用
    PEAR 的新功能，或者你的包是一个没有安装用户基础的全新包时，你才应该停止支持 `package.xml` 版本 1.0。
- en: PEAR development has progressed at a rapid pace, but the adoption of the new
    installer will not happen overnight. Large software projects like Linux distributions
    need time to evaluate the new features and make sure that everything works properly
    prior to adopting a new version. As PEAR developers, we must honor this need.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 的发展速度非常快，但新安装器的采用不会一夜之间发生。像 Linux 发行版这样的大型软件项目需要时间来评估新功能，并在采用新版本之前确保一切正常工作。作为
    PEAR 开发者，我们必须尊重这一需求。
- en: Once the installed userbase is no longer using the old and buggy versions of
    PEAR, upgrading the installer dependency is an option that should be taken up
    as soon as possible, for the sake of the users themselves. Having said this, PEAR
    users need to upgrade as soon as possible to avoid security holes discovered in
    older versions of the PEAR installer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装的用户不再使用过时且存在错误的 PEAR 版本，升级安装器依赖项应尽快进行，以使用户的利益为重。话虽如此，PEAR 用户应尽快升级以避免在较旧的
    PEAR 安装器版本中发现的安全漏洞。
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Security Issues in PEAR 1.4.3 and Older**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEAR 1.4.3及更早版本的安全问题**'
- en: A few months before writing this chapter, two major security holes were discovered
    in PEAR. Basically, if you're using PEAR 1.4.3 or older, you need to upgrade as
    soon as possible.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章的前几个月，PEAR中发现了两个主要的安全漏洞。基本上，如果你正在使用PEAR 1.4.3或更早版本，你需要尽快升级。
- en: 'Details are available at: [http://pear.php.net/advisory-20051104.txt](http://pear.php.net/advisory-20051104.txt)
    and [http://pear.php.net/advisory-20060108.txt](http://pear.php.net/advisory-20060108.txt).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息可在：[http://pear.php.net/advisory-20051104.txt](http://pear.php.net/advisory-20051104.txt)
    和 [http://pear.php.net/advisory-20060108.txt](http://pear.php.net/advisory-20060108.txt)
    查找。
- en: 'Case Study: The PEAR Package'
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：PEAR包
- en: PEAR is a perfect example of a package that will always need to support `package.xml
    1.0`. We will always have users who are upgrading from an earlier version to the
    latest one and PEAR 1.3.6 and older simply doesn't know anything about `package.xml
    2.0`. If we don't make it possible to upgrade PEAR, there isn't much point in
    making the code available.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR是一个始终需要支持`package.xml 1.0`的包的完美例子。我们总会有一批用户从早期版本升级到最新版本，而PEAR 1.3.6及更早版本根本不了解`package.xml
    2.0`。如果我们不能使PEAR升级成为可能，那么让代码可用就没有太多意义。
- en: However, at the same time, the new dependency features and tasks of `package.xml
    2.0` are very important for the PEAR package, and so both `package.xml 1.0` and
    `package.xml 2.0` are needed. For instance, the `pear` command itself is a shell
    script on UNIX (with UNIX `\n` line endings) and a batch file on Windows (with
    Windows `\r\n` line endings). Before `package.xml 2.0`, it was necessary to add
    these scripts as binary files to CVS, so that the line endings are not replaced
    with the packager's system line endings. Now, through the use of the`<tasks:windowseol/>`
    and`<tasks:unixeol/>` tasks, this is no longer necessary, as the correct line
    endings are set at package time. In addition, because of incompatibilities between
    PEAR 1.4.0 and earlier versions of PEAR_Frontend_Web and the older PEAR_Frontend_Gtk
    (superseded by PEAR_Frontend_Gtk2), it is necessary to check for the presence
    of these versions, and to silently succeed if the versions are OK. `package.xml
    2.0` provides this functionality through the use of the`<conflicts/>` tag in a
    package dependency.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与此同时，新的依赖特性以及`package.xml 2.0`的任务对于PEAR包来说非常重要，因此需要同时使用`package.xml 1.0`和`package.xml
    2.0`。例如，`pear`命令本身在UNIX上是一个shell脚本（带有UNIX `\n` 行结束符），在Windows上是一个批处理文件（带有Windows
    `\r\n` 行结束符）。在`package.xml 2.0`之前，必须将这些脚本作为二进制文件添加到CVS中，以确保行结束符不会被打包者的系统行结束符替换。现在，通过使用`<tasks:windowseol/>`和`<tasks:unixeol/>`任务，这不再是必要的，因为正确的行结束符在打包时已经设置好了。此外，由于PEAR
    1.4.0及更早版本与PEAR_Frontend_Web的早期版本以及较老的PEAR_Frontend_Gtk（已被PEAR_Frontend_Gtk2取代）之间的不兼容性，有必要检查这些版本的存在，如果版本正确，则静默成功。`package.xml
    2.0`通过在包依赖中使用`<conflicts/>`标签提供了这一功能。
- en: PEAR_PackageFileManager
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager
- en: Although the commands `convert` and `pickle` can be used in limited situations
    to manage both a `package.xml` version 1.0 and version 2.0, these commands can
    also be dangerous. A far safer way to maintain two versions of `package.xml` from
    a single location is through the use of the PEAR package PEAR_PackageFileManager.
    This package provides a simple interface from which to import an existing `package.xml`
    file and update with current information, or to create a new `package.xml` file
    from scratch. In addition, it is very simple to take an existing `package.xml
    2.0`, no matter how complicated it is, and easily create an equivalent `package.xml
    1.0` with absolute control over the contents of each `package.xml`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在有限的情况下可以使用`convert`和`pickle`命令来管理`package.xml`的1.0和2.0版本，但这些命令也可能很危险。通过使用PEAR包PEAR_PackageFileManager，从单一位置维护两个版本的`package.xml`是一个更安全的方法。这个包提供了一个简单的接口，可以从中导入现有的`package.xml`文件并更新为当前信息，或者从头开始创建一个新的`package.xml`文件。此外，它非常简单地将现有的`package.xml
    2.0`（无论其多么复杂）转换为等效的`package.xml 1.0`，并绝对控制每个`package.xml`的内容。
- en: Obtaining PEAR_PackageFileManager
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取PEAR_PackageFileManager
- en: 'PEAR_PackageFileManager can be easily obtained by using the PEAR installer.
    As of the writing of this book, version 1.6.0b1 is available. To install it, you
    must set the `preferred_state` configuration variable to `beta` via:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用PEAR安装程序轻松获取PEAR_PackageFileManager。在撰写本书时，版本1.6.0b1可用。要安装它，您必须通过以下方式设置`preferred_state`配置变量为`beta`：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Or you can run:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以运行：
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Of course, it is always good practice to determine the latest version at [http://pear.php.net/package/PEAR_PackageFileManager](http://pear.php.net/package/PEAR_PackageFileManager)
    and to install that version.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，始终确定最新版本在 [http://pear.php.net/package/PEAR_PackageFileManager](http://pear.php.net/package/PEAR_PackageFileManager)
    并安装该版本是一个好习惯。
- en: PEAR_PackageFileManager Script and the package.xml Files it Generates
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager 脚本及其生成的 package.xml 文件
- en: For our sample `PEAR_PackageFileManager` script, we will be generating a `package.xml`
    for the `Chiara_Managedb` task. Before writing the `package.xml` script, let's
    make sure we understand the components we wish to have for our `package.xml`.
    In our case, we will have three files to package up, the `Managedb.php` file containing
    the actual code for the task, the `rw.php` file containing the read/writable `PEAR_Task_Chiara_Managedb_rw`
    class for adding the task to `package.xml` through the `PEAR_PackageFile_v2_rw`
    API, and `rolesetup.php`, the post-installation script for initializing the `chiaramdb2schema`
    configuration variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例 `PEAR_PackageFileManager` 脚本，我们将为 `Chiara_Managedb` 任务生成一个 `package.xml`
    文件。在编写 `package.xml` 脚本之前，让我们确保我们理解了我们希望 `package.xml` 包含的组件。在我们的例子中，我们将有三个文件需要打包，包含任务实际代码的
    `Managedb.php` 文件，包含可读/可写 `PEAR_Task_Chiara_Managedb_rw` 类的 `rw.php` 文件，用于通过 `PEAR_PackageFile_v2_rw`
    API 将任务添加到 `package.xml`，以及 `rolesetup.php`，它是初始化 `chiaramdb2schema` 配置变量的安装后脚本。
- en: There are several important details to note before diving into the source. First
    of all, this script generates a `package.xml` file from scratch. Most scripts
    will not need this kind of detail when using the `importOptions()` method. In
    addition, it is important to note that the `PEAR_PackageFileManager2` class extends
    the `PEAR_PackageFile_v2_rw` class provided with PEAR itself. This allows use
    of utility methods such as
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究源代码之前，有几个重要的细节需要注意。首先，这个脚本是从头开始生成 `package.xml` 文件的。当使用 `importOptions()`
    方法时，大多数脚本不需要这种详细程度。此外，需要注意的是，`PEAR_PackageFileManager2` 类扩展了 PEAR 自身提供的 `PEAR_PackageFile_v2_rw`
    类。这允许使用如
- en: '`setPackage()` and others to tweak the contents of the `package.xml`. Let''s
    take a look at how to generate a somewhat complicated `package.xml 2.0` with a
    post-installation script.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setPackage()` 等方法来调整 `package.xml` 的内容。让我们看看如何生成一个包含安装后脚本的复杂 `package.xml
    2.0`。
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And the `package.xml` it generates:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成的 `package.xml` 如下：
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How PEAR_PackageFileManager Makes a Hard Life Easy
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager 如何让艰难的生活变得容易
- en: Astute readers may have noticed that the `package.xml` generation script is
    quite extensive and long. The good news is that in many cases, this will be unnecessary.
    In fact, the initial generation of `package.xml` is generally not the most important
    feat accomplished by PEAR_PackageFileManager. Far more significant is the management
    of release data. Maintaining a `package.xml` file, and in many instances `package.xml`
    and `package2.xml` is a serious problem. Although the PEAR installer makes it
    a bit easier by doing a careful equivalency comparison between package files,
    this process is not perfect.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能已经注意到，`package.xml` 生成脚本相当广泛且长。好消息是，在许多情况下，这将是多余的。事实上，`package.xml` 的初始生成通常不是
    PEAR_PackageFileManager 完成的最重要的功能。更重要的要数是发布数据的维护。维护 `package.xml` 文件，在许多情况下 `package.xml`
    和 `package2.xml` 是一个严重的问题。尽管 PEAR 安装程序通过在包文件之间进行仔细的等价性比较来使其变得容易一些，但这个过程并不完美。
- en: PEAR_PackageFileManager takes the same data and uses explicit logic to generate
    the metadata that is `package.xml` guaranteeing that equivalent `package.xml`
    files will be created. In addition, the centralization of data means that you
    need to modify only the script when updating release notes. In addition, it is
    impossible to generate an invalid `package.xml`, as PEAR's built-in `package.xml`
    validation is used to validate generated `package.xml` files — the same validation
    used on packaging and on installation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager 使用相同的数据，并使用显式逻辑来生成 `package.xml` 的元数据，从而保证创建的 `package.xml`
    文件是等效的。此外，数据的集中化意味着您只需在更新发布说明时修改脚本。此外，由于 PEAR 内置的 `package.xml` 验证用于验证生成的 `package.xml`
    文件——与打包和安装时使用的相同验证，因此不可能生成无效的 `package.xml`。
- en: Globbing Files for package.xml
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 package.xml 查找文件
- en: The single most important function that PEAR_PackageFileManager performs is
    the creation of the file list. Our simple package only has a few files in it,
    but for large, complex packages like PhpDocumentor ( [http://pear.php.net/PhpDocumentor](http://pear.php.net/PhpDocumentor)),
    it becomes an increasingly difficult task to manage `package.xml`. PhpDocumentor
    not only has several hundred files in it, but they also tend to change dramatically
    from release to release because of the use of Smarty templates.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager 执行的最重要功能之一是创建文件列表。我们的简单包中只有几个文件，但对于像 PhpDocumentor（[http://pear.php.net/PhpDocumentor](http://pear.php.net/PhpDocumentor)）这样的大型、复杂包来说，管理
    `package.xml` 就变成了一项越来越困难的任务。PhpDocumentor 不仅包含了几百个文件，而且由于使用了 Smarty 模板，它们在版本之间也往往会发生巨大的变化。
- en: By turning off the `simpleoutput` option, it is possible to easily detect modified
    files and monitor this from release to release without having to rely upon external
    tools.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭 `simpleoutput` 选项，可以轻松检测到已修改的文件，并从版本到版本进行监控，而无需依赖于外部工具。
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why was PEAR_PackageFileManager Conceived?**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么会出现 PEAR_PackageFileManager？**'
- en: Originally, PEAR_PackageFileManager was a single script for generating PhpDocumentor's
    `package.xml`. Over time, as more requests for the script came in, it improved
    and eventually it became clear that it should be a standalone project.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，PEAR_PackageFileManager 是一个用于生成 PhpDocumentor 的 `package.xml` 的单一脚本。随着时间的推移，随着对该脚本的请求越来越多，它得到了改进，最终变得明确，它应该成为一个独立的项目。
- en: At first, PEAR_PackageFileManager simply globbed all of the files in the current
    file list, using an`'ignore'` option with shell wildcards to exclude files. For
    instance, we can ignore all files containing "test" in their name with this wildcard:`"*test*"`.
    In addition, entire directories and all contents including subdirectories can
    be ignored by appending a "/" to the pattern as in`"CVS/"`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，PEAR_PackageFileManager 简单地使用 shell 通配符的 `'ignore'` 选项来排除文件，遍历当前文件列表中的所有文件。例如，我们可以使用这个通配符
    `"*test*"` 来忽略所有名称中包含 "test" 的文件。此外，通过在模式后附加一个 "/"，可以忽略整个目录及其所有内容，包括子目录，例如 `"CVS/"`。
- en: 'The previous example highlights one of the problems with this approach: In
    a CVS-based package, there may be files that are not part of the project inside
    the package and would not be exported with the `cvs export` command. As such,
    PEAR_PackageFileManager has several file-globbing drivers, or file list generators.
    The choice of which file list generator driver to use is controlled by the`''filelistgenerator''`
    option in the `setOptions()/importOptions()` family of methods. The simplest is
    the `file` generator.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例突出了这种方法的其中一个问题：在一个基于 CVS 的包中，可能存在不属于项目的文件在包内部，并且不会随着 `cvs export` 命令一起导出。因此，PEAR_PackageFileManager
    有几个文件遍历驱动程序，或文件列表生成器。选择使用哪个文件列表生成器驱动程序由 `setOptions()/importOptions()` 方法族中的 `'filelistgenerator'`
    选项控制。最简单的是 `file` 生成器。
- en: Other drivers are`'cvs', 'svn'`, and`'perforce'`. Each of these drivers is identical
    to the`'file'` driver except that instead of simply globbing every file in a directory
    and all subdirectories, it limits the list of files to those in a local checkout
    of a remote revision source control repository. Concurrent Versioning System (CVS),
    Subversion, and Perforce are all revision source control repository systems. If
    you don't know what they are, it would be a good idea to investigate Subversion
    and CVS, as both are free, open-source solutions. Subversion is much more full-featured
    than CVS, and is newer, whereas CVS is a tried-and-true warhorse.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其他驱动程序有 `'cvs'`, `'svn'`, 和 `'perforce'`。这些驱动程序与 `'file'` 驱动程序相同，只是它们不是简单地遍历目录及其所有子目录中的每个文件，而是将文件列表限制为远程版本控制源代码库的本地签出中的文件。并发版本控制系统（CVS）、Subversion
    和 Perforce 都是版本控制源代码库系统。如果你不知道它们是什么，调查 Subversion 和 CVS 会是一个好主意，因为它们都是免费的开源解决方案。Subversion
    比CVS功能更全面，而且更新，而 CVS 是一个经过考验的可靠系统。
- en: Managing Changelog
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理变更日志
- en: PEAR_PackageFileManager automatically generates a changelog for the current
    release, by default from oldest to newest. There are a few options for controlling
    this. First, the`'changelogoldtonew'` option, if set to false, will re-order the
    changelog so that newer entries are closer to the top of the file. In addition,
    if a different set of notes is to be used for the changelog than the release notes,
    use the`'changelognotes'` option to control this.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR_PackageFileManager默认会自动为当前发布版本生成一个变更日志，从旧到新。有一些选项可以控制这一点。首先，如果`'changelogoldtonew'`选项设置为false，将重新排序变更日志，使较新的条目更靠近文件顶部。此外，如果变更日志要使用不同于发布说明的笔记集，请使用`'changelognotes'`选项来控制这一点。
- en: Synchronizing package.xml Version 1.0 and package.xml Version 2.0
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步package.xml版本1.0和package.xml版本2.0
- en: 'In some cases, it might be necessary to generate an equivalent `package.xml`
    version 1.0\. For instance, we may wish to allow PEAR 1.3.x users to gracefully
    fail with a "requires PEAR 1.4.3 or newer" error message. Doing this with PEAR_PackageFileManager
    is a piece of cake. Change the `importOptions` line from:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要生成等效的`package.xml`版本1.0。例如，我们可能希望允许PEAR 1.3.x用户在出现“requires PEAR
    1.4.3 or newer”错误消息时优雅地失败。使用PEAR_PackageFileManager来做这件事非常简单。将`importOptions`行从：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为：
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, change the last few lines of the script to:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将脚本的最后几行更改为：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The script will then output both `package.xml` and `package2.xml`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本将输出`package.xml`和`package2.xml`。
- en: Creating a Package for Installation with the PEAR Installer
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PEAR Installer安装包
- en: 'The final step in the process is creating a package. Once you have a `package.xml`
    file that has been generated, you can use it to create a file containing the contents
    of the package. To do this, you should use the `package` command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过程的最后一步是创建一个包。一旦生成了一个`package.xml`文件，就可以使用它来创建包含包内容的文件。为此，应使用`package`命令：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This command should be executed from the directory containing the `package.xml`
    file. This will create a `.tgz` file like `Package-version.tgz` where `Package`
    is the package name, and `version` is the release version. If your package is
    named `Foo` and is version `1.2.3` the package command will create a file named
    `Foo-1.2.3.tgz`. This file can be installed with:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应在包含`package.xml`文件的目录中执行。这将创建一个`.tgz`文件，例如`Package-version.tgz`，其中`Package`是包名，`version`是发布版本。如果你的包名为`Foo`且版本为`1.2.3`，则包命令将创建一个名为`Foo-1.2.3.tgz`的文件。此文件可以安装为：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Or can also be uploaded to a channel server for public release (discussed in
    [Chapter 5](ch05.html "Chapter 5. Releasing to the World: PEAR Channels")).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也可以上传到频道服务器进行公开发布（见第5章）。
- en: 'The package command can also be used to create an uncompressed `.tar` file
    with the `--uncompress` or `-Z` option:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 包命令还可以使用`--uncompress`或`-Z`选项创建一个未压缩的`.tar`文件：
- en: '[PRE62]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In some cases, you may have renamed a package file. In this case, it is necessary
    to explicitly specify a `package.xml` to be used for packaging as in:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能已经重命名了包文件。在这种情况下，有必要明确指定用于打包的`package.xml`，如下所示：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is the actual command line used to create the PEAR package for release.
    Note that it does not matter which `package.xml` (version 1.0 or version 2.0)
    is passed in, the following command-line sequence is identical.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建用于发布的PEAR包的实际命令行。请注意，传入哪个`package.xml`（版本1.0或版本2.0）无关紧要，以下命令行序列是相同的。
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, if both `package.xml` are the same version, the packaging will fail.
    In addition, there is a strict comparison made between the two `package.xml` files.
    If there is even the slightest difference between the texts of the`<description>`
    tag,`<summary>` tag, or`<notes>` tag, validation will fail. In fact, every file
    within the `package.xml 1.0` must be contained with the `package.xml 2.0`. The
    number of maintainers and their roles must be identical.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果两个`package.xml`版本相同，打包将失败。此外，两个`package.xml`文件之间会进行严格的比较。如果`<description>`标签、`<summary>`标签或`<notes>`标签的文本之间有任何细微的差异，验证将失败。实际上，`package.xml
    1.0`中的每个文件都必须包含在`package.xml 2.0`中。维护者的数量和他们的角色必须完全相同。
- en: However, there are a few differences that are allowed. For instance, the dependencies
    of `package.xml 1.0` need not match those of `package.xml 2.0` whatsoever, due
    to the fact that `package.xml 2.0` simply represents a far greater set of possible
    dependencies than `package.xml 1.0`. In addition, the introduction of the`<ignore>`
    tag in `package.xml 2.0` makes it possible to distribute files that are ignored
    by the PEAR installer. In this way, an application that will run out-of-the-box
    can also be easily installed with PEAR by distributing files needed for the out-of-the-box
    run and asking the PEAR installer to ignore them. These files will not be present
    in the `package.xml 1.0` because PEAR 1.3.x did not have this capability.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许存在一些差异。例如，`package.xml 1.0` 的依赖关系无需与 `package.xml 2.0` 的依赖关系相匹配，这是因为 `package.xml
    2.0` 简单地代表了一个比 `package.xml 1.0` 更广泛的可能依赖集。此外，`package.xml 2.0` 中引入的 `<ignore>`
    标签使得能够分发被 PEAR 安装程序忽略的文件。通过这种方式，一个即插即用的应用程序也可以通过分发用于即插即用运行的文件，并要求 PEAR 安装程序忽略它们，而轻松地使用
    PEAR 进行安装。这些文件将不会出现在 `package.xml 1.0` 中，因为 PEAR 1.3.x 没有这个功能。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this stage, we've explored the inner workings of the PEAR installer and of
    `package.xml` to the highest level — it is safe to say that you are now a `package.xml`
    expert.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经深入探讨了 PEAR 安装程序和 `package.xml` 的内部工作原理——可以肯定地说，你现在已经成为了一个 `package.xml`
    专家。
