- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Organizing PHP Quality Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织 PHP 质量工具
- en: In the last two chapters, you learned a lot about quality metrics and how to
    measure them. There will surely be a couple of tools you would like to use in
    your future work environment, and these tools work best if they are seamlessly
    integrated so that you don’t even have to think about using them anymore.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个章节中，你学到了很多关于质量指标及其测量方法的知识。你肯定会在未来的工作环境中使用一些工具，并且这些工具如果无缝集成，你甚至不需要再考虑使用它们。
- en: 'Therefore, in this chapter, we will show you how you can organize these tools
    in a way that they will be the most productive and helpful in your daily work.
    This includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将向您展示如何以最有效和最有帮助的方式组织这些工具，以便在您的日常工作中使用。这包括以下主题：
- en: Installing code quality tools using **Composer**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Composer** 安装代码质量工具
- en: Installing code quality tools as `phar` files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码质量工具作为 `phar` 文件安装
- en: Managing `phar` files using the **PHAR Installation and Verification Environment**
    (**Phive**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **PHAR 安装和验证环境**（**Phive**）管理 `phar` 文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you followed the examples in the previous two chapters, you do not need to
    install anything else. If not, please go back to those chapters and install all
    the necessary tools first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了前两个章节中的示例，你不需要安装任何其他东西。如果没有，请回到那些章节，首先安装所有必要的工具。
- en: 'All code samples can be found in our GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都可以在我们的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)。
- en: Installing code quality tools using Composer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Composer 安装代码质量工具
- en: Most `require()` or `require_once()`. If there were any conflicts between package
    versions, you had to somehow solve the issues yourself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `require()` 或 `require_once()`。如果包版本之间存在冲突，你必须自己解决这些问题。
- en: Composer greatly simplified these efforts by solving these issues. It introduced
    a central repository called `require()` only to import Composer’s autoloader.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 通过解决这些问题极大地简化了这些工作。它引入了一个名为 `require()` 的中央仓库，仅用于导入 Composer 的自动加载器。
- en: All these features helped PHP compete with other web languages such as Python
    or Ruby, and without it, PHP would probably not be the most widely used language
    on the **World Wide Web** (**WWW**) anymore, as it is today. Therefore, we want
    to give Composer the space in this book that it deserves. In this section, we
    will show you the most used installation method. Additionally, we will also have
    a look at another, lesser-known way of using Composer in your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性帮助 PHP 与其他网络语言（如 Python 或 Ruby）竞争，如果没有它，PHP 可能不再是今天在 **万维网**（**WWW**）上最广泛使用的语言了。因此，我们想在本书中给
    Composer 应得的篇幅。在本节中，我们将向您展示最常用的安装方法。此外，我们还将探讨在项目中使用 Composer 的另一种不太为人所知的方法。
- en: Installing code quality tools using require-dev
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 require-dev 安装代码质量工具
- en: 'Throughout the last chapters, we already used Composer to install tools most
    of the time, so by now, you should already be familiar with the most common use
    case there is: adding dependencies to your project. **Dependencies** are code
    packages written by other developers that can quickly be integrated into your
    project.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的章节中，我们已经多次使用 Composer 安装工具，所以到现在，你应该已经熟悉了最常见的用例：将依赖项添加到你的项目中。**依赖项**是由其他开发者编写的代码包，可以快速集成到你的项目中。
- en: 'To recap, this is done using the `require` keyword and the package name. For
    example, if you want to add PhpMetrics, you can do so by running the following
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，这是通过使用 `require` 关键字和包名称来完成的。例如，如果你想添加 PhpMetrics，你可以通过运行以下命令来实现：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Typically, packages are identified by the name of the developer(s)—the so-called
    *vendor*—and, separated by a slash, the package name. In the preceding example,
    the vendor and the package name are identical, but this is not always the case.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，包通过开发者（所谓的 *vendor*）的名称来识别，并且通过斜杠与包名称分隔。在上面的例子中，供应商和包名称是相同的，但这并不总是如此。
- en: 'Let us look at the `--dev` option in more detail now. When we run the `composer
    require` command with this option, Composer will add the package in another section
    of the `composer.json` file, called `require-dev`. Here, you can see an excerpt
    of a typical `composer.json` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `--dev` 选项。当我们使用 `composer require` 命令并带上这个选项时，Composer 会将包添加到 `composer.json`
    文件的另一个部分，称为 `require-dev`。在这里，你可以看到典型的 `composer.json` 文件的摘录：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The idea behind the `require-dev` section is that all packages within this section
    are not necessary to run the application in production. In the local environment,
    or during the build, you will surely need PHPUnit and all our held-dear code quality
    tools; in production, they are not needed anymore, though.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`require-dev`部分背后的想法是，这个部分中的所有包对于在生产环境中运行应用程序不是必需的。在本地环境或构建过程中，你肯定会需要PHPUnit和所有我们珍视的代码质量工具；在生产环境中，它们不再需要。'
- en: 'In fact, you should strive to have as few packages as possible in production.
    This is mainly for two reasons, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你应该努力在生产环境中使用尽可能少的包。这主要是两个原因，如下所述：
- en: Each package you add will be included in Composer’s autoload mechanism, which
    costs performance on every request. Internally, Composer builds a so-called *classmap*,
    which is a simple array that maps a class name to the respective file location.
    If you are curious about this, check out—for example—the `vendor/composer/autoload_classmap.php`
    file. Depending on the number of packages your project uses, this file can get
    huge, slowing down your application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你添加的每个包都将包含在Composer的自动加载机制中，这会在每个请求上消耗性能。内部，Composer构建了一个所谓的*类映射*，它是一个简单的数组，将类名映射到相应的文件位置。如果你对此感兴趣，可以查看例如`vendor/composer/autoload_classmap.php`文件。根据你的项目使用的包的数量，这个文件可能会变得非常大，从而减慢你的应用程序。
- en: Every additional package can possibly introduce security issues. The less code
    there is, the fewer attack vectors there are.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每增加一个包都可能引入安全问题。代码越少，攻击向量就越少。
- en: By default, Composer will install all dependencies. Thus, be sure to run it
    using the `--no-dev` option for your production builds to exclude the packages
    in `require-dev` from being installed. In your local environment, however, you
    do not need to worry about anything else at this point.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Composer将安装所有依赖项。因此，请确保使用`--no-dev`选项运行它，以排除`require-dev`中的包在生产构建中被安装。然而，在你的本地环境中，你在这个阶段不需要担心其他任何事情。
- en: 'The previously described installation method is the one you will encounter
    the most for good reasons: it does not require any additional tooling and there’s
    just one additional option to be used when installing it on production. This makes
    it a perfect starting point and is often fully sufficient for a small project.
    Another approach worth knowing is the global installation of Composer, which we
    will discuss in the next section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的安装方法是一个很好的起点，也是你遇到最多的方法，原因有很多：它不需要任何额外的工具，并且在生产环境中安装时只有一个额外的选项需要使用。这使得它成为一个完美的起点，对于小型项目来说通常已经足够。另一种值得了解的方法是Composer的全局安装，我们将在下一节中讨论。
- en: Global installation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局安装
- en: If you are working on numerous projects simultaneously on your local system,
    you can choose to install Composer and packages globally, which means that they
    will not be installed in any project `root` folder and will thus not be added
    to any `composer.json` file there. Instead, both Composer and the packages will
    be installed in a single folder, which is usually `~/.composer`. In this folder,
    you will then find another `composer.json` file that keeps track of the globally
    installed packages, as well as another `vendor` folder, where their code is installed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在本地系统上同时处理多个项目，你可以选择全局安装Composer和包，这意味着它们不会安装在任何项目的`root`文件夹中，因此也不会添加到任何`composer.json`文件中。相反，Composer和包都将安装在一个单独的文件夹中，通常是`~/.composer`。在这个文件夹中，你将找到另一个`composer.json`文件，它跟踪全局安装的包，以及另一个`vendor`文件夹，其中安装了它们的代码。
- en: 'Installing packages globally simply requires adding the `global` modifier,
    like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装包只需添加`global`修饰符，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Likewise, updating all global packages is effortless too, as demonstrated here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，更新所有全局包也非常简单，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After global installation, tools such as the **PHP Coding Standards Fixer**
    (**PHP-CS-Fixer**) can simply be executed without having to specify the path,
    like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局安装后，工具如**PHP编码标准修复器**（**PHP-CS-Fixer**）可以简单地执行，无需指定路径，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To make this approach work, however, you will need to add this global folder
    to the execution path. Please see the Composer documentation ([https://getcomposer.org/](https://getcomposer.org/))
    for more details on how to do this for the operating system you use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这种方法生效，你需要将这个全局文件夹添加到执行路径中。请参阅Composer文档（[https://getcomposer.org/](https://getcomposer.org/)），以获取有关如何为使用的操作系统执行此操作的更多详细信息。
- en: Using the global installation feature should only be chosen if you are working
    alone on your projects and do not use any build pipelines. If you are working
    in a team and/or make use of a **continuous integration** (**CI**) pipeline, you
    should install it for every project separately, though.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你单独工作在项目上且不使用任何构建管道的情况下，才应选择使用全局安装功能。如果你在一个团队中工作并且/或者使用 **持续集成**（**CI**）管道，你应该为每个项目单独安装它。
- en: According to common best practices such as the **Twelve-Factor App** principles
    ([https://12factor.net](https://12factor.net)), all dependencies should be explicitly
    declared, and no global dependencies should be relied on since you can never be
    sure which version will be installed. Although code quality tool packages are
    not part of the actual program code, they are still part of the build process.
    Even small differences between the installed versions can lead to unforeseen behavior
    and can generate confusion when errors cannot be reproduced locally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据如 **Twelve-Factor App** 原则（[https://12factor.net](https://12factor.net)）等常见最佳实践，所有依赖项都应明确声明，不应依赖任何全局依赖项，因为你永远无法确定将安装哪个版本。尽管代码质量工具包不是实际程序代码的一部分，但它们仍然是构建过程的一部分。安装版本之间的小差异可能导致不可预见的行为，并且在错误无法在本地重现时会产生混淆。
- en: Furthermore, you want to make the initial installation of a project as easy
    as possible. Having your teammates install all the required tools manually is
    a time-wasting and error-prone process that can lead to frustration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你希望使项目的初始安装尽可能简单。让你的队友手动安装所有必需的工具是一个耗时且容易出错的过程，可能会导致挫败感。
- en: For the aforementioned reasons, we do not encourage using the global installation
    method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，我们不鼓励使用全局安装方法。
- en: Composer scripts
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Composer 脚本
- en: Once you have decided on a possible way to install Composer and have used it
    to download your desired tools, you want to start using them in the most straightforward
    way possible. In [*Chapter 11*](B19050_11.xhtml#_idTextAnchor145), *Continuous
    Integration*, where we will talk about CI, we will also show you how to run these
    tools automatically during the build process. For now, however, we want to show
    you how Composer can assist you in running them manually whenever required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定了一种安装 Composer 的可能方法，并使用它下载了你想要的工具，你希望以最直接的方式开始使用它们。在[*第 11 章*](B19050_11.xhtml#_idTextAnchor145)“持续集成”，我们将讨论
    CI，我们还将向你展示如何在构建过程中自动运行这些工具。然而，现在我们想向你展示 Composer 如何在需要时手动运行它们。
- en: 'Let us consider the following example: as a first step, we would like to run
    PHP-CS-Fixer to automatically fix the code in our `src` folder. Afterward, we
    wish to run PHPStan with level `1` on our code as well. You could surely run both
    steps separately, but we want to add a bit more comfort and execute both tools
    in one go.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：作为第一步，我们希望运行 PHP-CS-Fixer 以自动修复 `src` 文件夹中的代码。之后，我们希望对代码运行 PHPStan，级别为
    `1`。你当然可以单独运行这两个步骤，但我们希望增加一些便利，一次执行这两个工具。
- en: 'To achieve this, we can utilize the `scripts` section of the `composer.json`
    file *in the project root*. There, we have to add the tools we want to execute
    under a concise command name, such as `analyze`. The following example shows what
    this could look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以利用 `composer.json` 文件中的 `scripts` 部分在项目根目录下。在那里，我们必须添加我们想要执行的工具体现在一个简洁的命令名下，例如
    `analyze`。以下示例显示了这可能看起来像什么：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the **JavaScript Object Notation** (**JSON**) array notation here to
    add each command in a separate line, which makes it easier to read and maintain
    than writing everything in one line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了 **JavaScript 对象表示法**（**JSON**）数组表示法，将每个命令单独放在一行中，这使得它比在一行中写完所有内容更容易阅读和维护。
- en: 'If you want to share these Composer commands, you might want to add a short
    description text as well, which is displayed when you execute `composer list`
    to see a list of available commands. To do that, you need to add the `script-descriptions`
    section to your `composer.json` file. For the previously introduced `analyze`
    command, it could look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要分享这些 Composer 命令，你可能还想添加一段简短的描述文本，当你在执行 `composer list` 以查看可用命令时，这段文本会被显示。为此，你需要将
    `script-descriptions` 部分添加到你的 `composer.json` 文件中。对于之前介绍的 `analyze` 命令，它可能看起来像这样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By installing the tools in a subfolder, we found a suitable way to organize
    our code quality tools without letting them interfere with our application dependencies.
    But what if, for whatever reason, you are not using Composer in your project,
    or you dislike the fact of having two `composer.json` files in your repository?
    In the next section, we will introduce an alternative way that does not make use
    of Composer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在子目录中安装工具，我们发现了一种在不干扰我们的应用程序依赖关系的情况下组织我们的代码质量工具的合适方法。但是，如果出于任何原因，您在项目中没有使用Composer，或者您不喜欢在您的存储库中有两个`composer.json`文件的事实？在下一节中，我们将介绍一种不使用Composer的替代方法。
- en: Installing code quality tools as phar files
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码质量工具作为phar文件安装
- en: Composer is not the only possible way to add code quality tools to your project.
    In this section, we will show you to add the tools as `phar` files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Composer并不是添加代码质量工具到您项目的唯一可能方式。在本节中，我们将向您展示如何将工具作为`phar`文件添加。
- en: We already came across `phar` file right away without having to care about Composer
    or dependencies at all. Furthermore, `phar` files are supported by all modern
    PHP versions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无需关心Composer或依赖关系，就能立即遇到`phar`文件。此外，`phar`文件被所有现代PHP版本支持。
- en: This makes the usage of `phar` files quite handy, as you can treat them like
    binaries. Usually, you can download the many PHP tools we introduced to you so
    far as `phar` files directly and place them in whatever directory you want. However,
    there is no unified way these files are provided, so please refer to the official
    documentation of each tool.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使得`phar`文件的使用变得非常方便，您可以像处理二进制文件一样处理它们。通常，您可以直接将我们之前介绍给您的许多PHP工具作为`phar`文件下载，并将它们放置在您想要的任何目录中。然而，这些文件没有统一的提供方式，因此请参考每个工具的官方文档。
- en: 'Let us have a look at how to do that for the `phploc` tool, which we introduced
    in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*,* *Code Quality Tools*. According
    to its GitHub repository, you can simply download it from the *PHPUnit* website,
    as they are both from the same author. The following code snippet shows how you
    can do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为我们在[*第7章*](B19050_07.xhtml#_idTextAnchor084)*，* *代码质量工具*中介绍的`phploc`工具这样做。根据其GitHub仓库，您可以直接从*PHPUnit*网站下载它，因为它们都来自同一作者。以下代码片段显示了您如何这样做：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we install the tool under the name `phploc`, and not `phploc.phar`.
    The `-O` option allows you to specify a different filename than the one you are
    downloading. The `.phar` extension is not necessary to execute the tool, so you
    can save on a bit of typing effort here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们以`phploc`的名称安装工具，而不是`phploc.phar`。`-O`选项允许您指定与下载的文件名不同的文件名。`.phar`扩展名不是执行工具所必需的，因此您可以节省一些输入努力。
- en: Phar and checksums
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Phar和校验和
- en: Downloading and executing files from the internet always includes the risk that
    they can be corrupted and infected with malicious code. That is why the authors
    of the tools often generate checksums (for example, through hash algorithms such
    as **Secure Hash Algorithm 256** (**SHA256**)) of the downloads and publish them
    on their websites so that you can use them to verify the integrity of the download.
    Please check the official websites of the tools you’re considering using to find
    out if they offer checksums, and how to verify them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网下载和执行文件始终存在它们可能被损坏和感染恶意代码的风险。这就是为什么工具的作者通常会生成下载的校验和（例如，通过如**安全哈希算法256**（**SHA256**）之类的哈希算法），并在他们的网站上发布它们，以便您可以使用它们来验证下载的完整性。请检查您打算使用的工具的官方网站，以了解它们是否提供校验和以及如何验证它们。
- en: 'Of course, you can download it using any method you like, be it `curl` or via
    the browser. Once you download it, you can immediately run it using your local
    PHP installation, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用您喜欢的任何方法下载它，无论是使用`curl`还是通过浏览器。一旦下载，您就可以立即使用您本地的PHP安装运行它，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you do not want to type `php` every time, you need to make the `phar` file
    executable, which on Linux—for example—would look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想每次都输入`php`，您需要使`phar`文件可执行，例如在Linux上，它会看起来像这样：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Afterward, you just need to run the following command to execute `phploc`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您只需运行以下命令来执行`phploc`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keeping your phar files organized
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持您的phar文件组织有序
- en: Now, we do not just want to download the `phar` files—we also want to keep them
    organized in our project so that any other developer does not have to do any manual
    work before using them. The most obvious choice is to add these files to your
    repository, and that is precisely what we will look at now. In the following example,
    we will use Git, but this approach would work with any other **version control
    system** (**VCS**).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅想要下载 `phar` 文件，还希望在我们项目中将它们组织起来，这样任何其他开发者在使用它们之前都不需要做任何手动工作。最明显的选择是将这些文件添加到你的仓库中，这正是我们现在要探讨的。在下面的示例中，我们将使用
    Git，但这种方法也可以适用于任何其他 **版本控制系统**（**VCS**）。
- en: It is generally discouraged to store large files in Git because they can affect
    performance negatively. GitHub, for example, blocks files that are greater than
    100 `phar` files we use are usually just a few MB in size, so adding them should
    not have any negative side effects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不建议在 Git 中存储大文件，因为它们可能会对性能产生负面影响。例如，GitHub 会阻止大于 100 个 `phar` 文件，我们使用的 `phar`
    文件通常只有几兆大小，所以添加它们不应该有任何负面影响。
- en: Git Large File Storage (Git LFS)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Git 大文件存储（Git LFS）
- en: If you need to store large files in Git, consider using Git LFS, which was designed
    exactly for this use case. For our needs, though, we do not have to use it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 Git 中存储大文件，请考虑使用 Git LFS，它正是为此类用途而设计的。但就我们的需求而言，我们不必使用它。
- en: You can freely choose where to add `phar` files to your project. A common place
    is the `root` folder; however, since this will get quite crowded over time, we
    recommend using a separate folder to store them. A good place would be the `tools`
    folder again, just like we used it in the previous section. You do not need to
    consider anything else; just add them to the repository like any other file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由选择在哪里添加 `phar` 文件到你的项目中。一个常见的地方是 `root` 文件夹；然而，由于随着时间的推移这会变得相当拥挤，我们建议使用一个单独的文件夹来存储它们。一个不错的选择是再次使用
    `tools` 文件夹，就像我们在上一节中使用的那样。你不需要考虑其他任何事情；只需像添加任何其他文件一样将它们添加到仓库中。
- en: 'Let us assume you copied the `phploc` file into the `tools` folder and made
    it executable as described previously. Then, you would just execute as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已将 `phploc` 文件复制到 `tools` 文件夹，并按照之前描述的方式使其可执行。然后，你只需按照以下方式执行：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using `phar` files is easy and does not interfere with your application dependencies.
    However, they are not perfect: if you want to update them, you need to look up
    the download `phar` file, and validate its checksum manually every time—for each
    tool. In the next section, we will show you how to ease that process by introducing
    another dependency management tool: Phive.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `phar` 文件既简单又不会干扰你的应用程序依赖。然而，它们并不完美：如果你想更新它们，你需要查找下载的 `phar` 文件，并且每次都要手动验证其校验和——针对每个工具。在下一节中，我们将向您展示如何通过引入另一个依赖管理工具：Phive
    来简化这个过程。
- en: Managing phar files using Phive
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Phive 管理phar文件
- en: In the previous section, we learned about using `phar` files instead of using
    Composer to install our code quality tools. This approach works fine, but it does
    require some extra work in case you want to update them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了使用 `phar` 文件而不是使用 Composer 来安装我们的代码质量工具。这种方法很好，但如果你想要更新它们，它确实需要做一些额外的工作。
- en: '**Phive** is a tool that takes over that extra work. Let us install it right
    away.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phive** 是一个可以接管额外工作的工具。让我们立即安装它。'
- en: 'Naturally, Phive itself can be downloaded as `phar`, too. The following commands
    will download it under the name `phive` and make it executable:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，Phive 本身也可以作为 `phar` 下载。以下命令将按 `phive` 的名称下载它并使其可执行：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that this installation method is not very secure. Check the tool’s
    website (https://phar.io) to learn how to install it securely and how to make
    it globally available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种安装方法并不非常安全。请检查工具的网站（https://phar.io）了解如何安全安装以及如何使其全局可用。
- en: 'For demonstration purposes, the simple download works just fine. Once the file
    is downloaded and made executable, you can directly start using Phive to install
    the first tools. Let us use `phploc`, which we introduced in the previous chapter,
    to demonstrate how it works, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，简单的下载就足够了。一旦文件下载并设置为可执行，你就可以直接开始使用 Phive 来安装第一个工具。让我们使用我们在上一章中介绍的 `phploc`
    来演示它是如何工作的，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Download verification
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下载验证
- en: Phive not only takes care of the *installation* but also of the *verification*
    of the downloads. This is done automatically during the installation process.
    However, this requires the vendor to make the checksums available, which is also
    the main reason why not all tools can be managed through Phive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Phive不仅负责下载的*安装*，还负责*验证*。这是在安装过程中自动完成的。然而，这需要供应商提供校验和，这也是为什么不是所有工具都可以通过Phive管理的最主要原因。
- en: 'As you saw previously, installing a tool is done just by using the `install`
    command. The following four things have happened now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，安装一个工具只需使用`install`命令。现在已经发生了以下四个步骤：
- en: Phive downloaded the latest version of `phploc` and verified its checksum.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Phive下载了`phploc`的最新版本并验证了其校验和。
- en: The `phar` file got stored in a shared folder (usually located in your home
    folder under the name `.phive`).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`phar`文件被存储在一个共享文件夹中（通常位于你的家目录下，命名为`.phive`）。'
- en: Phive then created a symbolic link to that shared folder. A symbolic link is
    a reference in the filesystem so that a file or directory can appear in multiple
    directories, although it is stored in just one place. By default, this symbolic
    link is stored in the `tools` folder, which will be generated if it does not exist.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Phive创建了一个指向该共享文件夹的符号链接。符号链接是文件系统中的一个引用，使得一个文件或目录可以出现在多个目录中，尽管它只存储在一个地方。默认情况下，这个符号链接存储在`tools`文件夹中，如果不存在，将会生成。
- en: Another `.phive` folder has been created in your project root folder, which
    is used to store the information about which tools have been downloaded.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建了一个另一个`.phive`文件夹，用于存储有关已下载工具的信息。
- en: Symbolic links appear just as “real” executables in your directory, while the
    original file stays in one single location. If you do not want to use symbolic
    links, you can install a file copy instead by using the `--copy` option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接在你的目录中看起来就像“真实”的可执行文件一样，而原始文件仍然只存储在一个位置。如果你不想使用符号链接，可以使用`--copy`选项安装文件副本。
- en: 'After installation, the execution of `phploc` is simple, as we can see here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，执行`phploc`非常简单，正如我们在这里看到的：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Phive offers more useful commands. Just run the following code without any
    command to get a list of them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Phive提供了更多有用的命令。只需运行以下代码（不输入任何命令）即可获取它们的列表：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we introduce the most important ones:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍最重要的几个：
- en: '`list`—Lists all tools that can be managed through Phive'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`——列出所有可以通过Phive管理的工具'
- en: '`update`—Updates all installed `phar` files, if newer versions are available'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`——如果可用，更新所有已安装的`phar`文件'
- en: '`selfupdate`—Updates the `phive` executable itself'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selfupdate`——更新`phive`可执行文件本身'
- en: '`outdated`—Tells you which `phar` files can be updated'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outdated`——告诉你哪些`phar`文件可以更新'
- en: '`status`—Lists an overview of all installed tools'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`——列出所有已安装工具的概览'
- en: Adding Phive to your project
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Phive添加到你的项目中
- en: 'If you work in a team, you not only want to locally install the `phar` files.
    Phive has got you covered here as well. Two steps are necessary to properly add
    Phive to your project, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个团队中工作，你不仅想要在本地安装`phar`文件。Phive在这里也为你提供了支持。将Phive正确添加到你的项目中需要以下两个步骤：
- en: Add the `.phive` folder in your project root to your repository. The `phars.xml`
    file inside contains all necessary information (such as the `composer.lock` file).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目根目录下的`.phive`文件夹添加到你的仓库中。其中的`phars.xml`文件包含所有必要的信息（例如`composer.lock`文件）。
- en: Make sure the `tools` folder is not under version control (for example, by using
    a `.gitignore` file). You explicitly do not want to add the `phar` files themselves
    to your repository.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保工具文件夹不在版本控制之下（例如，通过使用`.gitignore`文件）。你明确不希望将`phar`文件本身添加到你的仓库中。
- en: 'Once this is done, the next time the project gets checked out from the repository,
    the tools can be installed by executing the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，下次从仓库检出项目时，可以通过执行以下命令来安装工具：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command can be easily integrated into other workflows—for example, as an
    additional `post-install-cmd` script in the `composer.json` file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可以轻松集成到其他工作流程中——例如，作为`composer.json`文件中的附加`post-install-cmd`脚本。
- en: That is already all you need to know about Phive to start using it. As usual,
    we recommend you read the official documentation because we could not cover every
    feature it provides in this book.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解的所有关于Phive的信息，以便开始使用它。像往常一样，我们建议你阅读官方文档，因为我们无法在这本书中涵盖它提供的所有功能。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Composer is an indispensable part of today’s PHP world. The usual approach to
    adding code quality tools to your project is by adding them to the `require-dev`
    section of the dependencies, which works fine in many cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 是当今 PHP 世界中不可或缺的一部分。通常情况下，向你的项目添加代码质量工具的方法是将它们添加到依赖项的 `require-dev`
    部分，这在许多情况下都运行得很好。
- en: 'However, Composer is not the one and only way there is. Therefore, in this
    chapter, we introduced two more options to manage your code quality tools: by
    adding the `phar` files manually to your project, or by utilizing Phive to manage
    the `phar` files.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Composer 并非唯一的途径。因此，在本章中，我们介绍了另外两种管理你的代码质量工具的选项：通过手动将 `phar` 文件添加到你的项目中，或者通过利用
    Phive 来管理 `phar` 文件。
- en: You are probably eager to apply all your gained knowledge to your code now.
    However, relentless refactoring can do more harm than good, and clicking through
    all parts of your application after every change to check if anything broke will
    cost you a lot of time and can be very frustrating. Thus, in the next chapter,
    we will show you how automated testing can help you here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在急于将所学到的所有知识应用到你的代码中。然而，不懈的重构可能会带来更多的伤害而不是好处，而且每次更改后都要点击应用程序的所有部分来检查是否有什么东西坏了，这会花费你很多时间，并且可能会非常令人沮丧。因此，在下一章中，我们将向你展示自动化测试如何在这里帮助你。
