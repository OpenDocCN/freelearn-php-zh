- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Code, Don’t Do Stunts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码，不要玩杂技
- en: The advanced principles of clean code will actually help you to become an easily
    understood developer who is able to code more cleanly. They teach you to be consistent
    in your choices, to think about other developers and your team, and to make communication
    the main tool of our work. Even before the source code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码的高级原则实际上会帮助你成为一个易于理解的开发者，能够编写更干净的代码。它们教你保持选择的一致性，考虑其他开发者和你的团队，并将沟通作为我们工作的主要工具。甚至在源代码之前。
- en: 'It’s a fact: although the source code has a preponderant place in the developer’s
    job, we should not make it our main reason to be. It is a reality: the developer’s
    job is not to write code. It’s about finding a solution to a given problem while
    adapting to constraints that would get in the way. This is the basis of our job
    that we must absolutely keep in mind. And although the principles we have just
    seen in the previous chapter, such as SOLID, seem to be strongly linked to the
    code, we must try to have a more *“meta”* perspective on all this, thinking outside
    the box, and taking a step back. The principles mentioned are, objectively, tools
    that will allow us to solve the problems posed in an efficient and straightforward
    way.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是：虽然源代码在开发者的工作中占据了主导地位，但我们不应将其作为我们存在的首要理由。这是一个现实：开发者的工作不是编写代码。它关于在适应会阻碍我们的限制条件的同时，找到解决给定问题的方法。这是我们工作的基础，我们必须绝对牢记。尽管我们在上一章中看到的原理，如SOLID，似乎与代码紧密相关，但我们必须尝试对所有这些事物有一个更“元”的视角，跳出思维定式，退后一步。这些提到的原理，从客观上来说，是允许我们以高效和直接的方式解决问题的工具。
- en: 'We can then ask ourselves the following questions: What is the real purpose
    of source code? What is its purpose, and can we allow ourselves to do anything
    with the most basic things in the language?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以问自己以下问题：源代码的真正目的是什么？它的目的是什么，我们是否可以允许自己在语言的最基本事物上做任何事情？ '
- en: 'These are the topics we’ll be covering in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码
- en: Be understood, not clever
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被理解，而不是聪明
- en: A note on maintainability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于可维护性的说明
- en: Understanding code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码
- en: Let’s first ask ourselves about the importance of code. What really is its importance
    for us developers in our daily lives? For that, let’s go back in time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先问问自己代码的重要性。对于我们开发者来说，它在我们的日常生活中真正的重要性是什么？为了回答这个问题，让我们回顾一下过去。
- en: A bit of history
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一点历史
- en: 'Computer programming is, in fact, a transistor through which an electric current
    passes or does not pass. So, we end up with a binary system, with a value of `0`
    if the electric current does not pass through the transistor, and `1` if the electric
    current does pass. If you multiply this number of transistors by several billion,
    you end up with today’s processors. It works very well, and our world has been
    governed by this system for decades. However, there is a clear limitation: it
    is not humanly possible to understand and create applications with only 0s and
    1s. So, we had to find a new way of writing these programs so that they became
    humanly possible and manageable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程实际上是一个电流通过或不过的晶体管。因此，我们得到了一个二进制系统，如果电流不通过晶体管，则值为`0`，如果电流通过，则值为`1`。如果你将这个晶体管的数量乘以数十亿，你最终得到今天的处理器。它工作得非常好，我们的世界已经由这个系统统治了几十年。然而，有一个明显的局限性：仅用0和1来理解和创建应用是不可能的。因此，我们必须找到一种新的编写这些程序的方法，使它们变得对人类来说是可能的并且可管理的。
- en: 'We then move to the first human-readable source code: the **assembly** language
    (often abbreviated **ASM**). Popularized at the end of the 1940s, this language
    finally made it possible to read files with a language that is more or less similar
    to our natural language, although assembly is a very low-level language (meaning
    that it is remarkably close to the language of the machine—namely, binary). One
    thing led to another, and higher-level languages appeared—the C language being
    the best known, seeing its first official version in 1972\. The principle is simple:
    to be able to write computer programs with a language that is more and more natural
    for human beings. A tool then automatically translates this higher-level language
    into assembly and binary language that the machine can interpret.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来转向第一个人类可读的源代码：**汇编语言**（通常缩写为**ASM**）。这种语言在20世纪40年代末开始流行，它终于使得人们能够用一种与我们的自然语言或多或少相似的语言来读取文件，尽管汇编语言是一个非常低级的语言（这意味着它与机器语言——即二进制语言——非常接近）。一环扣一环，更高级的语言随之出现——其中C语言最为知名，它在1972年首次发布了官方版本。其原理很简单：能够用越来越自然的人类语言来编写计算机程序。然后，一个工具会自动将这种高级语言翻译成机器可以解释的汇编语言和二进制语言。
- en: The C language is an excellent example of the usefulness and main purpose of
    a programming language. Indeed, this language, created by Dennis Ritchie and Brian
    Kernighan, was originally used to develop the Unix operating system. The point
    is that it was easier to create a programming language such as C to write the
    Unix operating system than to write the operating system with the tools of the
    time—namely, assembler (even if some parts of the Unix operating system are written
    in assembly, the vast majority of the source code is written in the C language).
    We’ll look at the actual purpose of programming languages and code next.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C语言是编程语言的有用性和主要目的的一个绝佳例子。确实，这种由Dennis Ritchie和Brian Kernighan创建的语言最初被用来开发Unix操作系统。关键在于，用C语言编写Unix操作系统比用当时的工具——即汇编器（即使Unix操作系统的某些部分是用汇编语言编写的，但绝大多数源代码是用C语言编写的）编写操作系统要容易得多。接下来，我们将探讨编程语言和代码的实际目的。
- en: The purpose of code
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码的目的
- en: 'And this is where it all makes sense. The programming languages are there to
    help us to transcribe our ideas as easily as possible, and they are interpretable
    by the machine. But programming languages are not limited to transcribing our
    ideas to machines—their goal is also that other people can understand our ideas
    by reading our code, and without needing us. Programming languages are a subtle
    mix of the potential to be understood by a human while giving us the leeway to
    communicate with the machine and the possibilities to exploit its full potential.
    This is what defines the level of a programming language when we talk about high-level
    and low-level languages: the position of the cursor is between “ease of use and
    understanding” and “performance and possibilities offered by the language”. There
    are necessary trade-offs to be made. These are things to have in mind when choosing
    the most appropriate programming language when kicking off a new project. A perfect
    example is all the tools bundled in the **PHP: Hypertext Preprocessor** (**PHP**)
    language to deal with **Hypertext Transfer Protocol** (**HTTP**) requests and
    responses, which makes it an excellent choice to create a web application. Most
    of the things you will need are already present, out of the box, and without the
    need to install anything to deal with the most basic and some pretty advanced
    web application features.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，一切都有了意义。编程语言的存在是为了帮助我们尽可能容易地将我们的想法记录下来，并且它们可以被机器理解。但编程语言不仅仅局限于将我们的想法转录给机器——它们的目的是让其他人通过阅读我们的代码就能理解我们的想法，而无需我们亲自解释。编程语言是一种微妙混合体，它既具有被人类理解的可能性，又给我们提供了与机器通信的自由度，以及利用其全部潜力的可能性。这就是当我们谈论高级语言和低级语言时，定义编程语言水平的原因：光标的位置在“易用性和理解性”与“语言提供的性能和可能性”之间。在启动新项目时选择最合适的编程语言时，需要做出必要的权衡。一个完美的例子是**PHP：Hypertext
    Preprocessor**（**PHP**）语言中捆绑的所有工具，用于处理**Hypertext Transfer Protocol**（**HTTP**）请求和响应，这使得它成为创建网络应用的绝佳选择。大多数你需要的功能都已经内置，无需安装任何东西就可以处理最基本的一些相当高级的网络应用功能。
- en: 'PHP is written in C; it is a higher-level language than the C language. It
    is, therefore, easier to understand and more permissive but offers, in comparison
    to C, less extended performance and fewer possibilities. If you ever need to write
    some assembly code in PHP to communicate with some custom hardware, for instance,
    the statement is simple: you cannot. You will have to write a PHP extension, which
    will be written in the C language (which then allows you to write source code
    parts in the assembly language). This is a super-advanced case, of course, but
    you get the point.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是用C语言编写的；它是一种比C语言更高级的语言。因此，它更容易理解，更宽容，但与C语言相比，它提供的性能扩展更少，可能性也更少。如果你需要在PHP中编写一些汇编代码来与某些定制硬件通信，例如，声明很简单：你不能。你必须编写一个PHP扩展，这个扩展将用C语言编写（这然后允许你在汇编语言中编写源代码部分）。这是一个超级高级的案例，当然，但你的观点已经明确了。
- en: 'Let’s go further by comparing PHP and **Hypertext Markup Language** (**HTML**).
    Although HTML is not a programming language but a description language, it still
    has similarities with PHP: both languages are used to express human ideas that
    can be interpreted by the machine. The point is simple: for someone who doesn’t
    really know technical and programming languages, you will certainly be able to
    explain the content of an HTML file, what it represents, its semantics, and its
    purpose. In PHP, it’s a different matter. Indeed, between file splitting, class
    splitting, **object-oriented programming** (**OOP**), and all these other concepts,
    it will certainly take you much more time to make your non-technical interlocutor
    understand the purpose of all this. However, although HTML does not allow OOP,
    it does not allow conditional branching, writing to a file, managing requests
    sent to the server, and so on. So, we end up with a language that is much more
    understandable to a human being because it is very close to our natural language
    but with much fewer possibilities.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步比较PHP和**超文本标记语言**（**HTML**）。尽管HTML不是一种编程语言而是一种描述性语言，但它与PHP仍有相似之处：这两种语言都用于表达人类思想，这些思想可以被机器解释。关键是简单的：对于一个真正不了解技术和编程语言的人来说，你当然能够解释HTML文件的内容，它代表什么，它的语义以及它的目的。在PHP中，情况就不同了。实际上，在文件分割、类分割、**面向对象编程**（**OOP**）以及所有这些其他概念之间，你肯定需要更多的时间来让你的非技术对话者理解所有这些的目的。然而，尽管HTML不允许OOP，它也不允许条件分支、写入文件、管理发送到服务器的请求等等。因此，我们最终得到一种对人类来说更容易理解的语言，因为它非常接近我们的自然语言，但可能性却少得多。
- en: 'Despite these differences, we must keep in mind the following thing—the languages’
    main objective is exactly the same: to be understood by the greatest number of
    people and by the computer. Writing code means being understandable. It is to
    expose ideas. And just as in everyday life when you expose your ideas, the simpler
    and more straightforward you are, the more people will be able to understand you.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些差异，我们必须记住以下事情——这些语言的主要目标完全相同：被尽可能多的人和计算机理解。编写代码意味着要易于理解。这是要表达思想。就像在日常生活中当你表达你的思想时，你越简单、越直接，就越多人能够理解你。
- en: Be understood, not clever
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被理解，而不是聪明
- en: 'It happens very often that in front of technical challenges and especially
    in source code, we want to do things in a fine, pretty, even “sexy” way, as some
    would say. This is completely normal—since code is a major part of our lives as
    developers, we sometimes want to show the extent of our abilities. Although this
    can be justified at times, it is often an awfully bad idea to want to show the
    complete extent of these talents. Obviously, our ego takes a hit—we must hold
    back sometimes. You just learned new ways of doing things, new ways of coding,
    and new principles of which you are ardently convinced. You have spent a weekend
    learning this new way of organizing your code and your project, you experience
    it as a revelation, and you are sure of it: you must show this new discovery to
    your colleagues and your team; it will revolutionize the project and bring only
    good things. Moreover, you will be given the credit for this new thing, and you
    will be the referent of it. However, this is not the right approach at all.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在面对技术挑战，尤其是在源代码面前，我们常常想要以一种精致、漂亮，甚至“性感”的方式做事，正如有些人所说。这是完全正常的——因为代码是我们作为开发者生活的重要组成部分，我们有时想展示我们能力的极限。虽然有时可以证明这是合理的，但想要完全展示这些才能通常是极其糟糕的想法。显然，我们的自尊心会受到打击——我们有时必须克制自己。你刚刚学习了新的做事方式，新的编码方式，以及你坚信的新原则。你花了一个周末学习这种新的代码和项目组织方式，你把它体验为一种启示，你确信这一点：你必须向你的同事和团队展示这个新发现；它将彻底改变项目，只会带来好事。此外，你将因这个新事物而获得赞誉，你将成为它的标杆。然而，这根本不是正确的做法。
- en: 'Don’t be mistaken. Learning every day, on your own time or not, is an exceptional
    thing. If you have the opportunity to do so, you will come out better. On a side
    note: this isn’t mandatory in any way! Nothing should force yourself to code in
    your spare time. It’s totally OK to keep coding and programming for work.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误解。每天学习，无论是在自己的时间还是不在，都是一件非凡的事情。如果你有机会这样做，你会变得更好。顺便说一句：这绝对不是强制性的！没有任何事情应该强迫你在业余时间编码。继续为工作编码和编程是完全正常的。
- en: 'The desire to share your discoveries and experience with your peers is normal—even
    more than that, it’s healthy. Sharing knowledge to lift your loved ones up is
    the best thing ever, and explaining something is the best way to learn yourself.
    The mistake is to want to apply it immediately, from everywhere, all the time.
    Each way has its advantages and disadvantages. It is absolutely necessary to be
    aware of the disadvantages that it brings. In general, the most common ones are
    the application in the current project and the resistance to change from other
    people involved in the project. Just take the example of the famous SOLID principles:
    although their effectiveness is proven, they can be difficult to access for newcomers.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与同行分享你的发现和经验是正常的——甚至更甚，这是健康的。通过分享知识来提升你爱的人是最好不过的事情，而解释某件事是自我学习最好的方式。错误在于想要立即、无处不在地应用它。每种方法都有其优点和缺点。绝对有必要意识到它带来的缺点。一般来说，最常见的是在当前项目中应用，以及来自项目其他参与者的变化抵抗。只需以著名的SOLID原则为例：尽管它们的有效性得到了证明，但新来者可能难以接触。
- en: 'Resistance to change is normal and natural for all people. Our brain likes
    regularity—it likes cycles and does not like the unexpected. This is obviously
    reflected in the work environment but also in all other aspects of life: diet,
    exercise, and sleep. For code and our work habits, it is exactly the same. Again,
    consistency and regularity are key.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对变化的抵抗对所有人来说都是正常且自然的。我们的大脑喜欢规律性——它喜欢周期性，不喜欢意外。这一点在工作环境中表现得尤为明显，但在生活的各个方面：饮食、锻炼和睡眠中也是如此。对于代码和我们的工作习惯来说，情况完全相同。再次强调，一致性和规律性是关键。
- en: If you bring your new discoveries into the project, you’re going to have to
    consider the training of the people already in place. They will not necessarily
    want to change their habits if the habits already in place are appropriate and
    already meet the need. New habits also mean training all the people who do not
    know these ways of doing things. This requires personal investment, even a substantial
    one in some cases. It is then a question of learning hours either in personal
    time or during working hours, and these hours will therefore be hours where productivity
    will be reduced, undeniably. Sometimes this is necessary, and sometimes it’s even
    a promising idea. But then, you must be able to justify it to everyone, including
    the non-technical parties in the project, and this can clearly be a critical part,
    especially if you are pushed for time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的新发现带入项目，你将不得不考虑现有人员的培训。如果现有的习惯是合适的并且已经满足需求，他们可能并不想改变习惯。新习惯也意味着培训所有不知道这些做事方式的人。这需要个人投入，在某些情况下甚至需要大量的投入。这变成了个人时间或工作时间中的学习小时数，因此这些小时数将是生产力降低的小时数，这是不可否认的。有时这是必要的，有时甚至是一个有希望的想法。但那时，你必须能够向每个人证明这一点，包括项目中的非技术方，这显然是一个关键部分，尤其是如果你时间紧迫。
- en: 'Also, some programming practices can work wonders, be proven, and make life
    much easier. However, they have a huge disadvantage: the onboarding time on the
    project. Just take as an example the practice of “if-less programming”. This programming
    method says to never, absolutely never use `if` and conditional branching in your
    code. This calls for massive and pure use of **object-oriented programming** (**OOP**).
    On paper, it looks good, and the intellectual satisfaction of such a technique
    must be quite exceptional. Its efficiency once mastered is quite clear. Everything
    becomes smarter and the code becomes noticeably clear. In short, everything is
    in place for your next project to adopt if-less programming from the start.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些编程实践可以产生奇迹，被证明是有效的，并使生活变得更加容易。然而，它们有一个巨大的缺点：项目的入职时间。以“无if编程”的实践为例。这种编程方法建议绝对不要在代码中使用`if`和条件分支。这要求大量和纯粹地使用**面向对象编程**（**OOP**）。从纸面上看，这看起来很好，这种技术的智力满足感必须非常特别。一旦掌握，其效率非常明显。一切都会变得更智能，代码也会变得明显清晰。简而言之，一切都在为你的下一个项目从开始就采用无if编程做好准备。
- en: 'However, the day when someone comes to your project to help you and try to
    understand what you are doing (or even to maintain and evolve the project with
    you), the observation will be overwhelming: if the person doesn’t know this programming
    technique (being a technique far from a generality), the whole process of introducing
    the project will be painful. In addition to having to train the person in the
    functional constraints of the project, they will also have to be trained in a
    new programming technique that they are certainly not used to. This means understanding
    the project, understanding the stakes, changing one’s habits, changing one’s way
    of doing and working, and reshaping one’s way of thinking. We understand very
    quickly the cost of such an operation. It can be justified, but you have to be
    very sure of yourself and know all the risks in advance.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当有人来到你的项目来帮助你并试图理解你所做的一切（甚至与你一起维护和演进项目）时，观察结果将会是压倒性的：如果这个人不了解这种编程技术（这是一种远非普遍性的技术），引入项目的整个过程将会很痛苦。除了需要培训这个人在项目功能限制方面的知识外，他们还需要接受一种新的编程技术的培训，他们可能并不熟悉。这意味着理解项目、理解风险、改变习惯、改变做事和工作方式，以及重塑思维方式。我们很快就能理解这种操作的代价。它可以被证明是合理的，但你必须非常确信自己，并且事先了解所有风险。
- en: We are talking about if-less programming here, but the same goes for other ways
    of doing things that are not a general rule. **Test-driven development** (**TDD**)
    is one of them! Integrating TDD into a project can be painful and complicated,
    as we have seen before. However, TDD mainly influences the order of doing things,
    more than learning a complete way of coding. It’s up to you to see, depending
    on your context and your constraints, to what extent these risks are worth taking.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的是无if编程，但同样的情况也适用于其他不是一般规则的做事方式。**测试驱动开发**（**TDD**）就是其中之一！将TDD整合到项目中可能会很痛苦且复杂，正如我们之前所看到的。然而，TDD主要影响做事的顺序，而不是学习一种完整的编码方式。这取决于你根据自己的环境和限制，判断这些风险是否值得承担。
- en: 'In any case, if you choose a new programming technique that can be described
    as exotic, you may have exemplary code, clean and efficient, and super-maintainable.
    The problem is that nobody will be able to understand it. Remember what was said
    in the previous section: code is used to express and convey ideas. It is used
    to be understood by machines and, especially, by human beings. It would be a shame
    to sacrifice the second point, which is why high-level programming languages were
    invented.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果你选择了一种可以描述为异国情调的新编程技术，你可能会拥有典范性的代码，既干净又高效，且易于维护。问题是没有人能够理解它。记住前一个章节中提到的内容：代码是用来表达和传达思想的。它是用来被机器和，尤其是人类理解的。牺牲第二点将会是一件遗憾的事情，这也是为什么高级编程语言被发明出来的原因。
- en: A note on maintainability
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于可维护性的说明
- en: 'And this is where it gets complicated. Your code is ready—it works. You have
    followed a new programming method, and the preliminary developments of the project
    have been going smoothly for several months. And it’s pretty obvious: there may
    have been no foundation on which to build your project; you were lucky enough
    to start from a blank sheet of paper. However, the question of maintainability
    will soon arise. Whichever programming technique you choose, whichever people
    are working on it, bugs will always appear. You may need new people to fix all
    this (and thus teach them your working methods). Are you sure that you have mastered
    your new methodologies enough to ensure the follow-up of an application over several
    years? It is quite possible, but you must be aware of this and know what to do
    if you get stuck on the maintenance of your application.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 而这正是事情变得复杂的地方。你的代码已经准备好了——它运行正常。你已经遵循了一种新的编程方法，项目的初步开发已经顺利进行了几个月。很明显：可能没有为你的项目打下基础；你很幸运地从一张白纸开始。然而，可维护性的问题很快就会出现。无论你选择哪种编程技术，无论谁在从事这项工作，错误总是会出现。你可能需要新的人来修复所有这些问题（并且因此教会他们你的工作方法）。你确定你已经足够熟练地掌握了你的新方法，以确保应用程序在几年内的后续维护吗？这是完全可能的，但你必须意识到这一点，并且知道如果你在应用程序的维护上遇到困难时应该怎么做。
- en: The purpose of this chapter is not to discourage initiative and the testing
    of new work methodologies. It is more a matter of being fully aware of the risks
    of opting for new working methodologies, especially in the long term. We will
    see later that we must be incredibly careful about the latest trends that can
    disappear overnight.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的并不是要阻止创新和测试新的工作方法。更多的是要充分意识到选择新工作方法的风险，尤其是在长期来看。我们稍后会看到，我们必须对一夜之间可能消失的最新趋势格外小心。
- en: The same applies to programming syntaxes that may seem elegant at first glance
    but that are in reality a nightmare of maintainability. Among these practices,
    we can find, in a non-exhaustive way, those highlighted next.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于那些乍一看似乎很优雅但实际上却难以维护的编程语法。在这些做法中，我们可以找到一些被突出显示的，以下是一些非详尽的例子。
- en: Using binary operators and octal, hexadecimal, and binary notations
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用二进制运算符和八进制、十六进制和二进制表示法
- en: In general, the use of binary operators on integers to perform operations (left
    and right shifting, logical `AND`, logical `OR`, bit inversion, and so on) is
    more useless than anything else. Their rarity makes them a syntax that may seem
    elegant to perform certain operations. However, this is not the case, and mastering
    binary operations should not be a prerequisite for understanding PHP code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在整数上使用二进制运算符进行操作（左移和右移、逻辑AND、逻辑OR、位反转等）比其他任何东西都更无意义。它们的罕见性使它们成为执行某些操作的语法看起来很优雅。然而，事实并非如此，掌握二进制操作不应是理解PHP代码的先决条件。
- en: The use of octal, hexadecimal, and binary notations can be justified at times.
    For example, octal notation can be used when you want to play with file permissions.
    Hexadecimal can be used if you want to use flags on your methods, as well as binary
    notation. But in general, apart from making your code complicated to read, there
    is not much to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用八进制、十六进制和二进制表示法是有道理的。例如，当你想玩弄文件权限时，可以使用八进制表示法。如果你想在你方法中使用标志，以及使用二进制表示法，可以使用十六进制。但总的来说，除了使你的代码难以阅读之外，并没有太多其他的作用。
- en: Assigning a variable and using gotos
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值变量和使用goto语句
- en: 'A variable can be assigned at the same time as testing its value. Here’s an
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在测试其值的同时被赋值。以下是一个例子：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At best, you save one line of code. But it’s been a long time since we cared
    about the size of application source files, which are optimized at runtime by
    the PHP interpreter anyway. There is no cost for assigning the variable before
    the test, and your code will become immediately more readable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最多只能节省一行代码。但自从我们关心应用程序源文件的大小以来已经很久了，这些文件最终由PHP解释器在运行时优化。在测试之前分配变量没有成本，而且你的代码会立即变得更加易读。
- en: 'A `goto` instruction allows you to skip entire parts of the code, and even
    “go up” in the code. Although it can be useful in some extremely specific cases,
    it should definitely not be used in most cases. For years now, the use of `goto`
    statements has been frowned upon in most programming languages. Indeed, they bring
    great complexity to the understanding of the code flow. There is a name when too
    many uses of `goto` are to be deplored: spaghetti code.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 指令允许你跳过代码的整个部分，甚至“向上”跳转。尽管在某些极其特定的情况下可能有用，但它绝对不应该在大多数情况下使用。多年来，在大多数编程语言中，`goto`
    语句的使用一直受到谴责。确实，它们给代码流程的理解带来了极大的复杂性。当`goto`的使用过多时，有一个专门的名称：意大利面代码。'
- en: Excessively using comments
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度使用注释
- en: Sometimes, we see the abusive use of comments on sometimes several hundred lines
    to explain the type of all the variables, their utility, all the exceptions raised
    by the function, the return value in detail, and so on. We can even find source
    files where there are more comments than code. All these details can be omitted
    most of the time by a clear naming of your methods and variables. Furthermore,
    the typing of variables, arguments, and function returns in recent versions of
    PHP also solves this problem. However, using comments to produce documentation
    can be totally justified and should be used when possible. Nobody will ever complain
    because there is “too much documentation”. Feel free to write dozens of lines
    about what a class, interface, method, and so on is all about; more generally,
    descendant, technical and/or functional choices about it, and so on. When we speak
    about “abusive use of comments”, we’re talking about comments that are explaining
    what’s happening in the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会看到注释的滥用，有时甚至有几百行来解释所有变量的类型、它们的用途、函数引发的所有异常、详细的返回值等等。我们甚至可以找到注释比代码还多的源文件。大多数情况下，通过清晰命名你的方法和变量，这些细节都可以省略。此外，PHP最新版本中变量的类型、参数和函数返回值的类型也解决了这个问题。然而，使用注释生成文档是完全合理的，并且在可能的情况下应该使用。没有人会抱怨“文档太多”。自由地写几十行关于类、接口、方法等等是什么，以及更普遍的关于它的派生、技术性和/或功能性选择等等。当我们谈论“注释的滥用”时，我们指的是解释代码中发生什么的注释。
- en: Using ternary comparisons
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用三元比较
- en: 'Here’s an example of a ternary comparison:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个三元比较的例子：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although ternary comparisons can make code concise and include a condition
    in—for example—the passing of an argument in a function, they should not be abused,
    especially nested ternary comparisons, which immediately become unreadable and
    headache-inducing at the first level of nesting. You can see proof of this in
    the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然三元比较可以使代码更加简洁，并将条件包含在例如函数参数传递中，但它们不应该被滥用，尤其是嵌套的三元比较，一旦嵌套到第一层，就会变得难以阅读，令人头疼。你可以在以下例子中看到这一点的证明：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is not a very clear or readable line of code, which makes ternary conditions
    complicated to read when the condition is not a basic and simple one, as in the
    first example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一条非常清晰或易于阅读的代码行，当条件不是基本且简单的时候，例如在第一个例子中，三元条件就会变得难以阅读。
- en: Using abbreviations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缩写
- en: 'Here’s maybe the most common practice to be discouraged: the use of abbreviations
    all over the place. Again, at the end of the last millennium, we might have had
    reasons to use abbreviations: space and storage were much more limited than today,
    and code editors were not as smart with all the autocomplete features we have
    today. Therefore, naming a variable `$userPasswordRequest` instead of `$usr` will
    make everyone’s life easier: both yours and the developers who will come back
    to your code and won’t have to ask you what your abbreviations mean. Again, with
    the autocomplete tools we have today, it doesn’t make sense to name our variables
    this way.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能是最常见且应被劝阻的做法：到处使用缩写。再次强调，在上个世纪的末尾，我们可能有一些使用缩写的理由：空间和存储比今天要有限得多，而且代码编辑器没有我们今天所拥有的所有自动完成功能那么智能。因此，将变量命名为`$userPasswordRequest`而不是`$usr`会让每个人的生活变得更轻松：既包括你，也包括将来回到你的代码的开发者，他们不需要问你这些缩写代表什么。再次强调，有了我们今天所拥有的自动完成工具，这样命名我们的变量是没有意义的。
- en: Bringing micro-optimizations to your code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将微优化引入你的代码
- en: 'Micro-optimizations are very minor changes made to the code that may impair
    its readability, justified by the optimization of the code. Thus, it would be
    faster to execute. The problem is that this is often not useful, first because
    you don’t need to optimize an instruction to the nanosecond (because of the power
    of processors nowadays), but also because a lot of optimizations are done by language
    interpreters and compilers. So, you sacrifice part of the readability of your
    code for something that is not useful and that will be done automatically. Moreover,
    this often provokes sterile debates where nobody is more right than anyone else.
    In these debates of micro-optimization specific to PHP, we find in particular
    the position of the operators of incrementation (`++`) and decrementation (`--`)
    in position before or after the variables, the use of the backslash in front of
    the methods of the **Standard PHP Library** (**SPL**), or the static declaration
    or not of anonymous functions. Again, the answer is: think about consistency with
    the rest of the code and be pragmatic. You certainly don’t need the 10 nanoseconds
    that will be (perhaps, in some circumstances) saved by your optimization that
    will have started a heated debate within the development team.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 微优化是对代码进行的非常小的更改，可能会损害其可读性，但这是为了优化代码，从而使其执行速度更快。问题是这通常并不有用，首先是因为你不需要优化指令到纳秒级别（因为现在的处理器很强大），而且因为很多优化都是由语言解释器和编译器完成的。所以，你牺牲了代码的一部分可读性，为了那些不实用且会被自动执行的事情。此外，这通常会引起无谓的争论，其中没有人比任何人更有道理。在这些针对PHP的特定微优化争论中，我们发现特别是关于增量运算符（`++`）和减量运算符（`--`）在变量之前或之后的位置、在**标准PHP库**（**SPL**）的方法前使用反斜杠，或者匿名函数的静态声明或不声明的问题。再次强调，答案是：考虑与代码其他部分的连贯性，并保持实用主义。你当然不需要通过优化节省的10纳秒，这可能会在某些情况下节省，但可能会在开发团队中引发一场热烈的争论。
- en: Recoding the methods of the SPL
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新编码SPL的方法
- en: 'We have a lot of use for a language that has a very extensive standard library.
    The standard library is a set of classes and methods provided with each installation
    of PHP. Unfortunately, we quickly realize that it is quite unknown and offers
    more possibilities than you might think. As a result, we often find ourselves
    with SPL methods that are recoded in the project because the developer in question
    did not know about the existence of the standard method. This is extremely unfortunate
    and, in some cases, a real problem for the following reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对一个非常广泛的标准库语言有很多用途。标准库是PHP每个安装提供的类和方法集合。不幸的是，我们很快就会意识到它相当不为人知，并且提供了比你想象的更多可能性。因此，我们经常发现自己项目中使用了SPL方法，因为相关的开发者不知道标准方法的存在。这非常不幸，在某些情况下，这确实是一个真正的问题，原因如下：
- en: SPL methods are available everywhere. There is no need to worry about whether
    they are available on this or that installation or setup.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPL方法无处不在。无需担心它们是否在某个安装或设置中可用。
- en: These methods are tested by the developers of the PHP interpreter, which is
    not necessarily the case for your methods.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法是由PHP解释器的开发者测试的，而你的方法则不一定如此。
- en: If one of these methods can be optimized or secured, it can be done thanks to
    the thousands of contributors and researchers of the language.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这些方法中的任何一个可以被优化或加强，这将得益于语言的数千名贡献者和研究人员。
- en: These methods are thought and conceptualized to be as efficient as possible
    by people whose job is to create the most efficient algorithms possible.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法被认为是尽可能高效的，由那些工作就是创建尽可能高效算法的人所构思和概念化。
- en: SPL methods can be written in the C language directly. This means that their
    performance will be unmatched no matter what you do in PHP. It would be a shame
    not to take advantage of this considerable benefit, especially on methods used
    intensively in applications where execution time can be critical. Furthermore,
    because they are written in C, the C compiler can offer very low-level optimizations
    on these methods, directly with assembly code. You won’t be able to do this by
    writing the method in PHP.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPL 方法可以直接用 C 语言编写。这意味着无论你在 PHP 中做什么，它们的性能都将无与伦比。不利用这一显著的好处将是遗憾的，尤其是在执行时间可能至关重要的应用中频繁使用的方法。此外，由于它们是用
    C 编写的，C 编译器可以对这些方法提供非常底层的优化，直接使用汇编代码。你无法通过在 PHP 中编写方法来实现这一点。
- en: Feel free to have a look at the official PHP documentation; some methods such
    as `natsort()` might surprise you and save you hours of development!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随意查看官方 PHP 文档；一些方法，如 `natsort()`，可能会让你感到惊讶，并为你节省数小时的开发时间！
- en: The list could go on and on, but the point is that while you may enjoy using
    these things, you will be the only one who will feel any satisfaction. A junior
    developer might be completely lost at the sight of these practices, while a senior
    developer won’t understand the value of using these practices when clearer and
    simpler ones are available. Your code must be understood by as many people as
    possible. Show the extent of your skills, knowledge, and proficiency by producing
    some simple, trivial, and readable code for a problem that seemed overly complex
    at first.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列举可以继续下去，但重点是，虽然你可能喜欢使用这些工具，但你将是唯一会感到满足的人。一个初级开发者可能会在这些实践面前完全迷失，而一个资深开发者则不会理解在更清晰、更简单的方法可用时使用这些实践的价值。你的代码必须尽可能被更多的人理解。通过为看似过于复杂的问题编写一些简单、琐碎且易于阅读的代码，来展示你的技能、知识和熟练程度。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Do you understand what is meant by “building on what we know”? We realize with
    a little hindsight that this is again a lot of common sense and altruism, thinking
    of the next developers who will pass over our code. Here, there was no question
    of scouts, SOLID, **Keep It Simple, Stupid** (**KISS**), or other principles.
    It’s about rethinking our very methods of writing code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你理解“建立在我们已知的基础上”是什么意思吗？我们稍作回顾后意识到，这又是一种常识和利他主义，考虑到未来会阅读我们代码的开发者。在这里，没有关于侦察兵、SOLID、**简单至上，傻瓜也明白**（**KISS**）或其他原则的问题。这是关于重新思考我们编写代码的方法。
- en: We must remember that the basics can (and should) be questioned and not considered
    as set in stone. Self-confidence is a wonderful thing, and if you are able to
    combine this with continuous questioning of your habits in a perspective of continuous
    improvement, you are on the right track to becoming an excellent developer, being
    able to write clean code naturally, and bringing your collaborators with you in
    this practice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，基础的东西可以（并且应该）被质疑，不应被视为一成不变。自信是一种美好的东西，如果你能够结合这种持续改进的习惯，你就能走上成为优秀开发者的正确道路，能够自然地编写干净的代码，并带领你的合作者一起实践。
- en: Taking the initiative is a remarkable thing; knowing the risks and evaluating
    them in your context is the key to striving for perfection. This way, you are
    able to know if it is really worth it, but also can justify your choices to the
    people running the project. Again, we come back to the ability to justify all
    our choices and actions when it comes to clean code. Clean code is not just about
    avoiding the use of binary operators or the use of hexadecimal notations. It means
    thinking about the environment, the constraints, and the surroundings of our project.
    Clean code is not only about code. Luckily, this is exactly what we will see in
    the next chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 积极主动是一件了不起的事情；了解风险并在你的环境中评估它们是追求完美的关键。这样，你才能知道这是否真的值得，同时也能向项目管理者证明你的选择是合理的。再次强调，当我们谈到干净代码时，我们回到能够证明我们所有选择和行动的能力。干净的代码不仅仅是避免使用二进制运算符或十六进制表示法。这意味着要考虑我们的项目环境、约束和周围环境。干净的代码不仅仅是关于代码。幸运的是，这正是我们将在下一章中看到的。
