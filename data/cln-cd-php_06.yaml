- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: PHP is Evolving – Deprecations and Revolutions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP正在发展——弃用和革命
- en: We did well. The PHP community did well; we were lucky. Indeed, PHP has been
    evolving very strongly for a few years now. But this strong evolution hasn’t always
    been there. This was mainly due to problems during the development of PHP 6, which
    was why this version was never released. This explains why so many projects were
    (and still are) stuck at PHP 5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做得很好。PHP社区做得很好；我们很幸运。的确，PHP在过去的几年里一直在非常强烈地发展。但这种强烈的演变并不是一直存在的。这主要是因为PHP 6开发期间的问题，这也是为什么这个版本从未发布的原因。这也解释了为什么许多项目（现在仍然如此）卡在PHP
    5上。
- en: PHP 7 has wiped the slate clean and brought a real revival to the language.
    Moreover, it is a real breath of fresh air that has boosted the language toward
    new horizons.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7彻底清除了旧账，为这门语言带来了真正的复兴。此外，它就像一股清新的空气，将语言推向了新的境界。
- en: 'PHP went from being an almost dead language to a language catching up and projecting
    itself in the future. In this last chapter, dedicated to the clean-code theory,
    we will focus on the following points:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PHP从几乎是一门死去的语言发展成为一个正在迎头赶上并面向未来的语言。在本章的最后，我们将专注于以下内容，这是专门针对清洁代码理论的：
- en: How PHP is different from its past versions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP与其过去版本的不同之处
- en: How these changes will help you become a more rigorous and better developer,
    and not only in PHP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些变化将如何帮助你成为一个更加严谨和更好的开发者，而不仅仅是PHP开发者
- en: What the major new features of PHP are in its latest versions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP最新版本中的主要新特性是什么
- en: Old versus new PHP
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧PHP与新PHP
- en: PHP has likely helped you become a much more rigorous developer over the years.
    If during its first decades of existence, PHP allowed you to write code the way
    you wanted to and without restricting you from doing so, with the (very) few advantages
    that this brings, in hindsight, it was mostly the opportunity to have as many
    ways to write code as there are developers (which rarely lead to exceptional results)
    that made it popular. As we now know, that can be a source of endless and infernal
    bugs to debug. Fortunately, the evolution of the language in the last few years
    has fixed a lot of these bugs, to the benefit of our applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，PHP可能已经帮助你成为一个更加严谨的开发者。如果在PHP存在的最初几十年里，PHP允许你按照自己的意愿编写代码，而不对你进行任何限制，并且只带来（非常）少的优势，那么从后视镜来看，这主要是提供了尽可能多的编写代码的方式，就像有尽可能多的开发者一样（这很少能产生卓越的结果），这使得它变得流行。正如我们现在所知道的那样，这可能是无穷无尽的和地狱般的调试bug的源头。幸运的是，在过去的几年里，语言的演变已经修复了许多这些bug，这对我们的应用程序来说是一大好处。
- en: Strict typing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格类型
- en: First, let’s look at one of the most important things you should be using in
    the newest versions of PHP from version 7.4 – the strict typing of properties.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看从7.4版本开始的新版PHP中最重要的一些特性之一——属性的严格类型。
- en: There was a time you were allowed to pass any data to any variable and cast
    variables as much as you wish, without a real and native way to prevent this –
    converting an array variable to a string, a string to an integer, and so on. That
    can be pretty confusing and potentially the source of so many problems. What would
    happen if you multiplied a string by an integer, for example? Well, the result
    is totally unexpected. This isn’t well managed like it is in Python, where these
    types of operations are allowed but well controlled. If your PHP code relies on
    the ability of weak typing, there may be a problem with your code architecture,
    and you must absolutely review the parts that need this weak typing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，你可以随意将任何数据传递给任何变量，并且可以随意将变量转换为任何类型，而没有真正和原生的方式来阻止这种行为——例如将数组变量转换为字符串，将字符串转换为整数等。这可能会非常令人困惑，并且可能是许多问题的源头。例如，如果你将一个字符串乘以一个整数，会发生什么？嗯，结果是完全出乎意料的。这不像Python那样管理得很好，在Python中，这类操作是允许的，但受到很好的控制。如果你的PHP代码依赖于弱类型的能力，那么你的代码架构可能存在问题，你必须绝对审查需要这种弱类型的部分。
- en: PHP now allows you to strictly type variables in some situations. As of PHP
    8.1, you can’t type a variable if it is not a class attribute or a method argument.
    That said, you should type all the attributes of your classes and method arguments
    – less confusion, more rigor. You may have to rethink some parts of your code,
    but you get the benefit of cleaner, more understandable code. There are no surprises
    at runtime because of an unexpected cast. If you really need to pass any type
    of data to your methods, you can still rely on the `mixed` keyword, which tells
    PHP that this variable can be any type of data, or that the method can return
    any type of data. Of course, you must avoid this if you can and only use it in
    very precise cases (such as interface method definitions, where the interface’s
    implementations can return several types of data).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 现在允许在某些情况下严格类型化变量。从 PHP 8.1 开始，如果变量不是类属性或方法参数，则不能对其进行类型化。话虽如此，你应该对所有类属性和方法参数进行类型化——这样可以减少混淆，增加严谨性。你可能需要重新思考代码的一些部分，但你会得到更干净、更易于理解的代码的好处。由于意外的类型转换，运行时不会出现任何意外。如果你真的需要将任何类型的数据传递给方法，你仍然可以依赖
    `mixed` 关键字，它告诉 PHP 这个变量可以是任何类型的数据，或者方法可以返回任何类型的数据。当然，如果你能避免这种情况，就避免使用它，并且只在非常精确的情况下使用它（例如接口方法定义，其中接口的实现可以返回几种类型的数据）。
- en: Error reporting
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误报告
- en: PHP 8 now displays deprecations and more strict errors by default. The error
    reporting level was lower in earlier versions of PHP. With this change, you’ll
    be able to see way more easily where you need to pay attention to deprecation,
    for example. You’ll be thankful for this change when you have to operate a PHP
    version upgrade, for example. If you take care of fixing deprecations as soon
    as they appear, upgrading to another version of PHP will be an easy task. Moreover,
    there is almost always a message resulting from the deprecation, telling you how
    to fix it precisely. Taking care of these errors and especially deprecations at
    the earliest opportunity is definitely a clever move and makes you adopt a clean-code
    mindset.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 8 默认显示弃用和更严格的错误。在 PHP 的早期版本中，错误报告级别较低。随着这一变化，你将能够更容易地看到需要关注弃用的地方，例如。当你需要操作
    PHP 版本升级时，你会感谢这一变化。如果你在弃用出现时立即着手修复它们，升级到另一个版本的 PHP 将会变得容易。此外，几乎总是有一个来自弃用的消息，告诉你如何精确地修复它。尽早处理这些错误，特别是弃用，绝对是一个明智的选择，并使你养成干净代码的思维模式。
- en: Attributes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: Comments in source code were invented to give a better understanding of tricky
    code parts. This means that if we remove all comments in source code, it should
    work perfectly as well, as compilers and interpreters shouldn’t consider comments.
    That’s the main and *very first reason* source code comments were invented.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码中的注释是为了更好地理解复杂的代码部分而发明的。这意味着如果我们从源代码中移除所有注释，它应该也能完美运行，因为编译器和解释器不应该考虑注释。这就是源代码注释被发明的主要原因和*第一个原因*。
- en: 'Then, annotations were created. Logic and mechanisms were introduced *right
    in the comment sections*. Don’t get me wrong – annotations are very practical.
    You get every bit of information and metadata about an element where you need
    it and when you need it. But it is somehow an aberration when you think about
    it. And remember what we said in previous chapters: if you write code cleanly,
    then there is a great chance that you never need to write a single line of comment,
    or at the most just a few (writing tricky code parts cannot always be avoided,
    even for the best clean coders).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建了注解。逻辑和机制被引入到注释部分。请别误会——注解非常实用。你可以在需要的地方和需要的时候获得有关元素的所有信息和元数据。但当你这么想的时候，它似乎是一种异常。而且记住我们在前面的章节中说过的话：如果你编写干净的代码，那么你几乎永远不需要写一行注释，或者最多只有几行（编写复杂的代码部分是无法避免的，即使是最好的干净代码编写者也不例外）。
- en: 'Attributes have been part of the PHP language since version 8.0\. Simply put,
    attributes have the same role as annotations: add metadata to different elements,
    including classes, properties, and methods. The difference is that they use another
    syntax, which is not the type used for comments. More than having better readability,
    comments will go back to their first use: being *informative*. In an instance,
    you can immediately differentiate metadata (described with attributes) and comments
    to better understand the code part you’re working on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 属性自 PHP 8.0 版本以来一直是 PHP 语言的一部分。简单来说，属性与注解具有相同的作用：为不同的元素添加元数据，包括类、属性和方法。不同之处在于它们使用另一种语法，这不是用于注释的类型。除了更好的可读性之外，注释将回归其最初用途：提供*信息*。在实例中，你可以立即区分元数据（用属性描述）和注释，以更好地理解你正在工作的代码部分。
- en: 'Let’s see what attributes look like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看属性的样子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is clear that the currently logged-in user will probably be injected in the
    `$user` variable. The code looks sharp, and we have all the information we need
    to understand what’s happening at a glance. We also have a perfectly blank space
    if we ever need to add information in the comments section above the `home()`
    method. You can now see clearly how attributes help you to be more rigorous –
    remove all comment blocks and think twice before adding a new one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，当前登录的用户很可能会被注入到 `$user` 变量中。代码看起来很锐利，我们有了所有需要的信息来一眼看出正在发生的事情。如果我们需要在 `home()`
    方法上面的注释部分添加信息，我们也有一个完美的空白空间。你现在可以清楚地看到属性如何帮助你更加严谨——移除所有注释块，在添加新的注释之前三思。
- en: 'There are obviously still a lot of things happening in the most recent versions
    of PHP, starting from version 8.0\. Here is a non-exhaustive list:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 8.0 开始，PHP 的最新版本中显然还有很多事情在发生。以下是一个非详尽的列表：
- en: Union types
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合类型
- en: Match syntax
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配语法
- en: Named arguments
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数
- en: Enumerations
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: JIT compiler
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 编译器
- en: Fibers
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纤程
- en: Numeric separator
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字分隔符
- en: Let’s see a few of them in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看其中的一些。
- en: The version 8 revolution
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 版革命
- en: As we have seen, PHP has experienced exceptional momentum in its evolution for
    the last few years. While we thought that version 7 was a real rebirth of the
    language, version 8 proved that it was only the beginning. Here are the main new
    features that will help you write clear and concise code, and that will help you
    to push even further the principles of clean code that we have seen throughout
    these chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，PHP 在过去几年中经历了非凡的势头。虽然我们认为版本 7 是语言的真正重生，但版本 8 证明这只是开始。以下是一些主要的新特性，这些特性将帮助你编写清晰简洁的代码，并帮助你进一步推动我们在这些章节中看到的清洁代码原则。
- en: Match syntax
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配语法
- en: 'The match syntax is the condensed version of the classic `switch/case`. It
    should not be used everywhere because it can quickly become unreadable. However,
    if you choose the places where you use it sparingly, your code can become much
    clearer in an instant. Here is an example of the match syntax:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配语法是经典 `switch/case` 的简略版本。它不应该到处使用，因为它可以很快变得难以阅读。然而，如果你选择谨慎使用它的地方，你的代码可以立即变得更加清晰。以下是一个匹配语法的示例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It works the same way as switch. However, note the difference in the length
    of the code and how readability is increased. You can also immediately see the
    limitations of such a syntax: if there is more than one statement to execute per
    case, it is not at all adaptable, and you run the risk of ending up with something
    unreadable. It is then preferable to stick to the more classical `switch/case`
    block.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与 switch 一样。然而，请注意代码长度和可读性提高的差异。你还可以立即看到这种语法的局限性：如果每个案例有多个要执行的语句，它根本不适应，你面临的结果可能是难以阅读的。因此，坚持更经典的
    `switch/case` 块是更好的选择。
- en: Named arguments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数
- en: If you are used to using other languages regularly, you may be familiar with
    this evolution of PHP. Since version 8.0, it is possible to pass arguments to
    methods in the order you want. This is done by specifying the name of the argument
    just before its value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于经常使用其他语言，你可能熟悉 PHP 的这种演变。从版本 8.0 开始，你可以按照你想要的顺序传递参数给方法。这是通过在参数值之前指定参数名称来完成的。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can quickly see two cases where this can be useful:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速看到两种情况下这很有用：
- en: First, we sometimes encounter methods with a lot of optional arguments that
    already have a default value defined. Sometimes, we want to change the value of
    an argument that may be the 5th or 11th in a list. This is followed by a lengthy
    process of rewriting the default values of all the parameters before it. This
    is clearly not ideal, but it is a problem that can be solved by using named arguments.
    You simply specify the name of the argument you want to give and its value, and
    you’re done.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有时会遇到具有很多可选参数的方法，这些参数已经定义了默认值。有时，我们想要更改列表中可能是第5个或第11个的参数的值。这随后是一个漫长的过程，需要重写所有参数的默认值。这显然不是理想的，但这是一个可以通过使用命名参数解决的问题。你只需指定你想要提供的参数的名称及其值，然后你就完成了。
- en: A second case is where you add clarity to a method call, even if it has no optional
    arguments. If your method has a lot of arguments, you might think about using
    named arguments to explicitly show what you are sending to the method. However,
    if this is the case, the real solution to make code more readable is to refactor
    it so that you don’t need to pass so many arguments to a method. This can be done
    by splitting the method into several ones, or by creating **Value Objects** (**VOs**).
    These are objects containing only simple properties, without other methods or
    logic, to transfer data from one point to another in code. This avoids the worry
    of endless arguments, and it also adds a layer of validation with strong-typed
    properties and adds some context to the data you carry with it.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是，即使方法没有可选参数，你也可以通过添加清晰度来改进方法调用。如果你的方法有很多参数，你可能想考虑使用命名参数来明确显示你发送给方法的参数。然而，如果情况如此，真正使代码更易读的解决方案是对代码进行重构，这样你就不需要向方法传递这么多参数。这可以通过将方法拆分成几个方法，或者通过创建**值对象**（**VOs**）来实现。这些对象只包含简单的属性，没有其他方法或逻辑，用于在代码中将数据从一个点传输到另一个点。这避免了无休止的参数担忧，并且它还通过强类型属性添加了一层验证，并为携带的数据添加了一些上下文。
- en: Read-only classes and properties
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读类和属性
- en: Here is a little riddle to introduce read-only classes and properties. In a
    PHP class, how can you ensure that an attribute will be assigned only once – that
    is, it can be assigned a value only once, and all future attempts to assign it
    will fail? Note that this also applies to assignments within the class itself.
    This means that a mutator throwing an exception in the case of a call cannot work
    because we cannot be 100% sure that the developer will go through the mutator
    within the class scope.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小谜题来介绍只读类和属性。在一个PHP类中，你如何确保一个属性只会被分配一次——也就是说，它只能分配一次值，所有未来的尝试分配它都会失败？请注意，这也适用于类内部的赋值。这意味着在调用中抛出异常的修改器无法工作，因为我们不能100%确定开发者会在类作用域内通过修改器。
- en: 'Actually, the answer is quite simple: it is impossible. If you are using PHP
    8.0 or earlier, it just isn’t possible. PHP 8.1 brings us a native solution to
    solve this problem: read-only properties. By declaring a class property with the
    `readonly` keyword, the variable can only be assigned once, regardless of the
    context. This can be especially useful when defining and using DTOs and VOs. By
    restricting access to the mutation of these properties, the developer using them
    will have to think carefully about the use of the object. If they want to make
    changes, they will have to create a new object. The original object cannot be
    modified, which can guarantee better stability and robustness of code. Here is
    how read-only properties are declared:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，答案很简单：这是不可能的。如果你使用的是PHP 8.0或更早版本，这根本不可能。PHP 8.1为我们带来了一个原生解决方案来解决这个问题：只读属性。通过使用`readonly`关键字声明类属性，变量只能被赋值一次，无论上下文如何。这特别有用，当定义和使用DTOs和VOs时。通过限制对这些属性的修改访问，使用它们的开发者将不得不仔细思考对象的使用。如果他们想要进行更改，他们将不得不创建一个新的对象。原始对象不能被修改，这可以保证代码有更好的稳定性和健壮性。以下是声明只读属性的方法：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since PHP 8.2, it has even been possible to declare an entire class as `readonly`
    by placing this modifier just before `class` keyword, so you don’t have to use
    the keyword on every property the class includes. This also gives you a big advantage:
    a class declared as `readonly` will not be able to have new properties declared
    dynamically. Although this behavior is deprecated and should be avoided at all
    costs (dynamic declaration of class properties is a nightmare in terms of debugging,
    stability, and code complexity), it is still possible to do so in versions up
    to PHP 9.0, in which a fatal error will be triggered if this behavior occurs.
    If you are not using PHP 9.0, declaring your class as `readonly` will protect
    you from this behavior.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自 PHP 8.2 以来，甚至可以通过在 `class` 关键字之前放置此修饰符来声明整个类为 `readonly`，这样你就不必在类包含的每个属性上使用该关键字。这也给你带来了很大的优势：声明为
    `readonly` 的类将无法动态地声明新属性。尽管这种行为已被弃用，并且应该不惜一切代价避免（在调试、稳定性和代码复杂性方面，动态声明类属性是一个噩梦），但在
    PHP 9.0 版本中仍然可以这样做，如果发生这种行为，将触发致命错误。如果你不使用 PHP 9.0，将你的类声明为 `readonly` 将保护你免受这种行为的影响。
- en: This is a big step forward for PHP developers. Indeed, all thanks to this feature,
    we will need to be, once again, increasingly rigorous on how we interact with
    objects and their properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于 PHP 开发者来说是一个巨大的进步。确实，多亏了这个特性，我们再次需要越来越严格地对待我们与对象及其属性交互的方式。
- en: Migrating resources to proper classes
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资源迁移到适当的类中
- en: 'Depending on how long you have been developing in PHP, you should be more or
    less familiar with what we call resources. A resource is a special type of variable,
    which represents a reference to an external resource. This may sound a bit vague,
    but it is actually quite trivial. A resource can be the following, for example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在 PHP 中的开发经验长短，你应该或多或少熟悉我们所说的资源。资源是一种特殊类型的变量，它代表了对外部资源的引用。这听起来可能有些模糊，但实际上相当简单。资源可以是以下内容，例如：
- en: An open file
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的文件
- en: A database connection
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接
- en: A cURL call
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cURL 调用
- en: A connection to an LDAP directory (which is a way to manage user accounts in
    companies, generally)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 LDAP 目录（通常是一种在公司中管理用户账户的方式）
- en: A font for a GD image manipulation extension
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 GD 图像操作扩展的字体
- en: This has worked well for a few decades now, but we understand that the term
    *resource* is not really adapted anymore by being too generalist and especially
    quite old-fashioned now that classes and objects are predominant in modern code.
    Why aren’t these resources simply objects like any other? Well, there is no particular
    reason (at least not at present) to justify this. And that’s why PHP 8.0 has started
    a long but necessary migration to convert the old resources into full-fledged
    classes. It makes much more sense.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很好地工作了数十年，但我们理解，术语 *资源* 由于过于通用，尤其是现在在现代代码中类和对象占主导地位，已经不再适用了。为什么这些资源不能像任何其他对象一样简单呢？好吧，至少目前没有特别的理由来证明这一点。这就是为什么
    PHP 8.0 开始了一个漫长但必要的迁移过程，将旧资源转换为完整的类。这样做更有意义。
- en: The use of resources was complex. They are complicated to debug and understand
    how they work and their internal state. They can only be called by special functions
    that handle resources. This is a big step forward for developers who will have
    more control and more tools to improve the rigor of development and robustness
    of their code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的使用很复杂。它们难以调试，并且理解它们的工作方式和内部状态也很复杂。它们只能通过处理资源的特殊函数来调用。这对于将会有更多控制和更多工具来提高开发严谨性和代码健壮性的开发者来说是一个巨大的进步。
- en: 'The change is made as new versions of PHP are released. For example, PHP 8.0
    embeds the migration of resources such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新版本的 PHP 发布，这种变化被实现。例如，PHP 8.0 内嵌了以下资源的迁移：
- en: GD, for the manipulation of images
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GD，用于图像操作
- en: '`cURL`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cURL`'
- en: OpenSSL
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL
- en: XML
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML
- en: Sockets
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sockets
- en: 'Conversely, PHP 8.1 embeds the migration of the following resources:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，PHP 8.1 内嵌了以下资源的迁移：
- en: GD fonts
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GD 字体
- en: FTP
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP
- en: IMAP
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IMAP
- en: finfo, for file management
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: finfo，用于文件管理
- en: Pspell, for spell checking
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pspell，用于拼写检查
- en: LDAP
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP
- en: PostgreSQL
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: 'The following versions of PHP continue to do the same – to eventually remove
    the use of resources in the standard PHP library. Furthermore, the core PHP developers
    have decided since PHP 8.1 to create some of these classes under namespaces. We
    can see that the language, with this kind of action and development, is catching
    up after a long delay and making every effort to restore its reputation. PHP shows
    it clearly: the language is here to stay.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的PHP继续执行相同的任务——最终移除标准PHP库中资源的使用。此外，自PHP 8.1以来，核心PHP开发者决定在命名空间下创建一些这些类。我们可以看到，经过长时间的滞后，这种行动和开发使得语言努力恢复其声誉。PHP清楚地表明：这种语言将长期存在。
- en: Protecting your sensitive arguments from leaking
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护你的敏感参数不被泄露
- en: 'If you have been developing with PHP for some time, you are surely aware of
    the many ways to display the content of a variable or a function argument. You
    can think of `var_dump` and `print_r` in particular. There are also other occasions
    when arguments and their values can be displayed: when the stack trace (or call
    stack) is displayed. This happens either by a manual call to a method such as
    `debug_print_backtrace` but also and often when an exception is thrown. In any
    case, if sensitive information is contained somewhere in the variables or call
    stack with the arguments of method calls, this can be problematic. You might think
    that this only happens in a development environment, but this is a mistake. It
    is highly likely that you write your exception messages in an error log somewhere
    on your server(s). This could result in sensitive information being displayed
    in your logs. This is obviously not recommended. Sensitive information should
    not be written in clear text anywhere. Also, and although it is a mistake, the
    security of application logs is often not as good as that of a database, for example.
    Furthermore, there is a great chance that many developers of the project (if not
    all of them) have access to such logs to debug the application. The threat does
    not always come from outside.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经用PHP开发了一段时间，你肯定知道有很多种方法可以显示变量或函数参数的内容。特别是你可以想到`var_dump`和`print_r`。还有其他场合可以显示参数及其值：当显示堆栈跟踪（或调用堆栈）时。这可能是通过手动调用`debug_print_backtrace`等方法，也可能是抛出异常时，这种情况很常见。无论如何，如果变量或调用堆栈中的方法调用参数包含敏感信息，这可能会成为问题。你可能认为这种情况只发生在开发环境中，但这是一种错误。你很可能在服务器（们）上的某个地方编写了异常消息到错误日志中。这可能导致敏感信息显示在你的日志中。这显然是不推荐的。敏感信息不应在任何地方以明文形式写入。此外，尽管这是一个错误，但应用程序日志的安全性通常不如数据库，例如。此外，项目中的许多开发者（如果不是所有开发者）都可能有权访问这些日志以调试应用程序。威胁并不总是来自外部。
- en: 'Fortunately, PHP 8.2 includes a new attribute to remedy this problem. It is
    indeed possible to indicate the `#[SensitiveParameter]` attribute before any function
    argument. This will tell PHP not to display the parameter value in `var_dump`,
    a stack trace, and so on. Placed cleverly, you’ll be sure not to leak a sensitive
    value in an error message, for example. Indeed, it is not uncommon for sites to
    display the server error directly on the frontend. This should obviously be banned
    as soon as possible, but at least it helps to limit the damage. Let’s see how
    this new attribute can be used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PHP 8.2包含了一个新的属性来解决这个问题。确实可以在任何函数参数之前指定`#[SensitiveParameter]`属性。这将告诉PHP不要在`var_dump`、堆栈跟踪等中显示参数值。如果巧妙地放置，你就可以确保不会在错误消息中泄露敏感值，例如。实际上，网站直接在前端显示服务器错误并不罕见。显然，这应该尽快被禁止，但至少它有助于限制损害。让我们看看这个新属性如何使用：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the internal workings of PHP, this attribute will replace the argument with
    an object of type `SensitiveParameterValue`, which will hide the real value of
    the argument. The argument will be displayed and present in the output, but its
    value will be hidden. Adding this attribute to your sensitive method arguments
    is a clever and welcome way to add rigor to your code and make it more resistant
    to attacks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的内部工作原理中，此属性将用类型为`SensitiveParameterValue`的对象替换参数，这将隐藏参数的真实值。参数将在输出中显示和存在，但其值将被隐藏。将此属性添加到你的敏感方法参数中是一种聪明且受欢迎的方法，可以增加代码的严谨性并使其更具抗攻击性。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'It cannot be repeated enough: PHP is evolving in the most beautiful way and
    is catching up with its competitors in the web world. The language listens to
    the community and the developers by offering them the tools they need to answer
    modern problems in the most viable way possible.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何强调都不为过：PHP正在以最美好的方式发展，并在网络世界中迎头赶上其竞争对手。该语言通过提供社区和开发者需要的工具，以最可行的方式解决现代问题，倾听他们的声音。
- en: We have come a long way from a language that allowed everything and was very
    (too) lax for the challenges of today’s web applications. Despite the explosion
    of frontend frameworks and technologies aimed at replacing server languages with
    languages intended for the frontend (such as Node.js with JavaScript), PHP has
    nothing to be ashamed of. Its impressive performance, its speed of evolution,
    and the reputation it has built over the years show that it still has a bright
    future ahead of it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从一个允许一切、对当今网络应用挑战非常（过于）宽松的语言走了很长的路。尽管前端框架和技术爆炸式增长，旨在用面向前端的语言（如Node.js和JavaScript）取代服务器端语言，但PHP没有任何可耻之处。它令人印象深刻的性能、其快速的发展速度以及多年来建立的名誉都表明，它面前还有光明的未来。
- en: 'Although clean code is, as we have seen, a state of mind and, in a way, a philosophy,
    solutions native to the language are arriving in spades to help us apply them
    as well as possible. Even better, these features brought to PHP allow us to see
    new possibilities that we would not necessarily have thought of initially to make
    our code robust, maintainable, and viable in the long term. Just think about named
    arguments, read-only classes and properties, strict typing, or simply the last
    topic we covered in this chapter: protecting sensitive arguments from leaking
    into application logs and exception messages.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如我们所见，干净的代码是一种心态，在某种程度上是一种哲学，但语言本身的原生解决方案正在大量涌现，帮助我们尽可能好地应用它们。更好的是，这些引入PHP的新特性使我们能够看到一些我们最初可能没有想到的新可能性，以使我们的代码更加健壮、可维护和长期可行。只需想想命名参数、只读类和属性、严格类型，或者简单地回顾一下本章最后讨论的主题：保护敏感参数不会泄露到应用程序日志和异常消息中。
- en: Having said that, it’s time to get down to business. We’ll start by looking
    at tools that will give you a very quick, numerical overview of the quality of
    your code. Having metrics for this kind of thing allows you to see what improvements
    you’ll make to your code, or whether it’s actually time to act because quality
    is diminishing as you develop. So, let’s dive into the next chapter, which highlights
    code quality tools dedicated to the PHP language.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，现在是时候开始着手工作了。我们将从查看能够快速、定量地概述您代码质量的工具开始。这类指标的拥有使您能够看到您将如何改进代码，或者是否真的到了采取行动的时候，因为随着您的发展，质量正在下降。那么，让我们进入下一章，本章将重点介绍针对PHP语言的代码质量工具。
- en: Part 2 – Maintaining Code Quality
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 维护代码质量
- en: The aim of the second part is to enable you to constantly improve your projects
    and eventually maintain a consistently high level of code quality. It will provide
    you guidance on using state-of-the-art tools and technologies, which will help
    to reduce the necessary efforts to achieve this goal. Finally, we will present
    several best practices that will help you to work together with other developers
    on a clean and maintainable code base.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分的目标是让您能够不断改进您的项目，并最终保持代码质量的一致高水平。它将为您提供使用最先进工具和技术方面的指导，这将有助于减少实现这一目标所需的努力。最后，我们将介绍一些最佳实践，这将帮助您与其他开发者一起在干净且可维护的代码库上协作。
- en: 'This section comprises the following chapters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 7*](B19050_07.xhtml#_idTextAnchor084), *Code Quality Tools*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19050_07.xhtml#_idTextAnchor084), *代码质量工具*'
- en: '[*Chapter 8*](B19050_08.xhtml#_idTextAnchor100), *Code Quality Metrics*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19050_08.xhtml#_idTextAnchor100), *代码质量指标*'
- en: '[*Chapter 9*](B19050_09.xhtml#_idTextAnchor115), *Organizing PHP Quality Tools*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19050_09.xhtml#_idTextAnchor115), *组织PHP质量工具*'
- en: '[*Chapter 10*](B19050_10.xhtml#_idTextAnchor128), *Automated Testing*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19050_10.xhtml#_idTextAnchor128), *自动化测试*'
- en: '[*Chapter 11*](B19050_11.xhtml#_idTextAnchor145), *Continuous Integration*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19050_11.xhtml#_idTextAnchor145), *持续集成*'
- en: '[*Chapter 12*](B19050_12.xhtml#_idTextAnchor174), *Working in a Team*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19050_12.xhtml#_idTextAnchor174), *团队合作*'
- en: '[*Chapter 13*](B19050_13.xhtml#_idTextAnchor195), *Creating Effective Documentation*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19050_13.xhtml#_idTextAnchor195), *创建有效的文档*'
