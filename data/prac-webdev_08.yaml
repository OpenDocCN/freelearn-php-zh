- en: Chapter 8. Ajax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。Ajax
- en: To some, Ajax is the name of a Dutch soccer team out of Amsterdam. To web developers,
    Ajax (also **Asynchronous JavaScript And XML** (**AJAX**)) is the collective name
    for a number of web techniques used on the client side to asynchronously retrieve
    data from the server. I started this chapter with this heavily loaded sentence
    because I always like to explain an acronym when I use it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对一些人来说，Ajax 是阿姆斯特丹的一支荷兰足球队的名字。对网络开发者来说，Ajax（也称为 **异步 JavaScript 和 XML**（**AJAX**））是用于客户端以异步方式从服务器检索数据的一组网络技术的总称。我以这个负载很重的句子开始本章，因为我总是喜欢在用到缩写时解释它。
- en: The A (asynchronous) is almost always present, the J (JavaScript) is a sure
    thing, as we are talking client side, but the X (XML) is not mandatory. Usually
    **JSON** is used as the data format between client and server. We will discuss
    both XML and JSON in [Chapter 10](ch10.html "Chapter 10. XML and JSON"), *XML
    and JSON*. In our examples, we will use the already familiar HTML format instead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: A（异步）几乎总是存在的，J（JavaScript）是肯定的，因为我们谈论的是客户端，但 X（XML）不是强制的。通常 **JSON** 被用作客户端和服务器之间的数据格式。我们将在[第
    10 章](ch10.html "第 10 章。XML 和 JSON")，*XML 和 JSON*中讨论 XML 和 JSON。在我们的示例中，我们将使用已经熟悉的
    HTML 格式。
- en: Using these techniques, a website can be modified after data is retrieved in
    the background, and parts of the screen can be updated without having to load
    a brand new page. This way, our website will begin to behave more like a desktop
    application, so we can safely call it a web application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术，在数据在后台检索后，可以修改网站，并且可以更新屏幕的部分内容，而无需加载全新的页面。这样，我们的网站将开始更像是一个桌面应用程序，因此我们可以安全地称之为网络应用程序。
- en: Unless properly managed, Ajax has its drawbacks. As it is all implemented using
    JavaScript, the desired behavior will not occur if JavaScript is switched off.
    In 2015, this should not be a concern. There are other drawbacks, but not without
    solutions to address them. That we will do, without delay, in [Chapter 9](ch09.html
    "Chapter 9. The History API – Not Forgetting Where We Are"), *The History API–Not
    Forgetting Where We Are*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有得到妥善管理，Ajax 有其缺点。由于它全部使用 JavaScript 实现，如果关闭 JavaScript，则期望的行为将不会发生。在 2015
    年，这不应该是一个问题。还有其他缺点，但并非没有解决这些问题的方法。我们将立即在[第 9 章](ch09.html "第 9 章。历史 API – 不要忘记我们的位置")，*历史
    API – 不要忘记我们的位置*中解决这些问题。
- en: XMLHttpRequest
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMLHttpRequest
- en: The Ajax technologies rely on the **XMLHttpRequest** (**XHR**) object that can
    be used in JavaScript code. It is used to send HTTP or HTTPS requests to a web
    server and load the server response data back into the script. As is the case
    with many other web technologies, implementations of XMLHttpRequest differ in
    various browsers. Here, again, jQuery will come to the rescue. By using jQuery
    and the Ajax related methods it comes with, those incompatibilities do not have
    any cause for concern.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 技术依赖于可以在 JavaScript 代码中使用的 **XMLHttpRequest**（**XHR**）对象。它用于向网络服务器发送 HTTP
    或 HTTPS 请求，并将服务器响应数据加载回脚本中。与其他许多网络技术一样，各种浏览器中的 XMLHttpRequest 实现有所不同。在这里，jQuery
    将再次提供帮助。通过使用 jQuery 和它附带的相关 Ajax 方法，这些不兼容性不会引起任何担忧。
- en: Ajax and jQuery
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax 和 jQuery
- en: There are several methods that come with jQuery that you can use to make what
    we like to refer to as Ajax calls. The most complete one is, not surprisingly,
    called .`ajax()`. We will start with a simple one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了几个方法，您可以使用它们来执行我们喜欢称之为 Ajax 调用的操作。最完整的一个不出所料地被称为 .`ajax()`。我们将从一个简单的例子开始。
- en: Many Ajax-based sites are like that—an omnipresent menu on top, some other navigation
    in a footer at the bottom, and a center piece with constantly changing content.
    We cannot stress early enough that when we use Ajax the way we describe here,
    and our website is called `index.php`, no matter how often the content of the
    center piece changes, our current web page will still be `index.php`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于 Ajax 的网站都是这样的——顶部有一个无处不在的菜单，底部有一些其他导航，以及一个不断变化内容的中心部分。我们无法强调得更多，当我们以我们在这里描述的方式使用
    Ajax，并且我们的网站被命名为 `index.php` 时，无论中心部分的内容如何频繁变化，我们的当前网页仍然是 `index.php`。
- en: So, let's assume that we have a website with a main menu on top, and some basic
    content in the middle, inside a `<div>` with the id `varicontent`. It does not
    really matter what is inside `#varicontent` on the initial load—it is typically
    a nice photo banner—this is the chapter that explains what goes on when we change
    its content and replace it with something different.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设我们有一个网站，顶部有一个主菜单，中间有一些基本内容，在一个具有 id `varicontent` 的 `<div>` 中。在初始加载时，`#varicontent`
    里面的内容并不重要——通常是一个漂亮的图片横幅——这是解释当我们更改其内容并用不同内容替换它时会发生什么的章节。
- en: jQuery Ajax methods
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery Ajax 方法
- en: We will walk you through some of the most useful jQuery methods to use Ajax,
    from the very simple to more complex. Imagine a corporate website of a company
    that organizes seminars and exhibits. The home page, and all pages for that matter,
    as we never leave the page, contains a menu that visitors can use to navigate
    and select the topic of their choice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您介绍一些最有用的 jQuery 方法，用于使用 Ajax，从非常简单到更复杂。想象一下一家公司组织的研讨会和展览的官方网站。主页以及所有页面，因为我们从未离开过页面，都包含一个访客可以使用来导航和选择他们所选择主题的菜单。
- en: 'So, let''s show some code first - just a snippet to illustrate how it is done:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先展示一些代码——只是一个片段，以说明它是如何完成的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: $.load() method
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: $.load() 方法
- en: 'We will use the `load()` method to load not an entirely new page, but exactly
    the HTML we need in the section of the page where we want to replace the content:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `load()` 方法来加载的不是全新的页面，而是我们需要的精确 HTML，在页面中我们想要替换内容的部分：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the sample code just given, we address any menu items that we have given
    the class `htmla`. The intent is to replace the content of what is inside `#varicontent`
    with the HTML that is inside a file that resides on the server. Notice that there
    is a `href` attribute in the example as well. We intend not to use it, but it
    can be present if we want a fallback plan in case JavaScript is not supported.
    We will readdress that when we discuss **progressive enhancement**. In the example,
    we include a link to a file located in a folder called `oldsite`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚给出的示例代码中，我们处理了任何具有类 `htmla` 的菜单项。目的是用位于服务器上的文件中的 HTML 替换 `#varicontent` 内的内容。注意，示例中还有一个
    `href` 属性。我们打算不使用它，但如果需要 JavaScript 不受支持时的后备计划，它也可以存在。我们将在讨论 **渐进增强** 时再次提及这一点。在示例中，我们包括了一个指向位于
    `oldsite` 文件夹中的文件的链接。
- en: 'So, in the preceding code, we have an event handler for when an `<a>` tag with
    the class `htmla` is clicked. The first thing we do is to actually prevent users
    going to the link specified in the `href` tag that would cause a brand new page
    to be loaded. The following line takes care of that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面给出的代码中，我们有一个事件处理程序，用于当点击具有类 `htmla` 的 `<a>` 标签时。我们首先实际上阻止用户访问 `href` 标签中指定的链接，这会导致加载一个全新的页面。以下行处理了这一点：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead, we are going to use the jQuery Ajax method `.load()`. We use the value
    of the ID of the anchor to determine what the name of the file is, and then we
    call the function `updateHTMLcontent()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用 jQuery Ajax 方法 `.load()`。我们使用锚点的 ID 值来确定文件名，然后调用 `updateHTMLcontent()`
    函数。
- en: Inside that function, we call `load()`, which will make the necessary Ajax calls
    underneath to go and fetch the contents of the file. Then, we replace `#varicontent
    <div>` with that content. Now, that part of the screen is updated, but we remain
    on the same page, and the rest of the screen is left intact.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数内部，我们调用 `load()`，这将进行必要的 Ajax 调用来获取文件的内容。然后，我们将 `#varicontent <div>` 替换为那个内容。现在，屏幕的那部分已经更新，但我们仍然停留在同一个页面上，屏幕的其他部分保持不变。
- en: $.post()
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: $.post()
- en: In the previous example, all we needed to do was to load some HTML. What if
    we want to execute PHP code on the server to dynamically create HTML and want
    to insert that inside our page? This is where the `.ajax()` method fits in, and
    in particular, the two special cases of `.ajax()`, `.post()`, and `.get()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只需要加载一些 HTML。如果我们想在服务器上执行 PHP 代码以动态创建 HTML，并将其插入到我们的页面中，那么 `.ajax()`
    方法就派上用场了，特别是 `.ajax()` 的两个特殊情况：`.post()` 和 `.get()`。
- en: 'As you may have guessed, the difference is, just as with HTML forms, the way
    that values are passed along to the server - whether as POST variables or as GET
    variables. Let''s use the example of the second menu item, which contains an `<a>`
    tag of the class `agenda`. Like the previous example, we first prevent the browser
    from loading the file that is specified in the `href` attribute. This time, we
    grab the value of the ID of the parent:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜想的，区别在于，就像HTML表单一样，值传递给服务器的方式——是作为POST变量还是作为GET变量。让我们以第二个菜单项为例，它包含一个类为`agenda`的`<a>`标签。就像之前的例子一样，我们首先阻止浏览器加载`href`属性中指定的文件。这次，我们获取父元素的ID值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we are asking the server to go and find the PHP file `showagendalist.php`
    on the server and pass it some values as POST variables, or just one, as in our
    example. The PHP code will be executed on the server and whatever it generates,
    we can catch inside a function. We will use this to insert inside the appropriate
    part of our page using the convenient JavaScript method `replaceWith()`. The default
    format expected back is HTML, but we can also use other formats, such as JSON
    and XML, which we will discuss in [Chapter 10](ch10.html "Chapter 10. XML and
    JSON"), *XML and JSON*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要求服务器找到服务器上的PHP文件`showagendalist.php`，并传递一些POST变量，或者就像我们的例子中那样，只传递一个。PHP代码将在服务器上执行，无论它生成什么，我们都可以在函数中捕获它。我们将使用这个函数来使用方便的JavaScript方法`replaceWith()`将其插入到页面的适当部分。期望返回的默认格式是HTML，但我们也可以使用其他格式，例如JSON和XML，我们将在[第10章](ch10.html
    "第10章。XML和JSON")中讨论，*XML和JSON*。
- en: 'Here is an example of what this PHP code could be like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个这个PHP代码可能的样子：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding PHP code, we look at the value of the single POST variable
    `$POST['nav']` to determine which section of the agenda the visitor has selected
    from the menu. The name of that section has to somehow match a table in our database.
    Next, we pull out all articles from our database, assuming that there is a column
    for `title`, stored as text, and `summary` and `body` as HTML. We then generate
    the entire HTML for all the articles. The final statement is an `echo` statement
    of the entire HTML generated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的PHP代码中，我们查看单个POST变量`$POST['nav']`的值，以确定访问者从菜单中选择了日历的哪个部分。那个部分的名称必须以某种方式与我们的数据库中的表匹配。接下来，我们从数据库中提取所有文章，假设有一个存储为文本的`title`列，以及存储为HTML的`summary`和`body`列。然后我们生成所有文章的完整HTML。最后的语句是一个输出整个生成HTML的`echo`语句。
- en: 'This is a practical example to show how Ajax works, but not practical at all
    in a real-life application. There are two reasons why the content inside `#varicontent
    <div>` will quickly become too large: not only do we show the entire content of
    each article, we also show all of them.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实际示例，用来展示Ajax是如何工作的，但在实际应用中并不实用。有两个原因导致`#varicontent <div>`中的内容会迅速变得过大：不仅我们展示了每篇文章的全部内容，我们还展示了所有文章。
- en: Rather than show the entire content of each article, we should only show the
    title and the summary, not the body text. Inside our generated HTML, we can have
    an `<input>` of the type `hidden` to carry the ID of the article, and we then
    turn the title into an anchor tag so that it becomes clickable. The jQuery event
    handler behind this anchor will trigger another Ajax call, and our `#varicontent
    <div>` that contains a list of article titles and summaries will be replaced by
    the complete content of single article upon clicking. But, yet again, we remain
    on the same page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该展示每篇文章的全部内容，而只应展示标题和摘要，而不是正文。在我们的生成HTML中，我们可以有一个类型为`hidden`的`<input>`来携带文章的ID，然后我们将标题转换成锚点标签，使其可点击。这个锚点背后的jQuery事件处理器将触发另一个Ajax调用，点击后，包含文章标题和摘要列表的`#varicontent
    <div>`将被单个文章的完整内容所替换。但是，我们仍然停留在同一个页面上。
- en: Even doing this is not going to be sufficient. Once the number of articles becomes
    large, the length of our `#varicontent` section is going to become unpleasantly
    long. To overcome this, we need to apply some kind of pagination and only show
    a given number of articles at a time. We will discuss a framework that has a **pagination**
    widget in [Chapter 13](ch13.html "Chapter 13. Foundation – A Responsive CSS/JavaScript
    Framework"), *Foundation - A Responsive CSS/JavaScript Framework*. In the following
    sample code , we have already taken into account an extra parameter we need, `offset`.
    The updated code to accommodate these changes follows later. We left out the `switch`
    statement in the PHP code. The only difference in the existing JavaScript code
    is that now `UpdateAgendaContent()` will take an extra argument for the offset.
    We only include the extra bits for the additional Ajax call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样做也不够。一旦文章的数量变得很大，我们的`#varicontent`部分的长度将变得令人不快。为了克服这一点，我们需要应用某种分页，并且一次只显示一定数量的文章。我们将在[第13章](ch13.html
    "第13章。基础 - 一个响应式CSS/JavaScript框架")中讨论一个具有**分页**小部件的框架，*Foundation - 一个响应式CSS/JavaScript框架*。在下面的示例代码中，我们已经考虑到了我们需要的一个额外参数，`offset`。稍后我们将提供适应这些变化的更新代码。我们在PHP代码中省略了`switch`语句。现有的JavaScript代码的唯一区别是现在`UpdateAgendaContent()`将接受一个额外的`offset`参数。我们只为额外的Ajax调用包括了额外的部分。
- en: 'The updated PHP is this snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的PHP代码如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Additional JavaScript code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的JavaScript代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we have now added an event handler inside the `updateAgendaContent()`
    function to trigger the right things happening when a visitor clicks on an article
    title. This is often necessary as, like in our example of the HTML tag, we want
    to trigger the event that did not exist on the page prior to the Ajax call.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在在`updateAgendaContent()`函数内部添加了一个事件处理器，以在访问者点击文章标题时触发正确的事情。这通常是必要的，就像在我们的HTML标签示例中，我们想要触发在Ajax调用之前页面上不存在的事件。
- en: $.ajax()
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: $.ajax()
- en: As we mentioned, the `$.post()` method (and there is a `$.get()` as well) is
    a special case of the `$.ajax()` method. The ones we used take fewer arguments
    than `.ajax()`, as some of them are predefined (not surprisingly, POST or GET),
    so, once again, jQuery makes things easier for us to write. To conclude this chapter,
    we will give you a summary on how the `.ajax()` methods can be used. Please check
    the full jQuery documentation for more details. It will be worth reading.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，`$.post()`方法（以及还有一个`$.get()`方法）是`$.ajax()`方法的一个特例。我们使用的参数比`.ajax()`少，因为其中一些是预定义的（不出所料，是POST或GET），所以，jQuery再次使我们更容易编写代码。为了总结这一章，我们将给出`.ajax()`方法的使用总结。请查阅完整的jQuery文档以获取更多详细信息。这将值得一读。
- en: 'The overall syntax is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These parameters specify one or more name/value pairs. Here is an overview
    of the most commonly used parameters and their meanings:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数指定一个或多个名称/值对。以下是常用参数及其含义的概述：
- en: '**data**: This is data to be sent to the server. It is converted to a query
    string, if it is not already a string. It can be passed as an object, a string,
    or an array.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**data**: 这是发送到服务器的数据。如果它不是一个字符串，它将被转换成一个查询字符串。它可以作为一个对象、一个字符串或一个数组传递。'
- en: '**dataType**: This is the data type expected of the server response. It can
    be XML, HTML, text, JSON, or script. In our examples, we assumed HTML.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dataType**: 这是服务器响应所期望的数据类型。它可以是以XML、HTML、文本、JSON或脚本。在我们的示例中，我们假设是HTML。'
- en: '**url**: This specifies the URL to send the request to. The default is the
    current page.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**: 这指定了发送请求的URL。默认是当前页面。'
- en: '**error(xhr,status,error)**: This is a function to be run if the request fails.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error(xhr,status,error)**: 这是一个在请求失败时运行的函数。'
- en: '**success(result,status,xhr)**: This is a function to be run when the request
    succeeds.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**success(result,status,xhr)**: 这是一个在请求成功时运行的函数。'
- en: '**type**: This specifies the type of request (GET or POST).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**: 这指定了请求的类型（GET或POST）。'
- en: 'So, the `$.post()` call in our last example is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最后示例中的`$.post()`调用是：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It could also have been written as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以写成：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Summary
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced Ajax, a collection of web techniques to asynchronously
    collect data from the server. It is used to update only parts of the screen on
    websites and web applications, rather than loading an entirely new page each time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了Ajax，这是一组用于异步从服务器收集数据的网络技术。它用于更新网站和Web应用程序上的屏幕的特定部分，而不是每次都加载一个全新的页面。
- en: Ajax techniques are based on the XMLHttpRequest object, but thanks to jQuery
    and its `$.ajax()` methods, you learned how to use Ajax in your applications without
    having to know anything about that object. We used the `$.load` and `$.post` methods
    in our examples to replace parts of our screen with HTML that is either stored
    or generated on the server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 技术基于 XMLHttpRequest 对象，但多亏了 jQuery 和其 `$.ajax()` 方法，你学会了如何在你的应用程序中使用 Ajax，而无需了解该对象。我们在示例中使用了
    `$.load` 和 `$.post` 方法来用存储在服务器上或由服务器生成的 HTML 替换屏幕的部分。
- en: Ajax can be used with other data formats, such as XML and JSON. It also has
    potential drawbacks, because now that we constantly update the page without actually
    leaving it, it will be perceived as different pages by the visitor of our site,
    particularly when they press the browser's back button.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 可以与其他数据格式一起使用，例如 XML 和 JSON。但它也存在潜在缺点，因为现在我们不断更新页面而不实际离开它，这会让访问我们网站的访客将其感知为不同的页面，尤其是在他们按下浏览器的后退按钮时。
- en: 'These two topics: making the back key do what is expected of it, and using
    different data formats between the client and server are the subject matter of
    our next two chapters.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主题：使返回键执行预期的功能，以及在客户端和服务器之间使用不同的数据格式，是我们接下来两章的主题内容。
