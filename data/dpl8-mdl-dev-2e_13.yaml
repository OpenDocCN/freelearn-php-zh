- en: Internationalization and Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和语言
- en: 'Even though there have been great advancements across the board, Drupal 8 has
    a couple of almost revolutionary developments compared to its predecessor. Notable
    among these are the configuration API and the caching system, which are both lightyears
    ahead of what was capable in Drupal 7\. Another one is the multilingual initiative
    that sought to make Drupal fully multilingual out of the box, rather than having
    to use 20 contributed modules to achieve results that don''t even come close.
    This also includes the internationalization (i18n: [https://www.w3.org/standards/webdesign/i18n](https://www.w3.org/standards/webdesign/i18n))
    aspect that allows sites to be translated into any of the installed languages.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在各方面都取得了巨大进步，但与前辈相比，Drupal 8有几项几乎是革命性的发展。其中最值得注意的是配置API和缓存系统，它们在Drupal 7中已经遥遥领先。另一个是旨在使Drupal完全多语言化的多语言倡议，而不是需要使用20个贡献模块才能达到类似的效果。这还包括国际化（i18n：[https://www.w3.org/standards/webdesign/i18n](https://www.w3.org/standards/webdesign/i18n)）方面，它允许网站翻译成任何已安装的语言。
- en: In this chapter, we are going to talk about internationalization and multilingual
    features in Drupal 8 from the point of view of a module developer. Many of the
    built-in capabilities of this system are oriented toward site builders—enabling
    languages, translating content and configuration entities, as well as the Drupal
    interface (for administrators and visitors alike). Our focus will be what we as
    module developers need to do programmatically to ensure that site builders and
    editors can use the aforementioned features. To that end, this chapter will be
    more of a reference guide with various tips, techniques, and even rules we need
    to follow when writing our code. Notwithstanding, we will also talk a bit about
    how we can work with languages programmatically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从模块开发者的角度讨论Drupal 8中的国际化和多语言功能。该系统的许多内置功能都是针对网站构建者的——启用语言、翻译内容和配置实体，以及Drupal界面（适用于管理员和访客）。我们的重点将是我们作为模块开发者需要做什么来确保网站构建者和编辑者可以使用上述功能。为此，本章将更多地作为参考指南，包含各种提示、技巧，甚至我们在编写代码时需要遵循的规则。尽管如此，我们也会简要谈谈我们如何以编程方式与语言一起工作。
- en: First, however, we will start with an introduction to the multilingual ecosystem
    that comes out of the box and the modules responsible for various parts of it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先，我们将从开箱即用的多语言生态系统及其负责各个部分的模块的介绍开始。
- en: Introduction to the multilingual ecosystem
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言生态系统的介绍
- en: 'The multilingual and internationalization system is based on four Drupal core
    modules. Let''s quickly go through them and see what they do:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言和国际化系统基于四个Drupal核心模块。让我们快速浏览一下它们，看看它们的作用：
- en: Language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言
- en: Content translation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容翻译
- en: Configuration translation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置翻译
- en: Interface translation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面翻译
- en: Language
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言
- en: 'The *Language* module is responsible for dealing with the available languages
    on the site. Site builders can choose to install one or more languages from a
    wide selection. They can even create their own custom language if necessary. The
    installed languages can then be added to things such as entities and menu links
    in order to control their visibility, depending on the current language. Apart
    from the installed ones, Drupal 8 comes with two extra special languages as well:
    *Not Specified* and *Not Applicable*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*语言*模块负责处理网站上的可用语言。网站构建者可以从广泛的选项中选择安装一种或多种语言。如果需要，他们甚至可以创建自己的自定义语言。安装的语言可以添加到实体和菜单链接等项目中，以便根据当前语言控制它们的可见性。除了已安装的语言外，Drupal
    8还附带两种额外的特殊语言：*未指定*和*不适用*。'
- en: 'The module also handles the contextual language selection based on various
    criteria, as well as provides a language switcher to change the current language
    of the site:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还根据各种标准处理上下文语言选择，并提供语言切换器以更改网站的当前语言：
- en: '![](img/15d12bfe-952a-4c61-9de8-b23d469a41c8.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15d12bfe-952a-4c61-9de8-b23d469a41c8.png)'
- en: Content translation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容翻译
- en: 'The *Content* t*ranslation* module is responsible for the functionality that
    allows users to translate content. Content entities are the principal vehicle
    for content, and with this module, the data inside can be translated (and granularly
    configured for it at field level). In other words, users can control which fields
    and which entity type bundles should be translatable:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容*翻译模块负责实现用户翻译内容的功能。内容实体是内容的主要载体，并且通过此模块，数据可以在字段级别进行翻译（并对其进行细粒度配置）。换句话说，用户可以控制哪些字段和哪些实体类型包应该可翻译：'
- en: '![](img/82a51594-f8fa-4c65-a3ff-1f2bcec4ce72.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82a51594-f8fa-4c65-a3ff-1f2bcec4ce72.png)'
- en: Configuration translation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置翻译
- en: The *Configuration* t*ranslation* module is responsible for providing the interface
    via which users can translate configuration values. These can be from simple configuration
    objects or configuration entities. We've already seen how we can ensure that our
    configuration values can be translated in previous chapters, so we won't dive
    into that again here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置*翻译模块负责通过接口提供用户翻译配置值的功能。这些可以是简单的配置对象或配置实体。我们已经在之前的章节中看到如何确保我们的配置值可以被翻译，所以在这里我们不再深入探讨。'
- en: I recommend you reference the section on configuration schemas from [Chapter
    6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and Storage:*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您参考第6章中关于配置架构的部分，*数据建模和存储*：
- en: '![](img/cbf6c83c-e965-4246-9a3c-7a17a70e8ad9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbf6c83c-e965-4246-9a3c-7a17a70e8ad9.png)'
- en: Interface translation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口翻译
- en: 'The *Interface translation* module is responsible for providing an interface
    that allows users to translate any string or text output on the website, in all
    the languages that are installed. Moreover, it provides a connection to the [localize.drupal.org](https://localize.drupal.org/)
    platform from which it can download translations for many languages of the more
    common interface strings that come with Drupal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口翻译*模块负责提供一个界面，允许用户将网站上安装的所有语言中的任何字符串或文本输出进行翻译。此外，它提供了一个连接到[localize.drupal.org](https://localize.drupal.org/)平台，从中可以下载许多常见接口字符串的翻译：'
- en: '![](img/6350111a-129b-46dd-9ad4-3bfc94e9961b.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6350111a-129b-46dd-9ad4-3bfc94e9961b.png)'
- en: These four modules are not alone in the multilingual system but rely on a cross-application
    standard of ensuring that all the written code works well with it. In other words,
    the entire Drupal code base is intertwined with the multilingual system at various
    levels, and is written in such a way that anything that should be translatable
    or localizable can be. This means that all the code we write needs to respect
    the same standard.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个模块并不是在多语言系统中独立存在的，而是依赖于一个跨应用标准，以确保所有编写的代码都能很好地与之协同工作。换句话说，整个Drupal代码库在多个层面上与国际化系统交织在一起，并且以这种方式编写，即任何应该可翻译或可本地化的内容都可以。这意味着我们编写的所有代码都需要遵守相同的标准。
- en: Internationalization
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: The idea behind internationalization is to ensure that everything that gets
    output on the site can be translated into the enabled languages through a common
    mechanism—in this case, using the Interface translation module. This refers to
    content, visible configuration values, and the strings and texts that come out
    of modules and themes. But there are many different ways this can happen, so let's
    see how in each of these cases we would ensure that our information can be translated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化的理念是确保网站上输出的所有内容都可以通过一个共同的机制翻译成已启用的语言——在这种情况下，使用接口翻译模块。这指的是内容、可见的配置值以及来自模块和主题的字符串和文本。但是，这可以通过许多不同的方式实现，所以让我们看看在每个这些情况下我们如何确保我们的信息可以被翻译。
- en: A principal *rule* when writing Drupal modules or themes is to always use English
    as the code language. This is to ensure consistency and keep open the possibility
    that other developers will work on the same code base, who may not speak a particular
    language. This is also the case for text used to be displayed in the UI. It should
    not be the responsibility of the code to output the translated text, but rather
    to always keep it consistent, that is, in English.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Drupal模块或主题时，一个主要的*规则*是始终使用英语作为代码语言。这是为了确保一致性，并保持其他开发者可能不会说特定语言的情况下，其他开发者可以在此代码库上工作的可能性。这也适用于用于在UI中显示的文本。代码输出翻译文本的责任不应落在代码上，而应始终保持一致性，即使用英语。
- en: Of course, this is dependent on it being done right, in order to allow it to
    be translated via interface translation. There are multiple ways this can be ensured,
    depending on the circumstances.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这取决于正确执行，以便允许通过界面翻译进行翻译。根据具体情况，有多种方式可以确保这一点。
- en: 'The most common scenario we need to be aware of is when we have to print out
    to the user a PHP string of text. Drupal 7 developers should already be familiar
    with the `t()` function through which these strings are run. This function still
    exists and should be used whenever we are not inside a class context:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要特别注意的最常见情况是我们必须向用户打印出一段 PHP 文本字符串。Drupal 7 开发者应该已经通过 `t()` 函数熟悉了这些字符串的处理方式。这个函数仍然存在，并且在我们不在类上下文内部时应该使用它：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, when we are inside a class, we should check whether any of the parents
    are using the `StringTranslationTrait`. If not, we should use it in our class
    and then we''ll be able to do this instead:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们处于类内部时，我们应该检查是否有任何父类使用了 `StringTranslationTrait`。如果没有，我们应该在我们的类中使用它，然后我们就能这样做：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even better still, we should inject the `TranslationManager` service into our
    class because the abovementioned trait makes use of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们应该将 `TranslationManager` 服务注入到我们的类中，因为上述特性正是使用了它。
- en: None of the examples given before should be new to us as we've been using these
    throughout the code we've been writing in this book. But what actually happens
    behind the scenes?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前给出的所有示例对我们来说都不应该陌生，因为我们一直在本书编写的代码中使用这些示例。但是，幕后实际上发生了什么？
- en: 'The `t()` and `StringTranslationTrait::t()` functions both create and return
    an instance of `TranslatableMarkup` (essentially delegating to its constructor),
    which, upon rendering (being cast to a string), will return the formatted and
    translated string. The responsibility of the actual translation is delegated to
    the `TranslationManager` service. This process has two parts. Static analyzers
    pick up on these text strings and add them to the database in the list of strings
    that need to be localized. These can then be translated by users via the user
    interface. Second, at runtime, the strings get formatted and the translated version
    is shown, depending on the current language context. And because of the first
    part, we should never do something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`t()` 和 `StringTranslationTrait::t()` 函数都会创建并返回一个 `TranslatableMarkup` 实例（本质上是将职责委托给其构造函数），在渲染（被转换为字符串）时，将返回格式化和翻译后的字符串。实际的翻译责任被委托给
    `TranslationManager` 服务。这个过程分为两个部分。静态分析器会检测这些文本字符串并将它们添加到数据库中，作为需要本地化的字符串列表。然后，用户可以通过用户界面进行翻译。其次，在运行时，根据当前的语言上下文，字符串会被格式化，并显示翻译后的版本。由于第一部分，我们永远不应该这样做：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason is that static analyzers can no longer pick up on the strings that
    need to be translated. Moreover, if the text is coming from user input, it can
    lead to XSS attacks if not properly sanitized before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于静态分析器无法再检测到需要翻译的字符串。此外，如果文本来自用户输入，在输出到用户之前如果没有得到适当的清理，可能会导致 XSS 攻击。
- en: 'That being said, we can still have dynamic, that is, formatted, text output
    using this method, and we''ve seen this in action as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们仍然可以使用这种方法来输出动态的、即格式化的文本，我们已经在实际操作中看到了这一点：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we have a dynamic variable that will be used to replace the `@count` placeholder from
    the text. Drupal takes care of sanitizing the variable before outputting the string
    to the user. Alternatively, we can also use the `%` prefix to define a placeholder
    we want Drupal to wrap with `<em class="placeholder">`. The cool thing is that,
    when performing translations, users can shift the placeholder in the sentence
    to accommodate language specificity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个动态变量，它将被用来替换文本中的 `@count` 占位符。Drupal 会负责在输出字符串到用户之前清理这个变量。或者，我们也可以使用
    `%` 前缀来定义一个 Drupal 应该用 `<em class="placeholder">` 包裹的占位符。酷的地方在于，在进行翻译时，用户可以根据语言特定性调整句子中的占位符。
- en: One of the intended consequences of the static analyzer picking out and storing
    the strings that need to be translated is that, by default, each individual string
    is only translated once. This is good in many cases but also poses some problems
    when the same English string has different meanings (which map to different translations
    in other languages). To counter this issue, we can specify a context to the string
    that needs to be translated so that we can identify which meaning we actually
    want to translate. This is where the third parameter of the `t()` function (and
    method) we saw in the previous paragraphs comes into play.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器挑选并存储需要翻译的字符串的一个预期后果是，默认情况下，每个单独的字符串只翻译一次。这在许多情况下是好的，但也可能在同一英语字符串具有不同含义（映射到其他语言中的不同翻译）时带来一些问题。为了解决这个问题，我们可以为需要翻译的字符串指定一个上下文，以便我们可以识别我们实际上想要翻译的含义。这就是我们在前几段中看到的`t()`函数（和方法）的第三个参数发挥作用的地方。
- en: 'For example, let''s consider the word *Book*, which is translated by default
    in its meaning as a noun. But we may have a submit button on a form that has the
    value Book, which clearly has a different meaning as a call to action. So in the
    latter case, we could do it like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑单词*Book*，它默认以其名词的含义进行翻译。但我们在表单上可能有一个值为Book的提交按钮，这显然有不同作为行动呼吁的含义。所以在后一种情况下，我们可以这样做：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now in the interface translation, we will have both versions available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在界面翻译中，我们将有这两个版本可供选择：
- en: '![](img/4866bc01-cbc0-4e73-9d13-b911464bfa20.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4866bc01-cbc0-4e73-9d13-b911464bfa20.png)'
- en: 'Another helpful tip is that we can also account for plurals in the string translations.
    The `StringTranslationTrait::formatPlural()` method helps with this by creating
    a `PluralTranslatableMarkup` object similar to `TranslatableMarkup`, but with
    some extra parameters to account for differences when it comes to plurals. This
    comes in very handy in our previous example with the brown fox jumping a number
    of times, because if the fox jumps only once, the resulting string would no longer
    be grammatically correct. So instead, we can do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的提示是，我们还可以在字符串翻译中考虑复数。`StringTranslationTrait::formatPlural()`方法通过创建一个类似于`TranslatableMarkup`的`PluralTranslatableMarkup`对象来帮助解决这个问题，但它有一些额外的参数来处理复数时的差异。这在我们的前一个例子中非常有用，关于棕色狐狸跳了几次，因为如果狐狸只跳了一次，结果字符串将不再语法正确。所以，我们可以这样做：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter is the actual count (the differentiator between singular
    and plural). The second and third parameters are the singular and plural versions,
    respectively. You'll also notice that since we specified the count already, we
    don't have to specify it again in the arguments array. It's important to note
    that the placeholder name inside the string needs to be `@count` if we want the
    renderer to understand its purpose.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是实际计数（区分单数和复数的区别）。第二个和第三个参数分别是单数和复数形式。你也会注意到，由于我们已经指定了计数，所以我们不需要在参数数组中再次指定它。需要注意的是，如果想让渲染器理解其目的，字符串内部的占位符名称需要是`@count`。
- en: 'The string translation techniques we discussed so far also work in other places—not
    just in PHP code. For example, in JavaScript we would do something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的字符串翻译技术也适用于其他地方——不仅仅是PHP代码。例如，在JavaScript中，我们会这样做：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, based on this knowledge, I encourage you to go back and fix our incorrect
    use of the string output in JavaScript in the previous chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这些知识，我鼓励你回去修复上一章中JavaScript字符串输出的错误使用。
- en: 'In Twig, we''d have something like this (for simple translations):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twig中，我们会有类似这样的内容（用于简单翻译）：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both of the above lines do the same thing. To handle plurals (and placeholders),
    we can use the `{% trans %}` block:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两行做的是同样的事情。为了处理复数（和占位符），我们可以使用`{% trans %}`块：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, the string context is also possible like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，字符串上下文也是可能的，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In annotations, we have the `@Translation()` wrapper, as we've seen already
    a few times when creating plugins or defining entity types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在注解中，我们有`@Translation()`包装器，就像我们在创建插件或定义实体类型时已经看到几次那样。
- en: 'Finally, in YAML files, some of the strings are translatable by default (so
    we don''t have to do anything):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在YAML文件中，一些字符串默认可翻译（因此我们不需要做任何事情）：
- en: Module names and descriptions in `.info.yml` files
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`.info.yml`文件中的模块名称和描述。
- en: The `_title` (together with the optional `_title_context`) key values under
    the defaults section of `.routing.yml` files
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`.routing.yml`文件的默认部分下，`_title`（以及可选的`_title_context`）键值。
- en: The `title` (together with the optional `title_context`) key values in `.links.action.yml`,
    `.links.task.yml` and `.links.contextual.yml` files
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.links.action.yml`、`.links.task.yml` 和 `.links.contextual.yml` 文件中 `title`（连同可选的
    `title_context`）键值'
- en: 'Dates are also potentially problematic when it comes to localization, as different
    locales show dates differently. Luckily, Drupal provides the `DateFormatter` service,
    which handles this for us. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 日期在本地化方面也可能存在潜在问题，因为不同的地区显示日期的方式不同。幸运的是，Drupal提供了 `DateFormatter` 服务，它为我们处理这个问题。例如：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first parameter of this formatter is the UNIX timestamp of the date we want
    to format. The second parameter indicates the format to use (either one of the
    existing formats or `custom`). Drupal comes with a few predefined date formats,
    but site builders can define others as well as, which can be used here. However,
    if the format is custom, the third parameter is a a PHP date format string suitable
    for input to `date()`. The fourth parameter is a time zone identifier we want
    to format the date in, and the final parameter can be used to specify the language
    to localize to directly (regardless of the current language of the site).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式化器的第一个参数是我们想要格式化的日期的UNIX时间戳。第二个参数表示要使用的格式（现有格式之一或 `custom`）。Drupal自带一些预定义的日期格式，但网站构建者也可以定义其他格式，这些格式也可以在这里使用。然而，如果格式是自定义的，第三个参数是一个适合输入到
    `date()` 的PHP日期格式字符串。第四个参数是我们想要格式化日期的时间区域标识符，最后一个参数可以用来直接指定要本地化的语言（无论网站的当前语言是什么）。
- en: Content entities and the Translation API
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容实体和翻译API
- en: So far in this chapter, we've mostly talked about how to ensure that our modules
    output only text that can also be translated. The Drupal best practice is to always
    use these techniques regardless of whether the site is multilingual. You never
    know if you'll ever need to add a new language.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们主要讨论了如何确保我们的模块只输出可以翻译的文本。Drupal的最佳实践是无论网站是否是多语言的，都要始终使用这些技术。你永远不知道你是否需要添加新语言。
- en: In this section, we are going to talk a bit about how we can interact with the
    language system programmatically and work with entity translations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论如何以编程方式与语言系统交互并处理实体翻译。
- en: 'A potentially important thing you''ll often want to do is check the current
    language of the site. Depending on the language negotiation in place, this can
    either be determined by the browser language, a domain, a URL prefix, or others.
    The `LanguageManager` is the service we use to figure this out. We can inject
    it using the `language_manager` key or use it via the static shorthand:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会想要做的一件重要的事情是检查网站的当前语言。根据现有的语言协商，这可以由浏览器语言、域名、URL前缀或其他因素确定。`LanguageManager`
    是我们用来确定这个的服务。我们可以使用 `language_manager` 键注入它或通过静态简写使用它：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To get the current language, we do this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前语言，我们这样做：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Where `$language` is an instance of the `Language` class that holds some information
    about the given language (such as the language code and name). The language code
    is probably the most important as it is used everywhere to indicate what language
    a given *thing* is.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `$language` 是 `Language` 类的一个实例，它包含有关给定语言的一些信息（例如语言代码和名称）。语言代码可能是最重要的，因为它在各个地方都用来指示某个*事物*的语言。
- en: There are other useful methods with this service that you can use. For example,
    we can get a list of all the installed languages with `getLanguages()` or the
    site default language with `getDefaultLanguage()`. I encourage you to check out
    the `LanguageManager` for all the available API methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务还有其他有用的方法可供使用。例如，我们可以使用 `getLanguages()` 获取所有已安装的语言列表，或使用 `getDefaultLanguage()`
    获取网站默认语言。我鼓励您查看 `LanguageManager` 以获取所有可用的API方法。
- en: 'When it comes to content entities, there is an API we can use to interact with
    the data inside them in different languages. So, for example, we have figured
    out the current language with the previous method, so we can now get some field
    values in that language. The way this works is that we ask for a *copy* of the
    entity in the respective language:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到内容实体时，我们可以使用一个API来以不同的语言与之交互其内部的数据。例如，我们已通过之前的方法确定了当前语言，因此现在我们可以获取该语言下的一些字段值。这种方式的工作原理是，我们请求相应语言的实体*副本*：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`$translation` is now almost the same as `$node`, but with the default language
    set to the one we requested. From there, we can access field values normally.
    However, not all nodes have to have a translation, so it''s better to first check
    whether one exists:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`$translation`现在几乎与`$node`相同，但默认语言设置为请求的语言。从那里，我们可以正常访问字段值。然而，并非所有节点都必须有翻译，因此最好首先检查是否存在：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we can configure entity translatability at the field level (allowing
    only the fields that make sense to be translated), we can also check which of
    these fields can have translated values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在字段级别配置实体的可翻译性（只允许翻译有意义的字段），我们还可以检查哪些字段可以具有翻译值：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can also check which languages there are translations for:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以检查哪些语言有翻译：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since it's up to the editors to add translations to an entity, we cannot guarantee
    in code that one exists.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加翻译的责任在于编辑者，所以我们无法在代码中保证其存在。
- en: 'Programmatically, we can also create a translation to an entity really easily.
    For example, let''s imagine we want to translate a Node entity and specify its
    title to be in French:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序上，我们也可以非常容易地创建一个实体的翻译。例如，让我们想象我们想要翻译一个节点实体，并指定其标题为法语：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second parameter is an array of values that needs to map to the entity fields
    just like when creating a new entity. Now the respective node has the original
    language (let's say EN) but also a French translation. It should be noted that
    the values of all the other fields apart from the title, even in the French translation,
    remain in the original language because we did not pass any translated values
    when creating the translation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个数组，需要将其映射到实体字段，就像创建新实体时一样。现在相应的节点具有原始语言（比如说EN），但也有一份法语翻译。应注意的是，除了标题之外的所有其他字段的值，即使在法语翻译中，也保持原始语言，因为我们没有在创建翻译时传递任何翻译值。
- en: 'And just as we add a translation, we can also remove one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们添加翻译一样，我们也可以删除一个：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to persist the addition or removal of a translation, we need to
    save the entity like we are used to. Otherwise, it''s stored only in memory. And
    with Drupal 8.3, content entities implement the `Drupal\Core\TypedData\TranslationStatusInterface`
    which allows us to inspect the status of the translations. So for example, we
    can do this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要持久化添加或删除翻译，我们需要像往常一样保存实体。否则，它只存储在内存中。并且从Drupal 8.3开始，内容实体实现了`Drupal\Core\TypedData\TranslationStatusInterface`，这允许我们检查翻译的状态。例如，我们可以这样做：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Where `$status` is the value of one of three constants from the `TranslationStatusInterface`
    class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`$status`是`TranslationStatusInterface`类中三个常量之一的值：
- en: '`TRANSLATION_REMOVED`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSLATION_REMOVED`'
- en: '`TRANSLATION_EXISTING`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSLATION_EXISTING`'
- en: '`TRANSLATION_CREATED`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSLATION_CREATED`'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this short chapter, we talked about the Drupal 8 multilingual and internationalization
    system from a module developer perspective. We started with an introduction to
    the four main modules responsible for languages and translating content, configuration
    entities as well as interface text.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一简短的章节中，我们从模块开发者的角度讨论了Drupal 8的多语言和国际化系统。我们从一个介绍开始，介绍了负责语言和内容翻译、配置实体以及界面文本的四个主要模块。
- en: Then, we focused on the rules and techniques we need to respect in order to
    ensure that our output text can be translated. We saw how we can do this in PHP
    code, Twig, and YAML files, and even in JavaScript. Finally, we looked a bit at
    the language manager and Translation API to see how we can work with content entities
    that have been translated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们关注了我们需要遵守的规则和技术，以确保我们的输出文本可以被翻译。我们看到了如何在PHP代码、Twig和YAML文件中以及JavaScript中实现这一点，最后我们还简要地看了看语言管理器和翻译API，看看我们如何与已翻译的内容实体一起工作。
- en: The main takeaway from this chapter should be that languages are important in
    Drupal 8 even if our site is only in one language. So, in developing modules,
    especially if we want to contribute them back to the community, we need to ensure
    that our functionality can be translated as needed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要收获应该是，即使在我们的网站只使用一种语言的情况下，语言在Drupal 8中也很重要。因此，在开发模块时，尤其是如果我们想将其贡献给社区，我们需要确保我们的功能可以根据需要被翻译。
- en: In the next chapter, we are going to talk about data processing using batches
    and queues, as well as the cron system that comes with Drupal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用批处理和队列进行数据处理，以及随Drupal一起提供的cron系统。
