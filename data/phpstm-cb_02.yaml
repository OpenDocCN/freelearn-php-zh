- en: Chapter 2. PHP Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 PHP 开发
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a PHP project using Composer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Composer 创建 PHP 项目
- en: Creating an empty project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空项目
- en: Reusing an existing project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用现有项目
- en: Creating a new PHP class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 PHP 类
- en: Creating a new PHP method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 PHP 方法
- en: Adding the getter/setter methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 getter/setter 方法
- en: Creating delegate methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代理方法
- en: Surrounding code with control structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制结构包围代码
- en: Finding the matching brace
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找匹配的大括号
- en: Commenting out a section of code and PHPDoc
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释代码段和 PHPDoc
- en: Creating a working set
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建工作集
- en: Creating TODO tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TODO 任务
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Now that you have your headlights turned on, you can have that "come what may"
    attitude and set out to drive your favorite car—PHP. Go ahead and give it your
    best shot now that you have your beloved tool ready—PhpStorm. PhpStorm will take
    care of eliminating the distractions from your life and will let you concentrate
    on programming.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经打开了前灯，你可以采取“无论发生什么”的态度，开始驾驶你最喜欢的汽车——PHP。现在你已经准备好了你心爱的工具——PhpStorm，就放手一搏吧。PhpStorm
    将会负责消除你生活中的干扰，让你能够专注于编程。
- en: You can think of any aspect in solving a problem using PHP, and PhpStorm will
    be there to assist you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 PHP 解决问题的任何方面来思考，PhpStorm 都会在那里帮助你。
- en: Do you have an imminent problem to solve, some problem that appears daunting
    to you, or some problem that has challenged your existence as a software engineer?
    If you stick to the software engineering principles, PhpStorm will leverage your
    capacity and let you do wonders while solving the problems at hand. PhpStorm lets
    you focus on designing your business logic by offloading you from the worries
    of remembering the finer details, such as the exact method signature and the list
    of parameters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否面临着一个即将解决的问题，一个让你感到棘手的问题，或者一个挑战你作为软件工程师存在感的问题？如果你坚持软件工程原则，PhpStorm 将会发挥你的能力，让你在解决当前问题时创造奇迹。PhpStorm
    让你能够专注于设计业务逻辑，因为它会帮你分担记住细节的烦恼，比如确切的方法签名和参数列表。
- en: Imagine that you have been called by your manager to discuss some new feature
    for the business that has to be developed in, as usual, no time at all. You are
    again in a fix. That decision to choose between the devil and the deep blue sea
    again looms large.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的经理叫你去讨论一些必须尽快开发的新业务功能。你又陷入了困境。再次面临选择魔鬼还是深海的抉择。
- en: PhpStorm users need not worry. They have a third option—to board a helicopter
    and reach their destination from the current scenario.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 用户无需担心。他们有一个第三选择——乘坐直升机从当前场景中到达目的地。
- en: You were brave enough to gather the requirements from the business end. Which
    way do you chose now? Decide whether you want to go right or left. If you go to
    the right, you will take the route to create a new project. If you go to the left,
    you will take the route to reuse an existing project and make modifications in
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经足够勇敢，从业务端收集了需求。现在你选择哪条路？决定你是想向右走还是向左走。如果你向右走，你将选择创建新项目的路线。如果你向左走，你将选择重用现有项目并对其进行修改的路线。
- en: Wherever you go and whichever road you take, you have to reach the same destination.
    In the end, you have to report to your manager what you did to achieve the target.
    Not only do you have to decide quickly, but you also have to act swiftly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你走到哪里，无论你选择哪条路，你都必须达到同一个目的地。最后，你必须向你的经理汇报你为了实现目标所做的一切。你不仅必须快速决定，还必须迅速行动。
- en: Creating a PHP project using Composer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Composer 创建 PHP 项目
- en: Welcome to those who have taken the route to the right! Fasten your seatbelts,
    and get ready to create a new project in PHP.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎那些走上正确道路的人！系好安全带，准备好在 PHP 中创建一个新的项目。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Creating a new project in itself is a very mature decision, so you should always
    decide maturely and strategically. There might be situations in which, out of
    sheer enthusiasm, you opted to create a new project, and within a few days, you
    realize that much of the functionality you are planning to create has already
    been developed. You will end up doing a lot of copy-pasting work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目本身是一个非常成熟的决定，所以你应该始终成熟和战略性地做出决定。可能会有这样的情况，出于纯粹的激情，你选择了创建一个新项目，但几天后，你意识到你计划创建的大部分功能已经被开发出来了。你最终会做很多复制粘贴的工作。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The principles of software engineering always teach students that a design should
    be high on coupling and low on cohesion. This means that an application program
    should use other programs but not depend on it. Composer in PHP is a system that
    helps you to adopt this methodology. Composer is a dependency manager for PHP,
    which allows other packages written in PHP to be included in other projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程的原则总是教导学生，设计应该是高耦合和低内聚。这意味着应用程序应该使用其他程序，但不能依赖它们。PHP 中的 Composer 是一个帮助您采用这种方法的系统。Composer
    是 PHP 的依赖管理器，它允许其他用 PHP 编写的包被包含在其他项目中。
- en: 'PhpStorm enables you to create projects that adhere to this principle. To create
    a new Composer project, you need to select the **Composer Project** option in
    the dropdown provided from the **File** | **New Project** menu item. The next
    question asked of you is to select the path of `composer.phar`—from the local
    disk or from the website: [http://www.getcomposer.org](http://www.getcomposer.org)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 允许您创建遵循此原则的项目。要创建一个新的 Composer 项目，您需要在 **文件** | **新建项目** 菜单提供的下拉菜单中选择
    **Composer 项目** 选项。接下来询问您的问题是要选择 `composer.phar` 的路径——从本地磁盘或从网站：[http://www.getcomposer.org](http://www.getcomposer.org)
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Don''t scratch your head out of utter confusion—more knowledge surely means
    more confusion, but that never means you should target zero knowledge to have
    no confusion at all! An executable, `composer.phar`, causes this magic of handling
    the packages to occur. You must be thinking what exactly is it inside Composer
    that makes it such a buzzword these days—everyone seems to be talking about it.
    Perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为完全的困惑而抓耳挠腮——更多的知识确实意味着更多的困惑，但这并不意味着你应该追求零知识以避免任何困惑！一个可执行的 `composer.phar`
    文件引发了处理这些包的魔法。您可能正在想，Composer 内部究竟是什么让它成为当今的热门话题——每个人都似乎在谈论它。执行以下步骤：
- en: 'Go to [https://getcomposer.org/download/](https://getcomposer.org/download/),
    and you will see that there is the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://getcomposer.org/download/](https://getcomposer.org/download/)，您将看到以下命令：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have already installed composer prior to coming to cook with PhpStorm,
    you should specify `/path/to/composer.phar`, the path to where composer has been
    installed.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在来到 PhpStorm 之前已经安装了 composer，您应该指定 `/path/to/composer.phar`，即 composer 已经安装的路径。
- en: You can then select from the list of available packages in the left-hand side
    panel. On the right, you can see the corresponding description of the package
    selected. You can select the version of the package to be installed, and then
    click on **OK**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以从左侧面板中的可用包列表中进行选择。在右侧，您可以查看所选包的相应描述。您可以选择要安装的包的版本，然后点击 **确定**。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com](http://www.packtpub.com) 账户下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，以便将文件直接通过电子邮件发送给您。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The command is actually a concatenation of two commands that get the contents
    of the installer script and execute that via the PHP command line. If you happen
    to open the specified link inside a web browser, you will see the entire PHP code
    behind Composer. Are you able to breathe freely (pun intended)? Back to work,
    the intention of the second part of the command is to execute the PHP content
    via the PHP command line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令实际上是两个命令的串联，它们获取安装脚本的内容并通过 PHP 命令行执行。如果您在网页浏览器中打开指定的链接，您将看到 Composer 背后的整个
    PHP 代码。您能自由呼吸吗（当然，这里是一个双关语）？回到工作，命令的第二部分意图是通过 PHP 命令行执行 PHP 内容。
- en: 'Backtracking to the original topic, you were trying to select the right type
    of `composer.phar`. Have a look at the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原始主题，您试图选择正确的 `composer.phar` 类型。看看下面的截图：
- en: '![How it works...](img/3878OT_02_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_01.jpg)'
- en: PhpStorm takes care of the remaining tasks in installing *your-selected-package*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 会处理安装过程中剩余的 *你选择的包* 任务。
- en: 'The Composer system generates a `json` file with the name `composer.json`,
    which contains the details about the requirements. The following is the `composer.json`
    file for a project that has been created from scratch:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Composer系统会生成一个名为`composer.json`的`json`文件，其中包含关于依赖项的详细信息。以下是一个从头开始创建的项目所对应的`composer.json`文件：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is quite apparent that the json file conveys a lot of information to the
    reader. `"name":` is the name of the package downloaded. `"description":` is the
    description of the package downloaded. If you have a good memory, you will remember
    that there was a description in the right-hand panel of the package selection
    window. This description is exactly the same. `"require":` is the name of the
    packages that this downloaded package depends upon. The json file specifies the
    name of the project as the key and the corresponding version number as the value.
    `"authors":` is the author of the downloaded package. It includes the name and
    e-mail address of the author. `"autoload":` is the coding standard, any of PSR-0,
    PSR-1, PSR-2, PSR-3, PSR-4, and the namespace mapping to the actual directory.
    The hierarchy goes like this: the coding-standard contains the value of the namespace
    mapping. Namespace mapping means the name as the key and the directory (relative
    to the project root) as the value.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个json文件向读者传达了大量的信息。`"name":`是下载的包的名称。`"description":`是下载的包的描述。如果你有很好的记忆力，你会记得在包选择窗口的右侧面板中有一个描述。这个描述正是相同的。`"require":`是此下载包所依赖的包的名称。json文件指定项目名称作为键，相应的版本号作为值。`"authors":`是下载的包的作者。它包括作者的名字和电子邮件地址。`"autoload":`是编码标准，可以是PSR-0、PSR-1、PSR-2、PSR-3、PSR-4，以及命名空间映射到实际目录。其层次结构如下：编码标准包含命名空间映射的值。命名空间映射意味着名称作为键，目录（相对于项目根目录）作为值。
- en: 'PhpStorm and the Composer combination work wonders. When you order PhpStorm
    to download and arrange the packages, it will automatically arrange for you the
    include paths for the projects. No more warnings or errors relating to missing
    files will present a hindrance to your work now. Consider the following sreenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm和Composer的组合效果显著。当你让PhpStorm下载并排列包时，它会自动为你安排项目的包含路径。现在不再会有关于缺失文件的警告或错误来阻碍你的工作。考虑以下截图：
- en: '![How it works...](img/3878OT_02_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_02.jpg)'
- en: 'Suppose you have already added a few packages in your project and you now realize
    that you need to have more of the packages. Not to worry says PhpStorm, as it
    provides you an option to add more packages in the form of **Add dependency**.
    Doing this is extremely easy. In the open project, you need to go to **Tools**
    | **Composer** | **Add dependency**. There will be a familiar pop up that will
    ask you to select a package name and proceed to install. The remainder of the
    tasks will, as usual, be taken care of by PhpStorm. The result you will see will
    be in the form of some downloaded files and folders besides a change in your `composer.json`
    file for this particular project. One such `composer.json` file is as shown in
    the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在项目中添加了一些包，现在你意识到你需要更多的包。不要担心，PhpStorm会提供一个选项，让你以**添加依赖项**的形式添加更多包。这样做非常简单。在打开的项目中，你需要转到**工具**
    | **Composer** | **添加依赖项**。会出现一个熟悉的弹出窗口，要求你选择包名称并继续安装。其余的任务将像往常一样由PhpStorm处理。你将看到的将是下载的文件和文件夹，以及你特定项目的`composer.json`文件中的变化。以下是一个这样的`composer.json`文件的代码片段：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The symbols have the usual meaning. The external dependencies have been added
    to the list according to the `json` notation and are denoted by the single key
    required, where the value is the actual list of the dependencies having the key
    as their name and the corresponding versions as the value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 符号具有通常的含义。外部依赖项已根据`json`标记添加到列表中，并由单个键required表示，其中值是具有键作为名称和相应版本作为值的依赖项的实际列表。
- en: Creating an empty project
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个空项目
- en: The feeling that you get when you find some support in times of trouble can
    be said to have an analogy with that feeling of finding cold water to drink in
    times of thirst. This statement's analogy with the current scenario is that until
    this point in time, you were unable to find the exact project type to create,
    but now you have found a way out.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在困难时期找到一些支持时，你得到的感受可以与在口渴时找到冷饮的感觉相类比。这个陈述与当前情景的类比是，直到这个时间点，你无法找到要创建的确切项目类型，但现在你找到了一条出路。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to create an empty PHP project when you are convinced enough to need
    to create a new project and achieve a new feat by fulfilling your manager's business
    demand.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信需要创建一个新项目并实现新的成就，以满足经理的业务需求时，你需要创建一个空的PHP项目。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'A new empty project is the easiest to create:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新空项目是最容易的：
- en: You need to specify a name for your new project. Don't worry even if there are
    spelling mistakes in the name itself because PhpStorm doesn't check the name you
    specify against the dictionary.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要为新项目指定一个名称。即使名称本身有拼写错误，也不要担心，因为PhpStorm不会将你指定的名称与字典进行核对。
- en: A project name should only contain valid characters that a directory name should
    contain under an operating system.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目名称应仅包含操作系统下目录名称应包含的有效字符。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Creating an empty project is easy to understand. You need to specify the `/path/to/files/and/folders/`
    if you already have some basic framework to start from. See *Integrating Frameworks*,
    else PhpStorm will manage that for you by setting the default path (`~/PhpstormProjects/<name-of-your-project>`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空项目很容易理解。如果你已经有一些基本框架作为起点，你需要指定 `/path/to/files/and/folders/`。参见 *集成框架*，否则PhpStorm将为你设置默认路径（`~/PhpstormProjects/<name-of-your-project>`）。
- en: Reusing an existing project
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用现有项目
- en: Those who planned to take the route on the right-hand side have rightly chosen
    to do so. At times, reinventing the wheel is not a wise action to perform.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那些计划走右侧路线的人正确地选择了这样做。有时，重新发明轮子并不是一个明智的行为。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you reuse, you will be able to avoid spending time and resources on something
    that has already been created. PhpStorm allows you to reuse existing projects
    and lets you move forward. To reuse an existing project, you need to have the
    project on the disk.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重用，你将能够避免在已经创建的东西上浪费时间资源。PhpStorm 允许你重用现有项目，并让你继续前进。要重用现有项目，你需要将项目放在磁盘上。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To open an existing project, perform the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开现有项目，请执行以下步骤：
- en: You need to go to **File** | **Open**. There will be a pop-up dialog from PhpStorm.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要转到 **文件** | **打开**。将会出现一个来自PhpStorm的弹出对话框。
- en: You need to tell PhpStorm the path of the directory where your project is saved,
    and PhpStorm will obediently open the project for you.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要告诉PhpStorm保存项目的目录路径，PhpStorm将为你自动打开项目。
- en: Note
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once a directory has been opened as a project in PhpStorm, you will be able
    to distinguish it the next time because PhpStorm puts its logo next to this directory.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦某个目录在PhpStorm中作为项目打开，你将在下次能够区分它，因为PhpStorm会将它的标志放在这个目录旁边。
- en: You can now concentrate on gathering your technical requirements. You are strongly
    advised to plan well in advance before actually jumping to code because although
    a perfect software engineering plan does not exist yet, you can be optimistic
    and create a good enough plan that is flexible enough to be modified in case of
    need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以专注于收集你的技术需求。强烈建议你在实际编写代码之前提前做好规划，因为尽管完美的软件工程计划尚未存在，但你仍然可以保持乐观，创建一个足够好的计划，足够灵活，以便在需要时进行修改。
- en: Creating a new PHP class
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的PHP类
- en: Having come to the kitchen, you should be prepared to get your hands dirty while
    cooking. You will have to face the class spills, member variable splashes, and
    literal wetness of sweat when you try to bake the data structures; they might
    be too hot to handle. You might end up causing a burning sensation inside you
    (out of control *acidity*; pun intended). You must be prepared to have mistakenly
    added less (syntactic) sugar, thought of incorrect salt handling algorithm. All
    sorts of cooking issues would be there to trouble you, which might make you leave
    cooking altogether and run away... scary? Maybe yes... but you will not tire,
    you will not falter, and you will not fail dear friends, Romans and countrymen!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您来到厨房，您应该准备好在烹饪时弄脏双手。当您尝试烘焙数据结构时，您将不得不面对溅出的液体、成员变量的飞溅和汗水带来的湿润；它们可能太热而难以处理。您可能会在内侧造成灼热感（不受控制的*酸度*；有意为之）。您必须准备好可能添加的糖分不足（语法上的糖分），或者考虑错误的盐处理算法。各种烹饪问题都会困扰您，这可能会让您完全放弃烹饪并逃跑...害怕吗？也许吧...但您不会感到疲倦，您不会动摇，您也不会失败，亲爱的朋友们，罗马人和同胞们！
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some fundamentals... some programmers always talk **class**. In fact, all should.
    If you have always wondered what exactly a class is, you need to understand a
    datatype first. You must now have started feeling nostalgic, recalling your school
    days when teachers continued to haunt you with all those alien words. Come back
    and try to understand what a datatype is.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本概念...一些程序员总是谈论**类**。实际上，所有人都应该。如果您一直想知道类究竟是什么，您首先需要理解数据类型。现在您可能已经开始怀念起学校时代，那时老师们用那些陌生的词汇困扰您。回来并尝试理解数据类型是什么。
- en: A **datatype** is a classification of data based on its type (some would like
    to call this its attribute) and the operations (some prefer calling this its behavior).
    So what is the relation between class and datatype? The answer is that a class
    is a custom datatype. Puzzled? Please do not be. If you attempt to create a class,
    what do you do? You plan a number of member variables… STOP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型**是根据其类型（有些人喜欢称之为其属性）和操作（有些人更喜欢称之为其行为）对数据进行分类。那么类和数据类型之间有什么关系呢？答案是类是一个自定义数据类型。困惑吗？请不要困惑。如果您尝试创建一个类，您会做什么？您规划一系列成员变量…停止。'
- en: 'What is a variable defined as? There is the connection. So, the complete statement
    now becomes: you plan a number of member variables, methods (functions, as some
    prefer saying) to pack inside a class.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是如何定义的？这里有一个联系。因此，完整的陈述现在变为：您规划一系列成员变量、方法（函数，有些人喜欢这样称呼）来打包进一个类中。
- en: A class can be inherited from another class, can implement an interface, or
    be designed to be inherited. You can think of any permutation from the set {simple,
    abstract, inherited, super, and sub}, and you will observe that most of the permutations
    will be valid. How do you attack a problem? Simple common sense would suggest
    attacking the easiest part of the problem. So, here is how you can create a simple
    PHP class using PhpStorm.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以继承自另一个类，可以实现一个接口，或者被设计为可继承。您可以从集合{简单、抽象、继承、超类和子类}中的任何排列组合进行思考，您会发现大多数排列组合都是有效的。您如何解决问题？简单的常识会建议从问题的最容易部分开始解决。所以，这里是如何使用PhpStorm创建一个简单的PHP类。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To be about to create a new class, you might have already created a project.
    Inside that project, you can create a new class by selecting the target folder
    and accessing the right-click context menu.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备创建一个新类，您可能已经创建了一个项目。在那个项目中，您可以通过选择目标文件夹并访问右键单击上下文菜单来创建一个新类。
- en: 'PhpStorm is a curious machine. No sooner do you ask it to do something for
    you than it starts asking you a number of questions related to it. Here, when
    you ask PhpStorm to create a new class for you, it will ask you the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm是一个好奇的机器。您刚要求它为您做点什么，它就开始向您提出一系列相关问题。在这里，当您要求PhpStorm为您创建一个新类时，它会问您以下问题：
- en: '**Name**: This is quite self explanatory and is a mandatory field. You need
    to tell PhpStorm the name of the class you want to be created. You should be careful
    while naming your class, as this has to be in sync with your project engineering
    plan.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 这一点相当直观，是一个必填字段。您需要告诉PhpStorm您想要创建的类的名称。在命名类时，您应该小心，因为这一点必须与您的项目工程计划保持一致。'
- en: '**Namespace**: This is a handle-with-care option. You need to specify the namespace
    in order to explicitly tell the interpreter which version of the function to use.
    This is an optional but important field—if you do not specify it, nothing bad
    will happen and you will not suffer any illness.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**: 这是一个需要小心处理的选择。您需要指定命名空间，以便明确告诉解释器使用哪个版本的函数。这是一个可选但重要的字段——如果您不指定它，不会发生任何坏事，您也不会遭受任何疾病。'
- en: '**Filename**: This is an option you need to be careful while using. By default,
    this assumes the same value as the name of the class. If you mishandle this option
    by providing some other name, any product that you create will be solely owned
    by destiny, and no engineering principle will be able to maintain your product
    with ease.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件名**: 这是一个在使用时需要谨慎处理的选择。默认情况下，它假定与类的名称相同。如果您通过提供其他名称错误地处理此选项，您创建的任何产品都将完全归命运所有，没有任何工程原理能够轻松维护您的产品。'
- en: '**Directory**: Here, you can set the location where you wish your class to
    physically reside on the disk. By default, it assumes the location where you created
    your project—project root to be precise.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**: 在这里，您可以设置您希望类在磁盘上物理存在的位置。默认情况下，它假定您创建项目的位置——确切地说，是项目根目录。'
- en: '**Kind**: Now, this is something you have to decide based on the type of engineering
    plan that you have made prior to selecting this project. If you had a plan according
    to which you will be able to decide the functionality at a later stage, you can
    set the type of file as an interface; or for all other cases, you need to select
    the type as class. This interface is required in those conditions in which you
    will add the salt to the recipe later (pun intended). A trait is something that
    has a philosophy of "me too". You can safely ignore it for now.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**: 现在，这是您必须根据在选定此项目之前制定的工程计划来决定的事情。如果您有一个计划，根据该计划您将在稍后阶段决定功能，您可以将文件类型设置为接口；或者对于所有其他情况，您需要将类型选择为类。在这些条件下，您将添加盐到食谱中（有意为之）。特性是一种有“我也一样”哲学的东西。现在您可以安全地忽略它。'
- en: '**File extension**: This is an option that you are not advised to unnecessarily
    change. At the heart of all PHP files lies only one extension—the `.php` file.
    PhpStorm knows this. Please allow it to proceed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件扩展名**: 这是一个不建议您不必要地更改的选项。所有PHP文件的核心只有一个扩展名——`.php`文件。PhpStorm知道这一点。请允许它继续。'
- en: 'The add class option is available via two menu items. One has already been
    discussed, and for the other, perform the following step:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 添加类选项可通过两个菜单项获得。其中一个已经讨论过，对于另一个，请执行以下步骤：
- en: Go to **File** | **New**:![How to do it...](img/3878OT_02_03.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **文件** | **新建**：![如何操作...](img/3878OT_02_03.jpg)
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A simple sample class would look like the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例类将如下代码片段所示：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creating an interface in PhpStorm is not difficult either. On telling PhpStorm
    to create an interface, the output will be similar to a class except that there
    will be the keyword interface that will replace the keyword class. It will look
    like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhpStorm中创建接口也不困难。告诉PhpStorm创建接口时，输出将与类类似，只是将关键字“class”替换为关键字“interface”。它看起来如下所示：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to differentiate class and interface, then you just need common
    sense in terms of PHP. A `Class` keyword is used for class and `interface` for
    creating interfaces in PHP.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想区分类和接口，那么您只需要在PHP方面的常识即可。`Class`关键字用于类，而`interface`用于在PHP中创建接口。
- en: Creating a new PHP method
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的PHP方法
- en: If classes that represent real-world entities are nouns, they do not have any
    existence without verbs—the actions to be performed. To be able to maximize the
    technical profit for the manager you work for, you must be ready to use functions
    for all the verbs that exist in your use case.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代表现实世界实体的类是名词，那么没有动词——要执行的动作——它们就不存在。为了能够最大限度地提高您为经理创造的技术利润，您必须准备好使用函数来处理您用例中存在的所有动词。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Say for example, you have a pizza cooking task at hand. The recipe would consist
    of a (bare minimum) pizza bread (a noun), cheese (a noun), some salt (a noun).
    If you ponder over your problem, you will realize that you need to apply cheese
    to your pizza bread and add salt according to taste. If you look at this scenario
    from a technical perspective, you would most probably decide that there would
    be a `PizzaDish` class with functions such as `applyCheese(pizzaBread)`, `addSalt(cheese)`,
    and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你手头有一个披萨烹饪任务。食谱将包括一个（最基本）披萨面包（名词），奶酪（名词），一些盐（名词）。如果你思考你的问题，你会意识到你需要将奶酪涂抹在披萨面包上，并按口味添加盐。如果你从技术角度看待这个场景，你可能会决定需要一个`PizzaDish`类，其中包含`applyCheese(pizzaBread)`、`addSalt(cheese)`等函数。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating a method in PhpStorm is easy. Suppose you have your `PizzaDish` class.
    Your pizza dish is a `Dish` so your `PizzaDish` would extend `Dish`. Your class
    would look like the following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhpStorm中创建一个方法很简单。假设你有一个`PizzaDish`类。你的披萨菜肴是一个`Dish`，所以你的`PizzaDish`会扩展`Dish`。你的类如下代码片段所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your `PizzaDish` class can look like the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`PizzaDish`类可以如下代码片段所示：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Coding in PhpStorm is eased heavily by the use of code hinting or code completion.
    You just need to type a few characters as a hint, and PhpStorm is ready to suggest
    what could be next. You type `fun` and press *Ctrl* + *Space*, and there will
    be a number of hints about what your function can be. If you want to do more with
    your pizza creation recipe, as in adding some more ingredients, such as capsicum
    or mushroom, you can have a general function, `add($ingredient, $dishname)`. You
    can do that in your `PizzaDish` class. You can make use of code completion for
    the access modifier. You have to manually take care of the other actions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhpStorm中编码可以通过使用代码提示或代码补全来简化。你只需输入几个字符作为提示，PhpStorm就会准备好建议下一步可能的内容。你输入`fun`并按*Ctrl*
    + *Space*，就会出现关于你的函数可以是什么的多个提示。如果你想对你的披萨制作食谱进行更多操作，比如添加一些配料，如彩椒或蘑菇，你可以有一个通用函数，`add($ingredient,
    $dishname)`。你可以在你的`PizzaDish`类中这样做。你可以使用代码补全来设置访问修饰符。你必须手动处理其他操作。
- en: To convert the method `addSalt()` to `add()`, you need to rename the `addSalt`
    method. This is done in PhpStorm by the refactor option.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法`addSalt()`转换为`add()`，你需要重命名`addSalt`方法。这可以通过PhpStorm的重构选项完成。
- en: To refactor an item (here, the `addSalt` method), access the right-click context
    menu | **Refactor** | **Rename** or **Refactor** | **Change Signature**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构一个项目（这里指`addSalt`方法），可以通过右键点击上下文菜单进行操作 | **重构** | **重命名** 或 **重构** | **更改签名**。
- en: 'The **Rename** submenu, as shown in the following screenshot, will only change
    the name of the method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，**重命名**子菜单只会更改方法的名称：
- en: '![How to do it...](img/3878OT_02_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3878OT_02_04.jpg)'
- en: 'The **Change Signature** option is a more detailed refactoring facility in
    which you can change the complete signature of a method, as shown in the following
    screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改签名**选项是一个更详细的重构功能，你可以更改方法的全签名，如下面的截图所示：'
- en: '![How to do it...](img/3878OT_02_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3878OT_02_05.jpg)'
- en: 'So, your new add function becomes like the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的新添加函数如下代码片段所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A similar change has occurred in the parent `Dish` class as well, where the
    method `addSalt` has been renamed to `add`, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在父`Dish`类中也发生了类似的变化，其中`addSalt`方法已被重命名为`add`，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can make use of the `PizzaDish` class and its methods by firing the code
    shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下截图中的代码来使用`PizzaDish`类及其方法：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working of the code ecosystem is quite simple. You instantiated the `PizzaDish`
    class normally. You invoked the `add` function. But, when you actually invoked
    the `add` function, what exactly happened? The `add` function called the `add`
    function defined in its parent class (remember extends added to the beginning
    of `PizzaDish`) using a special word—`parent`. So, you called the `add` method
    thinking that `PizzaDish` would do your work, but in reality, `Dish` did your
    work! No, no, this is not cheating. This is inheritance, as explained by the principles
    of software engineering.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生态系统的运作相当简单。你通常实例化了`PizzaDish`类。你调用了`add`函数。但是，当你实际调用`add`函数时，究竟发生了什么？`add`函数调用了其父类中定义的`add`函数（记得在`PizzaDish`的开始处添加了`extends`）使用一个特殊的词——`parent`。所以，你以为你调用的是`PizzaDish`的`add`方法来做你的工作，但实际上是`Dish`做了你的工作！不，不，这并不是欺骗。这是继承，正如软件工程原则所解释的。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The keyboard shortcuts are *Ctrl* + *F6* and *Shift* + *F6* to change the signature
    and rename respectively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘快捷键是*Ctrl* + *F6*和*Shift* + *F6*，分别用于更改签名和重命名。
- en: Adding the getter/setter methods
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加getter/setter方法
- en: Adding `getter` and `setter` methods in PhpStorm is equally easy. All you need
    to do is have a member variable of the class. In the `PizzaDish` example, it was
    `dishName`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhpStorm中添加`getter`和`setter`方法同样简单。你所需要做的只是拥有一个类的成员变量。在`PizzaDish`示例中，它是`dishName`。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To create getters and setters for `dishName`, PhpStorm provides that if you
    need to. Access the right-click context menu for the target variable, click on
    **Generate** and select **Getters** and **Setters** from the pop up. PhpStorm
    will create the desired getters and setters for the selected member.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`dishName`创建getter和setter，PhpStorm提供了这样的功能。如果你需要，可以通过右键单击目标变量的上下文菜单，点击**生成**并从弹出菜单中选择**getter**和**setter**。PhpStorm将为所选成员创建所需的getter和setter。
- en: 'Your `PizzaDish` class will now look like the following piece of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`PizzaDish`类现在将看起来像以下这段代码：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The process of adding salt, cheese, and capsicum is still the same.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加盐、奶酪和红椒的过程仍然是相同的。
- en: 'You have to send the following lines to your PHP engine in order to create
    a new pizza dish and add some ingredients to it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将以下几行代码发送到你的PHP引擎，以便创建一个新的披萨盘并添加一些配料：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Earlier, when you had to access `$dishName`, you did it directly. This initiated
    a number of poor engineering practices, such as exposing the representation of
    the member variables. Actually, the list is endless. All you need to do is ensure
    that you must use getters and setters to be a good software engineer. So, in the
    code provided to you, you just have to call the `getter` method (such as `getDishName`)
    and the `setter` method (such as `setDishName`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，当你需要访问`$dishName`时，你是直接访问的。这引发了许多不良的工程实践，例如暴露成员变量的表示。实际上，这个列表是无穷无尽的。你所需要做的只是确保你必须使用getter和setter来成为一名优秀的软件工程师。所以，在你提供的代码中，你只需要调用`getter`方法（例如`getDishName`）和`setter`方法（例如`setDishName`）。
- en: Are you still feeling uncomfortable? Have patience. Welcome to the real software
    engineering world.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否仍然感到不舒服？要有耐心。欢迎来到真正的软件工程世界。
- en: Creating delegate methods
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建委托方法
- en: Delegation is an important design pattern in software engineering. It enhances
    code reusability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是软件工程中的一个重要设计模式。它增强了代码的可重用性。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In PHP, delegate methods can be created in accordance with the principle of
    delegation. While calling delegate functions, you need not know the name of the
    actual function in advance—the PHP engine can find it out at runtime for you.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，可以按照委托原则创建委托方法。在调用委托函数时，你不需要事先知道实际函数的名称——PHP引擎可以为你找到它。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: PHP provides two factory methods for the purpose. However, you can create your
    own delegate methods using the principles of **object-oriented programming**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了两个工厂方法用于此目的。然而，你可以使用面向对象编程的原则创建自己的委托方法。
- en: 'The factory methods provided by PHP are `call_user_func()` and `call_user_func_array()`.
    While the usage of the two methods is out of the scope of this text, the creation
    and usage of the delegate methods is better explained by the same scenario of
    cooking `PizzaDish`, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供的工厂方法是`call_user_func()`和`call_user_func_array()`。虽然这两个方法的用法超出了本文的范围，但委托方法的创建和使用可以通过以下代码中所示的烹饪`PizzaDish`的相同场景来更好地解释：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The usage of the delegate method is almost the same, but not the same:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 委托方法的用法几乎相同，但并不完全相同：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the `Dish` class now looks like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Dish` 类看起来如下：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Surprised? What is happening here is that when you invoke the `PizzaDish` class
    and pass the name of the `Dish` class in the constructor, the value of `$instance`
    is a newly created object of the `Dish` class. The rest, as it goes, is the usual
    method call via a class object. You can take a deep breath now, as you have just
    delegated the `add` function in `PizzaDish` to use the `add` function of `Dish`.
    It appears that the `PizzaDish` class is performing the task, but the actual task
    is done by the `Dish` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶吗？这里发生的事情是，当你调用 `PizzaDish` 类并传递 `Dish` 类的名称到构造函数中，`$instance` 的值是 `Dish`
    类的一个新创建的对象。其余的，就像它进行的那样，是通过类对象进行的常规方法调用。现在你可以深呼吸了，因为你已经将 `PizzaDish` 中的 `add`
    函数委托给 `Dish` 的 `add` 函数。看起来 `PizzaDish` 类正在执行任务，但实际上是由 `Dish` 类完成的。
- en: Surrounding code with control structures
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制结构包围代码
- en: 'Whatever algorithm you think of, whichever tool you use to design the functional
    requirements, and whichever planet you go to and use whatever hardware as your
    development platform, there is this fact that is omnipresent and ubiquitous: loops
    will follow you everywhere. Control structures are the building blocks of any
    code you think of. Not convinced? Your `PizzaDish` use case itself will be able
    to prove it to you.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想到什么算法，无论你使用什么工具来设计功能需求，无论你前往哪个星球，使用什么硬件作为你的开发平台，都有一个无处不在、无所不在的事实：循环将伴随你到任何地方。控制结构是任何你想到的代码的构建块。你不信？你的
    `PizzaDish` 用例本身就能证明这一点。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a computer in the first place to make calculations and decisions and
    solve complex problems in a diligent manner. Does a computer stop by solving just
    one problem? No. It is programmed to continue for all possible number of times
    it has been instructed. How does a program achieve this diligence? You said it
    right. A bit louder please. Yes, control loops. Even though this explanation might
    appear trivial to all you big guns, yet it is right that you cannot proceed to
    code without control structures.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要一个计算机来勤奋地计算、做决策和解决复杂问题。计算机只解决一个问题就停止了吗？不。它被编程为继续执行所有可能的指令次数。程序是如何实现这种勤奋的呢？你说对了。请说得再大声一点。是的，控制循环。即使这个解释可能对你们这些高手来说显得微不足道，但事实是，没有控制结构，你无法继续编写代码。
- en: PhpStorm lets you write code. It lets you concentrate on the actual business
    logic. You can write the lines of code that you think would be the atomic part.
    When you are convinced that the logic fits, you can use PhpStorm's **Surround**
    with feature to surround this code in your desired control structure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 允许你编写代码。它让你专注于实际的业务逻辑。你可以编写你认为将是原子部分的代码行。当你确信逻辑正确时，你可以使用 PhpStorm 的
    **Surround** 功能将这段代码包围在你的期望控制结构中。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you wish to add ingredients to your `PizzaDish`, you can make use of loops.
    There are multiple ways to express a single statement:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望向你的 `PizzaDish` 添加配料，你可以使用循环。有多种方式来表达一个单一语句：
- en: 'Using `foreach`, the `PizzaDish` class is invoked as follows:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `foreach`，`PizzaDish` 类的调用方式如下：
- en: '[PRE15]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You had to write `$pizzaDish->add($ingredient)` while keeping the cursor on
    this line.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你必须在这行代码上保持光标位置，编写 `$pizzaDish->add($ingredient)`。
- en: Invoke Surround by going to **Code** | **Surround with**, and selecting the
    `foreach` option did the trick for you. However, you had to specify the variables
    inside the loop structure. You can also use the keyboard shortcut *Ctrl* + *Alt*
    + *T*.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过访问 **代码** | **Surround with** 来调用 Surround，并选择 `foreach` 选项为你解决了问题。然而，你必须指定循环结构内部的变量。你也可以使用键盘快捷键
    *Ctrl* + *Alt* + *T*。
- en: 'You can perform a similar action for the `for` loop. This change will allow
    you to invoke your code. Have a look at the following code snippet:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对 `for` 循环执行类似操作。这个更改将允许你调用你的代码。看看下面的代码片段：
- en: '[PRE16]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A similar action is performed by surrounding the code with a `while` control
    structure. Your `PizzaDish` gets invoked by the following code snippet:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `while` 控制结构包围代码，执行类似的操作。你的 `PizzaDish` 通过以下代码片段被调用：
- en: '[PRE17]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A careful observation will reveal that the `while` loop behavior is exactly
    the same as the `for` loop behavior. Why have two features to achieve the same
    functionality, then? The human mind feels happy on having more choices. A piece
    of (pseudo) code explains this better:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细观察会发现，`while` 循环的行为与 `for` 循环的行为完全相同。那么为什么有两个功能来实现相同的功能呢？人类的大脑喜欢有更多的选择。一段（伪）代码能更好地解释这一点：
- en: '[PRE18]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The two control structures explained here have much in common. In a single
    term, they can be termed as entry-controlled structures because they follow the
    **first-decide-then-do** principle. They were not designed to make you lament
    your actions (pun intended). There is a gunslinger control structure that lives
    by the gun and dies by it, the `do-while` loop. It can cause you to lament your
    decision if you do not pay proper attention while using it. In the same terminology,
    it is an exit-controlled structure and will execute the task at least once. While
    this can seem required in some scenarios, you are advised to refrain from using
    `do-while`. Take a look at the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释的两个控制结构有很多共同之处。简而言之，它们可以被称作入口控制结构，因为它们遵循**先决定后执行**的原则。它们并不是为了让你后悔自己的行为（有意为之）。有一个枪手控制结构，它靠枪活着，也因枪而死，即`do-while`循环。如果你在使用它时没有给予适当的注意，它可能会让你后悔自己的决定。在同样的术语下，它是一个退出控制结构，并且至少会执行一次任务。虽然在某些情况下这可能是必需的，但你被建议避免使用`do-while`。看看下面的截图：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, in essence, the statement `$pizzaDish->add($ingredients[$ingredientCount])`
    gets executed at least once, increments the value of `$ingredientCount` by one,
    and then checks if the value is within limit. To use `do-while`, you need to place
    the cursor on the target statement and select the `do-while` option that appears
    in the **Select** dialog on going to **Code** | **Surround with**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，语句`$pizzaDish->add($ingredients[$ingredientCount])`至少执行一次，将`$ingredientCount`的值增加一，然后检查该值是否在限制范围内。要使用`do-while`，你需要将光标放在目标语句上，并在**代码**
    | **用...包围**的**选择**对话框中选择出现的`do-while`选项。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To make your application program responsible enough, you need to implement exception
    handling denoted by a **try-catch** block. A simple use case to demonstrate the
    usage of exception handling will be shown in this recipe. You are attempting to
    prepare your `PizzaDish`. You plan to put salt and cheese as usual and capsicum
    as toppings to make it WOW. While cooking, you discovered that there was no capsicum
    in the fridge! But you are hungry enough not to let anything come between you
    and your `PizzaDish`. You will add tomato in that case. So, where is the responsibility
    in this code? It is that during preparation in your code to handle an *exceptional*
    situation there was a topping missing, but the code took the responsibility and
    handled this exceptional situation by adding tomato in place of capsicum.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的应用程序程序足够负责，你需要实现由**try-catch**块表示的异常处理。在这个菜谱中，将展示一个简单的用例来演示异常处理的用法。你试图准备你的`PizzaDish`。你计划像往常一样放盐和奶酪，并作为配料放彩椒以使其变得令人惊叹。然而，在烹饪过程中，你发现冰箱里没有彩椒！但你饿得足够厉害，不会让任何东西阻碍你和你`PizzaDish`之间的距离。在这种情况下，你将添加番茄。那么，这段代码中的责任在哪里？那就是在代码准备阶段处理一个*异常*情况时，配料缺失，但代码承担了责任，通过添加番茄代替彩椒来处理这个异常情况。
- en: 'Your `PizzaDish` continued to cook in the following way:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`PizzaDish`继续以下方式烹饪：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The following screenshot shows you how the which-control-to-surround looks.
    And it is worth noting that you should know which control structure you are going
    to use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何查看which-control-to-surround的外观。值得注意的是，你应该知道你将要使用哪种控制结构。
- en: '![How it works...](img/3878OT_02_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_06.jpg)'
- en: Finding the matching brace
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找匹配的大括号
- en: '*If you embrace the brace, you will never be embarrassed.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你拥抱大括号，你永远不会感到尴尬。*'
- en: '*Some PhpStorm Cookbook writer*'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一些PhpStorm食谱作者*'
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Braces are an important element in programming. They not only define the boundary
    for the programmer, but also the interpreter. Both of you get to know the construct
    or from where to where the variable ranges. The PHP interpreter just needs to
    have a closing brace for every opening brace to proceed irrespective of how the
    code has been written. But the PHP interpreter is not powerful enough to write
    code for you—you have to do it yourself.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号是编程中的重要元素。它们不仅为程序员定义了边界，也为解释器定义了边界。你们两个都知道结构或变量的范围从哪里到哪里。PHP解释器只需要为每个开括号有一个闭括号来继续执行，而不论代码是如何编写的。但是，PHP解释器并不强大到可以为你编写代码——你必须自己来做。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you are provided with a small piece of code that is less than 100 lines long,
    you can somehow manage to read and maintain the code. If the line numbers exceed
    100, code formatting comes to your rescue.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一小段少于100行长的代码，你设法阅读和维护代码。如果行数超过100，代码格式化就会帮助你。
- en: PhpStorm enables you to format all or some of the selected lines by simple mouse
    clicks or a single keyboard shortcut. To format code, you need to select **Code**
    | **Reformat Code**, and your code will be formatted like a charm.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm允许你通过简单的鼠标点击或单个键盘快捷键格式化所有或部分选定的行。要格式化代码，你需要选择**代码** | **重新格式化代码**，你的代码将像魔法一样被格式化。
- en: The keyboard shortcut for this is *Ctrl* + *Alt* + *L*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快捷键是*Ctrl* + *Alt* + *L*。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After PhpStorm has formatted the code, life becomes easier for you. You can
    very easily find the matching brace by putting the cursor on the brace. The paired
    braces get highlighted automatically. This highlighting feature can be customized
    as well. You need to go to **File** | **Settings** | **Editor** | **Highlight
    on caret movement** and check or uncheck the **Highlight matched brace** checkbox
    to turn highlighting matching braces on or off. You can change the brace color,
    the background color of the brace, and so on. You can make your braces look bold
    or italic. In order to customize this behavior, you need to set up a new scheme.
    To start off, you need to go to **File** | **Settings** | **Editor** | **Colors
    & Fonts** | **Language Defaults** | **Brackets**, select one of the default themes,
    and do a **Save As** in order to make a copy, as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhpStorm格式化代码后，你的生活变得更轻松了。你可以通过将光标放在括号上非常容易地找到匹配的括号。配对的括号会自动高亮。这个高亮功能也可以自定义。你需要转到**文件**
    | **设置** | **编辑器** | **光标移动时高亮显示**，勾选或取消勾选**高亮匹配括号**复选框来开启或关闭高亮匹配括号。你可以更改括号颜色、括号背景颜色等。你可以使括号看起来加粗或斜体。为了自定义这种行为，你需要设置一个新的方案。首先，你需要转到**文件**
    | **设置** | **编辑器** | **颜色与字体** | **语言默认值** | **括号**，选择一个默认主题，然后进行**另存为**以创建一个副本，如图所示：
- en: '![How it works...](img/3878OT_02_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_07.jpg)'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The color scheme you just saved was saved as an XML document with the extension
    `.icls` under the `~/.WebIdeXX/config/colors` directory. The name of this document
    is the same as the name you provided while copying the color scheme.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚保存的颜色方案被保存为扩展名为`.icls`的XML文档，位于`~/.WebIdeXX/config/colors`目录下。该文档的名称与你在复制颜色方案时提供的名称相同。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us now look at how to format a long string.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何格式化一个长字符串。
- en: Wrapping string
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 换行字符串
- en: Another important aspect of code formatting gains importance when you have written
    some really long strings or some really long statements. You might end up in trouble
    trying to read those long lines. Even if you managed to read it, you might end
    up being confused about the start and end of those long, unhandleable lines.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写了一些非常长的字符串或一些非常长的语句时，代码格式化的另一个重要方面变得尤为重要。你可能试图阅读这些长行时会遇到麻烦。即使你设法阅读了，你也可能对那些长、难以处理的长行的开始和结束感到困惑。
- en: PhpStorm enables you to wrap long lines and statements according to a fixed
    width. You can ask PhpStorm to remember some limits for you by visiting the **File**
    | **Settings** | **Editor** | **Virtual Space** pane.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm允许你根据固定宽度包裹长行和语句。你可以通过访问**文件** | **设置** | **编辑器** | **虚拟空间**面板，让PhpStorm为你记住一些限制。
- en: You can wrap the long lines in the editor by selecting the checkbox against
    the **Use Soft wraps in editor** option. Long lines don't torment you only in
    the editor. They can also create a usage torture sometimes when you use the PhpStorm
    terminal to execute command-line PHP. If you check the **Use Soft wraps in console**
    option, you can avoid this problem once and for all. PhpStorm makes a provision
    for you to set the indent level for the wrap in the console. If you select this
    checkbox, the wrapped long line will continue into the next line, but with the
    specified number of spaces. Now, you cannot complain that you are not sure which
    one is your wrapped line and which one is your original line!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择**编辑器中使用软换行**选项旁边的复选框，在编辑器中包裹长行。长行不仅会在编辑器中折磨你。当你使用PhpStorm终端执行命令行PHP时，有时也会创建使用折磨。如果你勾选**在控制台中使用软换行**选项，你可以一劳永逸地避免这个问题。PhpStorm为你提供了设置控制台中换行缩进级别的选项。如果你选择此复选框，包裹的长行将继续到下一行，但带有指定的空格数。现在，你不能抱怨你不确定哪一行是你的包裹行，哪一行是你的原始行！
- en: Commenting out a section of code and PHPDoc
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释代码段和PHPDoc
- en: '**PHPDoc** is a facility provided by PHP, which is meant to document the complex
    code that you toiled very hard to build. The importance of documenting code and
    properly documented code need not be explained to those of you who have taken
    care of someone else''s code at some point in their lives. For all others, and
    for those who know, yet are hungry for knowledge, here are a few points that might
    explain why you should always document your code—no matter what and how. Stay
    tuned for some interesting use cases.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHPDoc**是PHP提供的一个功能，旨在记录你非常努力构建的复杂代码。对于那些在某个时刻照顾过他人代码的人来说，代码记录和良好记录的代码的重要性无需解释。对于所有人，以及那些知道但渴望知识的人，这里有一些可能解释为什么你应该始终记录你的代码——无论是什么和如何。敬请期待一些有趣的用例。'
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You planned to cook `PizzaDish`. How did you proceed? You created an entity
    called `Dish`, designed some functions in it that will assist you in adding some
    ingredients, and created a special case of the general case `Dish`. You named
    this particular case `PizzaDish`. In order to cook your pizza, you invoked `PizzaDish`
    and enjoyed eating your favorite pizza. Things went smoothly. But how many times
    does it happen that you do not cook other things? Can you spend your life just
    eating pizza? Don't you think that you have other tasks to perform? Here's the
    analogy. How many times does it happen that you need nothing other than your written
    code? Can you be a good programmer by just using your own class or code? Will
    you create algorithms for each and every task that you perform?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划制作`PizzaDish`。你是如何进行的？你创建了一个名为`Dish`的实体，并在其中设计了一些函数来帮助你添加一些配料，并创建了一般情况`Dish`的特殊情况。你将这个特殊情况命名为`PizzaDish`。为了制作你的披萨，你调用了`PizzaDish`并享受了你最喜欢的披萨。一切都很顺利。但是，有多少次你没有做其他事情？你能只吃披萨过一生吗？你不认为你还有其他任务要完成吗？这里有一个类比。有多少次你需要除了你编写的代码之外的其他东西？你能只通过使用你自己的类或代码成为一个优秀的程序员吗？你会为每个你执行的任务创建算法吗？
- en: In short, do you believe in reinventing the wheel?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你相信重新发明轮子吗？
- en: Normal people would answer no. For them, how do you use classes written by another
    fellow programmer? How did you discover that the function `Engine::start('car')`
    will turn the ignition on? This is where documentation comes in. It is the medium
    by which you were able to discover that a start method in the `Engine` class was
    meant to turn on the engine ignition.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 普通人可能会回答不。对他们来说，你是如何使用其他程序员编写的类的？你是如何发现`Engine::start('car')`函数会打开点火开关的？这就是文档的作用。它是你能够发现`Engine`类中的启动方法旨在打开发动机点火开关的媒介。
- en: Writing clean code is the first key to documentation. You should always think
    of names that explain a lot. You should always think of descriptive names. If
    you think you are running out of names, you can make use of PHP namespaces.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净的代码是文档化的第一个关键。你应该始终考虑那些能解释很多内容的名称。你应该始终考虑描述性的名称。如果你认为你的名称快要用完了，你可以利用PHP命名空间。
- en: To start thinking about how to write clean code, you are requested to read this
    book thoroughly. To start writing clean code, you are requested to start writing
    code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始思考如何编写干净的代码，你被要求仔细阅读这本书。为了开始编写干净的代码，你被要求开始编写代码。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you were careful enough and have a sharp memory, you would have already
    read the `Dish` and the `PizzaDish` classes. Looking at the way the variables
    were defined and the methods were declared, did you feel the need for other documentation?
    They say it and they say it right: *Good code in itself is good documentation*.
    But if you are unable to think of descriptive names in your code, here comes your
    savior—PHPDoc.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够细心并且记忆力好，你早就已经阅读了`Dish`和`PizzaDish`类。看着变量是如何定义的，方法是如何声明的，你是否觉得需要其他文档？他们说得好，他们说得对：*好的代码本身就是好的文档*。但是，如果你在代码中无法想到描述性的名称，那么PHPDoc就是你的救星。
- en: 'You have three ways to add comments to your code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你有三种方法可以向你的代码中添加注释：
- en: Single line
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行注释
- en: Multiline or block comment
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行或块注释
- en: Documentation comment
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档注释
- en: In order to learn, you have to perform .In order to perform, you have to start.
    So let's start. Add comments to the `PizzaDish` class itself for clarity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习，你必须执行。为了执行，你必须开始。那么，让我们开始吧。为了使`PizzaDish`类本身更清晰，请添加注释到该类上。
- en: 'A single-line comment is the simplest and the easiest form of writing comments
    in PHP code. A single-line comment begins with `//`, and whatever follows in a
    single line is treated by the PHP engine as a single-line comment. In the `PizzaDish`
    class, a single-line comment has been added next to the list (php array) of ingredients,
    which looks like the following line of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PHP代码中单行注释是最简单和最易写的一种注释形式。单行注释以`//`开头，PHP引擎将单行中跟随的内容视为单行注释。在`PizzaDish`类中，旁边已经添加了成分列表（PHP数组）的单行注释，如下所示：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In order to write a single-line comment in PhpStorm, you need to take care of
    the location of the comment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在PhpStorm中写单行注释，你需要注意注释的位置。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can write the comment without the need to begin it with `//`. When you are
    done with your sentence, you can use the shortcut *Ctrl* + */*, and PhpStorm will
    happily convert the statement to a single-line comment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写注释而不需要以`//`开头。当你完成你的句子时，你可以使用快捷键*Ctrl* + */*，PhpStorm会愉快地将语句转换为单行注释。
- en: Can your life be restricted to write a single line of comment? What if you want
    to have a number of single-line comments? Multiline or block comments will be
    required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你的生活能被限制为只写一行注释吗？如果你想要有多个单行注释呢？需要多行或块注释。
- en: All you need to do is to identify the precious code extent, and add `/*` at
    the beginning and `*/` at the end of the code. There are people in this world
    who do not have an idea of what *precious* is. All good software engineers will
    ignore such people and move on. In the `PizzaDish` class discussed, you can see
    that the last few lines were commented out. This is a block comment. In the current
    scenario, your taste buds were the business end, people!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的只是确定宝贵的代码范围，并在代码的开始处添加`/*`，在结尾处添加`*/`。在这个世界上，有些人对“宝贵”的概念一无所知。所有优秀的软件工程师都会忽略这样的人，继续前进。在讨论的`PizzaDish`类中，你可以看到最后几行被注释掉了。这是一个块注释。在当前情况下，你的味蕾是商业端，人们！
- en: Documentation comments start with `/**` and end with `*/`. Does it not look
    like the block comment? A more careful examination would tell you the difference.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释以`/**`开头，以`*/`结尾。这看起来不像块注释吗？更仔细的检查会告诉你它们之间的区别。
- en: While a block comment just needs a comment starting symbol and an ending symbol,
    a documentation comment requires a `*` symbol before the start of every line.
    While the PHP engine skips the contents inside the block (and the single-line)
    comments, the PHP engine (actually, the documentation engine) "peeps" into the
    documentation lines when generating the actual beautiful comments. Where do you
    get to see the documents? Dear, when you press *Ctrl* + *Q* over any method declaration,
    what do you see? Yes, it is a document that is the same as generated by the documentation
    engine. Magic? PhpStorm's magic.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然块注释只需要一个开始符号和一个结束符号，但文档注释需要在每一行的开始处有一个`*`符号。虽然PHP引擎会跳过块（和多行）注释中的内容，但在生成实际的漂亮注释时，PHP引擎（实际上是文档引擎）会“窥视”文档行。你在哪里能看到文档？亲爱的，当你按*Ctrl*
    + *Q*在任何方法声明上时，你看到了什么？是的，它是一个与文档引擎生成的相同的文档。魔法？PhpStorm的魔法。
- en: 'Fireworks! Too long? Didn''t read? A step-by-step explanation follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸！太长了？没看？下面是一步一步的解释：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This is probably the first documentation comment you are looking into. You
    will be surprised to know that the HTML tags you write here are actually processed
    by the PHP documentation engine. The output of the documentation comment appears
    when you put the cursor over the target member and go to **View | Quick Documentation**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你第一次查看文档注释。你会惊讶地发现，你在这里写的HTML标签实际上是由PHP文档引擎处理的。文档注释的输出出现在你将光标放在目标成员上并转到**视图
    | 快速文档**时：
- en: '![How it works...](img/3878OT_02_08.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/3878OT_02_08.jpg)'
- en: A picture is worth a thousand words. You can easily see how the HTML tags were
    processed to give proper formatting to the document.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一图胜千言。你可以轻松地看到HTML标签是如何被处理以给文档提供正确格式的。
- en: 'Similarly, you can add documentation to your methods as well (the same class
    and the same method, but this time, it''s `setDishName` with added documentation).
    The documentation lines would be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以给你的方法添加文档（同一个类和同一个方法，但这次是`setDishName`，并添加了文档）。文档行如下所示：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You just used the HTML strong tag to emphasize the type of the method `setDishName`.
    You were also able to emphasize that software engineering principles advise the
    use of setter methods. The comment for this method takes the following form:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚使用了HTML strong标签来强调`setDishName`方法的类型。你还能够强调软件工程原则建议使用setter方法。这个方法的注释采用以下形式：
- en: '![How it works...](img/3878OT_02_09.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_09.jpg)'
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to use the keyboard shortcut *Ctrl* + *Q*, you need not necessarily
    place your cursor under the method name. This works for the documentation comment
    region as well. PhpStorm is smart, so it understands that and shows you the same
    documentation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用键盘快捷键*Ctrl* + *Q*，你不必一定将光标放在方法名下。这也适用于文档注释区域。PhpStorm很智能，所以它理解这一点，并显示相同的文档。
- en: PhpStorm never disappoints you. There is a facility in PhpStorm in which you
    can customize the way your documentation comment should look. To do that, you
    need to go to **File** | **Settings** | **Code Style** | **PHP** | **PHPDoc**,
    as shown in the following screenshot. The options are quite descriptive.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm从不让你失望。在PhpStorm中有一个功能，你可以自定义你的文档注释的外观。为此，你需要转到**文件** | **设置** | **代码样式**
    | **PHP** | **PHPDoc**，如下面的截图所示。选项相当详细。
- en: '![How it works...](img/3878OT_02_10.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_10.jpg)'
- en: Creating a working set
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建作业集
- en: You would have felt a number of times that different PHP projects have different
    priorities. You got it right. A website development project, for example, would
    require a running web server configuration, and it might not require command-line
    PHP.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能多次感觉到不同的PHP项目有不同的优先级。你做得对。例如，一个网站开发项目可能需要一个运行的Web服务器配置，可能不需要命令行PHP。
- en: Getting ready
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A simple PHP project, on the other hand, would require command-line PHP, without
    a web server, and the list of directories could be limited to some folders in
    a hierarchy. The point here is that there are different projects with different
    dependencies and settings. Having a working set makes PhpStorm behave appropriately
    for the project currently open.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个简单的PHP项目可能需要命令行PHP，而不需要Web服务器，目录列表可能仅限于层次结构中的某些文件夹。这里的要点是，不同的项目有不同的依赖和设置。拥有一个作业集使得PhpStorm能够为当前打开的项目做出适当的反应。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you monitor the **Settings** pane closely, you will notice that there are
    two major sections. One is the project-settings section, where you make settings
    according to your project. This helps a great deal. PhpStorm builds an index for
    every project. If you create a proper working set for your project, you will help
    PhpStorm to build a more precise index, and the project processing will be much
    faster. Some of the important settings are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细监控**设置**面板，你会注意到有两个主要部分。一个是项目设置部分，在这里你可以根据你的项目进行设置。这非常有帮助。PhpStorm为每个项目构建一个索引。如果你为你的项目创建一个合适的作业集，这将帮助PhpStorm构建一个更精确的索引，项目处理将更快。一些重要的设置包括：
- en: '**PHP Specific Settings**: Making settings to execute the application you plan
    to create is quite handy. You need not to worry about how to execute and test
    your application. You just need to choose from a list of options that PhpStorm
    will put up before you.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP特定设置**：为你要创建的应用程序执行设置是非常方便的。你不必担心如何执行和测试你的应用程序。你只需要从PhpStorm在你面前提供的选项列表中选择即可。'
- en: '**Interpreter**: You could be required to implement some offline tasks on your
    web hosting service, which could probably do an update, a check, log cleaning
    tasks, and so on. You might configure command-line PHP for such files so that
    you can access them by a direct keyboard shortcut.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：你可能需要在你的Web托管服务上实现一些离线任务，这可能包括更新、检查、日志清理等任务。你可能需要为这些文件配置命令行PHP，以便你可以通过直接键盘快捷键访问它们。'
- en: '**Webserver**: Most of the time, you need to have a web server to run your
    PHP web application code. For this, you can specify the settings for the web server
    in PhpStorm.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务器**：大多数情况下，你需要有一个Web服务器来运行你的PHP Web应用程序代码。为此，你可以在PhpStorm中指定Web服务器的设置。'
- en: '**Debugger**: Life without a debugger for a web developer is like life for
    a doctor without a stethoscope. When you don''t know what is going on inside,
    how can you find out what is actually going on? You require a debugger for sure.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器**：对于Web开发者来说，没有调试器的生活就像医生没有听诊器的生活。当你不知道内部发生了什么时，你怎么能找出真正发生的事情呢？你肯定需要一个调试器。'
- en: '**Directories**: PhpStorm builds indexes of the files and folders that are
    there in the project. A longer index list means more memory consumption. Exclude
    unwanted *directory(ies)* from indexing, and PhpStorm will be grateful to you.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：PhpStorm 为项目中的文件和文件夹建立索引。较长的索引列表意味着更多的内存消耗。排除不需要的 *目录* 从索引中，PhpStorm
    会感激您。'
- en: '**Inspections**: PhpStorm acts as an inspector for the code you write. By default,
    there are a number of inspections that are on, and in most probability, you would
    not require all of them at all times.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查**：PhpStorm 作为您所写代码的检查员。默认情况下，有一些检查是开启的，并且很可能您并不需要在任何时候都需要所有这些检查。'
- en: '**Version Control**: If you are working in a team, having a versioning system
    is the need of the hour. You can set the details of the versioning system, such
    as the URL, the username, the password, and all the necessary details that will
    make your life easier when downloading (checking out) or uploading (committing)
    in the project that a team is working on.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：如果您在一个团队中工作，拥有一个版本控制系统是当务之急。您可以设置版本控制系统的详细信息，例如 URL、用户名、密码以及所有在下载（检出）或上传（提交）团队正在工作的项目时使您生活更轻松的必要细节。'
- en: The other one is the IDE-specific settings section. This provides you with control
    over the configurations that are universally true for all projects under PhpStorm.
    The description is beyond the scope of this topic.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 IDE 特定的设置部分。这为您提供了对所有在 PhpStorm 下的项目都普遍适用的配置的控制。描述超出了本主题的范围。
- en: Creating TODO tasks
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 TODO 任务
- en: Suppose it is the end of day, you have to *hurry home* (no pun intended), there
    are fantastic ideas overflowing in your mind, and you are quite sure that you
    will not be able to regenerate those ideas. You can ask TODO to come to your assistance
    in those cases.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是一天结束的时候，您必须 *匆忙回家*（没有开玩笑），您脑海中充满了绝妙的主意，您非常确信您将无法重新生成这些想法。在这些情况下，您可以请求 TODO
    来帮助您。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A **TODO** tag, when added to some PHP code, makes it visible under the TODO
    view. You can also refer to the TODO section of this chapter for a refresher.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 PHP 代码中添加 **TODO** 标签时，它会在 TODO 视图中变得可见。您还可以参考本章的 TODO 部分，以进行复习。
- en: Considering the same `Dish` and the `PizzaDish` scenario, suppose you thought
    of having some system to check whether the dish is cooked, you can put a flag
    there and then. This flag will keep reminding you about this.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到相同的 `Dish` 和 `PizzaDish` 场景，假设您想到了一个检查菜肴是否煮熟的系统，您可以在那里放置一个标志。这个标志会不断提醒您这一点。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To do a TODO, all you need to do is write TODO, followed by the reminder text,
    and press *Ctrl* + */* (that is comment the code). From what you have learned
    already, you can now document your `Dish` class. Probably, it would look something
    like the following code snippet:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 TODO，您只需写下 TODO，然后是提醒文本，并按 *Ctrl* + */*（即注释代码）。根据您已经学到的知识，您现在可以记录您的 `Dish`
    类。可能看起来像以下代码片段：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You managed to keep the functionality intact; you just added documentation comments
    for the class and the member methods. Everything else is as usual; the only alien
    item is the TODO. So, as you can see, a simple TODO was added. People might argue
    the usage of TODO. They are right and wrong in saying that life can be managed
    without TODO. They are right only in the case of tiny projects, where there is
    not much code and simple comments are visible and easily remembered. They are
    absolutely wrong in all other (and real-world) cases, where there are uncountable
    lines of code and you could actually face a nightmare in trying to figure out
    where you placed a comment related to some suggestion. PhpStorm is able to extract
    all the TODOs from your project and show them accurately in the TODO view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您成功地保持了功能完整；您只是为类和成员方法添加了文档注释。其他一切都是常规操作；唯一的外来物品就是 TODO。所以，如您所见，简单地添加了一个 TODO。人们可能会争论
    TODO 的用法。他们说的对，也说的不对。他们说的对的情况是小型项目，其中代码不多，简单的注释可见且容易记住。在其他所有（和现实世界）情况下，他们完全错误，在这些情况下，有无数行代码，您实际上可能会在试图找出与某个建议相关的注释时遇到噩梦。PhpStorm
    能够从您的项目中提取所有 TODO，并在 TODO 视图中准确显示。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Besides reminding you of some tasks-be-done-in-future, there can be some **FIXME**
    tags as well. As the name suggests, FIXME tags can be used to denote some feature
    that has produced errors or is prone to producing errors. You just need to use
    the FIXME keyword, followed by the description, which is then followed using *Ctrl*
    + */* (commenting). PhpStorm will start showing it in the TODO section, as shown
    in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提醒您未来要完成的任务外，还可以有一些 **FIXME** 标签。正如其名所示，FIXME 标签可以用来表示一些产生错误或容易产生错误的特性。您只需使用
    FIXME 关键字，然后是描述，接着使用 *Ctrl* + */*（注释）即可。PhpStorm 将开始在 TODO 部分显示它，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The fixme (or FIXME) tag will start indicating that there is something that
    has to be fixed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: fixme（或FIXME）标签将开始指示存在一些必须修复的问题。
- en: However, the game's not over with TODO. If there are a number of fellow programmers
    in your development team, you can add flags for an individual teammate. How? PhpStorm
    provides you with filters. This is available at **File** | **Settings** | **TODO**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TODO 还没有结束。如果您的开发团队中有许多程序员，您可以为个别队友添加标志。如何？PhpStorm 为您提供了过滤器。这可以在 **文件**
    | **设置** | **TODO** 中找到。
- en: 'You need to add a new pattern and a new filter to make it available in the
    filters section in the TODO view. On adding it, you will be able to set the flag
    for a particular fellow programmer. The code with this new flag looks like the
    following snippet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加一个新的模式和新的过滤器，以便在 TODO 视图中的过滤器部分使其可用。添加后，您将能够为特定的程序员设置标志。具有此新标志的代码看起来像以下片段：
- en: '[PRE26]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The filters and the patterns are case-insensitive by default because a programmer's
    life already has a number of issues to handle. Keep this in mind!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，过滤器和模式不区分大小写，因为程序员的日常生活中已经有很多问题需要处理。请记住这一点！
- en: Will you able to do the TODO?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你能完成 TODO 吗？
- en: '![How it works...](img/3878OT_02_11.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_02_11.jpg)'
