- en: Chapter 1. Introduction to Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 反应式编程简介
- en: Reactive programming has become a very popular and in demand topic over the
    last few years, and even though the ideas behind it aren't new, it takes the good
    parts from multiple different programming paradigms. This book's purpose is to
    teach you how to start writing PHP applications with principles of reactive programming
    in mind and in combination with pre-existing libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程在过去的几年中已经成为一个非常受欢迎和需求旺盛的主题，尽管其背后的理念并不新颖，但它从多个不同的编程范式中学到了优点。本书的目的是教会你如何带着反应式编程的原则，结合现有的库来编写PHP应用程序。
- en: 'In this chapter, we''ll learn the most important principles that will guide
    us throughout this entire book:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习将指导我们贯穿整本书的最重要的原则：
- en: Recap well-known programming paradigms and quickly explain their meaning for
    humans.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾众所周知的编程范式，并简要解释它们对人类的意义。
- en: We'll see how we can use functional PHP programming, even today, using practical
    examples. We pay special attention to how we can use anonymous functions.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用实用的例子，即使在今天，我们也可以使用函数式PHP编程。我们特别关注我们如何使用匿名函数。
- en: Explain what reactive programing is and what good parts it takes from other
    programming paradigms.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释什么是反应式编程，以及它从其他编程范式中学到了哪些优点。
- en: We'll have a look at some examples of widely spread JavaScript and PHP libraries
    that already use very similar principles to reactive programming.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨一些广泛使用的JavaScript和PHP库的例子，这些库已经使用了与反应式编程非常相似的原则。
- en: Introduce Reactive Extensions and see how these fit into the world of reactive
    programming.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍反应式扩展，并了解这些如何融入反应式编程的世界。
- en: Show what using Reactive Extensions looks like using RxJS and how it fits into
    the grand scheme of things.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS展示使用反应式扩展的样子，以及它是如何融入整个方案的。
- en: Create a first simple demo with RxPHP library.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxPHP库创建一个简单的第一个演示。
- en: Since reactive programming is a programming paradigm, we'll take a quick look
    at other common paradigms that all of us have probably already heard of and that
    you'll see mentioned every time you read or hear about reactive programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反应式编程是一种编程范式，因此我们将快速浏览其他所有我们可能已经听说过的常见范式，你会在阅读或听到反应式编程时经常看到它们。
- en: Imperative programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式编程
- en: Imperative programming is a programming paradigm around executing statements
    that change the program's state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程是一种围绕执行改变程序状态的语句的编程范式。
- en: 'What this means in human language:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这在人类语言中的含义是：
- en: '**Programming paradigm**: This is a set of concepts defining a style of building
    and structuring programs. Most programming languages, such as PHP, support multiple
    paradigms. We can also think of it as a mindset and a way we approach problems
    when using such paradigms.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程范式**：这是一组定义构建和结构化程序风格的概念。大多数编程语言，如PHP，支持多种范式。我们也可以将其视为一种心态和一种当我们使用这些范式时解决问题的方法。'
- en: '**Statements**: Units of action with side effects in imperative programming
    evaluated in sequences usually containing expressions. Statements are executed
    for their side effects and expressions for their return value. Consider this example:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**：在命令式编程中，具有副作用的行为单元，通常包含表达式，按顺序评估。语句执行是为了它们的副作用，表达式是为了它们的返回值。考虑以下示例：'
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line of code is a statement where `2 + 5` is an expression. The expected
    side effect is assigning the value `7` to the `$a` variable. This leads to changing
    the program''s current state. Another statement could be, for instance:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码是一个语句，其中`2 + 5`是一个表达式。预期的副作用是将值`7`赋给`$a`变量。这会导致改变程序的当前状态。另一个例子可以是：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This statement has one expression and no return value.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个语句有一个表达式，但没有返回值。
- en: '**State**: Values of program variables in memory at any given time. In imperative
    programming, we define a series of statements that control the program''s flow
    and, therefore, change its state.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：在任何给定时间内存中程序变量的值。在命令式编程中，我们定义一系列控制程序流程的语句，因此改变其状态。'
- en: Declarative programming
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程
- en: Declarative programming is a paradigm focused on describing a program's logic
    instead of particular executional steps. In other words, in declarative programming,
    we define what we want instead of how we want it. In contrast to imperative programming,
    programs in declarative programming are defined with expressions instead of statements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程是一种关注于描述程序逻辑而不是特定执行步骤的范式。换句话说，在声明式编程中，我们定义我们想要什么，而不是我们想要如何实现。与命令式编程相比，声明式编程中的程序是用表达式而不是语句定义的。
- en: 'Very common examples could be SQL and HTML languages. Consider the following
    database query:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的例子可以是SQL和HTML语言。考虑以下数据库查询：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In SQL, we define what data from what table we want to query, but the implementation
    details are completely hidden for us. We don't even want to worry about how the
    database engine stores or indexes the data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，我们定义我们想要查询哪些表中的数据，但实现细节对我们来说完全隐藏。我们甚至不想担心数据库引擎如何存储或索引数据。
- en: In HTML, we define the structure of elements; what's behind the browser's rendering
    process isn't important for us. We just want to see the page on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们定义元素的结构；对于我们来说，浏览器渲染过程背后的细节并不重要。我们只想在屏幕上看到页面。
- en: Sequential and parallel programming
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序和并行编程
- en: We can think of sequential and parallel programming as counterparts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将顺序和并行编程视为对立面。
- en: 'In sequential programming, we''re executing processes in order. This means
    that a process is started when the preceding process has finished. In other words,
    there is always only one process being executed. The following figure illustrates
    this principle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序编程中，我们按顺序执行进程。这意味着当一个进程完成时，才会启动下一个进程。换句话说，始终只有一个进程正在执行。以下图示了这一原则：
- en: '![Sequential and parallel programming](img/00002.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![顺序和并行编程](img/00002.jpeg)'
- en: 'In parallel programming, multiple processes can be executed concurrently:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行编程中，可以同时执行多个进程：
- en: '![Sequential and parallel programming](img/00003.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![顺序和并行编程](img/00003.jpeg)'
- en: To make this easier to understand and more relevant to PHP, we can, instead
    of processes, think of lines of code. PHP interpreter is always sequential and
    it never executes code in parallel.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使理解更加容易，并且与PHP更加相关，我们可以不将进程视为代码行。PHP解释器始终是顺序执行的，它永远不会并行执行代码。
- en: In [Chapter 9](part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d
    "Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman"),
    *Multithreaded and Distributed Computing with pthreads and Gearman*, we'll use
    PHP module pthreads that makes it possible to run PHP code in multiple threads,
    but we'll see that it's not as simple as it seems. Module pthreads, in fact, creates
    multiple independent PHP interpreters, each running in a separate thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d "第9章。使用pthreads和Gearman进行多线程和分布式计算")《使用pthreads和Gearman进行多线程和分布式计算》中，我们将使用PHP模块pthreads，它使得在多个线程中运行PHP代码成为可能，但我们会看到这并不像看起来那么简单。实际上，pthreads模块创建了多个独立的PHP解释器，每个解释器都在一个单独的线程中运行。
- en: Asynchronous programming
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: The term asynchronous programming is very common in languages such as JavaScript.
    A very general definition is that, in asynchronous programming, we're executing
    code in a different order than it was defined. This is typical for any event based
    application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程这个术语在JavaScript等语言中非常常见。一个非常普遍的定义是，在异步编程中，我们以不同于定义的顺序执行代码。这对于任何基于事件的程序都是典型的。
- en: For example, in JavaScript, we first define an event listener with its handler,
    which is executed some time later, when an appropriate event occurs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在JavaScript中，我们首先定义一个事件监听器及其处理程序，该处理程序将在适当的事件发生一段时间后执行。
- en: 'In PHP, this could be, for example, a web application that needs to send an
    e-mail when we create a new blog article. Just, instead of lines of code, we''re
    considering tasks. The following figure demonstrates an asynchronously triggered
    event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，这可能是例如一个需要在创建新博客文章时发送电子邮件的Web应用程序。只是，我们考虑的是任务，而不是代码行。以下图示了一个异步触发的事件：
- en: '![Asynchronous programming](img/00004.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![异步编程](img/00004.jpeg)'
- en: While the web application was saving an article (processing a task), it triggered
    an event that sent an e-mail and then carried on with the original task. The event
    handler had to be defined somewhere before we started this task.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web应用程序保存文章（处理任务）时，它触发了一个事件，发送了电子邮件，然后继续执行原始任务。事件处理程序必须在开始此任务之前定义。
- en: Asynchronous versus parallel programming
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程与并行编程的比较
- en: A very common misconception is that asynchronous and parallel programming are
    the same, or that one is an implication of the other. This is very common in JavaScript
    where, from the user's perspective, it looks like things are running in parallel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的误解是异步编程和并行编程是相同的，或者认为一个是由另一个引起的。这在JavaScript中非常常见，从用户的角度来看，事情看起来像是并行运行的。
- en: This isn't true, but many programming languages (in fact, just their interpreters),
    create the illusion of running in parallel while they're still sequential. They
    appear to be parallel due to it's event-based nature (JavaScript), or because of
    their interpreter internals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不正确，但许多编程语言（实际上，只是它们的解释器）在它们仍然是顺序执行的同时，创造出并行运行的错觉。它们看起来像是并行的，这要归因于它们基于事件的本性（如JavaScript），或者归因于它们的解释器内部机制。
- en: For example, Python simulates threads by switching the execution context between
    different parts of the application. The Python interpreter is still single threaded
    and executes instructions sequentially, but creates the illusion of running code
    in parallel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python通过在不同部分的应用程序之间切换执行上下文来模拟线程。Python解释器仍然是单线程的，按顺序执行指令，但创造出并行运行代码的错觉。
- en: Functional programming
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: The functional programming paradigm treats program flow as an evaluation of
    functions. It utilizes several concepts, where the most important for us are eliminating
    side effects, avoiding mutable data, functions as first-class citizens and higher-order
    functions. The output of each function is dependent only on its input argument
    values, therefore, calling the same function twice has to always return the same
    value. It's based on declarative programming, in the sense of using expressions
    instead of statements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式将程序流程视为函数的评估。它利用了几个概念，其中对我们来说最重要的是消除副作用、避免可变数据、函数作为一等公民和高阶函数。每个函数的输出只依赖于其输入参数值，因此，调用同一个函数两次必须总是返回相同的值。它基于声明式编程，即在表达式中使用而不是使用语句。
- en: 'Let''s have a deeper look what this means:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看这意味着什么：
- en: '**Eliminating side effects**: While in imperative programming side-effects
    were desired during program execution, in functional programming it''s the exact
    opposite. Each function is supposed to be an individual building block whose return
    value is based only on its input values. Note that, in functional programming,
    it almost never makes sense to define a function that takes no arguments and returns
    no value. Assuming that functions have no side effects, this means that this function
    can''t do anything (or at least anything observable from the outside). This is
    in contrast to imperative programming, where using such functions makes sense
    because they can modify some internal state (of an object for instance). Eliminating
    side effects leads to more independent and better testable code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除副作用**：在命令式编程中，副作用在程序执行期间是期望的，而在函数式编程中则正好相反。每个函数都应该是一个独立的构建块，其返回值仅基于其输入值。请注意，在函数式编程中，定义一个没有参数且不返回值的函数几乎没有任何意义。假设函数没有副作用，这意味着这个函数不能做任何事情（或者至少从外部观察不到任何事情）。这与命令式编程形成对比，在命令式编程中，使用这样的函数是有意义的，因为它们可以修改某些内部状态（例如对象的内部状态）。消除副作用导致代码更加独立和易于测试。'
- en: '**Avoiding mutable data**: The concept of not modifying any input values and
    working with their copies works well with not creating any side effects. Executing
    the same function with the same input parameters will always return the same value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免可变数据**：不修改任何输入值并使用它们的副本的概念与不产生任何副作用很好地结合。使用相同的输入参数执行相同的函数将始终返回相同的值。'
- en: '**First-class citizens and higher-order functions**: In programming languages,
    stating that type/object/function is a first-class citizen (or first-class element)
    means that this entity supports operations generally available to all other entities.
    Usually, this includes:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一等公民和高阶函数**：在编程语言中，说类型/对象/函数是一等公民（或一等元素）意味着这个实体支持通常对所有其他实体都适用的操作。通常，这包括：'
- en: It can be passed as a parameter to functions
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为参数传递给函数
- en: It can be returned from a function
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从函数中返回
- en: It can be assigned to a variable
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被分配给一个变量
- en: 'Higher-order functions have a very similar meaning and have to do at least
    one of these:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高阶函数有非常相似的意义，并且至少要做以下之一：
- en: Take a function as an argument
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个函数作为参数
- en: Return a function as a result
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为结果
- en: In functional programming, this concept of higher-order function is often used
    in connection with methods on collections such as `map()`, `filter()`, `reduce()`, `concat()`,
    and `zip()`
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数式编程中，这种高级函数的概念经常与集合上的方法如 `map()`、`filter()`、`reduce()`、`concat()` 和 `zip()`
    结合使用。
- en: Functional programming in PHP
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的函数式编程
- en: Let's step aside for a moment and see how the three concepts mentioned above
    are related to PHP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时离开一下，看看上述提到的三个概念如何与PHP相关联。
- en: Eliminating side effects
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消除副作用
- en: 'This is mostly a matter of a good programming style and self-discipline. Of
    course, PHP doesn''t restrict us from violating this rule. Note that, by side
    effects, we also mean use cases like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是一个良好的编程风格和自律的问题。当然，PHP并没有限制我们违反这一规则。请注意，通过副作用，我们也指代以下用例：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though we have not defined the function `saveToDatabase()` ourselves (for
    example, it comes from a framework we are using), it's still a side effect. If
    we execute the same function again, it will return the same value, but the end
    state is different. For example, it will create the record in the database twice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有自己定义函数 `saveToDatabase()`（例如，它来自我们使用的框架），但它仍然是一个副作用。如果我们再次执行相同的函数，它将返回相同的值，但最终状态是不同的。例如，它将在数据库中创建两次记录。
- en: Avoiding mutable data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免可变数据
- en: 'This concept is simple with primitive data types, for example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始数据类型，这个概念很简单，例如：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, when working with collections, this principle requires the creation
    of a new collection and copying values from the old collection to the new one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与集合一起工作时，这一原则需要创建一个新的集合并将旧集合中的值复制到新集合中：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example shows this principle in practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子展示了这一原则在实际中的应用。
- en: In PHP, arrays are passed by reference for performance reasons until the first
    attempt to modify them. Then the interpreter will create a copy of the original
    array behind the scene (so called copy-on-write). However, objects are always
    passed as references, so we'll have to be very careful when working with them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，出于性能原因，数组是通过引用传递的，直到第一次尝试修改它们。然后解释器将在幕后创建原始数组的副本（所谓写时复制）。然而，对象始终作为引用传递，因此我们在处理它们时必须非常小心。
- en: This concept of immutable collections (or objects in general) became very popular
    in JavaScript with libraries such as `Immutable.js`, made by Facebook ( [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)
    ), or the so-called `onPush` change detection mechanism in Angular2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不可变集合（或一般对象）的概念在JavaScript中变得非常流行，例如Facebook制作的 `Immutable.js` 库（[https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)），或者Angular2中所谓的
    `onPush` 变化检测机制。
- en: Apart from making our code more predictable, when it's used appropriately, it
    will simplify checking for changes in large collections because, if any of its
    items have changed, then the entire collection is replaced by a new instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使我们的代码更可预测外，当它被适当使用时，它将简化对大型集合中变化的检查，因为如果其任何项已更改，则整个集合将被新的实例替换。
- en: In order to check if two collections contain the same data, we can use the identity
    operator (`===` three equal signs) instead of comparing the collections' items
    one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查两个集合是否包含相同的数据，我们可以使用身份运算符（`===` 三等号）而不是逐个比较集合的项。
- en: In PHP, there are already libraries that make this task easier, for instance,
    `Immutable.php` ( [https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php)
    ). Also, for example, PHP 5.5+ comes with an immutable version of `DateTime` class
    called `DateTimeImmutable` by default.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，已经有库使这项任务更容易，例如，`Immutable.php`（[https://github.com/jkoudys/immutable.php](https://github.com/jkoudys/immutable.php)）。例如，PHP
    5.5+ 默认包含一个不可变的 `DateTime` 类版本，称为 `DateTimeImmutable`。
- en: First-class citizens and higher-order functions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一等公民和高级函数
- en: Now it starts to get interesting. Functions in PHP have been first-class citizens
    for a very long time already. Moreover, since PHP 5.3+, we can use anonymous functions,
    which greatly simplifies the usage of higher-order functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情开始变得有趣。PHP中的函数已经是一等公民很长时间了。此外，自PHP 5.3+以来，我们可以使用匿名函数，这极大地简化了高级函数的使用。
- en: 'Consider a very trivial example that applies a function on every item in a
    collection with the built-in `array_map()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个非常简单的例子，使用内置的 `array_map()` 函数对集合中的每个元素应用一个函数：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have used PHP''s `array_map()` function to iterate the array and return
    the length of each string. If we consider just this function call, it uses many
    of the concepts from multiple paradigms that we have explained above:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 PHP 的 `array_map()` 函数来迭代数组并返回每个字符串的长度。如果我们只考虑这个函数调用，它使用了我们在上面解释的多个范式的许多概念：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What this means in particular:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这具体意味着什么：
- en: Single expression `strlen($item)` and no assignments (declarative programming).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个表达式 `strlen($item)` 和没有赋值（声明式编程）。
- en: Implementation details on how the array is actually iterated are hidden from
    us (declarative programming).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际迭代数组的实现细节对我们来说是隐藏的（声明式编程）。
- en: First-class citizens and higher-order functions (functional programming).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类公民和高级函数（函数式编程）。
- en: Immutable data - this function call doesn't change the original, but creates
    a new array (functional programming).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据 - 这个函数调用不会改变原始数据，而是创建一个新的数组（函数式编程）。
- en: No side effects - everything happens inside the inner closure. If we used any
    variables, they would exist only inside this closure (functional programming).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有副作用 - 所有操作都在内部闭包中进行。如果我们使用了任何变量，它们将只存在于这个闭包中（函数式编程）。
- en: 'Just for comparison, if we wanted to write the same example in imperative programming,
    it would be just one line longer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了比较，如果我们想用过程式编程写出相同的例子，它将只多一行：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s take this a little further, and say we want to get the sum of all lengths
    greater than `5`. First, we''ll start with the most obvious imperative approach:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，假设我们想要获取所有长度大于 `5` 的总和。首先，我们将从最明显的过程式方法开始：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can write the same thing using functional programming, utilizing three
    methods we mentioned earlier: map, filter and reduce. In PHP, these are called
    `array_map()`, `array_filter()`, and `array_reduce()` respectively:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用函数式编程来写出相同的内容，利用我们之前提到的三种方法：map、filter 和 reduce。在 PHP 中，这些分别被称为 `array_map()`、`array_filter()`
    和 `array_reduce()`：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We got rid of all statements and used only expressions. The resulting code
    isn''t short, and we had to also create three variables to hold partially processed
    arrays. So let''s transform this into one large nested call:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去掉了所有语句，只使用了表达式。生成的代码并不短，我们还得创建三个变量来保存部分处理的数组。所以让我们将其转换成一个大的嵌套调用：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a little shorter; we can see the sequence of functions applied and
    their respective expressions in the same order. We''ve already encountered inconsistency
    in function declarations in PHP, as shown in the following code, which has been
    highly criticized:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这要短一些；我们可以看到函数应用的顺序和它们相应的表达式，顺序相同。我们已经遇到了 PHP 中函数声明的矛盾，如下所示，这已经受到了高度批评：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are shortened function definitions from PHP documentation. We can see
    that, sometimes the first argument is the iterated collection; sometimes it's
    the callback function. The same problem exists with string functions and their
    haystack-needle arguments. We can try to improve the readability a little with
    functional-PHP library ( [https://github.com/lstrojny/functional-php](https://github.com/lstrojny/functional-php)
    ) - a collection of functions for functional programming in PHP.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是从 PHP 文档中缩短的函数定义。我们可以看到，有时第一个参数是迭代的集合；有时是回调函数。同样的问题也存在于字符串函数及其 haystack-needle
    参数中。我们可以尝试使用 functional-PHP 库（[https://github.com/lstrojny/functional-php](https://github.com/lstrojny/functional-php)）来提高可读性，这是一个
    PHP 函数式编程的函数集合。
- en: 'The following code represents the same example as above, but uses `lstrojny/functional-php`
    library:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示与上面相同的例子，但使用了 `lstrojny/functional-php` 库：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It definitely looks better, but this is probably the best we can get when using
    standard PHP arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实看起来更好，但当我们使用标准的 PHP 数组时，这可能是我们能得到的最好的结果。
- en: 'Let''s have a look at how the same problem could be solved in a language where
    arrays are objects and map, filter and reduce are its methods. Javascript, for
    example, is such a language, so we can rewrite the same example from above one
    more time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在数组是对象且 map、filter 和 reduce 是其方法的编程语言中，如何解决相同的问题。例如，JavaScript 就是这样一种语言，因此我们可以再次重写上面的例子：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll use the new ES6 standard whenever we show any JavaScript code throughout
    this entire book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用新的 ES6 标准来展示任何 JavaScript 代码。
- en: Well, this was quite easy and it meets all our expectations from functional
    programming much better than PHP. This might be the reason why we almost never
    use higher-order functions in PHP. They are just too hard to write, read and maintain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这相当简单，并且比 PHP 中的函数式编程更好地满足了我们的期望。这可能是我们几乎从不使用高阶函数的原因。它们太难编写、阅读和维护了。
- en: Before we move on, we should look at another topic related to functional programming
    in PHP that is worth mentioning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该看看与 PHP 中的函数式编程相关的一个值得注意的话题。
- en: Anonymous functions in PHP
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 中的匿名函数
- en: 'Every anonymous function is internally represented as an instance of a Closure
    class, shown as follows (we''ll also refer to anonymous functions as closures
    or callables):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个匿名函数在内部都表示为闭包类的一个实例，如下所示（我们也会将匿名函数称为闭包或可调用对象）：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What's unusual is that we can bind custom `$this` object when calling a closure,
    a concept that is very common in JavaScript but very rarely used in PHP.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不寻常的是，我们可以在调用闭包时绑定自定义的 `$this` 对象，这是一个在 JavaScript 中非常常见但在 PHP 中很少使用的概念。
- en: 'Let''s define a simple class that we''ll use for demonstration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的类，我们将用它来进行演示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, test the function stored in `$count` variable on two objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在两个对象上测试存储在 `$count` 变量中的函数：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example prints to console the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将以下输出打印到控制台：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In PHP, we can specify what variables we want to pass from the parent scope
    to the closure with the `use` keyword. Variables can be also passed by reference,
    similar to passing variables by reference on function calls. Consider the following
    example that demonstrates both principles:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，我们可以使用 `use` 关键字指定我们想要从父作用域传递到闭包中的变量。变量也可以通过引用传递，类似于在函数调用中通过引用传递变量。考虑以下示例，它演示了这两个原则：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have two closures `$func` and `$func2`. The first one works with a copy
    of `$str` so, when we print it outside of the function, it''s unmodified. However,
    the second closure, `$func2` works with a reference to the original variable.
    The output for this demo is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个闭包 `$func` 和 `$func2`。第一个闭包使用 `$str` 的一个副本，所以当我们将其打印到函数外部时，它不会被修改。然而，第二个闭包
    `$func2` 使用原始变量的引用。这个演示的输出如下：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We'll be passing objects to closures a lot in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将多次将对象传递给闭包。
- en: There's also a `bindTo($newThis)` method with a similar purpose. Instead of
    evaluating the closure, it returns a new Closure object with `$this` binded to `$newThis`, which
    can be later called with for example, `call_user_func()` method. When using closures
    inside objects, the context `$this` is bind automatically, so we don't need to
    worry about it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个具有类似功能的 `bindTo($newThis)` 方法。它不是评估闭包，而是返回一个新的闭包对象，其中 `$this` 被绑定到 `$newThis`，之后可以通过例如
    `call_user_func()` 方法调用。当在对象内部使用闭包时，上下文 `$this` 会自动绑定，所以我们不需要担心它。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Anonymous functions and the Closure class are very well explained in the official
    documentation, so head over there if you have any hesitations: [http://php.net/manual/en/functions.anonymous.php](http://php.net/manual/en/functions.anonymous.php)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数和闭包类在官方文档中解释得非常好，所以如果你有任何疑问，请前往那里：[http://php.net/manual/en/functions.anonymous.php](http://php.net/manual/en/functions.anonymous.php)
- en: PHP magic methods
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 魔术方法
- en: PHP defines a set of names that can be used as class methods with a special
    effect. These are all prefixed with two underscores `__`. For our purposes, we'll
    be particularly interested in two of them, called `__invoke()` and `__call()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 定义了一组可以用于具有特殊效果类方法的名称。这些名称都以前缀两个下划线 `__` 开头。就我们的目的而言，我们将特别关注其中的两个，称为 `__invoke()`
    和 `__call()`。
- en: The `__invoke()` method is used when we try to use an object as if it were a
    regular function. This is useful when we use higher-order functions because we
    can treat objects and functions exactly the same way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将对象用作普通函数时，会使用 `__invoke()` 方法。当我们使用高阶函数时，这很有用，因为我们可以将对象和函数以完全相同的方式对待。
- en: The second `__call()` method is used when we attempt to call an object method
    that doesn't exist (to be precise, a method that is inaccessible). It receives
    as arguments the original method name and an array of its arguments that was used
    when trying to call it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `__call()` 方法用于当我们尝试调用一个不存在的对象方法（更准确地说，是一个不可访问的方法）时。它接收原始方法名和尝试调用它时使用的参数数组作为参数。
- en: We'll use both of these magic methods in [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 2 章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "第 2 章。使用 RxPHP 的响应式编程") *使用 RxPHP 的响应式编程* 中使用这两个魔法方法。
- en: The principles shown here aren't very common in PHP, but we'll meet them on
    several occasions when using functional programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的原则在 PHP 中并不常见，但当我们使用函数式编程时，我们会在几个场合遇到它们。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this entire book, we'll try to follow PSR-1 and PSR-2 coding standards
    ([http://www.php-fig.org/psr/](http://www.php-fig.org/psr/)). However, we'll often
    violate them on purpose to keep the source codes as short as possible.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将尝试遵循 PSR-1 和 PSR-2 编码标准 ([http://www.php-fig.org/psr/](http://www.php-fig.org/psr/))。然而，我们经常会故意违反它们，以使源代码尽可能短。
- en: Now, we'll finally grasp reactive programming.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于要掌握响应式编程了。
- en: Reactive programming
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Reactive programming is yet another programming paradigm. It is based around
    the ability to easily express data flows and the automatic propagation of changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是另一种编程范式。它基于轻松表达数据流和自动传播变化的能力。
- en: 'Let''s explore this in more depth:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨这个问题：
- en: '**Data flows** (or data streams): In reactive programming, we want to think
    about variables as "values that change over time". For example, this could be
    a mouse position, user click or data coming via WebSockets. Basically, any event-based
    system can be considered a data stream.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据流**（或数据流）：在响应式编程中，我们希望将变量视为“随时间变化的值”。例如，这可以是鼠标位置、用户点击或通过 WebSocket 传入的数据。基本上，任何基于事件的系统都可以被视为数据流。'
- en: '**Propagation of change**: A very nice example is a spreadsheet editor. If
    we set the value of a single cell to `A1 = A2 + A3`, this means that every change
    to cells `A2` and `A3` will be propagated to `A1`. In programmers'' speech, this
    corresponds to the observer design pattern where `A2` and `A3` are observables
    and `A1` is an observer. We''ll talk about the observer pattern again later in
    this chapter.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变化的传播**：一个非常合适的例子是电子表格编辑器。如果我们把单个单元格的值设置为 `A1 = A2 + A3`，这意味着对单元格 `A2` 和
    `A3` 的任何更改都将传播到 `A1`。在程序员的用语中，这对应于观察者设计模式，其中 `A2` 和 `A3` 是可观察的，而 `A1` 是观察者。我们将在本章后面再次讨论观察者模式。'
- en: '**Easily express data flows**: This is related mostly to libraries we use rather
    than to the language itself. It means that, if we want to use reactive programming
    effectively, we need to be able to manipulate data streams easily. This principle
    also suggests that reactive programming falls under the category of declarative
    paradigms.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松表达数据流**：这与我们使用的库有关，而不仅仅是与语言本身有关。这意味着，如果我们想有效地使用响应式编程，我们需要能够轻松地操作数据流。这个原则还表明，响应式编程属于声明性范式类别。'
- en: As we can see, the definition is very broad.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，定义非常广泛。
- en: The first part about data flows and propagation of change looks like the observer
    design pattern with iterables. Expressing data flows with ease could be done with
    functional programming. This all basically describes what we've already seen in
    this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据流和变化传播的第一部分看起来像迭代器的观察者设计模式。使用函数式编程轻松表达数据流是可以做到的。这一切基本上描述了我们已经在本章中看到的内容。
- en: The main differences to the observer pattern are how we think and manipulate
    with data streams. In previous examples, we always worked with arrays as inputs,
    which are synchronous, while data streams can be both synchronous and asynchronous.
    From our point of view, it doesn't matter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与观察者模式的主要区别在于我们如何思考和操作数据流。在先前的例子中，我们总是以数组作为输入进行工作，这些数组是同步的，而数据流可以是同步的也可以是异步的。从我们的角度来看，这并不重要。
- en: 'Let''s see what a typical implementation of the observer pattern might look
    like in PHP:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看观察者模式在 PHP 中的典型实现可能是什么样子：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to be notified about any changes made by the Observable, we need another
    class called `Observer` that subscribes to an Observable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知任何由可观察者做出的更改，我们需要另一个名为 `Observer` 的类，它订阅了一个可观察者：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, a typical usage might look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个典型的用法可能如下所示：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This example will print two messages to the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在控制台打印出两条消息：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This almost follows how we defined the reactive programming paradigm. A data
    stream is a sequence of events coming from an Observable, and changes are propagated
    to all listening observers. The last point we mentioned above - being able to
    easily express data flows - isn't really there. What if we wanted to filter out
    all events that don't match a particular condition, just like we did in the examples
    with `array_filter()` and functional programming? This logic would have to go
    into each `Observer` class implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎遵循我们定义反应式编程范式的定义。数据流是从可观察者来的事件序列，变化被传播到所有监听观察者。我们上面提到的最后一个点——能够轻松表达数据流——实际上并不存在。如果我们想过滤掉所有不符合特定条件的事件，就像我们在`array_filter()`和函数式编程的示例中所做的那样，该怎么办？这种逻辑必须放入每个`Observer`类的实现中。
- en: The principles of reactive programming are actually very common in some libraries.
    We'll have a look at three of them and see how these relate to what we've just
    learned about reactive and functional programming.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程的原则实际上在一些库中非常常见。我们将查看其中的三个，并看看它们如何与我们刚刚学到的反应式和函数式编程相关。
- en: jQuery Promises
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery Promises
- en: 'Probably every web developer has used jQuery at some point. A very handy way
    of avoiding so-called **callback hell** is using Promises when dealing with asynchronous
    calls. For example, calling `jQuery.ajax()` returns a `Promise` object that is
    resolved or rejected when the AJAX call has finished:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可能每个Web开发者都曾在某个时候使用过jQuery。在处理异步调用时，使用Promise来避免所谓的**回调地狱**是一个非常方便的方法。例如，调用`jQuery.ajax()`返回一个`Promise`对象，当AJAX调用完成时解决或拒绝：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `Promise` object represents a value in the future. It's non-blocking (asynchronous),
    but lets us handle it in a declarative approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Promise`对象代表未来的一个值。它是非阻塞的（异步的），但允许我们以声明性的方式处理它。
- en: 'Another useful use case is chaining callbacks, forming a chain, where each
    callback can modify the value before propagating it further:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的用例是链式回调，形成一个链，其中每个回调都可以在进一步传播之前修改值：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we have a single source which is the `functionReturningAPromise()`
    call, and three callbacks where only the last one prints the value that resolved
    the Promise. We can see that the number `42` was modified twice when going through
    the chain of callbacks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个单一的资源，即`functionReturningAPromise()`调用，以及三个回调，只有最后一个打印出解决Promise的值。我们可以看到，当通过回调链传递时，数字`42`被修改了两次：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reactive programming, we'll use a very similar approach to Promises, but
    while a `Promise` object is always resolved only once (it carries just one value);
    data streams can generate multiple or even an infinite number of values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式编程中，我们将使用与Promise非常相似的方法，但`Promise`对象总是只解决一次（它只携带一个值）；数据流可以生成多个或甚至无限多个值。
- en: Gulp streaming build system
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gulp流式构建系统
- en: 'The Gulp build system has become the most popular build system in JavaScript.
    It''s completely based on streams and manipulating them. Consider the following
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp构建系统已经成为JavaScript中最受欢迎的构建系统。它完全基于流和流操作。考虑以下示例：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a stream of files that match the predicate `src/*.js`, concats
    all of them together and finally writes one single file to `build/all.min.js`.
    Does this remind you of anything?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个匹配谓词`src/*.js`的文件流，将所有这些文件连接在一起，最后将一个单独的文件写入`build/all.min.js`。这让你想起了什么吗？
- en: This is the same declarative and functional approach we used above, when talking
    about functional programming in PHP. In particular, this `concat()` function could
    be replaced with PHP's `array_reduce()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们上面在谈论PHP中的函数式编程时使用的相同声明性和功能性方法。特别是，这个`concat()`函数可以用PHP的`array_reduce()`来替换。
- en: 'Streams in gulp (aka vinyl-source-stream) can be modified in any way we want.
    We can, for example, split a stream into two new streams:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: gulp中的流（即vinyl-source-stream）可以被修改成我们想要的任何方式。例如，我们可以将一个流拆分为两个新的流：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, we can merge two streams and uglify (minify and obfuscate the source code)
    into one stream:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以合并两个流并将它们压缩（最小化和混淆源代码）成一个流：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This stream manipulation corresponds very well to the last concept we used to
    define the reactive programming paradigm - express data flows with ease - while
    it's both functional and declarative.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流操作与我们在定义反应式编程范式时使用的最后一个概念非常吻合——轻松表达数据流——同时它既功能性强又声明性强。
- en: EventDispatcher component in PHP
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的EventDispatcher组件
- en: Probably every PHP framework comes with some type of event-driven component
    to notify various different parts of an application using events.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可能每个 PHP 框架都附带某种类型的事件驱动组件，用于通过事件通知应用程序的各个不同部分。
- en: One such component comes with the Symfony framework out-of-the-box ( [https://github.com/symfony/event-dispatcher](https://github.com/symfony/event-dispatcher)
    ). It's an independent component that allows subscribing and listening to events
    (the observer pattern).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个组件是 Symfony 框架自带的功能（[https://github.com/symfony/event-dispatcher](https://github.com/symfony/event-dispatcher)）。它是一个独立的组件，允许订阅和监听事件（观察者模式）。
- en: 'Event listeners can be later grouped by the events they subscribe to and can
    also be assigned custom tags, as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器可以后来根据它们订阅的事件进行分组，也可以分配自定义标签，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This principle is very similar to Zend\EventManager used in Zend Framework.
    It is just another variation of the Observable - observer combination.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则与在 Zend Framework 中使用的 Zend\EventManager 非常相似。它只是可观察者-观察者组合的另一种变体。
- en: We'll come back to Symfony `EventDispatcher` component in  [Chapter 4](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 4. Reactive versus a Typical Event-Driven Approach") , *Reactive vs a
    Typical Event-Driven approach*, where we'll explore how to apply the reactive
    programming approach to event-based systems, which should lead to simplification
    and better-organized code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章“反应式与典型事件驱动方法”中回到 Symfony `EventDispatcher` 组件，探讨如何将反应式编程方法应用于基于事件的系统，这应该会导致代码简化并更有组织性。[第
    4 章](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d "第 4 章。反应式与典型事件驱动方法")，*反应式与典型事件驱动方法*。
- en: Reactive Extensions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: Now that we've seen that the principles in the reactive programming paradigm
    aren't completely new for us, we can start thinking about how to put all this
    together. In other words, what libraries or frameworks do we really need in order
    to start writing reactive code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到反应式编程范式中的原则对我们来说并不完全陌生，我们可以开始思考如何将这些全部组合起来。换句话说，为了开始编写反应式代码，我们真正需要哪些库或框架。
- en: 'Reactive Extensions (ReactiveX or just Rx in short) are a set of libraries
    in various languages that make reactive programming easy even in languages where
    concepts of asynchronous and functional programming are clumsy, such as PHP. However,
    there''s a very important distinction:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展（ReactiveX 或简称 Rx）是在各种语言中使反应式编程变得容易的库集合，即使在异步和函数式编程概念笨拙的语言中，如 PHP。然而，有一个非常重要的区别：
- en: Reactive programming doesn't equal Reactive Extensions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程不等于反应式扩展。
- en: A Reactive Extension is a library that introduces certain principles as one
    of the possible ways to approach reactive programming. Very often, when somebody
    tells you they're using reactive programming to do something in their applications,
    they're in fact talking about a particular Reactive Extension library in their
    favorite language.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展是一个库，它将某些原则作为接近反应式编程的可能方法之一。当有人告诉你他们正在使用反应式编程在他们的应用程序中做某事时，他们实际上是在谈论他们最喜欢的语言中特定的反应式扩展库。
- en: Reactive Extensions were originally made by Microsoft for .NET and called **Rx.NET**.
    Later, it was ported by Netflix to Java as **RxJava**. Now, there are over a dozen
    supported languages, the most popular probably being **RxJS** - the JavaScript
    implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展最初由微软为 .NET 创建，称为 **Rx.NET**。后来，Netflix 将其移植到 Java，称为 **RxJava**。现在，有超过十种支持的语言，其中最受欢迎的可能就是
    **RxJS** - JavaScript 的实现。
- en: All ports follow a very similar API design, however, differences occur and we'll
    talk about them a couple of times. We'll be mostly interested in differences between
    RxPHP and RxJS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有端口都遵循一个非常相似的 API 设计，然而，差异仍然存在，我们将在几个地方讨论它们。我们将主要关注 RxPHP 和 RxJS 之间的差异。
- en: RxPHP is mostly uncharted territory. A more typical environment where we encounter
    asynchronous events is JavaScript, so we'll first demonstrate examples in JavaScript
    (and RxJS 5), and afterwards we will have a look at RxPHP.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 主要是一片未知的领域。我们遇到异步事件的更典型环境是 JavaScript，因此我们首先将在 JavaScript（以及 RxJS 5）中演示示例，之后我们将查看
    RxPHP。
- en: Autocomplete with RxJS
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RxJS 自动完成
- en: 'Imagine we want to implement an autocomplete feature that downloads suggestions
    from Wikipedia (this example comes from the official collection of demos on RxJS''s
    GitHub page):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个自动完成功能，从维基百科下载建议（此示例来自 RxJS 的 GitHub 页面上的官方演示集合）：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s take a closer look at how this works:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它是如何工作的：
- en: We create an Observable from the form input's `keyup` event. This function is
    built into RxJS to simplify creating Observables. We can, of course, create our
    own Observables as well.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从表单输入的 `keyup` 事件创建一个可观察对象。这个函数是内置在 RxJS 中的，用于简化可观察对象的创建。我们当然也可以创建自己的可观察对象。
- en: Apply the `map()` function. This is exactly what we have already seen above.
    Note that this `map()` function, is in fact, not `Array.map()`, but `Observable.map()`
    instead, because we're not working with arrays here.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用 `map()` 函数。这正是我们上面已经看到的内容。请注意，这个 `map()` 函数实际上不是 `Array.map()`，而是 `Observable.map()`，因为我们这里不处理数组。
- en: Chain with `filter()` method. Exactly the same case as with `map()`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `filter()` 方法进行链式操作。这与 `map()` 的情况完全相同。
- en: Method `debounceTime()` is used to limit propagating an event down the stream
    only once after a period of time. In this case, we're using 750ms, which means
    that, when the user starts typing, it won't download data from Wikipedia on every
    `keyup` event, but only after at least a 750ms delay between two events.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法 `debounceTime()` 用于限制在一段时间后只将事件向下传播一次。在这种情况下，我们使用 750ms，这意味着当用户开始输入时，它不会在每次
    `keyup` 事件时从维基百科下载数据，而只是在两个事件之间至少有 750ms 延迟之后。
- en: The `distinctUntilChanged()` method makes sure we're calling the AJAX request
    only when the value has really changed from the last time, because it makes no
    sense to download the same suggestions twice.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged()` 方法确保我们只有在值真正从上一次改变时才调用 AJAX 请求，因为下载相同的建议两次是没有意义的。'
- en: The last statement with `keyup.switchMap()` guarantees that when making multiple
    asynchronous calls, only the last one in the stream gets processed. All the others
    are dismissed. This is important because, when dealing with AJAX calls, we have
    absolutely no control over which Promise resolves first.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一条使用 `keyup.switchMap()` 的语句保证了在执行多个异步调用时，只有流中的最后一个被处理。其他所有调用都被忽略。这很重要，因为在处理
    AJAX 调用时，我们绝对无法控制哪个 Promise 首先解析。
- en: If we didn't use RxJS, this feature would require multiple state variables.
    At least to keep the last value from the input, the last time the event occurred,
    and the last request value for the AJAX call. With RxJS, we can focus on what
    we want to do and not worry about its implementation details (declarative approach).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用 RxJS，这个功能将需要多个状态变量。至少需要保持输入的最后一个值、事件发生的最后时间以及 AJAX 调用的最后一个请求值。使用 RxJS，我们可以专注于我们想要做的事情，而不必担心其实现细节（声明式方法）。
- en: With Reactive Extensions, this approach fulfills all we described above about
    reactive programming, functional programming and also, mostly, declarative programming.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式扩展，这种方法满足了我们所描述的所有关于响应式编程、函数式编程以及主要是声明式编程的内容。
- en: Mouse position on drag and drop
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拖放鼠标位置
- en: Let's have a look at a slightly more complicated example in RxJS. We want to
    track the relative mouse position from where we start dragging an HTML element,
    until we release it (`mouseup` event).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微复杂一点的 RxJS 示例。我们想要跟踪从开始拖动 HTML 元素的位置到释放它（`mouseup` 事件）的相对鼠标位置。
- en: 'Pay attention to how this example combines multiple Observables (this example
    also comes from the official collection of demos on RxJS''s GitHub page):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个例子是如何结合多个可观察对象的（这个例子也来自 RxJS 的 GitHub 页面上的官方演示集合）：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that `mousedrag` is an Observable created by calling `return mousemove(...)`
    and that it emits events only until a `mouseup` event is emitted thanks to `takeUntil(mouseup)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`mousedrag` 是通过调用 `return mousemove(...)` 创建的可观察对象，并且它只会在发出 `mouseup` 事件时停止发出事件，这是通过
    `takeUntil(mouseup)` 实现的。
- en: Normally, without RxJS and with a typical imperative approach, this would be
    even more complicated than the previous example, with more state variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果没有使用 RxJS，并且采用典型的命令式方法，这会比上一个例子更复杂，需要更多的状态变量。
- en: Of course, this requires some basic knowledge of what functions are available
    for Observables, but even without any previous experience, the code should be
    reasonably easy to understand. Yet again, the implementation details are completely
    hidden for us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要一些关于可观察对象可用函数的基本知识，但即使没有任何先前的经验，代码也应该相对容易理解。再次强调，实现细节对我们来说是完全隐藏的。
- en: Introducing RxPHP
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 RxPHP
- en: RxPHP ( [https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP)
    ) is a port of RxJS. We're going to be using Composer to handle all dependencies
    in our PHP projects. It has become a state of the art tool, so if you haven't
    used it before, download it first and check out some basic usage at  [https://getcomposer.org/](https://getcomposer.org/)
    .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP ([https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP)
    ) 是 RxJS 的一个端口。我们将使用 Composer 来处理我们 PHP 项目的所有依赖。它已经成为一个前沿的工具，所以如果你之前没有使用过它，请先下载并查看一些基本用法
    [https://getcomposer.org/](https://getcomposer.org/) 。
- en: 'Then, create a new directory and initialize a composer project:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的目录并初始化一个 Composer 项目：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Fill in the required fields by the interactive wizard and then add RxPHP as
    a dependency:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交互式向导填写所需的字段，然后添加 RxPHP 作为依赖项：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the library successfully downloads, composer will also create `autoload.php`
    file to handle all class auto-loading on demand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当库成功下载后，Composer 将创建 `autoload.php` 文件来处理所有按需类自动加载。
- en: 'Then, our code will print string lengths of different types of fruit:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的代码将打印不同类型水果的字符串长度：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In all future examples, we won't include the `autoload.php` file, to keep the
    examples as short as possible. However, it's obviously required in order to run
    the examples. If you're unsure, have a look at the source codes provided for each
    chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有未来的示例中，我们不会包括 `autoload.php` 文件，以使示例尽可能简短。然而，显然它对于运行示例是必需的。如果你不确定，请查看每个章节提供的源代码。
- en: We first created an observer - `CallbackObserver` to be precise - which takes
    three functions as arguments. These are called on the next item in the stream,
    on error and when the input stream is complete and won't emit any more items.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个观察者 - 精确地说，是 `CallbackObserver` - 它接受三个函数作为参数。这些函数在流中的下一个项目上、在错误发生时以及在输入流完成且不会发出更多项目时被调用。
- en: The advantage of the `CallbackObserver` class is that we don't need to write
    a custom observer class every time we want to handle incoming items in some special
    and not very reusable way. With `CallbackObserver`, we can just write the callables
    for signals we want to handle.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallbackObserver` 类的优势在于，我们不需要每次都编写一个自定义观察者类来以特殊且不太可重用的方式处理传入的项目。使用 `CallbackObserver`，我们只需编写我们想要处理的信号的调用者。'
- en: 'When we run this example, we''ll see:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个示例时，我们会看到：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example was very easy, but compared to the JavaScript environment, it's
    not very common to use asynchronous operations in PHP and, in case we do have
    to work asynchronously, it's probably something non-trivial. In [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit reader with
    RxPHP*, we'll use **Symfony Console component** to handle all user input from
    the command line and, where we can, use similar principles to handling mouse events
    as we saw in the two RxJS examples above.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例非常简单，但与 JavaScript 环境相比，在 PHP 中使用异步操作并不常见，如果我们确实需要异步工作，那可能是一些非平凡的事情。在 [第
    3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第 3 章。使用
    RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器*，我们将使用 **Symfony 控制台组件**来处理来自命令行的所有用户输入，并在可能的情况下，使用与上面两个
    RxJS 示例中看到类似的原理来处理鼠标事件。
- en: The JavaScript examples work very well as examples of what reactive programming
    using Reactive Extensions looks like and what its benefits are.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 示例非常适合作为使用响应式扩展进行响应式编程的示例，以及它的好处。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to know more about Reactive Extensions, head over to [http://reactivex.io/](http://reactivex.io/).
    Also, before continuing to the next chapter, you can have a look at how many different
    operators Rx supports [http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)
    and how these can be used in different languages.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于响应式扩展的信息，请访问 [http://reactivex.io/](http://reactivex.io/)。此外，在继续下一章之前，你可以查看
    Rx 支持的不同操作符 [http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)
    以及这些操作符如何在不同的语言中使用。
- en: RxPHP 1.x and RxPHP 2
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxPHP 1.x 和 RxPHP 2
- en: As of April 2017, there're two versions of RxPHP.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2017 年 4 月，RxPHP 有两个版本。
- en: The RxPHP 1.x is stable and requires PHP 5.5+. All examples in this book are
    made for RxPHP 1.x, more specifically, RxPHP 1.5+. It's API is based mostly on
    RxJS 4, but it takes some features from RxJS 5 as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 1.x 是稳定的，需要 PHP 5.5+。本书中的所有示例都是为 RxPHP 1.x 制作的，更具体地说，是 RxPHP 1.5+。它的 API
    主要基于 RxJS 4，但也借鉴了一些 RxJS 5 的功能。
- en: There's also RxPHP 2 in development, which requires PHP 7.0+. RxPHP 2 API from
    the user's perspective is almost the same as 1.x, it just makes some things easier
    (for example working with even loops, as we'll see in [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*). When we encounter any differences worth mentioning,
    we'll give them extra space.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有正在开发的 RxPHP 2，它需要 PHP 7.0+。从用户的角度来看，RxPHP 2 API 几乎与 1.x 相同，它只是使某些事情变得更容易（例如，我们在第
    6 章[part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "第 6 章。PHP
    流 API 和高阶观察者"]中将会看到，与事件循环一起工作），*PHP 流 API 和高阶观察者*）。当我们遇到任何值得注意的差异时，我们会给予它们额外的空间。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The newer RxPHP 2 was meant to be based to the PHP loop interoperability specification
    ([https://github.com/async-interop/event-loop](https://github.com/async-interop/event-loop)).
    However, the specification is still in pre-release stage and it won't be stable
    in the nearest future. For this reason, the RxPHP team decided to leave the async-interop
    support for future releases. For more information visit [https://github.com/ReactiveX/RxPHP/pull/150](https://github.com/ReactiveX/RxPHP/pull/150).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 RxPHP 2 是打算基于 PHP 循环互操作规范（[https://github.com/async-interop/event-loop](https://github.com/async-interop/event-loop)）。然而，该规范仍处于预发布阶段，并且在未来一段时间内不会稳定。因此，RxPHP
    团队决定将 async-interop 支持留给未来的版本。更多信息请访问 [https://github.com/ReactiveX/RxPHP/pull/150](https://github.com/ReactiveX/RxPHP/pull/150)。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we tried to explain the common programming paradigms used
    in most programming languages. These were: imperative, declarative and functional
    programming. We also compared the meanings of asynchronous and parallel code.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图解释在大多数编程语言中使用的常见编程范式。这些是：命令式、声明式和函数式编程。我们还比较了异步和并行代码的含义。
- en: We spent some time on practical examples of functional programming in PHP and
    its downsides, and we went through examples of some not very common features,
    such as the Closure class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间讨论 PHP 中函数式编程的实际示例及其缺点，并介绍了某些不太常见的特性的示例，例如 Closure 类。
- en: Then, we examined the definition of reactive programming and how it's related
    to all we saw previously in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考察了反应式编程的定义以及它与本章中我们之前看到的所有内容的关联。
- en: We introduced Reactive Extensions (Rx) as a library for one of the possible
    approaches to reactive programming.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将反应式扩展（Rx）介绍为一个用于反应式编程可能方法之一的库。
- en: In two examples of RxJS, we saw what working with Reactive Extensions looks
    like in practice and how this matches our definition of reactive programming.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个 RxJS 的示例中，我们看到了在实际中与反应式扩展一起工作的样子，以及这与我们反应式编程定义的匹配程度。
- en: Finally, we introduced RxPHP, which we'll use throughout this entire book. We
    also quickly talked about differences between RxPHP 1.x and RxPHP 2.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 RxPHP，这是我们将在整本书中使用的库。我们还简要地讨论了 RxPHP 1.x 和 RxPHP 2 之间的差异。
- en: In the next chapter, we'll have a closer look at various parts of the RxPHP
    library and talk more about the principles used in Reactive Extensions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 RxPHP 库的各个部分，并更多地讨论在反应式扩展中使用的原则。
