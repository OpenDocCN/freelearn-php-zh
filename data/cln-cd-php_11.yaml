- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Continuous Integration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'You have learned the theory about writing clean **PHP: Hypertext Preprocessor**
    (**PHP**) code, and you now know the necessary tools and metrics that help us
    to achieve and keep to high quality levels. However, what is still missing is
    the integration of all these technologies into a workflow that facilitates your
    daily work.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了关于编写干净的 **PHP：超文本预处理器**（**PHP**）代码的理论，并且现在您知道必要的工具和指标，这些工具和指标帮助我们实现并保持高质量水平。然而，仍然缺少的是将这些技术集成到一个便于您日常工作的工作流程中。
- en: In the following pages, we will elaborate on **continuous integration** (**CI**)
    and learn by example how to set up a simple but effective automated workflow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面中，我们将详细阐述**持续集成**（**CI**）并通过示例学习如何设置一个简单但有效的自动化工作流程。
- en: Furthermore, we will show you how to set up a selection of code quality tools
    locally in a way that they support you the most, without having to manually run
    them. Additionally, we will tell you some best practices about how to add these
    workflows to an existing project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将向您展示如何在本地上设置一系列代码质量工具，以便它们以最支持您的方式工作，而无需手动运行它们。此外，我们还将告诉您一些关于如何将这些工作流程添加到现有项目中的最佳实践。
- en: 'The main topics we will cover are listed here:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主要主题如下：
- en: Why you need CI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要 CI
- en: The build pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建管道
- en: Building a pipeline with GitHub Actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 构建管道
- en: Your local pipeline—Git hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的本地管道——Git 钩子
- en: Excursion—Adding CI to existing software
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索——将 CI 添加到现有软件中
- en: An outlook on **continuous delivery** (**CD**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 **持续交付**（**CD**）的展望
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Additional to the setup of the previous chapters, you will require a GitHub
    account to be able to follow all examples. This will come with no additional costs,
    though, as we are only using the free plan.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章的设置外，您还需要一个 GitHub 账户才能跟随所有示例。不过，这不会带来额外的费用，因为我们只使用免费计划。
- en: 'The example application that we will use in this chapter can be downloaded
    from the GitHub repository to this book: [https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application](https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将使用的示例应用程序可以从本书的 GitHub 仓库下载：[https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application](https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application)。
- en: Why you need CI
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你需要 CI
- en: Writing software is a time-consuming and thus costly process. If you develop
    software for fun, it will “only” cost you your leisure time. If you work for a
    company (be it as a contractor or full-time employee), the time is even more valuable,
    as you get paid for it. As a matter of fact, companies want to reduce costs, and
    thus they do not want to spend more money on a feature than necessary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件是一个耗时且因此昂贵的流程。如果您为了乐趣开发软件，它“仅”会消耗您的休闲时间。如果您为一家公司工作（无论是作为承包商还是全职员工），时间就更加宝贵，因为您为此获得报酬。事实上，公司希望降低成本，因此他们不希望在一个功能上花费比必要的更多钱。
- en: A big part of our daily work is to fix defects. Delivering bug-free software
    is something that probably all developers would like to achieve. We do not make
    mistakes deliberately, yet they will always happen. There are ways, however, to
    reduce the costs of bugs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常工作中的一大部分是修复缺陷。交付无缺陷的软件是所有开发者可能都希望实现的目标。我们并不是故意犯错误，但它们总会发生。然而，有一些方法可以降低错误成本。
- en: The costs of a bug
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误的成本
- en: 'A bug is considerably costly because it adds no value to the product. Therefore,
    we aim to catch these bugs as early as possible—the earlier we catch them, the
    fewer costs they will cause. The following screenshot visualizes how the costs
    to fix a bug increase significantly the later it appears in the development process:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误相当昂贵，因为它对产品没有任何价值。因此，我们的目标是尽早捕捉这些错误——我们捕捉得越早，它们造成的成本就越少。以下截图展示了修复一个错误的成本如何在开发过程中出现得越晚而显著增加：
- en: '![Figure 11.1: Estimated relative costs of fixing a bug based on the time of
    its detection'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1：根据检测时间估计修复一个错误的相对成本]'
- en: '](img/Figure_11.1_B19050.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.1_B19050.jpg]'
- en: 'Figure 11.1: Estimated relative costs of fixing a bug based on the time of
    its detection'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：根据检测时间估计修复一个错误的相对成本
- en: But what is the reason for the massive cost increase over time? And why do bugs
    even cost money?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么原因导致成本随时间大幅增加？为什么错误甚至要花钱？
- en: 'In the early stages, costs mainly arise from the required time to resolve the
    issue. If a bug could have been avoided just by better requirements, for example,
    then this requires less effort as it was discovered during the manual testing.
    If a bug was found in production, many people are involved in fixing it: first,
    a helpdesk employee needs to acknowledge the bug reported by a customer and pass
    it over to the **quality assurance** (**QA**) engineer, who reproduces it and
    writes a proper bug ticket.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期阶段，成本主要来自于解决问题所需的时间。如果通过更好的需求就能避免一个错误，例如，那么在手动测试期间发现它所需的努力就较少。如果在生产中发现了一个错误，那么很多人都会参与修复它：首先，客服人员需要确认客户报告的错误并将其转交给**质量保证**（**QA**）工程师，该工程师会重现错误并编写适当的错误报告。
- en: This ticket then gets assigned to the product manager, who, after taking time
    to reproduce and verify the defect as well, plans it in for the next sprint. The
    ticket eventually gets assigned to one developer, who will need some time to reproduce
    and fix it. But it is not over here because the bug fix probably requires a code
    review from another developer and gets double-checked from the product manager
    or QA engineer as well before it can finally be released.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个工单会被分配给产品经理，他会在花时间重现和验证缺陷之后，将其计划到下一个迭代中。最终，这个工单会被分配给一位开发者，他将需要一些时间来重现和修复它。但事情还没有结束，因为错误修复可能需要另一位开发者的代码审查，并且在最终发布之前还需要产品经理或QA工程师的双重检查。
- en: Once “escaped” from the developer’s local environment, all this overhead raises
    the costs of the defect significantly. Additionally, if the bug is already in
    production, it can lead to customers not wanting to use the product anymore because
    they are no longer happy with it. This is called **customer churn**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“逃离”开发者的本地环境，所有这些开销都会显著提高缺陷的成本。此外，如果错误已经存在于生产环境中，它可能导致客户不再愿意使用该产品，因为他们对它不再满意。这被称为**客户流失**。
- en: Even if you are not working on a commercial product, but—for example—on an open
    source project, the concept can be translated into time or effort. A bug will
    lead to an issue report that you first need to read and understand, probably asking
    some more questions, and waiting for the ticker author to reply. If your software
    is too buggy, people will use it less, and all your previous efforts might have
    been in vain at some point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在商业产品上工作，而是在例如开源项目上工作，这个概念也可以转化为时间或努力。一个错误会导致一个问题报告，你首先需要阅读和理解它，可能还会提出更多问题，并等待错误报告作者回复。如果你的软件错误太多，人们就会少用，你之前所有的努力可能在某个时候都白费了。
- en: How to prevent bugs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何防止错误
- en: Fortunately, we now have a whole toolbox at your side that can help us find
    bugs in your code before somebody else does. We just have to use it—and this is
    already a problem because we developers are usually lazy people.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们现在有一整套工具箱在您身边，可以帮助我们在别人之前找到代码中的错误。我们只需要使用它——这本身就是一个问题，因为我们开发者通常是懒惰的人。
- en: 'Of course, you could run all the tools manually before every deploy. Let us
    say you want to deploy some code to production. After merging the code into the
    `main` branch, the following steps should be executed to ensure that no broken
    code gets delivered to production:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在每次部署之前手动运行所有工具。让我们假设你想要将一些代码部署到生产环境中。在将代码合并到`main`分支后，应执行以下步骤以确保不会将损坏的代码交付到生产环境中：
- en: Using the PHP linter to ensure the syntactical correctness of the code
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PHP代码检查器以确保代码的语法正确性
- en: Executing a code style checker and fixer to keep the code styling aligned
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码风格检查器和修复器以保持代码风格一致
- en: Finding potential issues using static code analysis
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态代码分析查找潜在问题
- en: Execution of all automated test suites to ensure your code still works
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所有自动化测试套件以确保你的代码仍然工作
- en: Creating reports for the used code quality metrics
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为使用的代码质量指标创建报告
- en: Cleaning up the build folder and creating an archive of the code to deploy
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理构建文件夹并创建要部署的代码存档
- en: This is quite a list of things to keep in mind. Nobody would do this over a
    longer period without making mistakes at some point, so, naturally, you would
    start writing scripts that help you to execute these steps in one go. This is
    already a good improvement, and we will also make use of it a bit further on in
    this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要记住的相当长的清单。没有人会在更长的时间内不犯错误，所以，自然地，你会开始编写脚本以帮助你在一次操作中执行这些步骤。这已经是一个很好的改进，我们将在本章的后面也稍微利用一下它。
- en: Introducing CI
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入持续集成（CI）
- en: Running all the steps from the previous section in your local environment will
    take some time, and during the checks run, you can hardly work on anything else,
    so you have to wait until they are finished. So, why not load this whole workflow
    onto another, dedicated server?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地环境中运行上一节中所有步骤将花费一些时间，并且在检查运行期间，你几乎无法做其他任何事情，所以你必须等待它们完成。那么，为什么不把这个整个工作流程加载到另一个专用服务器上呢？
- en: 'This is precisely what CI does: it describes the automated process of putting
    all necessary components of your application together into a **deliverable** so
    that it can be deployed to the wanted environments. During the process, automated
    checks will ensure the overall quality of the code. It is important to keep in
    mind that if one of the checks fails, the whole build will be considered as failed.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 CI 所做的：它描述了将你应用程序的所有必要组件自动组合成一个**可交付产品**的过程，以便它可以部署到所需的环境。在这个过程中，自动检查将确保代码的整体质量。重要的是要记住，如果其中一个检查失败，整个构建将被视为失败。
- en: There are many **CI tools** available, such as Jenkins, which is usually self-hosted
    (that is, operated by you or someone in your team or company). Or, you can choose
    paid services such as GitHub Actions, GitLab CI, Bitbucket Pipelines, or CircleCI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 **CI 工具** 可用，例如 Jenkins，它通常是自己托管的（也就是说，由你或你的团队或公司中的某人运营）。或者，你可以选择付费服务，如
    GitHub Actions、GitLab CI、Bitbucket Pipelines 或 CircleCI。
- en: You will often read the abbreviation *CI/CD*, and we will also use it throughout
    this book. **CD** stands for **continuous delivery**, a concept that we will cover
    at the end of this chapter. For now, you do not need to care about it, though.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到缩写 *CI/CD*，我们也会在这本书中一直使用它。**CD** 代表 **持续交付**，这是一个我们将在本章末尾讨论的概念。现在，你不需要关心它。
- en: 'Setting up one of these tools sounds like a lot of work, but it also has some
    great benefits, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些工具之一听起来像是一项繁重的工作，但它也有一些显著的优点，例如以下这些：
- en: '**Scalability**: If you work in a team, using the local setup will quickly
    cause problems. Any changes to the build process would need to be done on the
    computer of every developer. Although the build script would be part of your repository,
    people may forget to pull the latest changes from it before deploying, or something
    else might go wrong.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果你在一个团队中工作，使用本地设置会很快引起问题。对构建过程的任何更改都需要在每个开发者的计算机上完成。尽管构建脚本将是你的存储库的一部分，但人们可能会忘记在部署之前从其中拉取最新更改，或者可能发生其他问题。'
- en: '**Speed**: Automated tests or static code analysis is a pretty resource-consuming
    job. Although today’s computers are powerful, they have to do a lot of concurring
    tasks, and you do not want to additionally run a build pipeline on your local
    system. **CI/CD servers** are doing only this one job, and they are usually doing
    it fast. And even if they are slow, they still take the load from your local system.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：自动测试或静态代码分析是一项相当消耗资源的任务。尽管今天的计算机很强大，但它们必须执行许多并发任务，你不希望在你的本地系统上额外运行构建管道。**CI/CD
    服务器**只做这项工作，而且它们通常做得很快。即使它们速度较慢，它们仍然会从你的本地系统卸载负载。'
- en: '**Non-blocking**: You need a build environment to run all the tools and checks
    on your code. Using your local development environment for this will simply block
    it for the duration of the build, especially when you use slower test types such
    as integration or **end-to-end** (**E2E**) tests. Running two environments on
    your local system—one for development and one for CI/CD—is not recommended, as
    you will quickly end up in a configuration hell (just think of blocking a database
    of web server ports).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞**：你需要一个构建环境来运行你代码上的所有工具和检查。使用你的本地开发环境来做这件事将简单地阻塞它，直到构建完成，尤其是当你使用较慢的测试类型，如集成测试或**端到端**（**E2E**）测试时。在你的本地系统上运行两个环境——一个用于开发，一个用于
    CI/CD——是不推荐的，因为你很快就会陷入配置地狱（想想阻塞数据库或网络服务器端口）。'
- en: '**Monitoring**: Using a dedicated CI/CD server will let you keep an overview
    of who deployed what and when. Imagine that your production system is suddenly
    broken—using a CI/CD server, you can immediately see what the last changes have
    been and deploy the previous version of your application with a few clicks. Furthermore,
    CI/CD tools keep you up to date and inform you—for example—via email or your favorite
    messenger application about any build and deploy activities.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：使用专门的 CI/CD 服务器将让你对谁部署了什么以及何时部署有一个全面的了解。想象一下，如果你的生产系统突然出现故障——使用 CI/CD
    服务器，你可以立即看到最新的更改，并通过几个点击部署你应用程序的上一版本。此外，CI/CD 工具会让你保持最新状态，并通过电子邮件或你喜欢的消息应用等方式通知你任何构建和部署活动。'
- en: '**Handling**: A handwritten deployment script will surely do the work, but
    it takes a lot of time to make it as comfortable and flexible as a modern CI/CD
    solution. Plus, if you go with the business standards, it is much more likely
    that other developers of your team will already have experience with it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：一个手写的部署脚本当然可以完成工作，但让它变得像现代 CI/CD 解决方案一样舒适和灵活需要花费很多时间。此外，如果你遵循业务标准，那么你的团队中的其他开发者很可能已经对它有经验。'
- en: The preceding points hopefully give you an idea of how much you will benefit
    from using CI. An integral part of each CI/CD tool is the so-called build pipeline,
    which we will explain in detail in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的几点可能让你对使用 CI 将会受益多少有一个概念。每个 CI/CD 工具的一个基本组成部分是所谓的构建管道，我们将在下一节中详细解释。
- en: The build pipeline
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建管道
- en: 'In the previous section, we listed the many necessary steps to make our code
    ready to be shipped to production. In the context of CI, a combination of these
    steps is what we call the **build pipeline**: it takes the input (in our case,
    all the application code), runs it through several tools, and creates so-called
    **build artifacts** out of it. They are the outcome of a build—usually, this includes
    the **deliverable** (a package of the application code that is ready to be moved
    to the desired environment), plus additional data, such as build logs, reports,
    and so on.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们列出了许多必要的步骤，以便使我们的代码准备好被部署到生产环境中。在 CI 的背景下，这些步骤的组合就是我们所说的**构建管道**：它接收输入（在我们的案例中，是所有应用程序代码），通过几个工具运行它，并从中创建所谓的**构建工件**。它们是构建的结果——通常，这包括**可交付成果**（一个准备移动到目标环境的应用程序代码包），以及额外的数据，如构建日志、报告等。
- en: 'The following diagram gives you a schematic overview of what a typical build
    pipeline could look like. Since it is not executed in your local environment,
    it requires two additional steps: *creating a build environment* and *building
    an application*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表为你提供了一个典型的构建管道的概要图。由于它不是在本地环境中执行的，因此需要额外的两个步骤：*创建构建环境*和*构建应用程序*：
- en: '![Figure 11.2: Schema of a CI pipeline'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2：CI 管道架构图'
- en: '](img/Figure_11.2_B19050.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B19050.jpg)'
- en: 'Figure 11.2: Schema of a CI pipeline'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：CI 管道架构图
- en: Other languages in the pipeline
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的其他语言
- en: In this book, we will only have a look at the PHP-related parts of the pipeline,
    yet a modern web application does not only consist of PHP. Especially for the
    frontend-facing code, there is another whole universe of tools that needs to be
    part of the pipeline, too. Yet in the end, the process is very similar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们只会查看与管道相关的 PHP 部分，但一个现代的 Web 应用程序不仅仅由 PHP 组成。特别是对于面向前端的代码，还有另一个完整的工具集需要成为管道的一部分。然而，最终的过程是非常相似的。
- en: In the next sections, we will go into more detail about every build stage. We
    will keep it theoretical at first, and then give examples of technical implementation
    later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地介绍每个构建阶段。一开始我们将保持理论性，然后在本章的后面部分给出技术实现的例子。
- en: 'Stage 1: Build project'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 阶段：构建项目
- en: 'The CI pipeline requires a dedicated build instance of our application, where
    we can run all tools and checks on it isolated. This can roughly be divided into
    two steps: creating a build environment and running the necessary build tools.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CI 管道需要一个专门的应用程序构建实例，我们可以在其中运行所有工具和检查，使其隔离。这可以大致分为两个步骤：创建构建环境和运行必要的构建工具。
- en: Creating a build environment
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建构建环境
- en: To build an application somewhere else than on the local development system,
    we first need to create a **build environment**. How exactly the environment is
    provided depends on the used CI/CD tool. This can either be a dedicated server
    that offers separated workspaces for every project, or a completely containerized
    Docker environment, which is spun up every time you require it and only lasts
    for the duration of the build.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地开发系统之外构建应用程序，我们首先需要创建一个**构建环境**。具体如何提供环境取决于所使用的CI/CD工具。这可以是一个为每个项目提供独立工作空间的专用服务器，或者是一个完全容器化的Docker环境，每次需要时都会启动，并且只持续构建的持续时间。
- en: Once a build environment exists, we need to download all the source code there,
    but without external packages or other dependencies for now. Most likely, your
    code will be stored in a Git repository and either hosted on a private Git server,
    or a commercial service. Downloading a copy of a specific branch of a repository
    is called **checkout**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在构建环境，我们需要在那里下载所有源代码，但现在不要下载外部包或其他依赖项。很可能是你的代码存储在Git仓库中，并托管在私有Git服务器上或商业服务上。下载仓库特定分支的副本称为**检出**。
- en: We have to pay attention to which branch of the repository the code gets checked
    out from. This depends on what you want to build. If you intend to check the code
    of a `main` branch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意代码是从仓库的哪个分支检出的。这取决于你想要构建什么。如果你打算检查`main`分支的代码。
- en: Main versus master branch
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 主分支与master分支
- en: Throughout the history of computers, the terms *master* and *slave* have been
    widely used, be it for hard disk configuration, database replication, or—of course—Git.
    However, these terms are harmful to many people, so the `main` branch simply *main*
    instead of *master* nowadays. You will still find repositories out there that
    use the old branch name. In this book, though, we will stick with the new terminology.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的历史中，术语*master*和*slave*被广泛使用，无论是硬盘配置、数据库复制，还是当然——Git。然而，这些术语对许多人来说是有害的，所以现在的`main`分支简单地称为*main*而不是*master*。你仍然会找到使用旧分支名称的仓库。然而，在这本书中，我们将坚持使用新的术语。
- en: Do not worry, however, if your project is not hosted using Git—this step is
    still necessary because we need to get the code on the CI/CD server. Be it via
    Git, Mercurial, **Subversion** (**SVN**), or even direct file download, it does
    not matter in the end. The outcome of this step is to have the code we want to
    deploy readily available on the CI/CD server so that we can start installing the
    dependencies in the next step.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的项目不是使用Git托管，不要担心——这一步仍然是必要的，因为我们需要在CI/CD服务器上获取代码。无论是通过Git、Mercurial、**Subversion**（**SVN**）还是甚至直接文件下载，最终并不重要。这一步骤的结果是我们想要的代码在CI/CD服务器上准备好，以便我们可以开始安装依赖项。
- en: Building the application
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'Building the application is similar to installing it on a new system. In the
    previous step, we made sure that the source code is available in the environment.
    In this step, we need to execute any required build steps. This usually includes
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序类似于在新系统上安装它。在上一个步骤中，我们确保源代码在环境中可用。在这个步骤中，我们需要执行任何必要的构建步骤。这通常包括以下内容：
- en: '**Installing external dependencies**: Your repository should only contain your
    own code, with no external dependencies. These we manage, for example, via Composer
    or the **PHAR Installation and Verification Environment** (**Phive**).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装外部依赖项**：你的仓库应只包含你自己的代码，不包含外部依赖项。我们通过Composer或**PHAR安装和验证环境**（**Phive**）等来管理这些依赖项。'
- en: '`.env`, for example) during this stage.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，例如`.env`文件。
- en: '**Preparing the test database**: To run integration or E2E tests, the build
    instance needs a working database. Commonly, this is done by creating a test database,
    importing the database schema, running any additional database migrations, and—finally—populating
    the database with test data.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备测试数据库**：为了运行集成或端到端测试，构建实例需要一个可工作的数据库。通常，这是通过创建测试数据库、导入数据库模式、运行任何额外的数据库迁移，并最终用测试数据填充数据库来完成的。'
- en: To reduce the build time, many modern CI/CD tools offer caching. If activated,
    they will keep the dependencies in temporary storage after the first download.
    It is generally a good idea to turn this on, if not activated by default.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少构建时间，许多现代CI/CD工具提供了缓存功能。如果已启用，它们将在第一次下载后将依赖项保存在临时存储中。如果不默认启用，通常是一个好主意将其打开。
- en: Stage 2 – Code analysis
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二阶段——代码分析
- en: We covered code quality tools in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*,
    Code Quality Tools,* in detail. Now, it is time to add these tools to our pipeline
    to ensure that they will be executed for every change that gets introduced.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第七章*](B19050_07.xhtml#_idTextAnchor084)*，代码质量工具*中详细介绍了代码质量工具。现在，是时候将这些工具添加到我们的流程中，以确保它们会在引入的每个更改时执行。
- en: PHP linter
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP代码检查器
- en: 'If you merge code into another branch, it can always happen that the code breaks.
    Git has very sophisticated merge algorithms, but still, it cannot do magic. Given
    that you have a test suite with high coverage, some tests will surely break if
    there were a syntax error that had been caused by the merge. So, why should we
    run this extra step? We recommend it because the PHP linter has two advantages:
    it runs very fast, and it will check all PHP files, no matter if there are tests
    for them or not.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将代码合并到另一个分支中，代码总是可能断裂。Git有非常复杂的合并算法，但仍然不能做魔法。考虑到你有一个高覆盖率的测试套件，如果合并导致了语法错误，一些测试肯定会失败。那么，为什么我们要运行这个额外的步骤呢？我们推荐这样做，因为PHP代码检查器有两个优点：它运行得非常快，并且会检查所有PHP文件，无论是否有测试。
- en: We want our pipeline to fail fast if any issues have been detected. Therefore,
    before you execute any long-running tasks, it makes sense to run a quick syntax
    check in the beginning. They would break in any case, and you would lose some
    valuable time. As a rule of thumb, the faster the check runs, the earlier it will
    appear in the pipeline.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的管道在检测到任何问题后快速失败。因此，在执行任何长时间运行的任务之前，在开始时运行一个快速的语法检查是有意义的。无论如何，它们都会中断，你也会浪费一些宝贵的时间。作为一个经验法则，检查运行得越快，它就会越早出现在管道中。
- en: Code style checker
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码风格检查器
- en: After checking the code syntax, it is time to check the code style. This operation
    is fast too, so it makes sense to run it early in the pipeline. For our example,
    we will go with the **PHP Coding Standards Fixer** (**PHP-CS-Fixer**), which we
    already introduced in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*, Code Quality
    Tools*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查代码语法之后，是时候检查代码风格了。这个操作也很快，所以在管道的早期运行它是有意义的。在我们的例子中，我们将使用**PHP编码标准修复器**（**PHP-CS-Fixer**），这是我们已经在[*第七章*](B19050_07.xhtml#_idTextAnchor084)*，代码质量工具*中介绍过的。
- en: 'There is a subtle but important difference between running PHP-CS-Fixer locally
    and in the CI/CD pipeline: for the latter, we will only use it to check the code,
    but not to fix it. We do not want the pipeline to *change* our code, just to *analyze*
    it. In other words, our pipeline will only check if the code is correctly formatted
    (according to the rules we defined), but it will not attempt to fix it automatically;
    if any of the rules are violated, the build has failed.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行PHP-CS-Fixer和在CI/CD管道中运行之间有一个微妙但重要的区别：对于后者，我们只会用它来检查代码，但不会修复它。我们不希望管道*更改*我们的代码，只是*分析*它。换句话说，我们的管道只会检查代码是否正确格式化（根据我们定义的规则），但不会尝试自动修复；如果违反了任何规则，构建就会失败。
- en: No rules are saying that the CI/CD pipeline should not change the code. However,
    it adds complexity to automatically commit the changes to the repository during
    the process. Moreover, it requires a very well-tested application, and you need
    to trust that the tool of your choice does not break anything. Usually, they work
    well, but do you want to risk it?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规则说CI/CD管道不应该更改代码。然而，在过程中自动提交更改到仓库会增加复杂性。此外，它需要一个经过充分测试的应用程序，并且你需要信任你选择的工具不会破坏任何东西。通常，它们工作得很好，但你愿意冒险吗？
- en: In your local environment, it makes sense to run the fixer alongside the code
    style checker. We will discuss the local setup in one of the next sections of
    this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地环境中，同时运行修复器和代码风格检查器是有意义的。我们将在本章的下一节中讨论本地设置。
- en: Static code analysis
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: At this point, we know that our code is syntactically correct and formatted
    according to our rules. Both previous checks are usually performed quickly, so
    our build would fail early if any of those easy-to-detect problems had occurred.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们知道我们的代码在语法上是正确的，并且按照我们的规则进行了格式化。这两个之前的检查通常都很快，所以如果发生了那些容易检测到的问题，我们的构建过程会在早期失败。
- en: 'Now, it is time to run the slower tasks. The static code analysis usually takes
    a bit longer than the two previous ones, but it is by far not as slow as running
    the automated tests. Essentially, this step is not that different from the linting
    and code style checking: if the rules we have defined earlier are violated, the
    build will fail.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候运行较慢的任务了。静态代码分析通常比前两个阶段花费的时间要长一些，但它远远没有运行自动测试那么慢。本质上，这一步与代码检查和代码风格检查没有太大区别：如果我们之前定义的规则被违反，构建将失败。
- en: If you are introducing CI to an existing project, the challenge is to find the
    sweet spot in error reporting. On the one hand, you want to keep the developers
    happy and not force them to fix dozens of issues introduced by other developers
    on every file they touch. On the other hand, you need to set the threshold tight
    enough to enforce at least some refactoring with every code change.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在将CI引入现有项目，挑战在于找到错误报告的最佳平衡点。一方面，你希望让开发者满意，不要强迫他们在每次触摸文件时修复其他开发者引入的数十个问题。另一方面，你需要设置一个足够严格的阈值，以确保每次代码更改至少进行一些重构。
- en: There is no golden rule here, unfortunately, and you need to experiment with
    the settings. At a later point, when most of the issues of the static code analysis
    reports are solved, you need to tighten the error reporting rules a little so
    that your project does not stagnate at a certain level.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这里没有金科玉律，你需要对设置进行实验。在稍后，当大多数静态代码分析报告的问题都解决后，你需要稍微收紧错误报告规则，这样你的项目就不会在某一个水平上停滞不前。
- en: Stage 3 – Tests
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段 – 测试
- en: 'Once our code has reached this point in the pipeline, we are convinced that
    it is syntactically correct, adheres to our code styling guidelines, and has no
    general flaws according to our static code analysis rules. So, we will now run
    the step in the pipeline, which usually takes the longest time: the automated
    tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码达到管道的这个阶段时，我们确信它是语法正确的，遵循我们的代码风格指南，并且根据我们的静态代码分析规则没有一般性的缺陷。因此，我们现在将运行管道中的这一步，这通常需要最长时间：自动测试。
- en: As we introduced in the previous chapter, there are more than just unit tests
    to consider. Often, a project such as a web service has at least some integration
    tests to ensure that the service is working fine as a whole, including the database
    transactions. Or, if your project is a classical web application, you might have
    an E2E test suite that utilizes a browser to virtually click through it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中介绍的，除了单元测试之外，还有更多需要考虑的。通常，像网络服务这样的项目至少有一些集成测试来确保整个服务运行良好，包括数据库事务。或者，如果你的项目是一个传统的网络应用程序，你可能有一个端到端测试套件，它使用浏览器来模拟点击。
- en: 'We want to apply the same approach here that we did for the build steps: start
    with the fast-running tests, and then continue with the slower ones. If the unit
    tests are failing already, you do not need to wait for the results of the E2E
    tests. So, for the tests, the execution order would usually be this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在这里应用与构建步骤相同的方法：从快速运行的测试开始，然后继续进行较慢的测试。如果单元测试已经失败，你不需要等待端到端测试的结果。因此，对于测试，执行顺序通常是这样的：
- en: Unit tests
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试
- en: E2E tests
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: If only one test of whatever type fails, the build will be marked as failed.
    If they all pass, we have already passed the most critical part of the pipeline.
    Our application is ready to be deployed, so now, it is time to clean up and prepare
    the deliverable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何类型的测试失败，构建将被标记为失败。如果它们都通过，我们已经通过了管道中最关键的部分。我们的应用程序准备就绪，可以部署了，现在是时候清理和准备交付物了。
- en: Stage 4 – Deploy
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4阶段 – 部署
- en: Our code has been checked thoroughly by various tools, and we are confident
    that it adheres to our standards. We can now prepare the **build artifacts** and
    finally deploy the application. Let us have a look at what needs to be done for
    this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过各种工具彻底检查了我们的代码，并且我们确信它符合我们的标准。我们现在可以准备**构建工件**，并最终部署应用程序。让我们看看为此需要做些什么。
- en: Gathering data
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集数据
- en: During the previous stages, all tools we used produced some sort of data, be
    it through writing to the **standard output** (**stdout**), or if you configured
    that, by creating reports that summarize the performed actions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的阶段，我们使用的所有工具都产生了一些数据，无论是通过写入**标准输出**（**stdout**），还是如果你配置了，通过创建总结执行操作的报告。
- en: You can, for example, upload generated reports to dedicated storage or push
    them to your repository. Or, you can use the code coverage report of PHPUnit and
    automatically create a code coverage badge from it, which you can add to the README
    of your GitHub project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以上传生成的报告到专用存储或将其推送到您的仓库。或者，您可以使用PHPUnit的代码覆盖率报告并自动从它创建一个代码覆盖率徽章，您可以将它添加到GitHub项目的README中。
- en: The most important use case, though, is to debug if any of the stages have failed.
    You can never have enough debug output in case something goes wrong, so it is
    a good idea to set the verbosity of your tools to a higher level. Your CI/CD tool
    usually takes care that everything that was written to the stdout is made available
    after the execution of the build pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，最重要的用例是调试任何阶段是否失败。在出现问题时，您永远都不可能有足够的调试输出，因此将工具的详细程度设置为较高级别是一个好主意。您的CI/CD工具通常会确保在构建管道执行后，所有写入到stdout的内容都可用。
- en: Cleanup
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理
- en: Before we upload the application somewhere, we want to make sure that it does
    not contain any unnecessary ballast. This includes removing logs or reports from
    previous stages or deleting the code quality tools. Remember, we should only deploy
    code to production that is necessary for the application to run—development tools
    such as PHPUnit are not built with security in mind ([https://phpunit.readthedocs.io/en/9.5/installation.html#webserver](https://phpunit.readthedocs.io/en/9.5/installation.html#webserver)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序上传到某个地方之前，我们想要确保它不包含任何不必要的冗余。这包括删除前一个阶段的日志或报告，或者删除代码质量工具。记住，我们只应该部署运行应用程序所必需的代码——例如PHPUnit这样的开发工具并不是以安全性为设计目标的([https://phpunit.readthedocs.io/en/9.5/installation.html#webserver](https://phpunit.readthedocs.io/en/9.5/installation.html#webserver))。
- en: Deploy
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: To deploy the code to the target environment, we need to wrap it up into an
    asset that can be easily moved there. This asset is also called a **deliverable**.
    The type we choose for the deliverable depends on how the application has to be
    deployed to production. A common type for such a deliverable is simply an archive
    of the code that has to be deployed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码部署到目标环境，我们需要将其打包成一个可以轻松移动的资产。这个资产也被称为**交付物**。我们选择的交付物类型取决于应用程序如何部署到生产环境。这种交付物的常见类型就是需要部署的代码的存档。
- en: For example, if your production environment is running on a classic on-premises
    web server, we need to create an archive of the application code, upload it to
    the target server, and extract it from there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的生产环境运行在传统的本地Web服务器上，我们需要创建应用程序代码的存档，将其上传到目标服务器，并从那里提取它。
- en: The de facto standard today is a containerized environment using Docker. Once
    the build instance has been thoroughly tested, a **Docker image** can be created
    from it. This image will then be uploaded to an **image repository** such as **Amazon
    Web Services Elastic Container Repository** (**AWS ECR**). Such an **image repository**
    hosts all your images, so they can be used to spin up new containers when needed.
    This approach paved the way for highly scalable web applications as we have them
    today, so designing your application to be **Dockerizable** from the beginning
    will pay off if your application, at some point, needs to scale.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的既定标准是使用Docker的容器化环境。一旦构建实例经过彻底测试，就可以从它创建一个**Docker镜像**。然后，这个镜像将被上传到**镜像仓库**，例如**Amazon
    Web Services Elastic Container Repository**（**AWS ECR**）。这样的**镜像仓库**托管了所有您的镜像，因此当需要时，可以使用它们启动新的容器。这种方法为今天我们所拥有的高度可扩展的Web应用铺平了道路，因此如果您的应用程序在某个时刻需要扩展，从一开始就设计应用程序为**可Docker化**的将会带来回报。
- en: Containers and images
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和镜像
- en: If you are new to Docker, the concept of containers and images can be confusing.
    In short, an image contains all the data, but is read-only and cannot be used
    alone. To make it usable in the Docker environment, it requires a container that
    contains all information from the image and offers the required functionality
    to connect to other containers of your setup. Since you can create as many containers
    as you need from an image, you can also think of it as a container template.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Docker的新手，容器和镜像的概念可能会令人困惑。简而言之，镜像包含所有数据，但它是只读的，不能单独使用。为了使其在Docker环境中可用，它需要一个包含镜像所有信息的容器，并提供连接到您设置中其他容器的所需功能。由于您可以从一个镜像创建所需数量的容器，您也可以将其视为一个容器模板。
- en: If you want to know more about Docker, we recommend you check the official documentation
    at [https://docs.docker.com/get-started/overview](https://docs.docker.com/get-started/overview).
    There are also tons of tutorials, online courses, and other information to be
    found on the internet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Docker 的信息，我们建议你查看官方文档[https://docs.docker.com/get-started/overview](https://docs.docker.com/get-started/overview)。互联网上还有大量的教程、在线课程和其他信息可以找到。
- en: We now have a good idea of what a build pipeline could look like. Before we
    start setting up our example pipeline, one more thing needs to be clarified—when
    will it be executed?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对构建管道可能的样子有了很好的了解。在我们开始设置示例管道之前，还有一件事需要明确——它将在何时执行？
- en: Integrating the pipeline into your workflow
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将管道集成到你的工作流程中
- en: After setting up all the necessary steps, we finally need to integrate the pipeline
    into your workflow. CI/CD tools usually offer you different options on when a
    pipeline gets executed. In the beginning, this can, of course, be done manually
    by clicking a button. This is not very comfortable, though. If you use hosted
    Git repositories such as GitHub, GitLab, or Bitbucket, you can connect them with
    your build pipeline and start the build whenever a PR was created or a branch
    got merged into the `main` branch.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置所有必要的步骤之后，我们最终需要将管道集成到你的工作流程中。CI/CD 工具通常会提供不同的选项来决定何时执行管道。最初，当然可以通过点击按钮手动完成。但这并不方便。如果你使用
    GitHub、GitLab 或 Bitbucket 等托管 Git 仓库，你可以将它们与你的构建管道连接起来，并在创建 PR 或分支合并到 `main` 分支时开始构建。
- en: For huge projects where the build takes hours, it is also common to run a build
    for the current code base at nighttime (so-called **nightly builds**). The developers
    then get their feedback from the pipeline the next day.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要数小时构建的大型项目，在夜间（所谓的是**夜间构建**）运行当前代码库的构建也很常见。开发者将在第二天从管道中获得反馈。
- en: Running a build requires some time, and of course, the developers should not
    sit in front of the screens and wait until they can continue with their work.
    They should rather be informed as soon as the build succeeded or failed. All CI/CD
    tools nowadays offer multiple ways to notify the developer, mostly by email and
    by messages in chat tools such as Slack or Microsoft Teams. Additionally, they
    often also offer dashboard views, where you can see the status of all the builds
    on one screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建需要一些时间，当然，开发者不应该坐在屏幕前等待，直到他们可以继续工作。他们更应该在被构建成功或失败时立即得到通知。如今，所有 CI/CD 工具都提供了多种方式来通知开发者，主要是通过电子邮件和在
    Slack 或 Microsoft Teams 等聊天工具中的消息。此外，它们通常还提供仪表板视图，你可以在一个屏幕上看到所有构建的状态。
- en: You now should have a good idea of what a build pipeline could look like for
    your project. Therefore, it is time to show you a practical example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对你的项目构建管道可能的样子有了很好的了解。因此，现在是时候向你展示一个实际示例了。
- en: Building a pipeline with GitHub Actions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 构建管道
- en: After learning about all the stages of CI, it is time to practice. Introducing
    you to all the features of one or more CI/CD tools is out of scope for this book;
    however, we still want to show you how easy it can be to set up a working build
    pipeline. To keep the barrier to entry as low as possible for you and to avoid
    any costs, we have decided to use **GitHub Actions**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 CI 的所有阶段之后，是时候进行实践了。本书的范围不包括介绍一个或多个 CI/CD 工具的所有功能；然而，我们仍然想向你展示设置一个工作构建管道是多么容易。为了尽可能降低你的入门门槛并避免任何费用，我们决定使用
    **GitHub Actions**。
- en: GitHub Actions is not a classic CI tool like Jenkins or CircleCI, but rather
    a way to build workflows around GitHub repositories. With a bit of creativity,
    you can do much more than “just” a classical CI/CD pipeline. We will only focus
    on that aspect, of course.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 不是一个像 Jenkins 或 CircleCI 这样的经典 CI 工具，而是一种围绕 GitHub 仓库构建工作流程的方式。只要有点创意，你就可以做比“仅仅”一个经典的
    CI/CD 管道更多的事情。当然，我们只会关注这个方面。
- en: You probably already have a GitHub account, and if not, getting one will not
    cost you anything. You can use GitHub Actions for free up to 2,000 minutes per
    month at the time of writing for public repositories, which makes it a great playground
    or a useful tool for your open source projects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经有了 GitHub 账户，如果没有，注册一个也不会花费你任何费用。截至写作时，你可以免费使用 GitHub Actions，每月最多 2,000
    分钟，用于公共仓库，这使得它成为一个极好的游乐场或开源项目的有用工具。
- en: Example project
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目
- en: 'We created a small demo application to use during this chapter. You will find
    it here: [https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application](https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application).
    Please note that it does not serve any other purpose than demonstrating the basic
    use of GitHub Actions and Git hooks.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个小型的演示应用程序，在本章中使用。您可以在以下位置找到它：[https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application](https://github.com/PacktPublishing/Clean-Code-in-PHP/tree/main/ch11/example-application)。请注意，它没有其他用途，只是演示
    GitHub Actions 和 Git hooks 的基本使用。
- en: GitHub Actions in a nutshell
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions 简而言之
- en: GitHub Actions offers no fancy user interface where you can configure all stages.
    Instead, everything is configured via **YAML Ain’t Markup Language** (**YAML**)
    files that are stored directly in the repository. As a PHP developer, you are
    most likely experienced with using YAML files for all sorts of configurations—if
    not, do not worry, as they are easy to understand and use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 提供了没有花哨用户界面的配置方式，您可以通过存储在存储库中的 **YAML Ain’t Markup Language**
    (**YAML**) 文件来配置所有阶段。作为一个 PHP 开发者，您可能已经熟悉了使用 YAML 文件进行各种配置——如果不熟悉，请不要担心，因为它们很容易理解和使用。
- en: GitHub actions are organized around workflows. A workflow gets triggered by
    certain events and contains one or more jobs to be executed if the event occurred.
    A job consists of one or more steps that execute one action each.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 动作是围绕工作流程组织的。当某些事件发生时，工作流程会被触发，并包含一个或多个需要执行的工作。一个工作由一个或多个执行单个操作的步骤组成。
- en: 'The files have to be stored in the `.github/workflows` folder of a repository.
    Let us have a look at the first lines of the `ci.yml` file, which will be our
    CI workflow:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文件必须存储在存储库的 `.github/workflows` 文件夹中。让我们看看 `ci.yml` 文件的最初几行，它将成为我们的 CI 工作流程：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That is quite some information already. Let us go through it line by line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有了相当多的信息。让我们逐行过一遍：
- en: '`name` defines how the workflow will be labeled within GitHub and can be any
    string'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 定义了工作流程在 GitHub 中的标签，可以是任何字符串'
- en: '`on` states which events should trigger this workflow; these comprise the following:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on` 指定了哪些事件应该触发此工作流程；这些包括以下内容：'
- en: '`workflow_dispatch` allows us to manually trigger the workflow from the GitHub
    website, which is great for creating and testing a workflow. Otherwise, we would
    need to push a commit to main, or create a PR every time.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workflow_dispatch` 允许我们从 GitHub 网站手动触发工作流程，这对于创建和测试工作流程来说非常棒。否则，我们每次都需要向 `main`
    分支推送提交或创建 PR。'
- en: '`push` tells GitHub to execute this workflow whenever a push happens. We narrow
    it down to pushes on the `main` branch only.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push` 告诉 GitHub 在发生推送时执行此工作流程。我们将其限制为仅在 `main` 分支上的推送。'
- en: '`pull_request` will additionally trigger the workflow on every new PR. The
    configuration might look a bit incomplete because there is no more information
    after the colon.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull_request` 会在每个新的 PR 上额外触发工作流程。配置可能看起来有点不完整，因为冒号后面没有更多信息。'
- en: '`jobs` contains a list of jobs to be executed for this workflow, as detailed
    here:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs` 包含了此工作流程要执行的工作列表，具体如下：'
- en: '`pipeline` is the `_`) or a dash (`-`).'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipeline` 是 `_`) 或破折号 (`-`）。'
- en: '`runs-on` tells GitHub to use the latest Ubuntu version as a runner (that is,
    as a platform) for this job. Other available platforms are Windows and macOS.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runs-on` 告诉 GitHub 使用最新的 Ubuntu 版本作为此工作的运行者（即平台）。其他可用的平台是 Windows 和 macOS。'
- en: '`steps` marks a list of steps to be executed for this job. In the next section,
    we will have a closer look at this.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps` 标记了执行此工作所需的一系列步骤。在下一节中，我们将更详细地探讨这一点。'
- en: We have the basics of workflow configured now, so we can begin adding the build
    stages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了工作流程的基本设置，因此我们可以开始添加构建阶段。
- en: Stage 1 – Build project
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 阶段 – 构建项目
- en: 'The steps are what makes GitHub Actions so powerful: here, you can choose from
    a vast amount of already existing *actions* to use in your workflow. They are
    organized in *GitHub Marketplace* ([https://github.com/marketplace](https://github.com/marketplace)).
    Let us add some steps to the workflow YAML, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是使 GitHub Actions 变得如此强大的原因：在这里，您可以从大量已存在的 *actions* 中选择用于您的工作流程。它们组织在 *GitHub
    Marketplace* ([https://github.com/marketplace](https://github.com/marketplace))
    中。让我们按照以下方式将一些步骤添加到工作流程 YAML 中：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Actions maintained by GitHub are to be found in the `actions` namespace. In
    our example, this is `actions/checkout`, which is used to check out the repository.
    We do not need to specify any parameters for now, as this action will automatically
    use the repository in which this workflow file is located.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由GitHub维护的动作可以在`actions`命名空间中找到。在我们的例子中，这是`actions/checkout`，它用于检出仓库。目前我们不需要指定任何参数，因为这个动作将自动使用此工作流程文件所在的仓库。
- en: The `@V3` annotation is used to specify the *major* version to use. For `actions/checkout`,
    this would be version `3`. Please note that the latest *minor* version is always
    used, which at the time of writing would be version `3.0.2`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`@V3`注解用于指定要使用的*主要*版本。对于`actions/checkout`，这将是指版本`3`。请注意，总是使用最新的*次要*版本，在撰写本文时将是版本`3.0.2`。'
- en: The other action, `shivammathur/setup-php`, is provided by one of the many great
    people who make their work available as open source. For this step, we are using
    the `with` keyword to specify further parameters. In this example, we use the
    `php-version` option to have PHP `8.1` installed on the previously selected *Ubuntu*
    machine. Using the `coverage` parameter, we can tell `setup-php` to enable the
    `pcov` extension for generating code coverage reports.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个动作`shivammathur/setup-php`是由许多提供开源工作的优秀人士之一提供的。对于这一步，我们使用`with`关键字来指定进一步参数。在这个例子中，我们使用`php-version`选项来在之前选定的*Ubuntu*机器上安装PHP
    `8.1`。使用`coverage`参数，我们可以告诉`setup-php`启用`pcov`扩展以生成代码覆盖率报告。
- en: Action parameters
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 动作参数
- en: Both actions introduced previously offer far more parameters than we can describe
    here. You can find more information about their functionality by looking them
    up in *Marketplace*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前介绍的两个动作提供的参数比我们在这里能描述的要多得多。您可以通过在*Marketplace*中查找它们来获取更多关于它们功能的信息。
- en: Regarding the formatting, we used comments and blank lines between the steps
    to make the file more readable. There is no convention, and it is completely up
    to you how to format your YAML files later.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于格式化，我们使用注释和步骤之间的空白行来使文件更易于阅读。没有约定，完全取决于您如何格式化您后面的YAML文件。
- en: The next step is the installation of the project dependencies. For PHP, this
    usually means running `composer install`. Please note that we *do not* use the
    `--no-dev` option because we need to install the `dev` dependencies to perform
    all the quality checks. We will remove them at the end of the pipeline again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装项目依赖项。对于PHP来说，这通常意味着运行`composer install`。请注意，我们**不**使用`--no-dev`选项，因为我们需要安装`dev`依赖项来执行所有质量检查。我们将在管道末尾再次删除它们。
- en: Dependency management
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项管理
- en: We use the `--no-dev` option in detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细使用`--no-dev`选项。
- en: 'This is what the next steps could look like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是下一步可能的样子：
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'GitHub actions require some manual work to make caching of Composer dependencies
    possible. In the first step, we store the location of the Composer cache directory,
    which we get from Composer using the `config cache-files-dir` command, in an output
    variable called `dir`. Note `id: composer-cache` here—we will need this to reference
    the variable in the next step.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub动作需要一些手动工作来使Composer依赖项的缓存成为可能。在第一步中，我们将从Composer使用`config cache-files-dir`命令获取的Composer缓存目录的位置存储在一个名为`dir`的输出变量中。注意这里`id:
    composer-cache`——我们将在下一步中需要这个来引用变量。'
- en: Then, we access this variable in the next step by using the `steps.composer-cache.outputs.dir`
    reference (a combination of the `id` value we set in the previous step, and the
    variable name) to define the directory that should be cached by the `actions/cache`
    action. `key` and `restore-key` are used to generate unique caching keys—that
    is, the cache entries where our Composer dependencies are stored.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在下一步通过使用`steps.composer-cache.outputs.dir`引用（这是我们在上一步设置的`id`值和变量名的组合）来访问这个变量，以定义应该由`actions/cache`动作缓存的目录。`key`和`restore-key`用于生成唯一的缓存键——即存储我们的Composer依赖项的缓存条目。
- en: 'Lastly, we use the `run` parameter to directly execute `composer install`,
    as if we would execute it locally on an Ubuntu machine. This is important to keep
    in mind: you can, but you do not have to use existing GitHub actions for every
    step—you can just execute pure shell commands (or equivalent commands on Windows
    runners) as well.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`run`参数直接执行`composer install`，就像我们会在Ubuntu机器上本地执行它一样。这一点很重要：您可以使用，但不必在每一步都使用现有的GitHub动作——您也可以执行纯shell命令（或在Windows运行器上的等效命令）。
- en: There are also actions in *Marketplace* that take over the writing of commands,
    such as `php-actions/composer`. We do not have a preferred solution here; both
    will work fine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Marketplace**中也有一些操作会接管命令的编写，例如`php-actions/composer`。我们在这里没有首选解决方案；两者都可以正常工作。
- en: 'Because we want to run integration tests on the API of our example application,
    we need to have a web server running. For our simple use case, it is totally enough
    to use the PHP built-in web server, which we can start using in the following
    step:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想在示例应用的API上运行集成测试，我们需要有一个正在运行的Web服务器。对于我们的简单用例，使用PHP内置的Web服务器就完全足够了，我们可以在以下步骤中开始使用它：
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `-S` option tells the PHP binary to start a web server that is listening
    on the `localhost` address and port `8000`. Since we start in the `root` folder
    of our project, we need to define a *document root* folder (the folder where the
    web server looks for files to execute) using the `-t` option. Here, we want to
    use the public folder, which only contains the `index.php` file. It is good practice
    to not store any other code in the document root folder since this makes it harder
    for attackers to hack our application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S`选项告诉PHP二进制文件启动一个监听在`localhost`地址和端口`8000`的Web服务器。由于我们从项目的根目录开始，我们需要使用`-t`选项定义一个**文档根**文件夹（Web服务器查找要执行文件的文件夹）。在这里，我们想要使用公共文件夹，它只包含`index.php`文件。将任何其他代码存储在文档根文件夹中都不是一个好的做法，因为这会使攻击者更难攻击我们的应用程序。'
- en: PHP built-in web server
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PHP内置Web服务器
- en: Please note that the built-in web server of PHP is only to be used for *development*
    purposes. It should never be used in *production*, since it was not built with
    performance or security in mind.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PHP的内置Web服务器仅应用于**开发**目的。它绝不应该在生产环境中使用，因为它并不是为了性能或安全性而构建的。
- en: You surely noticed the ampersand (`&`) at the end of the command. This tells
    Linux to execute the command, but not wait for its termination. Without it, our
    workflow would get stuck at this point because the web server does not terminate
    by itself, as it needs to keep listening for requests until we run our *integration
    tests* at a later stage.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定注意到了命令末尾的`&`符号。这告诉Linux执行命令，但不要等待其终止。没有它，我们的工作流程会在这一点上卡住，因为Web服务器不会自行终止，因为它需要继续监听请求，直到我们在稍后的阶段运行我们的**集成测试**。
- en: The setup of our build environment is complete. Now, it is time to run the first
    code quality checks on our sample application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建环境设置已完成。现在，是时候在我们的示例应用程序上运行第一次代码质量检查了。
- en: Stage 2 – Code analysis
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二阶段 – 代码分析
- en: In the first build stage, we created our build environment and checked out our
    application code. At this point, the application should be completely functional
    and ready to be tested. Now, we want to do some static code analysis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个构建阶段，我们创建了我们的构建环境并检出我们的应用程序代码。在这个阶段，应用程序应该完全功能正常，并准备好进行测试。现在，我们想要进行一些静态代码分析。
- en: The standard approach is to use dedicated GitHub actions for each tool. The
    benefit is that we keep the development tools away from the build environment,
    as they will be executed in separate Docker containers that will be discarded
    right after use. There are some drawbacks to this approach, though.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方法是为每个工具使用专门的GitHub动作。好处是我们将开发工具与构建环境分开，因为它们将在单独的Docker容器中执行，并在使用后立即丢弃。尽管如此，这种方法也有一些缺点。
- en: Firstly, with each action, we introduce yet another dependency, and we rely
    on the author to keep it up to date and not lose interest in maintaining it after
    a while. Additionally, we add some overhead, since Docker images are usually many
    times bigger than the actual tool. And lastly, when our application setup gets
    more complicated, running the code quality tools in separate Docker containers
    can cause issues, simply because it is not the same environment as the build environment.
    Sometimes, already tiny differences can cause problems that keep you engaged for
    hours or days in solving them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个动作都会引入另一个依赖项，我们依赖于作者保持其更新，并在一段时间后不会失去维护它的兴趣。此外，我们增加了一些开销，因为Docker镜像通常比实际工具大得多。最后，当我们的应用程序设置变得更加复杂时，在单独的Docker容器中运行代码质量工具可能会引起问题，仅仅是因为它不是与构建环境相同的环境。有时，已经非常小的差异也可能导致问题，这些问题可能会让你花费数小时或数天来解决。
- en: As we saw in the previous section, we can simply execute Linux shell commands
    in the build environment, so nothing speaks against executing our code quality
    tools directly on the build environment—we just need to make sure to remove them
    afterward so that they do not get released into production.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，我们可以在构建环境中简单地执行Linux shell命令，所以没有理由在我们的构建环境中直接执行代码质量工具——我们只需要确保之后删除它们，以免它们被发布到生产环境中。
- en: 'In our example application, we added PHP-CS-Fixer and PHPStan to the `require-dev`
    section of the `composer.json` file. By adding the following lines of code to
    our workflow YAML, we will let them execute as the next steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将PHP-CS-Fixer和PHPStan添加到了`composer.json`文件的`require-dev`部分。通过将以下代码行添加到我们的工作流程YAML中，我们将让它们作为下一步执行：
- en: '[PRE4]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We do not need many parameters or options here, since our example application
    provides both the `.php-cs-fixer.dist.php` and `phpstan.neon` configuration files,
    which both tools will look up by default. Only for PHP-CS-Fixer will we use the
    `--dry-run` option because we only want to check for issues during the CI/CD pipeline,
    and not solve them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不需要很多参数或选项，因为我们的示例应用程序提供了`.php-cs-fixer.dist.php`和`phpstan.neon`配置文件，这两个工具默认都会查找。只有对于PHP-CS-Fixer，我们会使用`--dry-run`选项，因为我们只想在CI/CD管道中检查问题，而不是解决它们。
- en: Setting the scope of checks
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置检查范围
- en: 'For our small example application, it is OK to run the preceding checks on
    all files because they will execute quickly. If our application grows, however,
    or we wish to introduce CI/CD to an existing application (which we will discuss
    further on in this chapter), it is sufficient to run these checks on those files
    that have only changed in the latest commit. The following action could be helpful
    for you in this case: [https://github.com/marketplace/actions/changed-files](https://github.com/marketplace/actions/changed-files).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的小型示例应用程序，运行前面的检查在所有文件上是可以的，因为它们会快速执行。然而，如果我们的应用程序增长，或者我们希望将CI/CD引入现有的应用程序（我们将在本章后面进一步讨论），则只需在最新提交中只更改的文件上运行这些检查即可。以下操作在这种情况下可能对您有所帮助：[https://github.com/marketplace/actions/changed-files](https://github.com/marketplace/actions/changed-files)。
- en: 'If neither PHP-CS-Fixer nor PHPStan reports any issues, we can safely execute
    the automated tests in the next stage: the tests.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PHP-CS-Fixer或PHPStan没有报告任何问题，我们就可以安全地执行下一阶段的自动化测试：测试。
- en: Stage 3 – Tests
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三阶段 – 测试
- en: Our code has been thoroughly analyzed and checked for bugs and syntax errors,
    yet we need to check for logical errors in our code. Luckily, we have some automated
    tests to ensure that we did not inadvertently introduce any bugs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经彻底分析了代码，并检查了错误和语法错误，但我们还需要检查代码中的逻辑错误。幸运的是，我们有一些自动化测试来确保我们没有无意中引入任何错误。
- en: 'For the same reasons as for the code quality tools in *Stage 2*, we do not
    want to use a dedicated action for running our PHPUnit test suites. We simply
    execute PHPUnit as we would on our local development system. Using the `phpunit.xml`
    file clearly proves useful here since we do not need to remember all the many
    options to use here. Let us have a look at the *workflow YAML* first, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与*第二阶段*中的代码质量工具相同的原因，我们不希望为运行我们的PHPUnit测试套件使用专用操作。我们只是像在本地开发系统中一样执行PHPUnit。使用`phpunit.xml`文件在这里显然很有用，因为我们不需要记住所有许多选项。让我们首先看看*工作流程YAML*，如下所示：
- en: '[PRE5]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The only thing worth noting here is that we do not just run all tests, but
    we split them up in two test suites: `Unit` and `Api`. Since our unit tests should
    execute the fastest, we want to run them (and fail) first, then followed by the
    slower integration tests. Please note that we did not add any E2E tests as our
    application does not run in the browser but is a mere web service.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一值得注意的事情是我们不仅运行所有测试，而且将它们分成两个测试套件：`Unit`和`Api`。由于我们的单元测试应该执行得最快，我们希望首先运行它们（并失败），然后是较慢的集成测试。请注意，我们没有添加任何端到端测试，因为我们的应用程序不在浏览器中运行，而是一个简单的Web服务。
- en: 'We split the tests up by using the `phpunit.xml` configuration file. The following
    code fragment shows you its `<testsuites>` node, where we separate the suites
    by their directory (`Api` and `Unit`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`phpunit.xml`配置文件来分割测试。以下代码片段展示了其`<testsuites>`节点，其中我们根据目录（`Api`和`Unit`）来分离测试套件：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also configured PHPUnit to create code coverage reports, as illustrated
    here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还配置了PHPUnit以创建代码覆盖率报告，如下所示：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To create these reports, PHPUnit will automatically use the `pcov` extension,
    which we configured in *Stage 1*. They will be written into the `reports` folder,
    which we will take care of in the next stage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些报告，PHPUnit将自动使用我们在第1阶段配置的`pcov`扩展。它们将被写入`reports`文件夹，我们将在下一阶段处理。
- en: That is already everything that needs to be done for the tests stage. If our
    tests did not discover any errors, we are good to go into the last stage of our
    pipeline and wrap everything up.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试阶段需要做的所有事情。如果我们的测试没有发现任何错误，我们就可以进入管道的最后一个阶段，并完成所有工作。
- en: Stage 4 – Deploy
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4阶段 - 部署
- en: 'Our application is now thoroughly checked and tested. Before we are ready to
    deploy it into whichever environment we envisioned, we need to take care of removing
    the `dev` dependencies first. Luckily, this is very easy, as we can see here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已经彻底检查和测试过了。在我们准备好将其部署到我们预想的任何环境中之前，我们首先需要处理移除`dev`依赖项。幸运的是，这非常简单，正如我们在这里可以看到的：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running `composer install --no-dev` will simply delete all the `dev` dependencies
    from the `vendor` folder. Another noteworthy feature is the `--optimize-autoloader`
    option of Composer: since in production, we will not add or change any classes
    or namespaces as we would do in development, the Composer autoloader can be optimized
    by not checking for any changes, and thus disk access, speeding it up a bit.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`composer install --no-dev`将简单地从`vendor`文件夹中删除所有`dev`依赖项。另一个值得注意的特性是Composer的`--optimize-autoloader`选项：由于在生产环境中，我们不会像在开发中那样添加或更改任何类或命名空间，因此Composer的自动加载器可以通过不检查任何更改来优化，从而减少磁盘访问，稍微提高其速度。
- en: 'As the very last step, we want to create build artifacts: one artifact is the
    deliverable—that is the code we intend to deploy. The other artifact is the code
    coverage reports we created in *Stage 3*. GitHub Actions will not keep any additional
    data than the logging information displayed on the GitHub website after the workflow
    YAML has been executed, so we need to make sure they are stored away at the end.
    The code is illustrated in the following snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们想要创建构建工件：一个是可交付成果——即我们打算部署的代码。另一个是我们在第3阶段创建的代码覆盖率报告。GitHub Actions在执行工作流程YAML之后不会保留任何比GitHub网站上显示的日志信息更多的数据，因此我们需要确保它们在最后被存储起来。代码如下所示：
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the `actions/upload-artifacts` action to create two ZIP archives (called
    *artifacts* here): `release` and `reports`. The first contains all files and directories
    we need to run our application on production, and nothing more. We omit all the
    configuration files in the root folder of our project, even the `composer.json`
    and `composer.lock` files. We do not need them anymore, since our `vendor` folder
    already exists.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`actions/upload-artifacts`操作创建两个ZIP存档（在这里称为*工件*）：`release`和`reports`。第一个包含我们运行生产环境中的应用程序所需的所有文件和目录，不再需要其他任何东西。我们省略了项目根目录中的所有配置文件，甚至包括`composer.json`和`composer.lock`文件。我们不再需要它们，因为我们的`vendor`文件夹已经存在。
- en: The `reports` artifact will just contain the `reports` folder. After the build,
    you can simply download both ZIP archives separately on GitHub. More about this
    in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`reports`工件将仅包含`reports`文件夹。在构建完成后，你可以在GitHub上单独下载这两个ZIP存档。更多内容将在下一节中介绍。'
- en: Integrating the pipeline into your workflow
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将管道集成到你的工作流程中
- en: After adding the workflow YAML to the `.github/workflows` folder (for example,
    `.github/workflows/ci.yml`), you only need to commit and push it to the repository.
    We configured our pipeline to run upon every opened PR or whenever someone pushes
    a commit to the `main` branch.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在将工作流程YAML添加到`.github/workflows`文件夹（例如，`.github/workflows/ci.yml`）之后，你只需要将其提交并推送到仓库。我们配置了我们的管道，使其在每次打开PR或有人向`main`分支推送提交时运行。
- en: 'When you open [https://github.com](https://github.com) and go to your repository
    page, you will find an overview of your last workflow runs on the **Actions**
    tab, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开[https://github.com](https://github.com)并进入你的仓库页面时，你将在**操作**标签页中找到你最后的工作流程运行概览，如下面的截图所示：
- en: '![Figure 11.3: The repository page on github.com'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：github.com上的仓库页面'
- en: '](img/Figure_11.3_B19050.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.3_B19050.jpg)'
- en: 'Figure 11.3: The repository page on github.com'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：github.com上的仓库页面
- en: 'The green checkmark marks the successful runs, while the red cross—of course—marks
    the failed ones. You can also see when they were executed and how long this took.
    By clicking on the three dots on the right side of each entry, you will find more
    options—for example, where you can delete the workflow run. Clicking on the title
    of the run, which is the corresponding commit message of the run, you will enter
    the **Summary** page, as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色勾号标记成功的运行，而红色交叉——当然——标记失败的运行。您还可以看到它们何时执行以及这花了多长时间。通过点击每个条目右侧的三个点，您将找到更多选项——例如，您可以在这里删除工作流程运行。点击运行的标题，即运行的相应提交信息，您将进入
    **摘要** 页面，如下面的截图所示：
- en: '![Figure 11.4: The workflow run summary page'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4：工作流程运行摘要页面'
- en: '](img/Figure_11.4_B19050.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B19050.jpg)'
- en: 'Figure 11.4: The workflow run summary page'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：工作流程运行摘要页面
- en: Here, you can see all jobs of the workflow. Since our example only consists
    of one job, `pipeline`, you will only see one. On this page, you can also find
    any generated artifacts (such as our release and reports artifacts) and download
    or delete them. GitHub offers only limited disk space for free, so make sure to
    delete them when you are running out of space.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看工作流程的所有作业。由于我们的示例只包含一个作业，即 `pipeline`，您只会看到一个。在此页面上，您还可以找到任何生成的工件（例如我们的发布和报告工件）并下载或删除它们。GitHub
    免费提供的磁盘空间有限，所以当您快用完空间时，请确保删除它们。
- en: Another important piece of information is the billed time. Although our job
    only ran for 43 seconds in total, GitHub will deduct 1 minute from your monthly
    usage. GitHub offers a generous free plan, but you should have a look at your
    usage from time to time. You can find more information about this on your user
    settings page in the **Billing and plans** section ([https://github.com/settings/billing](https://github.com/settings/billing)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的信息是计费时间。尽管我们的作业总共只运行了 43 秒，GitHub 仍将从您的月度使用量中扣除 1 分钟。GitHub 提供了慷慨的免费计划，但您应该时不时地查看您的使用情况。您可以在用户设置页面中的
    **计费和计划** 部分找到更多关于此的信息（[https://github.com/settings/billing](https://github.com/settings/billing)）。
- en: 'If you want to see what exactly happens during the workflow run—for example,
    if something goes wrong—you can click on the `pipeline` job to get a detailed
    overview of all of its steps, as illustrated in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看工作流程运行期间确切发生了什么——例如，如果出了问题——您可以点击 `pipeline` 作业以获取所有步骤的详细概述，如下面的截图所示：
- en: '![Figure 11.5: Job details page'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5：作业详情页面'
- en: '](img/Figure_11.5_B19050.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.5_B19050.jpg)'
- en: 'Figure 11.5: Job details page'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：作业详情页面
- en: Each step can be expanded and collapsed to get additional information about
    what exactly happened during its execution. In the preceding screenshot, we expanded
    the **Install PHP** step to see what the action did in detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都可以展开和折叠以获取有关其执行期间确切发生了什么的额外信息。在上面的截图中，我们展开了 **安装 PHP** 步骤以查看动作的详细操作。
- en: Congratulations—you now have a working CI pipeline for your project! This ends
    our little tour through GitHub Actions. Of course, you can extend the pipeline
    as you like—for example, by uploading the release artifact to an **SSH File Transfer
    Protocol** (**SFTP**) server or an AWS **Simple Storage Service** (**S3**) bucket.
    There is a lot more than can be done, so make sure to experiment with it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——您现在为您的项目拥有了一个工作的 CI 管道！这标志着我们通过 GitHub Actions 的小型之旅结束。当然，您可以按需扩展管道——例如，通过将发布工件上传到
    **SSH 文件传输协议**（**SFTP**）服务器或 AWS **简单存储服务**（**S3**）存储桶。还有更多的事情可以做，所以请确保尝试一下。
- en: In the next section, we will show you how you can set up your local pipeline.
    This will save you some time and probably even costs by avoiding unnecessary workflow
    runs through early checks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何设置您本地的管道。这将为您节省一些时间，甚至可能通过避免不必要的早期检查来节省成本。
- en: Your local pipeline – Git hooks
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的本地管道 – Git 钩子
- en: After we successfully set up a simple but already very useful CI/CD pipeline,
    we now want to look at running some steps already in the local development environment,
    even before committing them to the repository. This may sound like double work
    right now—why should we run the same tools twice?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们成功设置了一个简单但已经非常有用的 CI/CD 管道之后，我们现在想看看在将它们提交到仓库之前，如何在本地开发环境中运行一些步骤。这听起来可能像是重复工作——为什么我们要运行相同的工具两次呢？
- en: 'Remember *Figure 11.1–Estimated relative costs of fixing a bug based on the
    time of its detection*, from the beginning of the chapter: the earlier we catch
    a bug, the fewer costs or the less effort it will cause. Of course, if we find
    a bug during the CI/CD pipeline, that is still much earlier than in the production
    environment.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住本章开头的*图11.1-根据检测时间估计修复错误的相对成本*：我们越早发现错误，它造成的成本或努力就越少。当然，如果在CI/CD管道中找到错误，这仍然比在生产环境中要早得多。
- en: The pipeline does not come for free, though. Our example application build was
    fast and just took roughly a minute. Imagine, however, a full-fledged Docker setup
    that already takes a considerable amount of time to create all the necessary containers.
    And now, it fails to build just because of a little bug that you could have solved
    within 2 minutes if you had not forgotten to execute unit tests before committing
    your code. You might have just taken a well-deserved tea or coffee break, only
    to find the build failed because of that when you came back. This is annoying
    and a waste of money as well as computational power.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然管道不是免费的。我们的示例应用程序构建速度快，只需大约一分钟。想象一下，一个完整的Docker设置已经花费相当多的时间来创建所有必要的容器。现在，它因为一个小错误而无法构建，如果您在提交代码之前没有忘记执行单元测试，您本可以在2分钟内解决这个错误。您可能刚刚享受了一个应得的茶或咖啡休息，结果回来发现构建失败了，这很烦人，也是金钱和计算能力的浪费。
- en: Exactly those fast-running checks such as unit tests, a code sniffer, or static
    code analysis are what we want to execute before we start a full build for our
    changes. We cannot rely on ourselves to execute these checks automatically because
    we are humans. We forget things, but machines do not.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正是那些快速运行的检查，比如单元测试、代码嗅探器或静态代码分析，是我们希望在开始全面构建我们的更改之前执行的。我们不能依赖我们自己自动执行这些检查，因为我们都是人类。我们会忘记事情，但机器不会。
- en: If you use Git for your development, which most developers do today, we can
    utilize the built-in functionality of Git hooks to automate these checks. Git
    hooks are shell scripts that are automatically executed on certain events, such
    as before or after every commit.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Git进行开发，像今天的大多数开发者一样，我们可以利用Git钩子的内置功能来自动化这些检查。Git钩子是在某些事件上自动执行的shell脚本，例如在每次提交之前或之后。
- en: For our needs, the *pre-commit* hook is particularly useful. It will be executed
    each time you run the `git commit` command and can abort the commit if the executed
    script returned an error. In this case, no code would be added to the repository.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的需求，*pre-commit*钩子特别有用。每次您运行`git commit`命令时，它都会执行，如果执行的脚本返回了错误，它还可以中止提交。在这种情况下，不会将任何代码添加到仓库中。
- en: Setting up Git hooks
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Git钩子
- en: Setting up Git hooks manually does require some knowledge of shell scripting,
    so we want to use a package called `CaptainHook` to assist us. Using this tool,
    we can install any hook we like and even use some advanced features without the
    need to master Linux.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 手动设置Git钩子确实需要一些shell脚本的了解，因此我们希望使用一个名为`CaptainHook`的包来帮助我们。使用这个工具，我们可以安装任何我们喜欢的钩子，甚至可以使用一些高级功能，而无需掌握Linux。
- en: 'You can easily download the Phar by using Phive (see [*Chapter 9*](B19050_09.xhtml#_idTextAnchor115)*,
    Organizing PHP Quality Tools,* for more information on that), or use Composer
    to install it, as we will do now:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Phive轻松下载Phar（有关更多信息，请参阅[*第9章*](B19050_09.xhtml#_idTextAnchor115)*，组织PHP质量工具*），或者使用Composer安装它，就像我们现在要做的：
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to create a `captainhook.json` file. This file contains the hook
    configuration for your project. Since this file will be added to the repository,
    we ensure that other developers in our team can use it. To create this file, we
    could run the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`captainhook.json`文件。此文件包含项目的钩子配置。由于此文件将被添加到仓库中，我们确保我们的团队中的其他开发者可以使用它。要创建此文件，我们可以运行以下命令：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'CaptainHook will ask you a couple of questions and generate a configuration
    file based on your answers. You can skip this step, however, and create a file
    directly, as we will do now. Open your favorite editor, and write the following
    code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: CaptainHook将向您提出几个问题，并根据您的答案生成一个配置文件。然而，您可以跳过此步骤，直接创建文件，就像我们现在要做的。打开您最喜欢的编辑器，并写下以下代码：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each hook has its own section. Within the `pre-commit` hook section, `enabled`
    can be either `true` or `false`—the latter disables the hook but keeps the configuration
    in the file, which can be handy for debugging purposes. `actions` contains the
    actual commands to execute. As you can see, these commands are like the ones you
    already know from [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*, Code Quality
    Tools*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个钩子都有自己的部分。在`pre-commit`钩子部分，`enabled`可以是`true`或`false`——后者禁用钩子但保留文件中的配置，这在调试时可能很有用。`actions`包含要执行的命令。正如你所看到的，这些命令就像你从[*第7章*](B19050_07.xhtml#_idTextAnchor084)*，代码质量工具*中已经了解的那样。
- en: Every action you want to have executed needs to be written in a separate action
    section. In the preceding example, we configured PHP-CS-Fixer and PHPStan to be
    executed on `pre-commit`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要执行的所有操作都需要在单独的操作部分中编写。在上面的例子中，我们配置了PHP-CS-Fixer和PHPStan在`pre-commit`时执行。
- en: Since we have additional configuration files for both tools, we do not need
    the specify any further options, except telling PHP-CS-Fixer to only do a dry
    run—that is, to only inform us when a code style violation has been found.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为这两个工具都有额外的配置文件，所以我们不需要指定任何其他选项，除了告诉PHP-CS-Fixer只进行dry run——也就是说，只在我们发现代码风格违规时通知我们。
- en: In the `config` section, you can specify further configuration parameters. We
    want to stop the hook execution immediately after an error occurred, so we set
    `fail-on-first-error` to `true`. Otherwise, CaptainHook would first run all checks,
    and then tell you the results. This is, of course, just a matter of personal taste.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`部分，你可以指定更多的配置参数。我们希望在错误发生后立即停止钩子执行，因此将`fail-on-first-error`设置为`true`。否则，CaptainHook会首先运行所有检查，然后告诉你结果。这当然只是个人喜好的问题。
- en: CaptainHook documentation
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: CaptainHook文档
- en: We cannot list all features of CaptainHook in this book. However, we encourage
    you to check out the official documentation at [https://captainhookphp.github.io/captainhook](https://captainhookphp.github.io/captainhook)
    to learn more about this tool.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在这本书中列出CaptainHook的所有功能。然而，我们鼓励你查看官方文档[https://captainhookphp.github.io/captainhook](https://captainhookphp.github.io/captainhook)，以了解更多关于这个工具的信息。
- en: As we are done now with the configuration, please store this `captainhook.json`
    in the project root folder. That is already everything we have to do regarding
    the configuration.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置，请将此`captainhook.json`文件存储在项目根目录中。这就是我们关于配置需要做的所有事情。
- en: 'We just need to install the hooks now—that is, generate hook files in `.git/hooks`.
    This can be simply done like so:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要安装钩子——也就是说，在`.git/hooks`中生成钩子文件。这可以简单地这样做：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `-f` option here, which stands for *force*. Without this option,
    CaptainHook would ask us for every hook separately, if we want to install it.
    Please note that CaptainHook will install a file for every Git hook it supports,
    even for those which you did not configure. Those hooks will not do anything,
    though.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`-f`选项，代表*强制*。没有这个选项，CaptainHook会单独询问我们是否要安装每个钩子。请注意，CaptainHook将为它支持的每个Git钩子安装一个文件，即使是你没有配置的钩子也不例外。不过，这些钩子不会做任何事情。
- en: 'To test the `pre-commit` hook, you can execute this manually without having
    to commit anything using the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`pre-commit`钩子，你可以使用以下命令手动执行，而无需提交任何内容：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar commands are available for all the other hooks that CaptainHook supports.
    If you made changes to the `captainhook.json` file, do not forget to install it
    by using the `install -f` command again.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CaptainHook支持的其它所有钩子，都有类似的命令可用。如果你对`captainhook.json`文件进行了修改，别忘了再次使用`install
    -f`命令来安装它。
- en: 'To make sure that the hooks get installed in the local development environment,
    you can add the following code to the `scripts` section of your `composer.json`
    file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保钩子被安装在本地的开发环境中，你可以在你的`composer.json`文件的`scripts`部分添加以下代码：
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the `post-autoload-dump` event of Composer to run the `install -f` command.
    The command will be executed every time the Composer autoloader gets refreshed,
    which will happen every time `composer install` or `composer update` is executed.
    This way, we make sure that the hooks are installed or updated regularly in the
    development environments of anybody who works on this project. By using `if [
    -e vendor/bin/captainhook ]`, we check if the CaptainHook binary exists and avoid
    breaking the CI build if it is not installed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Composer的`post-autoload-dump`事件来运行`install -f`命令。该命令将在Composer自动加载器每次刷新时执行，这将在每次执行`composer
    install`或`composer update`时发生。这样，我们确保任何参与此项目的开发者的开发环境中钩子定期安装或更新。通过使用`if [ -e vendor/bin/captainhook
    ]`，我们检查CaptainHook二进制文件是否存在，如果未安装，则避免破坏CI构建。
- en: Git hooks in practice
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的Git钩子
- en: 'We completed the configuration of the `pre-commit` hook and tested and installed
    it. Now, we are ready to see it in action: if you do any change in the application
    code—for example, by adding a blank line somewhere in the `ProductController.php`
    file—and then try to commit the changes, the `pre-commit` hook should be executed.
    If the changes violated the *PSR-12* standard, the PHP-CS-Fixer step should fail,
    as shown in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了`pre-commit`钩子的配置，并测试和安装了它。现在，我们准备看到它的实际应用：如果你在应用程序代码中做了任何更改——例如，在`ProductController.php`文件中添加一个空白行——然后尝试提交更改，`pre-commit`钩子应该被执行。如果更改违反了*PSR-12*标准，PHP-CS-Fixer步骤应该失败，如下面的截图所示：
- en: '![Figure 11.6: The pre-commit hook fails'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6：pre-commit钩子失败'
- en: '](img/Figure_11.6_B19050.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.6_B19050.jpg)'
- en: 'Figure 11.6: The pre-commit hook fails'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：pre-commit钩子失败
- en: Fixing code style issues automatically
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 自动修复代码风格问题
- en: Of course, you can remove the `--dry-run` option when executing PHP-CS-Fixer
    to let it fix issues automatically. In fact, this is a common practice, and we
    encourage you to try out the same. However, it requires a bit more work, because
    you must let the user know that their changed files have been fixed and that they
    need to be re-committed. To keep this example simple, we decided to omit this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在执行PHP-CS-Fixer时，你可以移除`--dry-run`选项，让它自动修复问题。实际上，这是一个常见的做法，我们鼓励你尝试一下。然而，这需要做更多的工作，因为你必须让用户知道他们的更改文件已经被修复，并且需要重新提交。为了使这个例子简单，我们决定省略这一点。
- en: 'We now know that the `ProductController.php` file has to be fixed. We can let
    PHP-CS-Fixer do the work, as demonstrated here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道`ProductController.php`文件需要被修复。我们可以让PHP-CS-Fixer来完成这项工作，如下所示：
- en: '![Figure 11.7: Using PHP-CS-Fixer to automatically fix code style issues'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7：使用PHP-CS-Fixer自动修复代码风格问题'
- en: '](img/Figure_11.7_B19050.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.7_B19050.jpg)'
- en: 'Figure 11.7: Using PHP-CS-Fixer to automatically fix code style issues'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：使用PHP-CS-Fixer自动修复代码风格问题
- en: '`ProductController.php` has been changed again now, and those additional changes
    have not yet been staged—that is, they have not yet been added to the commit.
    The previous changes are still staged, though. The following screenshot shows
    you what it would look like if you ran `git status` at this point:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductController.php`文件现在再次被更改，那些额外的更改尚未被暂存——也就是说，它们还没有被添加到提交中。之前的更改仍然被暂存。下面的截图显示了如果你现在运行`git
    status`会是什么样子：'
- en: '![Figure 11.8: Unstaged changes'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8：未暂存更改'
- en: '](img/Figure_11.8_B19050.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.8_B19050.jpg)'
- en: 'Figure 11.8: Unstaged changes'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：未暂存更改
- en: 'All that needs to be done now is to add the `ProductController.php` file again
    and run `git commit` again, as demonstrated in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要做的只是再次添加`ProductController.php`文件并再次运行`git commit`，如下面的截图所示：
- en: '![Figure 11.9: pre-commit hook passes'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9：pre-commit钩子通过'
- en: '](img/Figure_11.9_B19050.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.9_B19050.jpg)'
- en: 'Figure 11.9: pre-commit hook passes'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：pre-commit钩子通过
- en: Both steps of the `pre-commit` hook pass now. All you need to do now is to `git
    push` the committed changes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre-commit`钩子的两个步骤现在都通过了。你现在需要做的只是提交更改并执行`git push`。'
- en: Advanced usage
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级用法
- en: The preceding example was a very basic one. Of course, there is much more that
    you can do in the local development environment already. You could, for example,
    add more tools such as the `phpcpd` copy and paste detector or the `phpmd` mess
    detector, both of which we introduced in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*,
    Code Quality Tools*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是一个非常基础的例子。当然，在本地开发环境中，你可以做更多的事情。例如，你可以添加更多的工具，如`phpcpd`复制粘贴检测器或`phpmd`混乱检测器，这两者我们都在[*第7章*](B19050_07.xhtml#_idTextAnchor084)*，代码质量工具*中介绍过。
- en: If your tests are not too slow (what exactly that means depends on your and
    your teammates’ patience), you should consider running your tests locally as well.
    Even if you have slow-running tests, you can separate them into several test suites,
    and only execute the fast-running tests on `pre-commit`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试不是太慢（这究竟意味着什么取决于你和你的队友的耐心），你应该考虑在本地运行你的测试。即使你有运行缓慢的测试，你也可以将它们分成几个测试套件，并且只在`pre-commit`上执行快速运行的测试。
- en: 'You should also consider running code quality checks on modified files only
    and not the whole project, as we did in our example. CaptainHook provides the
    useful `{$STAGED_FILES}` placeholder, which contains all staged files. It is very
    convenient to use, as we can see here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑只对修改过的文件进行代码质量检查，而不是整个项目，就像我们在示例中所做的那样。CaptainHook提供了有用的`{$STAGED_FILES}`占位符，它包含所有暂存文件。使用起来非常方便，如下所示：
- en: '[PRE16]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding example runs the checks only on modified PHP files. This has
    two main benefits: firstly, it is faster because you do not have to check code
    that you have not touched. The speedup, of course, depends on the size of your
    code base.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例只对修改过的PHP文件运行检查。这有两个主要好处：首先，它更快，因为你不需要检查你未触及的代码。当然，这种加速取决于你的代码库的大小。
- en: Secondly, especially if you are working on an existing project and just started
    introducing these checks, running them on the whole code base is not an option
    because you would need to fix too many files at once. We will discuss this in
    more detail in the next section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，特别是如果你正在处理一个现有的项目并且刚刚开始引入这些检查，在整个代码库上运行它们不是一种选择，因为你需要一次性修复太多的文件。我们将在下一节中更详细地讨论这个问题。
- en: Excursion – Adding CI to existing software
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远足 - 向现有软件添加CI
- en: 'If you work in a company, you will not always start *on the green*—that is,
    build a new project from the ground up. In fact, most likely it will be the opposite:
    when you join a company, you will be added to a team that has been working on
    one or more projects for a long time already.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个公司工作，你并不总是从“绿色”开始——也就是说，从头开始构建一个新项目。事实上，很可能是相反的：当你加入一个公司时，你将被添加到一个已经为了一或多个项目工作了很长时间的团队中。
- en: You probably came across the terms *legacy software* or *legacy system* already.
    In our context, they describe software that has existed for a long time and is
    still in use in business-critical processes. It does not meet modern development
    standards anymore, so it cannot be easily updated or changed. Over time, it becomes
    so brittle and hard to maintain that no developer wants to touch it anymore. What
    makes it even worse is the fact that because the system grew over a longer time,
    it has so much functionality that no stakeholder (that is, the users) would like
    to miss it. So, replacing a legacy system is not that easy.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经遇到了*遗留软件*或*遗留系统*这样的术语。在我们的上下文中，它们描述的是已经存在很长时间并且仍在业务关键过程中使用的软件。它不再符合现代开发标准，因此不能轻易更新或更改。随着时间的推移，它变得如此脆弱和难以维护，以至于没有开发者愿意再碰它。更糟糕的是，由于系统在更长的时间内增长，它具有如此多的功能，以至于没有任何利益相关者（即用户）愿意错过它。因此，替换遗留系统并不那么容易。
- en: Not surprisingly, legacy software has a bad connotation, yet probably, all the
    system needs is some “attention”. Think of it like the restoration of an old machine,
    where old parts get replaced with modern ones, while the outside is left unchanged.
    Some developers even find it extra challenging to work on such software. It has
    come a long way, earned its money, and—most likely (at least partly)—pawed the
    success of the company, so it deserves some respect.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，遗留软件有一个不好的含义，但可能，整个系统需要的只是一些“关注”。想想看，就像修复一台旧机器，旧零件被现代零件所取代，而外观保持不变。一些开发者甚至发现，在这样软件上工作更具挑战性。它已经走了很长的路，赚了钱，并且——最有可能的是（至少部分如此）——推动了公司的成功，因此它值得一些尊重。
- en: So, if you have to work on such a project, do not give up quickly. With this
    book, we provided you with the necessary knowledge and tools to start bringing
    it into shape again—it just will take a bit longer, and you might never reach
    a perfect level. But being perfect is not necessary anyway.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你必须处理这样的项目，不要轻易放弃。在这本书中，我们为你提供了必要的知识和工具，以开始重新塑造它——这需要更长的时间，你可能永远达不到完美的水平。但完美并不是必要的。
- en: Step by step
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步进行
- en: Start with adding integration and E2E tests. Both test types usually require
    no or just a few changes on the code but will bring great benefit, as they indirectly
    cover a lot of code without having to write unit tests. Once you’ve covered the
    critical paths (that is, the most used workflows) of the application with tests,
    you can start refactoring the classes and start introducing additional unit tests.
    The tests will help you to discover bugs and side effects quickly, without having
    to click through the application repeatedly.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从添加集成和端到端（E2E）测试开始。这两种测试类型通常不需要对代码进行任何或只有很少的更改，但会带来巨大的好处，因为它们可以间接覆盖大量代码，而无需编写单元测试。一旦你用测试覆盖了应用程序的关键路径（即最常用的工作流程），你就可以开始重构类，并开始引入额外的单元测试。这些测试将帮助你快速发现错误和副作用，而无需反复点击应用程序。
- en: Introducing a code style such as *PSR-12* is, as you know by now, as easy as
    just running a tool such as `PHP-CS-Fixer` over the entire code base at once.
    The resulting commit will, of course, be huge, so you want to agree upon a code
    freeze with any fellow developers before you do it. A code freeze means that everybody
    commits their changes into the repository so that your refactoring does not cause
    huge merge conflicts when they check out the changes afterward.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，引入一种代码风格，如*PSR-12*，就像一次性在整个代码库上运行一个工具，例如`PHP-CS-Fixer`一样简单。当然，生成的提交将会非常大，所以在你这样做之前，你想要与任何其他开发者达成代码冻结的协议。代码冻结意味着每个人都将他们的更改提交到仓库中，这样你的重构就不会在他们在之后检查更改时引起巨大的合并冲突。
- en: To decide which code to refactor, we intend to use one or more of the many code
    quality tools you know by now. Going with PHPStan on level `0` is a good choice.
    You might also want to consider Psalm, as it can also resolve some issues automatically.
    Depending on the size of the project, the list of errors can be dauntingly long.
    Making use of the baseline feature, as described in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084),
    *Code Quality Tools*, can be a cosmetic help here, but it will only hide and not
    solve the code issues.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定要重构哪些代码，我们打算使用你现在所知道的许多代码质量工具中的一个或多个。在`0`级别使用PHPStan是一个不错的选择。你也可能想考虑使用PSalm，因为它也可以自动解决一些问题。根据项目的大小，错误列表可能会非常长。利用如[*第7章*](B19050_07.xhtml#_idTextAnchor084)中所述的基线功能，*代码质量工具*在这里可以提供一些外观上的帮助，但它只会隐藏而不是解决代码问题。
- en: You do not need to rush. If you configure your CI/CD pipeline to only check
    modified files, you can start improving the code over time, piece by piece. It
    does leave you with the problem that once you have touched a file, you must refactor
    it to meet the rules. Especially for old but huge classes, this can be problematic.
    In [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084), *Code Quality Tools*, however,
    we explained how you can exclude files or parts of the code from the performed
    checks. You can even set up a pipeline that allows you to skip the checks upon
    a certain keyword (for example, `skip ci`) in the commit message. This approach,
    however, should only be the last resort—otherwise, you will never start refactoring
    old code. It takes some self-restraint from the developers not to misuse this
    feature, too.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要急于求成。如果你配置你的CI/CD管道只检查已修改的文件，你可以随着时间的推移，逐步改进代码。这确实会给你留下一个问题，一旦你接触到一个文件，你必须重构它以满足规则。特别是对于旧但庞大的类，这可能会成为问题。然而，在[*第7章*](B19050_07.xhtml#_idTextAnchor084)中，*代码质量工具*，我们解释了如何排除文件或代码的一部分以进行执行检查。你甚至可以设置一个管道，允许你在提交信息中包含某些关键字（例如，`skip
    ci`）时跳过检查。然而，这种方法只能是最后的手段——否则，你永远不会开始重构旧代码。这需要开发者有一定的自我克制，不要滥用这个功能。
- en: Over time, the team working on the project will gather new confidence, and with
    growing test coverage, they will start refactoring more and more code. Make sure
    to install a local pipeline as well, to keep the waiting times short.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，参与项目工作的团队将积累新的信心，随着测试覆盖率的提高，他们将开始越来越多地重构代码。确保也安装一个本地管道，以缩短等待时间。
- en: An outlook on CD
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对CD的展望
- en: 'Eventually, your CI pipeline will work so well that you can fully trust it.
    It will prevent shipping broken code into production reliably, and at some point,
    you find yourself doing fewer and less-manual checks if the deployment went well.
    At that point, you could think about using CD: this describes the combination
    of tools and processes to deploy code to any environment automatically.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你的持续集成（CI）管道将运行得如此之好，以至于你可以完全信任它。它将可靠地防止将损坏的代码部署到生产环境中，在某个时刻，如果你发现部署顺利，你发现自己做的检查越来越少，也越来越不手动。到了这个时候，你可以考虑使用持续部署（CD）：这描述了将代码自动部署到任何环境的工具和流程的组合。
- en: A usual workflow is that whenever changes get merged into a certain branch (for
    example, `main` for the production environment), the CI/CD pipeline will be triggered
    automatically. If the changes pass all checks and tests, the process is trusted
    so much that the code gets deployed into the desired destination without testing
    the build result manually anymore.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的流程是，每当更改合并到某个分支（例如，用于生产环境的`main`分支）时，CI/CD管道将自动触发。如果更改通过了所有检查和测试，那么过程被信任得如此之高，以至于代码被部署到目标位置，而无需再手动测试构建结果。
- en: If you ever had the opportunity to work in such an environment, you surely do
    not want to miss it. Besides a great CI/CD pipeline and 99% trust in it, it requires
    some more processes in place to quickly react if a deployment has problems. Even
    the best tools cannot prevent logical errors or infrastructural issues that will
    only appear under a greater load.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经有机会在这样的环境中工作，你肯定不希望错过。除了一个出色的CI/CD管道和对其99%的信任之外，还需要一些流程来快速应对部署出现的问题。即使最好的工具也无法防止在更大负载下才会出现的逻辑错误或基础设施问题。
- en: 'Whenever there is a problem after deployment, your team should be the first
    ones to notice! You not only need to fully trust the pipeline but the monitoring
    and logging setup as well. There are many concepts and tools out there, and we
    are finally leaving the topic of code quality here, entering the realms of **development-operations**
    (**DevOps**) and system administration. Nevertheless, we want to give you some
    short guidance on a few key concepts you might want to delve into, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后出现问题时，你的团队应该是第一个注意到的人！你不仅需要完全信任管道，还需要信任监控和日志记录设置。外面有众多概念和工具，我们最终将离开代码质量的话题，进入**开发运维**（**DevOps**）和系统管理的领域。尽管如此，我们仍想给你一些关于一些你可能想要深入了解的关键概念的简要指导，如下所示：
- en: '**Monitoring** gathers information about the status of a system. In our context,
    this is usually information such as **central processing unit** (**CPU**) load,
    **random-access memory** (**RAM**) usage, or database traffic of all servers or
    instances. For example, if the CPU load suddenly increases massively, this is
    an excellent indicator that there is trouble ahead.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**收集有关系统状态的信息。在我们的环境中，这通常是有关所有服务器或实例的中央处理单元（**CPU**）负载、随机存取存储器（**RAM**）使用或数据库流量的信息。例如，如果CPU负载突然大幅增加，这是一个很好的迹象，表明前方可能有麻烦。'
- en: '**Logging** helps you organize all log messages your application produces in
    a single, easily accessible place. It is not helpful if you need to search for
    any log files on different servers first when the system is in trouble and all
    alerts are ringing.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**帮助你将应用程序产生的所有日志消息组织在一个单一、易于访问的地方。当系统出现问题时，如果需要先在多个服务器上搜索任何日志文件，那么这并没有帮助，此时所有警报都在响起。'
- en: There are multiple **deployment methods** available. Especially when your setup
    has grown and consists of multiple servers or cloud instances, you can roll out
    the new code just on a few instances or even a separate deploy environment and
    monitor the behavior there. If all goes well, you can continue the deploy to the
    remaining instances. These methods are called **canary**, **rolling**, and **blue/green**
    deployments. You will find a link with more information on them at the end of
    this chapter.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种**部署方法**可供选择。特别是当你的设置已经增长并包含多个服务器或云实例时，你只需在少数实例或甚至一个单独的部署环境中推出新代码，并监控那里的行为。如果一切顺利，你可以继续将部署扩展到剩余的实例。这些方法被称为**金丝雀**、**滚动**和**蓝绿**部署。你将在本章末尾找到更多关于这些方法的链接。
- en: Regardless of how well you monitor your software, if things go wrong (and they
    will), you need to go back to a previous version of your application. This is
    called a **rollback**. You should always be prepared to go back to the previous
    version as fast and easy as possible. This requires you to have the deliverables
    of several previous versions available. It is a good idea to keep at least 5 or
    10 versions because sometimes, it is not clear which version exactly caused the
    problem.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你如何监控你的软件，如果出了问题（而且它们会），你需要回到应用程序的早期版本。这被称为**回滚**。你应该总是准备好尽可能快、尽可能容易地回到上一个版本。这要求你拥有几个早期版本的交付成果。保留至少5个或10个版本是个好主意，因为有时并不清楚哪个版本确切地导致了问题。
- en: Surely, CD is beyond the scope of writing clean PHP code. However, we think
    it is a goal worth aiming for, as it will speed up your development a lot, and
    introduces you to a variety of fascinating tools and concepts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CD超出了编写干净PHP代码的范围。然而，我们认为这是一个值得追求的目标，因为它将大大加快您的开发速度，并使您接触到各种迷人的工具和概念。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We hope that, after reading this chapter, you are as convinced as we are that
    CI is extremely helpful and thus a must-have tool in your toolbox. We explained
    the necessary terms around this topic as well as the different stages of a pipeline,
    not only in theory but also in practice, by building a simple but working pipeline
    using GitHub Actions. Finally, we gave you an outlook on CD.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望，在阅读这一章后，您会像我们一样坚信CI极其有用，因此是您工具箱中不可或缺的工具。我们不仅从理论上，而且通过使用GitHub Actions构建一个简单但实用的管道，在实践中也解释了这一主题的必要术语以及管道的不同阶段。最后，我们为您展望了CD。
- en: You now have a great foundation of knowledge and tools to write great PHP code.
    Of course, learning never stops, and there is so much more knowledge out there
    for you to discover that we could not fit into this book.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有了编写出色PHP代码所需的知识和工具基础。当然，学习永远不会停止，而且还有许多知识等待您去发现，我们无法将它们全部放入这本书中。
- en: If you made developing PHP software your profession, then you usually work in
    teams of developers. And even if you are maintaining your own open source project,
    you will interact with others—for example, when they submit changes to your code.
    CI is an important building block, but not the only thing you need to consider
    for a successful team setup.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将开发PHP软件作为职业，那么您通常会在开发团队中工作。即使您在维护自己的开源项目，您也会与其他人互动——例如，当他们向您提交代码更改时。CI是一个重要的构建块，但不是您在成功团队设置中需要考虑的唯一事情。
- en: For us, this topic is so important that we dedicated the next two chapters to
    introducing modern collaboration techniques that will help you to write great
    PHP code when working in teams. We hope to see you in the next chapter!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，这个话题非常重要，以至于我们专门用接下来的两章来介绍现代协作技术，这些技术将帮助您在团队中编写出色的PHP代码。我们希望在下章中见到您！
- en: Further reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you wish to know more, have a look at the following resources:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多，请查看以下资源：
- en: 'Additional information about GitHub Actions:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GitHub Actions的更多信息：
- en: 'The official *GitHub Actions* documentation with lots of examples: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含大量示例的官方*GitHub Actions*文档：[https://docs.github.com/en/actions](https://docs.github.com/en/actions)
- en: '`setup-php` is not only very useful for PHP developers, but also offers a lot
    of useful information—for example, about the *matrix setup* (how to test code
    against several PHP versions) or *caching Composer dependencies* to speed up the
    build: [https://github.com/marketplace/actions/setup-php-action](https://github.com/marketplace/actions/setup-php-action)'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup-php`不仅对PHP开发者非常有用，还提供了大量有用的信息——例如，关于*矩阵设置*（如何针对多个PHP版本测试代码）或*缓存Composer依赖项*以加快构建速度：[https://github.com/marketplace/actions/setup-php-action](https://github.com/marketplace/actions/setup-php-action)'
- en: 'More information about CD and related topics can be found here:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CD和相关主题的更多信息可以在这里找到：
- en: 'A good overview of CD: [https://www.atlassian.com/continuous-delivery](https://www.atlassian.com/continuous-delivery)'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD的良好概述：[https://www.atlassian.com/continuous-delivery](https://www.atlassian.com/continuous-delivery)
- en: 'Logging and monitoring explained: [https://www.vaadata.com/blog/logging-monitoring-definitions-and-best-practices/](https://www.vaadata.com/blog/logging-monitoring-definitions-and-best-practices/)'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和监控解释：[https://www.vaadata.com/blog/logging-monitoring-definitions-and-best-practices/](https://www.vaadata.com/blog/logging-monitoring-definitions-and-best-practices/)
- en: 'A great introduction to advanced deployment methods: [https://www.techtarget.com/searchitoperations/answer/When-to-use-canary-vs-blue-green-vs-rolling-deployment](https://www.techtarget.com/searchitoperations/answer/When-to-use-canary-vs-blue-green-vs-rolling-deployment)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级部署方法的精彩介绍：[https://www.techtarget.com/searchitoperations/answer/When-to-use-canary-vs-blue-green-vs-rolling-deployment](https://www.techtarget.com/searchitoperations/answer/When-to-use-canary-vs-blue-green-vs-rolling-deployment)
- en: 'Tools and links regarding your local pipeline:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您本地管道相关的工具和链接：
- en: 'More insights on Git hooks: [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Git钩子的更多见解：[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)
- en: 'GrumPHP is a local CI pipeline “out of the box”: [https://github.com/phpro/grumphp](https://github.com/phpro/grumphp)'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GrumPHP是一个“开箱即用”的本地CI管道：[https://github.com/phpro/grumphp](https://github.com/phpro/grumphp)
