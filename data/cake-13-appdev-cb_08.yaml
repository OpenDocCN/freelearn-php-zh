- en: Chapter 8. Working with Shells
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。与Shell一起工作
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Building and running a shell
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 和运行一个Shell
- en: Parsing command line parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析命令行参数
- en: Creating reusable shell tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用Shell任务
- en: Sending e-mails from shells
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Shell发送电子邮件
- en: Creating Non-interactive tasks with the robot plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器人插件创建非交互式任务
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most powerful, yet unknown, features of CakePHP is its shell framework.
    It provides applications with all that is required for building command-line tools,
    which can be used to perform intensive tasks and any other type of non-interactive
    processing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP 最强大且鲜为人知的功能之一是其Shell框架。它为应用程序提供了构建命令行工具所需的一切，这些工具可以用于执行密集型任务和其他类型的非交互式处理。
- en: This chapter introduces the reader to CakePHP shells by starting with the process
    of building basic shells, and then moving on to more advanced features, such as
    sending e-mails and running controller actions from shells. It finishes by presenting
    the robot plugin, which offers a fully featured solution for scheduling and running
    tasks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍构建基本Shell的过程来向读者介绍 CakePHP Shell，然后继续介绍更高级的功能，例如从Shell发送电子邮件和运行控制器操作。最后，它通过介绍机器人插件来结束，该插件提供了一套完整的解决方案，用于调度和运行任务。
- en: Building and running a shell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 和运行一个Shell
- en: In this recipe, we will learn how to build and run a custom shell, which will
    ask for a username and a password, and add the given account to a list of user
    accounts. Based on the system created in the recipe *Setting up a basic authentication
    system* from [Chapter 1](ch01.html "Chapter 1. Authentication"), *Authentication*,
    this shell is a great help when looking to create test accounts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何构建和运行一个自定义Shell，该Shell将要求输入用户名和密码，并将指定的账户添加到用户账户列表中。基于来自 *第1章*
    的食谱 *设置基本认证系统*，这个Shell在创建测试账户时非常有帮助。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need an authentication system. Follow the entire
    recipe *Setting up a basic authentication system* from *Authentication* chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们需要一个认证系统。遵循来自 *认证* 章节的整个食谱 *设置基本认证系统*。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a file named `user.php` and place it in your `app/vendors/shells` folder,
    with the following contents:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `user.php` 的文件，并将其放置在你的 `app/vendors/shells` 文件夹中，内容如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are now ready to run our shell. Open a terminal window, and access the directory
    where your application resides. Inside this directory you should have your `app/`
    and `cake/` folders. For example, if your application is installed in `/var/www/myapp`,
    then `/var/www/myapp/app` should be your `app/` folder, and `/var/www/myapp/cake`
    your `cake/` folder. While standing in your application''s main directory (`/var/www/myapp`
    in this example), run:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行我们的Shell了。打开一个终端窗口，访问你的应用程序所在的目录。在这个目录中，你应该有你的 `app/` 和 `cake/` 文件夹。例如，如果你的应用程序安装在
    `/var/www/myapp`，那么 `/var/www/myapp/app` 应该是你的 `app/` 文件夹，而 `/var/www/myapp/cake`
    应该是你的 `cake/` 文件夹。在你应用程序的主要目录（例如，在这个例子中是 `/var/www/myapp`）中，运行：
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about setting the right path when running shells, or how to add
    the cake shell script to your PATH environment variable see [http://book.cakephp.org/view/1106/The-CakePHP-Console](http://book.cakephp.org/view/1106/The-CakePHP-Console)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于运行Shell时设置正确路径的信息，或者如何将 cake shell 脚本添加到你的 PATH 环境变量中，请参阅[http://book.cakephp.org/view/1106/The-CakePHP-Console](http://book.cakephp.org/view/1106/The-CakePHP-Console)
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 GNU Linux / Mac / Unix 系统：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Microsoft Windows：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you receive an error message such as **Error: Class UserShell could not
    be loaded**, this means that CakePHP is unable to find your `app/` folder, which
    is probably because you have a different name for the `app/` folder. In this case,
    you can specify the folder with the `app` argument, like so: `$ cake/console/cake
    -app /var/www/myapp/app user`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个错误信息，例如**错误：无法加载类UserShell**，这意味着 CakePHP 无法找到你的 `app/` 文件夹，这可能是由于你的
    `app/` 文件夹名称不同。在这种情况下，你可以使用 `app` 参数指定文件夹，如下所示：`$ cake/console/cake -app /var/www/myapp/app
    user`。
- en: 'Once the shell is run, it will ask us for the desired username and password,
    and will wait for a final confirmation before creating the account, as shown in
    the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Shell运行，它将要求我们输入所需的用户名和密码，并在创建账户之前等待最终确认，如下面的截图所示：
- en: '![How to do it...](img/1926_8_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1926_8_01.jpg)'
- en: We are now able to use this account when logging in through our application's
    login page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够通过应用程序的登录页面登录时使用这个账户。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started by importing the `Security` class, which is used for hashing the
    password prior to saving the user record. We then created a class named `UserShell`,
    extending it from CakePHP's `Shell` class, which offers us a set of methods and
    properties that are helpful when building shells. One of such properties is `uses`,
    which works the same way as a controller's `uses` property—by defining a list
    of application models that should be instantiated and ready to use from any method
    in the shell.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入了`Security`类，该类用于在保存用户记录之前对密码进行散列。然后我们创建了一个名为`UserShell`的类，它扩展了CakePHP的`Shell`类，这为我们提供了一套在构建shell时非常有用的方法和属性。其中之一是`uses`属性，它的工作方式与控制器的`uses`属性相同——通过定义一个列表，列出应该实例化并准备好在shell中的任何方法中使用的应用程序模型。
- en: Our shell's entry point is the `main()` method. This comes as no surprise if
    you have any experience developing C, C++, or Java applications, as `main()` is
    also their entry function. If you have no such experience, then all there is to
    know is that `main()` will be automatically executed by CakePHP when our shell
    is invoked through the command line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们shell的入口点是`main()`方法。如果你有任何开发C、C++或Java应用程序的经验，这并不会让你感到惊讶，因为`main()`也是它们的入口函数。如果你没有这样的经验，那么你需要知道的是，`main()`将在我们的shell通过命令行调用时自动由CakePHP执行。
- en: 'Our `main()` method starts by asking the user for their desired username. To
    ask for user input, we use the `in()` method (available through the `Shell` parent
    class), which takes up to three arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main()`方法首先请求用户输入他们想要的用户名。为了请求用户输入，我们使用`in()`方法（通过`Shell`父类提供），它最多可以接受三个参数：
- en: '`prompt`: The message that is shown to the user before asking for their input.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prompt`：在请求用户输入之前显示给用户的消息。'
- en: '`options`: An optional set of values that the user should be restricted to
    when entering their input.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：一个可选的值集，用户在输入时应该被限制在这些值中。'
- en: '`default`: An optional default value that is to be used if the user enters
    no input by clicking *Enter* at the prompt.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：一个可选的默认值，如果用户在提示符下点击*Enter*而没有输入，则使用此值。'
- en: If the user does not specify a user name, we exit the application by calling
    the `_stop()` method, available to all CakePHP classes that descend from `Object,
    Shell` being one of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有指定用户名，我们将通过调用所有从`Object, Shell`派生的CakePHP类都有的`_stop()`方法来退出应用程序。
- en: Once we have our username, we need to ask for a password. As a useful alternative,
    we want to offer the user an automatically generated password. To generate this
    password, we implement a method called, not surprisingly, `_randomPassword().`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了用户名，我们需要请求一个密码。作为一个有用的替代方案，我们希望向用户提供一个自动生成的密码。为了生成这个密码，我们实现了一个名为`_randomPassword()`的方法。
- en: 'This method takes one argument, the size of the generated password, and builds
    it by randomly selecting an element from a defined set of characters. This set
    is constructed by including all characters between the letters `A` and `Z, a`
    and `Z`, and `0` and `9`. For more secure passwords, we also included the symbols
    `@ ! # $` and `_` as valid characters.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '此方法接受一个参数，即生成的密码的大小，并通过从定义的字符集中随机选择一个元素来构建它。这个集合是通过包括字母`A`到`Z`，`a`到`z`和`0`到`9`之间的所有字符来构建的。为了生成更安全的密码，我们还包括了符号`@
    ! # $`和`_`作为有效字符。'
- en: When we use the `in()` method to ask the user for a password, we use this default
    generated password as its third argument (`default.`) After asking for the password,
    we show the user the choice for username and password, and ask for confirmation,
    utilizing the `options` argument in our call to `in()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`in()`方法请求用户输入密码时，我们使用这个默认生成的密码作为它的第三个参数（`default.`）。在请求密码后，我们向用户展示用户名和密码的选择，并请求确认，利用我们在`in()`调用中的`options`参数。
- en: 'If the user confirms the operation, we proceed to create the user record, hashing
    the entered password with the `Security::hash()` method, which takes up to three
    arguments:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确认操作，我们将继续创建用户记录，使用`Security::hash()`方法对输入的密码进行散列，该方法最多可以接受三个参数：
- en: '`string`: The string to be hashed.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：要散列的字符串。'
- en: '`method`: The method to use for hashing, which can be any of: `sha1, sha256,
    md5`, or any other method supported by the `hash()` PHP function. Defaults to
    the following PHP functions, depending on their availability: `sha1()` (also used
    if `sha1` is the chosen method), `mhash()` (also used if `sha256` is the chosen
    method), `hash()`, and finally `md5()`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：用于哈希的方法，可以是以下之一：`sha1`、`sha256`、`md5`或`hash()` PHP函数支持的任何其他方法。默认情况下，取决于它们的可用性，使用以下PHP函数：`sha1()`（如果选择`sha1`作为方法，也会使用），`mhash()`（如果选择`sha256`作为方法，也会使用），`hash()`，最后是`md5()`。'
- en: '`salt`: If `true`, prefixes the string with the application''s salt (available
    in the `Configure` setting `Security.salt`). If a string is specified, it is prefixed
    to the password being hashed in place of the application''s `Security.salt` setting.
    If `false`, hashes the given string without a prefix.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt`：如果为`true`，则在字符串前添加应用程序的盐（可在`Configure`设置`Security.salt`中找到）。如果指定了一个字符串，则将其作为应用程序的`Security.salt`设置的前缀添加到要哈希的密码中。如果为`false`，则不带前缀对给定的字符串进行哈希处理。'
- en: If a record is created, we inform the user that the operation succeeded. Otherwise
    we use the `error()` method (available through the `Shell` parent class) which
    sends an error message through the standard error stream and exits the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了记录，我们通知用户操作成功。否则，我们使用`error()`方法（通过`Shell`父类提供）通过标准错误流发送错误消息并退出应用程序。
- en: Using the Auth component for hashing passwords
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Auth组件进行密码哈希处理
- en: In this recipe, we called the `Security::hash()` method to hash passwords, by
    specifying the same exact arguments that are utilized in the `Auth` component.
    If we did not do so, we would have different hash values for the same passwords,
    which would render our shell useless, as any user account created with it wouldn't
    be able to log in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过指定与`Auth`组件中使用的相同精确参数调用了`Security::hash()`方法来哈希密码。如果我们没有这样做，相同的密码将会有不同的哈希值，这将使我们的shell变得无用，因为使用它创建的任何用户账户都无法登录。
- en: 'The problem with this approach is that if the method that is used by the `Auth`
    component to hash passwords is changed, we would need to reflect such changes
    in our shell. Therefore, we may want to use the `Auth` component to do the hashing
    instead. This solution requires a bit of extra effort, as components are not natively
    available in a shell. Edit your `app/vendors/shells/user.php` file and remove
    the import of the `Security` class, and then add the following import statement
    at the beginning of the file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果`Auth`组件用于哈希密码的方法被更改，我们需要在我们的shell中反映这些更改。因此，我们可能想使用`Auth`组件来进行哈希处理。这个解决方案需要一些额外的努力，因为组件在shell中不是原生可用的。编辑你的`app/vendors/shells/user.php`文件，并移除对`Security`类的导入，然后在文件开始处添加以下导入语句：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now need to instantiate the `AuthComponent` class. Add the following code
    to the beginning of the `main()` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实例化`AuthComponent`类。将以下代码添加到`main()`方法的开始部分：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally change the definition of the data that is used for creating the `User`
    record, so its `password` field is hashed using the `Auth` component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后更改用于创建`User`记录的数据定义，使其`password`字段使用`Auth`组件进行哈希处理：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Parsing command line parameters*'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解析命令行参数*'
- en: Parsing command line parameters
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析命令行参数
- en: The recipe *Building and running a shell* showed us how to create a shell that
    adds records based on user-provided information. This recipe adds support to import
    accounts from a CSV file, while allowing the user to configure different settings
    through the use of command-line parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱*构建和运行shell*展示了如何创建一个基于用户提供的信息的记录添加shell。这个菜谱增加了从CSV文件导入账户的支持，同时允许用户通过使用命令行参数来配置不同的设置。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need the user shell implemented. Follow the entire
    recipe *Building and running a shell*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，我们需要实现用户shell。遵循整个菜谱*构建和运行shell*。
- en: 'We will also need a sample CSV file from which to import records. Create a
    file named `users.csv` and place it in a directory of your choice (for example,
    in the application''s `app/tmp` directory) with the following contents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个样本CSV文件来导入记录。创建一个名为`users.csv`的文件，并将其放置在你选择的目录中（例如，在应用程序的`app/tmp`目录中），内容如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Edit your `app/vendors/shells/user.php` file, and change the name of the method
    `main()` to `add()`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/vendors/shells/user.php`文件，并将`main()`方法的名字改为`add()`。
- en: 'Add the following method right below the `add()` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`add()`方法下面添加以下方法：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now add the following method above the `_randomPassword()` method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `_randomPassword()` 方法之上添加以下方法：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, add the following below the `help()` method:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `help()` 方法之下添加以下内容：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run the shell without arguments, CakePHP will say that there is no known
    command, and suggest that we get help by specifying `help` as an argument to our
    shell. Doing so will display our help message, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不带参数运行 shell，CakePHP 会说没有已知的命令，并建议我们通过将 `help` 作为 shell 的参数来获取帮助。这样做将显示我们的帮助信息，如下面的截图所示：
- en: '![How to do it...](img/1926_8_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_8_06.jpg)'
- en: If we run our shell with the `add` argument, we will see exactly the same functionality
    implemented in the recipe *Building and running a shell*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `add` 参数运行我们的 shell，我们将看到与在 *构建和运行 shell* 脚本中实现的功能完全相同。
- en: 'Executing the shell with the `import` argument and the `verbose` parameter,
    and specifying the path to our CSV file with a command such as the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `import` 参数和 `verbose` 参数执行 shell，并使用如下命令指定我们的 CSV 文件的路径：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'would import the users listed in the CSV file, generating an output similar
    to what is shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将导入 CSV 文件中列出的用户，生成类似于以下截图所示的输出：
- en: '![How to do it...](img/1926_8_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_8_02.jpg)'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We started by changing the name of the entry method to `add()`. Doing so means
    we no longer have an entry method, so how does CakePHP find what to run when our
    shell is invoked? Through the use of commands.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将入口方法的名字改为 `add()`。这样做意味着我们不再有入口方法，那么当我们的 shell 被调用时，CakePHP 如何找到要运行的内容呢？通过使用命令。
- en: If there is no entry method defined in a shell, CakePHP will assume that the
    first argument used when executing a shell is a command. A command is nothing
    more than a public method that does not start with an underscore sign. As such,
    a method named `add()` is executed when the shell is invoked with the `add` argument.
    If no argument is specified, CakePHP complains, as there is no command to run,
    and suggests the user use the `help` argument, which is nothing more than a way
    to call the `help()` method in our shell (as `help` is a regular command).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 shell 中没有定义入口方法，CakePHP 将假设在执行 shell 时使用的第一个参数是一个命令。命令不过是一个不以下划线符号开头的公共方法。因此，当
    shell 使用 `add` 参数调用时，会执行名为 `add()` 的方法。如果没有指定参数，CakePHP 会抱怨因为没有可运行的命令，并建议用户使用
    `help` 参数，这实际上是通过调用我们的 shell 中的 `help()` 方法（因为 `help` 是一个常规命令）来实现的。
- en: 'We use the `help()` method to show usage instructions for our shell, listing
    the available commands (add, and `import)`, and the parameters for each of those
    commands. While the `add` command has no available parameters, we support the
    following parameters for our `import` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `help()` 方法来显示我们 shell 的使用说明，列出可用的命令（添加和 `import`），以及每个命令的参数。虽然 `add` 命令没有可用的参数，但我们为我们的
    `import` 命令支持以下参数：
- en: '| Setting | Purpose |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 目的 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `limit` | A maximum number of records to process from the CSV file. If omitted,
    all records will be processed. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `limit` | 从 CSV 文件中处理的最大记录数。如果省略，将处理所有记录。 |'
- en: '| `size` | The maximum length for the generated passwords. Defaults to `10`.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 生成的密码的最大长度。默认为 `10`。 |'
- en: '| `verbose` | If specified, the shell will output information as its creating
    the user records. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `verbose` | 如果指定，shell 将在创建用户记录时输出信息。 |'
- en: The `_parseCSV()` method is our helper method to parse a CSV file, returning
    an array of rows found in a file, where each row is itself an array of values.
    This method uses PHP's `fgetcsv()` function to parse a record from a file handle,
    obtained with the use of PHP's `fopen()` function, and closed with `fclose()`
    once the parsing is finished.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`_parseCSV()` 方法是我们解析 CSV 文件的帮助方法，返回文件中找到的行数组，其中每一行本身也是一个值数组。此方法使用 PHP 的 `fgetcsv()`
    函数从文件句柄中解析记录，该文件句柄是通过使用 PHP 的 `fopen()` 函数获得的，并在解析完成后使用 `fclose()` 关闭。'
- en: We continue by implementing the `import()` method, the body of our `import`
    command. This method uses the `_checkArgs()` method (available through the `Shell`
    class) to make sure that the command receives at least the specified number of
    arguments, in our case `1`. If the method finds that the user did not specify
    the minimum number of arguments, it will throw an error message and abort the
    execution. This is a way for us to make sure that at least the path to the CSV
    file is provided.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续实现 `import()` 方法，即我们的 `import` 命令的主体。该方法使用 `_checkArgs()` 方法（通过 `Shell`
    类提供）来确保命令至少接收了指定的参数数量，在我们的例子中是 `1`。如果该方法发现用户没有指定最小数量的参数，它将抛出一个错误消息并终止执行。这是我们确保至少提供了
    CSV 文件路径的一种方式。
- en: 'If the number of arguments is correct we proceed to process the optional parameters.
    To do so, we use the `params` property. This property is available to all shells,
    and includes the following values even when no parameters are provided:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数数量正确，我们继续处理可选参数。为此，我们使用 `params` 属性。即使没有提供参数，该属性对所有壳子都可用，并包括以下值：
- en: '| Setting | Purpose |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 目的 |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app` | The name of the `app/` directory. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `app` | `app/` 目录的名称。 |'
- en: '| `root` | The full path to our application''s root directory, which would
    contain the `app/` and `cake/` directories. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `root` | 我们应用程序根目录的完整路径，其中包含 `app/` 和 `cake/` 目录。 |'
- en: '| `webroot` | The name of the `webroot/` directory, which is inside the `app/`
    directory. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `webroot` | `webroot/` 目录的名称，它位于 `app/` 目录内部。 |'
- en: '| `working` | The full path to the `app/` directory. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `working` | `app/` 目录的完整路径。 |'
- en: However, we are only interested in the parameters given by the user through
    the command line. Therefore, we define the set of valid parameters with their
    default values, and we merge the values for those parameters that are available
    in the `params` property. We store this merged values in an array named `options`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只对用户通过命令行提供的参数感兴趣。因此，我们定义了具有默认值的有效参数集，并将 `params` 属性中可用的那些参数的值合并在一起。我们将这些合并后的值存储在一个名为
    `options` 的数组中。
- en: Using the `is_file()` and `is_readable()` PHP functions, we make sure we were
    given a valid file. If not, we use the `error()` method to print out an error
    message and abort the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is_file()` 和 `is_readable()` PHP 函数，我们确保我们得到了一个有效的文件。如果没有，我们使用 `error()`
    方法打印出错误消息并终止应用程序。
- en: We then proceed to use `_importCSV()` to get a list of parsed rows, and for
    each of those rows we assign a random password, using the `size` option. We stop
    generating passwords once we reach the value of the `limit` option, if one is
    provided. By the end of this loop, we will have an array named `users` where its
    index is a username, and its value is the password for the given user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着使用 `_importCSV()` 函数来获取解析后的行列表，并为这些行中的每一行分配一个随机密码，使用 `size` 选项。如果提供了 `limit`
    选项，一旦达到该值，我们就停止生成密码。在这个循环结束时，我们将有一个名为 `users` 的数组，其中索引是用户名，值是给定用户的密码。
- en: For each of the values in the `users` array, we create the account record similar
    to the way we do it in the `add` command, while outputting the status of each
    creation if the `verbose` option is set. If we get an error while creating a specific
    record, we remove the problematic user from the `users` array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `users` 数组中的每个值，我们创建与 `add` 命令中类似的用户记录，如果设置了 `verbose` 选项，则输出每个创建的状态。如果在创建特定记录时遇到错误，我们将有问题的用户从
    `users` 数组中删除。
- en: Once the creation process is finalized, we output the list of successfully created
    usernames, together with their generated passwords.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建过程完成，我们输出成功创建的用户名列表，以及它们生成的密码。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Parsing CSV files with a datasource* in [Chapter 5](ch05.html "Chapter 5. Datasources"),
    *Datasources*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](ch05.html "第5章。数据源")*Parsing CSV files with a datasource*，*数据源*'
- en: '*Creating reusable shell tasks*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建可重用的壳子任务*'
- en: Creating reusable shell tasks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的壳子任务
- en: Just as we have components to share functionality amongst controllers, we also
    have behaviors for models, and helpers for views. What about shells? CakePHP offers
    the concept of tasks, which are classes that also extend from the `Shell` class,
    but can be reused from other shells.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们有组件可以在控制器之间共享功能一样，我们也有模型的行为和视图的帮助器。那么壳子呢？CakePHP 提供了任务的概念，这些是扩展自 `Shell`
    类的类，但可以从其他壳子中重用。
- en: In this recipe, we will learn how to build a task that handles argument and
    parameter processing for our shell, can auto-generate help messages, and check
    the definition of mandatory arguments and optional parameters. We will implement
    this task in the most generic fashion, so we can use it for any future shells
    we may decide to build.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何构建一个处理shell的参数和参数处理的任务，可以自动生成帮助信息，并检查必填参数和可选参数的定义。我们将以最通用的方式实现这个任务，以便我们可以将其用于我们可能决定构建的任何未来的shell。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need a shell that accepts parameters and has different
    commands available. Follow the entire recipe *Parsing command line parameters*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要一个接受参数并且有不同命令可用的shell。遵循整个配方中的*解析命令行参数*。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Edit your `app/vendors/shells/user.php` file and add the following right below
    the declaration of the `uses` property:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/vendors/shells/user.php`文件，并在`uses`属性的声明下方添加以下内容：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While still editing the shell, remove the `help()` method, and remove the following
    lines from the beginning of the `import()` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然编辑shell的同时，删除`help()`方法，并从`import()`方法的开始处删除以下几行：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following lines at the beginning of the `import()` method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`import()`方法的开始处添加以下几行：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a file named `help.php` and place it in your `app/vendors/shells/tasks`,
    with the following contents:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`help.php`的文件，并将其放置在`app/vendors/shells/tasks`中，内容如下：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following methods to the created `HelpTask` class:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向创建的`HelpTask`类添加以下方法：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While still editing the `HelpTask` class, add the following helper methods
    to the class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然编辑`HelpTask`类的同时，向该类添加以下辅助方法：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you now run the shell without any parameters, with a command such as the
    following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行不带任何参数的shell，使用如下命令：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'we would get the thorough help message shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下截图所示的详细帮助信息：
- en: '![How to do it...](img/1926_8_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1926_8_03.jpg)'
- en: 'We can also obtain detailed help for a specific command. Running the shell
    with a command such as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为特定命令获取详细帮助。使用如下命令运行shell：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'would show us the help message for the `import` command, as shown in the following
    screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示`import`命令的帮助信息，如下截图所示：
- en: '![How to do it...](img/1926_8_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1926_8_04.jpg)'
- en: Running the shell with the same parameters as the ones used in the recipe *Parsing
    command line parameters* to import CSV files should work as expected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与配方*解析命令行参数*中使用的相同参数运行shell以导入CSV文件应该按预期工作。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a shell includes the property `tasks` in its declaration, it is said to
    use the specified tasks. Tasks are stored in the `app/vendors/shells/tasks` folder,
    and are accessible in the shell as instances. In our case, we add a task named
    `Help`, which should be implemented in a class named `HelpTask` and placed in
    a file named `help.php` in the `tasks` folder, and we refer to it as `$this->Help`
    from within the shell.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个shell在其声明中包含`tasks`属性时，它被认为是使用了指定的任务。任务存储在`app/vendors/shells/tasks`文件夹中，并且可以在shell中以实例的形式访问。在我们的情况下，我们添加一个名为`Help`的任务，它应该在名为`HelpTask`的类中实现，并放置在`tasks`文件夹中的名为`help.php`的文件中，并且我们在shell中通过`$this->Help`来引用它。
- en: 'Before proceeding, a point has to be made regarding the naming of this particular
    task. As we want our task to automatically generate help messages for our shell,
    we somehow need to catch the call to the `help()` command. This is only achievable
    if we first understand how the shell dispatching process works. Let us assume
    the following invocation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，必须指出关于这个特定任务的命名问题。因为我们希望我们的任务能够自动为我们的shell生成帮助信息，所以我们必须以某种方式捕获对`help()`命令的调用。这只有在首先理解shell分发过程如何工作的情况下才能实现。让我们假设以下调用：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The shell dispatcher, implemented in the file `cake/console/cake.php`, would
    go through the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现于文件`cake/console/cake.php`中的shell分发器将经过以下步骤：
- en: Instantiate the shell class `UserShell`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化shell类`UserShell`。
- en: Call its `initialize()` method.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用它的`initialize()`方法。
- en: Load all tasks defined in the `tasks` property of the shell.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载shell中定义在`tasks`属性下的所有任务。
- en: For each of those tasks, call their `initialize()` method, and load any tasks
    that they themselves may be using.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些任务中的每一个，调用它们的`initialize()`方法，并加载它们可能使用的任何任务。
- en: If the given command (`import` in this case) is the name of one of the included
    tasks, call the task's `startup()` method, and then its `execute()` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的命令（在这种情况下为 `import`）是包含的任务之一，则调用任务 `startup()` 方法，然后调用其 `execute()` 方法。
- en: If the given command is not a task name, then call the shell's `startup()` method,
    and execute the command's method, if it exists, or the entry method `main()` if
    the command is not implemented.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的命令不是任务名称，则调用shell的 `startup()` 方法，如果存在，则执行命令的方法，或者如果命令未实现，则执行入口方法 `main()`。
- en: 'This means that if we have a task named `Help` included in our shell, and the
    user launches the shell with the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个名为 `Help` 的任务包含在我们的shell中，并且用户使用以下命令启动shell：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then the shell dispatcher would call the `execute()` method of the `HelpTask`
    class, because the command, `help`, is actually the name of one of the shell's
    tasks. Knowing this, we can remove the `help()` implementation of our `User` shell,
    and have the `Help` task handle the display of help messages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，shell分发器将调用 `HelpTask` 类的 `execute()` 方法，因为命令 `help` 实际上是shell任务之一的名字。了解这一点后，我们可以移除
    `User` shell 的 `help()` 实现，让 `Help` 任务处理帮助信息的显示。
- en: 'Furthermore, our `Help` task needs to be generic enough to not be tied to a
    specific shell. Therefore, we need a way to tell it about our available commands,
    expected arguments, and optional parameters. This is what the `commands` property
    is there for: an array of commands, where the key is the command name and the
    value any of the following settings:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的 `Help` 任务需要足够通用，以便不与特定shell绑定。因此，我们需要一种方法来告知它我们的可用命令、预期参数和可选参数。这就是 `commands`
    属性的作用：一个命令数组，其中键是命令名称，值是以下设置中的任何一个：
- en: '| Setting | Purpose |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 目的 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `help` | The help message describing the purpose of the command. Defaults
    to no message. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `帮助` | 描述命令目的的帮助信息。默认没有信息。 |'
- en: '| `args` | The list of mandatory and optional arguments the command takes.
    Defaults to no arguments. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 命令接受的强制性参数和可选参数列表。默认没有参数。 |'
- en: '| `params` | The list of optional parameters the command accepts. Defaults
    to no parameters. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `params` | 命令接受的可选参数列表。默认没有参数。 |'
- en: 'Notice, however, that the `add` command is defined in a different fashion:
    instead of being defined in the key, it is simply the name of the command added
    to the `commands` array. This means that the command has no help message, no arguments,
    and no parameters.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，`add` 命令的定义方式不同：它不是在键中定义，而是简单地作为添加到 `commands` 数组中的命令名称。这意味着该命令没有帮助信息，没有参数，也没有参数。
- en: 'The `args` command setting is an array of arguments, indexed by argument name.
    Each argument may define any of the following settings:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 命令设置是一个通过参数名称索引的参数数组。每个参数可以定义以下设置中的任何一个：'
- en: '| Setting | Purpose |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 目的 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `help` | The help message that describes the argument. Defaults to no message.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `帮助` | 描述参数的帮助信息。默认没有信息。 |'
- en: '| `mandatory` | If `true`, this argument must be present. If `false`, the argument
    may be omitted. Defaults to `false`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `强制性` | 如果 `true`，则此参数必须存在。如果 `false`，则可以省略此参数。默认为 `false`。 |'
- en: 'Similarly, the `params` command setting is also an array, indexed by parameter
    name, where each parameter may define any of the following settings:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`params` 命令设置也是一个数组，通过参数名称索引，其中每个参数可以定义以下设置中的任何一个：
- en: '| Setting | Purpose |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 目的 |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `help` | The help message that describes the parameter. Defaults to no message.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `帮助` | 描述参数的帮助信息。默认没有信息。 |'
- en: '| `type` | The type of data this parameter holds. May be `int, bool`, or `string`.
    Any other type is interpreted as `string`. Defaults to `string`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 此参数持有的数据类型。可以是 `int, bool` 或 `string`。任何其他类型都被解释为 `string`。默认为 `string`。
    |'
- en: '| `value` | A default value to use if the parameter is not specified. Defaults
    to no default value. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 如果未指定参数，则使用默认值。默认没有默认值。 |'
- en: Using the `commands` property in the `UserShell` class, we define the set of
    available arguments and parameters for our `import` command, and we then modify
    the `import()` method so that the options are obtained from the `parameters` property
    of the `Help` task. We also use the `extract()` PHP function to convert any arguments
    that are defined in the `arguments` property of the `Help` task to local variables.
    This way, the `path` argument will be available to the method as the variable
    `$path`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserShell`类中使用`commands`属性，我们定义了`import`命令可用的参数和参数集，然后修改了`import()`方法，使其选项从`Help`任务的`parameters`属性中获取。我们还使用`extract()`PHP函数将`Help`任务的`arguments`属性中定义的任何参数转换为局部变量。这样，`path`参数将以变量`$path`的形式对方法可用。
- en: These were all the modifications required in the `UserShell` class. Notice how
    we not only removed the `help()` method implementation, but also the processing
    of parameters, and the check for the right number of arguments from the `import()`
    method. This is all done automatically by the `Help` task now, based on what we
    define in our `commands` property.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserShell`类中所需的修改都已经完成。注意我们不仅移除了`help()`方法的实现，还去除了`import()`方法中对参数的处理以及正确参数数量的检查。现在这一切都由`Help`任务自动完成，基于我们在`commands`属性中定义的内容。
- en: This means that our `Help` task is indeed the Swiss Army knife of our shells,
    with most of its work being done in its `initialize()` method. This method starts
    by utilizing the PHP method, `get_class_vars(),` to obtain the `commands` property
    defined in the shell, because our task has no way of getting a hold of the instance
    of the `UserShell` class. It then proceeds to go through the list of commands,
    and normalizes all arguments and parameters thereby defined, assigning the resulting
    array to the `commands` property of the `HelpTask` class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`Help`任务确实是我们的shell的瑞士军刀，其大部分工作都是在其`initialize()`方法中完成的。该方法首先利用PHP方法`get_class_vars()`来获取shell中定义的`commands`属性，因为我们的任务没有方法获取`UserShell`类的实例。然后继续遍历命令列表，并规范化所有定义的参数和参数，将结果数组分配给`HelpTask`类的`commands`属性。
- en: Once we have all our commands ready to be checked, we establish if the user
    has indeed selected a command to be executed through the `command` property, available
    to all classes that extend from `Shell`, and set to the current command. If the
    user has not, and if there is no `main()` method implemented in the shell, we
    use the `_help()` method to display the help.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好所有要检查的命令，我们检查用户是否确实通过`command`属性选择了要执行的命令，该属性对所有从`Shell`扩展的类都可用，并设置为当前命令。如果用户没有选择，并且shell中没有实现`main()`方法，我们使用`_help()`方法来显示帮助信息。
- en: If users have indeed specified a command that is within the list of available
    commands, we make sure that the specified arguments match the minimum number of
    mandatory arguments, if any, aborting the execution with a proper error message
    if the check fails. If the number of arguments is correct, we store the value
    of each given argument in the `arguments` property of the task.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确实指定了一个在可用命令列表中的命令，我们确保指定的参数与最小数量的必需参数匹配（如果有），如果检查失败，则通过适当的错误消息终止执行。如果参数数量正确，我们将每个给定参数的值存储在任务的`arguments`属性中。
- en: Once the arguments are processed, we proceed to deal with the parameters. Going
    through the specified parameters, we check their provided value against the data
    type, if any, aborting the shell with a proper error message if the value given
    is of an incorrect type. If no value is given, the default value is used, if any.
    The resulting array of parameters and values is stored in the `parameters` property
    of the task.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完参数，我们就继续处理参数。遍历指定的参数，我们将提供的值与数据类型进行比较（如果有），如果值类型不正确，则通过适当的错误消息终止shell。如果没有提供值，则使用默认值（如果有）。参数和值的数组结果存储在任务的`parameters`属性中。
- en: The `execute()` method is the one called whenever the `Help` task is invoked,
    which is whenever the `help` command is used when calling the shell. Therefore,
    this method will simply display the help message by calling the `_help()` method,
    optionally passing to it the first argument, which would provide the user with
    the help message for the given command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()`方法是在调用`Help`任务时被调用的方法，也就是在调用shell时使用`help`命令时。因此，这个方法将简单地通过调用`_help()`方法来显示帮助信息，可以可选地传递第一个参数，这样可以为用户提供给定命令的帮助信息。'
- en: The `_help()` method builds the help message, for the entire shell or a specific
    command. It uses the command information stored in the `commands` property, and
    calls the `_usageCommand()` helper method to get the usage message for a given
    command, and the `_helpCommand()` method to get the help message for all available
    parameters and arguments in the command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`_help()`方法构建整个shell或特定命令的帮助信息。它使用存储在`commands`属性中的命令信息，并调用`_usageCommand()`辅助方法来获取给定命令的使用信息，以及调用`_helpCommand()`方法来获取所有可用参数和命令中所有参数的帮助信息。'
- en: Sending e-mails from shells
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从shell发送电子邮件
- en: E-mail sending is not a task that requires any interaction by visitors to our
    web applications, so it is pointless to make them wait for their delivery, which
    is exactly what we would do if we were to send an e-mail from a controller's action.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件发送不是需要我们的Web应用程序访客进行任何交互的任务，因此让他们等待邮件的送达是没有意义的，这正是如果我们从控制器动作发送电子邮件时会发生的情况。
- en: Deferring e-mail sending to a shell makes real sense both from a performance
    perspective and from the administrator point of view, as we may also add the ability
    to re-send failed e-mails.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将电子邮件发送推迟到shell中，从性能和管理员的角度来看都非常有意义，因为我们还可以添加重新发送失败电子邮件的能力。
- en: This recipe uses the `Email` component provided by CakePHP to send a fictitious
    newsletter, adding the ability to test the sending process through a shell parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用CakePHP提供的`Email`组件来发送虚构的通讯稿，并添加了通过shell参数测试发送过程的能力。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To go through this recipe we need some data to work with. Create a `subscribers`
    table with the following SQL statement:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要一些数据来工作。使用以下SQL语句创建一个`subscribers`表：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `newsletters` table with the following statement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句创建一个`newsletters`表：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `newsletters_subscribers` table with the following statement:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句创建一个`newsletters_subscribers`表：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now add some sample data to these tables with the following statements:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用以下语句向这些表添加一些示例数据：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a file named `newsletter.php` and place it in your `app/models` folder,
    with the following contents:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`newsletter.php`的文件，并将其放置在您的`app/models`文件夹中，内容如下：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `email.php` and place it in your `app/vendors/shells`,
    with the following contents:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`email.php`的文件，并将其放置在您的`app/vendors/shells`中，内容如下：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make sure to change the following lines in the `startup()` function to match
    your settings:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更改`startup()`函数中的以下行以匹配您的设置：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you wish to use PHP''s `mail()` function instead of SMTP, change the `delivery`
    property of the `Email` component to `mail`. Once configured, you can run the
    shell with the following command to force all e-mails to go to your specific address
    (in this case, `my@email.com`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用PHP的`mail()`函数而不是SMTP，将`Email`组件的`delivery`属性更改为`mail`。一旦配置完成，您可以使用以下命令运行shell，以强制所有电子邮件发送到您的特定地址（在这种情况下，`my@email.com`）：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As all e-mails are forced to be sent to `my@email.com` through the use of the
    shell parameter, we need a way to tell if each e-mail will be going to the real
    e-mail address. Use your e-mail program to view the headers of the e-mail, and
    you will notice the following header lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有电子邮件都通过使用shell参数强制发送到`my@email.com`，我们需要一种方法来告诉每个电子邮件是否会发送到真实的电子邮件地址。使用您的电子邮件程序查看电子邮件的标题，您将注意到以下标题行：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: From these headers we can tell that the **X-Destination** header is set to the
    address to which the e-mail was originally intended for.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些标题中我们可以看出，**X-Destination**标题被设置为电子邮件最初打算发送的地址。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `EmailShell` starts by implementing the `startup()` method, which is called
    before any shell command or its entry method is executed. In this method, we create
    an instance of the `Email` component. Once we have the instance, we configure
    its delivery settings through the properties `delivery` and `smtpOptions`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailShell`首先通过实现`startup()`方法开始，该方法在执行任何shell命令或其入口方法之前被调用。在这个方法中，我们创建了一个`Email`组件的实例。一旦我们有了实例，我们就通过`delivery`和`smtpOptions`属性来配置其交付设置。'
- en: The entry method `main()` checks to see if the `to` parameter is given. If so,
    this will be the e-mail to which all e-mails will be sent to, a basic way to test
    the sending process. It continues to fetch the first newsletter that has not yet
    been sent, and the list of subscribers that should receive the newsletter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 入口方法`main()`检查是否提供了`to`参数。如果是，这将是要发送所有电子邮件的电子邮件地址，这是一种基本的测试发送过程的方法。然后它继续获取尚未发送的第一份通讯稿和应该接收通讯稿的订阅者列表。
- en: 'For each of those subscribers, we set the appropriate properties of the `Email`
    component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个订阅者，我们设置 `Email` 组件的适当属性：
- en: '| Property | Purpose |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 目的 |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sendAs` | Type of e-mail to send. Can be text, `html`, or `both`. We set
    it to `html` to specify that we are sending an HTML-only e-mail. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `sendAs` | 要发送的电子邮件类型。可以是文本、`html` 或 `both`。我们将其设置为 `html` 以指定我们正在发送纯HTML电子邮件。
    |'
- en: '| `subject` | The subject of the e-mail. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `subject` | 电子邮件的主题。 |'
- en: '| `from` | The address sending the e-mail. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `from` | 发送电子邮件的地址。 |'
- en: '| `to` | The destination address. If the parameter is provided, this is the
    e-mail to send `to`, otherwise we use the e-mail of the subscriber. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `to` | 目标地址。如果提供了参数，这是要发送的电子邮件 `to`，否则我们使用订阅者的电子邮件。 |'
- en: Finally, we proceed to send the actual e-mail through the component's `send()`
    method, informing the user of the result of the operation, and resetting the e-mail
    contents with the component's `reset()` method prior to the next loop in the `for`
    operation. We end the shell by marking that the newsletter is sent.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过组件的 `send()` 方法发送实际电子邮件，通知用户操作的结果，并在 `for` 操作的下一个循环之前使用组件的 `reset()`
    方法重置电子邮件内容。我们通过标记新闻通讯已发送来结束shell。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Sending an e-mail* in [Chapter 11](ch11.html "Chapter 11. Utility Classes
    and Tools"), *Utility Classes and Tools*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第11章](ch11.html "第11章。实用类和工具") *实用类和工具* 中发送电子邮件
- en: Non-interactive tasks with the robot plugin
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器人插件的非交互式任务
- en: As our application grows in size and complexity, we will find ourselves in the
    need to create and automate certain tasks, deferring the processing of non-interactive
    tasks for later execution. While we can create shells to perform these operations,
    some of our needs may be met by the Robot plugin.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序在规模和复杂性上的增长，我们将发现自己需要创建和自动化某些任务，将非交互式任务的执行推迟到稍后。虽然我们可以创建shell来执行这些操作，但我们的某些需求可能可以通过机器人插件得到满足。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this recipe shows a pure CakePHP approach, there are more involved and
    scalable alternatives. One of the most used tools is **Gearman**, available at
    [http://gearman.org/](http://gearman.org/).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个配方展示了纯CakePHP方法，但还有更多复杂和可扩展的替代方案。最常用的工具之一是 **Gearman**，可在 [http://gearman.org/](http://gearman.org/)
    获取。
- en: The Robot plugin allows us to schedule tasks for later execution, and have those
    tasks run by a shell. The tasks themselves are actually CakePHP controller actions,
    which are run by the shell at the specified time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人插件允许我们安排任务以供稍后执行，并由shell运行这些任务。这些任务本身实际上是CakePHP控制器操作，由shell在指定的时间运行。
- en: This recipe shows us how to use the Robot plugin to send an e-mail after a user
    has signed up for our newsletters, and how to have the shell in the Robot plugin
    periodically check for pending tasks and run them as they become available.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用机器人插件在用户注册我们的新闻通讯后发送电子邮件，以及如何让机器人插件中的shell定期检查待处理任务并在它们可用时运行它们。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need some data to work with. Follow the *Getting
    ready* section of the previous recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要一些数据来工作。遵循前一个配方中的 *准备工作* 部分。
- en: We need to download the Robot plugin. Go to [http://github.com/mariano/robot/downloads](http://github.com/mariano/robot/downloads)
    and download the latest release. Uncompress the downloaded file into your `app/plugins`
    folder. You should now have a directory named `robot` inside `app/plugins`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载机器人插件。访问 [http://github.com/mariano/robot/downloads](http://github.com/mariano/robot/downloads)
    并下载最新版本。将下载的文件解压缩到您的 `app/plugins` 文件夹中。现在您应该在 `app/plugins` 内有一个名为 `robot` 的目录。
- en: Run the SQL statements found in the `app/plugins/robot/config/sql/robot.sql`
    file to create the tables required by the Robot plugin.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `app/plugins/robot/config/sql/robot.sql` 文件中找到的SQL语句以创建机器人插件所需的表。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `subscribers_controller.php` and place it in your `app/controllers`
    folder, with the following contents:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subscribers_controller.php` 的文件并将其放置在您的 `app/controllers` 文件夹中，内容如下：
- en: '[PRE30]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a folder named `subscribers` in your `app/views` folder. Create a file
    named `add.ctp` and place it in the folder `app/views/subscribers`, with the following
    contents:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `app/views` 文件夹中创建一个名为 `subscribers` 的文件夹。创建一个名为 `add.ctp` 的文件并将其放置在 `app/views/subscribers`
    文件夹中，内容如下：
- en: '[PRE31]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a file named `welcome.ctp` and place it in the `app/views/subscribers`
    folder, with the following contents:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `welcome.ctp` 的文件并将其放置在 `app/views/subscribers` 文件夹中，内容如下：
- en: '[PRE32]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following property to the beginning of the `SubscribersController`
    class (change the delivery settings of the `Email` component to match your needs):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`SubscribersController`类的开头（将`Email`组件的投递设置更改为满足你的需求）：
- en: '[PRE33]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Edit the `add()` method of the `SubscribersController` class and make the following
    changes:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`SubscribersController`类的`add()`方法并做出以下更改：
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'While still editing the `SubscribersController` class, replace the `welcome()`
    method with the following contents:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑`SubscribersController`类时，将`welcome()`方法替换为以下内容：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can now browse to `http://localhost/subscribers/add` and enter your name
    and e-mail address. Now run the robot shell with the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以浏览到`http://localhost/subscribers/add`并输入你的姓名和电子邮件地址。现在使用以下命令运行机器人外壳：
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是GNU Linux / Mac / Unix系统：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Microsoft Windows：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should get an output similar to what is shown in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个类似于以下截图的输出：
- en: '![How to do it...](img/1926_8_05.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_8_05.jpg)'
- en: The robot is informing us that a task executed the CakePHP URL `/subscribers/welcome`
    successfully, after which we should receive a welcome e-mail.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人正在通知我们，任务已成功执行了CakePHP URL `/subscribers/welcome`，之后我们应该收到欢迎电子邮件。
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started with a basic controller that takes new subscriptions and saves them,
    redirecting to a welcome screen after the record is created. Then we added the
    `Email` component to our controller, as it will be used for sending e-mails.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个基本的控制器开始，该控制器处理新的订阅并将它们保存，在记录创建后重定向到欢迎屏幕。然后我们在控制器中添加了`Email`组件，因为它将被用于发送电子邮件。
- en: 'We continued by modifying the `add()` method to create the scheduled task.
    We scheduled a task using the `schedule()` method of the `RobotTask` model located
    in the Robot plugin. This method takes up to three arguments:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续修改`add()`方法以创建计划任务。我们使用位于Robot插件中的`RobotTask`模型的`schedule()`方法来安排任务。此方法最多接受三个参数：
- en: '| Argument | Purpose |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 目的 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `action` | The URL to a CakePHP action, which can be given as a string or
    as an array. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `action` | CakePHP操作的URL，可以是字符串或数组。 |'
- en: '| `parameters` | Optional parameters to send to the controller action specified
    in `action`. Defaults to no parameters. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `parameters` | 发送到`action`中指定的控制器操作的可选参数。默认为无参数。 |'
- en: '| `scheduled` | The time at which the action should be executed. This can be
    either a specific time stamp (in seconds since the Unix Epoch, which is January
    1, 1970 00:00:00 GMT), or any string that can be used by the PHP function `strtotime()`.
    Defaults to `null`, which means the task should be executed as soon as possible.
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `scheduled` | 操作应执行的时间。这可以是特定的时间戳（自Unix纪元（1970年1月1日00:00:00 GMT）以来的秒数），或任何可以由PHP函数`strtotime()`使用的字符串。默认为`null`，表示任务应尽快执行。
    |'
- en: 'In our `add()` method, we set the `action` argument to the `welcome` action
    of the current controller, and send two parameters: `name`, and `email`. These
    parameters are available to the called action through the `$this->params[''robot'']`
    array.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`add()`方法中，我们将`action`参数设置为当前控制器的`welcome`操作，并发送两个参数：`name`和`email`。这些参数可以通过`$this->params['robot']`数组在调用操作中使用。
- en: In fact, whenever a controller action is called through the robot shell, `$this->params['robot']`
    will be available. If no parameters were specified when scheduling the task, this
    array will be empty, hence the check with `isset()` instead of `!empty()` in the
    `welcome()` method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每当通过机器人外壳调用控制器操作时，`$this->params['robot']`都将可用。如果在安排任务时未指定参数，则此数组将为空，因此在`welcome()`方法中使用`isset()`而不是`!empty()`进行检查。
- en: When called through the robot shell, the `welcome()` method uses the given parameters
    to build and send the e-mail. It returns a Boolean value to indicate the success
    of the executed task. If no value is returned, the task is assumed to have succeeded.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过机器人外壳调用时，`welcome()`方法使用给定的参数构建并发送电子邮件。它返回一个布尔值以指示执行任务的成败。如果没有返回值，则假定任务已成功执行。
- en: To test the Robot plugin, we ended the recipe by signing up as a subscriber,
    and then running the robot. Naturally, the application should not have to wait
    for us to manually run the robot shell in order for e-mails to go out. We need
    to add the shell to our list of automated tasks, commonly known as CRON tasks
    on most operative systems.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试机器人插件，我们在注册为订阅者后结束了配方，然后运行了机器人。自然地，应用程序不应该需要我们手动运行机器人shell，以便发送电子邮件。我们需要将shell添加到我们的自动化任务列表中，这在大多数操作系统中通常被称为CRON任务。
- en: 'Assuming your application lives at `/var/www/myapp`, and that the path to your
    PHP binary is `/usr/bin/php`, the following would be the command that should be
    included as an automated task in your operative system:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序位于`/var/www/myapp`，并且你的PHP二进制文件的路径是`/usr/bin/php`，以下将是应包含在操作系统中的自动化任务中的命令：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the `silent` option. This tells the robot plugin to output no messages
    unless an error is found. This is particularly important when adding this command
    to our list of automated tasks, as it may be configured to e-mail the output of
    any executed command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`silent`选项。这告诉机器人插件除非发现错误，否则不输出任何消息。当我们将此命令添加到我们的自动化任务列表中时，这一点尤为重要，因为它可能被配置为发送任何执行命令的输出电子邮件。
- en: When adding this command to our list of automated tasks, we have to decide how
    often we want the robot to check for tasks. If we are interested in immediate
    results, we should set the robot to run every minute. However, what happens if
    at second 0 of a given minute the robot finds no tasks? We will have 59 seconds
    of idle time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此命令添加到我们的自动化任务列表中时，我们必须决定我们希望机器人多久检查一次任务。如果我们对即时结果感兴趣，我们应该将机器人设置为每分钟运行一次。然而，如果在给定分钟的秒数为0时机器人找不到任务，会发生什么？我们将有59秒的空闲时间。
- en: 'Fortunately, the plugin offers an interesting solution to this problem. Using
    the parameter `daemon`, we tell the Robot plugin to wait for tasks even if there
    are none available. If we try to manually run it with this option using the following
    command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，插件提供了一个有趣的解决方案来解决这个问题。使用`daemon`参数，我们告诉机器人插件即使在没有可用任务的情况下也要等待任务。如果我们尝试使用以下命令手动运行它并使用此选项：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: we will notice the shell complains, saying that there is no limit specified.
    This is because the robot should not be set to wait for tasks indefinitely, as
    any PHP fatal error that may be provoked by a called action could render the robot
    useless.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到shell会抱怨说没有指定限制。这是因为机器人不应该被设置为无限期地等待任务，因为由调用动作可能引发的任何PHP致命错误都可能使机器人失效。
- en: 'Instead, we can use the `time` parameter to limit the number of seconds to
    which the robot should wait for tasks. If we wanted to run the robot every minute,
    this limit should be set to 59 seconds:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用`time`参数来限制机器人等待任务的最大秒数。如果我们想每分钟运行机器人一次，这个限制应该设置为59秒：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means that we would have a robot waiting up to 59 seconds for tasks, after
    which the next robot run will be triggered.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着机器人将等待多达59秒的任务，之后将触发下一次机器人运行。
