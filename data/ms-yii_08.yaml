- en: Chapter 8. Routing, Responses, and Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。路由、响应和事件
- en: Like many modern web frameworks, Yii2 is built with a powerful router component,
    which we can utilize to handle a variety of URIs coming from both our end users
    and application. This functionality is further enhanced by Yii2's powerful request
    and response handlers, which we can use to manipulate request and response bodies.
    In this chapter, we'll cover the basics of how to manipulate Yii2's URL Manager
    to adjust routes, explore how to configure Yii2 to respond in different ways,
    and learn how to send and listen to events within our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多现代Web框架一样，Yii2使用了一个强大的路由组件，我们可以利用它来处理来自我们端用户和应用程序的各种URI。这种功能通过Yii2强大的请求和响应处理器进一步增强，我们可以使用它们来操作请求和响应体。在本章中，我们将介绍如何操作Yii2的URL
    Manager以调整路由，探讨如何配置Yii2以以不同的方式响应，以及学习如何在我们的应用程序中发送和监听事件。
- en: Routing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: As mentioned in previous chapters, routing within Yii2 is managed by the UrlManager
    component defined in our application configuration. The router in Yii2 is responsible
    for determining where Yii2 routes external URI requests to internal controllers
    and actions. In [Chapter 5](part0035_split_000.html#11C3M2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 5. Modules, Widgets, and Helpers"), *Modules, Widgets, and Helpers*,
    we covered the basics of how to create and manipulate URL routes with the `yii\helpers\Url`
    helper. In this section, we'll cover how Yii2 routes these requests inside our
    application by exploring Yii2's UrlManager in more detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Yii2中的路由由我们应用程序配置中定义的UrlManager组件管理。Yii2中的路由器负责确定将Yii2的外部URI请求路由到内部控制器和动作的位置。在第5章[模块、小部件和助手](part0035_split_000.html#11C3M2-ad3e09b384df46aea690d9c8897d5fe7
    "第5章。模块、小部件和助手")中，我们介绍了如何使用`yii\helpers\Url`助手创建和操作URL路由的基本方法。在本节中，我们将通过更详细地探讨Yii2的UrlManager来了解Yii2如何在应用程序内部路由这些请求。
- en: Routing in Yii2 can be broken down into two basic steps. The first of these
    steps is to parse the incoming request and query parameters (which are stored
    in the `GET` parameters of our request with the `r` parameter by default but can
    be retrieved from the request URI if we have pretty URLs enabled). The second
    step is to create an instance of the corresponding controller action, which will
    ultimately handle the request.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2中的路由可以分为两个基本步骤。第一个步骤是解析传入的请求和查询参数（默认情况下存储在请求的`GET`参数中，带有`r`参数，但如果我们启用了美观的URL，也可以从请求URI中检索）。第二个步骤是创建相应控制器动作的实例，它最终将处理请求。
- en: 'By default, Yii2 will break the route down in the forward slashes of the URL
    to map it to the appropriate module, controller, and action pair. For instance,
    the site/login route will match the `site` controller and the action named `login`
    in the default module of the application instance. Internally, Yii2 will take
    the following steps to route the request:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2会将路由分解为URL中的正斜杠，将其映射到适当的模块、控制器和动作对。例如，site/login路由将匹配默认应用程序实例中的`site`控制器和名为`login`的动作。内部，Yii2将采取以下步骤来路由请求：
- en: By default, Yii2 will set the current module as the application.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2会将当前模块设置为应用程序。
- en: 'Examine the controller map of the application to see whether it contains the
    current route. If so, a controller instance will be created according to the controller
    map defined within the module, at which point, the action will be created according
    to the action map defined in step *4*. By default, Yii2 will create a controller
    map based upon the controllers found within the `@app/controllers` folder, but
    this may be customized within the module (or UrlManager):'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查应用程序的控制器映射，看它是否包含当前路由。如果是，将根据模块内定义的控制器映射创建一个控制器实例。此时，将根据步骤*4*中定义的动作映射创建动作。默认情况下，Yii2将根据`@app/controllers`文件夹中找到的控制器创建控制器映射，但可以在模块（或UrlManager）中进行自定义：
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the controller map of the application module is found not within the application
    module, Yii2 will iterate through the module list in the `module` property of
    the application module to see if a route matches there. If a module is found,
    Yii2 will instantiate the module using the provided configuration and then create
    the controller using the details outlined in the previous step.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序模块的控制器映射不在应用程序模块中找到，Yii2将遍历应用程序模块的`module`属性中的模块列表，以查看是否有匹配的路由。如果找到模块，Yii2将使用提供的配置实例化该模块，然后根据前一步中概述的详细信息创建控制器。
- en: Yii2 will then look for the action within the action map defined in the module's
    configuration. If found, it will create an action according to that configuration;
    otherwise, it will attempt to create an inline action defined in the `action`
    method corresponding to the given action.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Yii2将在模块配置中定义的动作映射中查找动作。如果找到，它将根据该配置创建一个动作；如果没有找到，它将尝试创建与给定动作对应的`action`方法中定义的内联动作。
- en: If an error occurs at any point during this process, Yii2 will throw `yii\web\NotFoundHttpException`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此过程中任何一点发生错误，Yii2将抛出`yii\web\NotFoundHttpException`。
- en: Default and catch all routes
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认和捕获所有路由
- en: 'When Yii2 receives a request that is parsed into an empty route, the default
    route will be used instead. The default route is set to `site/index`, which references
    the `index` action of the `site` controller. This behavior can be changed by setting
    the `defaultRoute` property of the `application` component, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当Yii2收到一个解析为空路由的请求时，将使用默认路由。默认路由设置为`site/index`，它引用`site`控制器的`index`动作。可以通过设置`application`组件的`defaultRoute`属性来更改此行为，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionally, Yii2 can be configured to forward all requests to a single route
    by setting the `catchAll` property of `yii\web\application`. This can be beneficial
    when you need to perform application maintenance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以通过设置`yii\web\application`的`catchAll`属性来配置Yii2将所有请求转发到单个路由。当需要执行应用程序维护时，这可能是有益的。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Custom routes and URL rules
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义路由和URL规则
- en: Rather than relying upon the default controller/action routes Yii2 internally
    generates, custom URL rules can be written to define our own URL routes. URL routes
    in Yii2 are implemented by an instance of `yii\web\UrlRule`, and they consist
    of a pattern used to patch the path information and query parameters of a given
    route. When using custom URL rules, Yii2 will route a request to the first matching
    rule for the accompanying request. Moreover, the matching rule determines how
    the request parameters are split up. Additionally, using the `yii\helpers\Url`
    helper will also rely upon the list rules to internally route requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是依赖于Yii2内部生成的默认控制器/动作路由，我们可以编写自定义URL规则来定义我们自己的URL路由。Yii2中的URL路由是通过`yii\web\UrlRule`的一个实例实现的，它由用于修补给定路由的路径信息和查询参数的模式组成。当使用自定义URL规则时，Yii2将根据伴随请求将请求路由到第一个匹配的规则。此外，匹配规则确定如何分割请求参数。此外，使用`yii\helpers\Url`辅助器也将依赖于规则列表来内部路由请求。
- en: 'URL rules in Yii2 can be defined in our application configuration by setting
    the `yii\web\UrlManager:$rules` property as an array, with a key containing the
    URL pattern to be matched and the value being the corresponding route. For example,
    supposing we had a controller to manage published content, we could write custom
    rules, as follows, to route `posts` and `post` to our content:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置`yii\web\UrlManager:$rules`属性为一个包含要匹配的URL模式作为键和相应的路由作为值的数组来在应用程序配置中定义Yii2的URL规则。例如，假设我们有一个用于管理已发布内容的控制器，我们可以编写如下自定义规则，将`posts`和`post`路由到我们的内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now when navigating to the `/posts` endpoint of our application, the content/index
    controller action pair will be triggered. As shown in the previous example, URL
    rules can extend beyond simple strings and can contain complex regular expressions,
    which we can use to conditionally route rules. In the previous example, a route
    to the `/post` endpoint followed by an integer ID will route to the content/view
    controller action pair. Moreover, Yii2 will automatically pass the `$id` parameter
    to the action:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们导航到应用程序的`/posts`端点时，内容/index控制器动作对将被触发。正如前一个示例所示，URL规则可以超出简单的字符串，并且可以包含复杂的正则表达式，我们可以使用这些正则表达式来条件性地路由规则。在前一个示例中，到`/post`端点的路由后跟一个整数ID将路由到内容/view控制器动作对。此外，Yii2将自动将`$id`参数传递给动作：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Regular expressions can only be specified for parameters. However, as we'll
    see later in this section, we can parameterize our routes to make the controller
    and action more dynamic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式只能指定给参数。然而，正如我们将在本节后面看到的，我们可以参数化我们的路由，使控制器和动作更加动态。
- en: These regular expressions can be further customized to include more complex
    routes. For instance, adding the following to our URL routes would enable us to
    pass additional information to our content/index action, such as the year, month,
    and the day we want to show published entries for.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些正则表达式可以进一步定制以包含更复杂的路由。例如，将以下内容添加到我们的URL路由中，将使我们能够向内容/index动作传递额外的信息，例如我们想要显示的已发布条目的年份、月份和日期。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you may expect from the expression, this route will only match four-digit
    years and two-digit months and days. Moreover, as mentioned previously, by adding
    this information to our URL rules, the `yii\helper\Url` helper will understand
    any URL created with this pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从表达式中预期的那样，此路由将仅匹配四位数的年份和两位数的月份和日期。此外，如前所述，通过将此信息添加到我们的URL规则中，`yii\helper\Url`助手将理解使用此模式创建的任何URL：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'URL routes can also be defined to route domain names and schemes. For instance,
    the following routes can be written to ensure that different domain names route
    to different parts of the site:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: URL路由也可以定义为路由域名和方案。例如，可以编写以下路由以确保不同的域名路由到网站的不同部分：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is beneficial when handling multiple frontend applications within the same
    codebase.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一代码库中处理多个前端应用时，这很有益处。
- en: Parameterizing routes
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化路由
- en: 'In addition to named parameters, as described in the previous section, parameters
    can also be embedded within the URL rule itself. This approach enables Yii2 to
    match a single rule to multiple routes, which can greatly reduce the number of
    URL rules and, consequently, the performance of your router. Take, for instance,
    the following route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中描述的命名参数之外，参数还可以嵌入到URL规则本身中。这种方法使Yii2能够将单个规则匹配到多个路由，这可以大大减少URL规则的数量，从而提高路由器的性能。例如，以下路由：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This route will match both the content and comment controller with a given
    ID for the create, list, and delete actions and pass it to the appropriate action.
    In order for a route to match, however, all named parameters must be defined.
    If a given route does not contain the given parameters, Yii2 will fail to match
    the route, which will most likely result in the route hitting a 404 error. One
    way to get around this limitation is to provide default parameters for the routes,
    as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由将匹配具有给定ID的内容和评论控制器，并传递给相应的操作。然而，为了使路由匹配，必须定义所有命名参数。如果给定的路由不包含给定的参数，Yii2将无法匹配该路由，这很可能会导致路由遇到404错误。绕过这种限制的一种方法是为路由提供默认参数，如下例所示：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, `page` will default to `1`, and `name` will default to `NULL`.
    This URL rule can match multiple routes. In this specific instance, several routes
    will be matched:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`page`将默认为`1`，而`name`将默认为`NULL`。此URL规则可以匹配多个路由。在这个特定的情况下，将匹配多个路由：
- en: '`/content, page=1, name=NULL`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/content, page=1, name=NULL`'
- en: '`/content/215, page=215, name=NULL`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/content/215, page=215, name=NULL`'
- en: '`/content/215/foo, page=215, name=foo`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/content/215/foo, page=215, name=foo`'
- en: '`/content/foo, page=1, name=foo`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/content/foo, page=1, name=foo`'
- en: URL suffixes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL后缀
- en: As an alternative to declaring a key-value pair for a URL route, routes can
    be defined as an array of key-value pairs containing the pattern, route, and even
    a custom URL suffix to specifically respond to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为为URL路由声明键值对的替代方法，路由可以定义为包含模式、路由甚至特定URL后缀的键值对数组的数组，以专门响应。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These routes can be used to configure your application to respond to certain
    types of requests in different formats.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由可以用来配置您的应用程序以以不同格式响应某些类型的请求。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, rules created this way will be created as an instance of `yii\web\UrlRule`,
    but they can be changed by defining the `class` parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，以这种方式创建的规则将作为`yii\web\UrlRule`的一个实例创建，但可以通过定义`class`参数来更改。
- en: HTTP method-specific URL rules
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专门HTTP方法URL规则
- en: 'At times, you may find it beneficial to route different types of HTTP methods
    to the same route but handle them in different actions. In Yii2, this can be achieved
    by prefixing the method types before the route key, as shown in the following
    example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会发现将不同类型的HTTP方法路由到同一路由但以不同的方式处理它们是有益的。在Yii2中，可以通过在路由键之前添加方法类型来实现，如下例所示：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From an API perspective, all requests will ultimately route to `users/<id>`,
    but depending upon the HTTP method, a different action will be executed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从API的角度来看，所有请求最终都将路由到`users/<id>`，但根据HTTP方法的不同，将执行不同的操作。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: URL rules with specified HTTP methods will only be used for routing purposes,
    and they won't be used to create URLs such as when using `yii\helper\Url`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 具有指定HTTP方法的URL规则将仅用于路由目的，并且它们不会用于创建URL，例如在使用`yii\helper\Url`时。
- en: Custom URL rule classes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义URL规则类
- en: 'While `yii\web\Url` is extremely flexible, and it should cover the majority
    of use cases you need for a URL rule, often there are times when a custom URL
    may be required. For instance, a publisher may want to support a format to represent
    authors and books, such as `/Author/Book`, where both `Author` and `Book` are
    data retrieved from the database. Custom URL rules in Yii2 can be created to solve
    this problem by extending `yii\base\Object` and implementing `yii\web\UrlRuleInterface`,
    as shown in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`yii\web\Url`非常灵活，并且应该覆盖您需要的所有URL规则用例，但往往会有需要自定义URL的情况。例如，出版商可能希望支持一种表示作者和书籍的格式，如`/Author/Book`，其中`Author`和`Book`都是从数据库中检索的数据。在Yii2中，可以通过扩展`yii\base\Object`并实现`yii\web\UrlRuleInterface`来创建自定义URL规则以解决这个问题，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our custom rule can then be implemented within our `yii\web\UrlManager::$rules`
    section by declaring our desire to use that class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`yii\web\UrlManager::$rules`部分实现我们的自定义规则，通过声明我们希望使用该类：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Dynamic rule generation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态规则生成
- en: 'Rules can be programmatically and dynamically added to your application in
    several different ways. Dynamic rule generation can take the form of a custom
    URL rule class, as outlined in the previous section, or a custom URL manager.
    The simplest way to add new URL rules dynamically, however, is to use the `addRules()`
    method of the URL Manager. For rules to take effect, they need to occur early
    in the bootstrapping process of the application. For modules to dynamically add
    new rules, they should implement `yii\base\BootstrapInterface` and add the custom
    URL rules in the `bootstrap()` method, as shown in the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可以通过多种不同的方式以编程和动态的方式添加到您的应用程序中。动态规则生成可以采用自定义URL规则类，如前文所述，或者自定义URL管理器。然而，向URL管理器添加新URL规则的最简单方法还是使用`addRules()`方法。为了使规则生效，它们需要在应用程序引导过程中较早出现。为了使模块能够动态添加新规则，它们应该实现`yii\base\BootstrapInterface`并在`bootstrap()`方法中添加自定义URL规则，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In complex web applications, it's important to monitor how many URL rules you
    have. Adding many different rules can seriously degrade the performance of your
    application as Yii2 needs to iterate over each rule until it finds the first matching
    rule. Parameterized routes and reducing the number of URL rules can significantly
    improve the performance of your application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的Web应用程序中，监控您拥有的URL规则数量非常重要。添加许多不同的规则可能会严重降低应用程序的性能，因为Yii2需要遍历每个规则直到找到第一个匹配的规则。参数化路由和减少URL规则的数量可以显著提高应用程序的性能。
- en: Requests
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求
- en: After handling where we want our request to go, we will often need to write
    specific logic to handle the details of our HTTP request. To help facilitate this,
    Yii2 represents the HTTP request within the `yii\web\Request` object, which can
    provide a variety of information about the HTTP request, such as the request body,
    `GET` and `POST` parameters, and headers. Each request in Yii2 can be accessed
    easily through the request application component, which is represented by `Yii::$app->request`
    in our code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完我们希望请求去往的地方之后，我们通常需要编写特定的逻辑来处理HTTP请求的细节。为了帮助简化这个过程，Yii2通过`yii\web\Request`对象表示HTTP请求，该对象可以提供有关HTTP请求的各种信息，例如请求体、`GET`和`POST`参数以及头部信息。在Yii2中，每个请求都可以通过请求应用程序组件轻松访问，在我们的代码中由`Yii::$app->request`表示。
- en: Retrieving request parameters and data
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索请求参数和数据
- en: 'The most common task we''ll perform when working with the request object is
    retrieving `GET` and `POST` parameters, which are implemented by `yii\web\Request::get()`
    and `yii\web\Request::post()` respectively. These methods enable us to consistently
    and safely access the `$_GET` and `$_POST` parameters of our application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与请求对象一起工作时，最常见的工作任务是从`GET`和`POST`参数中检索数据，这些参数分别通过`yii\web\Request::get()`和`yii\web\Request::post()`方法实现。这些方法使我们能够一致且安全地访问应用程序的`$_GET`和`$_POST`参数：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike the native `$_GET` and `$_POST` PHP global variables, however, Yii2''s
    request object allows us to safely access named parameters, as shown in the next
    example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与原生的`$_GET`和`$_POST`PHP全局变量不同，Yii2的请求对象允许我们安全地访问命名参数，如下一个示例所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the parameters are not defined, Yii2 will return `NULL` by default. This
    behavior can be modified by setting the second parameter of both `yii\web\Request::get()`
    and `yii\web\Request::post()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数未定义，Yii2默认将返回`NULL`。这种行为可以通过设置`yii\web\Request::get()`和`yii\web\Request::post()`的第二个参数来修改：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In addition to providing safe access to the `$_GET` and `$_POST` data, the request
    object can also be easily mocked when running tests. We'll cover how to work with
    tests and mocking data in [Chapter 10](part0060_split_000.html#1P71O1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 10. Testing with Codeception"), *Testing with Codeception*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供对 `$_GET` 和 `$_POST` 数据的安全访问之外，请求对象在运行测试时也可以轻松地进行模拟。我们将在第 10 章 [Testing
    with Codeception](part0060_split_000.html#1P71O1-ad3e09b384df46aea690d9c8897d5fe7
    "第 10 章。使用 Codeception 进行测试") 中介绍如何与测试和模拟数据一起工作。*使用 Codeception 进行测试*。
- en: 'As an added convenience, Yii2 provides us with the ability to determine the
    type of request we''re working with, such as a `GET`, `POST`, or `PUT` request.
    The easiest way to determine the request type is to query `\Yii::$app->request->method`,
    which will return the HTTP method type (such as `GET`, `PUT`, `POST`, `DELETE`,
    and so on). Alternatively, we can conditionally check the request by querying
    one of the request objects of many Boolean options, as shown in the following
    table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的便利，Yii2 提供了确定我们正在处理的请求类型的能力，例如 `GET`、`POST` 或 `PUT` 请求。确定请求类型的最简单方法是查询
    `\Yii::$app->request->method`，它将返回 HTTP 方法类型（例如 `GET`、`PUT`、`POST`、`DELETE` 等）。或者，我们可以通过查询许多布尔选项之一的条件检查请求，如下表所示：
- en: '| Property | Explanation |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 说明 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `yii\web\Request::$isAjax` | If the request is an AJAX (`XMLHTTPRequest`)
    request |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isAjax` | 如果请求是 AJAX (`XMLHTTPRequest`) 请求 |'
- en: '| `yii\web\Request::$isConsoleRequest` | If the request is being made from
    the console |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isConsoleRequest` | 如果请求是从控制台发出的 |'
- en: '| `yii\web\Request::$isDelete` | If the request is an `HTTP DELETE` request
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isDelete` | 如果请求是 `HTTP DELETE` 请求 |'
- en: '| `yii\web\Request::$isFlash` | If the request originated from Adobe Flex or
    Adobe Flash. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isFlash` | 如果请求来自 Adobe Flex 或 Adobe Flash。 |'
- en: '| `yii\web\Request::$isGet` | If the request is an `HTTP GET` request |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isGet` | 如果请求是 `HTTP GET` 请求 |'
- en: '| `yii\web\Request::$isHead` | If the request is an `HTTP HEAD` request |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isHead` | 如果请求是 `HTTP HEAD` 请求 |'
- en: '| `yii\web\Request::$isOptions` | If the request is an `HTTP OPTIONS` request
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isOptions` | 如果请求是 `HTTP OPTIONS` 请求 |'
- en: '| `yii\web\Request::$isPatch` | If the request is an `HTTP PATCH` request |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isPatch` | 如果请求是 `HTTP PATCH` 请求 |'
- en: '| `yii\web\Request::$isPjax` | If the request is an `HTTP PJAX` request |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isPjax` | 如果请求是 `HTTP PJAX` 请求 |'
- en: '| `yii\web\Request::$isPost` | If the request is an `HTTP POST` request |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isPost` | 如果请求是 `HTTP POST` 请求 |'
- en: '| `yii\web\Request::$isPut` | If the request is an `HTTP PUT` request |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isPut` | 如果请求是 `HTTP PUT` 请求 |'
- en: '| `yii\web\Request::$isSecureConnection` | If the request was made over a secure
    (HTTPS) connection |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$isSecureConnection` | 如果请求是通过安全（HTTPS）连接发出的 |'
- en: 'Unlike `GET` and `POST` requests sent as forms, many of these requests submit
    data directly in the request body. To access this data, we can use `yii\web\Request::getBodyParam()`
    and `yii\web\Request::getBodyParams()`, as shown:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与作为表单发送的 `GET` 和 `POST` 请求不同，许多这些请求直接在请求体中提交数据。要访问这些数据，我们可以使用 `yii\web\Request::getBodyParam()`
    和 `yii\web\Request::getBodyParams()`，如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Request headers and cookies
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求头部和cookie
- en: 'In addition to the request body, Yii2''s request object can also retrieve header
    and cookie information sent along with the request. The headers sent along with
    our request are ultimately represented by `yii\web\HeaderCollection`, which provides
    several methods used to work with headers, namely `yii\web\HeaderCollection::get()`
    and `yii\web\HeaderCollection::has()`. In the following example, we''re checking
    whether the `X-Auth-Token` header is set and then assigning it to the `$authToken`
    variable if it is set:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了请求体之外，Yii2 的请求对象还可以检索随请求发送的头部和cookie信息。与我们请求一起发送的头部最终由 `yii\web\HeaderCollection`
    表示，它提供了用于处理头部的一些方法，即 `yii\web\HeaderCollection::get()` 和 `yii\web\HeaderCollection::has()`。在下面的示例中，我们正在检查
    `X-Auth-Token` 头部是否已设置，如果已设置，则将其分配给 `$authToken` 变量：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If a parameter is not provided to the `yii\web\HeaderCollection::get()` method,
    an array of all headers will be returned. More details on `yii\web\HeaderCollection`
    can be found at [http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html](http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为 `yii\web\HeaderCollection::get()` 方法提供参数，将返回所有头部的数组。有关 `yii\web\HeaderCollection`
    的更多详细信息，请参阅 [http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html](http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html)。
- en: 'The request object has several built-in defaults to access some commonly queried
    headers, namely:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象有多个内置默认值，用于访问一些常用查询头，即：
- en: '`yii\web\Request::$userAgent` retrieves the user agent sent by the browser'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yii\web\Request::$userAgent` 获取浏览器发送的用户代理'
- en: '`yii\web\Request::$contentType` can be used to determine the appropriate response
    type'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `yii\web\Request::$contentType` 来确定适当的响应类型
- en: '`yii\web\Request::$acceptableContentTypes` returns all the acceptable content
    types that the client will accept'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yii\web\Request::$acceptableContentTypes` 返回客户端将接受的全部可接受的内容类型'
- en: '`yii\web\Request::$acceptableLanguages` can be used if our application is configured
    to support multiple languages'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用程序配置为支持多种语言，则可以使用 `yii\web\Request::$acceptableLanguages`。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The request object can also tell us what the preferred language of the client
    is through `yii\web\Request::getPreferedLanguage()`. We'll work more with this
    variable and general translation and localization in [Chapter 11](part0068_split_000.html#20R681-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 11. Internationalization and Localization"), *Internationalization and
    Localization*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象也可以通过 `yii\web\Request::getPreferedLanguage()` 告诉我们客户端的首选语言。我们将在第 11 章 [Internationalization
    and Localization](part0068_split_000.html#20R681-ad3e09b384df46aea690d9c8897d5fe7
    "第 11 章。国际化与本地化") 中更深入地使用这个变量和通用翻译与本地化。
- en: Alongside our header information, we can also retrieve the cookie data sent
    with our request by querying `Yii::$app->request->cookies`, which will return
    an instance of `yii\web\CookieCollection`, which, as you may suspect, contains
    many of the same types of methods that `yii\web\HeaderCollection` provides, such
    as `get()` and `has()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的头部信息外，我们还可以通过查询 `Yii::$app->request->cookies` 来检索与我们的请求一起发送的 cookie 数据，这将返回一个
    `yii\web\CookieCollection` 实例，正如你可能怀疑的那样，它包含许多与 `yii\web\HeaderCollection` 提供的相同类型的函数，例如
    `get()` 和 `has()`。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Yii2 API documentation provides a complete set of methods for `yii\web\CookieCollection`
    at [http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html](http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2 API 文档在 [http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html](http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html)
    提供了 `yii\web\CookieCollection` 的完整方法集。
- en: Retrieving client and URL information
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取客户端和 URL 信息
- en: In addition to information about the request, the Yii2 request object can also
    be used to retrieve information about the client and our application state. For
    instance, client information such as their hostname or IP address can be accessed
    using `yii\web\Request::$userHost` and `yii\web\Request::$userIP`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了请求信息外，Yii2 请求对象还可以用来检索客户端和我们的应用程序状态信息。例如，可以使用 `yii\web\Request::$userHost`
    和 `yii\web\Request::$userIP` 访问客户端信息，如主机名或 IP 地址。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The user's IP address may not be accurate if your request is being forwarded
    through a proxy or load balancer. Ensure that your web server is properly configured
    to pass along the original data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的请求是通过代理或负载均衡器转发的，那么用户的 IP 地址可能不准确。请确保你的 Web 服务器已正确配置，以便传递原始数据。
- en: 'Data about the application state can be inspected by referencing a variety
    of methods, which are more convenient than querying the `$_SERVER` global variable.
    A few of the most common properties are shown in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过引用各种方法来检查应用程序状态的数据，这些方法比查询 `$_SERVER` 全局变量更方便。以下表格显示了其中一些最常用的属性：
- en: '| Property | Explanation |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 说明 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `yii\web\Request::$absoluteUrl` | This is the absolute URL, including the
    hostname and all the `GET` parameters (for example, `https://www.example.com/controller/action/?name=foo`)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$absoluteUrl` | 这是包含主机名和所有 `GET` 参数的绝对 URL（例如，`https://www.example.com/controller/action/?name=foo`）|'
- en: '| `yii\web\Request::$baseUrl` | This is the base URL used before the entry
    script. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$baseUrl` | 这是入口脚本之前使用的基 URL。|'
- en: '| `yii\web\Request::$hostInfo` | These are the host details (for example, `https://www.example.com`)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$hostInfo` | 这是主机详情（例如，`https://www.example.com`）|'
- en: '| `yii\web\Request::$pathInfo` | This is the full path after the entry script
    (for example, `/controller/action`) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$pathInfo` | 这是入口脚本之后的完整路径（例如，`/controller/action`）|'
- en: '| `yii\web\Request::$queryString` | This is the `GET` query string (for example,
    `name=foo`) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$queryString` | 这是 `GET` 查询字符串（例如，`name=foo`）|'
- en: '| `yii\web\Request::$scriptUrl` | This is the URL without the path and query
    string (for example, `/index.php`) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$scriptUrl` | 这是没有路径和查询字符串的 URL（例如，`/index.php`）|'
- en: '| `yii\web\Request::$serverName` | This is the server name (for example, `example.com`)
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$serverName` | 这是服务器名称（例如，`example.com`） |'
- en: '| `yii\web\Request::$serverPort` | This is the port the server is running on
    (usually 80 or 443 for TLS connections) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$serverPort` | 这是服务器正在运行的端口（通常为TLS连接的80或443） |'
- en: '| `yii\web\Request::$url` | This is the complete URL sans the host and scheme
    information (for example, `controller/action/?name=foo`). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\Request::$url` | 这是完整的URL，但不包含主机和方案信息（例如，`controller/action/?name=foo`）。
    |'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The request object is capable of representing nearly every aspect of the HTTP
    request and the data that may be stored in the `$_SERVER` global variable. For
    more information on the request object refer to the Yii2 API documentation at
    [http://www.yiiframework.com/doc-2.0/yii-web-request.html](http://www.yiiframework.com/doc-2.0/yii-web-request.html).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象能够表示HTTP请求的几乎所有方面以及可能存储在`$_SERVER`全局变量中的数据。有关请求对象的更多信息，请参阅Yii2 API文档[http://www.yiiframework.com/doc-2.0/yii-web-request.html](http://www.yiiframework.com/doc-2.0/yii-web-request.html)。
- en: Responses
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: After finishing the processing of the request object, Yii2 then generates a
    response object, which is sent back to the client. The response contains a myriad
    of information, such as the HTTP status code, response body, and headers. In Yii2,
    the response object is implemented by `yii\web\Response`, which is represented
    by the `response` application component. In this section, we'll explore how to
    work with responses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成请求对象的处理之后，Yii2随后生成一个响应对象，并将其发送回客户端。响应包含大量信息，例如HTTP状态码、响应体和头部。在Yii2中，响应对象由`yii\web\Response`实现，它由`response`应用程序组件表示。在本节中，我们将探讨如何与响应对象一起工作。
- en: Setting status codes
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置状态码
- en: 'In most cases, Yii2 is perfectly capable of setting the appropriate response
    code back to the end user; however, there may be situations that require us to
    explicitly define the HTTP response code for our application. To modify the HTTP
    status code within our application, we simply need to set `yii\web\Response::$statusCode`
    to a valid HTTP status code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Yii2能够完全胜任将适当的状态码设置回最终用户；然而，可能存在需要我们明确为我们的应用程序定义HTTP响应码的情况。要修改我们应用程序中的HTTP状态码，我们只需将`yii\web\Response::$statusCode`设置为有效的HTTP状态码：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Web exceptions
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络异常
- en: By default, Yii2 will return an HTTP 200 status code for any successful request.
    If we want to adjust the status code without interrupting our flow of logic, we
    can simply define a new status code for `yii\web\Response::$statusCode`. In other
    cases, it may be better to throw an exception to cause a short circuit in our
    application flow to prevent additional logic from being executed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2将为任何成功的请求返回HTTP 200状态码。如果我们想在不中断逻辑流程的情况下调整状态码，我们可以简单地为`yii\web\Response::$statusCode`定义一个新的状态码。在其他情况下，可能更好的做法是抛出异常，以在应用程序流程中引起短路，防止执行额外的逻辑。
- en: 'In general, web exceptions can be thrown by calling `yii\web\HttpException`
    with a valid HTTP status code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以通过调用带有有效HTTP状态码的`yii\web\HttpException`来抛出网络异常：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For convenience, Yii2 provides several specific methods for a few different
    types of requests, as shown in the following table:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Yii2为几种不同类型的请求提供了几个特定的方法，如下表所示：
- en: '| Exception | Status Code | HTTP Error |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 异常 | 状态码 | HTTP错误 |'
- en: '| --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `yii\web\BadRequestHttpException` | 400 | Bad request |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\BadRequestHttpException` | 400 | 错误请求 |'
- en: '| `yii\web\UnauthorizedHtpException` | 401 | Unauthorized |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\UnauthorizedHtpException` | 401 | 未授权 |'
- en: '| `yii\web\ForbiddenHttpException` | 403 | Forbidden |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\ForbiddenHttpException` | 403 | 禁止访问 |'
- en: '| `yii\web\NotFoundHttpException` | 404 | Not found |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\NotFoundHttpException` | 404 | 未找到 |'
- en: '| `yii\web\MethodNotAllowedException` | 405 | Method not allowed |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\MethodNotAllowedException` | 405 | 不允许的方法 |'
- en: '| `yii\web\NotAcceptableHttpException` | 406 | Not acceptable |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\NotAcceptableHttpException` | 406 | 不可接受 |'
- en: '| `yii\web\ConflictHttpException` | 409 | Conflict |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\ConflictHttpException` | 409 | 冲突 |'
- en: '| `yii\web\GoneHttpException` | 410 | Gone |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\GoneHttpException` | 410 | 已消失 |'
- en: '| `yii\web\UnsupportedMediaTypeHttpException` | 415 | Unsupported media type
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\UnsupportedMediaTypeHttpException` | 415 | 不支持的媒体类型 |'
- en: '| `yii\web\TooManyRequestsHttpException` | 429 | Too many requests |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\TooManyRequestsHttpException` | 429 | 请求过多 |'
- en: '| `yii\web\ServerErrorHttpException` | 500 | Sever error |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `yii\web\ServerErrorHttpException` | 500 | 服务器错误 |'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an alternative to throwing an empty `yii\web\HttpException` with a given
    status code, you can also extend `yii\web\HttpException` to implement your own
    `HttpException` exception.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为抛出一个带有给定状态码的空 `yii\web\HttpException` 的替代方案，你也可以扩展 `yii\web\HttpException`
    来实现你自己的 `HttpException` 异常。
- en: Setting response headers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置响应头
- en: 'As with the `yii\web\Request object`, we can manipulate the HTTP headers of
    our response using the `add()` and `remove()` methods from `yii\web\HeaderCollection`,
    as shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `yii\web\Request` 对象一样，我们可以使用 `yii\web\HeaderCollection` 的 `add()` 和 `remove()`
    方法来操作我们响应的 HTTP 头部，如下面的示例所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Adding new headers will override any previously set headers with the same name.
    Moreover, all headers set through `yii\web\HeaderCollection` are case insensitive.
    Removing a header will remove any header with the name that is currently sent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新头将覆盖具有相同名称的任何先前设置的头部。此外，通过 `yii\web\HeaderCollection` 设置的所有头部都是不区分大小写的。删除一个头部将删除任何具有当前发送名称的头部。
- en: Headers can be manipulated at any time during the response up until `yii\web\Response::send()`
    is called, which, by default, is called right before the response body is sent
    out.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任何时候操作头部，直到调用 `yii\web\Response::send()`，默认情况下，这是在响应体发送出去之前调用的。
- en: The response body
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应体
- en: 'Typically, the response body will be represented by an instance of `yii\web\View`,
    which is usually displayed to the end user by returning a rendered view inside
    a controller action, as shown here. By default, Yii2 will return the response
    with a MIME type of text/HTML and will format the response using `yii\web\HtmlResponseFormatter`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，响应体将由 `yii\web\View` 的一个实例表示，这通常通过在控制器操作中返回渲染的视图来显示给最终用户，如下所示。默认情况下，Yii2
    将以 MIME 类型 text/HTML 返回响应，并使用 `yii\web\HtmlResponseFormatter` 格式化响应：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There may be situations, however, where a different response type may be required,
    such as when displaying JSON or XML data. Within our controller action, we can
    change the output format from the default by setting the `yii\web\Response::$format`
    property and returning either an array or a string representing the data we want
    formatted, as shown in the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在需要不同响应类型的情况，例如在显示 JSON 或 XML 数据时。在我们的控制器操作中，我们可以通过设置 `yii\web\Response::$format`
    属性并返回表示我们想要格式化的数据的数组或字符串来更改输出格式，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous example will output the following JSON data to the client:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将输出以下 JSON 数据给客户端：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition to JSON formatting, `yii\web\Response::$format` can also be set
    to JSONP, HTML, RAW, and XML using the details outlined in the following table:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JSON 格式化外，`yii\web\Response::$format` 还可以设置为 JSONP、HTML、RAW 和 XML，具体细节如下表所示：
- en: '| Type | Formatter class | Format value |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 格式化器类 | 格式值 |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| HTML | `yii\web\HtmlResponseFormat` | `FORMAT_HTML` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| HTML | `yii\web\HtmlResponseFormat` | `FORMAT_HTML` |'
- en: '| RAW |   | `FORMAT_RAW` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| RAW |   | `FORMAT_RAW` |'
- en: '| XML | `yii\web\XmlResponseFormatter` | `FORMAT_XML` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| XML | `yii\web\XmlResponseFormatter` | `FORMAT_XML` |'
- en: '| JSON | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| JSON | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
- en: '| JSONp | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| JSONp | `yii\web\JsonResponseFormatter` | `FORMAT_JSON` |'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: RAW data will be submitted to the client as is without any additional formatting
    being applied to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据将按原样提交给客户端，不对其应用任何额外的格式。
- en: 'In addition to working with the default response object, in Yii2, you can also
    create new response objects to be sent to the end user, as shown in the following
    example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理默认响应对象外，在 Yii2 中，你还可以创建新的响应对象以发送给最终用户，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any custom configuration set for the response application component will not
    be applied to any custom response objects that you instantiate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为响应应用程序组件设置的任何自定义配置都不会应用于你实例化的任何自定义响应对象。
- en: 'While controller actions are the primary place where you will find yourself
    editing the response body, the response body can be modified from anywhere in
    Yii by directly manipulating `\Yii::$app->response`. Any data that has been already
    formatted can be assigned directly to the response object by setting the `yii\web\Response::$content`
    property. Moreover, if you want to have the data being passed through a response
    formatted before being sent to the user, you can set `yii\web\Response::$content`
    and then set `yii\web\Response::$data` with the data you want formatted:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制器动作是您最可能编辑响应体的地方，但您可以通过直接操作`\Yii::$app->response`在任何地方修改Yii2中的响应体。任何已经格式化的数据都可以通过设置`yii\web\Response::$content`属性直接分配给响应对象。此外，如果您想在数据发送给用户之前通过响应格式化数据，可以设置`yii\web\Response::$content`，然后设置`yii\web\Response::$data`为要格式化的数据：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Redirection
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向
- en: 'In order to redirect a browser to a new page, the special header location must
    be set by the response. Yii2 provides special support for this through the `yii\web\Response::redirect()`
    method, which can be called from within a controller action, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将浏览器重定向到新页面，响应必须设置特殊的头部位置。Yii2通过`yii\web\Response::redirect()`方法提供了对此的特殊支持，该方法可以在控制器动作内部调用，如下所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, Yii2 will return a 302 status code, indicating that the redirect
    should be temporary. To notify the browser to permanently redirect the request,
    you can set the second parameter of `yii\web\Response::redirect()` to 301, which
    is the HTTP status code for a permanent redirection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2将返回302状态码，表示重定向应该是临时的。为了通知浏览器永久重定向请求，可以将`yii\web\Response::redirect()`的第二个参数设置为301，这是永久重定向的HTTP状态码。
- en: 'Outside a controller action, a redirect can be called by calling the `redirect()`
    method and then immediately sending the response, as shown in the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器动作外部，可以通过调用`redirect()`方法然后立即发送响应来调用重定向，如下例所示：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The file output
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输出
- en: 'Similar to browser redirection, outputting a file to the client requests several
    custom headers to be set. To facilitate the transfer of files to the browser,
    Yii2 provides three distinct methods to output files:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器重定向类似，输出文件到客户端需要设置几个自定义头部。为了便于将文件传输到浏览器，Yii2提供了三种不同的方法来输出文件：
- en: '`yii\web\Response::sendFile()` should be used when sending an existing file
    located on the disk'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送位于磁盘上的现有文件时，应使用`yii\web\Response::sendFile()`。
- en: '`yii\web\Response::sendContentAsFile()` sends a string of data as a file (such
    as a CSV file)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yii\web\Response::sendContentAsFile()`将数据字符串作为文件发送（例如CSV文件）'
- en: '`yii\web\Response::sendStreamAsFile()` should be used for large files (typically,
    files larger than 100 MB), and it should be sent to the browser as it is more
    memory efficient. Within a controller, these methods can be called directly to
    send a file:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大文件（通常，文件大小超过100 MB），应使用`yii\web\Response::sendStreamAsFile()`，并且它应该以流的形式发送到浏览器，因为它更节省内存。在控制器中，可以直接调用这些方法来发送文件：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similar to redirecting a browser, these methods can be called outside a controller
    action by manipulating the response object directly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与重定向浏览器类似，这些方法可以通过直接操作响应对象在控制器动作外部调用：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the response object can be found in the Yii2 documentation
    at [http://www.yiiframework.com/doc-2.0/yii-web-response.html](http://www.yiiframework.com/doc-2.0/yii-web-response.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于响应对象的更多信息可以在Yii2文档中找到，请参阅[http://www.yiiframework.com/doc-2.0/yii-web-response.html](http://www.yiiframework.com/doc-2.0/yii-web-response.html)。
- en: Events
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Often when working with complex code bases, we may implement hooks and handlers
    so that our application can call custom code outside our main application flow.
    In Yii2, these handlers are called events, which can be automatically executed
    when a given event is triggered. For example, in a blogging platform, we may create
    an event to indicate that a post was published, which will trigger some custom
    code to send out an email to users in a specific mailing list. In this section,
    we'll cover how to create event handlers, trigger events, and write our own custom
    events.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂的代码库时，我们可能会实现钩子和处理器，以便我们的应用程序可以在主应用程序流程之外调用自定义代码。在Yii2中，这些处理器被称为事件，当触发给定事件时可以自动执行。例如，在一个博客平台上，我们可能会创建一个事件来指示帖子已发布，这将触发一些自定义代码向特定邮件列表的用户发送电子邮件。在本节中，我们将介绍如何创建事件处理器、触发事件以及编写我们自己的自定义事件。
- en: Event handlers
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理器
- en: Events in Yii2 are implemented within the `yii\base\Component` base class, which
    nearly every class in Yii2 extends from. By extending from this class, we can
    bind an event to nearly anywhere in our codebase. To begin working with events,
    we first need to create an event handler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2中的事件是在`yii\base\Component`基类中实现的，这个基类几乎被Yii2中的每个类扩展。通过扩展这个类，我们可以在代码库的几乎任何地方绑定一个事件。要开始使用事件，我们首先需要创建一个事件处理器。
- en: 'Event handlers in Yii2 can be bound by calling the `yii\base\Component::on()`
    method, and they specify a callback that should be executed when the event is
    triggered. These callbacks can take several different forms, ranging from a global
    PHP function specified as a string to an anonymous function written inline on
    the event. For instance, if we want to call a global PHP function (such as the
    one we defined or a built-in function such as `trim`), we can bind our event,
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2中的事件处理器可以通过调用`yii\base\Component::on()`方法来绑定，并指定当事件被触发时应执行的回调。这些回调可以采取几种不同的形式，从作为字符串指定的全局PHP函数到在事件内联编写的匿名函数。例如，如果我们想调用一个全局PHP函数（如我们定义的或内置函数如`trim`），我们可以绑定我们的事件，如下所示：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Events handlers can also be called on any PHP object: either the one that we
    already have an instance variable for or a namespaced class within our application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任意PHP对象上调用事件处理器：要么是我们已经有实例变量的对象，要么是我们应用程序中的命名空间类：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Moreover, event handlers can be written as an anonymous function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件处理器可以编写为匿名函数：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Additional data can be passed to event handlers by passing any data as the
    third parameter to the `yii\base\Component::on()` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将任何数据作为`yii\base\Component::on()`方法的第三个参数传递给事件处理器来传递额外的数据：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Furthermore, multiple event handlers can be bound to a single event. When a
    given event is triggered, each event will execute in the order in which it was
    bound to the event. If an event handler needs to stop the execution of the other
    events that follow, it can set the `yii\base\Event::$handled` property of the
    `$event` object to `true`, which will prevent all the event handlers bound to
    the event from not executing:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以将多个事件处理器绑定到单个事件。当给定事件被触发时，每个事件将按照绑定到事件的顺序执行。如果事件处理器需要停止后续事件的执行，它可以将`$event`对象的`yii\base\Event::$handled`属性设置为`true`，这将防止所有绑定到该事件的处理器执行：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By default, the event handler in Yii2 is bound in the order in which it is
    called, which means that the last event handler bound to a given event will be
    called last. To prepend an event handler to the beginning of the event handler
    queue, you can set the `$append` parameter of `yii\base\Component::on()` to `false`,
    which will override the default behavior and cause the event handler to be triggered
    first when the event is raised:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2中的事件处理器按照调用的顺序绑定，这意味着绑定到给定事件的最后一个事件处理器将最后被调用。要将在事件处理器队列的开头添加一个事件处理器，可以将`yii\base\Component::on()`方法的`$append`参数设置为`false`，这将覆盖默认行为，并在事件被触发时首先触发事件处理器：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Event handlers can also be unbound from the event they''re listening to by
    calling `yii\base\Component::off()` using the same syntax used to attach the event
    listener to the event. Alternatively, all events handlers can be unbound from
    an event by calling `yii\base\Component::off()` without any additional parameters,
    as shown in the following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器也可以通过使用与附加事件监听器到事件相同的语法调用`yii\base\Component::off()`来从它们监听的事件中解绑。或者，可以通过调用`yii\base\Component::off()`而不带任何额外参数来从事件中解绑所有事件处理器，如下面的示例所示：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Triggering events
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'Events in Yii2 are triggered by calling the `yii\base\Component::trigger()`
    method, which takes the event name as the second parameter, and an optional instance
    of `yii\base\Event` as the second parameter. For example, we can call `Thing::EVENT_NAME`
    within our code, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，通过调用`yii\base\Component::trigger()`方法来触发事件，该方法将事件名称作为第二个参数，并可选地传递`yii\base\Event`的实例作为第二个参数。例如，我们可以在代码中调用`Thing::EVENT_NAME`，如下所示：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This event was previously bound with the following event:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件之前绑定如下：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, the `app\components\Thing::doThing()` method will be triggered. This code
    may look as follows for our imaginary component:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`app\components\Thing::doThing()`方法将被触发。这段代码对于我们的虚构组件可能如下所示：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Yii2 considers it a best practice to store event names as constants within classes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2认为将事件名称存储为类中的常量是一种最佳实践。
- en: 'Additional information can be sent to our event handlers by extending `yii\base\Event`
    and passing it as the second parameter of our trigger call, as shown in the following
    example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过扩展`yii\base\Event`并将其作为触发调用第二个参数传递，向我们的事件处理器发送附加信息，如下面的示例所示：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Due to the single-threaded nature of PHP, Yii2's events will occur synchronously
    rather than asynchronously, which will block all other application flows from
    occurring until all the events in the event handler queue are complete. Consequently,
    you should be careful when using many events as they may cause detrimental application
    performance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PHP的单线程特性，Yii2的事件将同步发生而不是异步发生，这将会阻塞所有其他应用程序流程，直到事件处理队列中的所有事件都完成。因此，在使用多个事件时应该小心，因为它们可能会对应用程序性能产生不利影响。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One way to use implemented asynchronous events (such as sending an email newsletter
    from a CMS) is to have your event handlers pass off the event to a third-party
    messaging queue, such as Gearman, Sidekiq, or Resque, and immediately return the
    event. The event can then be handled in a separate processing thread, which can
    be a Yii2 console command configured to read events from the messaging queue and
    process them separately from the main application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实现异步事件（例如从CMS发送电子邮件通讯）的一种方法是将事件处理程序传递给第三方消息队列（如Gearman、Sidekiq或Resque），并立即返回事件。然后，事件可以在单独的处理线程中处理，这可以是一个配置为从消息队列读取事件并单独处理它们的Yii2控制台命令。
- en: Class-level events
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类级事件
- en: The events described previously were bound at an instance level. In Yii2, events
    can be bound to every instance of a class rather than a specific instance, and
    they can also be bound to Yii2's global event handler.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的事件是在实例级别绑定的。在Yii2中，事件可以绑定到类的每个实例，而不是特定实例，它们也可以绑定到Yii2的全局事件处理器。
- en: 'Class-level events can be bound by attaching the event handler directly through
    `yii\base\Event::on()`. For instance, Active Record will trigger an `EVENT_AFTER_DELETE`
    event whenever a record is deleted from the database. We can log this information
    for every Active Record instance, as shown in the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类级事件可以通过直接通过`yii\base\Event::on()`附加事件处理器来绑定。例如，Active Record在从数据库中删除记录时将触发`EVENT_AFTER_DELETE`事件。我们可以为每个Active
    Record实例记录此信息，如下面的示例所示：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Whenever a trigger occurs, it will first call instance-level event handlers,
    then it will call class-level event handlers, and then it will call global event
    handlers. Class-level events can be explicitly called by calling `yii\base\Event::trigger()`
    directly. Additionally, class-level event handlers can be removed through `yii\base\Event::off()`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每当触发器发生时，它将首先调用实例级事件处理器，然后调用类级事件处理器，最后调用全局事件处理器。可以通过直接调用`yii\base\Event::trigger()`显式调用类级事件。此外，可以通过`yii\base\Event::off()`移除类级事件处理器。
- en: Global events
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局事件
- en: 'Global events are supported in Yii2 by binding event handlers to the application
    singleton instance itself, as shown in the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，通过将事件处理器绑定到应用程序单例实例本身来支持全局事件，如下面的示例所示：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using global events, be cautious as to not override Yii2's built-in global
    events. Any global event that you use should include some sort of prefix in order
    to avoid collision with Yii2's built-in events.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用全局事件时，要小心不要覆盖Yii2的内置全局事件。你使用的任何全局事件都应该包含某种前缀，以避免与Yii2的内置事件冲突。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of how requests and responses are handled
    in Yii2\. We first explored how Yii2 handles the routing of URL routes, and we
    learned how to manipulate and create our own custom URL rules. We then explored
    the `yii\web\Request` and `yii\web\Response` objects and gained a better understanding
    of how we can use these objects to manipulate the requests and responses coming
    to and from our application. Finally, we learned how events work in Yii2, and
    we also learned how to create our own events.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍了Yii2中请求和响应处理的基本知识。我们首先探讨了Yii2如何处理URL路由的分配，并学习了如何操作和创建我们自己的自定义URL规则。然后，我们探讨了`yii\web\Request`和`yii\web\Response`对象，并更好地理解了如何使用这些对象来操作进入和离开我们应用程序的请求和响应。最后，我们学习了Yii2中事件的工作方式，并学习了如何创建我们自己的事件。
- en: In the next chapter, we'll take the knowledge we've gained in this chapter to
    the next level by exploring how to implement RESTful APIs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索如何实现RESTful API，将本章中获得的知识提升到新的水平。
