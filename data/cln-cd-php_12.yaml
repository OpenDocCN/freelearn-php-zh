- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Working in a Team
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队合作
- en: The main goal of this book is to enable you to write code that can be understood,
    maintained, and extended by you and others. Most of the time, being a PHP developer
    means that you do not work alone on a project or a tool. And even if you started
    writing code alone, chances are high that at some point, another developer will
    join you – be it on a commercial product, or your open source package where other
    developers start adding new features or bug fixes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的主要目标是让你能够编写可以被你和其他人理解、维护和扩展的代码。大多数时候，成为一名PHP开发者意味着你不会单独在一个项目或工具上工作。即使你开始独自编写代码，也很可能最终会有其他开发者加入你——无论是商业产品，还是你的开源包，其他开发者开始添加新功能或修复错误。
- en: There will always be multiple ways to carry out a task in software development.
    This is what makes working in a team more challenging when you want to write *clean
    code* together. In this chapter, you will find several tips and best practices
    on how to set up *coding standards* and *coding guidelines*. We will also talk
    about how *code reviews* will improve the code and ensure the guidelines are kept.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，总会有多种执行任务的方法。这就是当你想要一起编写*干净代码*时，团队合作变得更加具有挑战性的原因。在本章中，你将找到关于如何设置*编码标准*和*编码指南*的几个技巧和最佳实践。我们还将讨论*代码审查*如何改进代码并确保遵循指南。
- en: We will also explore the topic of *design patterns* in more detail at the end
    of this chapter. These patterns can help your team solve typical software development
    problems because they offer well-tested solutions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在本章末尾更详细地探讨*设计模式*这一主题。这些模式可以帮助你的团队解决典型的软件开发问题，因为它们提供了经过充分测试的解决方案。
- en: 'This chapter will include the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括以下部分：
- en: Coding standards
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准
- en: Coding guidelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码指南
- en: Code reviews
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you followed along with the previous chapters, you do not require any additional
    setup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随着前面的章节，你不需要进行任何额外的设置。
- en: 'The code samples for this chapter can be found in our GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在我们的GitHub仓库中找到：[https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)。
- en: Coding standards
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码标准
- en: In the previous chapters, you learned a lot about writing high-quality code.
    Yet, it is not enough if you do it by yourself only. When you work in a team,
    you will most likely have the problem that other developers have a different understanding
    of quality and are on a different skill level than you are.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到了很多关于编写高质量代码的知识。然而，如果你只是自己这样做，那就不够了。当你在一个团队中工作时，你很可能会遇到其他开发者对质量有不同的理解，并且他们的技能水平与你不同。
- en: This is harmful to your code because it might lead to lazy compromises, where
    the involved parties agree on a way, just to have their peace. Therefore, if you
    want to work effectively in a team, you want to standardize your work as much
    as possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你的代码是有害的，因为它可能会导致懒惰的妥协，其中涉及的各方同意一种方式，只是为了保持和平。因此，如果你想在一个团队中有效地工作，你希望尽可能标准化你的工作。
- en: 'It makes sense to start with the low-hanging fruit: code formatting. This goes
    down to the very basics, such as agreeing on how many spaces should be used to
    indent lines, or where braces should be placed. But why is this even important?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从低垂的果实开始是有意义的：代码格式化。这涉及到最基本的，比如同意使用多少空格来缩进行，或者大括号应该放在哪里。但为什么这甚至很重要呢？
- en: We already shortly addressed this topic in [*Chapter 5*](B19050_05.xhtml#_idTextAnchor055)*,
    Optimizing Your Time and Separating Responsibilities*. However, we want to expand
    on it at this point. The main advantage of having a common **coding standard**
    (also called *coding style*) is to reduce *cognitive friction* when reading code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第五章*](B19050_05.xhtml#_idTextAnchor055)*，优化你的时间和分离责任*中简要地提到了这个话题。然而，我们想在这里进一步展开。拥有共同的**编码标准**（也称为*编码风格*）的主要优势是减少阅读代码时的*认知摩擦*。
- en: Cognitive friction
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 认知摩擦
- en: Cognitive friction basically describes the required mental effort for our brain
    to process information. Imagine, for example, you read a book, where every other
    paragraph was written in a different font, size, or line spacing. You would still
    be able to read it, but it would become annoying or tiring soon. The same applies
    to reading code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 认知摩擦基本上描述了我们的大脑处理信息所需的精神努力。想象一下，例如，你读一本书，其中每隔一段文字就使用了不同的字体、大小或行间距。你仍然能够阅读它，但很快就会变得令人烦恼或疲劳。同样的情况也适用于阅读代码。
- en: Introducing a coding standard to a project is relatively easy, thanks to the
    tools we already presented to you earlier in this book. Agreeing with others on
    a common standard, on the other hand, requires more work. That is why, in this
    section, we want to show you how to easily align on a common coding standard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将编码规范引入项目相对容易，多亏了我们在本书前面介绍给你的工具。另一方面，与他人就共同标准达成一致则需要更多的工作。这就是为什么在本节中，我们想向你展示如何轻松地就共同编码标准达成一致。
- en: Going with existing standards
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循现有标准
- en: Setting up standards together with others can be a long and painful process.
    However, nowadays, you do not argue about the size of a sheet of paper anymore.
    In European countries, the *DIN A4* standard is widely accepted, while in other
    countries, such as the US, you would use the *US Letter Size* without asking why.
    Most people accept these measures, and following these standards makes life a
    bit easier – one thing less to care about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与他人一起制定标准可能是一个漫长而痛苦的过程。然而，如今，你不再争论纸张的大小了。在欧洲国家，*DIN A4*标准被广泛接受，而在其他国家，如美国，你会使用*US
    Letter Size*而无需询问原因。大多数人接受这些措施，遵循这些标准使生活变得稍微容易一些——少了一件需要担心的事情。
- en: The same applies to coding standards, which define how you format your code.
    Of course, you could argue for hours with your teammates about whether *tabs*
    or *spaces* should be used for the indentation. Both sides will come up with valid
    arguments, and you will never find the right answer, as there simply is no right
    and wrong here. And once you got the question about indentation sorted, the next
    topic to discuss could be the placement of brackets. Should they appear in the
    same line, or in the next?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于编码规范，它定义了你的代码应该如何格式化。当然，你可以和你的队友争论几个小时，关于是否应该使用*制表符*或*空格*进行缩进。双方都会提出有效的论据，但你永远不会找到正确答案，因为这里根本就没有对错之分。一旦你解决了关于缩进的疑问，下一个讨论的话题可能是括号的放置。它们应该出现在同一行，还是下一行？
- en: We do not necessarily need to agree with every detail of a standard, but undoubtedly,
    it saves time and nerves to use existing norms. In the PHP ecosystem, there are
    *Coding Standards* that already exist that you could utilize. A huge additional
    benefit of doing so is that the code sniffers have built-in rule sets for these
    standards. In the next section, we will talk about probably the best-known *Coding
    Standard* for PHP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定需要同意标准的每一个细节，但无疑，使用现有的规范可以节省时间和精力。在PHP生态系统中，已经存在一些你可以利用的*编码规范*。这样做的一个巨大额外好处是，代码嗅探器为这些标准内置了规则集。在下一节中，我们将讨论PHP最著名的*编码规范*。
- en: PHP-FIG and PSR
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP-FIG和PSR
- en: PHP itself has no official *Coding Standard*. Historically, each major PHP framework
    that existed, or still exists today, introduced some sort of standards because
    the developers quickly realized that using them has its benefits.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PHP本身没有官方的*编码规范*。从历史上看，每个曾经存在或至今仍存在的重大PHP框架都引入了一些标准，因为开发者很快意识到使用它们有其好处。
- en: However, since every project used its own standards, the PHP world ended up
    with a mixture of different formatting standards. Back in 2009, when the **PHP-FIG**
    (**PHP Framework Interoperability** **Group** (**PHP-FIG**) was formed, which
    consisted of members from all the important PHP projects and frameworks of that
    time, they wanted to solve exactly these kinds of problems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于每个项目都使用自己的标准，PHP世界最终形成了一种不同格式标准的混合。回想起2009年，当**PHP-FIG**（**PHP框架互操作性**组（**PHP-FIG**））成立时，该组织由当时所有重要PHP项目和框架的成员组成，他们想要解决的就是这类问题。
- en: 'At that time, Composer was becoming more and more important, and packages were
    introduced that could easily be used across different frameworks. To keep the
    code somewhat consistent, a mutual way to write code was agreed upon: the **PHP
    Standard Recommendations** (**PSRs**) were born.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，Composer变得越来越重要，引入了可以在不同框架之间轻松使用的包。为了保持代码的某种一致性，达成了一种共同编写代码的方式：**PHP标准建议**（**PSRs**）应运而生。
- en: To make the autoloader of Composer work, it was necessary to agree on how to
    name classes and directories. This was done with the very first standard recommendation,
    *PSR-0* (yes, nerds start counting at 0), which was eventually replaced by *PSR-4*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Composer的自动加载器工作，有必要就如何命名类和目录达成一致。这是通过第一个标准建议*PSR-0*（是的，极客们从0开始计数）实现的，它最终被*PSR-4*取代。
- en: The first *Coding Standard* recommendation was introduced with *PSR-1* and *PSR-2*.
    *PSR-2* was later replaced by *PSR-12*, which contained rules for language features
    of newer PHP versions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个*编码标准*建议是在*PSR-1*和*PSR-2*中引入的。*PSR-2*后来被*PSR-12*取代，其中包含了针对新PHP版本语言特性的规则。
- en: 'Although *PSR-12* addresses the code style, it does not cover naming conventions
    or how to structure the code. This is often still predefined by the framework
    you use. The *Symfony* framework, for example, has its own set of *Coding Standards*
    that are based on the aforementioned *PSR-4* and *PSR-12*, but add further guidelines,
    for example, conventions on naming or documentation. Even if you do not use a
    framework at all and just pick single components to build an application, you
    could consider using these guidelines, which you will find on the *Symfony* website:
    [https://symfony.com/doc/current/contributing/code/standards.html](https://symfony.com/doc/current/contributing/code/standards.html).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PSR-12解决了代码风格问题，但它没有涵盖命名约定或如何组织代码。这通常仍然由你使用的框架预先定义。例如，*Symfony*框架有自己的基于上述*PSR-4*和*PSR-12*的*编码标准*，并添加了进一步的指导，例如命名或文档约定。即使你根本不使用框架，只是选择单个组件来构建应用程序，你也可以考虑使用这些在*Symfony*网站上可以找到的指南：[https://symfony.com/doc/current/contributing/code/standards.html](https://symfony.com/doc/current/contributing/code/standards.html)。
- en: PER coding style
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PER编码风格
- en: '*PSR-12* was released in 2019 and thus does not cover the latest PHP features
    anymore. Therefore, at the time of writing this book, PHP-FIG released the *PER
    Coding Style 1.0.0* (**PER** is short for **PHP Extended Recommendation**). It
    is based on *PSR-12* and contains some additions to it. In the future, the PHP-FIG
    no longer plans to release any new *Coding Standards* related to PSRs, but new
    versions of this PER, if it is required. It is very likely that the **code quality**
    tools we featured in this book will pick up the new PER soon. You will find more
    information about it here: [https://www.php-fig.org/per/coding-style](https://www.php-fig.org/per/coding-style).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*PSR-12*于2019年发布，因此不再涵盖最新的PHP特性。因此，在撰写本书时，PHP-FIG发布了*PER编码风格1.0.0*（**PER**代表**PHP扩展建议**）。它基于*PSR-12*，并对其进行了某些补充。未来，PHP-FIG不再计划发布任何与PSR相关的新的*编码标准*，除非需要，才会发布新的PER版本。我们很有可能会在本书中介绍的**代码质量**工具很快就会采用新的PER。你可以在以下链接中找到更多关于它的信息：[https://www.php-fig.org/per/coding-style](https://www.php-fig.org/per/coding-style)。'
- en: 'Over time, the PHP-FIG has introduced over a dozen recommendations, and more
    are in the making. They cover topics such as how to integrate logging, caching,
    and HTTP clients, to just name a few. You will find a complete list on the official
    website: [https://www.php-fig.org](https://www.php-fig.org).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，PHP-FIG已经引入了十多个建议，并且还有更多正在制作中。它们涵盖了如何集成日志记录、缓存和HTTP客户端等主题。你可以在官方网站上找到完整的列表：[https://www.php-fig.org](https://www.php-fig.org)。
- en: Problems with PHP-FIG and PSR
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FIG和PSR的问题
- en: The PHP-FIG should not be considered the official PHP authority, and neither
    should any PSR be taken as indisputable. In fact, many important frameworks such
    as *Symfony* or *Laravel* are not part of the PHP-FIG anymore, since the recommended
    standards have interfered too much with their internals. Looking at all the PSRs
    that are available today, you could even regard them as their own meta-framework.
    This is not to diminish the relevance of many recommendations though – we just
    want you to not blindly accept them as granted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FIG不应被视为官方的PHP权威机构，任何PSR也不应被视为无可争议。事实上，许多重要的框架，如*Symfony*或*Laravel*，已经不再属于PHP-FIG，因为推荐的标准对它们的内部结构干扰过多。看看今天可用的所有PSR，你甚至可以将它们视为它们自己的元框架。但这并不是要贬低许多建议的相关性——我们只是希望你们不要盲目地接受它们为既定事实。
- en: Enforcing coding standards in your IDE
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的IDE中强制执行编码标准
- en: There are several ways to enforce coding standards. In the previous chapter,
    [*Chapter 11*](B19050_11.xhtml#_idTextAnchor145)*, Continuous Integration*, we
    explained how to make sure that no wrongly formatted code can spoil the code base.
    This worked fine, yet it requires an additional step, even if we let our tools
    fix the code formatting automatically because we need to commit those changed
    files again. So, would it not actually be useful if our code editor, or IDE, would
    help us with formatting the code while we write it?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以强制执行编码规范。在上一章[*第11章*](B19050_11.xhtml#_idTextAnchor145)“持续集成”中，我们解释了如何确保没有错误格式的代码会破坏代码库。这效果很好，但即使我们让我们的工具自动修复代码格式，也需要额外的步骤，因为我们需要再次提交这些更改过的文件。所以，如果我们的代码编辑器或IDE在编写代码时帮助我们格式化代码，这实际上不是很有用吗？
- en: Modern code editors usually have built-in functionality that assists you with
    adhering to your preferred coding standards, if you configure them. If not built-in,
    this functionality can at least be provided with plugins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现代代码编辑器通常具有内置功能，可以帮助你遵守你偏好的编码规范，如果你进行了配置的话。如果没有内置，这种功能至少可以通过插件提供。
- en: 'There are two basic ways your editor could support you:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编辑器可以支持你的两种基本方式：
- en: '**Highlighting the coding standard violations**: The IDE marks those parts
    of the source code that need to be corrected. It will not change the code actively
    though.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突出显示编码规范违规**：IDE会标记出需要修正的源代码部分。尽管如此，它不会主动更改代码。'
- en: '`PHP_CS_Fixer`. This can be done upon manual request, or every time a file
    is saved.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PHP_CS_Fixer`。这可以在手动请求时进行，或者每次保存文件时进行。'
- en: Reformatting the code on file save is a very convenient way to ensure that your
    code meets the coding standards. How to set this up depends on which IDE you are
    using, so we will not elaborate on this further in this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件保存时重新格式化代码是一种非常方便的方式来确保你的代码符合编码规范。如何设置这取决于你使用的IDE，因此我们不会在本书中进一步详细说明。
- en: We would still recommend using **Git hooks** and **continuous integration**
    as the second layer of checks to make sure no badly formatted code gets pushed
    to the project repository. You can never be sure whether a team member accidentally
    or willingly disabled the automated reformatting or did not care about the highlighted
    parts of the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然建议使用**Git钩子**和**持续集成**作为检查的第二层，以确保没有格式错误的代码被推送到项目仓库。你永远不能确定团队成员是否意外或故意禁用了自动重新格式化，或者是否没有关注代码中突出显示的部分。
- en: '*Coding Standards* are all about how to format code consistently. But that
    is not all you should agree on when working in a team – in the next section, we
    will show you what other aspects are worth agreeing upon.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*编码规范*主要涉及如何一致地格式化代码。但在团队工作中，你还需要就其他方面达成一致——在下一节中，我们将向你展示哪些其他方面值得达成共识。'
- en: Coding guidelines
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码指南
- en: In the previous section, we talked about why you should introduce *Coding Standards*.
    Once this is accomplished, you should consider setting up **coding guidelines**.
    Both topics sound very familiar, and indeed, they are. Yet while *Coding Standards*
    usually focus on how to format code, coding guidelines define how to write code.
    This, of course, includes defining which *Coding Standard* to use, but covers
    a lot more, as you will learn in this section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了为什么你应该引入*编码规范*。一旦完成这项工作，你应该考虑设置**编码指南**。这两个话题听起来非常熟悉，确实如此。然而，尽管*编码规范*通常关注如何格式化代码，编码指南则定义了如何编写代码。这当然包括定义要使用哪个*编码规范*，但涵盖的内容远不止这些，你将在本节中了解到。
- en: What does *how to write code* exactly mean? Usually, there is more than one
    way to achieve things when writing software. Take the widely known **model-view-controller**
    (**MVC**) pattern, for example. It is used to divide the application logic into
    three types of interconnected elements – the models, the views, and the controllers.
    It does not explicitly define where to place the **business logic**, though. Should
    it be located inside the controllers, or rather inside the models?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “如何编写代码”究竟意味着什么？在编写软件时，通常有多种方式可以实现目标。以广为人知的**模型-视图-控制器**（**MVC**）模式为例。它用于将应用程序逻辑划分为三种相互关联的元素——模型、视图和控制器。尽管它没有明确定义将**业务逻辑**放在哪里。是应该放在控制器内部，还是更合适地放在模型内部？
- en: 'There is no clear right or wrong answer to this question. Our recommendation,
    however, would be the *fat models, skinny controllers* approach: business logic
    should *not* be written within the controllers, as they are the binding element
    between the views and your problem-specific code. Also, the controllers usually
    contain a lot of framework-specific code, and it is good practice to keep that
    out of your business logic as much as possible.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，没有明确的正确或错误答案。然而，我们的建议是采用*胖模型，瘦控制器*的方法：业务逻辑不应该在控制器中编写，因为它们是视图和特定问题代码之间的绑定元素。此外，控制器通常包含大量的框架特定代码，尽可能地将这些代码排除在业务逻辑之外是良好的实践。
- en: Regardless of our recommendation, it should be defined in the coding guidelines
    of your project how you think your team should handle this question. Otherwise,
    you will most likely end up having both approaches in your code base.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们的推荐如何，你的项目编码规范中应该定义你如何看待你的团队处理这个问题。否则，你很可能会在你的代码库中同时采用这两种方法。
- en: 'Usually, coding guidelines cover questions such as how to name methods, functions,
    and properties. As you might know from the famous quote “*There are only two hard
    things in computer science: cache invalidation and naming things*,” finding the
    right names is indeed not a trivial problem. So, having conventions on this topic
    at least reduces the time of developers trying to come up with a proper name.
    Furthermore, the same as *Coding Standards*, they help reduce cognitive friction.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编码规范涵盖了如何命名方法、函数和属性等问题。正如你可能从那句著名的引语中得知：“*计算机科学中只有两件难事：缓存失效和命名事物*”，找到合适的名称确实不是一个简单的问题。因此，在这个问题上至少有一些约定可以减少开发者尝试想出合适名称的时间。此外，它们与*编码标准*一样，有助于减少认知摩擦。
- en: Coding guidelines help the lesser-experienced developers in your team, or those
    who just started, to have a solution at hand that they otherwise needed to search
    for in the code or on the internet. It also helps write maintainable code by avoiding
    bad practices, as we already discussed in [*Chapter 3*](B19050_03.xhtml#_idTextAnchor031)*,
    Code, Don’t Do Stunts*. To help you get started with setting up the first set
    of rules, we will give you some examples in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范有助于你团队中经验较少的开发者，或者那些刚开始的人，能够手头上有解决方案，否则他们可能需要在代码或互联网上搜索。它还有助于通过避免我们已经在[*第3章*](B19050_03.xhtml#_idTextAnchor031)*，*代码，不要做特技*中讨论的坏习惯，来编写可维护的代码。为了帮助你开始设置第一套规则，我们将在下一节给出一些示例。
- en: Examples of coding guidelines
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码规范示例
- en: Starting with a blank sheet of (virtual) paper is hard, so in this section,
    we collected a list of real-world examples of what could be part of your coding
    guidelines. Please note that this collection of rules, although they are based
    on best practices, is not meant to be perfect or the only truth. We rather want
    to give you a good starting point for discussions and examples on what topics
    should be clarified using coding guidelines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从一张空白（虚拟）纸开始是困难的，因此在这一节中，我们收集了一些现实世界的例子，这些例子可能是你编码规范的一部分。请注意，尽管这些规则基于最佳实践，但它们并不是完美的或唯一的真理。我们更希望为你提供一个良好的起点，用于讨论和示例，哪些主题应该通过编码规范来明确。
- en: Naming conventions
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: By using **naming conventions**, we make sure that certain elements of our code
    are being named in a uniform and comprehensible way. This reduces cognitive friction
    and makes the onboarding of new team members easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**命名约定**，我们确保我们的代码中某些元素以统一和可理解的方式进行命名。这减少了认知摩擦，并使新团队成员的入职更容易。
- en: Services, repositories, and models
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务、存储库和模型
- en: Written in *UpperCamelCase*. Use the type as the suffix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*大驼峰命名法*。使用类型作为后缀。
- en: 'Here are some examples:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '`UserService`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService`'
- en: '`ProductRepository`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductRepository`'
- en: '`OrderModel`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderModel`'
- en: Events
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件
- en: Written in *UpperCamelCase*. Use the correct tense to indicate whether the event
    is fired before or after the actual event.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*大驼峰命名法*。使用正确的时态来表示事件是在实际事件之前还是之后触发的。
- en: 'Here are some examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '`DeletingUser` is the event before the deletion'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeletingUser`是删除事件之前'
- en: '`DeleteUser` is the actual event'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteUser`是实际事件'
- en: '`UserDeleted` is the event after the deletion'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDeleted`是删除事件之后'
- en: Properties, variables, and methods
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性、变量和方法
- en: Written in *lowerCamelCase*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*小驼峰命名法*。
- en: 'Here are some examples:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '`$someProperty`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$someProperty`'
- en: '`$longerVariableName`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$longerVariableName`'
- en: '`$myMethod`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$myMethod`'
- en: Tests
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试
- en: Written in *lowerCamelCase*. Use the word *test* as a prefix.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*小驼峰命名法*。使用单词*test*作为前缀。
- en: 'Here are some examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '`testClassCanDoSomething()`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testClassCanDoSomething()`'
- en: Traits
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特性
- en: Written in *UpperCamelCase*. Use the adjective to describe what the trait is
    used for.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*UpperCamelCase*格式编写。使用形容词来描述特性用途。
- en: 'Here are some examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '`Loggable`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loggable`'
- en: '`Injectable`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Injectable`'
- en: Interfaces
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口
- en: Written in *UpperCamelCase*. Use the word *Interface* as the suffix.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*UpperCamelCase*格式编写。使用单词*Interface*作为后缀。
- en: 'Herer are some examples:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '`WriterInterface`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriterInterface`'
- en: '`LoggerInterface`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggerInterface`'
- en: General PHP conventions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般PHP约定
- en: Even if you already use *Coding Standards* such as *PSR-12*, there are certain
    aspects that they do not cover. We will pick up some of them in this section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经使用了*编码标准*如*PSR-12*，也有一些方面它们没有涵盖。我们将在本节中介绍其中的一些。
- en: Comments and DocBlocks
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注释和DocBlocks
- en: Avoid comments if possible, as they tend to get outdated and thus confuse more
    than they help. Only keep comments that cannot be replaced by self-explanatory
    names or by simplifying code, so it is easier to understand and does not require
    the comment anymore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，避免使用注释，因为它们往往会过时，从而造成比帮助更大的困惑。仅保留那些不能被自解释的名称或简化代码所替代的注释，这样更容易理解，并且不再需要注释。
- en: 'Only add **DocBlocks** if they add information, such as annotations for the
    code quality tools. Particularly since PHP 8, most DocBlocks can be replaced by
    type hints, which all modern IDEs will understand. If you use type hints, most
    DocBlocks can be removed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当DocBlocks提供信息时才添加，例如代码质量工具的注释。尤其是从PHP 8开始，大多数DocBlocks都可以被类型提示所替代，所有现代IDE都会理解。如果你使用类型提示，大多数DocBlocks都可以删除：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Often, DocBlocks are automatically generated by the IDE. If they are not updated,
    they are at best useless, or can even be plainly wrong:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IDE会自动生成DocBlocks。如果它们没有更新，它们至多是无用的，甚至可能是明显错误的：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'DocBlocks should still be used for information that cannot be provided by PHP
    language features until now, such as specifying the content of an array, or marking
    a function as deprecated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DocBlocks仍然应该用于现在PHP语言特性无法提供的信息，例如指定数组内容，或标记函数为已弃用：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: About DocBlocks
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于DocBlocks
- en: DocBlocks were introduced to, among other things, partially compensate for the
    shortcomings of weak typing in earlier versions of PHP. The de facto standard
    was introduced by the `phpDocumentor` project ([https://www.phpdoc.org/](https://www.phpdoc.org/))
    and as such is supported by many tools such as IDEs and static code analyzers.
    Using strict typing, it is often not necessary to use DocBlocks anymore though,
    unless you want to use `phpDocumentor` in your project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: DocBlocks被引入，部分是为了弥补PHP早期版本中弱类型不足的缺点。这个事实上的标准是由`phpDocumentor`项目引入的([https://www.phpdoc.org/](https://www.phpdoc.org/))，因此得到了许多工具的支持，如IDE和静态代码分析器。尽管使用严格类型通常不再需要DocBlocks，除非你希望在项目中使用`phpDocumentor`。
- en: Ternary operators
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'Every part should be written in a single line to increase readability. Exceptions
    can be made for very short statements:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每部分应单独一行编写以提高可读性。对于非常简短的语句可以例外：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Do not use nested ternary operators, as they are hard to read and debug:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用嵌套的三元运算符，因为它们难以阅读和调试：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Constructor
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Use **constructor property promotion** for shorter classes, if working with
    PHP 8+. Keep the trailing comma after the last property, as this will make it
    easier to add or comment out lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PHP 8+，使用**构造函数属性提升**来缩短类，如果工作在PHP 8+上。在最后一个属性后保留尾随逗号，因为这将使得添加或注释行更容易：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Arrays
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组
- en: 'Always use the short array notation and keep the comma after the last entry
    (see the previous section, *Constructor*, for an explanation):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用短数组表示法，并在最后一个条目后保留逗号（参见前面的*构造函数*部分，以获取解释）：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Control structures
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制结构
- en: 'Always use brackets, even for one-liners. This reduces cognitive friction and
    makes it easier to add more lines of code later:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一行代码也要使用括号。这减少了认知摩擦，并使得以后添加更多代码行更容易：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Avoid `else` statements and return early, as this is easier to read and reduces
    the complexity of your code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`else`语句和尽早返回，因为这更易于阅读并减少了代码的复杂性：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exception handling
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'Empty `catch` blocks should be avoided, as they silently swallow error messages
    and thus can make it difficult to find bugs. Instead, log the error message or
    at least write a comment that explains why the exception can be ignored:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用空的`catch`块，因为它们会静默地吞咽错误信息，从而使得查找错误变得困难。相反，记录错误信息或至少写一个注释来解释为什么可以忽略异常：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Architectural patterns
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构模式
- en: Coding guidelines are not limited to how to format code or name elements. They
    can also help you to control how the code is written in an architectural sense.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编码指南不仅限于如何格式化代码或命名元素。它们还可以帮助您从架构角度控制代码的编写。
- en: Fat models, skinny controllers
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 肥胖模型，苗条控制器
- en: If the MVC pattern is used, the business logic should be located inside **models**
    or similar classes, such as **services** or **repositories**. **Controllers**
    should contain as little code as possible as is required to receive or transfer
    data between the **views** and the **models**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用MVC模式，业务逻辑应该位于**模型**或类似的类中，例如**服务**或**仓库**。**控制器**应该包含尽可能少的代码，以接收或传输视图和模型之间的数据。
- en: Framework-agnostic code
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与框架无关的代码
- en: In the context of the *fat models, skinny controllers* approach, you will probably
    come across the term *framework-agnostic business logic*. It means that the code
    that contains your business rules should use as few features of the underlying
    framework as possible. This makes framework updates or even migrations to other
    frameworks much easier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*肥胖模型，苗条控制器*方法中，您可能会遇到*框架无关的业务逻辑*这个术语。这意味着包含您的业务规则的代码应尽可能少地使用底层框架的功能。这使得框架更新或甚至迁移到其他框架变得更加容易。
- en: Single responsibility principle
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Classes and methods should only have one responsibility. See [*Chapter 2*](B19050_02.xhtml#_idTextAnchor021)*,
    Who Gets to Decide What “Good Practices” Are?,* for more information about this
    principle.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类和方法应该只有一个职责。参见[*第2章*](B19050_02.xhtml#_idTextAnchor021)*，谁有权决定“良好实践”是什么？*，了解更多关于这个原则的信息。
- en: Framework guidelines
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架指南
- en: In this book, we want to focus on writing clean code in PHP. Often, though,
    you will be working with frameworks, and although it is essential to include them
    in the guidelines as well, we do not want to go into much more detail here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们希望专注于编写PHP的干净代码。然而，通常您会与框架一起工作，尽管将它们包含在指南中也是必要的，但我们不想在这里过多地深入细节。
- en: 'However, next, you will find a list of questions that should give you a good
    idea about which framework-related topics to include in your guidelines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接下来，您将找到一份问题列表，这将帮助您了解在指南中应包含哪些框架相关主题：
- en: How to access the database
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问数据库
- en: How to configure routes
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置路由
- en: How to register new services
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何注册新服务
- en: How is authentication handled within your project?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的项目中如何处理身份验证？
- en: How should errors or other debug information be logged?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该如何记录错误或其他调试信息？
- en: How to create and organize view files
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和组织视图文件
- en: How to handle translations
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理翻译
- en: Since the answers to these questions highly depend on the used framework, we
    cannot give you recommendations here. You will need to set the guidelines up together
    with your team. In the next section, we will give you some ideas on how to do
    that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题的答案高度依赖于所使用的框架，我们在这里不能给您提供推荐。您需要与您的团队一起制定指南。在下一节中，我们将为您提供一些关于如何做到这一点的想法。
- en: Setting up guidelines
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置指南
- en: The process of setting up coding guidelines takes time and often requires several
    workshops in which the rules are discussed. This requires moderation, for example,
    by a technical lead; otherwise, you might get stuck in endless discussions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置编码指南的过程需要时间，通常需要几个研讨会来讨论规则。这需要调解，例如，由技术负责人来执行；否则，您可能会陷入无休止的讨论中。
- en: Do not worry if you cannot immediately reach an agreement on all topics though.
    Remind yourself that the people in your team have different backgrounds, experiences,
    and skill levels – and no one will directly ditch their personal ways of coding
    just because there are suddenly rules that they do not understand or accept.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能无法立即就所有主题达成一致，但请不要担心。提醒自己，您的团队成员有不同的背景、经验和技能水平——没有人会直接放弃他们个人的编码方式，仅仅因为突然出现了他们不理解或不接受的规则。
- en: Make sure to set up a process that checks from time to time whether the guidelines
    need to be updated. Maybe some rules get outdated over time, or new language features
    must be included. An action point in a regularly occurring team meeting would
    be a good opportunity for this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设置一个定期检查指南是否需要更新的流程。也许随着时间的推移，某些规则会过时，或者必须包含新的语言特性。在定期举行的团队会议中的行动点将是一个很好的机会来做这件事。
- en: The guidelines should be easily accessible in written form, such as in a wiki
    or the company’s internal knowledge base, which should be able to track the version
    history. Every team member should be able to write comments on it so that questions
    or issues can be handled as soon as they appear. Lastly, all team members should
    be automatically informed about new changes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 指南应以书面形式轻松获取，例如在维基或公司的内部知识库中，它应该能够跟踪版本历史。每个团队成员都应该能够对其发表评论，以便尽快处理问题或问题。最后，所有团队成员都应该自动收到关于新更改的通知。
- en: Once your team agrees on a set of rules, make sure to utilize the code quality
    tools you learned about in earlier chapters to automatically check whether the
    rules are respected. You can, for example, use *PHPStan* to detect empty `catch`
    blocks, or *PHPMD* to enforce `if` without using `else`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的团队就一套规则达成一致，确保利用你在前面章节中学到的代码质量工具自动检查这些规则是否得到遵守。例如，你可以使用 *PHPStan* 来检测空的
    `catch` 块，或者使用 *PHPMD* 来强制执行 `if` 而不使用 `else`。
- en: How can we ensure that our coding guidelines are applied? Obviously, we should
    use our code quality tools wherever possible. But what if these tools do not include
    the rules we would like to enforce? With a bit of internet research, you might
    be able to find a third-party implementation for them. Or, if you cannot find
    anything, you could even write custom rules yourself, since all static code analyzers
    are extendable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们的编码规范得到应用？显然，我们应该尽可能使用我们的代码质量工具。但如果这些工具不包括我们想要强制执行的规则呢？通过一点互联网研究，你可能会找到它们的第三方实现。或者，如果你找不到任何东西，你也可以自己编写自定义规则，因为所有静态代码分析器都是可扩展的。
- en: For rules that are too complicated to check automatically, we have to manually
    check whether they are used correctly. This can happen in code reviews, and we
    think they are so important that they deserve their own section in this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于太复杂而无法自动检查的规则，我们必须手动检查它们是否被正确使用。这可以在代码审查中发生，我们认为它们如此重要，以至于它们值得在这一章中拥有自己的部分。
- en: Setting up coding guidelines alone will just be a waste of time if you do not
    make sure that they are kept. We can automate checking all the coding style-related
    rules and also a fair number of coding guidelines. But at the moment, for those
    rules that are addressing the framework guidelines or architectural aspects, automation
    is no longer possible, and we humans must jump in, taking over the checks. At
    this point, code reviews come into play. Let us have a closer look in the next
    section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能确保它们得到遵守，仅仅设置编码规范将只是浪费时间。我们可以自动化检查所有与编码风格相关的规则，以及相当数量的编码规范。但到目前为止，对于那些针对框架规范或架构方面的规则，自动化不再可能，我们必须人类介入，接管检查。在这个时候，代码审查就派上用场了。让我们在下节中更详细地探讨。
- en: Code reviews
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查
- en: The process of manually checking the code of other developers is called a **code
    review**. This includes all changes, that is, not only new functionality but also
    bug fixes or even simple configuration changes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 手动检查其他开发者的代码的过程称为 **代码审查**。这包括所有更改，即不仅包括新功能，还包括错误修复甚至简单的配置更改。
- en: A review is always done by at least one fellow developer, and it usually happens
    in the context of a `main` branch; only if the reviewer approves the changes will
    they become part of the actual application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 审查通常由至少一位同行开发者完成，并且通常发生在 `main` 分支的上下文中；只有当审查者批准更改时，它们才会成为实际应用程序的一部分。
- en: In this section, we will discuss what you should look for in code reviews, why
    they are so important, and how they should be done to make them a successful tool
    in your toolkit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论你在代码审查中应该寻找什么，为什么它们如此重要，以及它们应该如何进行，以便使它们成为你工具箱中的成功工具。
- en: Why you should do code reviews
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你应该进行代码审查
- en: 'It might sound a bit obvious because that is what this whole book is about.
    Yet, it cannot be stressed enough – code reviews will improve the quality of your
    code. Let us examine more closely why:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点明显，因为这正是整本书的主题。然而，这一点不能被强调得足够——代码审查将提高你代码的质量。让我们更仔细地考察一下为什么：
- en: '**Easy to introduce**: Introducing code reviews usually comes with no additional
    costs (except for the required time). All major Git repository services such as
    **Bitbucket**, **GitLab**, or **GitHub** have a built-in review functionality
    that you can use immediately.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于引入**：引入代码审查通常没有额外的成本（除了所需的时间）。所有主要的 Git 代码库服务，如 **Bitbucket**、**GitLab**
    或 **GitHub**，都内置了内置的审查功能，你可以立即使用。'
- en: '**Quick impact**: Code reviews are not only easy to introduce but they will
    show their usefulness very soon after they have been introduced.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速影响**：代码审查不仅易于引入，而且一旦引入，它们很快就会显示出其有用性。'
- en: '**Knowledge sharing**: Because code reviews often lead to discussions between
    the developers, they are a great tool to spread knowledge about best practices
    in the team. Of course, junior developers especially will massively benefit from
    the mentoring, but also the most seasoned developers will learn something new
    from time to time.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识分享**：由于代码审查经常导致开发者之间的讨论，因此它们是传播团队中最佳实践知识的一个很好的工具。当然，初级开发者尤其是会从指导中受益匪浅，但即使是经验丰富的开发者有时也会学到新东西。'
- en: '**Constant improvement**: The regular discussions will result in improved coding
    guidelines, as they are constantly challenged and updated, if necessary.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续改进**：定期的讨论将导致编码指南的改进，因为它们会不断受到挑战和更新，如果需要的话。'
- en: '**Avoid problems early**: Code reviews take place very early in the process
    (see [*Chapter 11*](B19050_11.xhtml#_idTextAnchor145), *Continuous Integration*),
    so chances are good that bugs, security issues, or architectural problems are
    found before they even reach the test environment.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽早避免问题**：代码审查在流程的早期阶段进行（参见[*第11章*](B19050_11.xhtml#_idTextAnchor145)，*持续集成*），因此很可能会在代码甚至达到测试环境之前就发现错误、安全问题或架构问题。'
- en: If you are not yet convinced of the benefits of code reviews, check out the
    next section, in which we will talk more about what code reviews should cover
    – and what not.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有确信代码审查的好处，请查看下一节，我们将更详细地讨论代码审查应涵盖的内容——以及不应涵盖的内容。
- en: What code reviews should cover
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查应涵盖哪些内容
- en: What aspects should we check when doing code reviews?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行代码审查时，我们应该检查哪些方面？
- en: '**Code design**: Is the code well designed and consistent with the rest of
    the application? Does it follow general best practices, such as reusability, design
    patterns (see the next section), or **SOLID** design principles (see [*Chapter
    2*](B19050_02.xhtml#_idTextAnchor021)*, Who Gets to Decide What "Good Practices"
    Are?*)?'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码设计**：代码是否设计良好且与应用程序的其他部分保持一致？它是否遵循通用的最佳实践，例如可重用性、设计模式（参见下一节）或**SOLID**设计原则（参见[*第2章*](B19050_02.xhtml#_idTextAnchor021)*，谁有权决定“良好实践”是什么？）？'
- en: '**Functionality**: Does the code do what it should or does it have any side
    effects?'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：代码是否执行了它应该执行的操作，或者是否有任何副作用？'
- en: '**Readability**: Is the code easy to understand or too complex? Are the comments
    necessary? Could the readability be improved by renaming a function or a variable,
    or by extracting code into a function with a meaningful name?'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：代码是否易于理解，还是过于复杂？注释是否必要？通过重命名函数或变量，或者将代码提取到具有有意义名称的函数中，是否可以提高可读性？'
- en: '**Security**: Does the code introduce potential attack vectors? Is all output
    escaped to prevent XSS attacks? Are database inputs sanitized to avoid SQL injections?'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：代码是否引入了潜在的攻击向量？所有输出是否都已转义以防止XSS攻击？数据库输入是否已清理以避免SQL注入？'
- en: '**Test coverage**: Is the new code covered with automated tests? Do they test
    the right things? Are more test cases needed?'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试覆盖率**：新代码是否被自动化测试覆盖？它们是否测试了正确的事情？是否需要更多的测试用例？'
- en: '**Coding standards and guidelines**: Does the code follow the *Coding Standards*
    and coding guidelines the team agreed upon?'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码标准和指南**：代码是否遵循团队商定的*编码标准*和编码指南？'
- en: Your team should also consider whether testing the code in their local development
    environment should be part of the review process or not. There is no clear recommendation
    on this though.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队还应考虑是否应该在本地开发环境中测试代码是否是审查过程的一部分。然而，对此并没有明确的建议。
- en: Best practices for code reviews
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查的最佳实践
- en: Although code reviews have many benefits and can be implemented fairly easily,
    there are a few pitfalls that you should be aware of, and established best practices
    that will make the reviews even more successful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码审查有许多好处并且可以相当容易地实施，但还有一些陷阱你应该注意，以及一些使审查更加成功的既定最佳实践。
- en: Who should review the code?
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谁应该审查代码？
- en: First and foremost, who should ideally be doing the *code reviews*? Of course,
    this also depends on your setup. If you work in a team together with another PHP
    developer, then this should surely be the first person to ask. This way, you build
    up shared domain knowledge; although your colleague has not worked on your ticket
    directly, they at least get an idea of what you have worked on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，谁应该理想地做 *代码审查*？当然，这也取决于你的设置。如果你与另一位PHP开发者一起工作，那么这个人应该是第一个被询问的人。这样，你可以建立起共享的领域知识；尽管你的同事没有直接处理你的工单，但他们至少能了解你做了什么。
- en: Yet, reaching out to members of other teams (if there are any) from time to
    time avoids being stuck in a bubble and fosters knowledge sharing. If you are
    unsure about certain topics, ask the domain experts for their assistance. Often,
    this includes performance, architecture, or security-related changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时不时地联系其他团队（如果有）的成员可以避免陷入孤立，并促进知识共享。如果你对某些主题不确定，可以向领域专家寻求帮助。这通常包括性能、架构或安全相关的更改。
- en: Automatize
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化
- en: One thing that code reviews should not cover is whether the *Coding Standards*
    are kept. In [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*,Code Quality Tools*
    we introduced the necessary tools to do this automatically, and in [*Chapter 11*](B19050_11.xhtml#_idTextAnchor145),
    *Continuous Integration*, we integrated them into a **CI pipeline**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查不应该涵盖的是是否遵守了 *编码标准*。在[*第7章*](B19050_07.xhtml#_idTextAnchor084)*，代码质量工具*中，我们介绍了自动执行此操作的必要工具，而在[*第11章*](B19050_11.xhtml#_idTextAnchor145)*，持续集成*中，我们将它们集成到了**持续集成管道**中。
- en: Make sure that only those pull requests get reviewed where all the checks (such
    as *code sniffers, code analyzers, and automated tests*) have passed. Otherwise,
    you will spend a lot of time on topics that should not even be discussed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保只有那些所有检查（例如 *代码嗅探器、代码分析器和自动化测试*）都通过了的拉取请求才被审查。否则，你将花费大量时间在甚至不应该讨论的话题上。
- en: Avoid long code reviews
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免长时间的代码审查
- en: How many lines should the code change that needs to be reviewed have? Studies
    suggest that 200 to 400 lines should be the maximum, as the concentration of the
    reviewer decreases over time. So, try to keep the individual changes relatively
    small. It is also much more likely for the reviewer to find time to review smaller
    changes, as for a long tapestry of diffs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要审查的代码更改应该有多少行？研究表明，200到400行应该是最大值，因为随着时间的推移，审查者的注意力会逐渐下降。因此，尽量保持单个更改相对较小。对于长串的差异，审查者找到时间审查较小的更改的可能性也更大。
- en: Code reviews, even smaller ones, will require time in which the reviewer will
    not be able to write code. But how much time should be spent? Again, this depends
    on your setup. A good ballpark number is a maximum of 60 minutes to avoid the
    fatigue of the reviewer. Allow enough space for the reviewer to review the code
    line by line. Reviews should be accepted as part of your daily work or they will
    quickly become a burden, so nobody should rush through them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查，即使是较小的，也会占用审查者无法编写代码的时间。但应该花多少时间？同样，这取决于你的设置。一个合理的估计是，最多60分钟，以避免审查者的疲劳。为审查者提供足够的空间逐行审查代码。审查应该被视为你日常工作的一部分，否则它们会迅速变成负担，所以没有人应该匆忙完成它们。
- en: Stay human
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持人性
- en: How to formulate feedback is crucial to make reviews successful. Watch your
    tone and try to avoid accusations such as “*This is wrong*!” or an absolute no-go,
    “*This is stupid*.” Developers, especially the lesser experienced ones, should
    not be anxious to let their code be reviewed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如何制定反馈对于使审查成功至关重要。注意你的语气，并尽量避免像“*这是错的*！”或绝对不行的“*这是愚蠢的*。”这样的指责。开发者，尤其是经验较少的开发者，不应该急于让他们的代码被审查。
- en: Remember that a human being will read your comments. It often works well if
    you write them from the “I” perspective, for example, “*I do not understand this
    line, can you please explain?*” or “*I think we could also do it like this..."*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，有人会阅读你的评论。如果你从“我”的角度来写，通常效果很好，例如，“*我不理解这一行，你能解释一下吗？*”或“*我认为我们也可以这样做...”*
- en: Do not forget to use the reviews to give praise for parts that are well done.
    A quick “*Great idea!*” or “*I really like your approach*” or “*Thanks for the
    code cleanup*” shows your appreciation of the other developer’s work and increases
    their motivation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记利用审查来表扬做得好的部分。一个快速的“*好主意！*”或“*我真的很喜欢你的方法*”或“*感谢代码清理*”表明你对其他开发者工作的赞赏，并增加了他们的动力。
- en: Usually, code reviews are done by writing comments on the Git platform you use.
    But of course, you can also do them face to face. Some developers appreciate direct
    feedback more than just comments because written text lacks a lot of meta information,
    such as the tone of voice or the facial expression.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码审查是通过在您使用的 Git 平台上写评论来完成的。但当然，你也可以面对面地进行。一些开发者更欣赏直接的反馈，而不是仅仅的评论，因为书面文本缺乏很多元信息，如语气或面部表情。
- en: Don’t overdo it, but don’t be careless either
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要过度，但也不要粗心大意
- en: Remember the **Pareto principle** and do not overdo things. Maybe there are
    still small parts in the code that you would change but that are not explicitly
    wrong, as they adhere to all the team standards. Programming is still a matter
    of personal style, and having endless discussions in a code review will lead to
    frustration without further benefit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住**帕累托原则**，不要过度行事。也许代码中还有一些小部分你可能想要更改，但它们并不是明显错误的，因为它们遵循了所有团队标准。编程仍然是一个个人风格的问题，在代码审查中无休止的讨论将导致挫败感而没有任何进一步的好处。
- en: Do not accept changes that degrade the overall system health though. If you
    are convinced that a change is harmful or violates the coding guidelines, you
    must not approve the changes. If in doubt, get another developer involved.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要接受会降低整体系统健康度的更改。如果你确信某个更改是有害的或违反了编码指南，你必须不批准这些更改。如果有疑问，请让另一位开发者参与。
- en: Embrace changes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拥抱变化
- en: Lastly, if you feel an issue that you discussed in a review should be part of
    the guidelines, note it down and address it in the next team meeting, without
    mentioning the other developer directly. Maybe you were right and the guidelines
    will be amended to avoid the issue in the future.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你觉得在审查中讨论的问题应该包含在指南中，记下来并在下次团队会议上提出，不要直接提及其他开发者。也许你是对的，指南将会被修改以避免未来出现类似问题。
- en: But you could also be wrong, and the rest of the team does not see it as a problem.
    If you cannot come up with convincing arguments and examples, you have to accept
    those decisions as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也有可能错了，而团队的其他成员并不认为这是一个问题。如果你无法提出令人信服的论据和例子，你必须接受这些决定。
- en: Ensuring code reviews are done
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保代码审查得到执行
- en: 'During stressful daily work, with high-priority bug fixes and tight deadlines,
    it is easy to forget about doing code reviews. Fortunately, all the Git service
    providers offer functionality to assist you here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧张的工作日中，面对高优先级的错误修复和紧迫的截止日期，很容易忘记进行代码审查。幸运的是，所有 Git 服务提供商都提供了一些功能来帮助你：
- en: '`main` branch if they got at least one approval. You should definitely enable
    this feature.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们至少获得了一个批准，则启用`main`分支。你绝对应该启用此功能。
- en: '**Rotate reviews**: If your team is larger, try to request the review not always
    from the same person. Some tools even allow selecting a reviewer randomly for
    you.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮换审查**：如果你的团队规模较大，尝试不要总是从同一个人那里请求审查。一些工具甚至允许随机为你选择审查者。'
- en: '**Use a checklist**: Checklists have proven to be useful, so you should use
    them too. Set up a checklist for all the aspects you need to look for in code
    reviews. In the next section, we will show you how to make sure it gets used.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用检查清单**：检查清单已被证明是有用的，因此你也应该使用它们。为代码审查中需要检查的所有方面设置一个检查清单。在下一节中，我们将展示如何确保它得到使用。'
- en: Definition of done
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成定义
- en: If you work using **agile methodologies**, you probably heard the term *definition
    of done* already. Here, the team agrees on a list of actions that should be done
    before a task is completed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用**敏捷方法**工作，你可能已经听说过**完成定义**这个术语。在这里，团队同意在任务完成前应该执行的一系列行动。
- en: A typical *definition of done* contains checks such as whether the test has
    been written or the documentation updated. You can utilize this for the code reviews
    as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的**完成定义**包含检查，例如是否编写了测试或更新了文档。你可以利用这一点来进行代码审查。
- en: Again, our Git tools help us by providing templates for pull requests (also
    called **merge requests**). These are texts that will be used to automatically
    prefill the description of the pull request.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的 Git 工具通过提供拉取请求（也称为**合并请求**）模板来帮助我们。这些文本将被用来自动预填充拉取请求的描述。
- en: 'How that works depends on the software you use, so we cannot give you exact
    instructions here. The following text, however, shows you an example of what it
    could look like:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这具体如何操作取决于你使用的软件，所以我们在这里无法提供确切的操作指南。然而，以下文本展示了它可能的样子：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What gets included in the checklist is up to you and your team. If used as a
    template, these items will always appear in the pull request description by default.
    It is meant to be used by both the reviewer and the developer to not forget what
    needs to be done before approving the pull request and merging it into the `main`
    branch.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 检查清单中包含的内容由你和你的团队决定。如果用作模板，这些项目将默认出现在拉取请求描述中。它的目的是供审阅者和开发者使用，以便在批准拉取请求并将其合并到`main`分支之前不会忘记需要完成的事情。
- en: Some tools, such as GitHub, use a **Markdown**-style markup language for these
    templates. They will display the checkboxes (the two square brackets before every
    item) as clickable checkboxes in the browser and keep track of whether they were
    clicked or not. Voilà! Without much work, you have set up an easy-to-use and helpful
    checklist!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具，如GitHub，使用**Markdown**风格的标记语言来处理这些模板。它们将在浏览器中将复选框（每个项目前的两个方括号）显示为可点击的复选框，并跟踪它们是否被点击。哇！无需太多工作，你就已经设置了一个易于使用且有用的检查清单！
- en: Code reviews conclusion
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查总结
- en: We hope this section gave you good insights into how beneficial code reviews
    can be for your team and yourself. Since they can be introduced effortlessly,
    it is worth trying them out. The best practices in this section will help you
    avoid some of the problems that code reviews could have.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一节能让你对代码审查如何对你的团队和你自己有益有更深的理解。由于它们可以轻松引入，所以值得一试。本节中的最佳实践将帮助你避免代码审查可能带来的某些问题。
- en: 'But, as always, they also have some downsides: reviews take a lot of time and
    they can lead to conflicts between team members. We are convinced that the time
    spent pays off well though because the positive aspects outweigh the negative
    ones by far. The conflicts would most likely happen anyway, and the reviews are
    just the gauge to vent off steam. This cannot be fully avoided if you work in
    a team but should be addressed early with your manager. It is their job to deal
    with these kinds of problems.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，就像往常一样，它们也有一些缺点：审查需要花费大量时间，并且可能导致团队成员之间的冲突。我们坚信，所花费的时间是值得的，因为积极方面远远超过了消极方面。冲突很可能会发生，而审查只是释放压力的一种方式。如果你在团队中工作，这无法完全避免，但应该尽早与你的经理讨论。这是他们的工作，处理这类问题。
- en: In the last part of this chapter, we will look at design patterns in more detail.
    They can act as guidelines on how to solve general problems in software development.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将更详细地探讨设计模式。它们可以作为解决软件开发中一般问题的指南。
- en: Design patterns
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: '**Design patterns** are commonly used solutions to problems that occur regularly
    in software development. As a developer, you will sooner or later come across
    this term, if you have not done so already – and not without a reason, as these
    patterns are based on best practices and have proven their usefulness.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**是软件开发中经常出现的问题的常用解决方案。作为一名开发者，你迟早会遇到这个术语，即使你之前还没有——这并非没有原因，因为这些模式基于最佳实践，并且已经证明了它们的实用性。'
- en: In this section, we will tell you more about the different types of design patterns
    and why they are so important that they became part of this book. Furthermore,
    we will introduce you to some common design patterns that are widely used in PHP.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将告诉你更多关于不同类型的设计模式以及为什么它们如此重要，以至于成为本书的一部分。此外，我们还将介绍一些在PHP中广泛使用的常见设计模式。
- en: Understanding design patterns
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: Let us have a closer look at design patterns now. They can be considered templates
    to solve particular problems and are named according to the solution they provide.
    For example, in this chapter, you will learn about the **Observer** pattern, which
    can help you to implement a way to observe changes in objects. This is very useful
    when you write code, but also when you design software with other developers.
    It is much easier to use a short name to name a concept rather than having to
    explain it every time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解设计模式。它们可以被视为解决特定问题的模板，并且根据它们提供的解决方案命名。例如，在本章中，你将了解**观察者模式**，这可以帮助你实现观察对象变化的方式。这在编写代码时非常有用，同样在与其他开发者设计软件时也很方便。使用简短的名字来命名一个概念，而不是每次都要解释它，要容易得多。
- en: Do not mistake design patterns with algorithms though. Algorithms define clear
    steps that need to be followed to solve a problem, while design patterns describe
    how to implement the solution on a higher level. They are not bound to any programming
    language.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，不要将设计模式与算法混淆。算法定义了需要遵循的明确步骤来解决一个问题，而设计模式描述了如何在更高层次上实现解决方案。它们不受任何编程语言的限制。
- en: You also cannot add design patterns to your code like you would add a Composer
    package, for example. You have to implement the pattern on your own, and you have
    certain degrees of freedom in how you do that.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能像添加Composer包那样将设计模式添加到你的代码中。你必须自己实现模式，并且你在实现方式上有一定的自由度。
- en: 'However, design patterns are not the single solution to every problem, nor
    do they claim to offer the most efficient solutions. Always take these patterns
    with a grain of salt – often, developers want to implement a certain pattern just
    because they know it. Or, as the saying goes: "*If all you have is a hammer, everything
    looks like a nail."*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设计模式并非解决所有问题的唯一方案，它们也不声称提供最有效的解决方案。始终对这些模式持保留态度——通常，开发者只是因为知道某个模式而想要实现它。或者，正如俗话所说：“*如果你只有一把锤子，那么一切看起来都像钉子。”*
- en: 'Usually, design patterns are divided into three categories:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计模式被分为三个类别：
- en: '**Creational patterns** deal with how to efficiently create objects and at
    the same time offer solutions to reduce code duplication'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**处理如何高效地创建对象，同时提供减少代码重复的解决方案'
- en: '**Structural patterns** help you organize relationships between entities (i.e.,
    classes and objects) in flexible and efficient structures'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型模式**帮助你在灵活且高效的结构中组织实体（即类和对象）之间的关系'
- en: '**Behavioral patterns** arrange communication between entities while maintaining
    a high degree of flexibility'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为型模式**在保持高灵活性度的同时安排实体之间的通信'
- en: In the following pages, we will have a look at some example implementations
    to explain the idea behind *design patterns*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我们将查看一些示例实现来解释*设计模式*背后的理念。
- en: Common design patterns in PHP
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的常见设计模式
- en: We now want to introduce some of the most widely used design patterns in the
    PHP world. We chose one pattern each from the three categories **Creational**,
    **Structural**,and **Behavioral**, which we discussed in the previous section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想介绍PHP世界中一些最广泛使用的模式。我们从三个类别**创建型**、**结构型**和**行为型**中各选择了一个模式，这些模式我们在上一节中讨论过。
- en: Factory Method
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂方法
- en: 'Imagine the following problem: you need to write an application that should
    be able to write data into files using different formats. In our example, we want
    to support **CSV** and **JSON**, but potentially, other formats in the future
    as well. Before the data is written, we would like to apply some filtering, which
    should always happen, regardless of which output format is chosen.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下问题：你需要编写一个应用程序，该应用程序应该能够使用不同的格式将数据写入文件。在我们的例子中，我们希望支持**CSV**和**JSON**，但未来也可能支持其他格式。在数据写入之前，我们希望应用一些过滤，这应该始终发生，无论选择哪种输出格式。
- en: An applicable pattern to solve this problem would be the **Factory Method**.
    It is a Creational pattern, as it deals with the creation of objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的适用模式将是**工厂方法**。它是一个创建型模式，因为它涉及对象的创建。
- en: 'The main idea of this pattern is that subclasses can implement different ways
    to achieve the goal. It is important to note that we do not use the `new` operator
    in the parent class to instantiate any subclasses, as you can see in the following
    class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的主要思想是子类可以实现不同的方式来实现目标。需要注意的是，我们在父类中没有使用`new`运算符来实例化任何子类，如下面的类所示：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `createEncoder` method – this is the factory method that gave the pattern
    the name, since it acts, in a sense, as a factory for new instances. It is defined
    as an abstract function, so it needs to be implemented by one or more subclasses.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`createEncoder`方法——这是赋予模式名称的工厂方法，因为它在某种程度上充当了新实例的工厂。它被定义为抽象函数，因此需要由一个或多个子类实现。
- en: 'To be flexible enough for future formats, we intend to use separate `Encoder`
    classes for each format. But first, we define an interface for these classes so
    that they are easily exchangeable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了足够灵活以适应未来的格式，我们打算为每种格式使用单独的`Encoder`类。但首先，我们为这些类定义一个接口，以便它们可以轻松交换：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we create an `Encoder` class for each format that implements the `Encoder`
    interface; first, we create `JsonEncoder`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每种格式创建一个实现`Encoder`接口的`Encoder`类；首先，我们创建`JsonEncoder`：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we create `CsvEncoder`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建 `CsvEncoder`：
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to create one subclass of the `AbstractWriter` class for each
    format we want to support. In our case, that is `CsvWriter` first:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为每个我们想要支持的格式创建一个 `AbstractWriter` 类的子类。在我们的例子中，首先是 `CsvWriter`：
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And second, it is `JsonWriter`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其次是 `JsonWriter`：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please note that both subclasses only overwrite the Factory Method `createEncoder`.
    Also, the `new` operators occur only in the subclasses. The `write` method remains
    unchanged, as it gets inherited from `AbstractWriter`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个子类只重写了工厂方法 `createEncoder`。`new` 操作符只出现在子类中。`write` 方法保持不变，因为它是从 `AbstractWriter`
    继承而来的。
- en: 'Finally, let us put this all together in an example script:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将这些内容组合到一个示例脚本中：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `factoryMethodExample` function first receives `CsvWriter` and, for the
    second run, `JsonWriter` as parameters. The output will look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`factoryMethodExample` 函数首先接收 `CsvWriter` 参数，在第二次运行时接收 `JsonWriter` 参数。输出将如下所示：'
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Factory Method pattern enables us to move the instantiation of the `Encoder`
    class away from the `AbstractWriter` parent class into the subclasses. By doing
    this, we avoid tight coupling between `Writer` and `Encoder`, gaining much more
    flexibility. As a downside, the code becomes more complex, as we have to introduce
    interfaces and subclasses to implement this pattern.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式使我们能够将 `Encoder` 类的实例化从 `AbstractWriter` 父类移动到子类中。通过这样做，我们避免了 `Writer`
    和 `Encoder` 之间的紧密耦合，获得了更大的灵活性。作为缺点，代码变得更加复杂，因为我们必须引入接口和子类来实现这个模式。
- en: Dependency injection
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The next pattern we want to introduce is a Structural pattern called **Dependency
    Injection** (**DI**). It helps us to implement a loosely coupled architecture
    by inserting dependencies into classes already at construction time, instead of
    instantiating them inside the class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍的模式是一个名为 **依赖注入**（**DI**）的结构模式。它通过在构造时将依赖项插入到类中，而不是在类内部实例化它们，帮助我们实现松散耦合的架构。
- en: 'The following code shows you how a dependency, in this example, a classic **Logger**,
    gets instantiated within the constructor:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在构造函数中实例化一个依赖项，在这个例子中是一个经典的 **Logger**：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code itself works perfectly fine, yet the problems start when you want to
    replace `FileLogger` with a different class. Although we already use the `Logger`
    interface for the `$logger` property, which theoretically makes it easy to exchange
    it with another implementation, we have hardcoded `FileLogger` in the constructor.
    Now, imagine you used that logger in almost every class; replacing it with a different
    `Logger` implementation causes some effort, as you would have to touch every single
    file that uses it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身运行得很好，但问题出现在你想要用不同的类替换 `FileLogger` 时。尽管我们已经在 `$logger` 属性中使用了 `Logger`
    接口，理论上这使得它容易与另一个实现交换，但我们已经在构造函数中硬编码了 `FileLogger`。现在，想象一下你几乎在每一个类中都使用了那个日志记录器；用不同的
    `Logger` 实现替换它需要一些努力，因为你必须触及使用它的每一个文件。
- en: Not being able to replace `FileLogger` also makes writing **unit tests** for
    the class more difficult. You cannot replace it with a mock, but you also do not
    want to write information to your actual logs during test runs. If you want to
    test that the logging works correctly, you have to build quite some workarounds
    into your code that is also used in production.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 无法替换 `FileLogger` 也使得为该类编写 **单元测试** 更加困难。你不能用模拟对象替换它，但在测试运行期间你也不想将信息写入实际的日志。如果你想测试日志是否正确工作，你必须将一些工作区间的代码构建到你的生产代码中。
- en: 'DI forces us to think about which, and how many, dependencies should be used
    in a class. It is considered a **code smell** (i.e., an indicator for badly structured
    code) when the constructor takes considerably more than three or four dependencies
    as a parameter because it indicates that the class violates the **single responsibility
    principle** (the “**S**” in **SOLID**). This is also known as **scope creep**:
    the scope of a class slowly but steadily gets bigger over time.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）迫使我们思考在类中应该使用哪些依赖项，以及使用多少。当构造函数接受的依赖项参数数量明显超过三个或四个时，这被认为是一种 **代码异味**（即，表示代码结构不良的指标），因为它表明该类违反了
    **单一职责原则**（SOLID 中的“**S**”）。这也被称为 **范围蔓延**：类的范围随着时间的推移逐渐但稳步增大。
- en: 'Let us now see how DI would solve the previously mentioned problems:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看依赖注入如何解决之前提到的问题：
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Constructor property promotion
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数属性提升
- en: Please note that we did not use constructor property promotion purposely here
    for better visualization.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里故意没有使用构造函数属性提升，以获得更好的可视化效果。
- en: 'The difference to the previous code does not seem to be that big. All we did
    was pass over the `Logger` instance as a parameter to the constructor instead
    of instantiating it there directly. The benefit is huge though: we can now change
    the instance that gets injected (if it implements the `Logger` interface) without
    touching the actual class.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码相比，差异似乎并不大。我们只是将`Logger`实例作为参数传递给构造函数，而不是直接在那里实例化。然而，好处是巨大的：我们现在可以更改要注入的实例（如果它实现了`Logger`接口），而无需触及实际类。
- en: Imagine you no longer want the class to log into the filesystem, but rather
    into a `GraylogLogger`, which implements the `Logger` interface as well but writes
    the logs to this system instead of into files. Then, you simply inject `GraylogLogger`
    instead of `FileLogger` into all classes that should use it – congratulations,
    you just changed the way your applications log information without touching the
    actual classes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不再希望类将日志记录到文件系统，而是记录到`GraylogLogger`，它也实现了`Logger`接口，但将日志写入该系统而不是写入文件。然后，你只需将`GraylogLogger`注入到所有应该使用它的类中即可——恭喜你，你刚刚改变了应用程序记录信息的方式，而无需触及实际类。
- en: Likewise, we can easily exchange a dependency with a mock object in our unit
    tests. This is a massive improvement regarding testability.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在单元测试中轻松地用一个模拟对象替换依赖。这在可测试性方面是一个巨大的改进。
- en: 'The instantiation of `Logger`, however, no matter which implementation you
    chose, still has to happen somewhere else. We just moved it out of the `InjectionExample`
    class. The dependency gets injected when the class gets instantiated:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论你选择哪种实现方式，`Logger`的实例化仍然需要在其他地方发生。我们只是将其从`InjectionExample`类中移出。依赖注入发生在类实例化时：
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Usually, you would find this kind of instantiation within a `Factory` class.
    This is a class that implements, for example, the **Simple Factory** pattern and
    whose only job is to create instances of a certain class, with all the necessary
    dependencies.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在`Factory`类中找到这种类型的实例化。这是一个实现例如**简单工厂**模式的类，其唯一任务是创建特定类的实例，并带有所有必要的依赖项。
- en: Simple Factory pattern
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 简单工厂模式
- en: 'We do not discuss this pattern in more detail in this book because it is, well,
    really simple. You can find more information about it here: [https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html](https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中不会更详细地讨论这个模式，因为它真的很简单。你可以在这里找到更多关于它的信息：[https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html](https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html)。
- en: 'The injection does not necessarily need to happen through the constructor.
    Another possible approach is the so-called **setter injection**:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注入不一定要通过构造函数进行。另一种可能的方法是所谓的**setter注入**：
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The injection of the dependency would then happen using the `setLogger` method.
    The same as for the `Factory` class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入将通过`setLogger`方法进行。与`Factory`类相同。
- en: 'The following is an example of what such a **factory** could look like:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个这样的**工厂**可能的样子：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Dependency injection container
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖注入容器
- en: You probably already wondered how to manage all the factories that are necessary,
    especially in a larger project. For this, the **DI container** has been invented.
    It is not part of the DI pattern, yet closely related, so we want to introduce
    it here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经想知道如何管理所有必要的工厂，尤其是在一个较大的项目中。为此，发明了**DI容器**。它不是DI模式的一部分，但与之密切相关，因此我们在这里介绍它。
- en: The DI container acts as central storage for all objects that are brought into
    their target classes using DI patterns. It also contains all the necessary information
    to instantiate the objects.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器充当所有通过DI模式引入其目标类的对象的中央存储库。它还包含实例化对象所需的所有必要信息。
- en: It also can store created instances so it does not have to instantiate them
    twice. For example, you would not create a `FileLogger` instance for each class
    that uses it, as this would end up in plenty of identical instances. You rather
    want to create it once and then pass it over by reference to its destination classes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以存储创建的实例，因此不需要重复实例化。例如，你不会为每个使用它的类创建一个`FileLogger`实例，因为这会导致大量相同的实例。你更希望只创建一次，然后通过引用传递给目标类。
- en: DI container
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器
- en: 'Showing all the functionality of a modern DI container would exceed this book.
    If you are interested in learning more about this concept, we recommend you to
    check out the `phpleague/container` package: [https://container.thephpleague.com](https://container.thephpleague.com).
    It is small yet feature-rich and has great documentation that can introduce you
    to more exciting concepts such as service providers or inflectors.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 展示现代DI容器所有功能会超出本书的范围。如果你对了解这个概念感兴趣，我们建议你查看`phpleague/container`包：[https://container.thephpleague.com](https://container.thephpleague.com)。它体积小但功能丰富，拥有优秀的文档，可以介绍你更多令人兴奋的概念，如服务提供者或屈折词。
- en: The concept of the DI container has been adopted in all major PHP frameworks
    nowadays, so you have most likely used such a container already. You probably
    did not notice it though, because it is usually hidden deep in the back of your
    application and is sometimes also referred to as a **service container**.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现今，DI（依赖注入）容器的概念已被所有主要的PHP框架所采用，因此你很可能已经使用过这样的容器了。你可能没有注意到它，因为通常它隐藏在你的应用程序的深处，有时也被称为**服务容器**。
- en: PSR-11 – Container interface
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-11 – 容器接口
- en: 'The DI container is so important to the PHP ecosystem that it got its own PSR:
    [https://www.php-fig.org/psr/psr-11](https://www.php-fig.org/psr/psr-11).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器对PHP生态系统来说非常重要，以至于它拥有自己的PSR：[https://www.php-fig.org/psr/psr-11](https://www.php-fig.org/psr/psr-11)。
- en: Observer
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者
- en: The last pattern we want to introduce in this book is the **Observer** pattern.
    As a *Behavioral pattern*, its main purpose is to allow efficient communication
    between objects. A common task to implement is to trigger a certain action on
    one object when the state of another object changes. A state change could be something
    as simple as a value change of a class property.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本书要介绍的最后一个模式是**观察者模式**。作为一种**行为模式**，其主要目的是允许对象之间进行高效的通信。一个常见的实现任务是，当一个对象的状态发生变化时，在另一个对象上触发某个动作。状态变化可能只是类属性值的改变这么简单。
- en: 'Let us start with another example: you have to send out an email to the sales
    team every time a customer cancels their subscription so that they get informed
    and can do countermeasures to keep the customer.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子：每当客户取消订阅时，你必须向销售团队发送一封电子邮件，以便他们得到通知并采取措施留住客户。
- en: How do you best do that? You could, for example, set up a recurring job that
    checks within a certain time interval (e.g., every 5 minutes) whether there had
    been any cancellations since the check. This would work, but depending on the
    size of your customer base, the job would probably not return any results most
    of the time. If the interval between two checks, on the other hand, is too long,
    you might lose valuable time until the next check.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好怎么做？例如，你可以设置一个定期任务，在特定的时间间隔内（例如，每5分钟）检查是否有任何取消操作。这会起作用，但根据你的客户群规模，这个任务可能大部分时间都不会返回任何结果。另一方面，如果两次检查之间的间隔太长，你可能会错过宝贵的时间直到下一次检查。
- en: Now, sales might not be the most time-critical thing in the world (salespeople
    usually disagree here), but you surely get the idea. Wouldn’t it be great if we
    could just send out the email as soon as the customer cancels the subscription?
    So, instead of regularly checking for changes, we only get informed at the moment
    when the change happens?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，销售可能不是世界上最重要的事情（销售人员通常不同意这一点），但你应该明白了。如果我们能在客户取消订阅时立即发送电子邮件，那不是很好吗？所以，而不是定期检查变化，我们只在变化发生时得到通知？
- en: 'The code could look like this simplified example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来像这个简化的例子：
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Simplified example
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 简化示例
- en: The example has been simplified. You should, for example, not hardcode the email
    address.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子已经被简化了。例如，你不应该硬编码电子邮件地址。
- en: 'That approach would surely work, but it has a drawback: the call of `MailService`
    is directly coded into the class and hence is tightly coupled to it. And now,
    the `CustomerAccount` class has to care about another dependency, which increases
    the maintenance effort, as the tests have to be extended, for example. If we later
    do not want to send this email anymore or even send an additional email to another
    department, `CustomerAccount` has to be changed again.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法当然会起作用，但它有一个缺点：`MailService`的调用被直接编码到类中，因此与它紧密耦合。现在，`CustomerAccount`类必须关心另一个依赖项，这增加了维护工作量，例如，测试必须扩展。如果我们以后不想再发送这封电子邮件，甚至要发送给其他部门的额外电子邮件，`CustomerAccount`类又必须再次更改。
- en: Using a loosely coupled approach, the `CustomerAccount` object would only store
    a list of other objects that it should notify in case of a change. The list is
    not hardcoded, and the objects that need to get notified have to be attached to
    that list during the bootstrap phase.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用松耦合的方法，`CustomerAccount`对象将只存储一个列表，该列表包含在发生更改时应通知的其他对象。这个列表不是硬编码的，需要得到通知的对象必须在引导阶段附加到该列表。
- en: The object that we want to be observed (in the preceding example, `CustomerAccount`),
    is called the **subject**. The subject is responsible for informing the **observers**.
    No code change would be necessary on the subject to add or remove observers, so
    this approach is very flexible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要观察的对象（在前面的例子中是`CustomerAccount`），被称为**主题**。主题负责通知**观察者**。在主题上添加或删除观察者不需要任何代码更改，所以这种方法非常灵活。
- en: 'The following code shows an example of how the `CustomerAccount` class could
    implement the **Observer** pattern:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`CustomerAccount`类如何实现**观察者**模式的示例：
- en: '[PRE25]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A lot has happened here, so let us go through it bit by bit. The first thing
    notable is that the class makes use of the `SplSubject` and `SplObserver` interfaces,
    as well as the `SplObjectStorage` class. Since the `CustomerAccount` class implements
    the `SplSubject` interface, it has to provide the `attach`, `detach`, and `notify`
    methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里发生了很多事情，所以让我们一点一点地过一遍。首先值得注意的是，这个班级使用了`SplSubject`和`SplObserver`接口，以及`SplObjectStorage`类。由于`CustomerAccount`类实现了`SplSubject`接口，它必须提供`attach`、`detach`和`notify`方法。
- en: We also use the constructor to initialize the `$observers` property as `SplObjectStorage`,
    which will store all observers of the `CustomerAccount` class. Luckily, the SPL
    provides the implementation of this storage already, so we do not need to do it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用构造函数来初始化`$observers`属性为`SplObjectStorage`，这将存储`CustomerAccount`类的所有观察者。幸运的是，SPL已经提供了这个存储的实现，所以我们不需要自己来做。
- en: Standard PHP Library
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 标准PHP库
- en: We talked about the **Standard PHP L****ibrary** (**SPL**) in [*Chapter 3*](B19050_03.xhtml#_idTextAnchor031)*,
    Code Quality Metrics* already. The fact that the SPL includes these entities shows
    the importance of the Observer pattern as well as the usefulness of this library.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第三章*](B19050_03.xhtml#_idTextAnchor031)*，代码质量指标*中已经讨论了**标准PHP库**（**SPL**）。SPL包括这些实体表明了观察者模式的重要性以及这个库的有用性。
- en: The `attach` and `detach` methods are required by the `SplSubject` interface.
    They are used for adding or removing observers. Their implementation is easy –
    we just need to forward the `SplObserver` object to `SplObjectStorage` in both
    cases, which takes over the necessary work for us.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`和`detach`方法是由`SplSubject`接口要求的。它们用于添加或删除观察者。它们的实现很简单——我们只需要在两种情况下将`SplObserver`对象转发到`SplObjectStorage`，它就会为我们完成必要的工作。'
- en: The `notify` method has to call the `update` method on all `SplObserver` objects
    that are stored in `SplObjectStorage`. This is as simple as using a `foreach`
    loop to iterate over all `SplObserver` entries and call their `update` method,
    passing over a reference to the subject using `$this`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`方法必须调用存储在`SplObjectStorage`中的所有`SplObserver`对象的`update`方法。这就像使用`foreach`循环遍历所有`SplObserver`条目并调用它们的`update`方法，传递一个引用到主题使用`$this`。'
- en: 'The following code shows what such an observer could look like:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了这样一个观察者可能的样子：
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The observer, not surprisingly, implements the `SplObserver` interface. The
    only required method is `update`, which gets called from the subject in the `notify`
    method. Since the interface requires the `$splSubject` parameter to implement
    the `SplSubject` interface, we have to use that parameter type hint. It would
    lead to a PHP error otherwise.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，观察者实现了`SplObserver`接口。唯一需要的方法是`update`，它会在`notify`方法中被主题调用。由于接口要求使用`$splSubject`参数来实现`SplSubject`接口，我们必须使用该参数类型提示。否则会导致PHP错误。
- en: Since we know that, in this case, the object is actually a `CustomerAccount`
    object, we can add this type hint as well. This will enable our IDE to help us
    with the proper code completion; it is not required to add it though.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道在这种情况下，对象实际上是一个`CustomerAccount`对象，我们还可以添加这个类型提示。这将使我们的IDE能够帮助我们完成正确的代码补全；尽管如此，添加它并不是必需的。
- en: As you can see, all the logic regarding the email sending has now moved into
    `CustomerAccountObserver`. In other words, we successfully eliminated the tight
    coupling between `CustomerAccount` and `MailService`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在所有关于发送电子邮件的逻辑都已经移动到了`CustomerAccountObserver`中。换句话说，我们成功地消除了`CustomerAccount`和`MailService`之间的紧密耦合。
- en: 'The last thing we need to do is to attach `CustomerAccountObserver`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是附加`CustomerAccountObserver`：
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, this code example is simplified. In a real-world application, all three
    objects would be instantiated in dedicated factories and brought together by a
    DI container.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个代码示例被简化了。在实际应用中，所有三个对象都会在专门的工厂中实例化，并通过DI容器组合在一起。
- en: The Observer pattern helps you to decouple objects with a relatively low amount
    of work. It has a few drawbacks though. The order in which the observers are updated
    cannot be controlled; thus, you cannot use it to implement functionality where
    the order is crucial. Second, by decoupling the classes, it is no longer obvious
    just by looking at the code which observers are attached to it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可以帮助你通过相对较少的工作量解耦对象。尽管如此，它也有一些缺点。观察者更新的顺序无法控制；因此，你不能用它来实现顺序至关重要的功能。其次，通过解耦类，仅通过查看代码就不再明显知道哪些观察者被附加到它上。
- en: To sum up the topic of *design patterns*, we will have a look at those patterns
    that are still quite common today but have proven to have too significant drawbacks
    to be recommended. Curtain up for the Anti-patterns!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下设计模式的话题，我们将看看那些至今仍然相当常见但已经证明有太多显著缺点而不被推荐的模式。帷幕拉开，反模式登场！
- en: Anti-patterns
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反模式
- en: Not every *design pattern* stood the test of time. Everything evolves, and so
    do software development and PHP. Some patterns that have been successful in the
    past have been replaced by newer and/or better versions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个设计模式都经得起时间的考验。一切都在发展，软件开发和PHP也是如此。一些在过去取得成功的模式已经被更新和/或更好的版本所取代。
- en: What was once the standard approach to solving a problem a couple of years ago
    might not be the right solution anymore. The PHP community keeps learning and
    improving, but this knowledge is not yet evenly distributed. Thus, to make it
    more obvious which patterns should be avoided, they are often referred to as Anti-patterns
    – this clearly sounds like something you would not like to have in your code,
    right?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前解决某个问题的标准方法可能现在已经不再是正确的解决方案了。PHP 社区一直在学习和改进，但这种知识尚未均匀分布。因此，为了更明显地指出哪些模式应该避免，它们通常被称为反模式——这显然听起来像是你不希望出现在代码中的东西，对吧？
- en: What does such an **Anti-Pattern** look like? Let us have a look at the first
    example.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的反模式是什么样的呢？让我们看看第一个例子。
- en: Singleton
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例
- en: 'Before DI became increasingly popular in the PHP world, we already had to deal
    with the problem of how to effectively create instances and how to make them available
    in the scopes of other classes. The **Singleton** pattern offered a quick and
    easy solution that usually looked something like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖注入（DI）在PHP世界中变得越来越流行之前，我们早已必须处理如何有效地创建实例以及如何使它们在其他类的范围内可用的问题。单例模式提供了一个快速且简单的解决方案，通常看起来是这样的：
- en: '[PRE28]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The static `getInstance` method is surprisingly simple:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`getInstance`方法非常简单：
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the method gets executed, it is checked whether an instance of the class
    has already been created. If yes, it will be returned; if not, it will be created
    beforehand. This approach is also called **lazy initialization**. Being lazy is
    a good thing here because it only gets initialized when it is required, so it
    saves resources.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法被执行，会检查该类的实例是否已经被创建。如果是，它将被返回；如果不是，它将事先创建。这种方法也被称为**延迟初始化**。在这里，懒惰是个好事，因为它只有在需要时才会初始化，所以节省了资源。
- en: The method furthermore stores the new instance in the static `$instance` property.
    This is remarkable as the approach is only possible because static properties
    can have a value without requiring a class instance. In other words, we can store
    the instance of a class in its own class definition. Also, in PHP, all objects
    are passed as a reference, that is, as a pointer to the object in memory. Both
    peculiarities help us to make sure that the same instance is always returned.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还将在静态的`$instance`属性中存储新的实例。这一点很引人注目，因为这种方法的实现仅因为静态属性可以在没有要求类实例的情况下具有值。换句话说，我们可以在其自己的类定义中存储类的实例。此外，在PHP中，所有对象都是通过引用传递的，即指向内存中对象的指针。这两个特性帮助我们确保总是返回相同的实例。
- en: The Singleton actually is quite elegant; as it also uses a static method, it
    needs no instance of the `Singleton` class as well. This way, it can literally
    be executed everywhere in your code, without any further preparation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式实际上相当优雅；因为它也使用静态方法，所以不需要`Singleton`类的实例。这样，它可以在你的代码的任何地方直接执行，而不需要任何进一步的准备。
- en: The ease of use is one of the main reasons why Singleton eventually became an
    Anti-Pattern, since it leads to **scope creep**. We explained this problem in
    the section about DI.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 易用性是单例最终成为反模式的主要原因之一，因为它会导致**范围蔓延**。我们在关于依赖注入的部分中解释了这个问题。
- en: 'Another problem is testability: it is very hard to replace the instance with
    a mock object, so writing unit tests for code that uses the Singleton pattern
    became much more complex.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于可测试性：用模拟对象替换实例非常困难，因此为使用单例模式的代码编写单元测试变得更加复杂。
- en: Nowadays, you should use DI together with a DI container. It is not as easy
    to use as the Singleton, but that in turn helps us to think twice before we use
    another dependency in a class.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该使用依赖注入与依赖注入容器一起使用。它不如单例模式容易使用，但反过来这又帮助我们三思而后行，在类中使用另一个依赖项之前。
- en: However, it does not mean that the Singleton pattern must not be used at all.
    There might be valid reasons to implement it, or at least to keep it in a legacy
    project. Just be aware of the risks.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着单例模式根本不能使用。可能存在有效的理由来实现它，或者至少在遗留项目中保留它。只是要意识到风险。
- en: Service locator
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务定位器
- en: 'The second pattern that could be considered problematic is **Service Locator**:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可能被认为有问题的第二个模式是**服务定位器**：
- en: '[PRE30]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example class, we inject `ServiceLocator` during the construction time
    of the object. It is then used throughout the class to fetch the required dependencies.
    In these regards, DI and the Service Locator are both implementations of the **dependency
    inversion** principle (the “**D**” in **SOLID**): they move the control about
    their dependencies out of the class scope, helping us to achieve a loosely coupled
    architecture.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例类中，我们在对象的构造时注入`ServiceLocator`。然后在整个类中使用它来获取所需的依赖项。在这方面，依赖注入和服务定位器都是**依赖倒置**原则（**SOLID**中的“**D**”）的实现：它们将控制其依赖项的范围移出类作用域，帮助我们实现松散耦合的架构。
- en: But, if we only need to inject one dependency instead of many, is that not a
    great idea? Well, the drawback of the Service Locator pattern is that it hides
    the dependencies of the class behind the `ServiceLocator` instance. While with
    DI you can clearly see which dependencies are used by looking at the constructor,
    you cannot do that when injecting only `ServiceLocator`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们只需要注入一个依赖项而不是多个，这不是一个好主意吗？嗯，服务定位器模式的缺点是它将类的依赖项隐藏在`ServiceLocator`实例后面。而使用依赖注入时，您可以通过查看构造函数清楚地看到使用了哪些依赖项，但在仅注入`ServiceLocator`时您无法做到这一点。
- en: Unlike DI, it does not force us to question which dependencies should be used
    in a class as, for larger classes, you can quickly lose the overview of which
    dependencies are used in a class. This is basically one of the main drawbacks
    we identified for the Singleton pattern.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖注入不同，它不会强迫我们质疑一个类中应该使用哪些依赖项，因为对于较大的类，您很快就会失去对类中使用了哪些依赖项的总体了解。这基本上是我们为单例模式识别出的主要缺点之一。
- en: Yet again, we do not want to be dogmatic when it comes to the use of the *Service
    Locator* pattern. There might be situations where it is appropriate to use it
    – just handle it with care.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不想在*服务定位器*模式的使用上过于教条。可能存在一些情况下使用它是合适的——只是要小心处理。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the importance of standards and guidelines. Coding
    standards help you to align with fellow developers on how the code should be formatted,
    and you learned about existing standards worth adopting.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了标准和规范的重要性。编码规范帮助您与同行开发者就代码的格式达成一致，并且您了解了值得采用的一些现有标准。
- en: Coding guidelines help your team to align on how to write software. Although
    these guidelines are highly individual for each team, we provided you with a good
    set of examples and best practices to build your team’s guidelines. With code
    reviews, you also know how to keep the quality up.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范有助于您的团队就如何编写软件达成一致。尽管这些规范对每个团队来说都非常个性化，但我们为您提供了一套良好的示例和最佳实践，以构建您团队的规范。通过代码审查，您也知道如何保持质量。
- en: Finally, we introduced you to the world of design patterns. We are confident
    that knowing at least a good part of these patterns will help you to design and
    write high-quality code together with your team members. There is much more to
    explore on this topic, and you will find links to some great sources at the end
    of this chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向您介绍了设计模式的世界。我们相信，至少了解这些模式的大部分内容将帮助您与团队成员一起设计和编写高质量的代码。关于这个主题还有更多可以探索的，您将在本章末尾找到一些优秀资源的链接。
- en: This almost ends our exciting journey through the many aspects of clean code
    in PHP. We are sure you now want to use all your new knowledge in your daily work
    as soon as possible. Yet, before you do, bear with us for the last chapter, when
    we talk about the importance of documentation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎结束了我们关于PHP中清洁代码多方面内容的激动人心的旅程。我们确信你现在迫不及待地想要尽快将所有新知识应用到日常工作中。然而，在你这样做之前，请耐心等待最后一章，我们将讨论文档的重要性。
- en: Further reading
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://google.github.io/eng-practices/review](https://google.github.io/eng-practices/review)
    provides you with more information about the *code review* process at Google'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://google.github.io/eng-practices/review](https://google.github.io/eng-practices/review)
    提供了更多关于谷歌的 *代码审查* 流程的信息'
- en: 'Useful sources about *design patterns* in PHP:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于PHP中 *设计模式* 的有用资源：
- en: '[https://refactoring.guru/design-patterns/adapter/php/example](https://refactoring.guru/design-patterns/adapter/php/example)'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://refactoring.guru/design-patterns/adapter/php/example](https://refactoring.guru/design-patterns/adapter/php/example)'
- en: '[https://sourcemaking.com/design_patterns/adapter/php](https://sourcemaking.com/design_patterns/adapter/php)'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sourcemaking.com/design_patterns/adapter/php](https://sourcemaking.com/design_patterns/adapter/php)'
- en: '[https://designpatternsphp.readthedocs.io/en/latest/README.html](https://designpatternsphp.readthedocs.io/en/latest/README.html)'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://designpatternsphp.readthedocs.io/en/latest/README.html](https://designpatternsphp.readthedocs.io/en/latest/README.html)'
