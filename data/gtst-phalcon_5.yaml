- en: Chapter 5. Using Phalcon's Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 使用Phalcon的特性
- en: It's time to add some features to our blog and learn more about Phalcon's functionality
    in the process. There is still a lot to do to get our blog up-to-speed. Users'
    passwords are still in plain text, and anyone, whether they are a user or not,
    can browse to a user's page and view the passwords. So, we need to set up at least
    some sort of security and user-access control. We have a comments table, yet we
    don't have any way to comment. And a blog is not a blog without an RSS feed and
    the ability to ping feed aggregators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给我们的博客添加一些特性，并在过程中了解更多关于Phalcon的功能了。为了使我们的博客达到预期效果，还有很多工作要做。用户的密码仍然是明文，任何人，无论是否是用户，都可以浏览到用户的页面并查看密码。因此，我们需要设置至少某种形式的安全性和用户访问控制。我们有一个评论表，但我们还没有任何评论的方式。而且，没有RSS源和ping到聚合器的功能，博客就不能称之为博客。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to hash passwords with Phalcon
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Phalcon哈希密码
- en: How to use view helpers and view partials
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用视图辅助器和视图部分
- en: How to set cookies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置cookies
- en: How to control the user's access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何控制用户的访问
- en: How to cache data in our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在我们的应用程序中缓存数据
- en: How to use Phalcon's event manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Phalcon的事件管理器
- en: How to route application requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何路由应用程序请求
- en: Hashing passwords with Phalcon
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Phalcon哈希密码
- en: First, let's at least get the passwords hashed. Hashing is a process by which
    a password is converted into a fixed length bit string or a hash that cannot be
    reverse-engineered to retrieve the password, but any change in the entered password
    will change the resulting hash. So, for a more secure application, we are going
    to generate a hash from the password that a user enters and store that value in
    the database. Then, when the user tries to log in again, we will generate a hash
    from the entered password and compare it to the value of the hash in the database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们至少将密码哈希化。哈希化是一个将密码转换为固定长度的位字符串或哈希的过程，该哈希不能被逆向工程以检索密码，但输入密码的任何变化都会改变生成的哈希。因此，为了更安全的应用程序，我们将从用户输入的密码生成一个哈希，并将该值存储在数据库中。然后，当用户再次尝试登录时，我们将从输入的密码生成一个哈希，并将其与数据库中哈希值的值进行比较。
- en: Fortunately, this is easy to do with Phalcon. The security component is automatically
    loaded in the Phalcon services' container. So, open up the `UsersController.php`
    file and find the `createAction` function; then, find the line where the password
    is set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这很容易用Phalcon做到。安全组件会自动加载到Phalcon服务的容器中。所以，打开`UsersController.php`文件，找到`createAction`函数；然后，找到设置密码的行。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, simply replace it with the following two lines of code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需将其替换为以下两行代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, when we create a user, the password will be hashed and saved to the database.
    We also want to save the password again as a hash if we edit. So, we find the
    same line of code in the `saveAction` function and replace it with the previous
    two lines of code to hash the password.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建用户时，密码将被哈希并保存到数据库中。如果我们编辑，我们还想将密码再次作为哈希保存。因此，我们在`saveAction`函数中找到相同的代码行，并将其替换为前面的两行代码以哈希密码。
- en: 'Now, all we need to do is edit our `loginAction` function. Our initial function
    was kind of clunky. So, we are going to replace it with something a little more
    streamlined. The new `loginAction` function will look like the following code
    snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要编辑我们的`loginAction`函数。我们的初始函数有点笨拙。所以，我们将用一些更流畅的东西来替换它。新的`loginAction`函数将如下代码片段所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of searching for the user in the database, we try to instantiate the
    user using the `findFirstByFieldname` function, where `Fieldname` can be replaced
    with the column in the database we are querying. If we do find a user by searching
    for the username, we use security services' `checkHash` function to compare the
    hash in the database with the hash we just generated off of the entered password.
    If there is a match, we go through the process of setting the `user_id` variable
    in the session and creating a welcome message.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在数据库中搜索用户，而是尝试使用`findFirstByFieldname`函数实例化用户，其中`Fieldname`可以替换为我们正在查询的数据库中的列。如果我们通过搜索用户名找到了用户，我们使用安全服务的`checkHash`函数来比较数据库中的哈希值与我们刚刚从输入的密码中生成的哈希值。如果匹配，我们就通过设置会话中的`user_id`变量和创建欢迎信息的过程。
- en: The Phalcon security component uses the bcrypt hash algorithm, which gives us
    a high level of security. This component is loaded in Phalcon by default, but
    it can also be configured manually to tweak the "slowness" of the bcrypt algorithm.
    You can learn more about this component at [http://docs.phalconphp.com/en/latest/reference/security.html](http://docs.phalconphp.com/en/latest/reference/security.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon 安全组件使用 bcrypt 哈希算法，这为我们提供了高水平的安全性。该组件默认由 Phalcon 加载，但也可以手动配置以调整 bcrypt
    算法的“缓慢”。你可以在[http://docs.phalconphp.com/en/latest/reference/security.html](http://docs.phalconphp.com/en/latest/reference/security.html)了解更多关于此组件的信息。
- en: Using Phalcon view helpers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Phalcon 视图助手
- en: 'We can also add some security by changing the password fields on the forms
    to true password fields. So, find the following files in the `users` folder located
    at `app/views`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将表单中的密码字段更改为真实密码字段来添加一些安全性。因此，在 `app/views` 目录下的 `users` 文件夹中找到以下文件：
- en: '`new.volt`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new.volt`'
- en: '`index.volt`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.volt`'
- en: '`edit.volt`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit.volt`'
- en: 'And find the following line of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中找到以下行：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Replace the preceding code with the following line of code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下行代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, passwords will be masked when they are entered in the field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当在字段中输入时，密码将被隐藏。
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Using Phalcon Models, Views,
    and Controllers"), *Using Phalcon Models, Views, and Controllers*, the Volt template
    engine is a very thin wrapper that is wrapped around PHP code, which Phalcon compiles
    to the actual PHP code. To call a Phalcon tag helper in Volt, we just use the
    uncamelized version of the function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章。使用 Phalcon 模型、视图和控制器")中学习的，*使用 Phalcon 模型、视图和控制器*，Volt
    模板引擎是一个非常薄的包装器，它围绕 PHP 代码包装，Phalcon 将其编译成实际的 PHP 代码。要在 Volt 中调用 Phalcon 标签助手，我们只需使用函数的非驼峰式版本。
- en: Using dynamic title tags
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态标题标签
- en: 'Let''s replace some of the HTML markup we wrote with some view helpers. A powerful
    view helper is the one for the document title. Right now, we have a hardcoded
    `title` tag in our main layout which gives the same title to every page. So, open
    up the `index.volt` file located at `app/views` and find the following line of
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些视图助手替换我们编写的部分 HTML 标记。一个强大的视图助手是文档标题助手。目前，我们在主布局中有一个硬编码的 `title` 标签，它给每个页面都赋予相同的标题。因此，打开位于
    `app/views` 目录下的 `index.volt` 文件，并找到以下行代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace the preceding code with the following line of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下行代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the only problem is that our page has no title because we haven''t set
    it yet. It would probably be a good idea to keep the title of our blog on every
    page. We could hardcode that or open up the `ControllerBase.php` file located
    at `app/controllers` and add the following function to the `ControllerBase` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一的问题是我们的页面没有标题，因为我们还没有设置它。保持我们博客的标题在每一页上可能是一个好主意。我们可以硬编码它，或者打开位于 `app/controllers`
    目录下的 `ControllerBase.php` 文件，并将以下函数添加到 `ControllerBase` 类中：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have our global title back again. But we want each blog post to have
    the title of the post in the title also. So, if we have a blog post called Hello
    World, we want our title to be Hello World: Phalcon Blog. It''s easy to do this.
    Open up the `PostController.php` file located at `app/controllers` and add the
    following line of code to the end of the `showAction` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们的全局标题又回来了。但我们要让每个博客文章的标题也出现在标题中。所以，如果我们有一个名为 Hello World 的博客文章，我们希望我们的标题是
    Hello World: Phalcon Blog。这样做很容易。打开位于 `app/controllers` 目录下的 `PostController.php`
    文件，并将以下行代码添加到 `showAction` 函数的末尾：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The title of a blog post is displayed before the blog title if you visit a blog
    post page. Now, if you want, you can add your own title to each action in each
    controller.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问博客文章页面，博客文章的标题会显示在博客标题之前。现在，如果你想的话，你可以在每个控制器中的每个操作中添加自己的标题。
- en: Setting the doctype
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置文档类型
- en: 'By setting the document type with Phalcon, you affect all the tags that it
    generates with tag helpers, so they conform to your chosen standard. We are going
    to use HTML5\. Add the following line of code to the `initialize` function in
    the `ControllerBase.php` file located at `app/controllers`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Phalcon 设置文档类型，你影响它生成的所有带有标签助手的标签，使它们符合你选择的标准。我们将使用 HTML5。将以下行代码添加到位于 `app/controllers`
    目录下的 `ControllerBase.php` 文件中的 `initialize` 函数中：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the document type will be set globally in each controller. Find the following
    line of code at the top of the `index.html` file located at `app/views`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文档类型将在每个控制器中全局设置。在 `app/views` 目录下的 `index.html` 文件顶部找到以下行代码：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And replace the preceding code with the following line of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下行代码：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, you can be sure that Phalcon will output tags that follow whatever standard
    you choose. To learn about the other document standards, you can visit [http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content](http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以确信 Phalcon 会输出你选择的任何标准的标签。要了解其他文档标准，你可以访问 [http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content](http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content)。
- en: Adding JavaScript and CSS with view helpers
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图助手添加 JavaScript 和 CSS
- en: 'We originally just hardcoded the CSS and JavaScript links in the head of our
    main layout file. This works for now, but if we move our project, we may have
    to change these links. Phalcon has script and CSS tag helpers that will make our
    job a little easier. We can replace the CSS links in the head of the `index.phtml`
    file located at `app/views` with the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初只是在主布局文件的头部分硬编码了 CSS 和 JavaScript 链接。目前这没问题，但如果我们移动项目，我们可能需要更改这些链接。Phalcon
    提供了脚本和 CSS 标签助手，这将使我们的工作变得容易一些。我们可以用以下代码片段替换 `app/views/index.phtml` 文件头部的 CSS
    链接：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We put the JavaScript links at the bottom of the file with the following lines
    of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码行将 JavaScript 链接放在文件底部：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will explore more view helpers as we read through this chapter. To learn
    more about Phalcon tag helpers, visit [http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html](http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在阅读本章的过程中探索更多的视图助手。要了解更多关于 Phalcon 标签助手的信息，请访问 [http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html](http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html)。
- en: Setting cookies
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 cookies
- en: Now we can log in and have secure passwords, but every time the browser is closed,
    we have to log in again. It would be nice to be able to log in to our blog and
    stay logged in for a few days at least. It is time to set a cookie.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以登录并拥有安全的密码，但每次浏览器关闭时，我们都需要再次登录。如果能够登录到我们的博客并至少保持几天登录状态会很好。是时候设置一个 cookie
    了。
- en: 'We are going to change the way we do this as we go through this chapter, but
    for now, it is very easy to set a cookie that will keep us logged in with very
    little code. First, we need to set up an encryption key because we will want to
    decrypt a cookie before setting it and decrypt it while retrieving it. We want
    to keep it that way, but in order to do this, we need to give it a key. So, go
    to [http://randomkeygen.com/](http://randomkeygen.com/) to generate a random string
    of digits. Then, open up the `config.ini` file located at `app/config` and add
    your key in the application section and call it `encryptKey`, shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在阅读本章的过程中改变我们做这件事的方式，但到目前为止，设置一个可以让我们保持登录状态的 cookie 非常简单。首先，我们需要设置一个加密密钥，因为我们在设置
    cookie 之前和检索它时都需要解密。我们希望保持这种方式，但为了做到这一点，我们需要给它一个密钥。所以，去 [http://randomkeygen.com/](http://randomkeygen.com/)
    生成一个随机的数字字符串。然后，打开 `app/config/config.ini` 文件，并在应用程序部分添加你的密钥，命名为 `encryptKey`，如下所示：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, open up the `services.php` file located at `app/config` and add the following
    code snippet to the bottom of the file in order to set the encryption key:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `app/config/services.php` 文件，并在文件底部添加以下代码片段以设置加密密钥：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, our cookies are ready to go. They were available earlier, but had we used
    them, they would have thrown an error about requiring an encryption key. Now,
    find the `loginAction` function in the `UsersController.php` file located at `app/controllers`
    and add the following line of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 cookies 已经准备好了。它们之前是可用的，但如果我们使用了它们，它们会抛出一个关于需要加密密钥的错误。现在，在 `app/controllers`
    目录下找到 `UsersController.php` 文件中的 `loginAction` 函数，并添加以下代码行：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add it right after you set the `user_id` variable in the session:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置会话中的 `user_id` 变量后立即添加它：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, open up the `PostsController.php` file located at `app/controllers` and
    find the part of the `createAction` function where we check the `user_id` variable
    in the session. Now, we are going to check for cookies first and then set the
    `user_id` variable in the session if we find a `user_id` cookie:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `app/controllers/PostsController.php` 文件，并找到检查会话中 `user_id` 变量的 `createAction`
    函数部分。现在，我们将首先检查 cookies，然后如果找到 `user_id` cookie，就在会话中设置 `user_id` 变量：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And that's about all that we have to do to retrofit our code to add cookies.
    To learn more about cookie management with Phalcon, see [http://docs.phalconphp.com/en/latest/reference/cookies.html](http://docs.phalconphp.com/en/latest/reference/cookies.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将代码改造以添加cookie的所有工作就到这里了。要了解更多关于Phalcon中cookie管理的知识，请参阅[http://docs.phalconphp.com/en/latest/reference/cookies.html](http://docs.phalconphp.com/en/latest/reference/cookies.html)。
- en: Now, we should be able to log out and log in again, close the browser, and still
    be logged in. However, this is not really all that we want when it comes to controlling
    users. We want to be able to seamlessly control everything they access. Currently,
    our application has holes, and to plug them, we need to copy and paste code to
    implement the same `user_id` variable check everywhere we need it's functionality.
    Fortunately, we won't have to do this. Phalcon provides a service that helps us
    control user access.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够注销并再次登录，关闭浏览器，仍然保持登录状态。然而，当涉及到控制用户时，这并不是我们真正想要的全部。我们希望能够无缝地控制他们访问的一切。目前，我们的应用程序存在漏洞，为了填补这些漏洞，我们需要复制并粘贴代码以在需要该功能的所有地方实现相同的`user_id`变量检查。幸运的是，我们不必这样做。Phalcon提供了一个服务，帮助我们控制用户访问。
- en: Controlling user access
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制用户访问
- en: 'An **access control list** (**ACL**) uses roles to control access to resources.
    `Phalcon\Acl` provides this functionality for us. With it, we can assign roles
    to the different types of visitors on our blog, and then use these roles to set
    up permissions on each action in each of our controllers. For our purposes, we
    are only going to create two roles, users and guests. A user will simply be a
    visitor that is logged in, a guest, or anyone else. We are only going to give
    guest access to perform the following actions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制列表**（**ACL**）使用角色来控制对资源的访问。`Phalcon\Acl`为我们提供了这个功能。有了它，我们可以将角色分配给我们博客上不同类型的访客，然后使用这些角色在每个控制器中的每个操作上设置权限。对于我们的目的，我们只将创建两个角色：用户和访客。用户将简单地是一个已登录的访客，访客或任何人。我们只将允许访客执行以下操作：'
- en: 'View the index page:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看索引页面：
- en: View the posts' index page
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看帖子索引页面
- en: Comment on a post
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对帖子进行评论
- en: View the users' index, which will be a login page, when a visitor is not logged
    in
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访客未登录时，查看用户索引页，这将是一个登录页面
- en: Log in
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录
- en: A logged in user can do everything. To put `Phalcon\Acl` to use in our application,
    we are going to create a simple Phalcon plugin. Phalcon Developer Tools already
    added our `plugins` folder and created the `pluginsDir` setting in the `config.ini`
    file. However, we still need to add the `plugins` directory to our loader. Open
    the `loader.php` file located at `app/config` and add the `plugins` directory
    to your loader.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用户可以做任何事情。为了在我们的应用程序中使用`Phalcon\Acl`，我们将创建一个简单的Phalcon插件。Phalcon开发者工具已经添加了我们的`plugins`文件夹，并在`config.ini`文件中创建了`pluginsDir`设置。然而，我们仍然需要将`plugins`目录添加到我们的加载器中。打开位于`app/config`的`loader.php`文件，并将`plugins`目录添加到您的加载器中。
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What we want to create is a plugin that will hook into Phalcon''s event manager.
    Using the event manager, we can attach listeners to various Phalcon events. Create
    a new file called `Security.php` in the `app/plugins` folder and add the following
    code snippet at the top of the file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的是一个插件，它将连接到Phalcon的事件管理器。使用事件管理器，我们可以将监听器附加到各种Phalcon事件。在`app/plugins`文件夹中创建一个名为`Security.php`的新文件，并在文件顶部添加以下代码片段：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We extend `Phalcon\Plugin`. Our constructor must accept a dependency injector
    instance. Then, we need to create a function that will add our ACL to our persistent
    variables. We will call it `getAcl`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`Phalcon\Plugin`。我们的构造函数必须接受一个依赖注入器实例。然后，我们需要创建一个函数，将我们的ACL添加到我们的持久变量中。我们将称之为`getAcl`。
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, the code checks if we already have an ACL instance. If not, we create
    one. We then set the `DefaultAction` function to deny access for security reasons.
    The next bit of code creates the roles, that is, users and guests, in our ACL.
    We then load all of the resources we want to be private into a variable and then
    add them all as resources. We will do the same for the resources that we want
    to be public. Then, we loop through the roles, giving both the roles access to
    the public resources. Then, we loop through the private resources and give access
    to users but not to guests. Finally, we set our new ACL to be persistent and return
    it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查我们是否已经有了ACL实例。如果没有，我们创建一个。然后，我们将`DefaultAction`函数设置为出于安全原因拒绝访问。接下来的代码段创建了角色，即用户和访客，在我们的ACL中。然后，我们将我们想要设置为私有的所有资源加载到一个变量中，并将它们全部添加为资源。我们将对想要设置为公共的资源做同样的事情。然后，我们遍历角色，为角色和公共资源提供访问权限。然后，我们遍历私有资源，为用户提供访问权限，但不为访客提供。最后，我们将我们的新ACL设置为持久性并返回它。
- en: 'This function just builds the structure of our ACL. We still need to actually
    control the access, and we will do that with a function that will fire before
    dispatch. Add the following function at the bottom of the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只是构建我们的ACL结构。我们仍然需要实际控制访问，我们将通过在调度之前触发一个函数来实现这一点。在文件底部添加以下函数：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function accepts an event instance and a dispatcher instance. We check
    if the visitor is logged in and set their role. Then, we set a variable to our
    controller name and one to the action name. We call our `getAcl` function to get
    our ACL, and we also call `$acl->isAllowed()`, passing the role of the visitor
    and the names of our controller and action. This will return true if the role
    is allowed access to the current resource. If the user is not allowed access,
    we set an error message and forward them to the index of our blog.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个事件实例和一个调度程序实例。我们检查访问者是否已登录并设置他们的角色。然后，我们设置一个变量来存储我们的控制器名称和一个变量来存储操作名称。我们调用我们的`getAcl`函数来获取我们的访问控制列表（ACL），并且我们还调用`$acl->isAllowed()`，传递访问者的角色以及我们的控制器和操作名称。如果角色被允许访问当前资源，这将返回true。如果用户不允许访问，我们将设置一个错误消息并将他们转发到我们博客的首页。
- en: 'Now, we need to hook into the standard dispatcher, attach this new `Security`
    plugin to our events manager, and set this as the event manager for our dispatcher.
    Open the `services.php` file located at `app/config` and add the following code
    snippet to the bottom of the file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要连接到标准调度程序，将这个新的`Security`插件附加到我们的事件管理器，并将其设置为调度程序的事件管理器。打开位于`app/config`的`services.php`文件，并将以下代码片段添加到文件底部：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about using `Phalcon\Acl`, visit [http://docs.phalconphp.com/en/latest/reference/acl.html](http://docs.phalconphp.com/en/latest/reference/acl.html).
    And to learn more about Phalcon's event manager, visit [http://docs.phalconphp.com/en/latest/reference/events.html](http://docs.phalconphp.com/en/latest/reference/events.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用`Phalcon\Acl`的信息，请访问[http://docs.phalconphp.com/en/latest/reference/acl.html](http://docs.phalconphp.com/en/latest/reference/acl.html)。要了解更多关于Phalcon的事件管理器的信息，请访问[http://docs.phalconphp.com/en/latest/reference/events.html](http://docs.phalconphp.com/en/latest/reference/events.html)。
- en: Applying the finishing touches to our application
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加最后修饰
- en: Phalcon Developer Tools can help out a lot, but let's face it, most of the code
    you are going to write for your application is from scratch. Our blog still doesn't
    have comments or a feed, so it is really not much of a blog. Adding these is going
    to be a manual job, but Phalcon makes it easy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon开发者工具可以提供很多帮助，但让我们面对现实，你将为你的应用程序编写的绝大多数代码都是从零开始的。我们的博客还没有评论或源，所以它实际上根本算不上一个博客。添加这些功能将是一项手动工作，但Phalcon使这变得容易。
- en: Adding comments
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加评论
- en: Now, let's give visitors the ability to comment on our posts. Earlier, we needed
    a user-access control so that we could limit moderating comments to logged-in
    users. But now, we need a place to do it. We are going to build a very simple
    comment-moderation system. We could use Phalcon Developer Tools or Phalcon web
    tools to generate our CRUD scaffolding for us, but in this case, we would almost
    be taking out more of the generated code than we'd be leaving in, but we can use
    the other controllers and views we generated as a guide.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给访问者提供在帖子上发表评论的能力。之前，我们需要用户访问控制，以便我们可以将评论管理限制为已登录用户。但现在，我们需要一个地方来做这件事。我们将构建一个非常简单的评论管理系统。我们可以使用Phalcon开发者工具或Phalcon网络工具为我们生成CRUD脚手架，但在这个案例中，我们几乎会移除比留下的更多生成的代码，但我们可以使用我们生成的其他控制器和视图作为指南。
- en: For comments, we need to add a form to comment on the posts showing an action
    view, and we also need to display comments that have been published under each
    post. We also need a place to list all comments, and a form to edit them and set
    them to be published.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于评论，我们需要添加一个表单来对帖子进行评论，并显示动作视图，我们还需要在每个帖子下显示已发布的评论。我们还需要一个地方来列出所有评论，以及一个表单来编辑它们并将它们设置为发布。
- en: 'Comments are already related to posts. We just need to modify a few things
    to make this relationship functional. Open the `show.volt` file located at `app/views/posts`.
    At the bottom of the file, add the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 评论已经与帖子相关联。我们只需修改几个地方，使这种关系变得可用。打开位于`app/views/posts`的`show.volt`文件。在文件底部，添加以下代码片段：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Right below the post, we loop through the comments that are related to that
    post, and if we set them to publish, we print the comment. Below that, we have
    the comment form, making sure that we have a hidden field that picks up the ID
    of the post. We make this form post to posts/comment, which means that we now
    need a `commentAction` function in our `Posts` controller. Open the `PostsController.php`
    file located at `app/controllers` and add the following function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在帖子下方，我们遍历与该帖子相关的评论，如果我们将它们设置为发布，则打印评论。下面是评论表单，确保我们有一个可以获取帖子ID的隐藏字段。我们将此表单提交到`posts/comment`，这意味着我们现在需要在`Posts`控制器中添加一个`commentAction`函数。打开位于`app/controllers`的`PostsController.php`文件，并添加以下函数：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's pretty simple. We create an instance of the `Comments` object from the
    `POST` variable, set the submitted date, and set the publish value to 0, which
    will represent false in our database. Then, we set a success message and forward
    the user back to the `Posts` show action, setting the ID to the ID of the post
    that was just commented on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。我们从`POST`变量中创建一个`Comments`对象的实例，设置提交日期，并将发布值设置为0，这在我们的数据库中将表示为false。然后，我们设置一个成功消息，并将用户转发回`Posts`的显示动作，设置ID为刚刚评论的帖子的ID。
- en: Now, we need a way to moderate our comments. First, we need a `Comments` controller.
    So, create a `CommentsController.php` file at `app/controllers` and make sure
    to include `Paginator`, because we will be using it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方式来管理我们的评论。首先，我们需要一个`Comments`控制器。因此，在`app/controllers`中创建一个`CommentsController.php`文件，并确保包含`Paginator`，因为我们将会使用它。
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we need our `CommentsController` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要我们的`CommentsController`类。
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And inside the `CommentsController` class, we need actions for indexing, editing,
    saving, and deleting. Our `indexAction` function returns a paginated result of
    all comments.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CommentsController`类内部，我们需要为索引、编辑、保存和删除操作创建动作。我们的`indexAction`函数返回所有评论的分页结果。
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our `editAction` function prepares a single comment for use in the edit form,
    when we are moderating a comment, by setting it to be published.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`editAction`函数通过将其设置为发布，为审核评论时使用的编辑表单准备单个评论。
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `saveAction` function saves an edited comment after we moderate it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveAction`函数在我们审核后保存编辑过的评论。'
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `deleteAction` function gets rid of our comment spam.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteAction`函数删除我们的评论垃圾邮件。'
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we just need views. First, we need the view for our `indexAction` function.
    So, create a file called `index.volt` in the `comments` folder located at `app/views`
    and insert the following code snippet in it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要视图。首先，我们需要为我们的`indexAction`函数创建视图。因此，在`app/views`的`comments`文件夹中创建一个名为`index.volt`的文件，并在其中插入以下代码片段：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, the view that will be used when we edit our posts. Save the following
    code snippet as `edit.volt` at `app/views/comments`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当编辑我们的帖子时将使用的视图。将以下代码片段保存为`edit.volt`，位于`app/views/comments`：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we can comment on posts and moderate them if we are logged in as a user.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们以用户身份登录，我们就可以对帖子进行评论和管理。
- en: Adding feeds
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加聚合源
- en: 'A blog is not really a blog without a way to syndicate our posts. Fortunately,
    it is going to be pretty simple to add a feed to our blog. Let''s put our feed
    at `http://localhost/phalconBlog/posts/feed`. This means that we need a new `feedAction`
    function in our posts controller. So, open the `PostsController.php` file located
    at `app/controllers` and add the following function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客如果没有一种方式来聚合我们的帖子，那就不是一个真正的博客。幸运的是，向我们的博客添加一个聚合源将会非常简单。让我们将我们的聚合源放在`http://localhost/phalconBlog/posts/feed`。这意味着我们需要在帖子控制器中添加一个新的`feedAction`函数。因此，打开位于`app/controllers`的`PostsController.php`文件，并添加以下函数：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we retrieve only 10 posts ordered by the published date in descending
    order using `Posts::find`. As the date format in an RSS feed is very specific
    and doesn''t match the MySQL datetime format, we loop through our records, converting
    the published date and adding this date to each `post` object. We then send the
    array of objects to the view. At the end of the function, we set the render level
    of the view. In this case, we don''t want our main layout or post layout to render.
    We only want the specialized template that we are about to create to render, so
    we set our level to `LEVEL_ACTION_VIEW`. The following six levels are available:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `Posts::find` 仅检索按发布日期降序排列的10篇帖子。由于RSS源中的日期格式非常特定，并且不匹配MySQL datetime格式，我们遍历我们的记录，转换发布日期，并将此日期添加到每个
    `post` 对象中。然后，我们将对象数组发送到视图。在函数的末尾，我们设置视图的渲染级别。在这种情况下，我们不希望我们的主布局或帖子布局渲染。我们只想渲染我们即将创建的专用模板，因此我们将我们的级别设置为
    `LEVEL_ACTION_VIEW`。以下六个级别可用：
- en: '`LEVEL_NO_RENDER`: This does not render any view'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_NO_RENDER`：这不会渲染任何视图'
- en: '`LEVEL_ACTION_VIEW`: This renders the view associated with the action'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_ACTION_VIEW`：这会渲染与操作关联的视图'
- en: '`LEVEL_BEFORE_TEMPLATE`: This generates the views before the controller''s
    layout'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_BEFORE_TEMPLATE`：这会在控制器布局之前生成视图'
- en: '`LEVEL_LAYOUT`: This generates the controller''s layout'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_LAYOUT`：这会生成控制器的布局'
- en: '`LEVEL_AFTER_TEMPLATE`: This generates the views after the controller is laid
    out'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_AFTER_TEMPLATE`：这会在控制器布局之后生成视图'
- en: '`LEVEL_MAIN_LAYOUT`: This generates the main layout'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEVEL_MAIN_LAYOUT`：这会生成主布局'
- en: 'Create a new file in the `posts` folder at `app/views`, call it `feed.volt`,
    and insert the following code snippet inside the `feed.volt` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app/views` 的 `posts` 文件夹中创建一个新文件，命名为 `feed.volt`，并在 `feed.volt` 文件中插入以下代码片段：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We wrap the XML tag at the top of the Volt template tag to hide `<?` from the
    Volt template engine. We add some necessary RSS elements including a title, description,
    and a link for our blog. Note that since we loaded our configuration into the
    DI container, we have access to the settings we created there for our blog's title
    and URL. The next step is to loop through the posts. This part is similar to the
    code in the `index.volt` file. But you may notice `|e` behind the title and the
    excerpt of the post. This is the Phalcon HTML escaping filter being called from
    Volt so that our feed will remain valid with any characters that may be in our
    content. We are generating XML and using the `rss_date` attribute that we created
    in our `feedAction` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Volt模板标签的顶部包裹XML标签，以隐藏Volt模板引擎中的 `<?`。我们添加一些必要的RSS元素，包括标题、描述和博客的链接。请注意，由于我们已经将配置加载到DI容器中，我们可以访问在那里为博客标题和URL创建的设置。下一步是遍历帖子。这部分与
    `index.volt` 文件中的代码类似。但您可能会注意到标题和摘要后面的 `|e`。这是从Volt中调用的Phalcon HTML转义过滤器，以确保我们的源在任何可能存在于我们内容中的字符下都保持有效。我们正在生成XML，并使用我们在
    `feedAction` 函数中创建的 `rss_date` 属性。
- en: 'The last step we need to do is add the link for RSS autodiscovery to the head
    of our pages. So, open the `index.volt` file located at `app/views` and add the
    following code snippet between the head tags:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一个步骤是将RSS自动发现链接添加到我们页面的头部。因此，打开位于 `app/views` 的 `index.volt` 文件，并在头部标签之间添加以下代码片段：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use the generic `tagHtml()` tag helper to generate the link for us,
    which becomes `tag_html()` in Volt. The first parameter is the name of the tag.
    The second parameter is an array of the tag's attributes. Note that the `href`
    parameter uses the `baseUri` configuration setting and `~`, which is a character
    used in Volt to concatenate strings together. The third parameter is a Boolean
    we set to true because we want this to be a self-closing tag. We set the fourth
    parameter to true because we only want to generate the start tag. Finally, we
    set the fifth parameter to true because we want an end-of-line character generated
    after the tag.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用通用的 `tagHtml()` 标签辅助函数来为我们生成链接，在 Volt 中变为 `tag_html()`。第一个参数是标签的名称。第二个参数是标签属性的数组。请注意，`href`
    参数使用了 `baseUri` 配置设置和 `~`，这是 Volt 中用于连接字符串的字符。第三个参数是一个我们设置为 true 的布尔值，因为我们希望这是一个自闭合标签。我们将第四个参数设置为
    true，因为我们只想生成起始标签。最后，我们将第五个参数设置为 true，因为我们希望在标签后生成一个换行符。
- en: Now, we can start telling the rest of the Internet about our new blog.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始向互联网的其余部分介绍我们的新博客。
- en: Sending update pings
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送更新ping
- en: 'In order to ping sites such as [http://weblogs.com](http://weblogs.com) and
    notify them that we have a new post, we are going to do a little more refactoring.
    It seems we used the title of our blog in the HTML title tag. We have to use it
    again in the function that we''ll write to ping. So, instead of hardcoding the
    title in two places that have to be edited, if we change the title, it would be
    better to create a configuration setting. So, add the following code snippet to
    the `config.ini` file located at `app/config`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了ping像[http://weblogs.com](http://weblogs.com)这样的网站并通知它们我们有一篇新文章，我们将进行一些重构。看起来我们在HTML标题标签中使用了我们博客的标题。我们还需要在将要编写的ping函数中使用它。因此，与其在两个必须编辑的地方硬编码标题，不如如果我们更改标题，创建一个配置设置会更好。所以，将以下代码片段添加到`app/config`中`config.ini`文件：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we are now going to use this setting in a controller, we need to have access
    to it there. To do this, we can add it to the Dependency Injection container.
    This can be done by adding these lines of code to the bottom of the `services.php`
    file located at `app/config`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在将在控制器中使用这个设置，我们需要在那里访问它。为此，我们可以将其添加到依赖注入容器中。这可以通过将以下代码行添加到`app/config`中`services.php`文件的底部来完成：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we can open the `ControllerBase.php` file located at `app/controllers`
    and set our title tag with our configuration setting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开位于`app/controllers`的`ControllerBase.php`文件，并使用我们的配置设置设置我们的标题标签。
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can create a new function in our `PostsController.php` file to ping the feed
    aggregator sites for us.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PostsController.php`文件中创建一个新的函数来为我们ping内容聚合网站。
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `$request` variable is the XML we are going to post to the services. Now
    that we've added the configuration settings to our Dependency Injection container,
    we can access the blog's title setting with `$this->config->blog->title` and the
    URL setting with `$this->config->blog->url`. The `$ping_urls` array contains the
    URLs of services we are going to ping. You can add more services to this array
    if you like. Then, we use PHP `curl` to ping.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`$request`变量是我们将要发布到服务的XML。现在我们已经将配置设置添加到我们的依赖注入容器中，我们可以使用`$this->config->blog->title`访问博客的标题设置，以及使用`$this->config->blog->url`访问URL设置。`$ping_urls`数组包含我们将要ping的服务URL。如果您喜欢，可以向此数组添加更多服务。然后，我们使用PHP
    `curl`进行ping。'
- en: 'Now, in the `createAction` function, find the following line of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`createAction`函数中，找到以下代码行：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following line of code before the preceding code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之前添加以下行：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Another feature we could add to this function is a way of logging the results
    of our pings, so we then have a way of debugging what is actually happening as
    our function doesn't return a status.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加到这个函数中的另一个特性是记录我们ping的结果，这样我们就有了一种调试实际发生情况的方法，因为我们的函数不返回状态。
- en: Now, it's time to add another variable to the application section of the configuration
    file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向配置文件的应用程序部分添加另一个变量了。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we need to add a service to log the results of our pings in the Dependency
    Injection container. Open up the `services.php` file located at `app/config` and
    add the following lines of code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在依赖注入容器中添加一个服务来记录我们ping的结果。打开位于`app/config`的`services.php`文件，并添加以下代码行：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will enable us to access our `pingLogger` service in the `sendPings` function
    we just created. So, after we set the `$result` variable, we can then log the
    URL we pinged along with the response we received. We check if the result is false,
    indicating that `curl` failed, and then change the `$result` variable to reflect
    that error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够访问我们刚刚创建的`sendPings`函数中的`pingLogger`服务。因此，在设置完`$result`变量后，我们可以记录我们ping的URL以及我们收到的响应。我们检查结果是否为假，表示`curl`失败，然后更改`$result`变量以反映该错误。
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using view partials
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图部分
- en: We have explored layouts and cascading views. We also have the option to use
    partials in Phalcon. Using partial templates allows us to reuse the same functionality
    in various parts of our application. A couple of places in which we may want to
    use partials are the navigation bar and the sidebar. Right now, our main layout
    does a lot of stuff. There is not much on the navigation bar or the sidebar. But
    as we add more functionalities, they might become more complex, and keeping them
    in separate files will help us to organize and simplify our code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了布局和级联视图。我们还有在Phalcon中使用部分视图的选项。使用部分模板允许我们在应用程序的各个部分重用相同的功能。我们可能想要使用部分视图的几个地方是导航栏和侧边栏。目前，我们的主布局做了很多事情。导航栏或侧边栏上没有太多内容。但随着我们添加更多功能，它们可能会变得更加复杂，将它们保存在单独的文件中将帮助我们组织和简化代码。
- en: 'You can create a folder to hold your partial views wherever you choose. You
    can even put them in your `views` folder located at `app` if you choose. But,
    to keep our templates more organized, let''s create a folder called `partials`
    inside of the `views` folder located at `app`. Now, open the `index.volt` file
    located at `app/views`. We are going to cut the sidebar out of this file and paste
    it in a new file called `sidebar.volt`, which we are going to save in our new
    `partials` folder. The content of that file should look like the following code
    snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何你选择的地方创建一个文件夹来存放你的部分视图。你甚至可以将它们放在位于`app`的`views`文件夹中。但是，为了使我们的模板更有组织性，让我们在位于`app`的`views`文件夹内创建一个名为`partials`的文件夹。现在，打开位于`app/views`的`index.volt`文件。我们将从这个文件中剪切侧边栏，并将其粘贴到一个名为`sidebar.volt`的新文件中，我们将将其保存在我们新的`partials`文件夹中。该文件的
    内容应如下代码片段所示：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will replace this in the `index.volt` file with the following line of code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`index.volt`文件中用以下代码行替换它：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the code we would use with Volt. If we were using PHP templates, we
    would use `<?php $this->partial("partials/sidebar"); ?>`. Note that we don't add
    the file extension to the `path` parameter. Make sure to do this with your `partials`
    folder. Adding the extension will cause an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在Volt中使用的代码。如果我们使用PHP模板，我们会使用`<?php $this->partial("partials/sidebar");
    ?>`。请注意，我们不要在`path`参数中添加文件扩展名。确保对你的`partials`文件夹也这样做。添加扩展名会导致错误。
- en: 'Now, you can cut the `div` tag with the `navbar` class in the `index.phtml`
    file located at `app/views`, paste it into a file called `navbar.volt`, save it
    in your `partials` folder, and replace the `div` tag with the following line of
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在位于`app/views`的`index.phtml`文件中，使用具有`navbar`类的`div`标签，将其粘贴到名为`navbar.volt`的文件中，将其保存在你的`partials`文件夹中，并用以下代码行替换`div`标签：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, the different types of functionalities are separated in your application.
    You may find other places in your application where you may want to use partials,
    such as in the header or the footer. To learn more about Phalcon, visit [http://docs.phalconphp.com/en/latest/index.html](http://docs.phalconphp.com/en/latest/index.html).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不同的功能类型已在你应用中分离。你可能会在应用的其他地方找到可能想要使用部分视图的地方，例如在页眉或页脚中。要了解更多关于Phalcon的信息，请访问[http://docs.phalconphp.com/en/latest/index.html](http://docs.phalconphp.com/en/latest/index.html)。
- en: Caching in Phalcon
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phalcon中的缓存
- en: Caching can speed up and save resources on a site that gets a lot of traffic
    or does a lot of intense repeatable database queries, but this should only be
    implemented where actually needed. In other words, our blog, in its current iteration,
    probably doesn't need a cache, but we are going to take a look at caching in Phalcon
    and add caching to a part of our blog just to get a handle on how it works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以加快并节省大量流量或执行大量密集型重复数据库查询的网站上的资源，但此功能只应在实际需要时实施。换句话说，我们当前的博客可能不需要缓存，但我们打算研究Phalcon中的缓存，并将缓存添加到我们博客的一部分，以便了解其工作原理。
- en: Setting up a cache service
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置缓存服务
- en: In Phalcon, the cache consists of two parts, a frontend cache that handles cache
    expiration and transformation, and the backend cache that handles the reads and
    writes when requested to by the frontend. Here is an example of a cache service.
    We could simply add this to our `service.php` file located at `app/config`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Phalcon中，缓存由两部分组成，一个处理缓存过期和转换的前端缓存，以及一个处理前端请求时的读取和写入的后端缓存。以下是一个缓存服务的示例。我们可以简单地将其添加到位于`app/config`的`service.php`文件中。
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are pretty used to setting up new Phalcon services by now. In this new service,
    we use the configuration variable so that it can use our cache directory setting.
    We give the frontend cache a lifetime of one day and feed this variable to our
    backend cache along with the location of our cache directory.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经很习惯于设置新的Phalcon服务。在这个新服务中，我们使用配置变量，以便它可以使用我们的缓存目录设置。我们给前端缓存设置了一天的生命周期，并将这个变量以及我们的缓存目录位置传递给后端缓存。
- en: 'We used a file-based cache in this service. It is not the fastest of caching
    mechanisms and is probably the slowest, but it is easy to set up and requires
    no other software. However, you are not limited to file-based backends with Phalcon.
    As long as you have the required software and PHP extensions installed, you can
    use any one of the following as a backend cache in Phalcon:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个服务中使用了基于文件的缓存。这不是最快的缓存机制，可能是最慢的，但它易于设置，且不需要其他软件。然而，你并不限于使用基于文件的Phalcon后端。只要你有所需的软件和PHP扩展安装，你就可以在Phalcon中使用以下任何一个作为后端缓存：
- en: File
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Memcached
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcached
- en: APC
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: APC
- en: MongoDB
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Xcache
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcache
- en: 'Phalcon has a variety of frontend cache adapters too. In the code for our cache
    service, we specified a data adapter that serializes our data before saving it,
    but you can also use one of the following frontend adapters:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon也有多种前端缓存适配器。在我们的缓存服务代码中，我们指定了一个数据适配器，在保存数据之前对其进行序列化，但你也可以使用以下前端适配器之一：
- en: Output
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出
- en: JSON
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: IgBinary
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IgBinary
- en: Base64
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base64
- en: None
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: Using a Phalcon cache
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Phalcon缓存
- en: 'Now that we have our cache service set up, we can use it wherever we need it.
    First, you need a cache key. All Phalcon caches use a key to store and access
    cached data. It needs to be unique to that piece of data. A good place for a function
    to generate keys for the cache in our application would be in the `ControllerBase.php`
    file located at `app/controllers`. We can add the following function to the `ControllerBase`
    class so that all of our controllers inherit it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了缓存服务，我们可以在需要的地方使用它。首先，你需要一个缓存键。所有Phalcon缓存都使用键来存储和访问缓存数据。它需要对于那份数据是唯一的。在我们的应用程序中，为缓存生成键的好地方是在`app/controllers`文件夹中的`ControllerBase.php`文件中。我们可以在`ControllerBase`类中添加以下函数，以便所有控制器继承它：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This function will simply create a unique key for us. So, now we test the function
    using our cache by opening up the `PostController.php` file located at `app/controllers`
    and modifying the `showAction` function. We can access the cache service we created
    by adding the following line of code at the beginning of the function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将为我们创建一个唯一的键。因此，现在我们通过打开位于`app/controllers`的`PostController.php`文件并修改`showAction`函数来测试使用我们的缓存的功能。我们可以在函数的开始处添加以下代码行来访问我们创建的缓存服务：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, by executing the following line of code, you can access the cached content
    or start the cache:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过执行以下代码行，你可以访问缓存内容或开始缓存：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, we check if we have content, and if we don't, we get it from the database
    and save it in the cache using our key.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查是否有内容，如果没有，我们就从数据库中获取它，并使用我们的键将其保存到缓存中。
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The rest of the function remains the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分保持不变。
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Open up one of your blog's posts in the browser and refresh the page. You will
    find the cache file in the `cache` folder located at `app`. Inside the file, serialized
    data will be present, representing the `$post` object. To learn more about using
    caching in Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/cache.html](http://docs.phalconphp.com/en/latest/reference/cache.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开你博客的一篇文章并刷新页面。你将在`app`文件夹中的`cache`文件夹中找到缓存文件。在文件中，将存在序列化数据，代表`$post`对象。要了解更多关于在Phalcon中使用缓存的信息，请访问[http://docs.phalconphp.com/en/latest/reference/cache.html](http://docs.phalconphp.com/en/latest/reference/cache.html)。
- en: You can also cache data at the model level. The mechanism is the same. Try to
    access the cached data by a key. Check if there is data. If not, execute the database
    call to retrieve the data and cache it. Then, return the result. To learn about
    caching in the ORM, visit [http://docs.phalconphp.com/en/latest/reference/models-cache.html](http://docs.phalconphp.com/en/latest/reference/models-cache.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在模型级别缓存数据。机制是相同的。尝试通过键访问缓存的数据。检查是否存在数据。如果没有，执行数据库调用以检索数据并将其缓存。然后，返回结果。要了解ORM中的缓存，请访问[http://docs.phalconphp.com/en/latest/reference/models-cache.html](http://docs.phalconphp.com/en/latest/reference/models-cache.html)。
- en: Routing in Phalcon
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phalcon中的路由
- en: 'Before we take a look at other application structures in Phalcon, especially
    the micro application, we should take a look at routing. Up to now, we just have
    the routes in our application; just magically map to our controllers and the actions
    in them and let Phalcon do all of the thinking about routing for us. This is because
    with the single MVC structure that we are using, the routing is in MVC mode. We
    also have the option of match-only mode. You will notice that our blog application
    has an index page that does nothing. It still has the default Phalcon message.
    The bulk of our site currently resides at `http://localhost/phalconBlog/posts`.
    Well, a hacky way to fix this that we are going to use to learn about routing
    in Phalcon is to use a router. So, we need to add another service to our Dependency
    Injection container. Open up the `services.php` file located at `app/config` and
    add the following lines of code at the bottom:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看Phalcon中的其他应用结构，特别是微应用之前，我们应该先看看路由。到目前为止，我们只是在我们的应用中有了路由；神奇地映射到我们的控制器和其中的动作，让Phalcon为我们处理所有的路由思考。这是因为我们正在使用的单MVC结构中，路由是在MVC模式下的。我们还有匹配模式的选择。你会注意到我们的博客应用有一个什么也不做的首页。它仍然有默认的Phalcon消息。我们网站的大部分内容目前位于`http://localhost/phalconBlog/posts`。嗯，为了修复这个问题，我们将使用一种黑客式的方法来学习Phalcon中的路由，那就是使用一个路由器。因此，我们需要向我们的依赖注入容器中添加另一个服务。打开位于`app/config`的`services.php`文件，并在底部添加以下代码行：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When we add a route to the MVC router, the first parameter is the path and the
    second is any array that maps this path to a module, controller, and an action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向MVC路由器添加路由时，第一个参数是路径，第二个参数是任何数组，它将此路径映射到一个模块、控制器和动作。
- en: Match-only mode routing is used in the micro application example coming up.
    To learn more about routing in Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/routing.html](http://docs.phalconphp.com/en/latest/reference/routing.html).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将出现的微应用示例中，使用的是匹配模式的路由。要了解更多关于Phalcon中路由的信息，请访问[http://docs.phalconphp.com/en/latest/reference/routing.html](http://docs.phalconphp.com/en/latest/reference/routing.html)。
- en: Other project types of Phalcon
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phalcon的其他项目类型
- en: We created one type of application in Phalcon, a single MVC application. But,
    the type of application structure does not fit all types of projects. We will
    now take a look at a few other types of applications you can build with Phalcon.
    Of course, Phalcon being a very loosely-coupled framework, you are not limited
    by just these structures, and you can structure your projects however you choose.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Phalcon中创建了一种类型的应用，一个单MVC应用。但是，这种应用结构并不适合所有类型的项目。现在我们将看看你可以使用Phalcon构建的几种其他类型的应用。当然，作为一个非常松散耦合的框架，Phalcon并不限制你只使用这些结构，你可以根据自己的选择来组织项目。
- en: Multimodule applications
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多模块应用
- en: As an application grows in size, it may be easy to organize the code into modules.
    Instead of an `app` folder in a project, you have multiple folders under an `apps`
    folder, each having their own sets of models, views, and controllers. Routing
    in MVC mode is already set up to handle modules. There are only a few extra steps
    involved. To learn more about Phalcon multimodule applications, visit [http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module](http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用规模的扩大，将代码组织到模块中可能变得容易。在项目中的`app`文件夹而不是一个`apps`文件夹下，你可以有多个文件夹，每个文件夹都有自己的模型、视图和控制器集合。在MVC模式下，路由已经设置好以处理模块。只需要几个额外的步骤。要了解更多关于Phalcon多模块应用的信息，请访问[http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module](http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module)。
- en: Micro applications
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微应用
- en: 'For even simpler applications than the one we wrote, using a micro framework
    structure may make more sense. A micro application in Phalcon can be as simple
    as the following code snippet:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于比我们写的应用更简单的应用，使用微框架结构可能更有意义。在Phalcon中，微应用可以像以下代码片段那样简单：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There is not much to this application. First, we create an instance of `Phalcon\MVC\Micro`
    and then we defined our routes. So, when a visitor visits the `/user/Stephan`
    page of the application, they are greeted with **Hi Stephan**. The second route
    shows one of the perfect uses of a micro application for an API. Most simple APIs
    don't need complex controllers. This example is here to show you how small a working
    Phalcon application can be. It uses routing in the match-only mode. As a micro
    application grows in size, you can use more of the features it supports, including
    models, redirects, and services. To learn more about Phalcon micro applications,
    visit [http://docs.phalconphp.com/en/latest/reference/micro.html](http://docs.phalconphp.com/en/latest/reference/micro.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序没有太多内容。首先，我们创建了一个`Phalcon\MVC\Micro`的实例，然后我们定义了我们的路由。因此，当访问者访问应用程序的`/user/Stephan`页面时，他们会看到**Hi
    Stephan**。第二个路由展示了微应用程序用于API的一个完美用途。大多数简单的API不需要复杂的控制器。这个例子在这里是为了展示一个工作的Phalcon应用程序可以有多小。它使用匹配模式的路由。随着微应用程序规模的扩大，你可以使用它支持的更多功能，包括模型、重定向和服务。想了解更多关于Phalcon微应用程序的信息，请访问[http://docs.phalconphp.com/en/latest/reference/micro.html](http://docs.phalconphp.com/en/latest/reference/micro.html)。
- en: Command-line applications
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行应用程序
- en: 'Sometimes, you may not need a complete web application to get the job done.
    For scripts that you run from a command line or cron, you just need a simple structure
    to organize the functionality of your code. A Phalcon command-line application''s
    structure can start as small as the following code snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不需要一个完整的Web应用程序来完成工作。对于从命令行或cron运行的脚本，你只需要一个简单的结构来组织你代码的功能。Phalcon命令行应用程序的结构可以从以下代码片段开始：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The bootstrap file is `cli.php`, and it starts out in pretty much the same manner
    that all command-line applications start in Phalcon.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件是`cli.php`，它以与Phalcon中所有命令行应用程序启动时几乎相同的方式开始。
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: All that bootstrap file has to do is process commands and choose the right task
    and action. We are storing our tasks in the `tasks` folder. A command-line application
    must have at least a `mainTask` and `mainAction`. So, we can add this file to
    the `tasks` folder and name it `MainTask.php`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件只需处理命令并选择正确的任务和操作。我们将任务存储在`tasks`文件夹中。命令行应用程序至少需要有一个`mainTask`和`mainAction`。因此，我们可以将此文件添加到`tasks`文件夹中，并将其命名为`MainTask.php`。
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `mainAction` function of the main task will be run while executing the
    following command line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令行时，主任务的`mainAction`函数将被运行：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To call a specific task and action, just assign the task as the first parameter,
    the action as the second, and any of the parameters (`tom`, `dick`, and `harry`)
    can be handled by the action function called `Executing`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用特定的任务和操作，只需将任务作为第一个参数，将操作作为第二个参数，任何参数（`tom`、`dick`和`harry`）都可以由名为`Executing`的动作函数处理：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To learn more about creating command-line applications with Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/cli.html](http://docs.phalconphp.com/en/latest/reference/cli.html).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用Phalcon创建命令行应用程序的信息，请访问[http://docs.phalconphp.com/en/latest/reference/cli.html](http://docs.phalconphp.com/en/latest/reference/cli.html)。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned more about what we can do with the Phalcon framework
    while adding features to our blog application. It is not the most feature-packed
    blog, but we showed how to use Phalcon tag helpers to set our document type and
    generate dynamic titles for our pages. We also explained how to control user access,
    hash passwords, and set cookies in Phalcon. Then, we broke up our views into reusable
    bit-sized pieces using view partials. Just in case our blog ever gets any traffic,
    we dabbled a bit with caching in Phalcon. We also learned how to use routing in
    Phalcon. Finally, we learned other structures we can use for a Phalcon application.
    To learn more about Phalcon, visit [http://phalconphp.com](http://phalconphp.com).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在为我们的博客应用程序添加功能的同时，更多地了解了我们可以使用Phalcon框架做什么。这并不是功能最丰富的博客，但我们展示了如何使用Phalcon标签助手设置文档类型并为我们的页面生成动态标题。我们还解释了如何在Phalcon中控制用户访问、散列密码和设置cookie。然后，我们使用视图部分将我们的视图拆分成可重用的块。以防我们的博客有任何流量，我们在Phalcon中尝试了一些缓存。我们还学习了如何在Phalcon中使用路由。最后，我们学习了我们可以用于Phalcon应用程序的其他结构。想了解更多关于Phalcon的信息，请访问[http://phalconphp.com](http://phalconphp.com)。
