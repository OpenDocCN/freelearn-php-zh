- en: Value Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: By using the `self` keyword, we don't The Value Objects are a fundamental building
    block of Domain-Driven Design, and they're used to model concepts of your Ubiquitous
    Language in code. A Value Object is not just a thing in your Domain — it measures,
    quantifies, or describes something. Value Objects can be seen as small, simple
    objects — such as money or a date range — whose equality is not based on identity,
    but instead on the content held.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `self` 关键字，我们不需要... 值对象是领域驱动设计的基本构建块，它们用于在代码中建模你的通用语言的概念。值对象不仅仅是领域中的一个事物——它衡量、量化或描述某物。值对象可以看作是小型、简单的对象——例如货币或日期范围——它们的等价性不是基于身份，而是基于所包含的内容。
- en: For example, a product price could be modeled using a Value Object. In this
    case, it's not representing a thing, but rather a value that allows us to measure
    how much Money a product is worth. The memory footprint for these objects is trivial
    to determine (calculated by their constituent parts) and there's very little overhead.
    As a result, new instance creation is favored over reference reuse, even when
    being used to represent the same value. Equality is then checked based on the
    comparability of the fields of both instances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用值对象来模拟产品价格。在这种情况下，它不是代表一个事物，而是一个值，它允许我们衡量一个产品值多少钱。这些对象的内存占用非常小（通过它们的组成部分计算得出）并且几乎没有开销。因此，在表示相同值时，新实例的创建比引用重用更受欢迎。然后根据两个实例的字段的可比性来检查等价性。
- en: Definition
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义
- en: 'Ward Cunningham [defines](http://c2.com/cgi/wiki?ValueObject) a Value Object
    as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Ward Cunningham [定义](http://c2.com/cgi/wiki?ValueObject) 值对象为：
- en: A measure or description of something. Examples of Value Objects are things
    like numbers, dates, monies and strings. Usually, they are small Objects which
    are used quite widely. Their identity is based on their state rather than on their
    Object identity. This way, you can have multiple copies of the same conceptual
    Value Object. Every $5 note has its own identity (thanks to its serial number),
    but the cash economy relies on every $5 note having the same Value as every other
    $5 note.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对某物的衡量或描述。值对象的例子包括像数字、日期、货币和字符串这样的东西。通常，它们是使用相当广泛的小对象。它们的身份基于它们的状态而不是它们的对象身份。这样，你可以有多个相同概念上的值对象副本。每张5美元纸币都有其自己的身份（多亏了它的序列号），但现金经济依赖于每张5美元纸币都有与其他5美元纸币相同的值。
- en: 'Martin Fowler [defines](http://martinfowler.com/bliki/ValueObject.html) a Value
    Object as:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler [定义](http://martinfowler.com/bliki/ValueObject.html) 值对象为：
- en: A small Object such as a Money or the date range object. Their key property
    is that they follow value semantics rather than reference semantics. You can usually
    tell them because their notion of equality isn't based on identity, instead two
    Value Objects are equal if all their fields are equal. Although all fields are
    equal, you don't need to compare all fields if a subset is unique — for example
    currency codes for currency objects are enough to test equality. A general heuristic
    is that Value Objects should be entirely immutable. If you want to change a Value
    Object you should replace the object with a new one and not be allowed to update
    the values of the value object itself — updatable value objects lead to aliasing
    problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的对象，如货币或日期范围对象。它们的关键属性是它们遵循值语义而不是引用语义。你通常可以通过它们的等价性不是基于身份来判断它们，而是如果所有字段都相等，则两个值对象是相等的。尽管所有字段都相等，但如果子集是唯一的，则不需要比较所有字段——例如，货币对象的货币代码就足以测试等价性。一个一般的启发式方法是值对象应该是完全不可变的。如果你想更改一个值对象，你应该用一个新的对象替换它，而不允许更新值对象本身的值——可更新的值对象会导致别名问题。
- en: Examples of Value Objects are numbers, text strings, dates, times, a person's
    full name (composed of first name, middle name, last name, and title), currencies,
    colors, phone numbers, and postal addresses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象的例子包括数字、文本字符串、日期、时间、一个人的全名（由名、中名、姓和头衔组成）、货币、颜色、电话号码和邮政地址。
- en: Exercise
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Try to locate more examples of potential Value Objects in your current Domain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的当前领域中定位更多潜在的值对象示例。
- en: Value Object vs. Entity
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象与实体
- en: 'Consider the following examples from [Wikipedia](http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD),
    in order to better understand the difference between Value Objects and Entities:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自 [维基百科](http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD)
    的例子，以更好地理解值对象与实体之间的区别：
- en: '**Value Object**: When people exchange dollar bills, they generally do not
    distinguish between each unique bill; they only are concerned about the face value
    of the dollar bill. In this context, dollar bills are Value Objects. However,
    the Federal Reserve may be concerned about each unique bill; in this context each
    bill would be an entity.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值对象**：当人们交换美元纸币时，他们通常不会区分每一张独特的纸币；他们只关心美元纸币的面值。在这种情况下，美元纸币是值对象。然而，联邦储备银行可能关心每一张独特的纸币；在这种情况下，每一张纸币都是一个实体。'
- en: '**Entity**: Most airlines distinguish each seat uniquely on every flight. Each
    seat is an entity in this context. However, Southwest Airlines, EasyJet and Ryanair
    do not distinguish between every seat; all seats are the same. In this context,
    a seat is actually a Value Object.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：大多数航空公司会在每架航班上唯一区分每个座位。在这种情况下，每个座位都是一个实体。然而，西南航空、易捷航空和瑞安航空不会区分每个座位；所有座位都是相同的。在这种情况下，座位实际上是一个值对象。'
- en: Exercise
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Think about the concept of an address (street, number, zip code, and so on).
    What is a possible context where an address could be modeled as an Entity and
    not as a Value Object? Discuss your findings with a peer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑地址的概念（街道、号码、邮编等）。在什么情况下可以将地址建模为实体而不是值对象？与同伴讨论你的发现。
- en: Currency and Money Example
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 货币与货币示例
- en: The `Currency` and `Money` Value Objects are probably the most used examples
    for explaining Value Objects, thanks to the [Money pattern](http://martinfowler.com/eaaCatalog/money.html).
    This design pattern provides a solution for modeling a problem that avoids a floating-point
    rounding issue, which in turn allows for deterministic calculations to be performed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Currency`和`Money`值对象可能是解释值对象最常用的例子，归功于[货币模式](http://martinfowler.com/eaaCatalog/money.html)。此设计模式提供了一种避免浮点数舍入问题的解决方案，从而允许进行确定性计算。'
- en: 'In the real world, a currency describes monetary units in the same way that
    meters and yards describe distance units. Each currency is represented with a
    three-letter uppercase ISO code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，货币以与米和码相同的方式描述货币单位。每种货币都使用一个三个字母的大写ISO代码表示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One of the main goals of Value Objects is also the holy grail of Object-Oriented
    design: encapsulation. By following this pattern, you''ll end up with a dedicated
    location to put all the validation, comparison logic, and behavior for a given
    concept.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象的主要目标之一也是面向对象设计的圣杯：封装。通过遵循此模式，你将最终拥有一个专门的位置来放置给定概念的所有验证、比较逻辑和行为。
- en: Extra Validations for Currency
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 货币的额外验证
- en: In the previous code example, we can build a Currency with an AAA Currency ISO
    code. That isn't valid at all. Write a more specific rule that will check if the
    ISO Code is valid. A full list of valid currency ISO codes can be found [here](http://www.xe.com/iso4217.php).
    If you need help, take a look at the [Money](https://github.com/moneyphp/money) packagist
    library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以使用AAA货币ISO代码构建一个货币。这完全不正确。编写一个更具体的规则来检查ISO代码是否有效。有效的货币ISO代码的完整列表可以在[这里](http://www.xe.com/iso4217.php)找到。如果你需要帮助，请查看[Money](https://github.com/moneyphp/money)包管理器库。
- en: Money is used to measure a specific amount of currency. It's modeled using an
    amount and a currency. Amount, in the case of the Money pattern, is implemented
    using an integer representation of the Currency's least-valuable fraction — For
    example   in the case of USD or EUR, cents.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 货币用于衡量特定货币的数量。它使用金额和货币进行建模。在货币模式的情况下，金额使用货币最不重要的分数的整数表示实现——例如，在美元或欧元的情况下，是分。
- en: 'As a bonus, you might also notice that we''re using [self encapsulation](http://martinfowler.com/bliki/SelfEncapsulation.html) to
    set the ISO code, which centralizes changes in the Value Object itself:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，你可能还会注意到我们正在使用[自我封装](http://martinfowler.com/bliki/SelfEncapsulation.html)来设置ISO代码，这集中了值对象本身的变化：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you know the formal definition of Value Objects, let's dive deeper
    into some of the powerful features they offer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了值对象的形式定义，让我们更深入地了解它们提供的强大功能。
- en: Characteristics
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征
- en: While modeling an Ubiquitous Language concept in code, you should always favor
    Value Objects over Entities. Value Objects are easier to create, test, use, and
    maintain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在将通用语言概念建模到代码中时，你应该始终优先考虑值对象而不是实体。值对象更容易创建、测试、使用和维护。
- en: 'Keeping this in mind, you can determine whether the concept in question can
    be modeled as a Value Object if:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你可以确定所讨论的概念是否可以建模为值对象，如果：
- en: It measures, quantifies, or describes a thing in the Domain
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它测量、量化或描述领域中的事物
- en: It can be kept immutable
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以保持不变
- en: It models a conceptual whole by composing related attributes as an integral
    unit
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将相关属性作为整体单元组合来模拟一个概念整体
- en: It can be compared with others through value equality
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过值相等与其他对象进行比较
- en: It is completely replaceable when the measurement or description changes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测量或描述发生变化时，它可以完全替换
- en: It supplies its collaborators with side-effect-free behavior
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为协作者提供无副作用的操作
- en: Measures, Quantifies, or Describes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量、量化或描述
- en: As discussed before, a Value Object should not be considered just a *thing*
    in your Domain. As a value, it measures, quantifies, or describes a concept in
    the Domain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，值对象不应仅被视为领域中的“事物”。作为一个值，它测量、量化或描述领域中的概念。
- en: In our example, the `Currency` object describes what type of Money it is. The
    `Money` object measures or quantifies units of a given currency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`Currency`对象描述了它是哪种类型的货币。`Money`对象测量或量化特定货币的单位。
- en: Immutability
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: This is one of the most important aspects to grasp. Object values shouldn't
    be able to be altered over their lifetime. Because of this immutability, Value
    Objects are easy to reason and test and are free of undesired/unexpected side
    effects. As such, Value Objects should be created through their constructors.
    In order to build one, you usually pass the required primitive types or other
    Value Objects through this constructor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理解最重要的方面之一。对象值在其生命周期内不应能够被更改。正因为这种不可变性，值对象易于推理和测试，并且没有不希望或不预期的副作用。因此，值对象应通过其构造函数创建。为了构建一个，你通常通过这个构造函数传递所需的原始类型或其他值对象。
- en: Value Objects are always in a valid state; that's why we create them in a single
    atomic step. Empty constructors with multiple setters and getters move the creation
    responsibility to the client, resulting in the [Anemic Domain Model](http://www.martinfowler.com/bliki/AnemicDomainModel.html),
    which is considered an anti-pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象始终处于有效状态；这就是为什么我们通过单个原子步骤创建它们。带有多个设置器和获取器的空构造函数将创建责任转移到客户端，导致[贫血领域模型](http://www.martinfowler.com/bliki/AnemicDomainModel.html)，这被认为是一种反模式。
- en: It's also good to point out that it's not recommended to hold references to
    Entities in your Value Objects. Entities are mutable, and holding references to
    them could lead to undesirable side effects occurring in the Value Object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还应指出，不建议在值对象中保留实体的引用。实体是可变的，持有它们的引用可能导致值对象中出现不希望或不预期的副作用。
- en: In languages with [method overloading](http://en.wikipedia.org/wiki/Function_overloading),
    such as Java, you can create multiple constructors with the same name. Each of
    these constructors are provided with different options to build the same type
    of resulting object. In PHP, we're able to provide a similar capability by way
    of [f](http://en.wikipedia.org/wiki/Factory_method_pattern)[actory methods](http://en.wikipedia.org/wiki/Factory_method_pattern).
    These specific factory methods are also known as semantic constructors. The main
    goal of `fromMoney` is to provide more contextual meaning than the plain constructor.
    More radical approaches propose to make the `__construct` method private and build
    every instance using a semantic constructor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持[方法重载](http://en.wikipedia.org/wiki/Function_overloading)的语言中，例如Java，你可以创建具有相同名称的多个构造函数。这些构造函数都提供了不同的选项来构建相同类型的对象。在PHP中，我们能够通过[工厂方法模式](http://en.wikipedia.org/wiki/Factory_method_pattern)提供类似的能力，这些特定的工厂方法也被称为语义构造函数。`fromMoney`的主要目标是提供比普通构造函数更多的上下文意义。更激进的方案建议将`__construct`方法设为私有，并使用语义构造函数来构建每个实例。
- en: 'In our `Money` object, we could add some useful factory methods like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Money`对象中，我们可以添加一些有用的工厂方法，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By using the `self` keyword, we don't couple the code with the class name. As
    such, a change to the class name or namespace won't affect these factory methods.
    This small implementation detail helps when refactoring the code at a later date.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`self`关键字，我们不会将代码与类名耦合。因此，对类名或命名空间的更改不会影响这些工厂方法。这个小的实现细节有助于在以后重构代码时。
- en: static vs. self
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静态与自身
- en: Using static over self can result in undesirable issues when a Value Object
    inherits from another Value Object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值对象从另一个值对象继承时，使用静态而非自身可能会导致不希望的问题。
- en: Due to this immutability, we must consider how to handle mutable actions that
    are common place in a stateful context. If we require a state change, we now have
    to return a brand new Value Object representation with this change. If we want
    to increase the amount of, for example, a `Money` Value Object, we're required
    to instead return a new `Money` instance with the desired modifications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不可变性，我们必须考虑如何在有状态上下文中处理常见的可变操作。如果我们需要状态变化，我们现在必须返回一个新的带有这种变化的值对象表示。如果我们想增加例如
    `Money` 值对象的数量，我们必须返回一个新的带有所需修改的 `Money` 实例。
- en: 'Fortunately, it''s relatively simple to abide by this rule, as shown in the
    example below:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，遵守这个规则相对简单，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Money` object returned by `increaseAmountBy` is different from the `Money`
    client object that received the method call. This can be observed in the example
    comparability checks below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`increaseAmountBy` 返回的 `Money` 对象与接收方法调用的 `Money` 客户端对象不同。这可以在下面的示例比较检查中观察到：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Conceptual Whole
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念整体
- en: So why not just implement something similar to the following example, avoiding
    the need for a new Value Object class altogether?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不直接实现以下示例，从而完全避免需要新的值对象类呢？
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This approach has some noticeable flaws, if say, for example, you want to validate
    the ISO. It doesn't really make sense for the Product to be responsible for the
    Currency's ISO validation (thus violating the Single Responsibility Principle).
    This is highlighted even more so if you want to reuse the accompanying logic in
    other parts of your Domain (to abide by the DRY principle).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些明显的缺陷，比如说，如果你想验证ISO。让产品负责货币的ISO验证（从而违反了单一职责原则）实际上并没有太多意义。如果你想在域的其他部分重用相关的逻辑（以遵守DRY原则），这一点尤为突出。
- en: With these factors in mind, this use case is a perfect candidate for being abstracted
    out into a Value Object. Using this abstraction not only gives you the opportunity
    to group related properties together, but it also allows you to create higher-order
    concepts and a more concrete Ubiquitous Language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，这个用例是抽象成值对象的完美候选者。使用这种抽象不仅给你提供了将相关属性分组在一起的机会，而且还允许你创建更高阶的概念和更具体的通用语言。
- en: Exercise
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Discuss with a peer whether or not an email could be considered a Value Object.
    Does the context it's used in matter?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与同行讨论一下，是否可以将电子邮件视为值对象。使用的上下文是否重要？
- en: Value Equality
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值等价
- en: As discussed at the beginning of the chapter, two Value Objects are equal if
    the content they measure, quantify, or describe is the same.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所讨论的，如果两个值对象测量的、计量的或描述的内容相同，则这两个值对象是相等的。
- en: For example, imagine two `Money` objects representing 1 USD. Can we consider
    them equal? In the *real world*, are two bills of 1 USD valued the same? Of course
    they are. Directing our attention back to the code, the Value Objects in question
    refer to separate instances of `Money`. However, they both represent the same
    value, which makes them equal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象有两个 `Money` 对象代表1美元。我们能认为它们相等吗？在*现实世界*中，两张1美元的纸币价值相同吗？当然，它们是相同的。将我们的注意力转回代码，所讨论的值对象指的是
    `Money` 的不同实例。然而，它们都代表相同的值，这使得它们相等。
- en: 'In regards to PHP, it''s commonplace to compare two Value Objects using the
    `==` operator. Examining the [PHP Documentation](http://php.net/manual/en/language.oop5.object-comparison.php) definition
    of the operator highlights an interesting behavior:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PHP，使用 `==` 操作符比较两个值对象是很常见的。查看[PHP文档](http://php.net/manual/en/language.oop5.object-comparison.php)中对操作符的定义，可以突出一个有趣的行为：
- en: 'When using the comparison operator `==`, object variables are compared in a
    simple manner, namely: Two object instances are equal if they have the same attributes
    and values, and are instances of the same class.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用比较操作符 `==` 时，对象变量以简单的方式进行比较，即：如果两个对象实例具有相同的属性和值，并且是同一类的实例，则这两个对象实例是相等的。
- en: This behavior works in agreement with our formal definition of a Value Object.
    However, as an exact class match predicate is present, you should be wary when
    handling subtyped Value Objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与我们的值对象正式定义一致。然而，由于存在精确的类匹配谓词，在处理子类型值对象时你应该小心。
- en: 'Keeping this in mind, the even stricter `===` operator doesn''t help us, unfortunately:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，甚至更严格的 `===` 操作符不幸地并没有帮上忙：
- en: When using the identity operator `===`, object variables are identical if and
    only if they refer to the same instance of the same class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用身份操作符`===`时，如果对象变量引用的是同一类的同一实例，则它们是相同的。
- en: 'The following example should help confirm these subtle differences:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应有助于确认这些细微的差异：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A solution is to implement a conventional equals method in each Value Object.
    This method is tasked with checking the type and equality of its composite attributes.
    Abstract data type comparability is easy to implement using the built-in type
    hinting in PHP. You can also use the `get_class()` function to aid in the comparability
    check if necessary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在每个值对象中实现一个传统的`equals`方法。此方法负责检查其复合属性的类型和相等性。使用PHP内置的类型提示，抽象数据类型比较很容易实现。如果需要，您还可以使用`get_class()`函数来帮助进行可比较性检查。
- en: 'The language, however, is unable to decipher what equality truly means in your
    Domain concept, meaning it''s your responsibility to provide the answer. In order
    to compare the `Currency` objects, we just need to confirm that both their associated
    ISO codes are the same. The `===` operator does the job pretty well in this case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该语言无法解析在您的领域概念中真正意味着什么，这意味着提供答案的责任在于您。为了比较`Currency`对象，我们只需确认它们关联的ISO代码相同。在这种情况下，`===`操作符做得相当不错：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because `Money` objects use `Currency` objects, the `equals` method needs to
    perform this comparability check, along with comparing the amounts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Money`对象使用`Currency`对象，`equals`方法需要执行这种可比较性检查，同时比较金额：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Replaceability
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可替换性
- en: Consider a `Product` Entity that contains a `Money` Value Object used to quantify
    its price. Additionally, consider two `Product` Entities with an identical price
    — for example 100 USD. This scenario could be modeled using  the two individual
    `Money` objects or two references pointing to a single Value Object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含用于量化其价格的`Money`值对象的`Product`实体。此外，考虑两个具有相同价格的`Product`实体——例如100美元。这种场景可以使用两个单独的`Money`对象或两个指向单个值对象的引用来建模。
- en: Sharing the same Value Object can be risky; if one is altered, both will reflect
    the change. This behavior can be considered an unexpected side effect. For example,
    if Carlos was hired on February 20, and we know that Christian was also hired
    on the same day, we may set Christian's hire date to be the same instance as Carlos's.
    If Carlos then changes the month of his hire date to May, Christian's hire date
    changes too. Whether it's correct or not, it's not what people expect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 共享相同的值对象可能存在风险；如果其中一个被修改，两个都会反映这种变化。这种行为可以被认为是一个意外的副作用。例如，如果卡洛斯于2月20日被雇佣，并且我们知道克里斯蒂安也是在同一天被雇佣的，我们可能会将克里斯蒂安的雇佣日期设置为与卡洛斯相同的实例。如果卡洛斯随后将他的雇佣日期月份改为五月，克里斯蒂安的雇佣日期也会改变。无论这是否正确，这并不是人们所期望的。
- en: 'Due to the problems highlighted in this example, when holding a reference to
    a Value Object, it''s recommended to replace the object as a whole rather than
    modifying its value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本例中指出的问题，当持有值对象的引用时，建议整个替换对象而不是修改其值：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This kind of behavior is similar to how basic types such as strings work in
    PHP. Consider the function `strtolower`. It returns a new string rather than modifying
    the original one. No reference is used; instead, a new value is returned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为类似于PHP中基本类型（如字符串）的工作方式。考虑函数`strtolower`。它返回一个新的字符串而不是修改原始字符串。没有使用引用；相反，返回了一个新值。
- en: Side-Effect-Free Behavior
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无副作用行为
- en: 'If we want to include some additional behavior — like an `add` method — in
    our `Money` class, it feels natural to check that the input fits any preconditions
    and maintains any invariance. In our case, we only wish to add monies with the
    same currency:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的`Money`类中包含一些额外的行为——比如一个`add`方法——那么检查输入是否符合任何先决条件并保持任何不变性似乎是自然的。在我们的情况下，我们只想添加相同货币的金额：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the two currencies don''t match, an exception is raised. Otherwise, the
    amounts are added. However, this code has some undesirable pitfalls. Now imagine
    we have a mysterious method call to `otherMethod` in our code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两种货币不匹配，将引发异常。否则，金额将被相加。然而，这段代码有一些不希望出现的陷阱。现在想象一下，在我们的代码中有一个神秘的`otherMethod`方法调用：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything is fine until, for some reason, we start seeing unexpected results
    when we're returning or finished with `otherMethod`. Suddenly, `$aMoney` no longer
    contains 100 USD. What happened? And what happens if `otherMethod` internally
    uses our previously defined `add` method? Maybe you're unaware that add mutates
    the state of the `Money` instance. This is what we call a side effect. You must
    avoid generating side effects. You must not mutate your arguments. If you do,
    the developer using your objects may experience strange behaviors. They'll complain,
    and they'll be correct.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很顺利，直到，由于某种原因，当我们返回或完成 `otherMethod` 时，我们开始看到意外的结果。突然，`$aMoney` 不再包含 100
    美元。发生了什么？如果 `otherMethod` 内部使用我们之前定义的 `add` 方法，会发生什么？你可能没有意识到 `add` 方法会改变 `Money`
    实例的状态。这就是我们所说的副作用。你必须避免产生副作用。你不应该修改你的参数。如果你这样做，使用你的对象的开发者可能会遇到奇怪的行为。他们会抱怨，而且他们是对的。
- en: 'So how can we fix this? Simple — by making sure that the Value Object remains
    immutable, we avoid this kind of unexpected problem. An easy solution could be
    returning a new instance for every potentially mutable operation, which the `add`
    method does:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题？简单——通过确保值对象保持不可变，我们避免了这种意外问题。一个简单的解决方案可能是对于每个可能可变操作，都返回一个新的实例，这是
    `add` 方法所做的：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this simple change, immutability is guaranteed. Each time two instances
    of `Money` are added together, a new resulting instance is returned. Other classes
    can perform any number of changes without affecting the original copy. Code free
    of side effects is easy to understand, easy to test, and less error prone.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的更改，不可变性得到了保证。每次两个 `Money` 实例相加时，都会返回一个新的结果实例。其他类可以执行任何数量的更改，而不会影响原始副本。没有副作用的代码易于理解，易于测试，且错误率较低。
- en: Basic Types
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'Consider the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although `$a` and `$b` are different variables stored in different memory locations,
    when compared, they're the same. They hold the same value, so we consider them
    equal. You can change the value of `$a` from `10` to `20` at any time that you
    want, making the new value `20` and eliminating the `10`. You can replace integer
    values as much as you want without consideration of the previous value because
    you're not modifying it; you're just replacing it. If you apply any operation
    — such as addition (That is. `$a + $b`) — to these variables, you get another
    new value that can be assigned to another variable or a previously defined one.
    When you pass `$a` to another function, except when explicitly passed by reference,
    you're passing a value. It doesn't matter if `$a` gets modified within that function,
    because in your current code, you'll still have the original copy. Value Objects
    behave as basic types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `$a` 和 `$b` 是存储在不同内存位置的不同的变量，但在比较时，它们是相同的。它们持有相同的值，因此我们认为是相等的。你可以随时将 `$a`
    的值从 `10` 改为 `20`，使新值为 `20` 并消除 `10`。你可以随意替换整数值，无需考虑之前的值，因为你没有修改它；你只是在替换它。如果你对这些变量应用任何操作——例如加法（即
    `$a + $b`）——你将得到另一个新值，该值可以分配给另一个变量或之前定义的一个。当你将 `$a` 传递给另一个函数时，除非明确通过引用传递，否则你传递的是一个值。无论
    `$a` 在该函数内部是否被修改，都无关紧要，因为在你当前的代码中，你仍然会有原始副本。值对象的行为就像基本类型。
- en: Testing Value Objects
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试值对象
- en: Value Objects are tested in the same way normal objects are. However, the immutability
    and side-effect-free behavior must be tested too. A solution is to create a copy
    of the Value Object you're testing before performing any modifications. Assert
    both are equal using the implemented equality check. Perform the actions you want
    to test and assert the results. Finally, assert that the original object and copy
    are still equal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象与普通对象以相同的方式进行测试。然而，必须测试不可变性和无副作用的行为。一种解决方案是在执行任何修改之前创建你正在测试的值对象的副本。使用实现的相等性检查断言两者相等。执行你想要测试的操作，并断言结果。最后，断言原始对象和副本仍然相等。
- en: 'Let''s put this into practice and test the side-effect-free implementation
    of our add method in the `Money` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个应用到实践中，并测试 `Money` 类中 add 方法的无副作用实现：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Persisting Value Objects
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化值对象
- en: Value Objects are not persisted on their own; they're typically persisted within
    an Aggregate. Value Objects shouldn't be persisted as complete records, though
    that's an option in some cases. Instead, it's best to use Embedded Value or Serialize
    LOB patterns. Both patterns can be used when persisting your objects with an open
    source ORM such as Doctrine, or with a bespoke ORM. As Value Objects are small,
    Embedded Value is usually the best choice because it provides an easy way to query
    Entities by any of the attributes the Value Object has. However, if querying by
    those fields isn't important to you, serialize strategies can be very easy to
    implement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象自身不进行持久化；它们通常在聚合（Aggregate）内部进行持久化。尽管在某些情况下可以选择将其作为完整记录进行持久化，但值对象不应作为完整记录进行持久化。相反，最好使用嵌入式值（Embedded
    Value）或序列化 LOB 模式。这两种模式都可以在持久化对象时使用开源 ORM，如 Doctrine，或定制 ORM。由于值对象较小，嵌入式值通常是最佳选择，因为它提供了一种通过值对象具有的任何属性查询实体的简单方法。然而，如果您不重视通过这些字段进行查询，序列化策略可以非常容易实现。
- en: 'Consider the following `Product` Entity with string id, `name`, and `price`
    (`Money` Value Objects) attributes. We''ve intentionally decided to simplify this
    example, with the id being a string and not a Value Object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有字符串 id、`name` 和 `price`（`Money` 值对象）属性的 `Product` 实体。我们故意决定简化这个例子，将 id
    设计为字符串而不是值对象：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Assuming you have a [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories* for
    persisting `Product` Entities, an implementation to create and persist a new `Product`
    could look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个 [第 10 章](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)，用于持久化 `Product`
    实体的 *仓库*，创建和持久化一个新的 `Product` 的实现可能看起来像这样：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now let's look at both the ad hoc ORM and the Doctrine implementations that
    could be used to persist a `Product` Entity containing Value Objects. We'll highlight
    the application of the Embedded Value and Serialized LOB patterns, along with
    the differences between persisting a single Value Object and a collection of them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看可以用来持久化包含值对象的 `Product` 实体的临时性 ORM 和 Doctrine 实现。我们将突出嵌入式值和序列化 LOB 模式的应用，以及持久化单个值对象和它们的集合之间的差异。
- en: Why Doctrine?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择 Doctrine？
- en: The [Doctrine](http://www.doctrine-project.org/projects/orm.html) is a great
    ORM. It solves 80 percent of the requirements a PHP application faces. It has
    a great community. With a correctly tuned setup, it can perform the same or even
    better than a bespoke ORM (without losing maintainability). We recommend using
    Doctrine in most cases when dealing with Entities and business logic. It will
    save you a lot of time and headaches.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[Doctrine](http://www.doctrine-project.org/projects/orm.html) 是一个优秀的 ORM。它解决了
    PHP 应用面临的大部分需求。它拥有一个庞大的社区。通过正确调优的设置，它可以与定制 ORM（不失去可维护性）的性能相同，甚至更好。我们建议在处理实体和业务逻辑时，大多数情况下使用
    Doctrine。这将为您节省大量时间和精力。'
- en: Persisting Single Value Objects
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化单个值对象
- en: Many different options are available for persisting a single Value Object. These
    range from using Serialize LOB or Embedded Value as mapping strategies, to using
    an Ad Hoc ORM or an open source alternative, such as Doctrine. We consider an
    Ad Hoc ORM to be a custom-built ORM that your company may have developed in order
    to persist Entities in a database. In our scenario, the Ad Hoc ORM code is going
    to be implemented using the [DBAL](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/) library.
    According to the [official documentation](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/introduction.html),
    The **Doctrine Database Abstraction** & **Access Layer **(**DBAL**) offers a lightweight
    and thin runtime layer around a PDO-like API and a lot of additional, horizontal
    features like database schema introspection and manipulation through an OO API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于持久化单个值对象，有许多不同的选项。这些选项从使用序列化 LOB 或嵌入式值作为映射策略，到使用临时性 ORM 或开源替代品，如 Doctrine。我们认为临时性
    ORM 是公司可能为了在数据库中持久化实体而开发的定制 ORM。在我们的场景中，临时性 ORM 代码将使用 [DBAL](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/)
    库来实现。根据 [官方文档](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/introduction.html)，**Doctrine
    数据库抽象** & **访问层**（**DBAL**）在类似 PDO 的 API 周围提供了一个轻量级且薄的运行时层，以及许多额外的横向功能，如通过面向对象的
    API 进行数据库模式自省和操作。
- en: Embedded Value with an Ad Hoc ORM
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用临时性 ORM 的嵌入式值
- en: 'If we''re dealing with an Ad Hoc ORM using the Embedded Value pattern, we need
    to create a field in the Entity table for each attribute in the Value Object.
    In this case, two extra columns are needed when persisting a `Product` Entity
    — one for the amount of the Value Object, and one for its currency ISO code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是使用嵌入式值模式的Ad Hoc ORM，我们需要在实体表中为值对象中的每个属性创建一个字段。在这种情况下，当持久化`Product`实体时需要两个额外的列——一个用于值对象的金额，另一个用于其货币ISO代码：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For persisting the Entity in the database, our [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml),
    *Repositories* has to map each of the fields of the Entity and the ones from the
    `Money` Value Object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据库中持久化实体，我们的[第10章](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)，*存储库*必须映射实体和`Money`值对象中的每个字段。
- en: 'If you''re using an `Ad hoc ORM` Repository based on DBAL—let''s call it `DbalProductRepository`—you
    must take care of creating the `INSERT` statement, binding the parameters, and
    executing the statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用基于DBAL的Ad hoc ORM存储库——让我们称它为`DbalProductRepository`——您必须注意创建`INSERT`语句，绑定参数，并执行该语句：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After executing this snippet of code to create a `Products` Entity and persist
    it into the database, each column is filled with the desired information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此代码片段以创建`Products`实体并将其持久化到数据库后，每个列都填充了所需的信息：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, you can map your Value Objects and query parameters in an `Ad
    hoc` manner in order to persist your Value Objects. However, everything is not
    as easy as it seems. Let''s try to fetch the persisted Product with its associated
    `Money` Value Object. A common approach would be to execute a `SELECT` statement
    and return a new Entity:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以通过Ad hoc方式映射您的值对象和查询参数，以持久化您的值对象。然而，事情并不像看起来那么简单。让我们尝试获取带有其关联的`Money`值对象的持久化产品。一个常见的方法是执行一个`SELECT`语句并返回一个新的实体：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are some benefits to this approach. First, you can easily read, step by
    step, how the persistence and subsequent creations occur. Second, you can perform
    queries based on any of the attributes of the Value Object. Finally, the space
    required to persist the Entity is just what is required — no more and no less.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些好处。首先，您可以轻松地逐步阅读持久化和随后的创建过程。其次，您可以根据值对象的任何属性执行查询。最后，持久化实体的空间需求正好是所需的——不多也不少。
- en: However, using the ad hoc ORM approach has its drawbacks. As explained in the
    [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*, Entities
    (in Aggregate form) should fire an Event in the constructor if your Domain is
    interested in the Aggregate's creation. If you use the new operator, you'll be
    firing the Event as many times as the Aggregate is fetched from the database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用Ad hoc ORM方法有其缺点。如[第6章](607255c5-e619-4398-94bb-484c008472b7.xhtml)中所述，*领域事件*，实体（以聚合形式）应该在构造函数中触发事件，如果您的领域对聚合的创建感兴趣。如果您使用新操作符，您将根据从数据库中获取聚合的次数触发事件。
- en: 'This is one of the reasons why Doctrine uses internal proxies and `serialize`
    and `unserialize` methods to reconstitute an object with its attributes in a specific
    state without using its constructor. An Entity should only be created with the
    new operator once in its lifetime:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Doctrine使用内部代理和`serialize`以及`unserialize`方法来在不使用构造函数的情况下，以特定状态重新构成一个对象及其属性的原因之一。一个实体在其生命周期中应该只使用新操作符创建一次：
- en: Constructors
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数
- en: Constructors don't need to include a parameter for each attribute in the object.
    Think about a blog post. A constructor may need an id and a title; however, internally
    it can also be setting its status attribute to draft. When publishing the post,
    a publish method should be called in order to alter its status accordingly and
    set a published date.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不需要为对象中的每个属性包含一个参数。考虑一下博客文章。构造函数可能需要一个id和一个标题；然而，在内部它也可以设置其状态属性为草稿。当发布文章时，应该调用发布方法以相应地更改其状态并设置发布日期。
- en: If your intention is still to roll out your own ORM, be ready to solve some
    fundamental problems such as Events, different constructors, Value Objects, lazy
    load relations, and so on. That's why we recommend giving Doctrine a try for Domain-Driven
    Design applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的意图仍然是推出您自己的ORM，请准备好解决一些基本问题，例如事件、不同的构造函数、值对象、延迟加载关系等。这就是为什么我们建议为领域驱动设计应用程序尝试使用Doctrine。
- en: Besides, in this instance, you need to create a `DbalProduct` Entity that extends
    from the `Product` Entity and is able to reconstitute the Entity from the database
    without using the new operator, instead using a static factory method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个例子中，您需要创建一个继承自`Product`实体并能够从数据库中重新构成实体的`DbalProduct`实体，而不使用新操作符，而是使用静态工厂方法。
- en: Embedded Value (Embeddables) with Doctrine >= 2.5.*
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine >= 2.5.*中的嵌入式值（Embeddables）
- en: The latest stable Doctrine release is currently *version 2.5* and it comes with
    support for mapping Value Objects, thereby removing the need to do this yourself
    as in *Doctrine 2.4*. Since December 2015, Doctrine also has support for nested
    embeddables. The support is not 100 percent, but it's high enough to give it a
    try. In case it doesn't work for your scenario, take a look at the next section.
    For official documentation, check the Doctrine [Embeddables reference](http://doctrine-orm.readthedocs.org/en/latest/tutorials/embeddables.html).
    This option, if implemented correctly, is definitely the one we recommend most.
    It would be the simplest, most elegant solution, that also provides search support
    in your *DQL* queries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最新的稳定Doctrine版本是*版本 2.5*，它提供了映射值对象的支持，从而消除了在*Doctrine 2.4*中自己执行此操作的需求。自2015年12月以来，Doctrine还支持嵌套嵌入式对象。虽然支持率不是100%，但已经足够高，可以尝试一下。如果它不适合您的场景，请查看下一节。对于官方文档，请查看Doctrine
    [嵌入式对象参考](http://doctrine-orm.readthedocs.org/en/latest/tutorials/embeddables.html)。如果正确实现，这绝对是我们最推荐的选择。这将是一个最简单、最优雅的解决方案，同时也为您的*DQL*查询提供了搜索支持。
- en: 'Because the `Product`, `Money`, and `Currency` classes have already been shown,
    the only thing remaining is to show the Doctrine mapping files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Product`、`Money`和`Currency`类已经展示过，剩下要展示的只是Doctrine映射文件：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the product mapping, we''re defining `price` as an instance variable that
    will hold a `Money` instance. At the same time, `Money` is designed with an amount
    and a `Currency` instance:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品映射中，我们定义`price`为一个实例变量，它将保存一个`Money`实例。同时，`Money`被设计为一个金额和一个`Currency`实例：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, it''s time to show the Doctrine mapping for our `Currency` Value Object:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候展示我们的`Currency`值对象的Doctrine映射了：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the above code has a standard embeddable definition with just
    one string field that holds the ISO code. This approach is the easiest way to
    use embeddables and is much more effective. By default, Doctrine names your columns
    by prefixing them using the Value Object name. You can change this behavior to
    meet your needs by changing the column-prefix attribute in the XML notation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上述代码具有一个标准的可嵌入定义，只需一个字符串字段来存储ISO代码。这种方法是使用可嵌入对象的最简单方式，并且效果更佳。默认情况下，Doctrine通过在对象名称前加前缀来命名您的列。您可以通过更改XML表示法中的列前缀属性来更改此行为以满足您的需求。
- en: Embedded Value with Doctrine <= 2.4.*
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine <= 2.4.*中的嵌入式值
- en: 'If you''re still stuck in *Doctrine 2.4*, you may wonder what an acceptable
    solution for using Embedded Values with *Doctrine < 2.5* is. We need to now surrogate
    all the Value Object attributes in the `Product` Entity, which means creating
    new artificial attributes that will hold the information of the Value Object.
    With this in place, we can map all those new attributes using Doctrine. Let''s
    see what impact this has on the `Product` Entity:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然停留在*Doctrine 2.4*，您可能会想知道使用*Doctrine < 2.5*的嵌入式值的可接受解决方案是什么。现在我们需要在`Product`实体中代理所有值对象属性，这意味着创建新的人工属性来保存值对象的信息。有了这个，我们可以使用Doctrine映射所有这些新属性。让我们看看这对`Product`实体有什么影响：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, there are two new attributes: one for the amount, and another
    for the ISO code of the currency. We''ve also updated the `setPrice` method in
    order to keep attribute consistency when setting it. On top of this, we updated
    the price getter in order to return the `Money` Value Object built from the new
    fields. Let''s see how the corresponding XML Doctrine mapping should be changed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有两个新属性：一个用于金额，另一个用于货币的ISO代码。我们还更新了`setPrice`方法，以便在设置时保持属性一致性。在此基础上，我们还更新了价格获取器，以便返回由新字段构建的`Money`值对象。让我们看看相应的XML
    Doctrine映射应该如何更改：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Surrogate Attributes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代理属性
- en: These two new fields don't strictly belong to the Domain, as they don't refer
    to Infrastructure details. Rather, they're a necessity due to the lack of embeddable
    support in Doctrine. There are alternatives that can push these two attributes
    outside the pure Domain; however, this approach is simpler, easier, and, as a
    tradeoff, acceptable. There's another use of surrogate attributes in this book;
    you can find it in  the sub-section *Surrogate Identity* of the section *Identity
    Operation* of [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml)*, Entities*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新字段并不严格属于域，因为它们不引用基础设施细节。相反，它们是由于Doctrine缺乏可嵌入支持而成为必要的。有其他方法可以将这两个属性推到纯域之外；然而，这种方法更简单、更容易，并且作为权衡，是可以接受的。本书中还有另一种代理属性的使用；你可以在[第4章](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml)的“实体”部分的*代理身份*子部分中找到它。
- en: If we wanted to push these two attributes outside of the Domain, this could
    be achieved through the use of an [Abstract Factory](http://en.wikipedia.org/wiki/Abstract_factory_pattern).
    First, we need to create a new Entity, `DoctrineProduct`, in our Infrastructure
    folder. This Entity will extend from `Product` Entity. All surrogate fields will
    be placed in the new class, and methods such as price or `setPrice` should be
    reimplemented. We'll map Doctrine to use the new `DoctrineProduct` as opposed
    to the `Product` Entity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将这两个属性推到域之外，可以通过使用[抽象工厂](http://en.wikipedia.org/wiki/Abstract_factory_pattern)来实现。首先，我们需要在我们的基础设施文件夹中创建一个新的实体，`DoctrineProduct`。这个实体将扩展自`Product`实体。所有代理字段都将放置在新类中，并且像价格或`setPrice`这样的方法应该被重新实现。我们将映射Doctrine使用新的`DoctrineProduct`而不是`Product`实体。
- en: Now we're able to fetch Entities from the database, but what about creating
    a new `Product`? At some point, we're required to call new `Product`, but because
    we need to deal with `DoctrineProduct` and we don't want our Application Services
    to know about Infrastructure details, we'll need to use Factories to create `Product`
    Entities. So, in every instance where Entity creation occurs with new, you'll
    instead call `createProduct` on `ProductFactory`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从数据库中检索实体，但创建一个新的`Product`呢？在某个时候，我们需要调用新的`Product`，但由于我们需要处理`DoctrineProduct`，并且我们不希望我们的应用程序服务了解基础设施细节，因此我们需要使用工厂来创建`Product`实体。所以，在每次使用`new`创建实体的情况下，你将调用`ProductFactory`上的`createProduct`。
- en: There could be many additional classes required to avoid placing the surrogate
    attributes in the original Entity. As such, it's our recommendation to surrogate
    all the Value Objects to the same Entity, though this admittedly leads to a less
    pure solution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将代理属性放置在原始实体中，可能需要许多额外的类。因此，我们建议将所有值对象代理到同一个实体中，尽管这确实会导致一个不那么纯粹的解决方案。
- en: Serialized LOB and Ad Hoc ORM
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化LOB和Ad Hoc ORM
- en: 'If the addition of searching capabilities to the Value Objects attributes is
    not important, there''s another pattern that can be considered: the Serialized
    LOB. This pattern works by serializing the whole Value Object into a string format
    that can easily be persisted and fetched. The most significant difference between
    this solution and the embedded alternative is that in the latter option, the persistence
    footprint requirements are reduced to a single column:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向值对象属性添加搜索功能并不重要，可以考虑另一种模式：序列化LOB。这种模式通过将整个值对象序列化为一个字符串格式，该格式可以轻松持久化和检索。与嵌入式替代方案相比，这种解决方案的最显著区别在于，在后者中，持久化足迹需求减少到单个列：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to persist the `Product` Entities using this approach, a change in
    the `DbalProductRepository` is required. The `Money` Value Object must be serialized
    into a string before persisting the `final` Entity:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种方法持久化`Product`实体，需要对`DbalProductRepository`进行更改。在持久化`final`实体之前，必须将`Money`值对象序列化为字符串：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see how our Product is now represented in the database. The table column
    `price` is a `TEXT` type column that contains a serialization of a `Money` object
    representing 9.99 USD:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的产品现在在数据库中的表示。表列`price`是一个`TEXT`类型的列，其中包含表示9.99美元的`Money`对象的序列化：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This approach does the job. However, it's not recommended due to problems occurring
    when refactoring classes in your code. Could you imagine the problems if we decided
    to rename our `Money` class? Could you imagine the changes that would be required
    in our database representation when moving the `Money` class from one namespace
    to another? Another tradeoff, as explained before, is the lack of querying capabilities.
    It doesn't matter whether you use Doctrine or not; writing a query to get the
    products cheaper than, say, 200 USD is almost impossible while using a serialization
    strategy.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以完成任务。然而，由于在代码中重构类时可能出现问题，因此不推荐使用。你能想象如果我们决定重命名我们的`Money`类会出现什么问题吗？你能想象当我们把`Money`类从一个命名空间移动到另一个命名空间时，我们的数据库表示需要做出哪些更改吗？另一个权衡，如前所述，是缺乏查询能力。无论你是否使用Doctrine，使用序列化策略时，编写一个查询以获取比200美元便宜的产品几乎是不可能的。
- en: The querying issue can only be solved by using Embedded Values. However, the
    serialization refactoring problems can be fixed using a specialized library for
    handling serialization processes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查询问题只能通过使用嵌入式值来解决。然而，可以通过用于处理序列化过程的专用库来解决序列化重构问题。
- en: Improved Serialization with JMS Serializer
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMS Serializer改进序列化
- en: 'The serialize/unserialize native PHP strategies have a problem when dealing
    with class and namespace refactoring. One alternative is to use your own serialization
    mechanism —  for example, concatenating the amount, a one character separator
    such as `|`, and the currency ISO code. However, there''s another favored approach:
    using an open source serializer library such as [JMS Serializer](http://jmsyst.com/libs/serializer).
    Let''s see an example of applying it when serializing a `Money` object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理类和命名空间重构时，序列化/反序列化原生的PHP策略存在问题。一个替代方案是使用你自己的序列化机制——例如，将数量、一个字符分隔符（如`|`）和货币ISO代码连接起来。然而，还有一个更受欢迎的方法：使用开源序列化库，如[JMS
    Serializer](http://jmsyst.com/libs/serializer)。让我们看看在序列化`Money`对象时应用它的一个例子：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to unserialize the object, the process is straightforward:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化对象，过程很简单：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this example, you can refactor your `Money` class without having to update
    your database. JMS Serializer can be used in many different scenarios — for example,
    when working with REST APIs. An important feature is the ability to specify which
    attributes of an object should be omitted in the serialization process — for example,
    a password.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，你可以重构你的`Money`类，而无需更新你的数据库。JMS Serializer可以在许多不同的场景中使用——例如，当与REST API一起工作时。一个重要特性是能够指定在序列化过程中应该省略对象哪些属性——例如，密码。
- en: Check out the [Mapping Reference](http://jmsyst.com/libs/serializer/master/reference/xml_reference) and
    the [Cookbook](http://jmsyst.com/libs/serializer/master/cookbook) for more information.
    JMS Serializer is a must in any Domain-Driven Design project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅[映射参考](http://jmsyst.com/libs/serializer/master/reference/xml_reference)和[食谱](http://jmsyst.com/libs/serializer/master/cookbook)以获取更多信息。JMS
    Serializer在任何领域驱动设计项目中都是必不可少的。
- en: Serialized LOB with Doctrine
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Doctrine序列化LOB
- en: In Doctrine, there are different ways of serializing objects in order to eventually
    persist them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Doctrine中，有不同方式序列化对象以便最终持久化。
- en: Doctrine Object Mapping Type
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine 对象映射类型
- en: Doctrine has support for the Serialize LOB pattern. There are plenty of predefined
    mapping types you can use in order to match Entity attributes with database columns
    or even tables. One of those mappings is the object type, which maps an SQL CLOB
    to a PHP object using `serialize()` and `unserialize()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine支持序列化LOB模式。有许多预定义的映射类型你可以使用，以便将实体属性与数据库列或表匹配。其中一种映射是对象类型，它使用`serialize()`和`unserialize()`将SQL
    CLOB映射到PHP对象。
- en: 'According to the [Doctrine DBAL 2 Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-dbal/en/latest/reference/types.html#object),
    `object` type:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[Doctrine DBAL 2 文档](http://doctrine-orm.readthedocs.io/projects/doctrine-dbal/en/latest/reference/types.html#object)，`object`类型：
- en: Maps and converts object data based on PHP serialization. If you need to store
    an exact representation of your object data, you should consider using this type
    as it uses serialization to represent an exact copy of your object as string in
    the database. Values retrieved from the database are always converted to PHP's
    object type using unserialization or null if no data is present.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PHP序列化映射和转换对象数据。如果你需要存储你对象数据的精确表示，你应该考虑使用此类型，因为它使用序列化来在数据库中以字符串形式表示你对象的精确副本。从数据库检索的值始终通过反序列化转换为PHP的对象类型，如果没有数据则转换为null。
- en: This type will always be mapped to the database vendor's text type internally
    as there is no way of storing a PHP object representation natively in the database.
    Furthermore this type requires a SQL column comment hint so that it can be reverse
    engineered from the database. Doctrine cannot correctly map back this type correctly
    using vendors that do not support column comments, and will instead fall back
    to the text type instead.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法在数据库中本地存储 PHP 对象表示，此类型将始终映射到数据库供应商的文本类型。此外，此类型需要一个 SQL 列注释提示，以便可以从数据库中反向工程。如果供应商不支持列注释，Doctrine
    无法正确映射此类型，并将回退到文本类型。
- en: Because the built-in text type of `PostgreSQL` does not support NULL bytes,
    the object type will result in unserialization errors. A workaround to this problem
    is to `serialize()/unserialize()` and `base64_encode()/base64_decode()` PHP objects
    and store them into a text field manually.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PostgreSQL 内置的文本类型不支持 NULL 字节，对象类型将导致反序列化错误。解决这个问题的一个方法是手动将 PHP 对象 `serialize()/unserialize()`
    和 `base64_encode()/base64_decode()` 存储到文本字段中。
- en: 'Let''s look at a possible XML mapping for the Product Entity by using the object
    type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用对象类型来查看为产品实体可能的 XML 映射：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The key addition is `type="object"`, which tells Doctrine that we''re going
    to be using an object mapping. Let''s see how we could create and persist a `Product`
    Entity using Doctrine:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关键新增是 `type="object"`，它告诉 Doctrine 我们将使用对象映射。让我们看看我们如何使用 Doctrine 创建和持久化 `Product`
    实体：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s check that if we now fetch our `Product` Entity from the database, it''s
    returned in an expected state:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下，如果我们现在从数据库中检索 `Product` 实体，它是否以预期的状态返回：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Last but not least, the [Doctrine DBAL 2 Documentation](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#doctrine-mapping-types) states
    that:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，[Doctrine DBAL 2 文档](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#doctrine-mapping-types)
    指出：
- en: Object types are compared by reference, not by value. Doctrine updates this
    value if the reference changes and therefore behaves as if these objects are immutable
    value objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型是通过引用比较的，而不是通过值。当引用改变时，Doctrine 会更新这个值，因此表现得像这些对象是不可变值对象。
- en: This approach suffers from the same refactoring issues as the Ad hoc ORM did.
    The object mapping type is internally using `serialize/unserialize`. What about
    instead using our own serialization?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与临时性 ORM 所遇到的重构问题相同。对象映射类型内部使用 `serialize/unserialize`。那么，我们是否可以使用自己的序列化方法呢？
- en: Doctrine Custom Types
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine 自定义类型
- en: Another option is to handle the Value Object persistence using a Doctrine Custom
    Type. A Custom Type adds a new mapping type to Doctrine — one that describes a
    custom transformation between an Entity field and the database representation,
    in order to persist the former.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 Doctrine 自定义类型来处理值对象的持久化。自定义类型向 Doctrine 添加了一个新的映射类型——它描述了实体字段与数据库表示之间的自定义转换，以便持久化前者。
- en: 'As the [Doctrine DBAL 2 Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-dbal/en/latest/reference/types.html#custom-mapping-types)
    explains:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [Doctrine DBAL 2 文档](http://doctrine-orm.readthedocs.io/projects/doctrine-dbal/en/latest/reference/types.html#custom-mapping-types)
    所解释：
- en: Just redefining how database types are mapped to all the existing Doctrine types
    is not at all that useful. You can define your own Doctrine Mapping Types by extending
    `Doctrine\DBAL\Types\Type`. You are required to implement 4 different methods
    to get this working.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仅重新定义数据库类型如何映射到所有现有的 Doctrine 类型并不十分有用。你可以通过扩展 `Doctrine\DBAL\Types\Type` 来定义自己的
    Doctrine 映射类型。你需要实现 4 个不同的方法才能使其工作。
- en: With the object type, the serialization step includes information, such as the
    class, that makes it quite difficult to safely refactor our code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象类型，序列化步骤包括诸如类等信息，这使得安全重构我们的代码变得相当困难。
- en: Let's try to improve on this solution. Think about a custom serialization process
    that could solve the problem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改进这个解决方案。考虑一个自定义序列化过程，它可以解决这个问题。
- en: 'One such way could be to persist the `Money` Value Object as a string in the
    database encoded in `amount|isoCode` format:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是将 `Money` 值对象以 `amount|isoCode` 格式编码为字符串持久化到数据库中：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using Doctrine, you're required to register all Custom Types. It's common to
    use an `EntityManagerFactory` that centralizes this `EntityManager` creation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Doctrine，你需要注册所有自定义类型。通常使用一个 `EntityManagerFactory` 来集中创建这个 `EntityManager`。
- en: 'Alternatively, you could perform this step by bootstrapping your application:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过引导应用程序来执行这一步：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we need to specify in the mapping that we want to use our Custom Type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在映射中指定我们想要使用我们的自定义类型：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why Use XML Mapping?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 XML 映射？
- en: Thanks to the XSD schema validation in the headers of the XML mapping file,
    many **Integrated Development Environment **(**IDEs**) setups provide auto-complete
    functionality for all the elements and attributes present in the mapping definition.
    However, in other parts of the book, we use YAML to show a different syntax.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 XML 映射文件头部的 XSD 架构验证，许多 **集成开发环境（IDEs**） 设置提供了对映射定义中所有元素和属性的自动完成功能。然而，在其他部分的书里，我们使用
    YAML 来展示不同的语法。
- en: 'Let''s check the database to see how the price was persisted using this approach:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查数据库，看看使用这种方法是如何持久化价格的：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This approach is an improvement on the one before in terms of future refactoring.
    However, searching capabilities remain limited due to the format of the column.
    With the Doctrine Custom types, you can improve the situation a little, but it's
    still not the best option for building your DQL queries. See [Doctrine Custom
    Mapping Types](http://doctrine-orm.readthedocs.org/en/latest/cookbook/custom-mapping-types.html) for
    more information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，这种方法在未来的重构方面有所改进。然而，由于列的格式，搜索能力仍然有限。使用 Doctrine 自定义类型，你可以稍微改善这种情况，但这仍然不是构建你的
    DQL 查询的最佳选项。有关更多信息，请参阅 [Doctrine 自定义映射类型](http://doctrine-orm.readthedocs.org/en/latest/cookbook/custom-mapping-types.html)。
- en: Time to Discuss
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论时间
- en: Think about and discuss with a peer how would you create a Doctrine Custom Type
    using JMS to `serialize` and `unserialize` a Value Object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 思考并与同伴讨论如何使用 JMS `序列化` 和 `反序列化` 值对象来创建 Doctrine 自定义类型。
- en: Persisting a Collection of Value Objects
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化值对象集合
- en: 'Imagine that we''d now like to add a collection of prices to be persisted to
    our `Product` Entity. These prices could represent the different prices the product
    has borne throughout its lifetime or the product price in different currencies.
    This could be named `HistoricalPrice`, as shown below:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想向我们的 `Product` 实体添加一个要持久化的价格集合。这些价格可能代表产品在其生命周期中承担的不同价格，或者不同货币中的产品价格。这可以命名为
    `HistoricalPrice`，如下所示：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`HistoricalProduct` extends from `Product`, so it inherits the same behavior,
    plus the price collection functionality.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistoricalProduct` 从 `Product` 继承，因此继承了相同的行为，以及价格集合功能。'
- en: As in the previous sections, serialization is a plausible approach if you don't
    care about querying capabilities. However, Embedded Values are a possibility if
    we know exactly how many prices we want to persist. But what happens if we want
    to persist an undetermined collection of historical prices?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，如果你不关心查询能力，序列化是一个可行的方案。然而，如果我们知道要持久化的价格数量，嵌入式值是一个可能的选择。但如果我们想持久化一个不确定数量的历史价格会发生什么呢？
- en: Collection Serialized into a Single Column
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合序列化到单个列
- en: 'Serializing a collection of Value Objects into a single column is most likely
    the easiest solution. Everything that was previously explained in the section
    about persisting a single Value Object applies in this situation. With Doctrine,
    you can use an Object or Custom Type — with some additional considerations to
    bear in mind: Value Objects should be small in size, but if you wish to persist
    a large collection, be sure to consider the maximum column length and the maximum
    row width that your database engine can handle.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将值对象集合序列化到单个列中可能是最简单的解决方案。在关于持久化单个值对象的章节中解释的所有内容都适用于这种情况。使用 Doctrine，你可以使用对象或自定义类型——但需要考虑一些额外的因素：值对象应该体积小，但如果你想持久化大量集合，请确保考虑数据库引擎可以处理的最大列长度和最大行宽度。
- en: Exercise
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Come up with both `Doctrine` Object Type and `Doctrine Custom` Type implementation
    strategies for persisting a Product with different prices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 提出使用 `Doctrine` 对象类型和 `Doctrine 自定义` 类型实现策略，以不同价格持久化一个产品。
- en: Collection Backed by a Join Table
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由连接表支持的集合
- en: In case you want to persist and query an Entity by its related Value Objects,
    you have the choice to persist the Value Objects as Entities. In terms of the
    Domain, those objects would still be Value Objects, but we'll need to give them
    an id and set them up with a one-to-many/one-to-one relation with the owner, a
    real Entity. To summarize, your ORM handles the collection of Value Objects as
    Entities, but in your Domain, they're still treated as Value Objects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过其相关值对象（Value Objects）持久化和查询实体（Entity），你可以选择将值对象作为实体持久化。在领域（Domain）方面，这些对象仍然是值对象，但我们需要给它们一个id，并将它们与拥有者（owner）建立一个一对一/一对多（one-to-many/one-to-one）的关系，即一个真正的实体。总结来说，你的对象关系映射（ORM）将值对象集合作为实体处理，但在你的领域（Domain）中，它们仍然被视为值对象。
- en: 'The main idea behind the Join Table strategy is to create a table that connects
    the owner Entity and its Value Objects. Let''s see a database representation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表策略背后的主要思想是创建一个连接所有者实体（owner Entity）及其值对象的表。让我们看看数据库表示：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `historical_products` table will look the same as products. Remember that
    `HistoricalProduct` extends `Product` Entity in order to easily show how to deal
    with persisting a collection. A new prices table is now required in order to persist
    all the different `Money` Value Objects that a `Product` Entity can handle:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`historical_products`表将与产品表看起来相同。记住，`HistoricalProduct`扩展了`Product`实体，以便更容易地展示如何处理持久化集合。现在需要一个新表来持久化`Product`实体可以处理的所有的不同`Money`值对象：'
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, a table that relates products and prices is needed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要一个关联产品和价格的表：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Collection Backed by a Join Table with Doctrine
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由连接表支持的集合与Doctrine
- en: 'Doctrine requires that all database Entities have a unique identity. Because
    we want to persist `Money` Value Objects, we need to then add an artificial identity
    so Doctrine can handle its persistence. There are two options: including the surrogate
    identity in the `Money` Value Object, or placing it in an extended class.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine要求所有数据库实体都有一个唯一标识符。因为我们想持久化`Money`值对象，所以我们需要添加一个人工标识符，这样Doctrine才能处理其持久化。有两种选择：在`Money`值对象中包含代理标识符，或者将其放在扩展类中。
- en: The issue with the first option is that the new identity is only required due
    to the Database persistence layer. This identity is not part of the Domain.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项的问题是新身份标识（new identity）仅由于数据库持久化层（Database persistence layer）的需要。这个身份标识不是领域的一部分。
- en: An issue with the second option is the amount of alterations required in order
    to avoid this so-called boundary leak. With a class extension, creating new instances
    of the `Money` Value Object class from any Domain Object isn't recommended, as
    it would break the Inversion Principle. The solution is to again create a `Money`
    Factory that would need to be passed into Application Services and any other Domain
    Objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项的问题是需要进行大量的修改以避免所谓的边界泄露（boundary leak）。由于创建`Money`值对象类的新实例会违反反转原则（Inversion
    Principle），因此不建议从任何领域对象（Domain Object）中创建`Money`值对象类的新实例。解决方案是再次创建一个`Money`工厂（Factory），该工厂需要传递给应用程序服务（Application
    Services）和任何其他领域对象。
- en: 'In this scenario, we recommend using the first option. Let''s review the changes
    required to implement it in the `Money` Value Object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们建议使用第一个选项。让我们回顾一下在`Money`值对象中实现它的所需更改：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As seen above, two new attributes have been added. The first one, `surrogateId`,
    is not used by our Domain, but it's required for the persistence Infrastructure
    to persist this Value Object as an Entity in our Database. The second one, `surrogateCurrencyIsoCode`,
    holds the ISO code for the currency. Using these new attributes, it's really easy
    to map our Value Object with Doctrine.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，已添加了两个新属性。第一个属性，`surrogateId`，在我们的领域（Domain）中不被使用，但它对于持久化基础设施（persistence
    Infrastructure）将此值对象（Value Object）作为实体（Entity）保存在我们的数据库中是必需的。第二个属性，`surrogateCurrencyIsoCode`，持有货币的ISO代码。使用这些新属性，将我们的值对象与Doctrine映射起来变得非常容易。
- en: 'The `Money` mapping is quite straightforward:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Money`映射相当直接：'
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using Doctrine, the `HistoricalProduct` Entity would have following mapping:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Doctrine，`HistoricalProduct`实体将具有以下映射：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Collection Backed by a Join Table with an Ad Hoc ORM
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由连接表支持的集合与临时对象关系映射（ORM）
- en: It's possible to do the same with an Ad hoc ORM, where Cascade `INSERTS` and
    `JOIN` queries are required. It's important to be careful about how the removal
    of Value Objects is handled, in order to not leave orphan  the `Money` Value Objects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时对象关系映射（Ad hoc ORM），其中需要级联`INSERTS`和`JOIN`查询，也可以做到同样的事情。重要的是要小心处理值对象的移除，以避免留下孤立的`Money`值对象。
- en: Exercise
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Think up a solution for `DbalHistoricalRepository` that would handle the persist
    method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为`DbalHistoricalRepository`想出一个处理持久化方法（persist method）的解决方案。
- en: Collection Backed by a Database Entity
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由数据库实体支持的集合
- en: Database Entity is the same solution as Join Table, with the addition of the
    Value Object that's only managed by the owner Entity. In the current scenario,
    consider that the `Money` Value Object is only used by the `HistoricalProduct`
    Entity; a Join Table would be overly complex. So the same result could be achieved
    using a one-to-many database relation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库实体与连接表是相同的解决方案，增加了仅由所有者实体管理的值对象。在当前场景中，考虑到`Money`值对象仅由`HistoricalProduct`实体使用；连接表将过于复杂。因此，可以使用一对一的数据库关系达到相同的结果。
- en: Exercise
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Think of the mapping required between `HistoricalProduct` and `Money` if a Database
    Entity approach is used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用数据库实体方法，请考虑`HistoricalProduct`和`Money`之间的映射需求。
- en: NoSQL
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL
- en: What about NoSQL mechanisms such as *Redis*, *MongoDB*, or *CouchDB*? Unfortunately,
    you can't escape these problems. In order to persist an Aggregate using *Redis*,
    you need to serialize it into a string before setting the value. If you use PHP
    `serialize`/`unserialize` methods, you'll face namespace or class name refactoring
    issues again. If you choose to serialize in a custom way (JSON, custom string,
    and so on.), you'll be required to again rebuild the Value Object during *Redis*
    retrieval.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于像*Redis*、*MongoDB*或*CouchDB*这样的NoSQL机制呢？不幸的是，你无法避开这些问题。为了使用*Redis*持久化聚合，你需要在设置值之前将其序列化为字符串。如果你使用PHP的`serialize`/`unserialize`方法，你将再次面临命名空间或类名重构问题。如果你选择以自定义方式（JSON、自定义字符串等）进行序列化，你将需要在*Redis*检索期间再次重建值对象。
- en: PostgreSQL JSONB and MySQL JSON Type
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL JSONB和MySQL JSON类型
- en: 'If our database engine would allow us to not only use the Serialized LOB strategy
    but also search based on its value, we would have the best of both approaches.
    Well, good news: now you *can* do this. As of *PostgreSQL version 9.4*, support
    for [JSONB](http://www.postgresql.org/docs/9.4/static/functions-json.html) has
    been added. Value Objects can be persisted as JSON serializations and subsequently
    queried within this JSON serialization.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据库引擎不仅允许我们使用序列化LOB策略，而且还可以根据其值进行搜索，我们将拥有两种方法的最佳之处。好消息是：现在你可以这样做。从*PostgreSQL版本9.4*开始，已添加了对[JSONB](http://www.postgresql.org/docs/9.4/static/functions-json.html)的支持。值对象可以作为JSON序列化持久化，并在该JSON序列化中进行查询。
- en: 'MySQL has done the same. As of *MySQL 5.7.8*, MySQL supports a native JSON
    data type that enables efficient access to data in **JSON** (**JavaScript Object
    Notation**) documents. According to the [MySQL 5.7 Reference Manual](https://dev.mysql.com/doc/refman/5.7/en/json.html),
    the JSON data type provides these advantages over storing JSON-format strings
    in a string column:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL也做了同样的事情。从*MySQL 5.7.8*开始，MySQL支持一种原生JSON数据类型，它允许高效访问**JSON**（**JavaScript对象表示法**）文档中的数据。根据[MySQL
    5.7参考手册](https://dev.mysql.com/doc/refman/5.7/en/json.html)，JSON数据类型与在字符串列中存储JSON格式字符串相比具有以下优势：
- en: Automatic validation of JSON documents stored in JSON columns. Invalid documents
    produce an error.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动验证存储在JSON列中的JSON文档。无效的文档将产生错误。
- en: Optimized storage format. JSON documents stored in JSON columns are converted
    to an internal format that permits quick read access to document elements. When
    the server later must read a JSON value stored in this binary format, the value
    need not be parsed from a text representation. The binary format is structured
    to enable the server to look up subobjects or nested values directly by key or
    array index without reading all values before or after them in the document.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化存储格式。存储在JSON列中的JSON文档被转换为一种内部格式，允许快速读取文档元素。当服务器稍后必须读取以这种二进制格式存储的JSON值时，无需从文本表示中解析该值。这种二进制格式被结构化，以便服务器可以直接通过键或数组索引查找子对象或嵌套值，而无需读取文档中它们之前或之后的所有值。
- en: If Relational Databases add support for document and nested document searches
    with high performance and with all the benefits of an **Atomicity**, **Consistency**,
    **Isolation**, **Durability**(**ACID**) philosophy, it could save a lot of complexity
    in many projects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系数据库添加了对具有高性能和所有**原子性**、**一致性**、**隔离性**、**持久性**（**ACID**）哲学优势的文档和嵌套文档搜索的支持，它可以在许多项目中节省大量的复杂性。
- en: Security
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Another interesting detail of modeling your Domain concepts using Value Objects
    is regarding its security benefits. Consider an application within the context
    of selling flight tickets. If you deal with International Air Transport Association
    airport codes, also known as [IATA codes](https://en.wikipedia.org/wiki/International_Air_Transport_Association_airport_code),
    you can decide to use a string or model the concept using a Value Object. If you
    choose to go with the string, think about all the places where you'll be checking
    that the string is a valid IATA code. What's the chance you forget somewhere important?
    On the other hand, think about trying to instantiate new `IATA("BCN'; DROP TABLE
    users;--")`. If you centralize the *guards* in the constructor and then pass an
    IATA Value Object into your model, avoiding SQL Injections or similar attacks
    gets easier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值对象来建模你的领域概念的一个有趣细节是其安全优势。考虑一个在销售机票的上下文中的应用。如果你处理的是国际航空运输协会机场代码，也称为[IATA代码](https://en.wikipedia.org/wiki/International_Air_Transport_Association_airport_code)，你可以选择使用字符串或使用值对象来建模这个概念。如果你选择使用字符串，想想你会在哪些地方检查这个字符串是否是有效的IATA代码。你忘记在某个重要地方的概率有多大？另一方面，想想尝试实例化新的`IATA("BCN';
    DROP TABLE users;--")`。如果你在构造函数中集中了*守卫*，然后将IATA值对象传递到你的模型中，避免SQL注入或类似的攻击就会变得更容易。
- en: If you want to know more about the security side of Domain-Driven Design, you
    can follow [Dan Bergh Johnsson](https://twitter.com/danbjson) or read his [blog](http://dearjunior.blogspot.com.es/search/label/domain%20driven%20security).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于领域驱动设计安全方面的信息，你可以关注[Dan Bergh Johnsson](https://twitter.com/danbjson)或阅读他的[博客](http://dearjunior.blogspot.com.es/search/label/domain%20driven%20security)。
- en: Wrap-Up
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Using Value Objects for modeling concepts in your Domain that measure, quantify,
    or describe is highly recommended. As shown, Value Objects are easy to create,
    maintain, and test. In order to handle persistence within a Domain-Driven Design
    application, using an ORM is a must. However, in order to persist Value Objects
    using Doctrine, the preferred way is using embeddables. In case you''re stuck
    in *version 2.4*, there are two options: adding the Value Object fields directly
    into your Entity and mapping them (less elegant, but easier), or extending your
    Entities (far more elegant, but more complex).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的领域中用值对象建模那些测量、量化或描述的概念是非常推荐的。正如所示，值对象易于创建、维护和测试。为了在领域驱动设计应用中处理持久化，使用ORM是必须的。然而，为了使用Doctrine持久化值对象，首选的方式是使用内嵌对象。如果你卡在*版本2.4*，有两种选择：直接将值对象字段添加到你的实体中并映射它们（不那么优雅，但更容易），或者扩展你的实体（更加优雅，但更复杂）。
