- en: Chapter 6. Testing the API – PHPBrowser to the Rescue
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。测试 API – PHPBrowser 来拯救
- en: We are now going to delve into functional testing. In the previous chapter,
    we created the initial steps that deal with the user model, but now we will be
    creating the REST interface that deals with the user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将深入研究功能测试。在上一章中，我们创建了处理用户模型的初始步骤，但现在我们将创建处理用户的 REST 接口。
- en: Before we even start to worry about the REST interface and its tests, we will
    be analyzing what's already available in the Yii basic app and later expand on
    the topic to create more awesome stuff.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始担心 REST 接口及其测试之前，我们将分析 Yii 基本应用程序中已经可用的内容，并在此基础上扩展主题，创建更多精彩的内容。
- en: 'This chapter is hence divided into three sections with an increasing level
    of difficulty, so keep your eyes peeled and feel free to revisit it multiple times
    until you understand each section which are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章分为三个部分，难度逐渐增加，所以请保持警惕，并随时多次回顾，直到你理解每个部分，它们是：
- en: Functional tests in Yii 2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yii 2 的功能测试
- en: Functional tests for REST interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 接口的功能测试
- en: Creating a RESTful web service with Yii 2
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Yii 2 创建 RESTful Web 服务
- en: Functional tests in Yii 2
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yii 2 的功能测试
- en: As you saw in [Chapter 3](ch03.html "Chapter 3. Entering Codeception"), *Entering
    Codeception*, we have some basic functional tests preloaded in our basic application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 3 章](ch03.html "第 3 章。进入 Codeception")中看到的，*进入 Codeception*，我们在基本应用程序中预加载了一些基本的函数测试。
- en: Let's start digging into that and once you acquire the required knowledge, we're
    going to move on to the tests for the REST interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始深入挖掘，一旦你掌握了所需的知识，我们就会继续进行 REST 接口的测试。
- en: As you know, the basic application is composed of a few pages, a login system,
    and a contact form.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，基本应用程序由几个页面、登录系统和联系表单组成。
- en: The functional tests cover almost everything, so let's start to see what files
    we have and what's their content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试几乎涵盖了所有内容，所以让我们开始看看我们有哪些文件以及它们的内容。
- en: Understanding and improving the available CEPTs
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和改进现有的 CEPTs
- en: 'The tests contained in `codeception/functional/HomeCept.php` are quite straightforward
    to understand. Thanks to the syntax used by Codeception, you can easily understand
    what the intention of the test is, so let''s break it down and see what each bit
    does:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在 `codeception/functional/HomeCept.php` 中的测试非常容易理解。多亏了 Codeception 使用的语法，你可以轻松理解测试的意图，所以让我们分解一下，看看每一部分的作用：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You would start by initializing the actor under which the tests will be performed.
    Yii uses a slightly different naming than the one officially used in the documentation
    and guide of Codeception, which is `TestGuy`, so keep that in mind when you're
    confronted with documentation outside of Yii's.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先初始化将在其中执行测试的演员。Yii 使用与 Codeception 文档和指南中官方使用的名称略有不同，即 `TestGuy`，所以当你遇到
    Yii 之外的其他文档时，请记住这一点。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that you can name the actors whatever you want, and their configuration
    is found in the suite YAML file, which for functional tests is `tests/codeception/functional.suite.yml`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以随意命名演员，他们的配置可以在套件 YAML 文件中找到，对于功能测试，它位于 `tests/codeception/functional.suite.yml`。
- en: 'This class is located within the same folder as that of the other functional
    tests and is generated automatically by running `codecept build`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此类位于与其他功能测试相同的文件夹中，并且通过运行 `codecept build` 自动生成：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The very first step is to declare the scope of the test in a compact but detailed
    way; this will help you and non-technical people to understand what went wrong
    and if the test is effectively doing what it is meant to be doing in a strong
    and comprehensive way. The method `wantTo()` should be called only once, as any
    following invocations will override what has been set previously:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是简洁但详细地声明测试的范围；这将帮助你和非技术人员了解出了什么问题，以及测试是否有效地以强烈和全面的方式执行了其预期要执行的操作。`wantTo()`
    方法应该只调用一次，因为任何后续调用都将覆盖之前设置的值：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our tests need a starting point; the method `amOnPage()` does nothing but load
    the given URL where our actual test will take place:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试需要一个起点；`amOnPage()` 方法除了加载实际测试将进行的给定 URL 外，什么都不做：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Codeception, assertions are performed through `see*` and `dontSee*` actions,
    ensuring a particular portion of text or link is present/absent in the page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Codeception 中，断言是通过 `see*` 和 `dontSee*` 动作执行的，确保特定的文本或链接在页面中存在或不存在。
- en: These actions can be as descriptive as needed, and in the preceding example
    with `see('My Company')`, we are just checking that the text is present somewhere
    in the markup rather than in a particular tag while `seeLink('About')` would be
    the same as writing `see('About', 'a')`. We will shortly see that we could pass
    a second parameter to `seeLink()`, which will allow us to check the URL where
    the link should point to.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以根据需要描述得尽可能详细，在前面的示例中，使用`see('My Company')`我们只是检查文本是否存在于标记中，而不是特定的标签中，而`seeLink('About')`则等同于编写`see('About',
    'a')`。我们很快就会看到，我们可以向`seeLink()`传递第二个参数，这将允许我们检查链接应指向的URL。
- en: 'Interaction with the page in the form of triggering, clicking links with `click()`,
    filling fields with `fillField()`, `checkOption()`, `submitForm()`, and so on
    is all you can do with Codeception functional tests. Anything more complicated
    must be re-evaluated carefully, as you might actually need to move it into acceptance
    tests instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与页面的交互，如触发、使用`click()`点击链接、使用`fillField()`、`checkOption()`、`submitForm()`等填充字段，这些都是Codeception功能测试所能做到的。任何更复杂的事情都必须仔细重新评估，因为你实际上可能需要将其移动到验收测试中：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding lines, we are triggering the link of the "About" page and expecting
    that the resulting page has a specific copy in it. This specific test just makes
    a point in using links to navigate through our application, as it could have been
    done as described earlier by using `seeLink('About', '/about')` and to leave any
    assertion with the About page within its own test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们触发了“关于”页面的链接，并期望结果页面包含特定的副本。这个特定的测试只是说明了使用链接在我们的应用程序中导航的要点，因为它可以像前面描述的那样使用`seeLink('About',
    '/about')`完成，并且可以将关于页面的任何断言留在其自己的测试中。
- en: 'We might as well extend the test a bit more and make it more relevant to what
    we''re trying to test; what are the functionality parts that we want to make sure
    exist, without which we can consider the page "non-functional"? In our instance,
    we are talking about the title of the page (as it''s already been done), the menu,
    and any other links we always want to have there:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不妨将测试扩展得更多一些，使其与我们试图测试的内容更相关；我们想要确保存在的功能部分是什么，没有它们我们可以认为页面“非功能”？在我们的例子中，我们谈论的是页面的标题（因为它已经被处理过），菜单，以及我们总是希望在那里出现的任何其他链接：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The beginning is the same, but then we ensure that the title for the page contains
    what we expect it to be:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 开始是相同的，但然后我们确保页面的标题包含我们期望的内容：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next section instead makes sure that the menu contains all the required
    links to the various pages:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分确保菜单包含所有必要的链接到各个页面：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You have to keep in mind that the links are not strictly checked; this means
    that if you have `$I->seeLink('Something', '/something')`, it will match any link
    that contains `Something`; for example, it can be `Something Else` and any `href`
    attribute like `/something/else`, or even `http://something.com`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住，链接不是严格检查的；这意味着如果你有`$I->seeLink('Something', '/something')`，它将匹配任何包含`Something`的链接；例如，它可以是指`Something
    Else`的任何`href`属性，如`/something/else`，甚至`http://something.com`。
- en: 'In our case, it clearly renders the check for the link to the home page a bit
    irrelevant, so we might well grab the current URL and check against it in the
    following way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这显然使检查主页链接的相关性变得有些不相关，所以我们很可能会获取当前的URL，并以下述方式对其进行检查：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are different ways to grab content to be reused dynamically in the rest
    of the tests, such as `grabAttributeFrom()`, `grabCookie()`, `grabResponse()`,
    and so on. Once again, your `FunctionalTester` class will contain the details
    of these methods in case your IDE does not support code hinting.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以抓取要在测试的其余部分动态重用的内容，例如`grabAttributeFrom()`、`grabCookie()`、`grabResponse()`等。再次强调，如果你的IDE不支持代码提示，你的`FunctionalTester`类将包含这些方法的详细信息。
- en: 'We can do the same for any other link that is pointing to the homepage:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为指向主页的任何其他链接做同样的事情：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the rest of the links, it might also be useful to check that our routes
    are well configured; for instance, you need to check if the name of the controller
    doesn''t show up:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的链接，检查我们的路由是否配置良好也可能很有用；例如，你需要检查控制器的名称是否没有显示：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last bit we want to make sure of is that the `Home` link is marked as selected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后想要确保的是，`Home`链接被标记为选中。
- en: 'For this test, we need to use a very prescriptive selector as the active class
    that identifies the status of our link is in the parent of the actual anchor,
    and as there''s no way to assert that in a simple way, so making use of XPath
    expressions comes particularly handy:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们需要使用一个非常具体的选择器，因为标识我们链接状态的激活类位于实际锚点的父级中，而且没有简单的方法可以断言这一点，所以使用 XPath
    表达式特别有用：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Most of the methods available that require a context selector such as `click()`,
    `see()`, and, `seeElement()` can accept this parameter in various formats, mostly
    as CSS selectors, XPath queries or Locators, which are specific objects made available
    by Codeception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数需要上下文选择器的可用方法，如 `click()`、`see()` 和 `seeElement()`，可以接受此参数的多种格式，主要是作为 CSS
    选择器、XPath 查询或定位器，这些都是 Codeception 提供的特定对象。
- en: In its simplest form, selectors can be just a simple word or sentence, which
    means "find me the first context where this word/sentence appears". As you saw
    earlier, `see("Something")` will return the first element that contains `Something`
    as its value (for example, `Something Else)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，选择器可以只是一个简单的单词或句子，这意味着“找到这个单词/句子首次出现的地方”。如您之前所见，`see("Something")`
    将返回第一个包含 `Something` 作为其值的元素（例如，`Something Else`）。
- en: CSS selectors are probably the ones you might be more comfortable with, but
    for more complex stuff, XPath is generally the winner.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 选择器可能是你更熟悉的一种，但对于更复杂的内容，XPath 通常更胜一筹。
- en: 'In the preceding example, the XPath query `//li[@class="active"]/a[contains(.,"Home")]`,
    can be read as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，XPath 查询 `//li[@class="active"]/a[contains(.,"Home")]` 可以按以下方式阅读：
- en: Find me all the `li` nodes at any level (`//li`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何级别找到所有的 `li` 节点（`//li`）
- en: Filter them by a specific class attribute (`[@class="active"]`);—mind that is
    literal and case-sensitive
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过特定的类属性过滤它们（`[@class="active"]`）；请注意，这是字面意义和区分大小写的
- en: Within those find me the direct descendant `a` nodes (`/a`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些中找到直接的子节点 `a` 节点（`/a`）
- en: Filter them if they contain a specific text (`[contains(.,"Home")]`)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们包含特定的文本，则过滤它们（`[contains(.,"Home")]`）
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XPath 2.0 has been a W3C recommendation since December 2010, and you can read
    more about it at [http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XPath 2.0 自 2010 年 12 月以来一直是 W3C 建议的标准，您可以在 [http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/)
    上了解更多信息。
- en: 'Locators can ease the process of writing even more complex queries in your
    DOM and let you combine CSS and XPath queries via OR:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器可以简化在您的 DOM 中编写更复杂查询的过程，并允许您通过 OR 组合 CSS 和 XPath 查询：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the preceding statement, we can check the presence of the `Title` string
    in any `h1`, `h2`, or `h3` tag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的声明，我们可以检查任何 `h1`、`h2` 或 `h3` 标签中是否存在 `Title` 字符串。
- en: 'Another possibly useful feature is a method available in Locator that you can
    use to browse the page via `tabIndex`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能有用的功能是定位器中可用的一种方法，您可以使用它通过 `tabIndex` 浏览页面：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example has been deliberately taken from the documentation page
    of Locator, available at [http://codeception.com/docs/reference/Locator](http://codeception.com/docs/reference/Locator).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是故意从定位器的文档页面中选取的，该页面可在 [http://codeception.com/docs/reference/Locator](http://codeception.com/docs/reference/Locator)
    找到。
- en: Writing reusable page interactions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可重用的页面交互
- en: Testing forms is probably one of the most strenuous tasks any developer and
    tester has probably ever done. You can feel the pain if you think of forms as
    questionnaires of several single and multiple choice questions, spread across
    several pages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试表单可能是任何开发人员和测试人员可能做过的最艰巨的任务之一。如果您将表单视为跨越多个页面的多个单选和复选问题的问卷，您会感受到这种痛苦。
- en: You can clearly see the direct benefit of automating using functional tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到使用功能测试自动化的直接好处。
- en: 'The two examples already available, `LoginCept.php` and `ContactCept.php`,
    are a good starting point. Let''s have a closer look at `LoginCept.php`; if you
    scan through the content of the test, you will immediately notice that the `fillField()`
    method is never called, and in its place we have the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的两个示例，`LoginCept.php` 和 `ContactCept.php`，是一个很好的起点。让我们更仔细地看看 `LoginCept.php`；如果您浏览测试的内容，您会立即注意到
    `fillField()` 方法从未被调用，取而代之的是以下命令：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pages are, in fact, one of the easiest ways to reuse components across tests.
    The sequence of actions that are repeated several times in the same test are likely
    to be taken and put into a page like the one used in our test:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，页面是跨测试重用组件的最简单方法之一。在同一个测试中多次重复执行的操作可能被提取并放入页面中，就像我们在测试中使用的页面一样：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only thing needed is the route associated to it and then you can implement
    as many methods as you need to achieve whatever you need, which is the login process
    in the preceding case.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只有与之关联的路由，然后你可以实现所需的方法，以实现任何需要的功能，在先前的案例中就是登录过程。
- en: Within the `Page` class, `$this->actor` is a reference to the actor that is
    currently in use in the test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Page` 类中，`$this->actor` 是对当前在测试中使用的演员的引用。
- en: 'You have two ways to use pages; the first is by opening the page immediately
    and associate it with the current actor, as seen earlier with `LoginPage::openBy($I)`,
    otherwise, you can simply call its constructor and load the page (also with different
    parameters) when needed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种使用页面的方式；第一种是立即打开页面并将其与当前演员关联，就像之前在 `LoginPage::openBy($I)` 中看到的那样，否则，你可以在需要时简单地调用其构造函数并加载页面（也可以使用不同的参数）：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, as you saw while working with unit tests, being able to keep the content
    of the database under a controlled state is very useful. And, once again, fixtures
    come to our help, even here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你在与单元测试一起工作时所看到的，能够保持数据库内容处于受控状态是非常有用的。而且， fixtures 再次为我们提供了帮助，甚至在这里。
- en: Implementing fixtures
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现固定装置
- en: In [Chapter 4](ch04.html "Chapter 4. Isolated Component Testing with PHPUnit"),
    *Isolated Component Testing with PHPUnit*, you saw how to implement a fixture.
    In functional tests the same classes can be used; the only difference is that
    Codeception's PHPBrowser and its underlying infrastructure doesn't know how to
    load fixtures, so each framework using Codeception, like what Yii does, needs
    to provide the bridging to fill in this gap.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第4章](ch04.html "第4章。使用PHPUnit进行隔离组件测试") 中，*使用PHPUnit进行隔离组件测试*，你看到了如何实现一个固定装置。在功能测试中，可以使用相同的类；唯一的区别是，Codeception的PHPBrowser及其底层基础设施不知道如何加载固定装置，因此使用Codeception的每个框架，如Yii所做的那样，需要提供桥梁来填补这个差距。
- en: 'The advanced app provides the implementation for `FixtureHelper` that implements
    the Codeception `Module` class and imports the methods from `FixtureTrait`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 高级应用为 `FixtureHelper` 提供了实现，它实现了Codeception `Module` 类并从 `FixtureTrait` 导入方法：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is quite simple, and the only important bit is that in the
    `FixtureHelper`, we implement the `fixtures()` method that returns the list of
    models handled and their data files that contain all the rows we want in the database.
    The only difference with the original code that is found in the advanced app is
    the import of the `getFixture()` method as public, and we'll later see why this
    is so.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当简单，唯一重要的是在 `FixtureHelper` 中实现 `fixtures()` 方法，该方法返回处理模型及其包含我们想要在数据库中的所有行的数据文件的列表。与高级应用中找到的原始代码的唯一区别是导入
    `getFixture()` 方法作为公共的，我们将在稍后看到为什么这样做。
- en: 'The following code is for the `init_login.php` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是针对 `init_login.php` 文件的：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we imported the trait `getFixture()` as public, we can access the fixture
    through `$I->getFixture('user')` in a similar way to what we did in our unit tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将特性 `getFixture()` 作为公共的导入，我们可以通过 `$I->getFixture('user')` 以类似我们在单元测试中所做的方式访问固定装置。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to load additional fixtures, you can similarly expose the `loadFixtures()`
    method from the `FixtureTrait` trait and use it directly in your tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要加载额外的固定装置，你可以类似地公开 `FixtureTrait` 特性中的 `loadFixtures()` 方法，并在你的测试中直接使用它。
- en: 'The last step is about loading the module in Codeception configuration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在Codeception配置中加载模块：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And after running `codecept build`, the fixture will be automatically loaded
    when running the tests in the `_beforeSuite()` and `_afterSuite()` methods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `codecept build` 之后，当在 `_beforeSuite()` 和 `_afterSuite()` 方法中运行测试时，固定装置将被自动加载。
- en: Pitfalls of functional tests
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试的陷阱
- en: A word of advice is that there's plenty of information on functional tests,
    as well as what cannot be tested, in the official documentation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一句话建议是，官方文档中关于功能测试以及不能测试的内容有很多信息。
- en: The most important thing to grab there is all about the underlying technology
    that is used to perform tests; PHPBrowser is in fact a powerful tool, but as the
    whole functional test does not rely on the presence of a web server like you would
    have in a normal client-server situation, your application and functional tests
    will be running in the same memory space.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是了解用于执行测试的底层技术；PHPBrowser实际上是一个强大的工具，但整个功能测试不依赖于像正常客户端-服务器情况那样存在的Web服务器，因此你的应用程序和功能测试将在相同的内存空间中运行。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Normally the memory is cleaned during the `_after()` method execution, but remember
    that if you see any of your tests failing, remember to execute the test file separately,
    before starting to doubt your sanity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，内存会在`_after()`方法执行期间被清理，但请记住，如果您看到任何测试失败，请记住在开始怀疑自己的理智之前，单独执行测试文件。
- en: Functional tests for REST interfaces
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对REST接口的功能测试
- en: Up until now, you have seen what's already been implemented, what is possible
    to do out of the box, and some additional functionalities like the fixtures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了已经实现的内容，可以开箱即用的功能，以及一些额外的功能，如固定装置。
- en: Now let's have a look at what testing a REST interface entails; the default
    functional tests available in Codeception are executed by PHPBrowser, and the
    interface exposed to interact with it is quite limited and can only be used to
    deal and interact with the markup output by the web server. The REST module provided
    by Codeception is something we would love.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看测试REST接口涉及什么；Codeception中可用的默认功能测试是由PHPBrowser执行的，与之交互的接口相当有限，只能用来处理和与由Web服务器输出的标记进行交互。Codeception提供的REST模块是我们所希望的。
- en: Just to cite a few of the features available, you'll have functions to set and
    read headers, such as `seeHttpHeader()` and `haveHttpHeader()`, and specific methods
    to call HTTP requests towards our interface, such as `sendGET()`, `sendPUT()`,
    and `sendOPTIONS()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 仅举几个可用的功能为例，您将拥有设置和读取头部的函数，例如`seeHttpHeader()`和`haveHttpHeader()`，以及调用针对我们接口的HTTP请求的特定方法，例如`sendGET()`、`sendPUT()`和`sendOPTIONS()`。
- en: 'Specifically for our interface of the user, our tests will be split into two
    parts:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对我们的用户接口，我们的测试将分为两部分：
- en: Tests on the actual functionality—authentication and interaction with the application
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对实际功能——认证和与应用程序的交互进行的测试
- en: Some additional tests to ensure that we are exposing the right endpoints
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些额外的测试以确保我们公开了正确的端点
- en: 'Now, with this in mind, let''s start having a look at the configuration part;
    in the `functional.suite.yml` file, just add the REST module and configure it
    as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到这一点，让我们开始查看配置部分；在`functional.suite.yml`文件中，只需添加REST模块并按照以下代码进行配置：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last line is quite important, as we will end up making calls by specifying
    only our endpoint without the need of naming the module base path. Clearly things
    need to be adjusted accordingly in case you have more than one REST endpoint you
    need to test.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行非常重要，因为我们最终将只通过指定端点来调用，而不需要命名模块基本路径。显然，如果您需要测试多个REST端点，您需要相应地调整。
- en: Now, once again we need to run `codecept build` in order to get everything ready
    before starting to run our tests. This command, as already seen, will take all
    the module's methods and merge them into our actor's class (which in this case
    is `FunctionalTester`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次需要运行`codecept build`命令，以便在开始运行测试之前准备好一切。这个命令，如之前所见，将合并所有模块的方法到我们的actor类中（在这种情况下是`FunctionalTester`）。
- en: 'Let''s generate our new test file with the following commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令生成我们的新测试文件：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have the file, we can start implementing our tests:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了文件，我们可以开始实现我们的测试：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start the file with the initialization of the `FunctionalTester` and the
    definition of the scope of our test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从初始化`FunctionalTester`和定义测试范围开始文件。
- en: Defining the API endpoints
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义API端点
- en: As it's now time to implement the tests for our API endpoints, we need to define
    what these will look like and take our architectural decisions if these haven't
    been taken beforehand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们的API端点测试了，我们需要定义这些测试将是什么样子，并做出我们的架构决策，如果在此之前还没有做出这些决策。
- en: The basic interaction we want to provide to our clients interacting with our
    APIs is the ability to retrieve the user information, and modify it with the specific
    ability to change the password.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供给与我们的API交互的客户的基礎交互能力是获取用户信息，并具有修改信息的能力，特别是更改密码的能力。
- en: The client would normally know only the username and password. Since our update
    method will leverage on the ID of the user, we need to find a way for the client
    to get it in advance. Depending on the type of authentication protocol you decide
    to use, you can decide to return it right after the authentication has happened,
    otherwise you need to find a different way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户通常会知道用户名和密码。由于我们的更新方法将利用用户的ID，我们需要找到一种方法让客户提前获取它。根据您决定使用的认证协议类型，您可以选择在认证发生后立即返回它，否则您需要找到不同的方法。
- en: As you will later see, you're going to use the simplest of the authentication
    methods available, that is HTTP Basic Auth, which means that all our requests
    require a username and password to be sent along with them in a header. By doing
    so we clearly can't return the user ID in the response as this should contain
    the answer to the call and not the authentication header, so we can decide to
    provide a "search by username" endpoint. This will clearly make the username a
    unique field in the database, but that's not an issue, rather it's something you
    need to take into consideration if you're providing a user creation interface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你稍后将会看到的，你将使用可用的最简单的认证方法，即HTTP基本认证，这意味着我们所有的请求都需要在头中发送用户名和密码。通过这样做，我们显然不能在响应中返回用户ID，因为这应该包含对调用的答案，而不是认证头，因此我们可以决定提供一个“按用户名搜索”的端点。这将清楚地使用户名成为数据库中的唯一字段，但这不是一个问题，而是一个如果你提供用户创建界面时需要考虑的问题。
- en: 'Now, we have the following endpoints to test:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有以下端点需要测试：
- en: '`GET users/search/<username>`: This is used to retrieve the ID of the user.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET users/search/<username>`：这个端点用于检索用户的ID。'
- en: '`GET users/<id>`: This is used to retrieve any other information associated
    with the user.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET users/<id>`：这个端点用于检索与用户关联的任何其他信息。'
- en: '`PUT users/<id>`: This is used to update the password.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT users/<id>`：这个端点用于更新密码。'
- en: Implementing the tests for the API
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API测试
- en: As our passwords are passed as encrypted in the fixtures, we need to hardcode
    them in the tests, in order to authenticate appropriately.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的密码在 fixtures 中以加密形式传递，我们需要在测试中硬编码它们，以便正确地进行认证。
- en: 'This is not a good practice as we are going to make things a bit harder to
    maintain. On the other end, if things get more complex, we might want to refactor
    the code and find a better, more unified solution:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一种好的做法，因为我们将会使维护变得更加困难。另一方面，如果事情变得更加复杂，我们可能想要重构代码并找到一个更好、更统一的解决方案：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have some basic information about the user, we can try to grab
    its ID and check if its authentication works altogether:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于用户的基本信息，我们可以尝试获取其ID并检查其认证是否完全有效：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first step is to prepare the request, which is composed of the `Authorization`
    header and the actual request. We don't need to explicitly generate the `Authorization`
    header, as we have an abstraction over it provided by `amHttpAuthenticated()`,
    which would do that for us.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是准备请求，它由`Authorization`头和实际请求组成。我们不需要显式生成`Authorization`头，因为我们有一个由`amHttpAuthenticated()`提供的抽象，它会为我们完成这项工作。
- en: 'The header is then sent alongside the GET request over our endpoint; note how
    the URL omits the `/v1/` part that we would normally use to prefix the API:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将头与GET请求一起发送到我们的端点；注意URL省略了通常用于前缀API的`/v1/`部分：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we''ve sent the request, we can start analyzing the response and do various
    assertions on it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发送了请求，我们就可以开始分析响应并对它进行各种断言：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we grab the user ID from the response, so we can reuse it afterwards.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从响应中获取用户ID，以便之后可以重用它。
- en: 'The next step is about fetching the user''s own information knowing their ID,
    which looks particularly straightforward to implement:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取用户自己的信息，已知他们的ID，这看起来特别简单易行：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As the last step, we have kept the tests on updating the password and ensuring
    that the new password works as expected:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们保留了更新密码和确保新密码按预期工作的测试：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that due to the length of the tests, we will be keeping them all
    in one file as it won't affect their legibility, but you can clearly split them
    in more CEST files to aggregate them in a more concise and logical way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于测试的长度，我们将把它们全部放在一个文件中，因为这不会影响它们的可读性，但你当然可以将它们分成更多的 CEST 文件，以更简洁和逻辑的方式聚合它们。
- en: This should be all you really need to know. We can check that none of the tests
    will pass at this point, and at the end of the chapter, we will ensure that all
    of them are finally passing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是你需要了解的所有内容。我们可以检查在这个阶段，没有任何测试会通过，并在章节结束时，我们将确保所有测试最终都能通过。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also note that it's not necessary to call `amHttpAuthenticated()` to send the
    authentication header every time as it will be cached after the first call in
    the CEPT file, and should only be required when the header needs to be updated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，没有必要每次都调用`amHttpAuthenticated()`来发送认证头，因为它在CEPT文件中的第一次调用后将被缓存，并且只有在需要更新头时才需要。
- en: Now that we have seen how easy it is to write a functional test, I can leave
    the creation of additional tests to you. If you want, you can start by checking
    that the rest of the interfaces have not been exposed, such as the ability to
    request the list of all users and retrieve or change their passwords.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到编写功能测试是多么容易，我可以将创建额外测试的任务留给你。如果你想，你可以先检查其他接口是否未被暴露，例如请求所有用户的列表以及检索或更改他们的密码的能力。
- en: In the following section of this chapter, we are going to focus on the implementation
    side of the things by looking at some new, shiny features provided by Yii 2.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将通过查看 Yii 2 提供的一些新特性来关注事物的实现方面。
- en: Creating a RESTful web service with Yii 2
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Yii 2 创建 RESTful Web 服务
- en: It's important to remember that a REST web service is by definition a stateless
    service, this will imply some requirements in the way we will test things and
    deal with the information we need to POST or GET.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，根据定义，REST Web 服务是一种无状态服务，这将在我们测试事物和处理我们需要 POST 或 GET 的信息时产生一些要求。
- en: The big step forward that Yii made with version 2 can be seen in the built-in
    REST classes that provide an immediate solution once provided by third-party implementations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 2 版本带来的重大进步体现在内置的 REST 类上，这些类可以立即提供第三方实现曾经提供的解决方案。
- en: This means we'll have to introduce several changes to what we've achieved so
    far; the REST part of the application will be developed as a separate module,
    which will give us the ability to extend it and contain its logic. Because of
    this, the routes will be rearranged appropriately as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将不得不对我们迄今为止所取得的成果进行一些修改；应用程序的 REST 部分将作为一个独立的模块来开发，这将使我们能够扩展它并包含其逻辑。因此，路由也将相应地重新排列。
- en: Before seeing what the Yii REST functionality is capable of doing, we'll need
    to first have a quick look at modules in Yii, which we will use to develop our
    API to be tested.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 Yii REST 功能能够做什么之前，我们首先需要快速了解 Yii 中的模块，我们将使用它来开发要测试的 API。
- en: Writing modular code in Yii
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Yii 中编写模块化代码
- en: If you've never used modules since you've started working with Yii, well, I
    think it's time to do so. Right now, modules are really easy and straightforward
    to use, and they will help you keep your code architecturally well organized and
    separated from the other components of your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自从开始使用 Yii 以来从未使用过模块，那么我认为现在是时候了。目前，模块的使用非常简单直接，并且它们将帮助你保持代码在架构上的良好组织，并与其他应用程序组件分离。
- en: Modules are self-contained software units that contain models, views and controllers,
    and other software components, and the end user will be able to access the controller
    once it is installed in the main application. For this reason, modules are considered
    mini-applications, only difference being that they cannot live on their own. As
    an example, a forum or an administrative area can be developed as modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是包含模型、视图、控制器和其他软件组件的独立软件单元，一旦安装到主应用程序中，最终用户就可以访问控制器。因此，模块被认为是微型应用程序，唯一的区别是它们不能独立存在。例如，论坛或管理区域可以开发为模块。
- en: Modules can also be composed of submodules; a forum might have an admin submodule
    that contains all the logic and interfaces to moderate and customize the main
    forum module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以由子模块组成；一个论坛可能有一个包含所有逻辑和接口以管理和定制主论坛模块的管理子模块。
- en: Modules can be quite complex in their structure; I would always strongly suggest
    an architectural analysis before deciding to keep everything under the same module,
    in the same way as you need to question your choices if you were to keep all the
    code in the same controller. Always try to keep in mind that you should be able
    to understand your code in one year's time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的结构可能相当复杂；我总是强烈建议在决定将所有内容都放在同一个模块下之前进行架构分析，就像你需要质疑将所有代码都放在同一个控制器下的选择一样。始终牢记，你应该能够在一年后理解你的代码。
- en: Creating a module with Gii
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gii 创建模块
- en: Developing the REST interface using Yii modules is the easiest way to achieve
    versioning of the API. This way, we can easily switch and make an improved version
    of the API while still continuing to support the old version with minimal maintenance,
    until full deprecation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Yii 模块开发 REST 接口是实现 API 版本化的最简单方法。这样，我们可以轻松地切换并制作 API 的改进版本，同时仍然以最小的维护支持旧版本，直到完全弃用。
- en: So we will start with the creation of the module, using the web interface to
    the code generator called Gii. In case you skipped a few pages, the configuration
    for that is available in [Chapter 4](ch04.html "Chapter 4. Isolated Component
    Testing with PHPUnit"), *Isolated Component Testing with PHPUnit*, where you saw
    how to create a model with it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从创建模块开始，使用Gii代码生成器的Web界面。如果您跳过了一些页面，该配置在[第4章](ch04.html "第4章。使用PHPUnit进行隔离组件测试")中可用，*使用PHPUnit进行隔离组件测试*，您在那里看到了如何使用它创建模型。
- en: Now, we will see how to create a module and what this will mean in terms of
    generated code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何创建一个模块，以及这在生成代码方面意味着什么。
- en: So, head over to the Gii application, which in my case is `http://basic.yii2.sandbox/gii`
    and log in, if you are configured to do so and click on the **Module Generator**
    button.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前往Gii应用程序，在我的情况下是`http://basic.yii2.sandbox/gii`，如果配置了登录，请登录，然后单击**模块生成器**按钮。
- en: 'The only two fields we have to fill in are these:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须填写的只有两个字段：
- en: '**Module Class**: This represents the main name-spaced class name of the module,
    which will be set to `app\modules\v1\Module`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块类**：这代表模块的主要命名空间类名，将被设置为`app\modules\v1\Module`。'
- en: '**Module ID**: This will be (automatically) set to `v1`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块ID**：这将（自动）设置为`v1`。'
- en: 'Have a look at the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![Creating a module with Gii](img/B03646_06_01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用Gii创建模块](img/B03646_06_01.jpg)'
- en: Module generator page within the Gii code generation tool
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Gii代码生成工具中的模块生成页面
- en: You can avoid creating the view by deselecting the related checkbox, as we're
    not going to need one. We're going to make more changes to what has been generated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过取消选择相关的复选框来避免创建视图，因为我们不需要它。我们将对已生成的内容进行更多修改。
- en: Click on the **Generate** button, once ready.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好后，单击**生成**按钮。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If your application will end up being more complex than what we have here, you
    still have a few options.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序最终比这里更复杂，您仍然有一些选择。
- en: You can simply adjust the routes for the module, as explained in the documentation
    at [http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以简单地调整模块的路由，正如在[http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically)文档中所述。
- en: Otherwise, you can create a module within a module (for example, a container
    module called `api` which will contain the various versions as modules such as
    `v1`, `v2`, and so on). Just remember to namespace it correctly when creating
    it. This is usually the solution I'd recommend from the code organization point
    of view.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以在模块内创建一个模块（例如，一个名为`api`的容器模块，它将包含各种版本作为模块，如`v1`、`v2`等）。只需记住在创建时正确命名空间即可。这通常是我在代码组织方面推荐的方法。
- en: The next step is to configure the module in order to be able to use it, and
    then we will see how to transform it into a REST module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置模块以便使用它，然后我们将看到如何将其转换为REST模块。
- en: Using modules in Yii 2
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Yii 2中使用模块
- en: Now that we have our basic code for our module ready, we need to see how we
    can use it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了模块的基本代码，我们需要看看我们如何使用它。
- en: Ideally, the created module can be used straight away without much hassle, which
    is quite helpful in an environment where you want to be able to create reusable
    and, of course, modular code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，创建的模块可以立即使用，无需太多麻烦，这在您希望创建可重用和当然模块化代码的环境中非常有帮助。
- en: The only step that's really needed is instructing Yii that there is a new module,
    and in return, it will take care of auto-loading and calling our module controller
    at the right time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 真正需要的唯一步骤是指导Yii存在一个新的模块，然后它将负责在正确的时间自动加载和调用我们的模块控制器。
- en: 'So let''s head over to our configuration file located in `/config/web.php`
    and add the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们转到位于`/config/web.php`的配置文件，并添加以下代码：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this, you're ready to go. In order to convert the newly created module
    to act as a REST controller, it requires some additional changes, which we will
    explore immediately.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就准备就绪了。为了将新创建的模块转换为REST控制器，需要一些额外的更改，我们将立即探讨。
- en: Converting our controller to be a REST controller
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的控制器转换为REST控制器
- en: This much anticipated feature of Yii 2 lets you create a REST interface in a
    clear and easy way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个备受期待的Yii 2功能让您能够以清晰和简单的方式创建REST接口。
- en: The REST controller we will inherit from will deal with our models without much
    configuration needed and even if there was, it's quite straightforward to do and
    keep in mind.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要继承的REST控制器将处理我们的模型，无需太多配置，即使需要配置，也是相当直接且容易记住的。
- en: Our first step is to create `UserController` which will be dealt with the `User`
    model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建`UserController`，它将处理`User`模型。
- en: 'Let''s start by defining the namespace and the basic classes we''re going to
    use in our new controller:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义命名空间和我们将在新控制器中使用的基本类：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can clearly see, we're going to use the `User` model and on top of it
    the REST `ActiveController`. This controller is where the magic happens, and we're
    going to illustrate what it is all about in a moment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们明显看到的，我们将使用`User`模型，并在其之上使用REST `ActiveController`。这个控制器是魔法发生的地方，我们将在稍后展示它是如何工作的。
- en: 'Now, let''s implement the actual class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现实际的类：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only thing needed at this point is just the definition of the model class
    that the REST controller is going to manage and that's it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要做的只是定义REST控制器将要管理的模型类，然后就可以了。
- en: '`yii\rest\ActiveController` is the controller that will deal with Active Records
    models, such as our `User` model. If you were to manage custom classes (non active
    records) that do not connect to a database or do connect to a custom data source
    (for instance, an online service), you can use the class that `ActiveController`
    is inheriting from, which is `yii\rest\Controller`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\rest\ActiveController`是处理Active Records模型（如我们的`User`模型）的控制器。如果你要管理自定义类（非活动记录），这些类不连接到数据库或连接到自定义数据源（例如，在线服务），你可以使用`ActiveController`继承的类，即`yii\rest\Controller`。'
- en: 'The beauty of `ActiveController` is that it provides already implemented actions
    that are available immediately, which are:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActiveController`的美丽之处在于它提供了已经实现并立即可用的操作，包括：'
- en: '`index`, which is accessed via `GET` or `HEAD` and returns the list of the
    models and their (database-bound) attributes'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`，通过`GET`或`HEAD`访问，返回模型及其（数据库绑定）属性的列表'
- en: '`view`, which is accessed via `GET` and `HEAD` and returns the details of a
    single model'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view`，通过`GET`和`HEAD`访问，返回单个模型的详细信息'
- en: '`create`, which can be accessed only via `POST` and lets you create a new model'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`，只能通过`POST`访问，并允许你创建一个新的模型'
- en: '`update`, which is accessed via `PUT` or `PATCH` and does what it says on the
    tin'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`，通过`PUT`或`PATCH`访问，并执行其名称所表示的操作'
- en: '`delete`, which is used to delete a model and can be invoked using `DELETE`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`，用于删除模型，可以使用`DELETE`调用'
- en: '`OPTIONS`, which, lastly, you can invoke to see all the allowed HTTP methods'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`，最后，你可以调用它来查看所有允许的HTTP方法'
- en: In the actions that you'll be able to implement yourself, you will be dealing
    with the raw models, which are rendered by default in XML and JSON (depending
    on the `Accept` header that was sent along with the request).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以自己实现的操作中，你将处理原始模型，这些模型默认以XML和JSON格式渲染（取决于随请求发送的`Accept`头）。
- en: We know we'll need to modify the list of exposed endpoints, and we'll see how
    to do it in a moment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要修改公开端点的列表，我们将在稍后展示如何做到这一点。
- en: Before getting there, there are a few other bits that need to be addressed first,
    in particular the access credentials, as we don't want anybody to access our endpoints
    without being authenticated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到那里之前，还有一些其他问题需要先解决，特别是访问凭证，因为我们不希望任何人未经认证就能访问我们的端点。
- en: Adding the access check and security layer
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加访问检查和安全层
- en: You might already have asked yourself how to prevent non-authenticated users
    from using certain endpoints of your application. For instance, we might want
    to give a client access to the user endpoint only if it's authenticated and authorized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经问过自己如何防止未经认证的用户使用应用程序的某些端点。例如，我们可能只想在客户端认证并授权的情况下，允许客户端访问用户端点。
- en: The authorization and authentication happen at two different phases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 授权和认证发生在两个不同的阶段。
- en: Authorization is done at controller level by simply overriding the `checkAccess()`
    method and performing the right checks, which might involve establishing if the
    user has been authenticated and if he/she is active, in case this flag exists
    in the user model.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 授权在控制器级别通过简单地重写`checkAccess()`方法并执行适当的检查来完成，这可能包括确定用户是否已认证以及他/她是否活跃，如果用户模型中存在此标志的话。
- en: 'In our case, we can simply add the following method to our controller:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可以在控制器中简单地添加以下方法：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that if the user is a guest, we raise a `401` response.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果用户是访客，我们将引发一个`401`响应。
- en: 'Yii will automatically call the method on each request as we can see in the
    `actions()` method in its parent class, which is `\yii\rest\ActiveController`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Yii会自动在每次请求中调用该方法，正如我们可以在其父类`\yii\rest\ActiveController`中的`actions()`方法中看到的那样：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Instead, the authentication is done in a completely different way and varies
    depending on the implementation and level of security you want to implement in
    the application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，认证是以完全不同的方式进行的，并且取决于实现和你在应用程序中想要实现的安全级别。
- en: 'As far as it goes, in case you haven''t touched the argument in depth, you
    have different possibilities, which are:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就其本身而言，如果你没有深入接触这个参数，你有不同的可能性，它们是：
- en: '**HTTP Basic Auth**: This is basically the same that you would have by using
    htpasswd and configuring Apache accordingly and is the simplest one available,
    but needs the username and password to be sent in a header with every request.
    This requires the communication to work over HTTPS for obvious reasons.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP基本认证**：这基本上是你通过使用htpasswd并相应地配置Apache所拥有的相同认证方式，是可用的最简单的一种，但需要将用户名和密码以每个请求的头部信息发送。这要求通信通过HTTPS进行，这是显而易见的。'
- en: '**Query parameter**: Here, the client is already possessing an access token,
    which will be sent to the server as a query parameter as `https://server.com/users?access-token=xxxxxxx`,
    which is quite handy if you don''t have the ability to send additional tokens
    with the request.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询参数**：在这里，客户端已经拥有一个访问令牌，它将以查询参数的形式发送到服务器，作为`https://server.com/users?access-token=xxxxxxx`，如果你没有能力在请求中发送额外的令牌，这相当方便。'
- en: There are some other ways that use a combination of different techniques and/or
    asymmetric and symmetric encryption or different types of handshakes to authenticate
    a client. One of the most well-known, although potentially complex, is **OAuth
    2**, which has different implementations as it's considered more of a framework
    than a well-defined protocol. Most of the well-known social websites such as Google,
    Twitter, Facebook, and so on implement it. Its Wikipedia page, available at [http://en.wikipedia.org/wiki/OAuth](http://en.wikipedia.org/wiki/OAuth),
    provides some good links and references to help you explore it further.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他方法，它们结合了不同的技术以及非对称和对称加密或不同类型的手shake来认证客户端。其中最著名的一个，尽管可能很复杂，是**OAuth 2**，由于它被视为一个框架而不是一个定义良好的协议，因此有不同的实现。大多数知名的社会网站，如Google、Twitter、Facebook等，都实现了它。它的维基百科页面，可在[http://en.wikipedia.org/wiki/OAuth](http://en.wikipedia.org/wiki/OAuth)找到，提供了一些有用的链接和参考资料，可以帮助你进一步探索。
- en: As encryption and authentication protocols are outside the scope of this book,
    I've decided to use the simplest solution, which will anyway give us enough hints
    on where to put our hands, should we want to implement something more robust or
    complex.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密和认证协议超出了本书的范围，我决定使用最简单的解决方案，这无论如何都会给我们足够的提示，告诉我们如何在需要实现更健壮或更复杂的解决方案时着手。
- en: Building the authentication layer
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建认证层
- en: 'As Yii uses sessions by default, which will violate the stateless constraints
    of a RESTful server according to the fielding dissertation ([http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3)),
    we will want to disable the session in the module''s `init()` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Yii默认使用会话，这会违反RESTful服务器无状态约束（根据Fielding论文[http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3)），我们希望在模块的`init()`方法中禁用会话：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Yii the actual authentication is then done via the available authenticator
    behavior.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii中，实际的认证是通过可用的认证器行为完成的。
- en: 'Yii provides four different authenticators which are:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供了四种不同的认证器，它们是：
- en: '`HttpBasicAuth`: This is used for HTTP Basic Auth, which we will use here'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpBasicAuth`：这用于HTTP基本认证，我们将在这里使用'
- en: '`QueryParamAuth`: This is used for query parameter authentication'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryParamAuth`：这用于查询参数认证'
- en: '`HttpBearerAuth`: This is used for OAuth and similar methods'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpBearerAuth`：这用于OAuth和类似方法'
- en: '`CompositeAuth`: This is a way to use multiple cascading authentication methods'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompositeAuth`：这是一种使用多个级联认证方法的方式'
- en: 'Again open our `UserController` and let''s define the one we want to use:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开我们的`UserController`，让我们定义我们想要使用的方法：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you were to run the tests against this implementation, you will have problems
    making them pass; the default implementation will use `findIdentityByAccessToken()`
    and use the `$username` part of the header as an access token. So, there's no
    real password check.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对这个实现运行测试，你将遇到问题，使它们通过；默认实现将使用`findIdentityByAccessToken()`并使用头部的`$username`部分作为访问令牌。所以，实际上并没有进行密码检查。
- en: HTTP Basic Auth defines that, together with your request, you will also have
    to send an `Authorization` header containing `'Basic '.base64($username.':'.$password);`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本认证定义了，除了你的请求外，你还需要发送一个包含`'Basic '.base64($username.':'.$password);`的`Authorization`头。
- en: As explained in the documentation of the `HttpBasicAuth` class at [https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55](https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55),
    you need to override the `$auth` attribute in order to perform the password authentication
    in the way that you want.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如在`HttpBasicAuth`类的文档[https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55](https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55)中所述，你需要覆盖`$auth`属性，以便以你想要的方式执行密码认证。
- en: 'As you saw, `findIdentityByAccessToken()` is not a method we''re going to need,
    and we have the unit tests that clearly state that. The best way to address this
    is by adding our authenticator method straight in the definition of the behavior
    in the following way:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`findIdentityByAccessToken()`不是我们需要的那个方法，我们也有单元测试明确地说明了这一点。解决这个问题的最佳方式是在以下方式中直接在行为的定义中添加我们的认证器方法：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As explained in the documentation, the `auth` attribute should be a function
    that expects `$username` and `$password` as actual parameters, and returns the
    user identity if the authentication is verified.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中所述，`auth`属性应该是一个函数，它期望`$username`和`$password`作为实际参数，并在认证验证通过时返回用户身份。
- en: With this last method, implementation of our authentication and authorization
    scheme should be complete.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们认证和授权方案的实现应该就完成了。
- en: Modifying the existing actions
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有操作
- en: 'Now that we''ve restricted access to any other user, we need to re-implement
    the view and update actions, in order to allow only the currently logged in user
    to view just his/her details and allow him to update only the password. If you
    have already started implementing the actions, this won''t be enough as the parent
    class, `yii\rest\Controller`, already implements all the default actions, so we
    need to redefine their configuration, which happens to be set within the `actions()`
    method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经限制了其他用户的访问，我们需要重新实现视图和更新操作，以便只允许当前登录的用户查看他/她的详细信息，并允许他/她更新密码。如果你已经开始实现这些操作，这还不够，因为父类`yii\rest\Controller`已经实现了所有默认操作，所以我们需要重新定义它们的配置，这发生在`actions()`方法中：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we unset the two actions, our own overridden methods will be picked up
    automatically without much else to do:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们取消这两个操作的设置，我们的覆盖方法将自动被选中，无需做太多其他事情：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The view action just adds a check on the ID of the user and returns a 403 error,
    while the update action can be something along the lines of the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 视图操作只是对用户的ID进行检查，并返回403错误，而更新操作可以类似于以下代码：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the update, we only allow changing of the password, after which we return
    the value of the `save` method. We could have returned a more comprehensive status,
    but for our cause, this is good enough.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新中，我们只允许更改密码，之后我们返回`save`方法的价值。我们本可以返回一个更全面的状态，但对我们来说，这已经足够好了。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won't actually need to add the check if the request is not a PUT, as the
    current internal implementation restricts it by default. We'll see in [Chapter
    8](ch08.html "Chapter 8. Analyzing Testing Information"), *Analyzing Testing Information*,
    how this will be fixed, using the coverage report information.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果请求不是PUT，我们就不需要添加检查，因为当前内部实现默认就限制了它。我们将在[第8章](ch08.html "第8章。分析测试信息")中看到，如何使用覆盖率报告信息来解决这个问题，即*分析测试信息*。
- en: Adding a new endpoint with parameters
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加带有参数的新端点
- en: With all we have done, if we try to run the tests on `UserAPICept`, we will
    see that it will fail immediately at the first `sendGET('user/search')command`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成所有这些之后，如果我们尝试在`UserAPICept`上运行测试，我们将看到它将在第一个`sendGET('user/search')`命令时立即失败。
- en: 'Implementing the new `actionSearch()` method won''t be a problem, and it can
    be implemented in the following way:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`actionSearch()`新方法不会有问题，并且可以按以下方式实现：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What is important to note is how we will customize the routes to add this new
    action in a "compliant" way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意我们将如何定制路由以“合规”的方式添加这个新操作。
- en: 'Switch to the configuration file located at `config/web.php` and let''s start
    by adding the search action to the list of allowed methods:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到位于 `config/web.php` 的配置文件，让我们首先将搜索操作添加到允许的方法列表中：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `UrlRule` class that is used to create routes exposes some variables that
    you can configure, either to extend or entirely re-define the patterns and the
    structure of the tokens. The first are `extraPatterns` and `patterns` respectively.
    Tokens can be used in the patterns and represent the parameters passed to the
    action.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建路由的 `UrlRule` 类公开了一些你可以配置的变量，既可以扩展也可以完全重新定义模式和令牌的结构。首先是 `extraPatterns`
    和 `patterns`。令牌可以在模式中使用，并代表传递给操作的参数。
- en: 'In Yii terminology, a pattern is a tuple composed of allowed HTTP method(s),
    the actual structure of the resource to identify, and the corresponding action
    to be called. The following is an example of this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii 术语中，一个模式是由允许的 HTTP 方法、实际要识别的资源结构以及要调用的相应操作组成的元组。以下是一个示例：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A token is one or more parameters that can be as complex as a regular expression.
    In the preceding example, `{username}` is a token and can be defined as shown
    in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌是一个或多个参数，它可以像正则表达式一样复杂。在先前的示例中，`{username}` 是一个令牌，可以按照以下代码所示进行定义：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our final list of rules will end up looking like the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的规则列表将最终看起来像以下代码：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first thing to note is that we had to re-define all the tokens rather than
    adding them as we are doing with `extraPatterns`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们不得不重新定义所有令牌，而不是像我们在 `extraPatterns` 中所做的那样添加它们。
- en: In the list of rules, we have defined the REST interface rules before any other
    as rules are read top to bottom, and the first one that is found matching will
    be captured. This means that specific rules must stay at the top, while generic
    catch-all rules are at the bottom.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则列表中，我们首先定义了 REST 接口规则，然后是其他任何规则，因为规则是从上到下读取的，第一个找到的匹配规则将被捕获。这意味着特定的规则必须放在顶部，而通用的捕获所有规则则放在底部。
- en: 'The preceding configuration will be fed to `urlManager`, as explained in the
    official guide at [http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将被传递给 `urlManager`，如官方指南[http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls)中所述：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can check that the tests are passing using the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令来检查测试是否通过：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw many things such as how to write basic functional tests,
    how to test a REST interface, and the implementation side of things. Given the
    amount of knowledge condensed here, it might be useful for you to revisit the
    chapter later on and give yourself enough time to experiment on the single features
    in more detail and adapt them to your likings.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了许多内容，例如如何编写基本的功能测试、如何测试 REST 接口以及实现方面的内容。鉴于这里浓缩的知识量，你可能以后会再次阅读本章，给自己足够的时间更详细地实验单个功能，并适应你的喜好。
- en: In the next chapter, you're going to see how to create acceptance tests for
    your interfaces that will overcome some of the limitations of working with PHPBrowser.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到如何为你的接口创建验收测试，这将克服使用 PHPBrowser 的一些限制。
