- en: Chapter 8. It's Not Enough! Extending Eloquent, Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.还不够！扩展Eloquent，高级概念
- en: Through this book, you learned that you can do many amazing things with Eloquent.
    It is a great active record implementation; it's easy to use, really flexible,
    and it offers many tools out of the box to improve your code base quality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这本书，你学习了你可以用Eloquent做许多令人惊叹的事情。它是一个出色的活动记录实现；它易于使用，非常灵活，并且提供了许多工具来提高代码库的质量。
- en: 'A developer usually must face two types of projects: *Applications* and *applications*,
    as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常必须面对两种类型的项目：*应用*和*应用*，如下所示：
- en: For *applications*, I intend something that you can do, maybe in a quick way,
    with some workarounds and some hacks, here and there. Also, I know that you know
    what I am talking about. That site you made for a friend, a little blog, and so
    on.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*应用*，我打算做一些你可以做的事情，可能是一种快速的方式，一些在这里和那里的解决方案和技巧。而且，我知道你知道我在说什么。你为朋友做的那个网站，一个小博客，等等。
- en: Let's be clear and serious, you can't make every application with the same,
    perfect care. Being honest, neither me nor probably any one does. Then, you have
    to deal with *Applications*. Things can get really serious there, and you must
    be able to build a maintainable, awesome application structure.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们明确并严肃，你不能用同样的完美关怀来制作每个应用。说实话，可能没有人能做到。那么，你必须处理*应用*。事情可能会变得非常严重，你必须能够构建一个可维护、出色的应用结构。
- en: 'It''s not just about something that works; in this case, I am thinking about
    something that can scale easily, with a good quality code base. It''s not just
    about calling your models from controllers. That''s not enough. You could stumble
    upon many issues: testability, maintainability, and also in following some principles.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是关于一些能工作的事情；在这种情况下，我在想的是一些可以轻松扩展且代码质量良好的事情。这不仅仅是关于从控制器中调用模型。这还不够。你可能会遇到许多问题：可测试性、可维护性，以及遵循某些原则。
- en: In this chapter, we will explore two different ways to extend Eloquent more
    seriously.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种不同的方法来更认真地扩展Eloquent。
- en: 'In the very first part, you will learn how to extend the Eloquent Model class.
    Actually, the Model does many things, but what if we need something more? No problem:
    extending the existing Model class will be a bed of roses if standing on the shoulders
    of a giant.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，你将学习如何扩展Eloquent模型类。实际上，模型做了很多事情，但如果我们需要更多呢？没问题：站在巨人的肩膀上，扩展现有的模型类将会变得容易。
- en: 'Have you ever heard about the Ardent Project? It''s a package for Laravel 4
    that extends the Model class, adding some super powers: self-validating models
    and auto-hydrating from the request input data.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过Ardent项目吗？这是一个为Laravel 4设计的包，它扩展了模型类，添加了一些超级功能：自我验证的模型和从请求输入数据中自动填充。
- en: You'll make something similar for the Laravel 5 Eloquent Model, and I will show
    you how to do it step by step. Also, it is inspired by the work of Philip Brown
    in his blog ([http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/](http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为Laravel 5 Eloquent模型做类似的事情，我会一步步地教你如何做。此外，它受到了菲利普·布朗在他的博客中的工作（[http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/](http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/)）的启发。
- en: However, as mentioned earlier in this book, Laravel is mostly about freedom,
    especially when it comes to freedom in organizing your projects. Now, a really
    interesting trend is the **repository pattern**. It's a way to abstract your code
    in a better way and separate responsibilities. For a project bigger than the bakery's
    blog, it's a must-have in your knowledge base.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如本书前面提到的，Laravel主要关于自由，尤其是在组织项目方面的自由。现在，一个真正有趣的趋势是**仓库模式**。这是一种以更好的方式抽象你的代码并分离责任的方法。对于比面包店的博客更大的项目，这是你知识库中必须拥有的。
- en: Also, the repository pattern is not something related to Laravel only. This
    means that you will learn something new that you will be able to reuse in the
    future, with other languages and products.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仓库模式不仅仅与Laravel有关。这意味着你将学习一些新东西，你将来可以在其他语言和产品中重用。
- en: Alright, no more chitchat. It is time to get our hands dirty for the last time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，不再闲聊。现在是时候最后一次动手实践了。
- en: 'Come on, hero! We will cover the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 来吧，英雄！我们将涵盖以下主题：
- en: 'Extending the Model: Aweloquent !'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展模型：Aweloquent !
- en: Diving into the repository pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入到仓库模式
- en: The summary
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Extending the Model: Aweloquent!'
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模型：Aweloquent！
- en: The Eloquent Model can actually do tons of things in a very smart and easy way.
    However, something can be improved in terms of code to write every time you want
    to do a specific operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent Model实际上可以非常聪明且容易地完成很多事情。然而，在每次想要执行特定操作时，代码的编写方面可能需要改进。
- en: Usually, when creating a new model instance, you are probably using some data
    that the user previously typed in to a form.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建新的模型实例时，你可能会使用用户之前输入到表单中的某些数据。
- en: Adding a new author to our database can be the perfect example. All you have
    to do is to insert the first and last names in to a form and then press **save**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的数据库添加新作者可以是一个完美的例子。你所要做的就是将姓名和姓氏输入到表单中，然后按下**保存**。
- en: 'Then, in the dedicated post route (or relative controller method), you will
    do something similar to the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在专用的路由（或相对控制器方法）中，你将执行以下类似操作：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's quite fine. However, you will probably also have to validate the user
    input.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不错。然而，你可能还必须验证用户输入。
- en: 'So, assuming that you are still in a controller, you could add a controller
    validator call, just like this one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设你仍然在控制器中，你可以添加一个控制器验证调用，就像这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once again, saved the day!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，救了场！
- en: Now, very often, developers debate the responsibilities of a single class in
    terms of what that class has to do and what not. Everyone has a thought about
    the topic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发者们经常就单个类的职责进行辩论，讨论这个类应该做什么，不应该做什么。每个人对这个话题都有自己的看法。
- en: The **Single Responsibility Principle**, a part of the SOLID principles, is
    very clear about that—put simply, the principle says that a class should do one
    and only one thing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**，SOLID原则的一部分，对此非常明确——简单来说，这个原则指出，一个类应该只做一件事情。'
- en: On the other hand, however, you will often find very big classes. The Eloquent
    Model is one of them. At the time of writing, the Illuminate\Database\Eloquent\Model
    counts 3,399 lines of code. Not exactly something small!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，然而，你经常会发现非常大的类。Eloquent Model就是其中之一。在撰写本文时，Illuminate\Database\Eloquent\Model有3,399行代码。这绝对不是一个小数字！
- en: Obviously, the Model doesn't perform a single operation; it fills its own attributes,
    deals with relationships, and serializes its own attributes. Yes, it goes far
    beyond the principle you just read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Model并不执行单一操作；它填充自己的属性，处理关系，并序列化自己的属性。是的，它远远超出了你刚才读到的原则。
- en: So, what's the deal with it?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这到底是怎么回事呢？
- en: Well, even if it is very big, a Model like this allows you to perform many operations
    using a single class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，即使它非常大，这样的Model也允许你使用一个单独的类执行许多操作。
- en: 'A perfect example is how you can use a Model as a model, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的例子是，你可以如何将Model用作模型，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use it as a factory (a class that is used to create instances
    in a more elegant and better way) using the `create()` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用它作为工厂（一个用于以更优雅和更好的方式创建实例的类）使用`create()`方法：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If this isn''t enough, the Model also handles everything related to the persistence
    of the instance:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，Model还处理与实例持久化相关的一切：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All using a single class—that's the main advantage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用一个单独的类——这是主要优势。
- en: 'You are probably asking yourself what he is trying to say with all this stuff.
    The answer is really simple: there isn''t always a single correct solution. Some
    people hate the Eloquent Model, some people love it.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在问自己，所有这些话他到底想说什么。答案其实很简单：并不总是只有一个正确的解决方案。有些人讨厌Eloquent Model，有些人则非常喜欢它。
- en: So, in this specific situation, I will add new features to the existing Model
    class creating a new Eloquent Model… **the Aweloquent**!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这种情况下，我将向现有的Model类添加新功能，创建一个新的Eloquent Model… **Aweloquent**！
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we go any further, here's a clarification. I will repeat it again, but
    I also want to say it now. In the following part of this chapter, we will extend
    the Model class adding a feature that, in Laravel, is handled by the `Validator`
    class. I am not teaching you this because I want you to do this, but because I
    want to show you how to extend the Model class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，这里有一个澄清。我会再次重复，但我也想现在就说明。在本章的后续部分，我们将扩展Model类，添加一个在Laravel中由`Validator`类处理的功能。我之所以教你们这个，并不是因为我想要你们这样做，而是因为我想要展示如何扩展Model类。
- en: For instance, you will probably find the **smart password hashing** feature
    stupid, but it's just an example. Extending Models and using repositories are
    two different techniques, which are totally separated. I am just giving you the
    knowledge, then you can choose what to do, and I am sure you will do the right
    thing, hero!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能觉得**智能密码哈希**功能很愚蠢，但这只是一个例子。扩展模型和使用仓库是两种完全不同的技术，它们是完全分开的。我只是给你提供知识，然后你可以选择做什么，我相信你会做出正确的选择，英雄！
- en: The Aweloquent Model
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aweloquent模型
- en: As I mentioned earlier, our powered-up Eloquent Model will be really similar
    to the Ardent Laravel 4 package-improved Model. I will also borrow some ideas
    from Philip Brown's Magniloquent project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们的增强Eloquent模型将非常类似于Ardent Laravel 4包改进的模型。我还会从Philip Brown的Magniloquent项目中借鉴一些想法。
- en: 'To be more precise, our improved Model will feature the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，我们的改进模型将具有以下特性：
- en: Auto Hydrate
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动填充
- en: Model self-validation
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型自我验证
- en: Smart password hashing
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能密码哈希
- en: The autopurge of confirmation fields
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认字段的自动清除
- en: Auto Hydrate
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动填充
- en: Instead of assigning attributes individually, or passing them in an array, the
    Aweloquent Model will be able to read the current request and autopopulate its
    attributes without any other code lines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个分配属性，或者将它们作为一个数组传递，Aweloquent模型将能够读取当前请求并自动填充其属性，而无需任何其他代码行。
- en: 'This means that you will be able to use the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将能够使用以下内容：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of the more classic:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更经典的：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Model self-validation
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型自我验证
- en: You will be able to specify validation rules and messages as static properties
    of a Model. Then, the Model will automatically perform the validation operation
    you need, without using any external classes or controller validators. You will
    be able, also, to assign a certain rule to a certain operation (the `'create'`
    or the `'update'` operation, or both).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够指定验证规则和消息作为模型的静态属性。然后，模型将自动执行你需要的验证操作，而无需使用任何外部类或控制器验证器。你还将能够将特定的规则分配给特定的操作（`'create'`或`'update'`操作，或者两者都分配）。
- en: 'So, in your Model, you will have something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在你的模型中，你将会有类似以下的内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Smart password hashing
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能密码哈希
- en: Another thing you have to do frequently is to **hash a password**. Usually,
    you take the value from a `password` attribute. So, the Aweloquent Model automatically
    performs the hash operation on a `password` field, if present.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你经常需要做的事情是**哈希密码**。通常，你会从`password`属性中获取值。因此，Aweloquent模型会自动在存在`password`字段的情况下执行哈希操作。
- en: The autopurge of confirmation fields
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认字段的自动清除
- en: The Laravel validator has the confirmed rule, based on an `x_confirmation` attribute
    (where `x` is the name of the field). You have probably used it used it for a
    password confirmation field. The auto purge feature of the Aweloquent Model automatically
    removes (after validation, of course) every `_confirmation` field.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel验证器有一个基于`x_confirmation`属性（其中`x`是字段的名称）的确认规则。你可能已经用它来为密码确认字段使用过了。Aweloquent模型的自动清除功能会在验证后（当然）自动删除每个`_confirmation`字段。
- en: However, it's not over yet! The Aweloquent Model will automatically exclude
    the `'_token'` field, used by the **Cross Site Request Forgery** (**CSRF**) protection
    middleware.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还没有结束！Aweloquent模型将自动排除由**跨站请求伪造**（**CSRF**）保护中间件使用的`'_token'`字段。
- en: Alright, that's all! Now you can write some code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就结束了！现在你可以编写一些代码了。
- en: Extending the class
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类
- en: The first thing you have to do is to create a new class, the `AweloquentModel`
    class that extends the existing Eloquent Model one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先必须做的是创建一个新的类，即扩展现有Eloquent模型的`AweloquentModel`类。
- en: 'In my specific case, I made something really simple: I created a new folder
    called `Aweloquent` in the `app` one and then created an `AweloquentModel.php`
    file inside.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的特定情况下，我做了件非常简单的事情：我在`app`文件夹中创建了一个名为`Aweloquent`的新文件夹，然后在其中创建了一个`AweloquentModel.php`文件。
- en: 'Here''s the code you have to put into this file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你必须放入此文件的代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great! As a start, we have our new `AweloquentModel` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！作为一个开始，我们有了新的`AweloquentModel`类。
- en: If you want, you can use it as a base for your future models. There are no changes
    here, just a simple extension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以将其用作未来模型的基础。这里没有变化，只是简单的扩展。
- en: 'Let''s add the first feature: Auto Hydrate.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第一个功能：自动填充。
- en: The Auto Hydrate feature
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动填充功能
- en: Before we implement this first feature, let's think about what we want as a
    result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现这个第一个功能之前，让我们先思考一下我们想要的结果。
- en: 'Actually, when you create a new model, you can quickly pass its attributes
    using the constructor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你创建一个新模型时，你可以快速通过构造函数传递其属性：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These parameters are passed from the constructor to another method called `fill()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是从构造函数传递到另一个名为 `fill()` 的方法：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a logical consequence, if we want to implement this Auto Hydrate feature,
    we will have to write a new constructor to deal with the auto hydrating there
    and then to call the parent class. So, let''s go back to our `AweloquentModel`
    class. Here''s the first implementation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为逻辑上的后果，如果我们想实现这个自动填充功能，我们必须编写一个新的构造函数来处理那里的自动填充并调用父类。所以，让我们回到我们的 `AweloquentModel`
    类。这是第一个实现：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `autoHydrate` method creates the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoHydrate` 方法创建了以下内容：'
- en: An instance of the current request to get the required data
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前请求的一个实例以获取所需数据
- en: After that, and for each cycle, it adds to the attributes array every element
    in the request data array (excluding the CSRF `'_token'`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，并且对于每个循环，它将请求数据数组中的每个元素（排除 CSRF 的 `'_token'`）添加到属性数组中
- en: Note that the explicit specified attribute (the one you can put in the Model
    constructor) has the priority over the request data array. So, you are still free
    to deal with the Model and decide what to define and what not, maybe to add some
    extra data that you are not getting from the form.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，显式指定的属性（你可以在模型构造函数中放入的属性）具有优先级，高于请求数据数组。因此，你仍然可以自由地处理模型并决定定义什么，不定义什么，也许可以添加一些你从表单中未获取到的额外数据。
- en: If you try to create a new user by setting up a basic form, the Auto Hydrate
    feature is already working.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过设置基本表单来创建新用户，自动填充功能已经起作用了。
- en: Let's move forward!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进！
- en: The Aweloquent Model self-validation feature – the basic version
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aweloquent 模型自验证功能 – 基本版本
- en: 'It is time to implement the self-validation feature of our Aweloquent Model.
    The idea is quite simple: for every model, you will be able to declare (as properties)
    rules and related messages. So, it should look something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现我们 Aweloquent 模型的自验证功能了。这个想法很简单：对于每个模型，你将能够声明（作为属性）规则和相关消息。所以，它应该看起来像这样：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These rules and message will be used automatically by a `validate()` dedicated
    method. What I want to achieve is something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则和消息将被 `validate()` 专用方法自动使用。我想实现的是类似这样的效果：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, let''s open the `AweloquentModel.php` file and add some code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们打开 `AweloquentModel.php` 文件并添加一些代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great! The `Validator` `Facadec` is used to instantiate a new validator. The
    static `$rules` and `$message` attributes are used for the `make()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！`Validator` `Facadec` 用于实例化一个新的验证器。静态 `$rules` 和 `$message` 属性用于 `make()`
    方法。
- en: Then, the `$validator->fails()` call determines if the given model is valid
    or not. If not, the `$errors` property is populated using the validation errors
    `MessageBag` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`$validator->fails()` 调用确定给定的模型是否有效。如果不有效，则使用验证错误 `MessageBag` 对象填充 `$errors`
    属性。
- en: Obviously, this is a very basic validation system. However, we could do something
    more. For instance, an implementation of an operation-based validation would be
    great.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个非常基础的验证系统。然而，我们可以做更多。例如，基于操作的验证实现会很好。
- en: Go ahead and try it, if you want! It already works!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试，那就继续吧！它已经起作用了！
- en: The Aweloquent Model self-validation feature – the operation-based version
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aweloquent 模型自验证功能 – 操作版本
- en: In order to implement the advanced version of the self-validation system, we
    have to define the rule format for every model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现自验证系统的先进版本，我们必须为每个模型定义规则格式。
- en: 'In this specific one, I have chosen something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的版本中，我选择了类似这样的方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `$message` property is left untouched. The only one that has to be modified
    is `$rules`, as you may easily imagine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`$message` 属性保持不变。唯一需要修改的是 `$rules`，正如你可以想象的那样。'
- en: In this new version of `$rules`, you can define rules for a single operation,
    `'create'`, or both. If you want to use a rule in both of them, there is a dedicated
    `'everytime'` item to avoid the duplication of rules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `$rules` 的新版本中，你可以为单个操作 `'create'` 或两者都定义规则。如果你想在这两者中都使用规则，有一个专门的 `'everytime'`
    项来避免规则重复。
- en: Of course, we have to edit our `AweloquentModel` once again. This time, we have
    to define a method that has to work with the existing validate one and understand
    if we are creating or updating it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须再次编辑我们的 `AweloquentModel`。这次，我们必须定义一个方法，该方法必须与现有的验证方法一起工作，并理解我们是创建还是更新它。
- en: Then, merge the right rules in a single array and validate the model against
    those rules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将正确的规则合并到一个数组中，并验证模型是否符合这些规则。
- en: 'Let''s see what we can do! Consider the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能做什么！考虑以下代码：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great, we have it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们做到了！
- en: 'The `validate()` method doesn''t change too much. The only big difference stands
    in the newly line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`方法变化不大。唯一大的不同在于新的一行：'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Basically, we are saying, "Ok, now assign to the `$rules` property the result
    of this `mergeValidationRules()` method."
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们说的是：“好的，现在将`$rules`属性分配给这个`mergeValidationRules()`方法的返回结果。”
- en: 'Then, in the `mergeValidationRules()` method, the first instruction to be used
    is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`mergeValidationRules()`方法中，首先使用的指令是：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is used to determine if the current operation is an insert or an update.
    Starting from this value, we can get the right rules array, merging them with
    the `everytime` rules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于确定当前操作是插入还是更新。从这个值开始，我们可以获取正确的规则数组，并将它们与`everytime`规则合并。
- en: Your new complex self-validating model is almost ready to be used.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的复杂自验证模型几乎可以使用了。
- en: Smart password hashing and the confirmation fields autopurge method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能密码哈希和确认字段自动清除方法
- en: The last features we have to implement are the smart password hashing and confirmation
    fields auto purge methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现的最后两个功能是智能密码哈希和确认字段自动清除方法。
- en: 'The first is very easy and intuitive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事非常简单直观：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If a `'password'` field is present, hash it. Nothing more!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`'password'`字段，则对其进行哈希处理。仅此而已！
- en: 'Even if, it''s a little longer, the `purgeConfirmationFields()` isn''t so hard
    to understand:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它稍微长一点，`purgeConfirmationFields()`也不难理解：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time, I used the `Str` string utility class in order to use the `endsWith()`
    method, which is used to determine if a strings ends with a certain sequence of
    characters. Every `'_confirmation'` field is removed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我使用了`Str`字符串实用类来使用`endsWith()`方法，该方法用于确定字符串是否以某个字符序列结束。每个`'_confirmation'`字段都被移除。
- en: Fixing the save() Model method
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复save()模型方法
- en: 'Now, the last thing that we need to fix is the `save()` method. Actually, the
    `save()` method totally ignores the validation procedure, and this is no good.
    So, this is my final version of the `AweloquentModel` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修复的最后一件事情是`save()`方法。实际上，`save()`方法完全忽略了验证过程，这是不行的。所以，这是`AweloquentModel`类的最终版本：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s analyze the `save()` method in detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析`save()`方法：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing to do is to validate the entire input. After that, if everything
    is fine, passwords are hashed and the confirmation fields are purged, as we don't
    need them anymore.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是验证整个输入。之后，如果一切正常，密码将被哈希处理，确认字段将被清除，因为我们不再需要它们了。
- en: Finally, the `parent::save()` method is called, and the operation is complete.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`parent::save()`方法，操作完成。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to create a perfect continuity with the parent class, I declared the
    `save()` method with the same signature as its parent (including the `$options`
    array parameter).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与父类保持完美的连续性，我声明了与父类相同的签名（包括`$options`数组参数）的`save()`方法。
- en: That's it! The `AweloquentModel` class is finished, and you can use it as you
    want in your projects. You also learned how to go deep inside the `Model` class
    and extend it in order to add new methods, behaviors, and features.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！`AweloquentModel`类已经完成，你可以在你的项目中随意使用它。你还学会了如何深入到`Model`类中并扩展它，以便添加新的方法、行为和功能。
- en: Diving into the repository pattern
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解仓库模式
- en: If you know a couple of things about good development and best practices, you
    have probably heard about software design patterns.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解一些关于良好开发和最佳实践的知识，你可能听说过软件设计模式。
- en: 'You can define them as useful solution templates for a certain kind of problem,
    or to be more precise:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其定义为针对某种问题的有用解决方案模板，或者更准确地说：
- en: '*"In software engineering, a design pattern is a general reusable solution
    to a commonly occurring problem within a given context in software design. A design
    pattern is not a finished design that can be transformed directly into source
    or machine code. It is a description or template for how to solve a problem that
    can be used in many different situations. Patterns are formalized best practices
    that the programmer can use to solve common problems when designing an application
    or system."*'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在软件工程中，设计模式是在软件设计给定上下文中对常见问题的一般可重用解决方案。设计模式不是可以直接转换为源代码或机器代码的最终设计。它是对如何解决问题的描述或模板，可以在许多不同情况下使用。模式是程序员在设计和应用或系统时解决常见问题的最佳实践。"* '
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This extract is from the software design patterns page ([http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern))
    on Wikipedia.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个摘录来自维基百科上的软件设计模式页面([http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern))。
- en: Now, let's focus on the second sentence.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于第二句话。
- en: A design pattern is not something that can be transformed directly into source
    code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式不是可以直接转换为源代码的东西。
- en: That's the most important part because it explains many things. It is not something
    you learn specifically for Laravel or maybe for a certain language.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的部分，因为它解释了许多事情。这不是你为了 Laravel 或可能为了某种特定语言而专门学习的东西。
- en: Absolutely, once you learned about design patterns, it is for life!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对地，一旦你了解了设计模式，它就会伴随你一生！
- en: In the previous part of this chapter, you learned how to create an improved
    version of the Eloquent Model. You reached the objective by adding something to
    the existing model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分，你学习了如何创建 Eloquent 模型的改进版本。你通过向现有模型添加内容达到了目标。
- en: However, many people don't like that kind of approach. They strongly believe
    in the Single Responsibility Principle, so every class must do one and only one
    thing. Nothing more!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多人不喜欢这种做法。他们坚信单一职责原则，所以每个类必须只做一件事情。没有更多！
- en: Let's be clear; I don't want to bore you by adding my useless opinion in this
    long-time debate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一点；我不想通过在这个长时间的辩论中添加我的无用观点来让你感到无聊。
- en: In the final part of this chapter, I will introduce a specific design pattern
    that can be really useful for improving a Laravel application—the repository pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我将介绍一种可以真正有助于改进 Laravel 应用的特定设计模式——仓库模式。
- en: Hello, repository pattern!
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嗨，仓库模式！
- en: You know that I like to explain a concepts with an example as a start. This
    is no exception.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道我喜欢从例子开始解释一个概念。这也不例外。
- en: 'Imagine that you are building an application for a warehouse. In this warehouse,
    you can store whatever you want and you probably have a model like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为仓库构建一个应用程序。在这个仓库中，你可以存储任何你想要的东西，你可能有一个像这样的模型：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's nothing to say; it works, and you know it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么好说的；它有效，你知道这一点。
- en: This is a cool solution for a simple project, the kind of project that you can
    call an *application*. However, what happens if we don't have an *Application*,
    instead?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单项目的酷解决方案，你可以称之为**应用程序**。然而，如果我们没有**应用程序**，会发生什么呢？
- en: Imagine that the business you're helping grows and the management decides to
    create a mobile application that must be used internally. You will probably need
    to implement an API for the other developers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在帮助的业务在增长，管理层决定创建一个必须内部使用的移动应用程序。你可能需要为其他开发者实现一个 API。
- en: 'If you don''t know how to deal with something like this, you will soon start
    to write duplicated code. In your Rest API, for sure, there will be an endpoint
    `\items` that does the same thing you did in the controller method such as:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何处理这类事情，你很快就会开始编写重复的代码。在你的 Rest API 中，肯定会有一个 `\items` 端点，它执行你在控制器方法中执行的操作，例如：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Repeating the same code many times isn't safe. You know it, right?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的代码很多次是不安全的。你知道这一点，对吧？
- en: But no fear, hero! The solution is called a **repository pattern**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，英雄！解决方案被称为**仓库模式**。
- en: 'The best definition of this concept is the one you can find on Martin Fowler''s
    website ([http://martinfowler.com/eaaCatalog/repository.html](http://martinfowler.com/eaaCatalog/repository.html)):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的最佳定义可以在 Martin Fowler 的网站上找到([http://martinfowler.com/eaaCatalog/repository.html](http://martinfowler.com/eaaCatalog/repository.html))：
- en: '*"A Repository mediates between the domain and data mapping layers, acting
    like an in-memory domain object collection. Client objects construct query specifications
    declaratively and submit them to Repository for satisfaction.*'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"仓库在领域和数据映射层之间进行调解，就像内存中的领域对象集合。客户端对象以声明性方式构建查询规范，并将它们提交给仓库以满足需求。"*'
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Objects can be added to and removed from the Repository, as they can from
    a simple collection of objects, and the mapping code encapsulated by the Repository
    will carry out the appropriate operations behind the scenes."*'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*对象可以被添加到和从仓库中移除，就像它们可以从一个简单的对象集合中添加和移除一样，由仓库封装的映射代码将在幕后执行适当的操作。"*'
- en: So, imagine a repository as something in between that abstracts all the necessary.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想象一个仓库就像介于中间，抽象出所有必要的。
- en: Going back to the previous example, imagine that we have a repository with a
    dedicated method `getRecent($perPage, $pageNumber)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的例子，想象我们有一个包含专用方法`getRecent($perPage, $pageNumber)`的仓库。
- en: 'We will use the same method in the controller:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制器中使用相同的方法：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the Rest API, the following method is used:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rest API中，使用以下方法：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The same code is used twice and written once. However, there's more than this;
    let's see how to implement repositories in a Laravel project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的代码被两次使用，但只写了一次。然而，还有更多；让我们看看如何在Laravel项目中实现仓库。
- en: Introducing repositories – a concrete implementation
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍仓库——一个具体的实现
- en: The best way to start with repositories is to implement a concrete implementation.
    As I mentioned earlier, a repository stands between the controller and model.
    It is something in the middle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用仓库的最佳方式是实现一个具体的实现。正如我之前提到的，仓库位于控制器和模型之间。它是中间某个东西。
- en: When you build a repository, you must do it thinking about what you will need
    from the repository. Let's imagine something for our `Author` model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个仓库时，你必须考虑到你将需要从仓库中获取什么。让我们为我们的`Author`模型想象一个例子。
- en: 'I will probably need the following methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能需要以下方法：
- en: '`getAll($perPage, $pageNumber)`: This returns a paginated list of every author
    in my data source'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAll($perPage, $pageNumber)`: 这将返回数据源中每个作者的分页列表'
- en: '`find($authorId)`: This returns a specific author with a certain primary key'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find($authorId)`: 这将返回具有特定主键的特定作者'
- en: '`search($firstName, $lastName)`: This returns an array of results starting
    from the first name to the last name'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search($firstName, $lastName)`: 这将返回从第一个名字到最后一个名字的结果数组'
- en: 'Enough of searching for and getting records! However, we will also need other
    methods, which are dedicated to data persistence:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的搜索和获取记录了！然而，我们还需要其他方法，这些方法专门用于数据持久化：
- en: '`create($authorData)`: This will save a new author in the data source'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create($authorData)`: 这将在数据源中保存一个新的作者'
- en: '`save($authorData, $authorId)`: This will update an existing author in the
    data source with a certain primary key'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save($authorData, $authorId)`: 这将使用特定的主键更新数据源中现有的作者'
- en: Let's start!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始！
- en: First of all, create a new directory in the `app` folder. Name it `Repositories`.
    Inside it, create a new file called `DbAuthorsRepository.php`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`app`文件夹中创建一个新的目录。命名为`Repositories`。在其内部，创建一个名为`DbAuthorsRepository.php`的新文件。
- en: 'Here''s the content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是内容：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is how you can use it in some test routes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以在一些测试路由中使用它的方法：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nothing more!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多了！
- en: By creating a repository, you learned how to improve your software architecture
    and the abstraction level of your solution. Also, instead of what you saw earlier
    in this chapter with Aweloquent, this time you can feel a great separation of
    responsibilities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个仓库，你学习了如何改进你的软件架构和解决方案的抽象级别。此外，与本章前面提到的Aweloquent相比，这次你可以感受到职责的极大分离。
- en: However, this is not the end yet; the repository pattern hasn't yet shown all
    of its power.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还没有结束；仓库模式还没有展示出它的全部力量。
- en: Coding on Abstractions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在抽象上编码
- en: I already introduced you to the SOLID principles earlier in this chapter. I
    mentioned the Single Responsibility Principle, the *S* of SOLID. Now that we are
    close to the end, I will introduce the *D*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在本章的早期介绍了你SOLID原则。我提到了单一职责原则，SOLID的*S*。现在我们接近尾声，我将介绍*D*。
- en: The dependency inversion principle is one of my favorites because it really
    highlights the importance of abstracting your code base the best you can.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则是我最喜欢的之一，因为它真正强调了尽可能抽象你的代码库的重要性。
- en: 'Its definition is:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它的定义是：
- en: '*"A. High-level modules should not depend on low-level modules. Both should
    depend on abstractions.*'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “A. 高级模块不应该依赖于低级模块。两者都应该依赖于抽象。”
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*B. Abstractions should not depend on details. Details should depend on abstractions."*'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “B. 抽象不应该依赖于细节。细节应该依赖于抽象。”
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*-Wikipedia ([http://en.wikipedia.org/wiki/Dependency_inversion_principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle))*'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “-维基百科 ([http://en.wikipedia.org/wiki/Dependency_inversion_principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle))”
- en: 'In a few words, the concept is that you must code abstractions and should not
    depend on concrete classes. Else, a better way to say it: you must depend on abstractions
    and not on concrete classes.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个概念是你必须编写抽象，而不应该依赖于具体类。否则，更好的说法是：你必须依赖于抽象，而不是具体类。
- en: In PHP, talking about abstraction refers to working with interfaces and contracts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，谈论抽象是指使用接口和契约。
- en: In a certain sense, Laravel itself widely uses this concept. The basic Laravel
    package is `Contracts`, that is made up of several interfaces that specify whatevery
    component must do and how it does it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，Laravel本身广泛使用这个概念。基本的Laravel包是`Contracts`，它由几个接口组成，这些接口指定了每个组件必须做什么以及如何做。
- en: However, it's not just about a framework big thing. You can apply this principle
    in your everyday development. More specifically, you can apply the concept to
    repositories.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不仅仅是一个大型框架的问题。你可以在日常开发中应用这个原则。更具体地说，你可以将这个概念应用到仓库中。
- en: I will show you how!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我会向你展示如何！
- en: Repositories – a complete implementation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库 – 一个完整的实现
- en: Before we dive in, let's introduce a little problem to our software.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，让我们向我们的软件引入一个小问题。
- en: 'Actually, our situation is the following: our controllers and routes use the
    `DbAuthorsRepository` class to get data, like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的情况是这样的：我们的控制器和路由使用`DbAuthorsRepository`类来获取数据，如下所示：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the `DbAuthorsRepository` class uses the Author model in order to get
    the desired data from the physical storage:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`DbAuthorsRepository`类使用作者模型从物理存储中获取所需的数据：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's imagine that our data sources change. For a certain reason (I know,
    that is quite paradoxical), the management wants to switch to a file-based storage.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们的数据源发生了变化。出于某种原因（我知道，这相当矛盾），管理层想要切换到基于文件的存储。
- en: 'You have two ways to deal with this problem:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种处理这个问题的方法：
- en: You scream and are paralyzed by fear
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你尖叫并因恐惧而瘫痪
- en: Decide to organize your code base in a better way, introducing interfaces in
    to your repository workflow
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定以更好的方式组织你的代码库，在你的仓库工作流程中引入接口
- en: 'Here''s the plan:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计划：
- en: Using the Laravel service container, you can decide to bind a certain interface
    to a specific implementation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Laravel服务容器，你可以决定将某个接口绑定到特定的实现。
- en: So, if you create an interface for every repository, you will be able to write
    your code once and then write every concrete repository you need and, finally,
    to switch from one repository to another, you will have to change a single line
    of code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你为每个仓库创建一个接口，你将能够一次性编写代码，然后编写你需要的每个具体仓库，最后，要从一个仓库切换到另一个仓库，你只需更改一行代码。
- en: 'However, let''s make it step by step:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们一步一步来：
- en: First of all, let's define a standard behavior for our author's repository defining
    an `AuthorRepository` interface. Create a new `AuthorRepository.php` file in `app/Repositories/Contracts`.
    I will use the `Contracts` folder for interfaces.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的作者仓库定义一个标准行为，定义一个`AuthorRepository`接口。在`app/Repositories/Contracts`中创建一个新的`AuthorRepository.php`文件。我将使用`Contracts`文件夹来存储接口。
- en: 'Here''re the contents of the fresh file:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是新鲜文件的目录：
- en: '[PRE31]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interfaces are pure abstraction. All we are saying here is, "When I build a
    new author repository, I don't care about the underlying implementation. I don't
    care if I am working with a NoSQL database or a flat file driver. All I want is
    that every repository implements all these methods."
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口是纯粹的抽象。我们在这里所说的就是，“当我构建一个新的作者仓库时，我不关心底层的实现。我不在乎我是使用NoSQL数据库还是平面文件驱动器。我只想每个仓库都实现所有这些方法。”
- en: Working in this manner means that we can define a standard format for every
    component (or repository, in this case) that we will use in the future.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式工作意味着我们可以为未来使用的每个组件（或在这个案例中是仓库）定义一个标准格式。
- en: 'Now we can update our `DbAuthorsRepository` class in order to implement our
    interface. Consider the following line:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的`DbAuthorsRepository`类以实现我们的接口。考虑以下行：
- en: '[PRE32]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ok. Now, let's see the power of the entire mechanism in action.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的。现在，让我们看看整个机制在实际中的威力。
- en: 'First of all, open the `app/Providers/AppServiceProvider.php` file and add
    this binding to the `register()` method:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`app/Providers/AppServiceProvider.php`文件，并将此绑定添加到`register()`方法中：
- en: '[PRE33]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Laravel now knows that every time you will request an instance of `AuthorsRepository`,
    it will have to create an instance of the `DbAuthorsRepository` using the service
    container.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Laravel现在知道，每次你请求`AuthorsRepository`的实例时，它都必须使用服务容器创建一个`DbAuthorsRepository`的实例。
- en: 'To test our assumptions, open the routes file and add this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的假设，打开路由文件并添加以下内容：
- en: '[PRE34]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The result will be exactly what we are expecting. Also, using the method injection
    technique, we don't have to explicitly call the service container.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果将正好是我们所期望的。此外，使用方法注入技术，我们不需要显式调用服务容器。
- en: 'In fact, an alternative to this syntax would be the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实上，这个语法的替代方案可以是以下这样：
- en: '[PRE35]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Adding the new repository
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的仓库
- en: 'Finally, we are close to the end. Let''s return to our main problem: we have
    to implement a new file-based author''s repository.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们接近了尾声。让我们回到我们的主要问题：我们必须实现一个新的基于文件的作者仓库。
- en: 'At this point, it is quite easy:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当简单：
- en: First, create a new file in `app/Repositories`, called `FileAuthorsRepository`.
    It will be a new class, of course.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`app/Repositories`中创建一个新的文件，命名为`FileAuthorsRepository`。它将是一个新的类，当然。
- en: It will implement the AuthorsRepository interface, obviously.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将实现`AuthorsRepository`接口，这是显而易见的。
- en: 'Here are the class contents:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是类的内容：
- en: '[PRE36]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can easily see, I have implemented all the required methods from the
    interface. This means that our application will be able to use the FileAuthorsRepository
    in the same way as the DbAuthorsRepository.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所容易看到的，我已经从接口实现了所有必需的方法。这意味着我们的应用程序将能够以与DbAuthorsRepository相同的方式使用FileAuthorsRepository。
- en: 'I filled method bodies with some `dd` instructions, just to show you how the
    concept works. For our final step, go to the `AppServiceProvider` class and update
    the previous binding to the following:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在方法体中添加了一些`dd`指令，只是为了展示这个概念是如何工作的。为了我们的最后一步，前往`AppServiceProvider`类并更新之前的绑定到以下内容：
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, browse to the `/authors` route. Yes, the output now is:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，浏览到`/authors`路由。是的，输出现在是：
- en: '**"getting all records from flat file driver..."**'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**"从平面文件驱动程序获取所有记录..."**'
- en: Yes, it worked!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它工作了！
- en: 'Our route file will never know what repository it is using: the interface defines
    all the methods you need.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由文件永远不会知道它正在使用哪个仓库：接口定义了你需要的所有方法。
- en: This is fantastic because, for instance, if you want to add a NoSQL repository
    to your application in the future, all you will have to do is to create a new
    `NoSQLAuthorsRepository` class that implements the `AuthorsRepository` interface.
    Then, in the `AppServiceProvider`, you will switch the binding with the one you
    need.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太棒了，因为例如，如果你想在将来将NoSQL仓库添加到你的应用程序中，你只需要创建一个新的`NoSQLAuthorsRepository`类，该类实现了`AuthorsRepository`接口。然后，在`AppServiceProvider`中，你将切换到所需的绑定。
- en: Easy, cool, and also testable!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 简单、酷炫，而且可测试！
- en: 'Maybe I am a little repetitive, but focus your attention on this specific point:
    with the mentioned structure, you can abstract the way you work with your data
    from the way you access to it. I know that reading the same thing again and again
    is boring, but I need you to understand this concept.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我有点重复，但请关注这个具体点：使用提到的结构，你可以将处理数据的方式与访问数据的方式抽象出来。我知道一遍又一遍地读同样的事情很无聊，但我需要你理解这个概念。
- en: It is probable that the first time you read about repositories you will think
    *what am I doing here? What the hell?* I have done the same thing, so I totally
    understand your doubts. However, when you work on a more complex project, you
    will totally feel the difference.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你第一次读到关于仓库的内容时，会想“我在这里做什么？见鬼了？”我也做过同样的事情，所以我完全理解你的疑惑。然而，当你处理更复杂的项目时，你将完全感受到这种差异。
- en: That's the magic of repositories!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是仓库的魔力！
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We are done. In this final chapter, you learned about empowering your application
    in two different and separate ways: on one hand, adding features on an existing
    entity. In this case, the Eloquent Model.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。在本章的最后，你学习了以两种不同且独立的方式增强你的应用程序：一方面，向现有实体添加功能。在这种情况下，是Eloquent模型。
- en: On the other one, you learned how to structure your application in a different
    way using repositories in order to get a better code testability, maintainability,
    and a separation of purposes instead of delegating everything to a single class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，你学习了如何使用仓库以不同的方式来结构你的应用程序，以便获得更好的代码可测试性、可维护性，以及目的的分离，而不是将一切委托给单个类。
- en: Now you have all the tools you need to build great applications using Eloquent
    and Laravel.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了构建优秀应用程序所需的所有工具，使用Eloquent和Laravel吧。
- en: What are you waiting for? Go on and make me proud!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在等什么？继续吧，让我为你感到骄傲！
