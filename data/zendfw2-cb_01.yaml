- en: Chapter 1. Zend Framework 2 Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Zend Framework 2基础知识
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: Setting up a Zend Framework 2 project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Zend Framework 2项目
- en: Handling routines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序
- en: Understanding dependency injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入
- en: Using configurations to your benefit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用配置来获得好处
- en: The EventManager and Bootstrap classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件管理器和Bootstrap类
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we will go through a basic Zend Framework 2 application, from
    download, to setup, to running it. If you are unfamiliar with how Zend Framework
    2 works, and the best way to install it, you can use this chapter as a reference.
    Further on in the chapter, we will get somewhat deeper in the framework by looking
    at the **dependency injection** (**DI**) and how it can help us code more efficiently.
    Lastly we will go more into the details of the configuration options, the `EventManager`
    and `ModuleManager`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始介绍一个基本的Zend Framework 2应用程序，从下载、设置到运行。如果您不熟悉Zend Framework 2的工作原理以及最佳安装方式，可以使用本章作为参考。在章节的后续部分，我们将通过查看**依赖注入**（**DI**）以及它如何帮助我们更高效地编码来对框架进行更深入的了解。最后，我们将更详细地介绍配置选项、`EventManager`和`ModuleManager`。
- en: Setting up a Zend Framework 2 project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Zend Framework 2项目
- en: Nothing is more exciting than setting up a new project in our favourite framework.
    Every time we start a new project we begin with a clean slate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比在我们的最爱框架中设置一个新的项目更令人兴奋的了。每次我们开始一个新的项目，我们都是从一张白纸开始。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you can set up a new Zend Framework 2 application you need to make sure
    you have the following items ready:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您设置新的Zend Framework 2应用程序之前，您需要确保您已准备好以下项目：
- en: A web server such as Apache running PHP Version 5.3.3 or higher that you can
    reach from a web browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个运行PHP版本5.3.3或更高版本的Apache网络服务器，您可以通过网络浏览器访问它
- en: Git
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: If you don't have everything ready as mentioned, you are best off reading the
    topics mentioned in the *See also* section of this recipe (every topic we explain
    in this chapter is called a recipe) before you continue reading here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有准备好上述所有项目，您最好在继续阅读本章内容之前，阅读本食谱中提到的*也见*部分（我们本章中解释的每个主题都称为食谱）。
- en: We are assuming that Zend Framework 2 will be used on a Linux-based platform
    running an Apache 2 web server; this means that commands might not directly work
    on a Windows platform. Windows users, however, can set up a virtual machine with
    Linux on it to make full use of the book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设将在基于Linux的平台和Apache 2网络服务器上使用Zend Framework 2；这意味着命令可能不会在Windows平台上直接工作。然而，Windows用户可以通过在虚拟机上安装Linux来设置虚拟机，以充分利用本书。
- en: To install a virtual machine on Windows, we can use an application called Oracle
    VM VirtualBox, which is freely available. We can go to [www.virtualbox.org](http://www.virtualbox.org)
    and download plus install the latest version of VirtualBox, we can go to VirtualBoxes
    ([http://virtualboxes.org/images/ubuntu](http://virtualboxes.org/images/ubuntu))
    and download a preconfigured virtual machine from there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装虚拟机，我们可以使用一个名为Oracle VM VirtualBox的应用程序，它是免费提供的。我们可以访问[www.virtualbox.org](http://www.virtualbox.org)下载并安装VirtualBox的最新版本，我们还可以访问VirtualBoxes
    ([http://virtualboxes.org/images/ubuntu](http://virtualboxes.org/images/ubuntu))并从那里下载一个预配置的虚拟机。
- en: All we have to do on the VirtualBoxes website is click on the latest Ubuntu
    (which is a distribution of Linux) link in the list, please take note of the username
    and password displayed there as we will need it later to login. Once the image
    is downloaded, it can be made ready by following the instructions in the documentation
    that can be found on the VirtualBoxes site ([http://virtualboxes.org/doc/register-and-load-a-downloaded-image](http://virtualboxes.org/doc/register-and-load-a-downloaded-image)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在VirtualBoxes网站上，我们只需点击列表中最新的Ubuntu（Linux的一个发行版）链接，请注意那里显示的用户名和密码，因为我们稍后会需要它们来登录。一旦下载了镜像，就可以按照VirtualBoxes网站上可找到的文档说明将其准备好（[http://virtualboxes.org/doc/register-and-load-a-downloaded-image](http://virtualboxes.org/doc/register-and-load-a-downloaded-image)）。
- en: Assuming the image is imported we can easily start up the virtual machine and
    put in our username and password that has been supplied with the downloaded virtual
    machine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设图像已导入，我们可以轻松启动虚拟机并输入与下载的虚拟机一起提供的用户名和密码。
- en: 'Once logged in to the virtual machine we need to make sure Git is installed,
    which can be done easily by typing in the following command (mind that the dollar
    sign is the command prompt, and not the command we actually need to type):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到虚拟机后，我们需要确保Git已安装，这可以通过输入以下命令轻松完成（请注意，美元符号是命令提示符，而不是我们需要输入的命令）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If Git wasn't installed, the system will ask you to install Git, which can be
    done by pressing the *Y* key, followed by the *Enter* key, on the other hand if
    Git was already installed, than it will not do anything and tell you it already
    is installed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Git未安装，系统将提示您安装Git，这可以通过按*Y*键，然后按*Enter*键来完成；另一方面，如果Git已经安装，则不会进行任何操作，并告诉您它已经安装。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: First of all, we need the Zend Framework 2 skeleton so we can easily create
    a new project. A skeleton is a template structure that can be used to start developing
    with an application, and in this case it creates a template for us to develop
    within Zend Framework. Fortunately doing this is relatively easy, and almost never
    causes any problems, and when it does, it is usually related to Git not being
    able to retrieve the code. When Git isn't able to retrieve the skeleton, please
    make sure there are no spelling mistakes in the command, and that Git has outside
    access (we can test this by typing `ping Github.com` and see whether we get a
    response back).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要Zend Framework 2骨架，这样我们就可以轻松地创建一个新项目。骨架是一个模板结构，可以用来开始使用应用程序进行开发，在这种情况下，它为我们创建了一个在Zend
    Framework中开发的模板。幸运的是，这样做相对简单，几乎从不引起任何问题，当它发生时，通常与Git无法检索代码有关。当Git无法检索骨架时，请确保命令中没有拼写错误，并且Git有外部访问权限（我们可以通过输入`ping
    Github.com`并查看是否收到响应来测试这一点）。
- en: The method we are going to use to retrieve the skeleton is called **cloning**,
    through a version control system called Git. Cloning the source code will make
    sure we always get the latest version that the developer (in this case Zend itself)
    has put online.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的方法称为**克隆**，通过名为Git的版本控制系统。克隆源代码将确保我们总是获取开发者（在这种情况下是Zend本身）已上传的最新版本。
- en: Cloning the skeleton
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克隆骨架
- en: 'We can clone the skeleton—and almost everything else on Github for that matter
    — through use of the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令克隆骨架——实际上，在GitHub上几乎可以克隆任何东西：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Moving the skeleton
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动骨架
- en: 'Once finished we can go into the newly created folder called `ZendSkeletonApplication`,
    and copy and paste everything in there over to our web server document root. On
    a Linux system this is usually `/var/www` (this is also the case when we use Zend
    Server, as described in the [Appendix](apa.html "Appendix A. Setting up the Essentials"),
    *Setting up the Essentials*). We can do this, for example, by typing the following
    commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以进入新创建的名为`ZendSkeletonApplication`的文件夹，并将里面的所有内容复制粘贴到我们的Web服务器文档根目录。在Linux系统中，这通常是`/var/www`（当我们使用Zend
    Server时也是如此，如[附录](apa.html "附录A. 设置基本要素")中所述，*设置基本要素*）。我们可以通过输入以下命令来完成此操作：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initializing the Composer
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Composer
- en: 'When everything is copied over, we are going to initialize the project by typing
    the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内容复制完毕后，我们将通过输入以下命令来初始化项目：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now the **Command Line Interface** (**CLI**) of PHP executes `composer.phar`,
    which will in this instance, download and install the Zend Framework 2 library
    and set up a simple project for us to be able to work in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PHP的**命令行界面**（**CLI**）执行`composer.phar`，在这个例子中，它将下载并安装Zend Framework 2库，并为我们设置一个简单项目，以便我们能够工作。
- en: This command can take a long time before it is successfully executed, as Composer
    needs to do a lot of things before it tells you that Zend Framework 2 is ready
    for use, we won't go into the details of the workings of Composer here, as it
    is already discussed in the [Appendix](apa.html "Appendix A. Setting up the Essentials"),
    *Setting up the Essentials*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可能需要很长时间才能成功执行，因为Composer需要在告诉您Zend Framework 2已准备好使用之前完成很多事情，我们在这里不会深入讨论Composer的工作原理，因为它已经在[附录](apa.html
    "附录A. 设置基本要素")中讨论过，*设置基本要素*。
- en: Once this command has been completed we need to make sure our web server document
    root is changed to match the layout of the skeleton. It is common practice that
    Zend Framework 2 uses the `public` folder as a main landing point for the application.
    The structure of the Zend Framework 2 skeleton allows us to bind the user to the
    `public` folder, while all our logic is safely outside the public area.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此命令，我们需要确保我们的Web服务器文档根已更改以匹配骨架布局。通常的做法是，Zend Framework 2使用`public`文件夹作为应用程序的主要着陆点。Zend
    Framework 2骨架的结构允许我们将用户绑定到`public`文件夹，同时所有逻辑都安全地位于公共区域之外。
- en: In essence this means we need to `root` or `jail` the web server in using the
    `public` folder first before we can actually see anything that we just installed.
    We want to `root` or `jail` the web server because we don't want the outside world
    to be able to abuse our web server more than necessary, and rooting or jailing
    makes sure that the web server itself has no access to any other folders than
    what it is jailed to, thus making our server a bit more secure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这意味着我们需要首先使用`public`文件夹`root`或`jail`Web服务器，然后我们才能真正看到我们刚刚安装的内容。我们想要`root`或`jail`Web服务器，因为我们不希望外部世界过度滥用我们的Web服务器，而`root`或`jail`确保Web服务器本身无法访问除其被`jail`的文件夹之外的其他任何文件夹，从而使我们的服务器更加安全。
- en: In my personal case this means changing the Apache 2 configuration. In most
    Linux-based systems it will be the Apache web server that is serving our web requests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人的情况下，这意味着更改Apache 2配置。在大多数基于Linux的系统上，它将是Apache Web服务器为我们提供Web请求。
- en: The easiest thing that you can do is find your web server configuration (usually
    located in `/etc/apache2` and append the DocumentRoot with `/public`. For me this
    would change the document root from `/var/www' to '/var/www/public`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的事情就是找到您的Web服务器配置（通常位于`/etc/apache2`），并将DocumentRoot追加为`/public`。对我来说，这将更改文档根从`/var/www`到`/var/www/public`。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are using Apache, you need to check if the `AllowOverride` setting is
    set correctly, this can be found in the same section as your document root and
    should reflect the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Apache，您需要检查`AllowOverride`设置是否设置正确，这可以在与文档根相同的部分找到，并应反映以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally we need to restart the Apache web server, which can be done by the following
    command if you are logged in as a root user or invoke it by prepending the command
    with `sudo`, which tells the server that we want to execute it as a super user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要重新启动Apache Web服务器，如果您以root用户登录，可以通过以下命令完成，或者通过在命令前添加`sudo`来调用它，这告诉服务器我们想要以超级用户身份执行它。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we are able to check our browser and see what we have actually done. We
    now simply go with a web browser to the project created by typing in the URL,
    in my case this would be the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够检查我们的浏览器并查看我们实际上做了什么。我们现在只需使用Web浏览器输入URL访问创建的项目，在我的情况下，这将如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will result in the following screen:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下屏幕：
- en: '![Initializing the Composer](img/4841OS_01_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![初始化Composer](img/4841OS_01_01.jpg)'
- en: Congratulations, you have now set up a basic Zend Framework 2 application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您现在已设置了一个基本的Zend Framework 2应用程序。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: After getting the basic Zend Framework 2 skeleton working, it is the perfect
    time to install the ZFTool. The ZFTool is a utility module that comes in handy
    when we want to list the current modules in our project, or add a new module,
    or even set up a new project. It also contains an extremely useful class-map generator
    that we can use in the somewhat more advanced areas of Zend Framework 2.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本Zend Framework 2骨架工作正常后，安装ZFTool是完美的时机。ZFTool是一个实用模块，当我们需要列出项目中的当前模块、添加新模块或设置新项目时，它非常有用。它还包含一个极其有用的类映射生成器，我们可以在Zend
    Framework 2的某些更高级区域中使用它。
- en: 'We can install this utility by using the following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令安装此实用程序：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although we already set up our Zend Framework 2 skeleton through the composer,
    it might be a fun thing to show you how you can easily set up a new project through
    the ZFTool.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已通过composer设置了Zend Framework 2骨架，但向您展示如何轻松通过ZFTool设置新项目可能很有趣。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding command will create a new Zend Framework 2 skeleton project in
    the folder `/var/www/new-project`. In turn this means that the document root for
    our new project should be set to `/var/www/new-project/public`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`/var/www/new-project`文件夹中创建一个新的Zend Framework 2骨架项目。这反过来意味着我们新项目的文档根应设置为`/var/www/new-project/public`。
- en: 'To complete the Zend Framework 2 application in our new-project, we can simply
    go to the new-project directory and execute the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成新项目中Zend Framework 2应用程序，我们只需进入新项目目录并执行以下命令：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another handy command of the ZFTool is the creation and display of modules
    in our project. The ZFTool can easily display a list of modules that we currently
    use (with larger applications we tend to lose sight of the modules) and the ability
    to create a new skeleton module for our application. To see a list of the current
    modules used in our application we can use the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ZFTool的另一个实用命令是在我们的项目中创建和显示模块。ZFTool可以轻松显示我们当前使用的模块列表（对于大型应用程序，我们往往容易失去对模块的视线），以及为我们应用程序创建新骨架模块的能力。要查看我们应用程序中当前使用的模块列表，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create a new module named `wow-module` in our project based in the directory
    `/var/www/new-project` we can use the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于`/var/www/new-project`目录的项目中创建一个名为`wow-module`的新模块，我们可以使用以下命令：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Giving the path to the application is optional, but if we are using it with
    multiple projects on the same machine, it is best to make sure that we have the
    right path for our project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提供应用程序的路径是可选的，但如果我们在同一台机器上使用多个项目，最好确保我们有正确的项目路径。
- en: And now for the last and probably the most useful command in the ZFTool box,
    the class-map generator. A class-map file is a file that has all the classes of
    a project with their respective paths declared, which makes it easier for the
    PHP auto loaders to load the class file. Normally class files are found in paths
    that we know of, creating a small lag because the auto loader actually needs to
    search for the file. With a class-map file, however, this is not the case as the
    auto load can immediately find the file required.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一条，也可能是ZFTool中最有用的一条命令，即类映射生成器。类映射文件是一个包含项目所有类及其相应路径的文件，这使得PHP自动加载器加载类文件变得更容易。通常类文件位于我们知道的路径中，这会导致自动加载器实际上需要搜索文件，从而产生小的延迟。然而，使用类映射文件，情况并非如此，因为自动加载器可以立即找到所需的文件。
- en: Class-mapping is a big issue in Zend Framework 2 because a bad class mapping
    can make a good application terribly slow, and to be completely fair Zend Framework
    2 can use all the speed it can get.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类映射在Zend Framework 2中是一个大问题，因为不良的类映射可以使一个良好的应用程序运行得非常慢，而且为了完全公平，Zend Framework
    2可以使用它所能获得的所有速度。
- en: What the class-map generator does is create a file that contains all the classes
    and paths that can be autoloaded. That way we don't have to worry about where
    the classes are located.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类映射生成器的作用是创建一个包含所有可自动加载的类和路径的文件。这样我们就不必担心类的位置。
- en: 'To generate a new class-map file, we can use the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成新的类映射文件，我们可以使用以下命令：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command requires us to give in two different parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 命令要求我们提供两个不同的参数：
- en: '`<directory`>: The directory that needs to have the classes indexed. For example,
    this can be a new library you added to the `vendor` directory.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<directory`>：需要索引类的目录。例如，这可以是添加到`vendor`目录的新库。'
- en: '`<file>`: This is the class-map file the ZFTool needs to generate. Our auto
    loader in Zend Framework 2 needs to pick this file up, so we need to make sure
    that the ZFTool can find the file. If you don''t specify a file, it will create
    a file called `autoload_classmap.php` in the current working directory.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<file>`：这是ZFTool需要生成的类映射文件。我们的Zend Framework 2自动加载器需要拾取此文件，因此我们需要确保ZFTool可以找到该文件。如果您没有指定文件，它将在当前工作目录中创建一个名为`autoload_classmap.php`的文件。'
- en: Most of the time it is necessary to append a class-map file instead of overwriting
    it, if you want to append it you can simply change `-w` with `-a`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，如果您想追加而不是覆盖类映射文件，这是必要的，如果您想追加，只需将`-w`改为`-a`。
- en: 'An example of a class-map file is the `autoload_namespaces.php` file in the
    `vendor/composer` directory, and it looks a little bit like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类映射文件的示例是`vendor/composer`目录中的`autoload_namespaces.php`文件，它看起来有点像这样：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: There's more…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are also other ways of installing the ZFTool, some are just as easy as
    using the composer, so we'll cover two other methods of installing the ZFTool.
    That way we give ourselves the broadest options available to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ZFTool也有其他方法，其中一些与使用composer一样简单，所以我们将介绍两种其他安装ZFTool的方法。这样我们就能获得最广泛的可选方案。
- en: Another method of installing ZFTool is by utilizing git, and thus cloning the
    source code from the repository itself. This however gets the current master version,
    which can be a bit buggy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ZFTool的另一种方法是利用git，从而从仓库本身克隆源代码。然而，这会获取当前的master版本，可能会有些bug。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instead of `zftool.phar` we have now got the `zf.php` file at our disposal,
    which can be used in exactly the same way. Now we have covered all the different
    options on installing ZFTool.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`zf.php`文件，可以像使用`zftool.phar`一样使用它。现在我们已经涵盖了安装ZFTool的所有不同选项。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Making sure you have all that you need* recipe in the [Appendix](apa.html
    "Appendix A. Setting up the Essentials"), *Setting up the Essentials*
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录](apa.html "附录 A. 设置基本要素")中的*确保你拥有所有需要的东西*配方，*设置基本要素*'
- en: The *Downloading Zend Framework 2 and finding its documentation* recipe in the
    [Appendix](apa.html "Appendix A. Setting up the Essentials"), *Setting up the
    Essentials*
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录](apa.html "附录 A. 设置基本要素")中的*下载Zend Framework 2及其文档*配方，*设置基本要素*'
- en: The *Composer and its uses within Zend Framework 2* recipe in the [Appendix](apa.html
    "Appendix A. Setting up the Essentials"), *Setting up the Essentials*
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录](apa.html "附录 A. 设置基本要素")中的*作曲家及其在Zend Framework 2中的用途*配方，*设置基本要素*'
- en: Apache web server [http://apache.org/](http://apache.org/)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache网络服务器 [http://apache.org/](http://apache.org/)
- en: PHP website [http://php.net](http://php.net)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP网站 [http://php.net](http://php.net)
- en: Handling routines
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理例程
- en: An important aspect (if not the most important one) is the routing within Zend
    Framework 2\. In its most basic form routing tells the framework how the user
    should get from page A to page B, and what needs to be done to arrive at that
    destination. That is why we generally think this is the most important part to
    understand if you are just starting out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要方面（如果不是最重要的方面）是Zend Framework 2中的路由。在其最基本的形式中，路由告诉框架用户应该如何从页面A到达页面B，以及到达那个目的地需要做什么。这就是为什么我们通常认为这是如果你是初学者的话，理解的最重要部分。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To define a route we can simply go into one of the configuration files and add
    the router configuration to there.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个路由，我们只需进入一个配置文件，并将路由配置添加到那里。
- en: Setting up routing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置路由
- en: 'Let''s look at our simple (`Segment`) configuration as follows (file: `/module/Application/config/module.config.php`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的简单（`Segment`）配置如下（文件：`/module/Application/config/module.config.php`）：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this basic configuration we can easily define routes in our application,
    and in this instance we have configured a route that responds to the `/website`
    URL. When we would go to the `/website` URL, we would be routed to the `Website\Controller\Index::indexAction`
    by default. If we however use the route `/website/another/route`, we would be
    routed to the `Website\Controller\Another::routeAction`, as we have defined that
    the controller and action can be parsed behind that. If we omit the route path
    and put in `/website/another`, we would be redirected to the `Website\Controller\Another::indexAction`,
    as that is used by default by the framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本配置，我们可以轻松地在我们的应用程序中定义路由，在这个例子中，我们已经配置了一个响应`/website` URL的路由。当我们访问`/website`
    URL时，我们默认会被路由到`Website\Controller\Index::indexAction`。如果我们使用路由`/website/another/route`，我们会被路由到`Website\Controller\Another::routeAction`，因为我们已经定义了控制器和动作可以解析在后面。如果我们省略路由路径并输入`/website/another`，我们会重定向到`Website\Controller\Another::indexAction`，因为这是框架默认使用的。
- en: The preceding example has only one really major drawback, which is, when we
    decide to use anonymous function in the configuration to create more dynamic routes,
    we would not be able to cache the route as closures are not serializeable by the
    cache.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例只有一个真正的主要缺点，那就是当我们决定在配置中使用匿名函数来创建更多动态路由时，我们无法缓存路由，因为闭包不能被缓存序列化。
- en: However, there is another method of declaring the route, and that is in the
    code. The need to create the route functionality in the code could (obviously
    everyone has their own reasons and requirements) arise because we want to cache
    the configuration in a later stage (as we cannot cache anonymous function, for
    example) or when we want to load up a route dynamically from a database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种声明路由的方法，那就是在代码中。在代码中创建路由功能的需求（显然每个人都有自己的原因和需求）可能是因为我们想在稍后的阶段缓存配置（例如，因为我们不能缓存匿名函数）或者当我们想从数据库中动态加载路由时。
- en: 'Let''s take a look at the `/module/Application/Module.php` example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`/module/Application/Module.php`的例子：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Naturally there are more ways of adding a route, but the method mentioned in
    the preceding code for adding a route displays a canny way of dynamically adding
    a route. What we created there is that whenever Gdog goes to his profile, he can
    simply type in `http://example.ext/gdog` and end up on his profile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，有更多添加路由的方法，但前述代码中提到的添加路由的方法展示了动态添加路由的巧妙方式。我们在那里创建的是，每当Gdog去他的个人资料时，他可以简单地输入`http://example.ext/gdog`并最终到达他的个人资料页面。
- en: Even more wonderful is that if our friend Gdog wants to see his friends, he
    is able to do that by just typing in for example, `http://example.ext/gdog/my/friends`,
    which will resolve to the `Member` module and then go to the `My` controller,
    lastly executing the `Friends` action.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人惊奇的是，如果我们的朋友Gdog想看看他的朋友，他只需输入例如`http://example.ext/gdog/my/friends`，这将解析到`Member`模块，然后转到`My`控制器，最后执行`Friends`操作。
- en: Using SimpleRouteStack
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SimpleRouteStack
- en: This route stack is—as the name implies—the simplest router around and is basically
    a list with routes that is being parsed to see which route matches, by default
    this type of router is not used in Zend Framework 2\. The general rule of thumb
    is that if we want to add a route with a high priority, we give it a high index
    number for example, 100, or 200\. If we want to give the route a very low priority,
    we would give it an index number of, for example, 5 or 10.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由栈——正如其名所示——是最简单的路由器之一，基本上是一个包含路由的列表，这些路由被解析以查看哪个路由匹配。默认情况下，这种类型的路由器在Zend
    Framework 2中不被使用。一般规则是，如果我们想添加一个具有高优先级的路由，我们给它一个高的索引号，例如100或200。如果我们想给路由一个非常低的优先级，我们会给它一个索引号，例如5或10。
- en: Giving priorities to routes comes in handy when we have very specific routes
    (which usually have a high priority) and less specific routes (low priority).
    If we, for example, want to make `/website/url` redirect to a completely different
    module, controller, and action, but not affect the other website routes, we need
    to give the `/website/url` route a higher priority so that when it is found, it
    will not search for the lower priority routes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有非常具体的路由（通常具有高优先级）和不太具体的路由（低优先级）时，给路由分配优先级很有用。如果我们，例如，想让`/website/url`重定向到一个完全不同的模块、控制器和操作，但不影响其他网站路由，我们需要给`/website/url`路由一个更高的优先级，这样当它被找到时，它就不会搜索低优先级的路由。
- en: If we, by accident, turn the priorities around, we would find our `/website/url`
    always redirect to the route that contains all the `/website` routes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心颠倒了优先级，我们会发现我们的`/website/url`总是重定向到包含所有`/website`路由的路由。
- en: '`SimpleRouteStack` uses a `Zend\Mvc\Router\PriorityList` class to manage its
    routes priorities.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleRouteStack`使用`Zend\Mvc\Router\PriorityList`类来管理其路由优先级。'
- en: We need to consider routing before we want to start creating our application,
    as when the application grows we might get into trouble with our routing if we
    haven't considered 'how to route' beforehand. It would therefore be wise for us
    to 'sitemap' the application before coding the routes to make sure we have a correct
    route list and are not creating any conflicting routes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要开始创建应用程序之前，我们需要考虑路由，因为当应用程序增长时，如果我们没有事先考虑“如何路由”，我们可能会遇到路由问题。因此，在我们编码路由之前“绘制”应用程序的“网站地图”是明智的，以确保我们有正确的路由列表，并且没有创建任何冲突的路由。
- en: 'The `SimpleRouteStack` class has a number of methods defined that are very
    useful for us:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleRouteStack`类定义了一些对我们非常有用的方法：'
- en: '`getRoute($name)` / `getRoutes($name)`: This will retrieve the current route—if
    a name is provided—or routes that are defined in our `SimpleRouteStack`. If we
    are unsure about the routes we have defined, this would be a good place to check
    first.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRoute($name)` / `getRoutes($name)`: 这将检索当前路由——如果提供了名称——或者检索我们定义在`SimpleRouteStack`中的路由。如果我们不确定我们定义了哪些路由，这是一个首先检查的好地方。'
- en: '`addRoute($name, $route, $priority)` / `addRoutes($routes)`: We can use this
    to add a new route or an array of routes to our route type by simply adding it
    through this method. A route requires a `name`, `route` (which can be a string
    or an instance of `RouteInterface`) and if we fancy a priority, we can give that
    as the third parameter.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`addRoute($name, $route, $priority)` / `addRoutes($routes)`: 我们可以通过简单地将它添加到这个方法中来使用它来添加一个新的路由或一组路由到我们的路由类型。一个路由需要一个
    `name`、`route`（可以是字符串或 `RouteInterface` 的实例）以及如果我们想要一个优先级，我们可以将其作为第三个参数提供。'
- en: '`hasRoute($name)`: If we would want to check whether a specific route already
    exists, we can search using its `name` and find out if it does or doesn''t.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasRoute($name)`: 如果我们想要检查是否存在特定的路由，我们可以通过其 `name` 来搜索，并找出它是否存在。'
- en: '`removeRoute($name)`: When we are tired of a route we can simply give its name
    and remove it from the list. This can be particularly handy if we want for example
    to have a module override a certain /login when the user has logged in to route
    to/user.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeRoute($name)`: 当我们厌倦了一个路由时，我们可以简单地给出它的名字，并将其从列表中删除。如果我们想要例如在用户登录后重定向到
    /user 而不是 /login，这可能会特别有用。'
- en: '`SimpleRouteStack`: Does not have a functionality to have multiple routes with
    the same priority. If there is a route with a priority already defined, it will
    prioritize the last route added as the route with the highest priority.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleRouteStack`: 没有多个具有相同优先级的路由的功能。如果已经定义了一个具有优先级的路由，它将优先考虑最后添加的路由作为具有最高优先级的路由。'
- en: Using TreeRouteStack
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TreeRouteStack
- en: Routers are not restricted to using the URI path to find out how to route a
    request. They can also use other information such as the query parameters, headers,
    methods, or hostnames to find a match.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器不仅限于使用 URI 路径来确定如何路由请求。它们还可以使用其他信息，如查询参数、头部、方法或主机名来找到匹配项。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Zend Framework 2, we will generally use routing that is based on a request
    URI, which contains path segments that should be queried. Routes are matched by
    a router, which utilizes `RouteStack` to find the match to the query made by the
    router. We use `RouteStack` because we want a decent way of managing our different
    routes. With Zend Framework 2 there are loads of route types provided, but only
    two flavorless routers namely `SimpleRouteStack` and `TreeRouteStack`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中，我们通常会使用基于请求 URI 的路由，其中包含应查询的路径段。路由是通过路由器匹配的，路由器利用 `RouteStack`
    来找到与路由器查询相匹配的路由。我们使用 `RouteStack` 是因为我们想要一种管理不同路由的合理方式。在 Zend Framework 2 中提供了大量的路由类型，但只有两种无味的路由器，即
    `SimpleRouteStack` 和 `TreeRouteStack`。
- en: When we are defining a router, we need to make sure we understand how it works.
    Although creating lists with different paths is simple enough, it is wise to remember
    that the Zend Framework 2 router generally works with the **Last In First Out**
    (**LIFO**) concept, which means that a route that would be used often would be
    registered last, and a route that is less common would be registered earlier in
    the router stack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个路由器时，我们需要确保我们理解它是如何工作的。虽然创建不同路径的列表足够简单，但记住，Zend Framework 2 的路由器通常使用
    **后进先出**（**LIFO**）的概念，这意味着经常使用的路由会被最后注册，而较少使用的路由会在路由器堆栈中较早注册。
- en: There's more…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Besides the two standard route types, Zend Framework 2 comes with a whole scale
    of route types that are more specialized to the Internet navigation or even through
    the console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两种标准路由类型之外，Zend Framework 2 还提供了一系列更专门针对互联网导航或甚至通过控制台的路由类型。
- en: Namespace – Zend\Mvc\Router\Http
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间 – Zend\Mvc\Router\Http
- en: A wonderful set of HTTP routers can be found in the `Zend\Mvc\Router\Http` namespace
    and we will take a quick look at the different classes that reside within this
    namespace.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一套出色的 HTTP 路由器可以在 `Zend\Mvc\Router\Http` 命名空间中找到，我们将快速浏览一下这个命名空间中存在的不同类。
- en: The Hostname class explained
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机名类解释
- en: 'The `Zend\Mvc\Router\Http\Hostname` namespace will try to match its routing
    against the hostname defined in the configuration. For example, if we define the
    route to be `something.example.ext`, our router will make its routing decision
    based on the full URL. But, if we add a single colon at the beginning of that
    same route, for example: `:something.example.ext`, the router would base its route
    on the `something` variable, which could be anything from `aardvark.example.ext`
    to `zyxt.example.ext`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zend\Mvc\Router\Http\Hostname` 命名空间将尝试将其路由与配置中定义的主机名匹配。例如，如果我们定义的路由是 `something.example.ext`，我们的路由器将基于完整的URL做出路由决策。但是，如果我们在这个相同路由的开始处添加一个单冒号，例如：`:something.example.ext`，那么路由器将基于
    `something` 变量进行路由，这个变量可以是 `aardvark.example.ext` 到 `zyxt.example.ext` 之间的任何内容。'
- en: The Literal class explained
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Literal` 类的解释'
- en: The `Zend\Mvc\Router\Http\Literal` class will literally match the path we give
    in. For example, if we put a route in there, which is `/grouphug`, the route will
    only resolve to that URL, and nothing else.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zend\Mvc\Router\Http\Literal` 类将直接匹配我们给出的路径。例如，如果我们把一个路由放在那里，比如 `/grouphug`，那么这个路由将只解析到那个URL，而不会是其他任何东西。'
- en: Methods explained
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释的方法
- en: The `Zend\Mvc\Router\Http\Method` class is used when we want to match against
    an HTTP method instead of a segment or path. This could be, for example, a `POST`,
    `DELETE` and so on. The method is also called `verb` by Zend Framework 2, which
    means that instead of a `route` parameter, it requests a `verb` parameter when
    adding the route, which is an excellent way to create RESTful APIs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要匹配HTTP方法而不是段或路径时，使用 `Zend\Mvc\Router\Http\Method` 类。例如，可以是 `POST`、`DELETE`
    等等。在Zend Framework 2中，这个方法也被称为 `verb`，这意味着在添加路由时，它请求一个 `verb` 参数而不是 `route` 参数，这是一种创建RESTful
    API的绝佳方式。
- en: The Part class explained
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Part` 类的解释'
- en: The `Zend\Mvc\Router\Http\Part` class is used to describe `child_routes` in
    our routing configuration. This means that—although never used directly—we can
    define that `/user/profile` is being redirected to use the `UserController`, with
    the `profile` action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zend\Mvc\Router\Http\Part` 类用于描述我们的路由配置中的 `child_routes`。这意味着——尽管它从未被直接使用——我们可以定义
    `/user/profile` 被重定向到使用 `UserController`，并执行 `profile` 动作。'
- en: 'Let''s consider the following configuration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下配置：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Regex explained
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式解释
- en: The `Zend\Mvc\Router\Http\Regex` class would be used when we have a complex
    routing structure that requires us to dynamically create the route. This would,
    for example, come in handy when we look at News sites, where posts are built up
    like `/archive/some-subject-2013.html`. This fairly complex route (as `some-subject-2013.html`
    is dynamic in our case) would require a `Regex` router that can resolve the Controller,
    Action, and in our case also the output format.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要匹配HTTP方法而不是段或路径时，使用 `Zend\Mvc\Router\Http\Regex` 类。例如，可以是 `POST`、`DELETE`
    等等。在Zend Framework 2中，这个方法也被称为 `verb`，这意味着在添加路由时，它请求一个 `verb` 参数而不是 `route` 参数，这是一种创建RESTful
    API的绝佳方式。
- en: 'Let''s consider the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, it is important to note that `/archive/%id%.%format%`
    tells us that we will receive two parameters in our method called `indexAction`
    that is, `id` and `format`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，重要的是要注意 `/archive/%id%.%format%` 告诉我们，在我们的 `indexAction` 方法中我们将接收两个参数，即
    `id` 和 `format`。
- en: The Scheme class explained
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Scheme` 类的解释'
- en: The `Zend\Mvc\Router\Http\Scheme` class is always using the `defaults` parameter
    and will accept only one other parameter, which is called `scheme` and can only
    contain one of the following options, that is, `http`, `https`, and `mailto`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zend\Mvc\Router\Http\Scheme` 类始终使用 `defaults` 参数，并且只接受另一个参数，该参数称为 `scheme`，并且只能包含以下选项之一，即
    `http`、`https` 和 `mailto`。'
- en: The Segment class explained
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Segment` 类的解释'
- en: The `Zend\Mvc\Router\Http\Segment` class is probably one of the most-used routers
    that we would use, as you can dynamically define the route and controller for
    any module by using, for example, `/:controller/:action`, which is easily recognizable
    by the colon separation. We can define any `constraints` to the segment by configuring
    only the use of alphanumeric characters or another definition that we would like
    to use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zend\Mvc\Router\Http\Segment` 类可能是我们最常用的路由器之一，因为我们可以通过使用例如 `/:controller/:action`
    这样的方式动态定义任何模块的路由和控制器，这种路由方式通过冒号分隔很容易识别。我们可以通过仅配置使用字母数字字符或其他我们希望使用的定义来为段定义任何 `constraints`。'
- en: An example of `Segment` is given in the first example in the *How to do it...*
    section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做...* 部分的第一个示例中给出了 `Segment` 的一个示例。
- en: Understanding dependency injection
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖注入
- en: When we talk about the dependency injection, or in short DI, we talk about the
    simple task of, for example, injecting data in object or methods at initialization
    when needed by one or other higher up classes, which either modify or dispose
    off the object after use. The DI is probably the most complex feature in Zend
    Framework 2 to understand. Unfortunately because DI's over complexity in debugging
    and performance and the Service Locator (explained in [Chapter 6](ch06.html "Chapter 6. Modules,
    Models, and Services"), *Modules, Models and Services*). However, although it
    is not the best tool in the shed, we must try to learn it, because when mastered
    it could prove to be a very powerful tool to create a very maintainable piece
    of code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论依赖注入，简称DI时，我们谈论的是在需要时，例如在初始化时向对象或方法中注入数据，这些对象或方法在用后要么修改要么销毁对象。DI可能是Zend
    Framework 2中最复杂的功能之一。不幸的是，由于DI在调试和性能上的过度复杂性以及服务定位器（在第6章中解释，*模块、模型和服务*），DI可能不是最好的工具。然而，尽管它不是最好的工具，我们仍然必须努力去学习它，因为一旦掌握，它可能证明是一个非常强大的工具，可以创建非常易于维护的代码。
- en: If we come across a situation where it is necessary for us to input a lot of
    parameters in classes because of objects deeper in the code are dependent on them
    is probably the most annoying and un-maintainable piece of code that we can find
    in even the most professional environment. We need to think mainly about objects
    that are used more than once in an application, and always required to instantiate
    again.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到需要我们在类中输入大量参数的情况，因为代码中更深层的对象依赖于它们，这可能是我们在甚至最专业环境中能找到的最令人烦恼且难以维护的代码片段。我们需要主要考虑在应用程序中多次使用且总是需要重新实例化的对象。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let us take a look at the following example and assume that `FirstClass` is
    the only class that we will actually need further in the code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，并假设`FirstClass`是我们将在代码中进一步需要的唯一类：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both the preceding examples give either variables that are only used to instantiate
    another class and/or add complexity in reading the code. Although they both are
    correct, the use of DI can, in this case, make the configuration of both the classes
    much easier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个例子都给出了仅用于实例化另一个类或/和在阅读代码时增加复杂性的变量。尽管它们都是正确的，但在这个情况下，使用DI可以使这两个类的配置变得更加容易。
- en: Initializing the DI at call-time
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在调用时间初始化DI
- en: 'Let''s take a look at this DI example, considering that we have the same classes
    as the preceding example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个DI示例，考虑到我们拥有与前面示例相同的类：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we simply say to the DI that `AnotherNamespace\ThirdClass`
    has two parameters in its `__construct` method. The DI will then utilize `Reflection`
    to find out what parameters are present there, and will then give any class that
    has a `first_name`, `vehicle`, or `last_name` parameter in its constructor that
    parameter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是告诉DI，`AnotherNamespace\ThirdClass`在其`__construct`方法中有两个参数。然后DI将利用`Reflection`来找出那里有哪些参数，然后将为任何在其构造函数中具有`first_name`、`vehicle`或`last_name`参数的类提供该参数。
- en: Of course we will see a potential flaw here, as you might need to utilize multiple
    instantiations, one can presume that at some point the same parameter name will
    be used. In our example, it would cause a problem if another class also has a
    `$first_name` parameter but requires a different input, as the DI will simply
    give the one that is in its list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在这里会看到一个潜在的缺陷，因为你可能需要利用多个实例化，可以假设在某个时刻会使用到相同的参数名称。在我们的例子中，如果另一个类也有一个`$first_name`参数但需要不同的输入，那么这将会引起问题，因为DI将简单地给出列表中的那个。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we use DI to instantiate our classes and all we need the constructor for
    is to set our variables, we can easily remove the constructor altogether as the
    DI doesn't use the constructor to initialize the variables. Instead the DI will
    just set the properties of the values.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用依赖注入（DI）来实例化我们的类，并且我们只需要构造函数来设置变量，那么我们可以很容易地完全移除构造函数，因为DI不会使用构造函数来初始化变量。相反，DI将只设置值的属性。
- en: One good thing about this is that this can flaw only happens when we use the
    DI at a call-time level, and not in a global configuration level as we will see
    now. That is why it isn't recommended to use the DI at call-time level at all.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的一个好处是，这种错误只会在我们使用DI在调用时间级别时发生，而不会在全局配置级别上，正如我们现在将要看到的。这就是为什么不建议在调用时间级别上使用DI。
- en: Initializing the DI through a Configuration object
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过配置对象初始化DI
- en: What we also can do to create a more specific (or accurate) initialization of
    our object – and to make sure classes with the same property names don't conflict
    – is initializing the DI with a configuration object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用配置对象来创建更具体（或更准确）的对象初始化，并确保具有相同属性名的类不会发生冲突。
- en: The idea behind this is that we first create a configuration object (or array)
    that defines which classes need which properties set, and then use that to initialize
    the DI, which in its turn finds out when it needs to initiate what.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，我们首先创建一个配置对象（或数组），它定义了哪些类需要设置哪些属性，然后使用它来初始化DI，DI反过来找出何时需要启动什么。
- en: 'Take a look at the following example, which shows you the exact thing we just
    explained:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子，它展示了我们刚才解释的 exactly 东西：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To make everything even nicer, we would just put the `Zend\Di\Configuration`
    of the DI in the bootstrap of our module, so that we can use it easily throughout
    the namespace. This way we can simply put the configuration of the DI in our `module.config.php`
    and let the framework take care of it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切更加完美，我们只需将DI的`Zend\Di\Configuration`放在我们模块的引导程序中，这样我们就可以在整个命名空间中轻松使用它。这样我们就可以简单地将DI的配置放在我们的`module.config.php`中，让框架来处理它。
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The DI or dependency injector is an important, and most of the time overlooked
    feature of Zend Framework 2\. The DI makes our lives a lot easier by automatically
    finding the classes we need in our application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: DI或依赖注入器是Zend Framework 2的一个重要特性，但大多数时候都被忽视了。DI通过自动查找我们应用中需要的类，使我们的生活变得更加容易。
- en: With all its complexity however, comes a couple of features we should be wary
    of.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管它很复杂，但也有一些特性我们应该小心。
- en: The DI only gives out one instance of an object
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DI只提供一个对象的实例
- en: This means that every `get()` call will result in the same instantiation over
    and over again. If we would like a new instance, we would need to call `newInstance()`
    as the DI implements the singleton pattern, which means that all the data persists
    every time we call the `get()` method unless we force a new instance of the DI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次`get()`调用都会导致相同的实例化重复进行。如果我们想要一个新的实例，我们需要调用`newInstance()`，因为DI实现了单例模式，这意味着每次我们调用`get()`方法时，所有数据都会持续存在，除非我们强制创建DI的新实例。
- en: Defining either all properties, or using a Fully Qualified (FQ) setter parameter
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义所有属性或使用完全合格（FQ）设置器参数
- en: When our class has more properties than we define, we will find out that the
    DI will use the last value for every other property in the class. Of course this
    is unwanted, and if we wrote the class ourselves we should consider refactoring
    the configuration and/or class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的类具有比我们定义的更多的属性时，我们会发现DI将使用类中每个其他属性的最后一个值。当然，这是我们不希望的，如果我们自己编写了类，我们应该考虑重构配置和/或类。
- en: However, when there is no other way we can define the right properties only
    by using a **Fully Qualified** (**FQ**) setter parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当没有其他方法可以定义正确的属性时，我们只能通过使用**完全合格**（**FQ**）设置器参数来定义。
- en: In our configuration we would then define a very specific property name, for
    example, `class::method:paramPos`. If we take our `ThirdClass` example from earlier
    on, this would then be `ThirdClass::setFirstName:0` and `ThirdClass::setLastName:0`
    respectively.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置中，我们可以定义一个非常具体的属性名，例如，`class::method:paramPos`。如果我们以之前提到的`ThirdClass`为例，那么这将分别是`ThirdClass::setFirstName:0`和`ThirdClass::setLastName:0`。
- en: There's more…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There is loads more we can learn about the DI in Zend Framework 2\. The following
    list provides a very short and compact description of other interesting DI components:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zend Framework 2中，我们还可以学习更多关于DI的知识。以下列表提供了一个非常简短且紧凑的描述，介绍了其他有趣的DI组件：
- en: '`RuntimeDefinition` (default), `CompilerDefinition` and `ClassDefinition`:
    These definitions are used to determine how to configure our objects. Although
    the default one usually does the job, it can''t hurt to see what the other two
    Definitions do, because they all have their pros and cons.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeDefinition`（默认）、`CompilerDefinition`和`ClassDefinition`：这些定义用于确定如何配置我们的对象。尽管默认的一个通常可以完成工作，但看看其他两个定义做了什么是有好处的，因为它们都有其优缺点。'
- en: '`InstanceManager`: Used to define the configuration, specifically the `Aliases`,
    `Parameters` and `Preferences`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstanceManager`：用于定义配置，特别是`Aliases`、`Parameters`和`Preferences`。'
- en: Using configurations to your benefit
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用配置的优势
- en: Configurations play a crucial role in the workings of Zend Framework 2, therefore
    it is essential to know how it works.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 配置在Zend Framework 2的工作中起着至关重要的作用，因此了解它是如何工作的至关重要。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Go through the following sections to use configurations to your benefit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历以下部分，以利用配置：
- en: Creating a global configuration
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建全局配置
- en: 'When beginning to code in Zend Framework 2 there is some misunderstanding as
    to what the different configuration files do. By default we have multiple configuration
    files, and it might not always be simple to understand where things need to go.
    That is why we like to apply a simple rule:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始使用Zend Framework 2编码时，对于不同的配置文件的作用存在一些误解。默认情况下，我们有多个配置文件，而且可能并不总是简单易懂地知道东西应该放在哪里。这就是为什么我们喜欢应用一个简单的规则：
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Is the configuration necessary throughout all our modules? If yes, place your
    configuration in the `config/application.config.php` file. If not, place your
    configuration in the `config/global.php` file at the module where it belongs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是否需要在所有模块中都是必要的？如果是，请将您的配置放在`config/application.config.php`文件中。如果不是，请将配置放在属于该模块的`config/global.php`文件中。
- en: The configuration that we usually place in the `global.php` file can be, for
    example, the caching method and configuration, the database configuration. Normally
    we would like to place items in there that are environment related, but nothing
    that is security sensitive.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常放在`global.php`文件中的配置，例如，可以是缓存方法和配置、数据库配置。通常我们希望放置与环境相关的项目，但没有任何安全敏感的信息。
- en: 'Let''s take a look at a bad example of `global.php`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`global.php`的一个糟糕的例子：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is terrible practice to put the username and password in the `global.php`
    file. The `global.php` file is to be put in our version control, and therefore
    should contain only configuration items that are required to globally run the
    application, not specific information that is relevant per environment, such as
    database usernames and passwords.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`global.php`文件中放置用户名和密码是非常糟糕的做法。`global.php`文件应该放入我们的版本控制中，因此应该只包含全局运行应用程序所需的配置项，而不是与特定环境相关的特定信息，例如数据库用户名和密码。
- en: Creating configuration that only works for a local machine
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建仅适用于本地机器的配置
- en: One of the benefits of the ultra-many configuration files in Zend Framework
    2, is that you are able to override your global configuration with your local
    configuration. This certainly comes in handy when developing and you find yourself
    in a position where your details are slightly different in configuration than
    your production environment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zend Framework 2中，超多配置文件的好处之一是您可以使用本地配置覆盖全局配置。这在开发过程中非常有用，当您发现自己处于配置与生产环境略有不同的情况时。
- en: 'Let''s assume that we have the following `/config/autoload/global.php` configuration
    file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下的`/config/autoload/global.php`配置文件：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see in the preceding example, we create a nice and simple MySQL database
    connection to our `somename` database which resides on the localhost. But as good
    developers we have not defined our username and password in here. That is where
    the /`config/autoload/local.php` file comes in.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个例子所示，我们创建了一个很好的简单的MySQL数据库连接到我们位于本地的`somename`数据库。但作为优秀的开发者，我们并没有在这里定义用户名和密码。这就是`/config/autoload/local.php`文件的作用所在。
- en: 'Let''s take a look at how our `local.php` might look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`local.php`可能的样子：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we are using a version control system (please say yes), we should not commit
    this file, not only for security reasons but also because this is a local configuration
    file and wouldn't be necessary on a live system, as we would create a new one
    with the right details for that environment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用版本控制系统（请说“是”），我们不应该提交此文件，这不仅出于安全原因，而且因为这是一个本地配置文件，在实时系统中可能并不必要，因为我们会在该环境中创建一个新的具有正确细节的文件。
- en: Editing your application.config.php file
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑您的application.config.php文件
- en: If we look at our default `config/application.config.php` file we have only
    a few properties set, but loads of inline comments, which really come in handy
    when we can't remember the exact name or description of a property any more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的默认`config/application.config.php`文件，我们只设置了少量属性，但有很多内联注释，当我们不再记得某个属性的准确名称或描述时，这些注释非常有用。
- en: 'The main configuration that we will be changing the most in our application
    as we develop is the `modules` property. This specific property is a simple array
    with the different module namespaces that we have (and want to use) in our application.
    At default this looks somewhat like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发应用程序时，我们将更改最多的主要配置是`modules`属性。这个特定的属性是一个简单的数组，包含我们在应用程序中（并希望使用）的不同模块命名空间。默认情况下，它看起来有点像这样：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we add or remove a module, this line needs to be modified as well and one
    can even suggest modifying this before starting a new module or removing one.
    The reason for this is simple, when we forget to modify this file when removing
    a module it will generate a `500 – Application Error` when visiting the application
    in our browser. And because this configuration file is read quite early in the
    instantiation, it can sometimes be hard for the developer to pinpoint why the
    application fails to load all of a sudden.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加或删除模块时，此行也需要修改，甚至可以在开始新模块或删除模块之前修改此文件。原因很简单，当我们忘记在删除模块时修改此文件，访问应用程序时会在浏览器中生成`500
    – 应用程序错误`。而且因为此配置文件在实例化早期就被读取，有时对于开发者来说很难确定为什么应用程序突然无法加载。
- en: How it works…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If we look at the `index.php` file in the `public` folder, we can see that we
    parse our initial configuration file to the Zend Framework MVC Application with
    the line `require 'config/application.config.php'`. This then loads up the main
    configuration file, which in its turn defines all our properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`public`文件夹中的`index.php`文件，我们可以看到我们将初始配置文件通过以下行解析到Zend Framework MVC应用程序中：`require
    'config/application.config.php'`。然后加载主配置文件，它反过来定义了所有我们的属性。
- en: A nifty property in the `application.config.php` file is the `config_glob_paths`
    property. Any additional configuration files are by default read by finding files
    in the `config/autoload` folder as well, using a very specific file pattern namely;
    `*global.php` and `*local.php`. The order in which this is defined is also very
    important.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.config.php`文件中的一个巧妙属性是`config_glob_paths`属性。任何额外的配置文件默认情况下都会通过在`config/autoload`文件夹中查找文件来读取，使用一个非常具体的文件模式，即`*global.php`和`*local.php`。定义的顺序也非常重要。'
- en: When we say `*global.php`, we can define anything from `somemodule.global.php`
    to `menu.global.php` to just `global.php`, as the file pattern (also named `GLOB_BRACE`)
    searches for anything that matches that. The same happens for `*local.php`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`*global.php`时，我们可以从`somemodule.global.php`到`menu.global.php`，甚至只是`global.php`来定义任何内容，因为文件模式（也称为`GLOB_BRACE`）会搜索任何匹配的内容。对于`*local.php`也是如此。
- en: The order this is defined is very important as said before because we want our
    global configuration to be loaded before our local configuration, otherwise there
    would be no point in overriding our global configuration, would there?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，定义的顺序非常重要，因为我们希望全局配置在本地配置之前加载，否则覆盖全局配置就没有意义了，对吧？
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'To summarize the configuration files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 总结配置文件：
- en: '`config/application.config.php`: Modules can be added and removed here, and
    very low level configuration happens here.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config/application.config.php`: 可以在此处添加和删除模块，并且非常底层的配置也在这里进行。'
- en: '`config/autoload/some-module.global.php`: Used to override your default values
    of your module configuration. Make sure not to put sensitive information in here,
    but hostnames and database names should go in here.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config/autoload/some-module.global.php`: 用于覆盖模块配置的默认值。请确保不要在此处放置敏感信息，但主机名和数据库名称应该放在这里。'
- en: '`config/autoload/some-module.local.php`: You can put your usernames and passwords
    and other configuration items that are very specific to your local environment
    here.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config/autoload/some-module.local.php`: 您可以在此处放置您的用户名和密码以及其他非常特定于您本地环境的配置项。'
- en: '`module/SomeModule/config/module.config.php`: Module specific configuration
    happens here, use only default values and make sure nothing too specific will
    be entered here.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module/SomeModule/config/module.config.php`: 模块特定配置在此处进行，请仅使用默认值，并确保不要在此处输入过于具体的内容。'
- en: The EventManager and Bootstrap classes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件管理器和引导类
- en: 'We will be showing off one of the most beautiful features of Zend Framework
    2: The EventManager.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示Zend Framework 2最漂亮的功能之一：事件管理器。
- en: How to do it…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The `EventManager` and `Bootstrap` classes are an essential part of our application,
    this recipe is all about how to use those two tools:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventManager`和`Bootstrap`类是我们应用程序的重要组成部分，这个配方主要介绍如何使用这两个工具：'
- en: Using the bootstrap
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用引导
- en: The bootstrap is in our case the start of a module, whenever a module is requested
    it will use the `onBootstrap()` method located in the `Module.php` file. Although
    the method is not required, we usually want this method in our module as it is
    an easy method of making sure that some instances already exist or are configured
    before venturing further in our client request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，引导是模块的开始，每当请求一个模块时，它将使用位于 `Module.php` 文件中的 `onBootstrap()` 方法。虽然这个方法不是必需的，但我们通常希望在模块中包含这个方法，因为它是一个确保在进一步处理客户端请求之前某些实例已经存在或配置好的简单方法。
- en: Starting a session
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始一个会话
- en: Sessions are a wonderful way of saving information about a user on a temporary
    basis. Think about saving the information of a logged-in user, or history on the
    pages they have been. Once we begin creating an application we find ourselves
    saving a lot of things in the session.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是保存用户临时信息的绝佳方式。想想保存已登录用户的信息，或者他们在页面上浏览的历史记录。一旦我们开始创建应用程序，我们会发现自己会在会话中保存很多东西。
- en: 'The first thing we need to do is modify the `/module/Application/config/module.config.php`
    file, and add another section called `session` to it. Let''s assume that we have
    a completely empty module configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是修改 `/module/Application/config/module.config.php` 文件，并向其中添加一个名为 `session`
    的新部分。假设我们有一个完全空的模块配置：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And that is it. Sessions are now useable in our controllers and models. We
    have now created two session containers that we can use to store our information
    in. We can access these containers in any Controller or Model that has a service
    locator available by doing the following (file: `/module/Application/src/Application/Controller/IndexController.php`):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。会话现在可以在我们的控制器和模型中使用。我们现在创建了两个会话容器，我们可以使用它们来存储我们的信息。我们可以通过以下方式在任何有服务定位器可用的控制器或模型中访问这些容器（文件：`/module/Application/src/Application/Controller/IndexController.php`）：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the EventManager class
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 EventManager 类
- en: The `EventManager` class is possibly one of the nicest features in the framework.
    When used properly, it can make our code a lot more dynamic and maintainable without
    creating spaghetti code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventManager` 类可能是框架中最好的特性之一。当正确使用时，它可以使我们的代码更加动态和易于维护，而不会产生乱麻般的代码。'
- en: What it does is relatively simple, for example; a class might have a method
    called `MethodA`. This `MethodA` has a list of listeners, which are interested
    in the outcome of that class. When `MethodA` executes, it just runs through its
    normal procedures, and when finished it just notifies the `EventManager` a specific
    event has occurred. Now the `EventManager` will trigger all of the interested
    parties that this event has taken place, and the parties in their turn will execute
    their code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的事情相对简单，例如；一个类可能有一个名为 `MethodA` 的方法。这个 `MethodA` 有一个监听器列表，它们对这个类的结果感兴趣。当
    `MethodA` 执行时，它只是运行其正常程序，完成后就通知 `EventManager` 发生了一个特定的事件。现在 `EventManager` 将触发所有感兴趣的相关方，而这些相关方将依次执行它们的代码。
- en: 'Got it? Don''t worry if you don''t, because this example code might clear things
    up (file: `/module/Application/src/Application/Model/SwagMachine.php`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？如果你不明白，不要担心，因为这个示例代码可能会澄清一些问题（文件：`/module/Application/src/Application/Model/SwagMachine.php`）：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see we created a little class with two event triggers, `findSwag.begin`
    and `findSwag.end`, respectively on the beginning of the method, and one on the
    end of the method. The `findSwag.begin` event will potentially modify the `$id`,
    and the `findSwag.end` event only parses the `returnValue` object, with no modification
    possible to the value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们创建了一个带有两个事件触发器的小类，分别是 `findSwag.begin` 和 `findSwag.end`，分别位于方法的开始和结束处。`findSwag.begin`
    事件可能会修改 `$id`，而 `findSwag.end` 事件仅解析 `returnValue` 对象，无法修改其值。
- en: 'Now let''s see the code that implements the triggers (file: `/module/Application/src/Application/Controller/IndexController.php`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看实现触发器的代码（文件：`/module/Application/src/Application/Controller/IndexController.php`）：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see attaching triggers to events is pretty straightforward. And –
    if the events are properly documented – can come in handy when we want to, say,
    modify parameters going into a method (like we did with the `findSwag.begin`),
    or just outputting the results to a log (like `findSwag.end`).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，将触发器附加到事件上非常简单。如果事件得到适当的文档说明，当我们需要修改传入方法（如我们用 `findSwag.begin` 所做的那样）的参数或只是将结果输出到日志（如
    `findSwag.end`）时，它们会很有用。
- en: 'When we look at what is on our screen, it should be something like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看屏幕上的内容时，它应该是这样的：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result consists of the top line being the output from the `findSwag.end`
    trigger, while the value `60` comes from the highest priority trigger, the one
    with priority `100` (as that is considered a higher priority than `200`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，最上面一行是来自`findSwag.end`触发器的输出，而值`60`来自最高优先级的触发器，即优先级为`100`的触发器（因为那被认为比`200`的优先级更高）。
- en: Changing the View output
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改视图输出
- en: Sometimes it is necessary that we have different View outputs, for example when
    we need to build ourselves a REST service or a SOAP service. Although this can
    be arranged much simpler by a controller plugin, it is an example on how to hook
    into the `dispatch` event, and see what is going on there.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要不同的视图输出，例如当我们需要构建自己的REST服务或SOAP服务时。虽然这可以通过控制器插件更简单地安排，但它是一个如何连接到`dispatch`事件并查看那里的示例。
- en: 'Without further ado, let us take a look at the following code snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们看一下以下代码片段：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see it is relatively simple to attach a callback function to the `EventManager`
    object. In this example we are using `McvEvent::EVENT_DISPATCH` as the event we
    want to hook in to. So what basically happens is that whenever a controller executes
    the `onDispatch()` method, this event will be triggered as well. This means that
    through events we can modify the outcome of a method without actually needing
    to modify the code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，将回调函数附加到`EventManager`对象相对简单。在这个例子中，我们使用`McvEvent::EVENT_DISPATCH`作为我们想要连接的事件。所以基本上发生的事情是，每当控制器执行`onDispatch()`方法时，这个事件也会被触发。这意味着通过事件，我们可以修改方法的输出结果，而实际上并不需要修改代码。
- en: How it works…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The EventManager class works through a couple of different methods, namely the
    Observer pattern, the Aspect-Oriented Programming technique (or AOP) and the Event-Driven
    architecture.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventManager`类通过几种不同的方法工作，即观察者模式、面向方面编程技术（或AOP）和事件驱动架构。'
- en: The Observer pattern explained
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式解释
- en: Simply said the Observer pattern means that there are several interested parties,
    called listeners that want to know when the application triggers a certain event.
    When a specific event is triggered, the listeners will be notified so that they
    can take their necessary actions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，观察者模式意味着存在几个感兴趣的参与者，称为监听器，它们希望知道当应用程序触发某个事件时。当特定事件被触发时，监听器将收到通知，以便它们可以采取必要的行动。
- en: Aspect-Oriented Programming (AOP) explained
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向方面编程（AOP）解释
- en: If we want to explain what AOP is, we could say that in short it stands for
    writing clean code that have only function and are as isolated from the rest of
    the code as possible.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要解释AOP是什么，我们可以简单地说，它代表编写只包含功能且尽可能与代码其他部分隔离的干净代码。
- en: Event-driven architecture explained
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件驱动架构解释
- en: The benefit of an Event-driven architecture is that instead of creating bulks
    of code that need to check every condition, we can easily hook ourselves to different
    events, which in essence will create a more responsive application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构的好处是，我们不必创建大量需要检查每个条件的代码，我们可以轻松地将自己连接到不同的事件，本质上这将创建一个更响应的应用程序。
- en: There's more…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `EventManager` object is queried through a `PriorityQueue`, which tells
    us that an important event will generally get a lower value, while an unimportant
    event a higher value. For example, the highest priority might get priority `-1000`
    while a quite low priority might get 40\. The `EventManager` class then gets the
    queue through a **FIFO** (**First In, First Out**) concept, meaning the higher
    the priority, the lower the number.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventManager`对象通过`PriorityQueue`进行查询，这告诉我们，重要的事件通常会得到更低的值，而不重要的事件会得到更高的值。例如，最高优先级可能得到优先级`-1000`，而相当低的优先级可能得到40。然后`EventManager`类通过**FIFO**（**先进先出**）的概念获取队列，这意味着优先级越高，数字越低。'
