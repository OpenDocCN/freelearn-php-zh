- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Writing Automated Tests in Drupal
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Drupal 中编写自动化测试
- en: In previous chapters, we reviewed how to add custom functionality to Drupal
    with controllers, routes, responses, custom modules, custom entity types, hooks,
    and more. With even just a little bit of code, you can add a lot of functionality
    to your Drupal application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们回顾了如何使用控制器、路由、响应、自定义模块、自定义实体类型、钩子等来为 Drupal 添加自定义功能。即使只有一点点的代码，你也可以为你的
    Drupal 应用程序添加很多功能。
- en: But how do you know that *it works*? Sure, you can click around and try things
    out – but it is not a 100% guarantee that things are working under the hood as
    intended. The more code and features you add, the harder it will be to verify
    that existing functionality is still intact without providing tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但你怎么知道它真的“工作”了？当然，你可以点击并尝试一些事情——但这并不能保证事情在底层按预期工作。你添加的代码和功能越多，验证现有功能是否仍然完整而不提供测试就越困难。
- en: By implementing automated tests, you can ensure that the code and features you
    have added actually work the way you expect. Most importantly, automated tests
    help significantly reduce bugs and regressions making it to your production website,
    which in turn will help build your confidence as a developer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施自动化测试，你可以确保你添加的代码和功能确实按预期工作。最重要的是，自动化测试可以显著减少错误和回归到你的生产网站，这反过来将有助于增强作为开发者的信心。
- en: 'Drupal provides several classes of tools to help provide tests for your application.
    This chapter covers the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 提供了几种类别的工具来帮助你为你的应用程序提供测试。本章涵盖了以下内容：
- en: Installing the PHPUnit test suite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 PHPUnit 测试套件
- en: Running PHPUnit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 PHPUnit
- en: Writing a unit test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Writing a kernel test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内核测试
- en: Writing a functional test
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写功能测试
- en: Writing a functional JavaScript test
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写功能 JavaScript 测试
- en: Writing a NightwatchJS test
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 NightwatchJS 测试
- en: Types of tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are five types of tests you can run and write in Drupal – **unit tests**,
    **kernel tests**, **functional tests**, **functional JavaScript tests**, and **NightwatchJS
    tests**. Which ones you write will depend on the kind of feature(s) you are creating
    and the level of test coverage you are willing to accept to prove your code is
    working. Let’s take a look at each of these types of tests. You can find the full
    code used in this chapter on GitHub: [https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Drupal 中运行和编写的测试类型有五种——**单元测试**、**内核测试**、**功能测试**、**功能 JavaScript 测试**和**NightwatchJS
    测试**。你编写哪些将取决于你正在创建的功能类型以及你愿意接受的测试覆盖率水平来证明你的代码正在工作。让我们来看看这些测试类型。你可以在 GitHub 上找到本章中使用的完整代码：[https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13)
- en: Unit tests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are tests that do not need a Drupal installation to evaluate because
    they test code that executes code only. They are the lowest-level test you can
    write. Unit tests are useful for testing plugins, services, or other code that
    do not require interaction with the database. If you need to write tests that
    require a database or Drupal environment in some way, you would write a kernel
    test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是不需要 Drupal 安装即可评估的测试，因为它们只测试执行代码。这是你可以编写的最低级别的测试。单元测试对于测试插件、服务或其他不要求与数据库交互的代码非常有用。如果你需要编写需要数据库或
    Drupal 环境的测试，你将编写内核测试。
- en: Kernel tests
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核测试
- en: Kernel tests are the next step up from unit tests. A kernel test is a test that
    can execute and test functionality that requires some level of database interaction.
    If you want to test the functionality of features that act when saving entities,
    test field formatters, check user role access to routes, or test controllers and
    their responses, a kernel test is what you would write. When executing kernel
    tests, an instance of Drupal is installed where the tests are performed. This
    level of isolation is what permits you to test interactive functionality without
    interfering with your current working database. You are able to specify modules
    to install and configurations to include in a kernel test, making it an excellent
    way of testing your modules. These are the most common tests you will see in Drupal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内核测试是单元测试的下一步。内核测试是一种可以执行和测试需要一定数据库交互级别的功能的测试。如果你想测试在保存实体时触发的功能、测试字段格式化器、检查用户对路由的访问权限，或者测试控制器及其响应的功能，内核测试就是你需要编写的测试。在执行内核测试时，会在测试执行的地方安装一个
    Drupal 实例。这种隔离级别允许你在不影响当前工作数据库的情况下测试交互式功能。你可以指定要安装的模块和在内核测试中包含的配置，这使得它成为测试模块的绝佳方式。这些是在
    Drupal 中最常见的测试。
- en: Functional tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性测试
- en: Functional tests are the highest-level test you can write. Like kernel tests,
    a functional test will install a working copy of Drupal to run the tests in. These
    tests are evaluated with a headless browser and are useful for testing functionality
    from the user perspective. These types of tests are good for testing user workflows,
    user permissions, and evaluating page content for what you expect to see. For
    example, if you have a feature where a user navigates to a site, logs in, navigates
    to the Drupal admin, and sees sections that other roles should not, you can evaluate
    this with a functional test.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性测试是你能编写的最高级别的测试。像内核测试一样，功能性测试将安装一个可工作的 Drupal 副本来运行测试。这些测试使用无头浏览器进行评估，并且从用户的角度测试功能非常有用。这类测试适用于测试用户工作流程、用户权限，以及评估页面内容是否符合预期。例如，如果你有一个功能，用户导航到网站，登录，导航到
    Drupal 管理界面，并看到其他角色不应看到的部分，你可以通过功能性测试来评估这一点。
- en: Functional JavaScript tests
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性 JavaScript 测试
- en: Functional JavaScript tests are executed using a real browser, such as Chrome
    or Firefox. Regular functional tests run in a headless PHP browser emulator called
    Mink under the hood. Since it is not a full-fledged browser, it cannot test any
    JavaScript-related features that real browsers such as Chrome have. If you want
    to test features related to AJAX, cookies, or DOM-related JavaScript events in
    the browser, you would write a functional JavaScript test. Functional JavaScript
    tests will require the presence of a browser such as Chrome and tools such as
    Selenium to orchestrate Chrome under test.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性 JavaScript 测试是在真实浏览器中执行的，例如 Chrome 或 Firefox。常规的功能性测试在底层使用名为 Mink 的无头 PHP
    浏览器模拟器中运行。由于它不是一个完整的浏览器，因此无法测试像 Chrome 这样的真实浏览器所拥有的任何 JavaScript 相关功能。如果你想在浏览器中测试与
    AJAX、cookies 或 DOM 相关的 JavaScript 事件，你需要编写一个功能性 JavaScript 测试。功能性 JavaScript 测试将需要存在一个浏览器，如
    Chrome，以及像 Selenium 这样的工具来编排测试中的 Chrome。
- en: NightwatchJS tests
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NightwatchJS 测试
- en: Similar to a functional JavaScript test, `yarn` to run and interact with. If
    you are a developer who tends to write far more JavaScript than you do PHP, you
    may be interested in using NightwatchJS instead of **PHPUnit**. Another added
    benefit is that you can write unit tests for the custom JavaScript you write,
    which is something you cannot test with PHPUnit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能性 JavaScript 测试类似，可以使用 `yarn` 运行和与之交互。如果你是一位倾向于编写比 PHP 更多 JavaScript 的开发者，你可能对使用
    NightwatchJS 而不是 **PHPUnit** 感兴趣。另一个额外的优点是，你可以为自定义编写的 JavaScript 编写单元测试，这是你不能用
    PHPUnit 来测试的。
- en: Functional JavaScript and NightwatchJS tests require the most effort to set
    up and implement, but they can be very valuable because they are running under
    the same setup, conditions, user role(s), and browser that your visitors are using.
    They also take the longest to execute but still run in a fraction of the time
    any human could perform the same tasks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性 JavaScript 和 NightwatchJS 测试需要最多的努力来设置和实施，但它们非常有价值，因为它们在相同的设置、条件、用户角色（们）和浏览器下运行。它们执行时间最长，但仍然只占任何人类完成相同任务时间的很小一部分。
- en: Installing the PHPUnit test suite
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PHPUnit 测试套件
- en: All of the preceding types of tests (with the exception of NightwatchJS tests)
    are executed from one test harness, PHPUnit. We can add any number of tests to
    our custom modules or custom themes and run them using PHPUnit – all we have to
    do is install it and configure it to point at our test files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前测试类型（除了 NightwatchJS 测试）都由一个测试框架 PHPUnit 执行。我们可以向我们的自定义模块或自定义主题添加任意数量的测试，并使用
    PHPUnit 运行它们——我们只需安装它并配置它指向我们的测试文件。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first thing to do before proceeding is to install all the test dependencies
    so that you can actually run tests in Drupal. Drupal has a specific Composer package
    that brings in PHPUnit and the required dependencies for it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，首先要安装所有测试依赖项，以便您实际上可以在 Drupal 中运行测试。Drupal 有一个特定的 Composer 包，它带来了 PHPUnit
    和其所需的依赖项。
- en: 'To install, follow these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时，请按照以下步骤操作：
- en: Open up a Terminal (command line) at the root of your project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录打开一个终端（命令行）。
- en: 'Run the following Composer command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下 Composer 命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `drupal/core-dev` package will bring in PHPUnit and various dependencies
    to your project that are needed for writing and running tests in Drupal.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`drupal/core-dev` 包将把 PHPUnit 和 Drupal 中编写和运行测试所需的各个依赖项引入到您的项目中。'
- en: The --dev flag
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: --dev 标志
- en: Note that when installing, we are using the `--dev` flag. This tells Composer
    to list these packages under the `require-dev` section in `composer.json`. The
    `drupal/core-dev` package is not something you want to have in your production
    environment; it is for testing only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在安装时，我们使用 `--dev` 标志。这告诉 Composer 在 `composer.json` 的 `require-dev` 部分列出这些包。`drupal/core-dev`
    包不是您想在生产环境中拥有的东西；它仅用于测试。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Next, we need to configure PHPUnit so that it knows where our tests reside.
    Drupal core ships with an example `phpunit.xml.dist` file in the `core` directory.
    This is the file that PHPUnit reads when it executes. You don’t have to understand
    it line for line, but there are a few areas we need to adjust so that it will
    execute within your custom module directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 PHPUnit，使其知道我们的测试所在的位置。Drupal 核心在 `core` 目录中提供了一个示例 `phpunit.xml.dist`
    文件。这是 PHPUnit 执行时读取的文件。您不需要逐行理解它，但有一些区域我们需要调整，以便它可以在您的自定义模块目录中执行。
- en: 'Copy the `phpunit.xml.dist` file out of the `core` directory and place this
    file in the root of your project. Rename the file `phpunit.xml` and make the following
    edits:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `phpunit.xml.dist` 文件从 `core` 目录复制出来，并将其放置在项目根目录中。将文件重命名为 `phpunit.xml` 并进行以下编辑：
- en: 'Edit the bootstrap attribute on the `<phpunit>` tag at the top of the document
    to point to the core tests’ `bootstrap` file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档顶部 `<phpunit>` 标签上编辑 bootstrap 属性，使其指向核心测试的 `bootstrap` 文件：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to run kernel or functional tests, edit the following environment
    settings in the `<``php>` section:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行内核或功能测试，请编辑 `<php>` 部分中的以下环境设置：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: DDEV, Lando, Docksal, or Docker?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: DDEV、Lando、Docksal 或 Docker？
- en: If you use DDEV, Lando, Docksal, or other readymade tools to run Drupal locally,
    check their documentation and what the service names are. Depending on which one
    you use, the preceding values can differ for `SIMPLETEST_BASE_URL`, `SIMPLETEST_DB`,
    and `MINK_DRIVER_ARGS_WEBDRIVER`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 DDEV、Lando、Docksal 或其他本地运行 Drupal 的现成工具，请检查它们的文档以及服务名称。根据您使用的工具，`SIMPLETEST_BASE_URL`、`SIMPLETEST_DB`
    和 `MINK_DRIVER_ARGS_WEBDRIVER` 的先前值可能会有所不同。
- en: 'Next, edit the `testsuites` section to point to your custom modules directory.
    You need to specify a `testsuite` entry per test type:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑 `testsuites` 部分，使其指向您的自定义模块目录。您需要为每种测试类型指定一个 `testsuite` 条目：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These changes will tell PHPUnit where to locate the tests that we write for
    our custom modules, located in `web/modules/custom`. Tests live in the `tests/src`
    directory of a module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将告诉 PHPUnit 我们为自定义模块（位于 `web/modules/custom`）编写的测试的位置。测试位于模块的 `tests/src`
    目录中。
- en: 'Each type of test lives in its own directory within that:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每种测试类型都位于该目录下的独立目录中：
- en: Unit tests go into `tests/src/Unit`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试放入 `tests/src/Unit`
- en: Kernel tests go into `tests/src/Kernel`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内核测试放入 `tests/src/Kernel`
- en: Functional tests go into `tests/src/Functional`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试放入 `tests/src/Functional`
- en: Function JavaScript tests go into `tests/src/FunctionalJavascript`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 JavaScript 测试放入 `tests/src/FunctionalJavascript`
- en: 'By defining each type of test as its own test suite in `phpunit.xml`, we can
    choose which kind of test type to execute using PHPUnit, which we will look at
    in the next section. You can also set several `testsuite` entries, or several
    directories within a `testsuite` entry. For example, if you wanted to include
    all unit tests from contributed modules when you run PHPUnit, you can add another
    `directory` entry:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`phpunit.xml`中将每种测试类型定义为单独的测试套件，我们可以选择使用PHPUnit执行哪种类型的测试，我们将在下一节中探讨这一点。你还可以设置多个`testsuite`条目，或者一个`testsuite`条目内的多个目录。例如，如果你想运行PHPUnit时包含所有贡献模块的所有单元测试，你可以添加另一个`directory`条目：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The reason we have created a `phpunit.xml` file and placed it at the root of
    the project is that the file prevents the project from being overwritten or removed
    the next time you update Drupal. This way, you can commit the configuration to
    your repository and share it with a team, as well as be able to run tests in continuous
    integration services provided by GitHub, GitLab, or CircleCI.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`phpunit.xml`文件并将其放置在项目的根目录下，原因在于该文件可以防止在下次更新Drupal时覆盖或删除项目。这样，你可以将配置提交到你的仓库中，并与团队共享，同时还能在GitHub、GitLab或CircleCI提供的持续集成服务中运行测试。
- en: It is important to know that this is just one possible way to set your PHPUnit
    configuration. There are more settings that you can configure here once you are
    more comfortable with PHPUnit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，这仅仅是一种设置PHPUnit配置的可能方式。一旦你对PHPUnit更加熟悉，你还可以在这里配置更多设置。
- en: There are other settings that can output test coverage results, where to save
    screenshots of test failures, additional test listeners, logging output, and so
    on. Be sure to check the online documentation ([https://phpunit.readthedocs.io/en/9.5/configuration.html](https://phpunit.readthedocs.io/en/9.5/configuration.html))
    for configuring PHPUnit for more information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他设置可以输出测试覆盖率结果，保存测试失败截图的位置，额外的测试监听器，日志输出等等。请务必查看在线文档（[https://phpunit.readthedocs.io/en/9.5/configuration.html](https://phpunit.readthedocs.io/en/9.5/configuration.html)），以获取更多关于如何配置PHPUnit的信息。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you execute PHPUnit, it uses the `phpunit.xml` file to inform how it executes.
    It will scan all listed directories for test files and execute them accordingly,
    providing test feedback in the command-line window (or IDE). Every project you
    write tests for will require a `phpunit.xml` file like this in order to run any
    tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行PHPUnit时，它会使用`phpunit.xml`文件来告知如何执行。它将扫描所有列出的目录以查找测试文件，并相应地执行它们，在命令行窗口（或IDE）中提供测试反馈。为每个你编写测试的项目，都需要一个像这样的`phpunit.xml`文件才能运行任何测试。
- en: There’s more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you plan on writing functional JavaScript tests, you will also need Chrome,
    Chrome WebDriver, and Selenium. Installing and configuring this can vary, depending
    on whether you are using Lando, DDEV, Docksal, Docker Compose, or other tools
    to run Drupal. Please consult the documentation for the best information on how
    to install these tools to properly execute functional JavaScript tests. Assuming
    you are using `services` section of your `.``lando.yml` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划编写功能JavaScript测试，你还需要Chrome、Chrome WebDriver和Selenium。安装和配置这些工具可能因你使用Lando、DDEV、Docksal、Docker
    Compose或其他工具来运行Drupal而异。请查阅有关如何安装这些工具以正确执行功能JavaScript测试的最佳信息的文档。假设你正在使用`.lando.yml`文件中的`services`部分：
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`chrome` becomes a new wired service in the `MINK_DRIVER_ARGS_WEBDRIVER` setting
    in `phpunit.xml`, which makes this all work for functional JavaScript tests).
    If you want to install and use Firefox as an alternative browser to test with,
    you can do that as well, but Chrome is the most common browser used for testing.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`phpunit.xml`中的`MINK_DRIVER_ARGS_WEBDRIVER`设置中，`chrome`成为了一种新的有线服务，这使得所有这些功能都能为功能JavaScript测试工作）。如果你想安装并使用Firefox作为测试的替代浏览器，你也可以这样做，但Chrome是测试中最常用的浏览器。
- en: The way these tools are added can vary, depending on what you use. Please consult
    the documentation on the best approach to add Chrome and Chrome WebDriver. There
    are simply too many stack-specific configurations to cover in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的添加方式可能因你所使用的工具而异。请查阅有关如何添加Chrome和Chrome WebDriver的最佳方法的文档。由于涉及太多特定于堆栈的配置，本书无法涵盖。
- en: Running PHPUnit
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行PHPUnit
- en: First, we can verify that we have set up correctly by executing the `phpunit`
    command. There are no tests yet, but that’s okay. This step just verifies that
    the tool is installed and our configuration file is properly read.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过执行`phpunit`命令来验证我们是否正确设置了。目前还没有测试，但这没关系。这一步只是为了验证工具已安装，并且我们的配置文件被正确读取。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Consult the documentation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 咨询文档
- en: From here, we are going to provide bare-bones, verbose commands to use PHPUnit
    to execute tests. If you use Lando, DDEV, Docksal, or otherwise, please consult
    their documentation on how to best run PHPUnit. They usually have command wrappers
    that are small and convenient.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将提供使用PHPUnit执行测试的裸骨、详尽的命令。如果你使用Lando、DDEV、Docksal或其他工具，请查阅它们的文档，了解如何最佳运行PHPUnit。它们通常有小型且方便的命令包装器。
- en: 'In your command line, execute the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的命令行中，执行以下操作：
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the main command you will run. PHPUnit will automatically detect our
    `phpunit.xml` configuration in the project directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将运行的主要命令。PHPUnit将自动检测项目目录中的`phpunit.xml`配置。
- en: Can’t find phpunit?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 找不到phpunit？
- en: If you get an error about the `phpunit` command not being found, you may need
    to instead use the full path to it from the project root with `vendor/bin/phpunit`.
    Composer should automatically alias commands for you, but depending on how a project
    is set up, this may be required.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到关于找不到`phpunit`命令的错误，你可能需要使用项目根目录中的完整路径来代替，使用`vendor/bin/phpunit`。Composer应该会自动为你别名命令，但根据项目的设置，这可能是必需的。
- en: 'You should see output similar to the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下输出的内容：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also run specific `testsuites` or individual tests by adding the `--testsuite`
    and `--filter` arguments to `phpunit`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过向`phpunit`添加`--testsuite`和`--filter`参数来运行特定的`testsuites`或单个测试：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding command will run all unit tests found in the directories listed
    in your `unit` testsuite in `phpunit.xml`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`phpunit.xml`文件中列出的目录中运行所有找到的单元测试：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding command will run only the `FooBarTest` unit test. These two approaches
    are useful for testing certain `testsuites` only or specific tests themselves
    for faster feedback, when testing, debugging, and iterating your code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将仅运行`FooBarTest`单元测试。这两种方法在测试特定`testsuites`或测试本身以获得更快反馈时非常有用，尤其是在测试、调试和迭代代码时。
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you execute PHPUnit, it scans all listed directories in the `phpunit.xml`
    file and provides test feedback in the command-line window.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行PHPUnit时，它会扫描`phpunit.xml`文件中列出的所有目录，并在命令行窗口中提供测试反馈。
- en: In this instance, PHPUnit said that no tests were found or executed, which is
    correct because we do not have any yet. We are now ready to write our first unit
    test.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，PHPUnit表示没有找到或执行任何测试，这是正确的，因为我们还没有任何测试。我们现在可以编写第一个单元测试了。
- en: Writing a unit test
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Let’s write our first test. As previously mentioned, a unit test is the lowest-level
    type of test you can write. It only executes and tests raw PHP code that has no
    dependencies on services such as a connected database or other integrated APIs.
    This means the test can execute using PHP only.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个测试。如前所述，单元测试是你能编写的最低级别的测试类型。它只执行和测试没有依赖服务（如连接的数据库或其他集成API）的原始PHP代码。这意味着测试可以使用PHP单独执行。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let’s create a scenario that will help you think about when and how to apply
    unit testing. Imagine you have to provide data to a frontend component. The frontend
    developer has requested that you provide all JSON keys in `camelCase` format in
    the API response. `camelCase` would turn strings such as `field_event_date` into
    `fieldEventDate`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个场景，帮助你思考何时以及如何应用单元测试。想象一下，你需要向一个前端组件提供数据。前端开发者要求你在API响应中提供所有JSON键，格式为`camelCase`。`camelCase`会将字符串如`field_event_date`转换为`fieldEventDate`。
- en: '`snake_case` is used in many places in Drupal; the most common place you will
    see this is with machine names (such as on the preceding event date field). All
    machine names in Drupal are in `snake_case`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal的许多地方使用`snake_case`；你最常见的用途是在机器名（如前一个事件日期字段）上。Drupal中的所有机器名都在`snake_case`格式。
- en: This is a very simple example but perfect to illustrate how we can wield a unit
    test to test our class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但完美地说明了我们如何使用单元测试来测试我们的类。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做呢...
- en: Go ahead and create a custom module called `chapter13`. This is where we will
    be writing example code and its tests for the rest of this chapter. Refer to [*Chapter
    4*](B18548_04.xhtml#_idTextAnchor131), *Extending Drupal with Custom Code*, if
    you need a refresher on how to create a custom module in Drupal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`chapter13`的自定义模块。这是我们将在本章的其余部分编写示例代码及其测试的地方。如果你需要复习如何在Drupal中创建自定义模块，请参考[*第4章*](B18548_04.xhtml#_idTextAnchor131)，*使用自定义代码扩展Drupal*。
- en: 'With the custom module created, let’s add the `CamelCase` class in the `chapter13`
    module under the `src` directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义模块创建完成后，让我们在 `chapter13` 模块的 `src` 目录下添加 `CamelCase` 类：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Looks like it works, right? Let’s prove it with a test.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它工作得很好，对吧？让我们通过一个测试来证明它。
- en: In your custom module, create a `tests` directory. Under this directory, create
    an `src` directory, and within the `src` directory, create a `Unit` directory.
    You should have a path now that looks like `chapter13/tests/src/Unit`. Note that
    the `src` directory in your `tests` directory is different than the `src` directory
    at the root of the `chapter13` module, where the `CamelCase` class resides.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的自定义模块中，创建一个 `tests` 目录。在这个目录下，创建一个 `src` 目录，然后在 `src` 目录中，创建一个 `Unit` 目录。现在你应该有一个路径看起来像
    `chapter13/tests/src/Unit`。请注意，你的 `tests` 目录中的 `src` 目录与 `chapter13` 模块根目录下的 `src`
    目录不同，`CamelCase` 类就位于该目录。
- en: In the `chapter13/tests/src/Unit` directory, create a new file and name it `CamelCaseTest.php`.
    All test files must have `Test` at the end of their filenames to be discovered
    by PHPUnit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter13/tests/src/Unit` 目录下，创建一个新文件并将其命名为 `CamelCaseTest.php`。所有测试文件都必须以
    `Test` 结尾，以便被 PHPUnit 发现。
- en: 'Our test file needs to do two things:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试文件需要做两件事：
- en: Provide test data to convert with the `CamelCase` class
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CamelCase` 类提供测试数据
- en: Assert that the convert method returns what we expect
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言转换方法返回我们期望的结果
- en: 'Any method that begins with `test` in your test class will be evaluated by
    PHPUnit. With that in mind, let’s go ahead and fill in our unit test in `CamelCaseTest.php`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试类中，任何以 `test` 开头的方法都将由 PHPUnit 进行评估。考虑到这一点，让我们继续在我们的 `CamelCaseTest.php`
    文件中填写我们的单元测试：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Go ahead and run `phpunit`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，运行 `phpunit`：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It will result in the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This output indicates that the test was called three times (one for each set
    of data in `@dataProvider`) and each one passed. In other words, `$input` equaled
    `$expected`, which is what `assertEquals` evaluates. If a test were to fail, this
    output would indicate what test failed and on what line.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明测试被调用了三次（一次对应于 `@dataProvider` 中的每一组数据）并且每次都通过了。换句话说，`$input` 等于 `$expected`，这是
    `assertEquals` 评估的内容。如果测试失败，这个输出将表明哪个测试失败以及在哪一行。
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: PHPUnit reports that all three tests pass. But, wait – didn’t we only write
    the `testCamelCaseConversion` test method?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 报告说所有三个测试都通过了。但是，等等——我们不是只写了 `testCamelCaseConversion` 测试方法吗？
- en: 'When the test is executed, PHPUnit detects a special annotation in our test
    method called `@dataProvider`, which tags the `exampleStrings` method. The `exampleStrings`
    method provides an array of data. Each array contains a value to send in and the
    value we expect to get back. PHPUnit will loop the data provider values, so our
    test method is called three times (one for each set of values) and evaluates the
    test. This means PHPUnit sees the test method called like this when executed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试执行时，PHPUnit 检测到我们测试方法中的一个特殊注释，称为 `@dataProvider`，它标记了 `exampleStrings` 方法。`exampleStrings`
    方法提供了一个数据数组。每个数组包含要发送的值和我们期望得到的值。PHPUnit 将循环数据提供者的值，因此我们的测试方法被调用三次（一次对应于每一组值）并评估测试。这意味着当执行时，PHPUnit
    看到的测试方法调用如下：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The three values test that the method works for two or more words and returns
    the proper case.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 三个值测试确保该方法对两个或更多单词有效，并返回正确的格式。
- en: Within the test, we pass the input along to `CamelCase::convert`. From that
    method, we pass the value it returned to `assertEquals`, one of the many value
    assertion methods of PHPUnit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们将输入传递给 `CamelCase::convert` 方法。从该方法中，我们将返回的值传递给 `assertEquals`，这是 PHPUnit
    的许多值断言方法之一。
- en: Every item you add to a data provider will be asserted by the test method(s)
    that use them. `dataProviders` is an excellent way to test our code under a variety
    of scenarios. Therefore, we know that any string passed to convert will be transformed
    from `foo_bar` to `fooBar` and returned. The test proves that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到数据提供者中的每一个项目都将由使用它们的测试方法进行断言。`dataProviders` 是测试我们代码在多种场景下的一个极好的方式。因此，我们知道传递给转换的任何字符串都将从
    `foo_bar` 转换为 `fooBar` 并返回。这个测试证明了这一点。
- en: So, how does automated testing help here? With our setup, any developer on a
    team is able to run the `testsuites` and see their output. If they fail, they
    can see what code is failing and where. This provides an opportunity to fix the
    code before it is deployed to production.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，自动化测试是如何帮助这里的呢？在我们的设置中，团队中的任何开发者都可以运行 `testsuites` 并查看它们的输出。如果它们失败了，他们可以看到哪些代码失败以及在哪里。这为在代码部署到生产之前修复代码提供了机会。
- en: Under continuous integration setups, you can prevent code from being merged
    into your main branch until all tests pass. As we mentioned, this is an excellent
    way to reduce bugs and errors from surfacing on production to your users.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成设置下，你可以防止代码在所有测试通过之前合并到你的主分支。正如我们提到的，这是减少在生产环境中向用户暴露错误和缺陷的绝佳方式。
- en: There’s more…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Over time, requirements can and often do change. Assume that after you have
    deployed this code, your frontend developer returns and asks that any string such
    as `foo-bar` is also converted to camel case.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，需求可能会改变，而且经常是这样。假设你部署了这段代码后，你的前端开发者回来要求将任何类似`foo-bar`的字符串也转换为驼峰格式。
- en: 'With our test in place, we can add this new case to our data provider:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试已经到位，我们可以将这个新案例添加到我们的数据提供者中：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we run the test now, we get the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行测试，得到以下结果：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is fine – we have not updated our implementation yet. Adding new cases
    to the test first lets us iterate and improve the implementation code until the
    test passes. This provides a fast feedback loop because we can modify the implementation
    in the `CamelCase` class all we want. If the tests all pass, we know we have met
    the requirements and that our functionality works, and we can move on to other
    features in our module.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题——我们还没有更新我们的实现。首先添加新案例到测试中，让我们可以迭代和改进实现代码，直到测试通过。这提供了一个快速的反馈循环，因为我们可以在`CamelCase`类中随意修改实现。如果所有测试都通过，我们知道我们已经满足了要求，我们的功能是有效的，我们可以继续处理模块中的其他功能。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Writing tests first before having any implementation code is referred to as
    **test-driven development**. This means the tests drive the specification or requirements,
    and the implementation code makes them pass. There are many schools of thought
    on whether you should write all tests first or not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何实现代码之前先编写测试被称为**测试驱动开发**。这意味着测试驱动规范或需求，实现代码使它们通过。关于你是否应该先编写所有测试，有许多不同的观点。
- en: If you are new to testing, it is fine to write some initial code for a proof
    of concept if you need to hash out an idea in your Drupal module. You can always
    add tests to it at any point during development. The important point is to add
    tests for your code; don’t worry so much about when.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触测试，如果你需要在Drupal模块中澄清一个想法，写一些初始代码作为概念验证是完全可以的。你可以在开发过程中的任何时候添加测试。重要的是要为你的代码添加测试；不必太担心何时添加。
- en: The more you practice and write tests, the better you will get, and you will
    eventually shift to writing the tests first.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你练习得越多，写测试也越多，你的技能就会越好，最终你会转向先写测试。
- en: Continue experimenting with the `CamelCase` class and its `CamelCaseTest` class.
    See whether you can invent some new requirements, change the code, run the tests,
    and get them to pass.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实验`CamelCase`类及其`CamelCaseTest`类。看看你是否可以发明一些新的需求，更改代码，运行测试，并使它们通过。
- en: Drupal core has hundreds of great examples of unit tests. The most-popular contributed
    modules are useful as well. Be sure to check them out if you are stuck or need
    guidance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal核心有数百个优秀的单元测试示例。最受欢迎的贡献模块也很有用。如果你卡住了或需要指导，一定要查看它们。
- en: Now that you know the basics of unit testing in Drupal, let’s look at kernel
    tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Drupal中单元测试的基础，让我们看看内核测试。
- en: Writing a kernel test
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写内核测试
- en: Let’s build upon the previous example. Assume now that stakeholders have asked
    you to output a field value on the screen in the camel case format. The good news
    is we have a working implementation and unit test, so we can make short work of
    this task in Drupal.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于之前的例子继续前进。现在假设利益相关者要求你在屏幕上以驼峰格式输出字段值。好消息是我们有一个工作的实现和单元测试，所以我们可以轻松地在Drupal中完成这个任务。
- en: In this case, we need to make a field formatter class for string fields. When
    the formatter is used on a field to display output, we want to run the user input
    through our existing `CamelCase` class. If you need a refresher on field formatters
    and managing entity displays, refer to [*Chapter 2*](B18548_02.xhtml#_idTextAnchor059),
    *Content* *Building Experience*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要为字符串字段创建一个字段格式化类。当格式化器用于字段以显示输出时，我们希望将用户输入通过我们现有的`CamelCase`类。如果你需要关于字段格式化和管理实体显示的复习，请参阅[*第2章*](B18548_02.xhtml#_idTextAnchor059)，*内容*
    *构建经验*。
- en: This provides an excellent example to step into a kernel test. Earlier, we mentioned
    that kernel tests create a minimal installation of Drupal with the setup that
    you specify in your test, in order to run and evaluate their test methods. There
    is no danger in running kernel tests, as they do not touch or interfere with your
    current site database in any way. When the test is done, it is *torn down*, or
    removed, from the database with no trace.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个很好的例子，可以进入内核测试。之前，我们提到内核测试创建了一个具有你测试中指定的设置的Drupal最小安装，以便运行和评估它们的测试方法。运行内核测试没有危险，因为它们以任何方式都不会接触或干扰你的当前站点数据库。测试完成后，它将被*拆除*，或从数据库中删除，不留痕迹。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new directory in your `tests/src` directory called `Kernel`. This is
    where your kernel tests for the `chapter13` module will live. This time around,
    we are going to write the test first.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`tests/src`目录下创建一个新的目录，命名为`Kernel`。这是你的`chapter13`模块的内核测试将驻留的地方。这次，我们将先编写测试。
- en: 'Under `chapter13/tests/src/Kernel`, create the `CamelCaseFormatterTest.php`
    file. Next, we are going to fill it in with the following code. There is a fair
    amount of boilerplate in the setup, but we will review what’s going on:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter13/tests/src/Kernel`下创建`CamelCaseFormatterTest.php`文件。接下来，我们将用以下代码填充它。设置部分有相当多的模板代码，但我们将回顾正在发生的事情：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Don’t be discouraged by the amount of code in this test. A majority of the
    code is setting up the conditions we need to run the test itself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为测试中的代码量而气馁。大多数代码是设置我们运行测试本身所需的条件：
- en: Installing the required modules needed to provide the field and `Node` entity
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装提供字段和`Node`实体的所需模块
- en: Installing the module configuration and entity schema
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装模块配置和实体模式
- en: Creating a `page` content type
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`page`内容类型
- en: Creating `field_chapter13_test` and assigning it to the page Node type
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`field_chapter13_test`并将其分配给页面节点类型
- en: Modifying the Node default view mode and setting `field_chapter13_test` to use
    the `camel_case` field formatter
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改节点默认视图模式并将`field_chapter13_test`设置为使用`camel_case`字段格式化器
- en: An alternative way to do this would be to create all of these items in Drupal
    (the content type, the field, set the formatter) and export that configuration
    into a module that is used only for this test. The result is more or less equivalent
    in the end, but you may find that creating the conditions entirely out of code
    is more maintainable in the long run than a few dozen YAML files.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，在Drupal中创建所有这些项目（内容类型、字段、设置格式化器）并将该配置导出到仅用于此测试的模块中。最终结果大致相同，但你可能会发现，完全用代码创建条件在长期来看比几十个YAML文件更易于维护。
- en: Names in tests
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的命名
- en: When naming content types, entities, or fields in a kernel test, you can make
    them whatever you want. They don’t have to match your system exactly, especially
    if all you need is a random content type that can hold a field. What we are testing
    is the output returned, not the names.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核测试中命名内容类型、实体或字段时，你可以随意命名。它们不必与你的系统完全匹配，特别是如果你只需要一个可以包含字段的随机内容类型。我们测试的是返回的输出，而不是名称。
- en: If we run the test now, it will fail; now, we can make the implementation so
    that the tests will pass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，它将失败；现在，我们可以实现使测试通过。
- en: To solve the ask, we need to create a `FieldFormatter` plugin that uses our
    existing `CamelCase` class. This exercise is easy, since the bulk of the work
    already exists for changing inputs to camel case format.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个使用我们现有的`CamelCase`类的`FieldFormatter`插件。这个练习很简单，因为将输入转换为驼峰格式的大部分工作已经存在。
- en: 'Add a `Plugin/Field/FieldFormatter` directory under the `src` directory of
    the `chapter13` module. Within that directory, add a file called `CamelCaseFormatter.php`.
    Our implementation will be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter13`模块的`src`目录下添加一个名为`Plugin/Field/FieldFormatter`的目录。在该目录中，添加一个名为`CamelCaseFormatter.php`的文件。我们的实现将如下所示：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By extending the `StringFormatter` class from core Drupal, we can make modifications
    that leverage our `CamelCase` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从核心Drupal扩展`StringFormatter`类，我们可以利用我们的`CamelCase`类进行修改。
- en: 'Now, let’s run our kernel test:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的内核测试：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This results in the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It failed! What happened? Remember when we mentioned before that requirements
    can change? Our test case passes `A user entered string` as test data. Our `CamelCase`
    class does not currently handle strings with spaces, dashes, or commas. Since
    this is a field in Drupal, users can enter just about anything. We need to account
    for that.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 失败了！发生了什么？记得我们之前提到过需求可能会改变吗？我们的测试用例将`用户输入的字符串`作为测试数据。我们的`CamelCase`类目前无法处理包含空格、破折号或逗号的字符串。由于这是Drupal中的一个字段，用户可以输入几乎所有内容。我们需要考虑到这一点。
- en: 'Modify the `CamelCase` class to account for this new requirement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`CamelCase`类以适应这个新的要求：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The addition of replacing the comma, space, and dash character should now satisfy
    new use cases. Let’s run the kernel test again:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 替换逗号、空格和破折号字符的添加现在应该能满足新的用例。让我们再次运行内核测试：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, let’s not forget about our unit test that broke earlier – let’s add
    our two new example strings to the `exampleStrings` data provider method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不要忘记之前损坏的单元测试——让我们将两个新的示例字符串添加到`exampleStrings`数据提供者方法中：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, when you run PHPUnit, both the unit and the kernel test should pass:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行PHPUnit时，单元测试和内核测试都应该通过：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now have another new and tested feature added to the site that we can deploy
    with confidence. Of course, we are free to reuse this functionality for our Drupal
    application when we need to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在网站新增了一个新的、经过测试的功能，我们可以有信心地部署它。当然，当我们需要时，我们可以自由地在我们Drupal应用程序中重用这个功能。
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When running a kernel test, Drupal will install an additional copy of itself
    to run tests in. The kernel test will use the install profile and modules you
    require in the test. This way, you can ensure that you are testing your code in
    the cleanest possible setup, with no interference from unnecessary contributed
    modules or other code. When the tests finish running, Drupal will automatically
    clean up and remove this second installation, including any data that was created
    within the test itself.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行内核测试时，Drupal将安装一个额外的副本来运行测试。内核测试将使用测试中所需的安装配置文件和模块。这样，你可以确保你在最干净的可能设置中测试你的代码，没有任何不必要的贡献模块或其他代码的干扰。当测试运行完成后，Drupal将自动清理并删除这个第二个安装，包括测试本身创建的任何数据。
- en: So far, we have written code and tests that prove they do what we need – but
    they can’t test that a user on the site sees the right thing. Let’s dive in and
    add a functional test to do just that!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了代码和测试来证明它们确实做了我们需要的——但它们无法测试网站上的用户是否看到了正确的内容。让我们深入进去，添加一个功能测试来做到这一点！
- en: Writing a functional test
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写功能测试
- en: Now that we know our code is working, let’s prove that a user can see the formatted
    string when they visit a node. Functional tests use an emulated browser that allows
    us to simulate users navigating the site. Functional tests install Drupal and
    test in an isolated fashion, so there is no risk of corrupting your current Drupal
    installation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的代码是有效的，让我们证明用户在访问节点时可以看到格式化的字符串。功能测试使用一个模拟浏览器，允许我们模拟用户在网站上导航。功能测试安装Drupal并在隔离模式下进行测试，因此没有风险会破坏你当前的Drupal安装。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: With a functional test, we can navigate the browser as if we were a real user,
    navigating and performing all kinds of assertions that unit and kernel tests cannot
    do. Like before, we do need to set some configurations in place in order to test.
    Within your `tests/src` directory, create a new directory called `Functional`,
    and then create a file inside of it called `CamelCaseFormatterDisplayTest.php`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能测试，我们可以像真实用户一样导航浏览器，执行所有各种断言，这是单元测试和内核测试无法做到的。像之前一样，我们需要设置一些配置才能进行测试。在你的`tests/src`目录中，创建一个名为`Functional`的新目录，然后在其中创建一个名为`CamelCaseFormatterDisplayTest.php`的文件。
- en: 'In this new test file, we are going to borrow some of the setups from the previous
    kernel test:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的测试文件中，我们将借鉴之前内核测试的一些设置：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There are some differences here for the functional test.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能测试中这里有一些差异。
- en: In a functional test, you can specify two properties, `$profile` and `$defaultTheme`.
    `$profile` specifies which installation profile to use for this test, and `$defaultTheme`
    specifies which theme to activate for this test. By default, the *testing* profile
    is used, the absolute minimum needed to install Drupal. You can also specify *minimal*
    or *standard*, which installs either one of those profiles to use in testing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能测试中，您可以指定两个属性，`$profile` 和 `$defaultTheme`。`$profile` 指定用于此测试的安装配置文件，而 `$defaultTheme`
    指定用于此测试要激活的主题。默认情况下，使用 *testing* 配置文件，这是安装 Drupal 所需的最小绝对值。您还可以指定 *minimal* 或
    *standard*，这将安装这些配置文件之一以用于测试。
- en: Install profiles and testing
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 安装配置文件和测试
- en: If you use install profiles that come with configurations or extras that create
    content types and roles, for example, be sure to not try to create them again
    in your test, with methods such as `createContentType`. In those cases, we will
    receive an error, since the install profile will have already created them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用带有配置或额外内容的安装配置文件，例如创建内容类型和角色，请确保不要尝试在测试中再次使用 `createContentType` 等方法创建它们。在这些情况下，我们将收到错误，因为安装配置文件已经创建了它们。
- en: Finally, you can also create your own install profile for testing that contains
    Drupal configuration files that you need – this is useful if you don’t want to
    write code in the state in the `setUp` method of the test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以创建自己的安装配置文件进行测试，其中包含您需要的 Drupal 配置文件 – 如果您不想在测试的 `setUp` 方法中编写代码，这将很有用。
- en: 'All we need for this test to run are the defaults, so run PHPUnit:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此测试运行，我们只需要默认设置，所以运行 PHPUnit：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This results in the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It passes, but do note that the total time to perform functional tests is far
    higher than unit or kernel tests. This is due to having to install a full version
    of Drupal to run the functional tests in. On this machine, it took 7 seconds with
    the core *testing* profile. If we switch to the core *standard* profile, which
    installs a lot more, we can see the time increase:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了，但请注意，执行功能测试的总时间远高于单元测试或内核测试。这是由于必须安装 Drupal 的完整版本来运行功能测试。在此机器上，使用核心 *testing*
    配置文件需要 7 秒。如果我们切换到安装更多内容的核心 *standard* 配置文件，我们可以看到时间的增加：
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The time elapsed is double over the smaller install profile. This is not necessarily
    a problem, but do keep that in mind when writing tests. In the end, valuable tests
    and concrete feedback are worth a little extra time to make sure we get things
    right with custom code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所用时间比较小的安装配置文件翻倍。这不一定是一个问题，但在编写测试时请记住这一点。最终，有价值的测试和具体的反馈值得花一点额外的时间来确保我们用自定义代码正确地完成事情。
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functional tests are more robust than kernel tests. Like a kernel test, Drupal
    will install another copy of itself to run tests in, but the installation is more
    *full* or complete than a kernel test. These tests are run with a browser emulator
    called Mink, and that is how it is able to navigate URLs, check for HTML elements,
    and perform actions as if a real user were navigating the site.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试比内核测试更健壮。与内核测试一样，Drupal 将安装另一个副本来运行测试，但安装比内核测试更 *完整* 或更完整。这些测试使用名为 Mink
    的浏览器模拟器运行，这就是它能够导航 URL、检查 HTML 元素以及执行类似真实用户导航网站的操作的原因。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There are many things you can do with functional tests (see the end of this
    chapter for ideas on how to expand what we covered previously). However, Mink
    is not an actual browser and has no capability to run or react to JavaScript interactions.
    For example, if we had to hide the field text on the page after 5 seconds, or
    display the field value with AJAX, we would need to use a functional JavaScript
    test to do that.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用功能测试做很多事情（请参阅本章末尾关于如何扩展我们之前所涵盖的内容的想法）。然而，Mink 并不是一个真正的浏览器，并且没有运行或对 JavaScript
    交互做出反应的能力。例如，如果我们需要在 5 秒后隐藏页面上的字段文本，或者使用 AJAX 显示字段值，我们需要使用功能 JavaScript 测试来完成。
- en: Writing a functional JavaScript test
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写功能 JavaScript 测试
- en: Assume that you now have one last request. You have been asked to use AJAX to
    display the value from the Camel Case formatter 3 seconds after a user has visited
    a page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您现在有一个最后的请求。您被要求使用 AJAX 在用户访问页面 3 秒后显示 Camel Case 格式化器的值。
- en: Testing this requires using an actual browser such as Google Chrome. Checking
    anything that involves AJAX, cookies, user interactions, or the DOM cannot be
    done with a regular functional test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这需要使用实际的浏览器，例如 Google Chrome。检查涉及 AJAX、cookies、用户交互或 DOM 的任何内容都不能用常规功能测试完成。
- en: Fortunately, writing a functional JavaScript test is not all that different;
    we just extend from a different base class for the test – `WebDriverTestBase`
    instead of `BrowserTestBase`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编写功能 JavaScript 测试并没有太大的不同；我们只是扩展了不同的基类进行测试——`WebDriverTestBase` 而不是 `BrowserTestBase`。
- en: Chrome and Selenium required
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 Chrome 和 Selenium
- en: If you use DDEV, Lando, Docksal, or other ready made tools to run Drupal locally,
    check their documentation on how to best integrate Chrome and Selenium for functional
    JavaScript tests. They all have variations in approach to installing them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 DDEV、Lando、Docksal 或其他现成的工具在本地运行 Drupal，请检查它们的文档，了解如何最佳地集成 Chrome 和 Selenium
    以进行功能 JavaScript 测试。它们在安装方法上都有所不同。
- en: How to do it…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In your `tests/src` directory, create a new directory named `FunctionalJavascript`.
    Within that new directory, create a file named `CamelCaseFormatterDisplayAjaxTest.php`.
    You can copy the previous functional test code into this file, with these changes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `tests/src` 目录中，创建一个名为 `FunctionalJavascript` 的新目录。在该新目录中，创建一个名为 `CamelCaseFormatterDisplayAjaxTest.php`
    的文件。你可以将之前的函数测试代码复制到这个文件中，并进行以下更改：
- en: Update `namespace` from `Functional` to `FunctionalJavascript`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `namespace` 从 `Functional` 更改为 `FunctionalJavascript`
- en: Extend `WebDriverTestBase` instead of `BrowserTestBase`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WebDriverTestBase` 而不是 `BrowserTestBase` 扩展
- en: The class name should be changed to `CamelCaseFormatterDisplayAjaxTest`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应更改为 `CamelCaseFormatterDisplayAjaxTest`
- en: Since we now have a requirement to add JavaScript around the display of this
    text on the page, you can remove the old functional test, since it will fail.
    Text won’t be present on the page at first and the old test can’t listen or wait
    for AJAX, so we no longer need that test.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在需要在页面显示此文本周围添加 JavaScript，因此可以删除旧的功能测试，因为它将失败。文本最初不会出现在页面上，旧测试无法监听或等待
    AJAX，所以我们不再需要这个测试。
- en: 'Now, we can update the test method to account for the new requirement. Assume
    that JavaScript has been written already and that the field value is fetched and
    output by AJAX. The implementation details are not important here, but we can
    change our test method to *wait* until AJAX has completed before checking for
    text on the page:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新测试方法以适应新的要求。假设 JavaScript 已经编写好，并且字段值是通过 AJAX 获取和输出的。实现细节在这里并不重要，但我们可以更改测试方法以
    *等待* AJAX 完成后再检查页面上的文本：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And after running our new test with PHPUnit, this is the result:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的新测试后，这是结果：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Functional JavaScript tests are functional tests, with the added functionality
    of being run in a real browser such as Google Chrome. This is what makes it possible
    to assert even more tests for HTML elements, interactivity, AJAX, cookies, and
    other features that require using a real browser to perform actions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 功能 JavaScript 测试是功能测试，增加了在真实浏览器（如 Google Chrome）中运行的功能。这使得可以对 HTML 元素、交互性、AJAX、cookies
    以及其他需要使用真实浏览器执行操作的功能进行更多测试。
- en: Writing a NightwatchJS test
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 NightwatchJS 测试
- en: Similar to a functional JavaScript test, NightwatchJS uses Google Chrome to
    evaluate tests. However, instead of PHP files, the test files are written entirely
    in JavaScript and require NodeJS and `yarn` to run and interact with.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能 JavaScript 测试类似，NightwatchJS 使用 Google Chrome 来评估测试。然而，测试文件完全是用 JavaScript
    编写的，而不是 PHP 文件，并且需要 NodeJS 和 `yarn` 来运行和交互。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'NightwatchJS is not included as part of PHPUnit, so you will need to install
    it using `yarn`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: NightwatchJS 不是作为 PHPUnit 的一部分包含的，因此你需要使用 `yarn` 安装它：
- en: Inside the `/core` folder, run `yarn install`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/core` 文件夹中，运行 `yarn install`。
- en: Configure `.env.example` to `.env` and editing as necessary. These settings
    will mostly be the same as your local environment settings. `DRUPAL_TEST_BASE_URL`
    will be the value of your local site URL, for example.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `.env.example` 为 `.env` 并根据需要编辑。这些设置将大致与你的本地环境设置相同。`DRUPAL_TEST_BASE_URL`
    将是本地站点的 URL 值，例如。
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'NightwatchJS looks for tests in the following directories:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: NightwatchJS 在以下目录中查找测试：
- en: '`mymodule/tests/src/Nightwatch/Tests`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/tests/src/Nightwatch/Tests`'
- en: '`mymodule/tests/src/Nightwatch/Commands`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/tests/src/Nightwatch/Commands`'
- en: '`mymodule/tests/src/Nightwatch/Assertions`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/tests/src/Nightwatch/Assertions`'
- en: '`mymodule/tests/src/Nightwatch/Pages`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/tests/src/Nightwatch/Pages`'
- en: Here, `mymodule` is your custom module name, like `chapter13`, which we have
    been using for all the code in this chapter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mymodule` 是你的自定义模块名称，例如 `chapter13`，我们一直在本章的所有代码中使用它。
- en: 'You can run NightwatchJS tests using `yarn`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `yarn` 运行 NightwatchJS 测试：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Alternatively, you can run a single test – for example, a test in your custom
    module:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以运行单个测试——例如，您自定义模块中的测试：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let’s convert the `CamelCase` PHP class to a JavaScript function and test it
    with `nightwatch`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CamelCase` PHP类转换为JavaScript函数，并使用`nightwatch`进行测试。
- en: 'Create a directory called `js` at `chapter13/js`. Inside, create a file called
    `camelCase.js`. The file will contain the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter13/js`目录下创建一个名为`js`的目录。在其内部，创建一个名为`camelCase.js`的文件。该文件将包含以下代码：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can unit-test this JavaScript function just like we did with the PHP class
    at the start of the chapter. To do that, create a new directory under `chapter13/tests/src/Nightwatch`,
    and within that directory, create another directory called `Tests`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在章节开头对PHP类进行单元测试一样对这个JavaScript函数进行单元测试。为此，在`chapter13/tests/src/Nightwatch`目录下创建一个新的目录，并在该目录内创建一个名为`Tests`的目录。
- en: 'Create a file in the `Tests` directory called `CamelCaseTest.js`. It will look
    like this, getting the same result that we got from the previous functional JavaScript
    test:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tests`目录下创建一个名为`CamelCaseTest.js`的文件。它看起来像这样，得到与之前功能JavaScript测试相同的结果：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now execute the test with:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行测试，使用以下命令：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Nightwatch will execute the JavaScript function, loop over the `dataProvider`
    values, and assert that the function returns what we expect it to:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Nightwatch将执行JavaScript函数，遍历`dataProvider`值，并断言函数返回我们期望的结果：
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is useful for testing JavaScript functions you have written for your custom
    modules or themes. Testing JavaScript functions or behaviors can be a time-intensive
    task to do manually. NightwatchJS is handy for automating that task.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于测试您为自定义模块或主题编写的JavaScript函数非常有用。手动测试JavaScript函数或行为可能是一项耗时的工作。NightwatchJS可以方便地自动化这项任务。
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: NightwatchJS is also capable of doing browser-based test assertions such as
    the functional JavaScript tests we discussed earlier in the chapter. There are
    caveats though, as the scope of JavaScript is more limited than a language such
    as PHP – depending on what you are trying to test, the test setup may take way
    longer than it would in PHP. You can certainly script your way there by using
    JavaScript in the test to log in as an admin and navigate Drupal to create fields,
    nodes, and elements, but this would take a *lot* of JavaScript to do, and it is
    more suitable to make your own install profile in this case.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: NightwatchJS也能够执行基于浏览器的测试断言，例如我们在本章前面讨论的功能JavaScript测试。然而，也有一些限制，因为JavaScript的作用域比PHP等语言要有限得多——根据您试图测试的内容，测试设置可能比在PHP中要长得多。您当然可以通过在测试中使用JavaScript来登录为管理员并导航Drupal来创建字段、节点和元素来编写脚本，但这需要大量的JavaScript，在这种情况下，创建自己的安装配置文件可能更合适。
- en: Having said that, there are various tests in Drupal core that use NightwatchJS,
    so be sure to refer to them for pointers, examples, and ideas.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Drupal核心中有各种使用NightwatchJS的测试，因此请务必参考它们以获取提示、示例和想法。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: 'You are not strictly limited to writing tests using PHPUnit or NightwatchJS
    for Drupal. There are many third-party test harnesses you can use to write and
    run tests for different use cases in Drupal. Be sure to check out the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不严格限于使用PHPUnit或NightwatchJS为Drupal编写测试。有许多第三方测试框架可用于在Drupal中编写和运行针对不同用例的测试。请务必查看以下内容：
- en: Behat Drupal Extension
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Behat Drupal扩展
- en: Drupal Test Traits
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal测试特性
- en: '[Cypress.io](https://Cypress.io)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cypress.io](https://Cypress.io)'
