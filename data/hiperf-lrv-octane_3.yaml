- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Configuring the Swoole Application Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Swoole 应用服务器
- en: With Laravel Octane, instead of RoadRunner, you can use another type of application
    server. In addition to RoadRunner, we can configure and use Swoole. Both tools
    allow you to implement an application server. Obviously, there are differentiating
    elements between the two tools, and sometimes deciding which one to use can be
    difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Laravel Octane，您可以选择另一种类型的应用服务器。除了 RoadRunner 之外，我们还可以配置和使用 Swoole。这两个工具都允许您实现应用服务器。显然，这两个工具之间存在不同的元素，有时决定使用哪一个可能会很困难。
- en: As we saw, RoadRunner is a separate executable, which means that its installation,
    as seen in [*Chapter 2*](B17728_02.xhtml#_idTextAnchor036), *Configuring the RoadRunner
    Application Server*, is quite simple and does not affect the heart of the PHP
    engine. This means that in all probability, it has no side effects on other tools
    that work in the heart of the engine. These tools (such as Xdebug) are typically
    diagnostic, monitoring, and debugging tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，RoadRunner 是一个独立的可执行文件，这意味着其安装，如在第 2 章[*配置 RoadRunner 应用服务器*](B17728_02.xhtml#_idTextAnchor036)中所示，相当简单，不会影响
    PHP 引擎的核心。这意味着它很可能对引擎核心中的其他工具没有副作用。这些工具（如 Xdebug）通常是诊断、监控和调试工具。
- en: The advice I would like to give is that, in the process of analysis and selection
    of the application server, evaluate the various other tools that may be useful
    in the development process (such as Xdebug) and evaluate their compatibility with
    Swoole.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给出的建议是，在分析和选择应用服务器的过程中，评估可能对开发过程有用的各种其他工具（如 Xdebug），并评估它们与 Swoole 的兼容性。
- en: Despite there being a greater complexity in the management of Swoole, Swoole
    offers benefits such as additional and advanced features, such as the management
    of an in-memory cache (benefits on performance), Swoole Table, which is a data
    store for sharing information between different processes (and facilitates information
    sharing and better cooperation between processes), and the ability to start asynchronous
    functions and processes at a specific interval (thus enabling asynchronous and
    parallel execution of functions).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管管理 Swoole 的复杂性更高，但 Swoole 提供了诸如内存缓存管理（性能上的好处）、Swoole Table（用于在不同进程之间共享信息的数据存储，便于进程间的信息共享和更好的协作），以及能够在特定间隔启动异步函数和进程的能力（从而实现函数的异步和并行执行）等额外和高级功能。
- en: In the chapter, we will see how to install and configure Swoole with Laravel
    Octane and how to best use the specific features provided by Swoole. In this chapter,
    we will explore features of Swoole such as executing concurrent tasks, executing
    interval tasks, using the highly performant cache and storage mechanisms provided
    by Swoole, and accessing metrics about the usage of workers. All these features
    are available via Octane thanks to the Swoole application server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何使用 Laravel Octane 安装和配置 Swoole，以及如何最好地使用 Swoole 提供的特定功能。在本章中，我们将探讨
    Swoole 的功能，例如执行并发任务、执行间隔任务、使用 Swoole 提供的高性能缓存和存储机制，以及访问关于工作者使用情况的指标。所有这些功能都可通过
    Swoole 应用服务器通过 Octane 提供。
- en: 'In particular, we will cover the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下内容：
- en: Setting up Laravel Octane with Swoole using Laravel Sail
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Laravel Sail 配置 Laravel Octane 与 Swoole
- en: Installing Open Swoole
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Open Swoole
- en: Exploring Swoole features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Swoole 功能
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will cover the Swoole and Open Swoole application server setup
    (installation and configuration).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖 Swoole 和 Open Swoole 应用服务器的设置（安装和配置）。
- en: Unlike what we did for RoadRunner, in this case, we have to install a **PHP
    Extension Community Library** (**PECL**) extension to allow PHP to be able to
    operate with Swoole.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为 RoadRunner 所做的不同，在这种情况下，我们必须安装一个 **PHP 扩展社区库**（**PECL**）扩展，以便 PHP 能够与 Swoole
    一起操作。
- en: What is PECL?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 PECL？
- en: PECL is the repository for PHP extensions. The PECL extensions are written in
    C language and have to be compiled to be used with the PHP engine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PECL 是 PHP 扩展的仓库。PECL 扩展是用 C 语言编写的，并且必须编译后才能与 PHP 引擎一起使用。
- en: Because of the complexity of installing the PECL module with all the dependencies
    required by the compilation, configuration, and setup of the PHP extension, we
    are going to use a container approach – so instead of installing all the necessary
    tools for compiling the PHP extension on our personal operating system, we will
    use **Docker**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装PECL模块及其所有依赖项的编译、配置和设置复杂，我们将使用容器方法——因此，我们不会在我们的个人操作系统中安装编译PHP扩展所需的所有必要工具，而是使用**Docker**。
- en: This allows us to have a running operating system (container) hosted within
    our real operating system. The purpose of having an isolated operating system
    in a container is to contain everything you need for the PHP development environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在真实的操作系统内托管一个运行中的操作系统（容器）。在容器中拥有一个隔离的操作系统目的是为了包含PHP开发环境所需的所有内容。
- en: This means that if we install dependencies and tools, we will do it within an
    isolated environment without affecting our real operating system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们安装依赖项和工具，我们将在一个隔离的环境中完成，而不会影响我们的真实操作系统。
- en: In the previous chapter, we did not use this approach as the requirements were
    simpler. However, many people use the container method for every development environment,
    even the simplest ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们没有使用这种方法，因为要求更简单。然而，许多人使用容器方法来处理每个开发环境，即使是简单的那些。
- en: 'As the development environment begins to require additional dependencies, it
    may become unmanageable. It could become especially unmanageable in the case of
    evolution: try to think of the simultaneous management of several versions of
    PHP, which may require additional versions of dependencies. To isolate and limit
    all this within a consistent environment, it is recommended to use a container
    approach. To do this, the installation of **Docker Desktop** ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/))
    is suggested.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发环境开始需要额外的依赖项，它可能变得难以管理。在进化的情况下，这可能会变得尤其难以管理：试着想象同时管理多个版本的PHP，这可能会需要依赖项的额外版本。为了在一致的环境中隔离和限制所有这些，建议使用容器方法。为此，建议安装**Docker
    Desktop** ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/))。
- en: Once we have installed Docker Desktop, we will configure a specific image for
    PHP with the extensions we need.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Docker Desktop，我们将配置一个带有所需扩展的特定PHP镜像。
- en: All these new packages that we are going to install will be stored within this
    image. When we delete the development environment, simply delete the image used.
    The only tool installed on our operating system will be Docker Desktop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要安装的所有新包都将存储在这个镜像中。当我们删除开发环境时，只需删除使用的镜像即可。我们操作系统中安装的唯一工具将是Docker Desktop。
- en: So, to install Docker Desktop, simply download and proceed with the installation
    wizard specific to your operating system. In the case of macOS, please refer to
    the type of reference chip (Intel or Apple).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要安装Docker Desktop，只需下载并按照适用于您操作系统的安装向导进行即可。在macOS的情况下，请参考参考芯片的类型（Intel或Apple）。
- en: 'If you do not have a thorough knowledge of Docker, do not worry – we are going
    to use another powerful tool in the Laravel ecosystem: **Laravel Sail**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有深入了解Docker，不要担心——我们将使用Laravel生态系统中的另一个强大工具：**Laravel Sail**。
- en: Laravel Sail is a command-line interface that exposes commands for managing
    Docker, specifically for Laravel. Laravel Sail simplifies the use and configuration
    of Docker images, allowing the developer to focus on the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Sail是一个命令行界面，它公开了用于管理Docker的命令，特别是针对Laravel。Laravel Sail简化了Docker镜像的使用和配置，使开发者能够专注于代码。
- en: We are going to use Laravel Sail commands for the creation of a development
    environment, but under the hood, they will result in Docker commands and ready-to-use
    Docker configurations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Laravel Sail命令来创建开发环境，但底层将产生Docker命令和现成的Docker配置。
- en: Source code
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码
- en: 'You can find the source code of the examples used in this chapter in the official
    GitHub repository of this book: [https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch03](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch03).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节中使用的示例的源代码在本书的官方GitHub仓库中：[https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch03](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch03)。
- en: Setting up Laravel Octane with Swoole using Laravel Sail
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Laravel Sail设置Laravel Octane与Swoole
- en: 'In order to have an environment up and running with Swoole as the application
    server and using a Docker container, you have to follow some steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个使用Swoole作为应用服务器并通过Docker容器运行的运行环境，你必须遵循一些步骤：
- en: Set up Laravel Sail
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Laravel Sail
- en: Install Laravel Octane
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Laravel Octane
- en: Set up Laravel Octane and Swoole
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Laravel Octane和Swoole
- en: Setting up Laravel Sail
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Laravel Sail
- en: 'First, create your Laravel application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建你的Laravel应用：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, if you already have your Laravel application you can use the `composer
    show` command to check whether Laravel Sail is installed. This command also shows
    you some additional information about the package:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你已经有了你的Laravel应用，你可以使用`composer show`命令来检查Laravel Sail是否已安装。此命令还会显示有关包的一些附加信息：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If Laravel Sail is not installed, run `composer require` `laravel/sail --dev`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Laravel Sail未安装，请运行`composer require` `laravel/sail --dev`。
- en: 'Once you have Sail installed, you have to create a `docker-compose.yml` file.
    To create a `docker-compose.yml` file, you can use the `sail` command, `sail:install`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Sail，你必须创建一个`docker-compose.yml`文件。要创建`docker-compose.yml`文件，你可以使用`sail`命令，`sail:install`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `sail:install` command will create Docker files for you. The `sail:install`
    process will ask you which service you want to enable. Just to start, you can
    select the default item (`mysql`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sail:install`命令将为你创建Docker文件。`sail:install`过程将询问你想要启用哪个服务。为了开始，你可以选择默认项（`mysql`）：'
- en: '![Figure 3.1 – The Laravel Sail services](img/Figure_3.1_B17728.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Laravel Sail服务](img/Figure_3.1_B17728.jpg)'
- en: Figure 3.1 – The Laravel Sail services
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Laravel Sail服务
- en: 'Answer the questions in the `sail:install` command to determine which services
    to include. The Sail configuration for Docker starts from a set of ready-to-use
    templates (stubs), and the `sail:install` command includes the necessary ones.
    If you are curious about which templates are included and how they are implemented,
    look here: [https://github.com/laravel/sail/tree/1.x/stubs](https://github.com/laravel/sail/tree/1.x/stubs).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回答`sail:install`命令中的问题以确定要包含哪些服务。Sail的Docker配置从一组现成的模板（占位符）开始，`sail:install`命令包含了必要的模板。如果你对包含哪些模板以及它们是如何实现的感兴趣，请查看这里：[https://github.com/laravel/sail/tree/1.x/stubs](https://github.com/laravel/sail/tree/1.x/stubs)。
- en: 'If you take a look at the templates, you will see that they make use of environment
    variables such as `${APP_PORT:-80}`. This means that you can control the configuration
    through environment variables, which are configurable through the `.env` file.
    The `.env` file is automatically generated by the installation of Laravel. If
    for some reason the `.env` file is not present, you can copy the `.env` file from
    the `.env.example` file (for example, when you clone an existent repository that
    uses Laravel Octane, probably the `.env` file is included in the `.gitignore`
    file). In the example, if you want to customize the port where the web server
    receives the request (`APP_PORT`), simply add the parameter to the `.``env` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这些模板，你会看到它们使用了环境变量，例如`${APP_PORT:-80}`。这意味着你可以通过环境变量来控制配置，这些变量可以通过`.env`文件进行配置。`.env`文件由Laravel的安装自动生成。如果由于某种原因`.env`文件不存在，你可以从`.env.example`文件（例如，当你克隆一个使用Laravel
    Octane的现有仓库时，可能`.env`文件包含在`.gitignore`文件中）复制`.env`文件。在示例中，如果你想自定义Web服务器接收请求的端口（`APP_PORT`），只需将参数添加到`.env`文件中：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the web server that will serve your Laravel application will do
    so via port `81`. The default is `80` as seen from `${APP_PORT:-80}`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将使用端口`81`来服务你的Laravel应用，默认端口为`80`，如`${APP_PORT:-80}`所示。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The examples in the *Using Swoole features* section will use Laravel Sail with
    `APP_PORT` set to `81`, so all examples will refer to the host `http://127.0.0.1:81`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用Swoole功能*部分的示例中，将使用`APP_PORT`设置为`81`的Laravel Sail，因此所有示例都将引用主机`http://127.0.0.1:81`。
- en: 'If you have made this change to the `.env` file, you can now launch the command
    from your Laravel project directory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经修改了`.env`文件，你现在可以从你的Laravel项目目录中启动命令：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will start the Docker container. The first time, the execution may take
    some time (a few minutes) because the preconfigured images with nginx, PHP, and
    MySQL will be downloaded.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Docker容器。第一次执行可能需要一些时间（几分钟），因为将下载预配置的包含nginx、PHP和MySQL的镜像。
- en: 'Once the execution of the command is complete, you can visit the `http://127.0.0.1:81`
    page and see your Laravel welcome page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，你可以访问`http://127.0.0.1:81`页面并看到你的Laravel欢迎页面：
- en: '![Figure 3.2 – Laravel welcome page](img/Figure_3.2_B17728.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Laravel 欢迎页面](img/Figure_3.2_B17728.jpg)'
- en: Figure 3.2 – Laravel welcome page
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Laravel 欢迎页面
- en: The main difference with this container approach is that the tools used to render
    the page (nginx, PHP) are included in the Docker image and not in your main operating
    system. With this method, you may not even have the PHP and nginx engine on your
    main operating system. The Laravel Sail configuration instructs Docker to use
    the container for PHP and all the needed tools, and points to your local source
    code (the root of your Laravel project) on your local filesystem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与此容器方法相比，主要区别在于用于渲染页面的工具（nginx、PHP）包含在 Docker 图像中，而不是在您的主操作系统上。使用此方法，您甚至可能没有在主操作系统上安装
    PHP 和 nginx 引擎。Laravel Sail 配置指示 Docker 使用容器来运行 PHP 和所有需要的工具，并将本地文件系统中的本地源代码（您的
    Laravel 项目的根目录）指向本地文件系统。
- en: Now that we have Laravel Sail installed with your Laravel application, we have
    to add Laravel Octane stuff to use the Swoole package already included in the
    Laravel image provided by Sail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Laravel Sail 与您的 Laravel 应用程序一起安装好了，我们必须添加 Laravel Octane 的相关内容，以便使用
    Sail 提供的 Laravel 图像中已经包含的 Swoole 包。
- en: Let’s begin by installing Laravel Octane.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Laravel Octane 开始。
- en: Installing Laravel Octane
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Laravel Octane
- en: We are going to install Laravel Octane through the container provided by Laravel
    Sail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Laravel Sail 提供的容器来安装 Laravel Octane。
- en: 'So while `sail up` is still running (is running as a server), launch `composer
    require` with the Octane package. Launching the command with `sail` will execute
    your command inside your container:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 `sail up` 仍在运行（作为服务器运行）时，使用 `composer require` 命令启动 Octane 包。使用 `sail`
    启动命令将在您的容器内执行您的命令：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting up Laravel Octane and Swoole
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Laravel Octane 和 Swoole
- en: 'In order to adjust the command that launches the server, you have to publish
    Laravel Sail files with the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整启动服务器的命令，您必须使用以下命令发布 Laravel Sail 文件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will copy the Docker configuration files from the package in the
    `docker` directory in the root project directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从根项目目录中的 `docker` 目录中的包中复制 Docker 配置文件。
- en: 'It creates a `docker` directory. Inside the `docker` directory, more than one
    directory is created, one for each PHP version: `7.4`, `8.0`, `8.1`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个 `docker` 目录。在 `docker` 目录内，创建了多个目录，每个目录对应一个 PHP 版本：`7.4`、`8.0`、`8.1`。
- en: 'In the `docker/8.1` directory, you have the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker/8.1` 目录中，您有以下内容：
- en: A Dockerfile.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Dockerfile。
- en: The `php.ini` file.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php.ini` 文件。'
- en: The `start-container` script used to launch the container. This script refers
    to the `supervisor.conf` file with the bootstrap configuration.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于启动容器的 `start-container` 脚本。此脚本引用了带有引导配置的 `supervisor.conf` 文件。
- en: The `supervisor.conf` file with the configuration of the supervisor script.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含监督脚本配置的 `supervisor.conf` 文件。
- en: '![Figure 3.3 – The Docker configuration files (after sail:publish execution)](img/Figure_3.3_B17728.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Docker 配置文件（sail:publish 执行后）](img/Figure_3.3_B17728.jpg)'
- en: Figure 3.3 – The Docker configuration files (after sail:publish execution)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Docker 配置文件（sail:publish 执行后）
- en: 'The `supervisord.conf` file is important because it includes the bootstrap
    command of the web server of the container. By default, the `supervisord.conf`
    file contains the command directive:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisord.conf` 文件很重要，因为它包含了容器中 web 服务器的引导命令。默认情况下，`supervisord.conf` 文件包含命令指令：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have Laravel Octane, so instead of using the classic `artisan serve`,
    we have to change it and use `artisan octane:start`; so, in the `docker/supervisor.conf`
    file, you have to adjust the command line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了 Laravel Octane，所以不再使用经典的 `artisan serve`，而要改为使用 `artisan octane:start`；因此，在
    `docker/supervisor.conf` 文件中，您必须调整命令行：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you look, you will see that with `artisan octane:start`, the Swoole server
    with the `--server=swoole` parameter is also defined.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看的话，您会看到，使用 `artisan octane:start` 时，带有 `--server=swoole` 参数的 Swoole 服务器也被定义了。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are confused by ports `80` and `81`, just to clarify: the application
    server inside the container will listen internally to port `80`. With `APP_PORT=81`,
    we are instructing Docker to map the external connections from port `81` to internal
    port `80`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对端口 `80` 和 `81` 感到困惑，只是为了澄清：容器中的应用服务器将监听内部端口 `80`。通过 `APP_PORT=81`，我们指示 Docker
    将来自端口 `81` 的外部连接映射到内部端口 `80`。
- en: 'When you change some Docker configuration files, you have to rebuild the image
    in order for the container to use the changed files. To rebuild the image, use
    the `build` option:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改一些 Docker 配置文件时，你必须重建镜像以便容器使用更改的文件。要重建镜像，请使用 `build` 选项：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command takes a while to be completed, but once it is completed, you can
    execute the `sail` `up` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令需要一段时间才能完成，但一旦完成，你就可以执行 `sail up` 命令：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When Octane is ready, you will see the `INFO Server` `running…` message:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Octane 准备就绪时，你会看到 `INFO Server` `running…` 消息：
- en: '![Figure 3.4 – The Octane server is running](img/Figure_3.4_B17728.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – The Octane server is running](img/Figure_3.4_B17728.jpg)'
- en: Figure 3.4 – The Octane server is running
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Octane 服务器正在运行
- en: If you open your browser, you can access `http://localhost:81`. The message
    in your console says that the server is listening to port `80`, but as we previously
    mentioned, the process wherein the server is listening to port `80` is the internal
    process inside the Docker container. The processes external to the Docker container
    (your browser) have to refer to the exposed port (`81` according to the `APP_PORT`
    configuration).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的浏览器，你可以访问 `http://localhost:81`。你的控制台中的消息表明服务器正在监听端口 `80`，但如我们之前提到的，监听端口
    `80` 的进程是 Docker 容器内的内部进程。Docker 容器外部的进程（你的浏览器）必须引用暴露的端口（根据 `APP_PORT` 配置，为 `81`）。
- en: 'In your browser, you will see the default welcome Laravel page. You can tell
    that this page is served by Octane and Swoole from the HTTP server header from
    the response. A way to see this is to launch the `curl` command with the `-I`
    option to show the header, and filter the header needed with the `grep` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中，你会看到默认的 Laravel 欢迎页面。你可以从响应的 HTTP 服务器头中看出这个页面是由 Octane 和 Swoole 服务的。查看这个的一个方法是使用带有
    `-I` 选项的 `curl` 命令来显示头信息，并使用 `grep` 命令过滤所需的头信息：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This means that the Laravel application is served by Octane and the Swoole application
    server.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Laravel 应用程序是由 Octane 和 Swoole 应用服务器服务的。
- en: So, we can start to use some Swoole functionalities – but before that, let us
    install Open Swoole.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以开始使用一些 Swoole 功能 – 但在那之前，让我们先安装 Open Swoole。
- en: Installing Open Swoole
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Open Swoole
- en: 'Laravel Sail uses by default an image with PHP that includes Swoole modules.
    Swoole is distributed as a PECL module and you can find it here: [https://pecl.php.net/package/swoole](https://pecl.php.net/package/swoole).
    The sources are here: [https://github.com/swoole/swoole-src](https://github.com/swoole/swoole-src).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Sail 默认使用包含 Swoole 模块的 PHP 镜像。Swoole 以 PECL 模块的形式分发，你可以在这里找到它：[https://pecl.php.net/package/swoole](https://pecl.php.net/package/swoole)。源代码在这里：[https://github.com/swoole/swoole-src](https://github.com/swoole/swoole-src)。
- en: Some developers forked the source of Swoole, creating the Open Swoole project
    to address security concerns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者从 Swoole 的源代码中分叉，创建了 Open Swoole 项目来解决安全问题。
- en: 'The reason for the fork is reported here: [https://news-web.php.net/php.pecl.dev/17446](https://news-web.php.net/php.pecl.dev/17446).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉的原因在此处报告：[https://news-web.php.net/php.pecl.dev/17446](https://news-web.php.net/php.pecl.dev/17446)。
- en: So, if you want to use Swoole as the engine for Laravel Octane, you could decide
    to use the Open Swoole implementation. If you want to use Open Swoole, the installation
    and the configuration are the same as Swoole; Open Swoole is also distributed
    as a PECL module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想将 Swoole 作为 Laravel Octane 的引擎，你可以决定使用 Open Swoole 实现。如果你想使用 Open Swoole，安装和配置与
    Swoole 相同；Open Swoole 也以 PECL 模块的形式分发。
- en: Laravel Octane supports both.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane 支持两者。
- en: 'For demonstration purposes, I will install Open Swoole for a new Laravel project
    directly in the operating system (no Docker):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我将在操作系统（无 Docker）中直接为新的 Laravel 项目安装 Open Swoole。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To check that the HTTP response is created by the Open Swoole server, in another
    terminal session, launch the following `curl` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 HTTP 响应是 Open Swoole 服务器创建的，在另一个终端会话中，启动以下 `curl` 命令：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, Open Swoole is a fork of the Swoole project. We will refer to it as Swoole;
    you can decide which you want to install. The features discussed in the *Exploring
    Swoole features* section are supported both by Swoole and Open Swoole.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Open Swoole 是 Swoole 项目的分支。我们将称之为 Swoole；你可以决定安装哪一个。在 *探索 Swoole 功能* 部分讨论的功能都由
    Swoole 和 Open Swoole 支持。
- en: Before exploring the Swoole features, we should install one more package that
    improves the developer experience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 Swoole 功能之前，我们应该安装一个额外的包来提高开发者体验。
- en: Before editing the code
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑代码之前
- en: 'We are going to use Swoole functionalities, implementing some example code.
    When you change (or edit) your code and Laravel Octane has already loaded the
    worker, you have to reload the worker. Manually, you can use an Octane command.
    If you are using Laravel Sail (so Docker), you have to run the command in the
    container. The command is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Swoole功能，实现一些示例代码。当你更改（或编辑）你的代码，并且Laravel Octane已经加载了工作进程时，你必须重新加载工作进程。手动来说，你可以使用Octane命令。如果你使用Laravel
    Sail（因此是Docker），你必须在该容器中运行命令。命令如下：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you are running in a container, you have to use the `sail` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个容器中运行，你必须使用`sail`命令：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to avoid manually reloading workers every time you edit or change
    your code and you want that Octane watches automatically the file changes, you
    have to do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要避免每次编辑或更改代码时手动重新加载工作进程，并且你希望Octane自动监视文件更改，你必须做以下操作：
- en: Install the `watch` mode
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`watch`模式
- en: Change the `supervisord` configuration file in order to launch Octane with the
    `--``watch` option
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`supervisord`配置文件以使用`--watch`选项启动Octane
- en: Rebuild the image to reflect the changes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建镜像以反映更改
- en: Execute `Sail` again
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次执行`Sail`
- en: 'So, first, let’s install `chokidar`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们安装`chokidar`：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In `docker/8.1/supervisord.conf`, add the `--watch` option to the `octane:start`
    command directive:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker/8.1/supervisord.conf`中，将`--watch`选项添加到`octane:start`命令指令中：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, rebuild the Docker image to be sure that the update to the configuration
    takes effect and then launch the Laravel Sail service:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重建Docker镜像以确保配置更新生效，然后启动Laravel Sail服务：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, when you edit the code (in the PHP files of your Laravel application),
    the workers will be automatically reloaded. In the output messages of Octane,
    you will see the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你编辑代码（在你的Laravel应用程序的PHP文件中）时，工作进程将自动重新加载。在Octane的输出消息中，你会看到以下内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have the auto-reload functionality, we can explore the Swoole features.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自动重新加载功能，我们可以探索Swoole的功能。
- en: Exploring Swoole features
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Swoole功能
- en: 'Swoole has a lot of features that we can use in the Laravel Octane application
    in order to improve the performance and speed of our application. In this chapter,
    we are going to explore these functionalities and then in the subsequent chapters,
    we will use these functionalities. The Swoole functionalities that we are going
    to explore are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole拥有许多我们可以在Laravel Octane应用程序中使用的功能，以提高我们应用程序的性能和速度。在本章中，我们将探讨这些功能，然后在随后的章节中，我们将使用这些功能。我们将探讨的Swoole功能如下：
- en: Concurrent tasks
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发任务
- en: Interval command execution
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔命令执行
- en: Caching
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Tables
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格
- en: Metrics
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标
- en: Concurrent tasks
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发任务
- en: With Swoole, it is possible to execute multiple tasks in parallel. To demonstrate
    this, we are going to implement two functions whose execution takes some time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swoole，可以并行执行多个任务。为了演示这一点，我们将实现两个执行需要一些时间的函数。
- en: To simulate the fact that these two functions are time-consuming, we will use
    the `sleep()` function, which suspends execution for a certain number of seconds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这两个函数是耗时的，我们将使用`sleep()`函数，该函数会暂停执行一定数量的秒数。
- en: 'These two functions return strings: the first one returns “`Hello`” and the
    second one returns “`World`”.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数返回字符串：第一个返回“`Hello`”，第二个返回“`World`”。
- en: We are going to set the execution time to 2 seconds, via the `sleep()` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过`sleep()`函数将执行时间设置为2秒。
- en: In a classic scenario of sequential execution of the two functions, the total
    time taken would be 4 seconds plus a millesimal due to overheads.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个函数的经典顺序执行场景中，总耗时将是4秒加上由于开销而产生的毫秒数。
- en: We are going to track the execution time using the `hrtime()` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`hrtime()`函数跟踪执行时间。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you need to track the execution time of a series of instructions, the use
    of `hrtime()` is recommended since it is a function that returns monotonic timestamps.
    A monotonic timestamp is a time calculated based on a reference point (thus relative)
    and is not affected by system date changes such as automatic clock adjustments
    (NTP or Daylight Savings Time updates).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要跟踪一系列指令的执行时间时，建议使用`hrtime()`函数，因为它是一个返回单调时间戳的函数。单调时间戳是基于一个参考点（因此是相对的）计算的时间，并且不受系统日期更改（如自动时钟调整[NTP或夏令时更新]）的影响。
- en: We are also going to use two anonymous functions because this will come in handy
    in the second example (the example with concurrent execution) to be able to make
    an easier comparison.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用两个匿名函数，因为在第二个示例（并发执行示例）中这将非常有用，以便能够更容易地进行比较。
- en: Another consideration, before we take a look at the code, we are going to implement
    the examples directly in the `routes/web.php` file for simplicity and focus on
    the example code. You can use that code, especially `Octane::concurrently()` in
    your controllers or other parts of your Laravel application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，我们将为了简单和专注，直接在`routes/web.php`文件中实现示例。您可以使用这段代码，特别是`Octane::concurrently()`，在您的控制器或其他Laravel应用程序的部分。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For access to these examples, we are going to use the configuration with Laravel
    Sail and Swoole, with `APP_PORT` set to `81`. If you are going to use your local
    Open Swoole installation, refer to `127.0.0.1:8000` instead of `127.0.0.1:81`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问这些示例，我们将使用Laravel Sail和Swoole的配置，将`APP_PORT`设置为`81`。如果您打算使用您本地的Open Swoole安装，请使用`127.0.0.1:8000`而不是`127.0.0.1:81`。
- en: 'The example shows the sequential execution:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示了顺序执行：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you access the `http://127.0.0.1:81/serial-task`page with your browser,
    you should see this output on your page:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器访问`http://127.0.0.1:81/serial-task`页面，您应该在您的页面上看到以下输出：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The two functions are executed sequentially, which means that the execution
    time is the sum of the execution time of the first function and that of the second
    function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是顺序执行的，这意味着执行时间是第一个函数的执行时间加上第二个函数的执行时间。
- en: 'If you call the two functions with the `Octane::concurrently()` method (passing
    your functions as an array of `Closure`), you can execute the functions in parallel:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`Octane::concurrently()`方法（将您的函数作为`Closure`数组传递）调用这两个函数，您可以在并行中执行这些函数：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you open your browser to `http://127.0.0.1:81/concurrent-task`, you will
    see the following message:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开浏览器到`http://127.0.0.1:81/concurrent-task`，您将看到以下信息：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Another thing to note is that for concurrent functions, the execution time depends
    on what happens inside the function. For example, if you want to execute two or
    more functions in parallel that take an unpredictable amount of time because they
    depend on third-party factors such as the response time of web services or the
    workload of a database, or when a huge file is being parsed, you probably can’t
    make any assumptions about the order of the execution or the duration time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，对于并发函数，执行时间取决于函数内部发生的情况。例如，如果您想并行执行两个或更多函数，这些函数的执行时间不可预测，因为它们依赖于第三方因素，如网络服务的响应时间或数据库的工作负载，或者当正在解析大文件时，您可能无法对执行顺序或持续时间做出任何假设。
- en: 'In the next example, we have two simple functions: the first one takes more
    time to be executed, so even though it is the first function, it is completed
    after the second one. This is obvious for people who are used to working with
    parallel tasks but probably is less obvious for people who are used to using a
    strong synchronous language (such as PHP without Swoole or other tools that add
    asynchronous functionalities):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们有两个简单的函数：第一个函数执行时间更长，因此尽管它是第一个函数，但它是在第二个函数之后完成的。这对于习惯于处理并行任务的人来说是显而易见的，但对于习惯于使用强同步语言（如没有Swoole或其他添加异步功能的工具的PHP）的人来说可能不太明显：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is to print the second statement in the log file before the first
    one. If you take a look at the `storage/logs/laravel.log` file, you will see the
    following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在日志文件中先打印第二条语句，然后再打印第一条。如果您查看`storage/logs/laravel.log`文件，您将看到以下内容：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It means that the execution of the functions called by `Octane::concurrently`
    start more or less at the same time, but the exact moment they are completed,
    the execution, depends on the time needed by the execution of the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着由`Octane::concurrently`调用的函数的执行将在大致相同的时间开始，但它们完成的精确时刻取决于函数执行所需的时间。
- en: Why is this important to keep in mind?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这一点需要记住？
- en: 'Because everything might be okay if the two functions are totally independent
    of each other. On the other hand, if the functions operate using the same resources
    (reading and writing to the same database table, for example), we need to consider
    the dependencies between the two operations. For example, one function might alter
    the data in the table, while the other function might read it. The time at which
    the data is read is relevant: think about whether the data is read before it is
    written or whether it is read after it is written. In this case, we might have
    two totally different behaviors.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果两个函数完全独立于彼此，那么一切可能都会顺利。另一方面，如果函数使用相同的资源（例如，读写同一个数据库表），我们需要考虑两个操作之间的依赖关系。例如，一个函数可能会更改表中的数据，而另一个函数可能会读取它。读取数据的时间是相关的：考虑数据是在写入之前读取还是写入之后读取。在这种情况下，我们可能会有两种完全不同的行为。
- en: Regardless, we will go more deeply into the `concurrently` method in the next
    chapter, where we will use Octane in a more real-life scenario – for example,
    using `concurrently` to retrieve data from multiple database queries and multiple
    API calls.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，我们将在下一章更深入地探讨`concurrently`方法，在那里我们将使用 Octane 在更真实的场景中——例如，使用`concurrently`从多个数据库查询和多个
    API 调用中检索数据。
- en: Interval command execution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间隔命令执行
- en: Sometimes, you have to execute a function every X second(s). For example, you
    want to execute a function every 10 seconds. With Swoole, you can use the `Octane::tick()`
    function, where you can provide a name (as the first parameter) and the function
    defining a `Closure` as the second parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你必须每X秒执行一次函数。例如，你可能想每10秒执行一次函数。使用 Swoole，你可以使用`Octane::tick()`函数，其中你可以提供一个名称（作为第一个参数）和定义一个`Closure`的函数作为第二个参数。
- en: The best place to call the `tick()` function is in the `boot()` method of one
    of your service providers. Typically, I use the default `AppServiceProvider` in
    the `app/Providers` directory, already created for you when you set up a new Laravel
    application (with the `laravel new` command, for example).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`tick()`函数的最佳位置是在你的服务提供者之一的`boot()`方法中。通常，我使用在`app/Providers`目录中默认创建的`AppServiceProvider`，这是当你使用`laravel
    new`命令设置新的 Laravel 应用程序时为你创建的。
- en: 'In `app/Providers/AppServiceProvider.php`, in the `boot()` method, call the
    `Octane::tick()` function with a very simple feature that logs a message with
    the timestamp. The log message will be tracked in the `storage/logs/laravel.log`
    file unless you have some special configuration in the `.``env` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/Providers/AppServiceProvider.php`中的`boot()`方法中，使用一个非常简单的功能调用`Octane::tick()`函数，该功能使用时间戳记录一条消息。除非你在`.env`文件中有特殊配置，否则日志消息将被跟踪在`storage/logs/laravel.log`文件中：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code snippet, we are using `Octane` and `Log` classes, so
    remember to include them at the top of the `AppServiceProvider.php` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`Octane`和`Log`类，所以请记住在`AppServiceProvider.php`文件的顶部包含它们：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Octane::tick()` method returns the `InvokeTickCallable` object that implements
    a few methods:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Octane::tick()`方法返回一个实现了几个方法的`InvokeTickCallable`对象：'
- en: '`__invoke()`: A special method used for invoking the `tick()` listener; it
    is the method responsible for executing the function passed as the second parameter
    to the `tick()` method.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__invoke()`: 一个特殊的方法，用于调用`tick()`监听器；它是负责执行传递给`tick()`方法的第二个参数中函数的方法。'
- en: '`seconds()`: A method for indicating how often the listener should be automatically
    invoked (via the `__invoke()` method). It accepts an integer parameter in seconds.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seconds()`: 一个方法，用于指示监听器应该自动调用（通过`__invoke()`方法）。它接受一个以秒为单位的整数参数。'
- en: '`immediate()`: A method indicating that the listener should be invoked on the
    first tick (so, as soon as possible).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`immediate()`: 一个方法，表示监听器应该在第一次tick时被调用（因此，尽可能快地）。'
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `tick()` method from the application service is called when you start the
    `octane:start` command. If you are using Laravel Sail, the application service
    is loaded and booted when you run `sail up`, just because at the end, Sail launches
    `supervisord` and the configuration of `supervisord` has the `octane:start` command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动`octane:start`命令时，会调用应用程序服务中的`tick()`方法。如果你使用 Laravel Sail，当运行`sail up`时，应用程序服务会被加载和启动，仅仅因为最终
    Sail 启动了`supervisord`，而`supervisord`的配置中包含了`octane:start`命令。
- en: 'Once Octane is started in `storage/logs/laravel.log`, you can see the message
    logged by the `tick()` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在`storage/logs/laravel.log`中启动了 Octane，你就可以看到`tick()`函数记录的消息：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the snippet here, the Laravel log shows us the execution of the `tick()`
    method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，Laravel日志显示`tick()`方法的执行。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For displaying the log in real time, you can use the `tail -f` command – for
    example, `tail -``f storage/logs/laravel.log`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实时显示日志，你可以使用`tail -f`命令——例如，`tail -f storage/logs/laravel.log`。
- en: Caching
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Managing a caching mechanism to momentarily save some data in a system based
    on workers, where each worker has its own memory space, might not be so straightforward.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于工作者的系统中管理缓存机制，暂时保存一些数据，其中每个工作者都有自己的内存空间，可能并不那么简单。
- en: Laravel Octane provides a mechanism to non-permanently save data shared between
    different workers. This means that if a worker needs to store a value and make
    it available to subsequent executions by other workers, it is possible to do so
    through the cache mechanism. The caching mechanism in Laravel Octane is implemented
    through Swoole Table, which we will see in detail later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane提供了一个机制来非永久地保存不同工作者之间共享的数据。这意味着如果一个工作者需要存储一个值并使其对其他工作者的后续执行可用，这是可能的，可以通过缓存机制来实现。Laravel
    Octane中的缓存机制是通过Swoole Table实现的，我们将在稍后详细了解。
- en: In this specific case, we are going to use the `Cache` class exposed directly
    by Laravel. Laravel’s caching mechanism allows us to use different drivers, such
    as, for example, databases (MySQL, Postgresql, or SQLite), Memcache, Redis, or
    other drivers. Because we installed Laravel Octane and used Swoole, we can use
    a new Octane-specific driver. If we wanted to use Laravel’s caching mechanism,
    we would use the `Cache` class with the classic `store` method to store a value.
    In the example, we are going to store a key called `last-random-number` in the
    Octane driver, to which we are going to associate a random number. In the example,
    we’re going to call the function responsible to store the value in the cache via
    the Octane tick seen earlier with an interval set to 10 seconds. We will see that
    every 10 seconds, a new cached value is generated with a random number. We are
    also going to implement a new route, `/get-number`, where we are going to read
    this value and display it on a web page.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们将使用Laravel直接暴露的`Cache`类。Laravel的缓存机制允许我们使用不同的驱动程序，例如，例如，数据库（MySQL、Postgresql或SQLite）、Memcache、Redis或其他驱动程序。因为我们安装了Laravel
    Octane并使用了Swoole，我们可以使用一个新的Octane特定驱动程序。如果我们想使用Laravel的缓存机制，我们将使用带有经典`store`方法的`Cache`类来存储值。在示例中，我们将在Octane驱动程序中存储一个名为`last-random-number`的键，并将其与一个随机数关联。在示例中，我们将通过之前看到的Octane
    tick函数调用负责在缓存中存储值的函数，并将间隔设置为10秒。我们将看到每10秒生成一个新的带有随机数的缓存值。我们还将实现一个新的路由，`/get-number`，我们将读取此值并在网页上显示它。
- en: To obtain the Cache instance with the Octane provider you can use `Cache::store('octane')`.
    Once you have the instance, you can use the `put()` method to store the new value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Octane提供程序获取缓存实例，你可以使用`Cache::store('octane')`。一旦你有了实例，你可以使用`put()`方法来存储新值。
- en: 'In the `app/Providers/AppServiceProvider.php` file, in the `boot()` method,
    add the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/Providers/AppServiceProvider.php`文件中，在`boot()`方法中，添加以下内容：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Be sure that you include the right classes at the beginning of your file. The
    classes needed by this code snippet are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在文件开头包含正确的类。此代码片段需要的类如下：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you want to check, you can see the log messages printed by the `tick()` function
    in the `storage/logs/laravel.log` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查，你可以在`storage/logs/laravel.log`文件中查看`tick()`函数打印的日志消息。
- en: 'Now, we can create a new route in the `routes/web.php` file, where we get the
    value (`last-random-number`) from the cache:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`routes/web.php`文件中创建一个新的路由，从缓存中获取值（`last-random-number`）：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you open your browser and you go to your `/get-random-number` path (in my
    case, `http://127.0.0.1:81/get-random-number` because I’m using Laravel Sail and
    I set `APP_PORT=81` in the `.env` file), you can see the random number. If you
    refresh the page, you will see the same number for 10 seconds, or in general for
    the interval time set with the `tick()` function (in the service provider file).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器并访问你的`/get-random-number`路径（在我的情况下，`http://127.0.0.1:81/get-random-number`因为我使用Laravel
    Sail并且我在`.env`文件中设置了`APP_PORT=81`），你可以看到随机数。如果你刷新页面，你将在10秒内看到相同的数字，或者更一般地说，在`tick()`函数（在服务提供者文件中）设置的间隔时间内。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The storage in the Octane cache is not permanent; it is volatile. This means
    that you can lose the values every time the server is restarted.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Octane缓存中的存储不是永久的；它是易变的。这意味着每次服务器重启时，你可能会丢失这些值。
- en: 'With the Octane cache, we have also some other nice methods, such as `increment`
    and `decrement`, for example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Octane 缓存，我们还有一些其他不错的方法，例如 `increment` 和 `decrement`，例如：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, open your browser and the `/increment-number` path load multiple times
    and then `load /get-number`; you will see the incremented value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的浏览器，多次加载 `/increment-number` 路径，然后加载 `/get-number`；你将看到增加的值。
- en: 'Other useful functions for managing multiple values are `putMany()`, which
    saves an array of items, and `many()`, which retrieves more items at a time:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用于管理多个值的实用函数包括 `putMany()`，它用于保存一个项目数组，以及 `many()`，它一次检索多个项目：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you open your browser first at the `/save-many` path and then at `/get-many`,
    you will see the following on the page:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先在 `/save-many` 路径上打开浏览器，然后打开 `/get-many`，你将在页面上看到以下内容：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you saved a value as an item of an array with the `putMany()` method, you
    can retrieve it as a single item using the array key as the cache key:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `putMany()` 方法将一个值作为数组的项目保存，你可以使用数组键作为缓存键来检索它：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you open the `/get-one-from-many/my-string` page, you will see the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `/get-one-from-many/my-string` 页面，你将看到以下内容：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This means that the value with the `"my-string"` key is retrieved from the cache.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从缓存中检索了具有 `"my-string"` 键的值。
- en: In the end, we are using the Laravel cached mechanism with Swoole as the backend
    provider.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 Laravel 缓存机制，以 Swoole 作为后端提供者。
- en: Why should we use Swoole as a backend cache provider? What advantages does it
    have over other providers such as databases, for example? The way Swoole is made,
    we have seen that performance is certainly one of its main values. Using this
    kind of cache allows us to share information between workers in a very efficient
    way. Swoole’s official documentation reports that it supports a read-write rate
    of 2 million per second.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用 Swoole 作为后端缓存提供者？它相对于数据库等其他提供者有什么优势？我们已经看到，性能肯定是它的主要价值之一。使用这种类型的缓存允许我们以非常高效的方式在工作进程之间共享信息。Swoole
    的官方文档报告，它支持每秒 2 百万的读写速率。
- en: The Laravel Octane cache is implemented via Swoole Table. In the next section,
    we will look at Swoole Table.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane 缓存是通过 Swoole 表实现的。在下一节中，我们将探讨 Swoole 表。
- en: Swoole Table
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swoole 表
- en: If you want to share data across workers in a more structured way than a cache,
    you can use Swoole Table. As already mentioned, the Octane cache uses Swoole Table,
    so let me explain a bit more about Swoole Table.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以比缓存更结构化的方式在多个工作进程之间共享数据，你可以使用 Swoole 表。如前所述，Octane 缓存使用 Swoole 表，所以让我更详细地解释一下
    Swoole 表。
- en: First, if you want to use Swoole Table, you must define the structure of the
    table. The structure is defined in the `config/octane.php` file in the `tables`
    section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你想使用 Swoole 表，你必须定义表的架构。架构在 `config/octane.php` 文件的 `tables` 部分中定义。
- en: '![Figure 3.5 – The configuration of a table in a config/octane.php file](img/Figure_3.5_B17728.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – config/octane.php 文件中表的配置](img/Figure_3.5_B17728.jpg)'
- en: Figure 3.5 – The configuration of a table in a config/octane.php file
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – config/octane.php 文件中表的配置
- en: 'By default, when you execute the `octane:install` command, a `config/octane.php`
    file is created for you, and a table is already defined: a table named `example`
    with a maximum of 1,000 rows (`example:1000`) with 2 fields. The first one is
    called `name` and is a string with a maximum of 500 characters, and the second
    field is called `votes` and the type is an integer (`int`).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你执行 `octane:install` 命令时，会为你创建一个 `config/octane.php` 文件，并且已经定义了一个表：一个名为
    `example` 的表，最多有 1,000 行 (`example:1000`)，包含 2 个字段。第一个字段名为 `name`，是一个最大长度为 500
    个字符的字符串，第二个字段名为 `votes`，类型为整数 (`int`)。
- en: 'In the same way, you can configure your table. The field types are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，你可以配置你的表。字段类型如下：
- en: '`int`: For integers'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 用于整数'
- en: '`float`: For floating-point numbers'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`: 用于浮点数'
- en: '`string`: For strings; you can define the max number of characters'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`: 用于字符串；你可以定义最大字符数'
- en: Once you have defined the table in the config file, you can set the values of
    the table.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在配置文件中定义了表，你就可以设置表的值。
- en: 'For example, I’m going to create a `my-table` table of max 100 rows with some
    fields. In the `config/octane.php` file in the `tables` section, we are going
    to create the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我将创建一个最大 100 行的 `my-table` 表，并包含一些字段。在 `config/octane.php` 文件的 `tables` 部分中，我们将创建以下内容：
- en: A table named `my-table` with a maximum of 100 rows
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `my-table` 的表，最多有 100 行
- en: A UUID field with a `string` type (maximum of 36 characters)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `string` 类型的 UUID 字段（最大长度为 36 个字符）
- en: A name field with a `string` type (maximum of 1000 characters)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `string` 类型的名称字段（最大长度为 1000 个字符）
- en: An age field with an `int` type
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `int` 类型的年龄字段
- en: A value field with a `float` type
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `float` 类型的值字段
- en: 'Therefore, the configuration is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置如下：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the server starts, Octane will create the table in memory for us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，Octane 将为我们创建内存中的表。
- en: 'Now, we are going to create two routes: the first one is for seeding the table
    with some *fake* data, and the second one is for retrieving and showing information
    from the table.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个路由：第一个路由用于向表中填充一些*假*数据，第二个路由用于从表中检索并显示信息。
- en: 'The first route, `/table-create`, will do the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由 `/table-create` 将执行以下操作：
- en: Obtain the table instance for `my-table`. `my-table` is the table configured
    in `config/octane.php`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 `my-table` 表的实例。`my-table` 是在 `config/octane.php` 中配置的表。
- en: Create 90 rows, filling fields for `uuid`, `name`, `age`, and `value`. For filling
    the values, we are going to use the `fake()` helper. This helper allows you to
    generate random values for UUIDs, names, integer numbers, decimal numbers, and
    so on.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 90 行，为 `uuid`、`name`、`age` 和 `value` 字段填充数据。为了填充值，我们将使用 `fake()` 辅助函数。这个辅助函数允许你为
    UUID、名称、整数数字、小数数字等生成随机值。
- en: 'The code in `routes/web.php` is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes/web.php` 文件中的代码如下：'
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The snippet creates the table once the `/table-create` URL is called.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该片段在调用 `/table-create` URL 时创建表。
- en: If you open `http://127.0.0.1:81/table-create`, you will see a table is created
    with some rows.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `http://127.0.0.1:81/table-create`，你会看到一个带有一些行的表被创建。
- en: 'On your page, it’s possible that you have an error such as this one:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的页面上，你可能会有这样的错误：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be sure that the size of the table in the configuration file is greater than
    the number of rows that you are creating. When we work with a database table,
    we don’t have to set the maximum number of rows; in this case, with this kind
    of table (in a memory table shared across the workers), we have to be aware of
    the number of rows.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 确保配置文件中表的尺寸大于你创建的行数。当我们与数据库表一起工作时，我们不需要设置最大行数；在这种情况下，对于这种类型的表（在跨工作进程共享的内存表中），我们必须注意行数。
- en: Once everything is fine, you will see **Table created!** on your web page. This
    means that the rows were created in the right way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常后，你将在网页上看到**表已创建**！这意味着行已正确创建。
- en: 'To verify this, we are going to create a new route, `/table-get`, where we
    do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们将创建一个新的路由，`/table-get`，我们执行以下操作：
- en: Obtain the table instance for `my-table` (the same table we used in `/table-create`)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 `my-table` 表的实例（与我们在 `/table-create` 中使用的相同表）
- en: Get the rows with index 1
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取索引为 1 的行
- en: Return the row (associative array, where the items are the fields of the row
    with `uuid`, `name`, `age`, and `value`)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回行（关联数组，其中项是具有 `uuid`、`name`、`age` 和 `value` 字段的行字段）
- en: 'In the `routes/web.php` file, define the new route:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/web.php` 文件中，定义新的路由：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Opening `https://127.0.0.1:81/table-get` (after opening `/table-create` because
    you have to create rows before accessing them), you should see something such
    as the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `https://127.0.0.1:81/table-get`（在打开 `/table-create` 之后，因为你必须先创建行才能访问它们），你应该看到如下内容：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You will see something different in terms of content because rows were generated
    using the `fake()` helper, but you will see something similar in terms of structure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到内容方面有所不同，因为行是使用 `fake()` 辅助函数生成的，但在结构方面你会看到类似之处。
- en: 'You can also walk through Swoole Table using `foreach()`, and you can also
    use the `count()` function (for counting elements of a table) on the `Table` object:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `foreach()` 遍历 Swoole Table，你还可以在 `Table` 对象上使用 `count()` 函数（用于计数表中的元素）：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, for counting rows, you can see that in the end, we
    can access the Swoole object and use the functions and methods implemented by
    it. Another example of using a Swoole object is accessing the server object, as
    in the next section for retrieving metrics.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，对于行计数，你可以看到最后，我们可以访问 Swoole 对象并使用它实现的函数和方法。使用 Swoole 对象的另一个例子是访问服务器对象，如下一节中检索指标时所示。
- en: Metrics
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: 'Swoole offers a method to retrieve some metrics about the resource usage of
    the application server and the workers. This is useful if you want to track the
    usage of some aspect – for example, the time, the number of requests served, the
    active connections, the memory usage, the number of tasks, and so on. To retrieve
    metrics, first of all, you have to access the Swoole class instance. Thanks to
    the service container provided by Laravel, you can resolve and access objects
    from the container. The Swoole server object is *stored* in the container by Octane
    so, via `App::make`, you can access the Swoole server class instance. In the `routes/web.php`
    file, you can create a new route where you can do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Swoole提供了一种方法来检索关于应用服务器和工作进程资源使用情况的某些指标。如果你想要跟踪某些方面的使用情况——例如，时间、处理请求数量、活跃连接数、内存使用量、任务数量等，这非常有用。要检索指标，首先，你必须访问Swoole类实例。感谢Laravel提供的服务容器，你可以从容器中解析和访问对象。Swoole服务器对象由Octane存储在容器中，因此，通过`App::make`，你可以访问Swoole服务器类实例。在`routes/web.php`文件中，你可以创建一个新的路由，在那里你可以做以下操作：
- en: You can retrieve the Swoole server via `App::make`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过`App::make`检索Swoole服务器。
- en: Once you can access the object, you can use their methods, such as, for example,
    `stats`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你可以访问该对象，你就可以使用它们的方法，例如，比如`stats`
- en: 'The Swoole server `Stats` object is returned as a response:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swoole服务器`Stats`对象作为响应返回：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: On the new `/metrics` page, you can see all the metrics provided by the Swoole
    server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`/metrics`页面上，你可以看到Swoole服务器提供的所有指标。
- en: 'For all methods, you can see directly the server documentation provided by
    Swoole: [https://openswoole.com/docs/modules/swoole-server-stats](https://openswoole.com/docs/modules/swoole-server-stats).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有方法，你可以直接看到Swoole提供的服务器文档：[https://openswoole.com/docs/modules/swoole-server-stats](https://openswoole.com/docs/modules/swoole-server-stats)。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to install and configure an environment with
    Swoole. Then, we also analyzed the various functionalities exposed by this application
    server.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何安装和配置Swoole环境。然后，我们还分析了该应用服务器暴露的各种功能。
- en: We walked through the functionalities with simple examples so that we could
    focus on the individual features. In the next chapter, we will look at using Laravel
    Octane with an application server in a more real-world context.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过简单的示例了解了这些功能，以便我们可以专注于单个特性。在下一章中，我们将探讨在更真实的应用服务器环境中使用Laravel Octane。
- en: 'Part 3: Laravel Octane – a Complete Tour'
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：Laravel Octane——全面游览
- en: The goal of this part is to show practical examples of how to best use the features
    provided by Laravel Octane and the Swoole application server, especially for optimized
    data access. Examples of data query management with caching and parallel queries
    are shown in this part.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的目标是展示如何最好地使用Laravel Octane和Swoole应用服务器提供的功能，特别是针对优化数据访问。本部分展示了具有缓存和并行查询的数据查询管理示例。
- en: 'This part comprises the following chapters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 4*](B17728_04.xhtml#_idTextAnchor065), *Building a Laravel Octane
    Application*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B17728_04.xhtml#_idTextAnchor065)，*构建Laravel Octane应用*'
- en: '[*Chapter 5*](B17728_05.xhtml#_idTextAnchor093), *Reducing Latency and Managing
    Data with an Asynchronous Approach*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17728_05.xhtml#_idTextAnchor093)，*使用异步方法降低延迟和管理数据*'
