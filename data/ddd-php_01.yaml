- en: Getting Started with Domain-Driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用领域驱动设计
- en: So what is all the fuss about? If you've already read books on this topic by
    Vaughn Vernon and Eric Evans, you're probably familiar with what we're about to
    say, as we borrow heavily from their definitions and explanations. **Domain-Driven
    Design **(**DDD**), is an approach that helps us succeed in understanding and
    building software model designs. It provides us with *strategic* and *tactical*
    modeling tools to aid designing high-quality software that meets our business
    goals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有的喧嚣都是关于什么的呢？如果你已经阅读了Vaughn Vernon和Eric Evans关于这个主题的书籍，你可能对我们即将说的内容很熟悉，因为我们大量借鉴了他们的定义和解释。**领域驱动设计（DDD**），是一种帮助我们成功理解和构建软件模型设计的途径。它为我们提供了**战略**和**战术**建模工具，以帮助设计符合我们商业目标的优质软件。
- en: 'The main goal of this book is to show you PHP code examples of the Domain-Driven
    Design tactical patterns. If you want to learn more about the strategic patterns
    and the main Domain-Driven Design, you should read [Domain Driven Design Distilled](https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420)
    by *Vaughn Vernon* or [Domain-Driven Design Reference: Definitions and Pattern
    Summaries](https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-Summaries/dp/1457501198)
    by *Eric Evans*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标是向您展示领域驱动设计战术模式的PHP代码示例。如果您想了解更多关于战略模式和主要领域驱动设计的内容，您应该阅读*Vaughn Vernon*的[《领域驱动设计精粹》](https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420)或*Eric
    Evans*的[《领域驱动设计参考：定义和模式摘要》](https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-Summaries/dp/1457501198)。
- en: More importantly, *Domain-Driven Design is not about technology*. Instead, it's
    about developing knowledge around business and using technology to provide value.
    Only once you're capable of understanding the business your company works within
    will you be able to participate in the software model discovery process to produce
    a Ubiquitous Language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，**领域驱动设计不是关于技术的**。相反，它是关于围绕业务发展知识，并使用技术提供价值。只有当你能够理解公司所在业务时，你才能参与软件模型发现过程，以产生通用语言。
- en: Why Domain-Driven Design Matters
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么领域驱动设计很重要
- en: Software is not just about code. If you think about it, code is rarely the end
    goal of our profession. Code is just the medium to solve business problems. So
    why does it have to talk a different language? Domain-Driven Design emphasizes
    making sure businesses and software speak the same language. Once broken the barrier,
    there is no need for translations or tedious syncing, information doesn't get
    lost. Everyone contributes to discovering the Business Domain, not just coders.
    The resulting software is the only truth for the common language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 软件不仅仅是代码。如果你仔细想想，代码很少是我们职业的最终目标。代码只是解决商业问题的媒介。那么为什么它必须使用不同的语言呢？领域驱动设计强调确保商业和软件使用相同的语言。一旦打破了障碍，就无需翻译或繁琐的同步，信息不会丢失。每个人都在发现业务领域，而不仅仅是程序员。由此产生的软件是通用语言的唯一真理。
- en: Domain-Driven Design it also provides a framework for strategic and tactical
    design — strategic to pinpoint the most important areas to develop based on business
    value, and tactical to build a working Domain Model of battle-tested building
    blocks and patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计还提供了一个战略和战术设计的框架——战略的是基于商业价值确定最重要的开发领域，战术的是构建经过实战检验的构建块和模式的可工作的领域模型。
- en: The Three Pillars of Domain-Driven Design
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计的三个支柱
- en: 'Domain-Driven Design is an approach for delivering software, and it''s focused
    on three pillars:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计是一种交付软件的方法，它专注于三个支柱：
- en: '**Ubiquitous Language**: Domain Experts and software developers work together
    to build a common language for the business areas being developed. There''s no
    *us versus them*; it''s always *us*. Developing software is a business investment
    and not just a cost. The effort involved in building the Ubiquitous Language helps
    spread deep Domain insight among all team members.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通用语言**：领域专家和软件开发者一起为正在开发的业务领域构建一个共同的语言。没有“我们与他们”；总是“我们”。开发软件是一种商业投资，而不仅仅是成本。构建通用语言的努力有助于在所有团队成员中传播深入的领域洞察。'
- en: '**Strategic Design**: Domain-Driven Design addresses the strategy behind the
    direction of the business and not just the technical aspects. It helps define
    the internal relationships and early warning feedback systems. On the technical
    side, strategic design protects each business service by providing the motivation
    for how an service-oriented architecture should be achieved.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**战略设计**：领域驱动设计关注的是业务方向的策略，而不仅仅是技术方面。它有助于定义内部关系和早期预警反馈系统。在技术方面，战略设计通过提供如何实现面向服务的架构的动机来保护每个业务服务。'
- en: '**Tactical Design**: Domain-Driven Design provides the tools and the building
    blocks for iterative software deliverable. Tactical design tools produce software
    that is not only correct, but that is also testable and less error prone.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**战术设计**：领域驱动设计提供了迭代软件交付的工具和构建块。战术设计工具产生的软件不仅正确，而且可测试且错误率较低。'
- en: Ubiquitous Language
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用语言
- en: Along with  [Chapter 12](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml), *Integrating* *Bounded
    Contexts*, Ubiquitous Language is one of the main strengths of Domain-Driven Design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第12章[整合**边界上下文**]，**通用语言**是领域驱动设计的主要优势之一。
- en: In Terms of Context
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文方面
- en: For now, consider that a Bounded Context is a conceptual boundary around a system.
    The Ubiquitous Language inside a boundary has a specific contextual meaning. Concepts
    outside of this context can have different meanings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，考虑一个**边界上下文**是一个系统周围的概念边界。边界内的通用语言具有特定的上下文意义。此上下文之外的概念可以有不同的含义。
- en: 'So, how to find, explore and capture this very special language, the following
    pointers would highlight the same:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如何找到、探索和捕捉这种非常特殊的语言，以下要点将突出同样的事情：
- en: Identify key business processes, their inputs, and their outputs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别关键业务流程、它们的输入和输出
- en: Create a glossary of terms and definitions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建术语表和定义
- en: Capture important software concepts with some kind of documentation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用某种形式的文档捕捉重要的软件概念
- en: Share and expand upon the collected knowledge with the rest of the team (Developers
    and Domain Experts)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与团队中的其他成员（开发人员和领域专家）分享和扩展收集到的知识
- en: Since Domain-Driven Design was born, new techniques for improving the process
    of building the Ubiquitous Language have emerged. The most important one, which
    is used regularly now, is Event Storming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自从领域驱动设计诞生以来，出现了许多改进构建通用语言过程的技巧。其中最重要的一个，现在经常使用，就是事件风暴。
- en: Event Storming
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件风暴
- en: 'Alberto Brandolini explains Event Storming and its advantages in a [blog post](http://ziobrando.blogspot.com.es/2013/11/introducing-event-storming.html),
    and he does it far more succinctly than we could.Event Storming is a workshop
    format for quickly exploring complex business domains:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔贝托·布兰多利尼在一篇[博客文章](http://ziobrando.blogspot.com.es/2013/11/introducing-event-storming.html)中解释了事件风暴及其优势，他比我们更简洁地做了这件事。事件风暴是一种快速探索复杂业务领域的研讨会格式：
- en: 'It is **powerful**: It has allowed me and many practitioners to come up with
    a comprehensive model of a complete business flow in hours instead of weeks.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**强大的**：它使我以及许多从业者能够在数小时内而不是数周内构建出一个完整的业务流程的综合模型。
- en: 'It is **engaging**: The whole idea is to bring people with the questions and
    people who know the answer in the same room and to build a model together.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**吸引人的**：整个想法是将有疑问的人和知道答案的人放在同一个房间里，共同构建一个模型。
- en: 'It is **efficient**: The resulting model is perfectly aligned with a Domain-Driven
    Design implementation style (particularly fitting an Event Sourcing approach),
    and allows for a quick determination of Context and Aggregate boundaries.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**高效的**：生成的模型与领域驱动设计实现风格（尤其是适合事件源方法）完美对齐，并允许快速确定上下文和聚合边界。
- en: 'It is **easy**: The notation is ultra-simple. No complex UML that might cut
    off participants from the heart of the discussion.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**简单的**：符号非常简单。没有可能让参与者脱离讨论核心的复杂UML。
- en: 'It is **fun**: I always had a great time leading the workshops, people are
    energized and deliver more than they expected. The right questions arise, and
    the atmosphere is the right one.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**有趣的**：我总是很享受领导研讨会，人们充满活力，交付的成果超过了他们的预期。正确的问题出现了，气氛恰到好处。
- en: If you want to know more about Event Storming, check out Brandolini's book,
    [Introducing EventStorming](https://leanpub.com/introducing_eventstorming).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于事件风暴的信息，请查看布兰多利尼的书籍，[介绍事件风暴](https://leanpub.com/introducing_eventstorming)。
- en: Considering Domain-Driven Design
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑领域驱动设计
- en: Domain-Driven Design is not a silver bullet; as with everything in software,
    it depends on the context. As a rule of thumb, use it to simplify your Domain,
    but never to add more complexity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计不是万能的；就像软件中的所有事物一样，它取决于上下文。作为一个经验法则，使用它来简化你的领域，但永远不要增加更多的复杂性。
- en: If your application is data-centric and your use cases mainly manipulate rows
    in a database and perform CRUD operations — that is, Create, Read, Update, and
    Delete — you don't need Domain-Driven Design. Instead, the only thing your company
    needs is a fancy face in front of your database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序以数据为中心，你的用例主要是操作数据库中的行并执行CRUD操作——即创建、读取、更新和删除——那么你不需要领域驱动设计。相反，你的公司只需要在数据库前面有一个花哨的界面。
- en: If your application has less than 30 use cases, it might be simpler to use a
    framework like Symfony or Laravel to handle your business logic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序用例少于30个，使用像Symfony或Laravel这样的框架来处理业务逻辑可能更简单。
- en: However, if your application has more than 30 use cases, your system may be
    moving toward the dreaded [Big Ball of Mud](https://en.wikipedia.org/wiki/Big_ball_of_mud).
    If you know for sure your system will grow in complexity, you should consider
    using Domain-Driven Design to fight that complexity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的应用程序用例超过30个，你的系统可能正在走向令人恐惧的[大泥球](https://en.wikipedia.org/wiki/Big_ball_of_mud)。如果你确信你的系统将增长复杂性，你应该考虑使用领域驱动设计来对抗这种复杂性。
- en: If you know your application is going to grow and is likely to change often,
    Domain-Driven Design will definitely help in managing the complexity and refactoring
    your model over time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你的应用程序将会增长并且很可能会经常变化，领域驱动设计肯定有助于管理复杂性和随着时间的推移重构你的模型。
- en: If you don't understand the Domain you're working on because it's new and nobody
    has invested in a solution before, this might mean it's complex enough for you
    to start applying Domain-Driven Design. In this case, you'll need to work closely
    with Domain Experts to get the models right.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你因为该领域是新的，之前没有人投资解决方案，而对该领域不理解，这可能意味着它足够复杂，可以开始应用领域驱动设计。在这种情况下，你需要与领域专家紧密合作，以确保模型正确。
- en: The Tricky Parts
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 困难的部分
- en: Applying Domain-Driven Design is not easy. It requires time and effort to get
    around the Business Domain, terminology, research, and collaboration with Domain
    Experts rather than coding jargon. You'll need to have the commitment of Domain
    Experts for getting involved in the process too. This will requires an open and
    healthy continuous conversation to model their spoken language into software.
    On top of that, we'll have to make an effort to avoid thinking technically, to
    think seriously about the behavior of objects and the Ubiquitous Language first.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用领域驱动设计并不容易。它需要时间精力来理解业务领域、术语、研究和与领域专家的合作，而不是编码术语。你还需要领域专家的承诺来参与这个过程。这需要开放和健康的持续对话，将他们的口头语言转化为软件。此外，我们还需要努力避免技术思维，首先要认真思考对象的行为和通用语言。
- en: Strategical Overview
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略概述
- en: 'In order to provide a general overview of the strategical side of Domain-Driven
    Design, we''ll use an approach from *Jimmy Nilsson''s* book, [Applying Domain-Driven
    Design and Patterns](https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202).
    Consider two different spaces: the problem space and the solution space.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个关于领域驱动设计战略方面的概述，我们将使用来自*吉米·尼尔森*的书籍《应用领域驱动设计和模式》中的方法，[应用领域驱动设计和模式](https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202)。考虑两个不同的空间：问题空间和解决方案空间。
- en: In the problem space, Domain-Driven Design uses Domains and Subdomains to group
    and organize what companies want to solve. In the case of an **Online Travel Agency **(**OTA**),
    the problem is about dealing with things like flight tickets and booking hotels.
    Such a Domain can be organized into different Subdomains such as Pricing, Inventory,
    User Management, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题空间中，领域驱动设计使用领域和子领域来分组和组织公司想要解决的问题。以**在线旅行社**（**OTA**）为例，问题在于处理诸如机票和酒店预订等问题。这样的领域可以组织成不同的子领域，如定价、库存、用户管理等。
- en: 'In the solution space, Domain-Driven Design provides two patterns: Bounded
    Contexts and Context Maps. The goal is to define how to provide an implementation
    to all the identified Subdomains by defining their interactions and the details
    of those interactions. Continuing with the OTA example, each of the Subdomains
    will be solved with a Bounded Context implementation — for example, consider a
    custom Web Application developed by a team for the Pricing Management Subdomain,
    and an off-the-shelf solution for the User Management Subdomain. The Context Map
    will show how each Bounded Context is related to the rest. Inside the Context
    Map, we can see what type of relation two Bounded Contexts have (example: customer-supplier,
    partners). The ideal approach is to have each Subdomain implemented by one Bounded
    Context, but that''s not always possible. In terms of implementation, when following
    Domain-Driven Design, you''ll end up with distributed architectures. As you may
    already know, distributed architectures are more complex than monolithic ones,
    so why is this approach interesting, especially for big and complex companies?
    Is it really worth it? Well, it is.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案空间中，领域驱动设计提供了两种模式：边界上下文和上下文图。目标是定义如何通过定义它们的交互和交互的细节来为所有已识别的子域提供实现。继续使用OTA示例，每个子域都将通过边界上下文实现来解决——例如，考虑一个团队为定价管理子域开发的定制Web应用程序，以及为用户管理子域提供的现成解决方案。上下文图将显示每个边界上下文如何相互关联。在上下文图中，我们可以看到两个边界上下文之间有什么类型的关联（例如：客户-供应商，合作伙伴）。理想的方法是每个子域都由一个边界上下文实现，但这并不总是可能的。在实施方面，遵循领域驱动设计时，你最终会得到分布式架构。正如你可能已经知道的，分布式架构比单体架构更复杂，那么这种方法为什么有趣，尤其是对于大型和复杂公司？这真的值得吗？嗯，是的。
- en: Distributed architectures are proven to increase overall company productivity
    because they define boundaries for your product that can be developed by focused
    teams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式架构已被证明可以增加整体公司生产力，因为它们为你的产品定义了由专注的团队开发的边界。
- en: If your Domain — the problem you need to solve  — is not complex, applying the
    strategical part of Domain-Driven Design can add unnecessary overhead and slow
    down your development speed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的领域——你需要解决的问题——并不复杂，应用领域驱动设计的战略部分可能会增加不必要的开销并减慢你的开发速度。
- en: 'If you want to know more about the strategical part of Domain-Driven Design,
    you should take a look at the first three chapters of *Vaughn Vernon''s* book,
    [Implementing Domain-Driven Design](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon-ebook/dp/B00BCLEBN8),
    or the book [Domain-Driven Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215))
    by *Eric Evans*, both of which specifically focus on this aspect.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于领域驱动设计战略部分的信息，你应该看看*Vaughn Vernon*的书的头三章，[实施领域驱动设计](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon-ebook/dp/B00BCLEBN8)，或者*埃里克·埃文斯*的书籍[领域驱动设计：软件核心的复杂性处理](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)，这两本书都专门关注这个方面。
- en: 'Related Movements: Microservices and Self-Contained Systems'
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关运动：微服务和自包含系统
- en: 'There are other movements promoting architectures that follow the same principles
    Domain-Driven Design is promoting. Microservices and Self-Contained Systems are
    good examples of this. *James Lewis* and *Martin Fowler* define Microservices
    in the [Microservices Resource Guide](http://martinfowler.com/microservices/):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他运动推广遵循与领域驱动设计相同原则的架构。微服务和自包含系统是这方面的良好例子。*詹姆斯·刘易斯*和*马丁·福勒*在[微服务资源指南](http://martinfowler.com/microservices/)中定义了微服务：
- en: The Microservice architectural style is an approach to developing a single application
    as a suite of small services, each running in its own process and communicating
    with lightweight mechanisms, often an HTTP resource API. These services are built
    around business capabilities and are also independently deployable using fully
    automated machinery. There is a bare minimum of centralized management of these
    services, which may be written in different programming languages and also use
    different data storage technologies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格是一种将单个应用程序作为一系列小型服务开发的方法，每个服务都在自己的进程中运行，并通过轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务能力构建，并且可以使用完全自动化的机器独立部署。对这些服务的集中式管理最少，这些服务可能用不同的编程语言编写，也可能使用不同的数据存储技术。
- en: If you want to know more about Microservices, their guide is a good place to
    start.How is this related to Domain-Driven Design? As explained in *Sam Newman's*
    book, [Building Microservices](http://www.amazon.com/Building-Microservices-Sam-Newman/dp/1491950358),
    Microservices are implementations of Domain-Driven Design Bounded Contexts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于微服务的知识，他们的指南是一个很好的起点。这与领域驱动设计（Domain-Driven Design）有何关系？正如*山姆·纽曼*（Sam
    Newman）的书中所解释的，[构建微服务](http://www.amazon.com/Building-Microservices-Sam-Newman/dp/1491950358)，微服务是领域驱动设计边界上下文的实现。
- en: 'In addition to Microservices, another related movement is **Self-Contained
    Systems** (**SCS**). According to the [Self-Contained Systems](http://scs-architecture.org) website:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了微服务（Microservices）之外，另一个相关的运动是**自包含系统**（**SCS**）。根据[自包含系统](http://scs-architecture.org)网站：
- en: The Self-contained System approach is an architecture that focuses on a separation
    of the functionality into many independent systems, making the complete logical
    system a collaboration of many smaller software systems. This avoids the problem
    of large monoliths that grow constantly and eventually become unmaintainable.
    Over the past few years, we have seen its benefits in many mid-sized and large-scale
    projects. The idea is to break a large system apart into several smaller self-contained
    system, or SCSs, that follow certain rules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含系统（Self-contained System）方法是一种关注将功能分离成许多独立系统的架构，使完整的逻辑系统成为许多较小软件系统的协作。这避免了大型单体不断增长最终变得难以维护的问题。在过去的几年中，我们在许多中型和大型项目中看到了它的好处。这个想法是将一个大型系统分解成几个较小的自包含系统，或SCS，它们遵循某些规则。
- en: 'The website also spells out seven characteristics of SCS:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站还列出了SCS的七个特点：
- en: Each SCS is an autonomous web application. For the SCS's domain all data, the
    logic to process that data and all code to render the web interface is contained
    within the SCS. An SCS can fulfill its primary use cases on its own, without having
    to rely on other systems being available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SCS都是一个自主的Web应用程序。对于SCS的域，所有数据、处理这些数据的逻辑以及渲染Web界面的所有代码都包含在SCS内部。SCS可以独立完成其主要用例，无需依赖其他系统可用。
- en: Each SCS is owned by one team. This does not necessarily mean that only one
    team might change the code, but the owning team has the final say on what goes
    into the code base, for example by merging pull-requests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SCS由一个团队拥有。这并不一定意味着只有一支团队可能会更改代码，但拥有团队对代码库中包含的内容有最终决定权，例如通过合并pull-requests。
- en: 'Communication with other SCSs or 3rd party systems is asynchronous wherever
    possible. Specifically, other SCSs or external systems should not be accessed
    synchronously within the SCS''s own request/response cycle. This decouples the
    systems, reduces the effects of failure, and thus supports autonomy. The goal
    is decoupling concerning time: An SCS should work even if other SCSs are temporarily
    offline. This can be achieved even if the communication on the technical level
    is synchronous, example by replicating data or buffering requests.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他SCS或第三方系统的通信尽可能异步。具体来说，其他SCS或外部系统不应在SCS自己的请求/响应周期内同步访问。这解耦了系统，减少了故障的影响，从而支持了自主性。目标是关于时间解耦：即使其他SCS暂时离线，SCS也应能正常工作。即使技术层面的通信是同步的，例如通过复制数据或缓冲请求，这也是可以实现的。
- en: An SCS can have an optional service API. Because the SCS has its own web UI
    it can interact with the user — without going through a UI service. However, an
    API for mobile clients or for other SCSs might still be useful.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SCS可以有一个可选的服务API。因为SCS有自己的Web UI，它可以与用户交互——无需通过UI服务。然而，为移动客户端或其他SCS提供的API可能仍然有用。
- en: Each SCS must include data and logic. To really implement any meaningful features
    both are needed. An SCS should implement features by itself and must therefore
    include both.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SCS必须包含数据和逻辑。要真正实现任何有意义的特性，两者都是必需的。SCS应自行实现功能，因此必须包含两者。
- en: 'An SCS should make its features usable to end-users by its own UI. Therefore
    the SCS should have no shared UI with other SCSs. SCSs might still have links
    to each other. However, asynchronous integration means that the SCS should still
    work even if the UI of another SCS is not available. To avoid tight coupling an
    SCS should share no business code with other SCSs. It might be fine to create
    a pull-request for an SCS or use common libraries, example: database drivers or
    oAuth clients.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SCS应该通过其自己的UI使其功能对最终用户可用。因此，SCS不应与其他SCS共享任何UI。SCS之间可能仍然存在链接。然而，异步集成意味着即使另一个SCS的UI不可用，SCS仍然应该工作。为了避免紧密耦合，SCS不应与其他SCS共享任何业务代码。可能创建一个SCS的pull-request或使用公共库是可行的，例如数据库驱动程序或oAuth客户端。
- en: Exercise
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Discuss the pros and cons of such distributed architectures with your workmates.
    Think about using different languages, deployment processes, infrastructure responsibilities,
    and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的同事讨论这种分布式架构的优缺点。考虑使用不同的语言、部署流程、基础设施责任等等。
- en: Wrap-Up
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'During this chapter you''ve learned:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了：
- en: Domain-Driven Design is not about technology; it's actually about providing
    value in the field you're working in by focusing on the model. Everyone takes
    part in the process of discovering the Domain, and developers and Domain Experts
    team up to build the knowledge base by sharing the same language, the Ubiquitous
    Language.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计并非关于技术；实际上，它是通过关注模型，在您工作的领域提供价值。每个人都参与发现领域的过程，开发者和领域专家通过共享相同的语言，即通用语言，共同构建知识库。
- en: Domain-Driven Design provides tactical and strategic modeling tools to design
    high-quality software. Strategic design targets the business direction, helps
    in defining the internal relationships, and technically protects each business
    service by defining strong boundaries. Tactical design provides useful building
    blocks for iterative design.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计提供了战术和战略建模工具来设计高质量的软件。战略设计针对业务方向，有助于定义内部关系，并通过定义强大的边界在技术上保护每个业务服务。战术设计提供了迭代设计的有用构建块。
- en: Domain-Driven Design only makes sense in certain contexts. It's not a silver
    bullet for every problem in software, so whether or not you use it highly depends
    on the amount of complexity you're dealing with.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计仅在特定情境下才有意义。它并非解决软件中所有问题的万能钥匙，因此是否使用它高度取决于你处理复杂性的程度。
- en: Domain-Driven Design is a long-term investment; it requires active effort. Domain
    Experts will be required to collaborate closely with developers, and developers
    will have to think in terms of the business. In the end, the business customer
    is the one who has to be pleased.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计是一项长期投资；它需要积极的努力。领域专家需要与开发者紧密合作，开发者也必须从商业角度思考。最终，必须让业务客户满意。
- en: Implementing Domain-Driven Design requires effort. If it were easy, everybody
    would be writing high-quality code. Get ready, because you'll soon learn how to
    write code that, when read, will perfectly describe the business your company
    operates on. Enjoy this journey!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实施领域驱动设计需要努力。如果它很容易，那么每个人都会编写高质量的代码。准备好吧，因为你很快就会学到如何编写代码，当阅读时，它将完美地描述你公司运营的业务。享受这段旅程吧！
