- en: Chapter 8. Cooking Library Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 烹饪库插件
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a library plugin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建库插件
- en: Refining the plugin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精炼插件
- en: Configuring the plugin with PhpStorm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PhpStorm配置插件
- en: Code hinting for the plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件的代码提示
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Imagine a world where programmers such as you just enjoy writing code. That
    world seems enjoyable, perfect, and highly suitable for you in the first place.
    However, it isn't. What makes a programmer happier and satisfied more than anything
    in the world is the scenario in which the application reaches the end user. However,
    if programmers just enjoyed writing their code, who would ensure delivery of the
    code to the end user?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个世界，程序员就像你一样，只是喜欢编写代码。这个世界看起来很愉快，完美，首先非常适合你。然而，事实并非如此。在世界上，什么能让程序员比任何事情都更快乐和满足呢？那就是应用程序最终到达最终用户的情况。然而，如果程序员只是喜欢编写他们的代码，那么谁会确保代码被交付给最终用户呢？
- en: The end user can be anyone—a naive user, a professional user or even another
    programmer. So, regardless of the case, scenario, or end user, you, as a programmer,
    must be careful and concerned to make sure that whatever you code is (re)usable.
    Throughout your software-engineering life, you were told and you would be told
    not to reinvent the wheel. If you want this *dry* principle to be alive, you must
    make your code usable and reusable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户可以是任何人——一个新手用户、专业用户，甚至是另一个程序员。所以，无论在什么情况下，场景或最终用户，作为程序员的你都必须小心谨慎，确保你编写的代码是（可）重用的。在你的整个软件工程生涯中，你被告知过，你也会被告知不要重复造轮子。如果你想使这个*枯燥*的原则保持活力，你必须让你的代码可使用和可重用。
- en: Another use case! Suppose you are asked to develop an application programming
    interface (API) in PHP. So, your task at hand is to write code. But another (untold)
    task for you is to ensure that the code you write can be included with minimum
    hassle. One quick solution to achieve this feat is to wrap up your application
    in an archive such that the archive itself can be included wherever required.
    Kindly read again! You need to have a bundle-like entity that you can pass on
    to the testing team to validate and verify. A wise programmer would advise the
    use of Phing to build the files together. However, the catch in this situation
    is that Phing will do what you ask it to do. However, do you actually know what
    to do?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例！假设你被要求在PHP中开发一个应用程序编程接口（API）。所以你手头的任务是编写代码。但对你来说还有一个（未说出的）任务是确保你编写的代码可以以最小的麻烦被包含。实现这一壮举的一个快速解决方案是将你的应用程序打包成一个存档，这样存档本身就可以在任何需要的地方被包含。请再次阅读！你需要有一个类似捆绑包的实体，你可以将其传递给测试团队以验证和确认。一个明智的程序员会建议使用Phing来一起构建文件。然而，这种情况的难点在于Phing会做你要求它做的事情。然而，你真的知道你要做什么吗？
- en: You read it right that you need to create an archive. This time, we make use
    of a PHP archive, or phar, as they call it in the industry ([http://www.php.net/manual/en/book.phar.php](http://www.php.net/manual/en/book.phar.php)).
    Phar should not be alien to you. You must have used phar a number of times during
    your software engineering career. A PhpStorm cookbook author might have instructed
    you at some point in time as to how to get phar and include it in the PhpStorm
    library path. Can you recall how easy you used to find the task to have a PHP
    functionality in your project? If yes, it is the time to switch roles—from a phar
    user to a phar creator. If no, the time is ripe to learn how to create phars.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有看错，你需要创建一个存档。这次，我们使用PHP存档，或者叫phar，就像行业里称呼的那样（[http://www.php.net/manual/en/book.phar.php](http://www.php.net/manual/en/book.phar.php)）。Phar对你来说不应该陌生。在你的软件工程生涯中，你一定多次使用过phar。某个时候，一个PhpStorm食谱的作者可能指导过你如何获取phar并将其包含在PhpStorm库路径中。你能回忆起你曾经多么容易地找到在项目中添加PHP功能这个任务吗？如果可以，那么现在是时候转换角色了——从phar用户到phar创建者。如果不能，那么现在是学习如何创建phars的好时机。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Phar is an archive file created in PHP. Like other archives, phars also contain
    a number of files and directories. To be able to use phar in your application
    code, you just need to include or require phar in your code. That's it! Phar would
    behave as if you included (or required) a regular PHP class. You will be able
    to use the classes, corresponding methods, and member variables that are declared
    inside phar (of course, the access specifiers will be respected).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Phar是PHP创建的存档文件。和其他存档一样，phar也包含了许多文件和目录。为了能在你的应用程序代码中使用phar，你只需要在代码中包含或引入phar。就是这样！Phar会表现得就像你包含了（或引入了）一个普通的PHP类。你将能够使用在phar内部声明的类、对应的方法和成员变量（当然，会尊重访问限定符）。
- en: However, having PhpStorm at your disposal helps you a lot. You can also include
    phar in the include path for the project so that a particular project is able
    to use the functionality provided by phar. If you need to make the PHP functionality
    available to all projects across your development machine, consider adding phar
    to the global include path.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有PhpStorm可以帮助你很多。你还可以将phar包含在项目的包含路径中，以便特定项目能够使用phar提供的功能。如果你需要将PHP功能提供给开发机器上的所有项目，考虑将phar添加到全局包含路径。
- en: PHP programming has always been fun. However, since you are an experienced member
    of your team, it is highly encouraged that you love your work while still taking
    care of the utility of the work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PHP编程一直很有趣。然而，既然你是团队中的资深成员，强烈建议你在享受工作乐趣的同时，还要关注工作的实用性。
- en: Creating a library plugin
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库插件
- en: Have you ever thought about what makes up a library? A library is a collection
    of useful methods just as a book library is a collection of useful books. So is
    the case with an application library contains numerous useful methods and elements.
    The emphasis is on the word *useful* to stress the importance of not having redundant
    methods and elements in the library. A redundant piece of code requires documentation.
    When the company spends resources (essentially money), it will never want to have
    entities that have less usage. What is the reason for this? The principles of
    economics—the primary objective of any company is to maximize profit. No matter
    what!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过是什么构成了一个库？库就像一个图书库一样，是一个有用方法的集合。同样，应用程序库包含了许多有用的方法和元素。重点在于“有用”这个词，强调在库中不保留冗余的方法和元素的重要性。一段冗余的代码需要文档。当公司投入资源（本质上就是金钱）时，它永远不会希望拥有使用频率较低的实体。这是为什么？经济学的原则——任何公司的首要目标是最大化利润。无论如何！
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'However, not to worry, you do not need to be a Nobel Prize winner in Economics
    to stop putting redundant elements in the library. Just stay calm and stay wise.
    Cooking a plugin involves a number of engineering decisions to be made. Some of
    the decisions can be:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不必担心，你不需要成为经济学诺贝尔奖得主才能停止在库中添加冗余元素。只需保持冷静，保持明智。制作插件涉及许多工程决策。其中一些决策可以是：
- en: '**Decide what is that which makes you write a library**: You will not have
    the task of creating libraries too often. A library is a collection of a number
    of methods that you require a bit too often. So, to decide which methods are required,
    involves maturity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决定让你编写库的原因**：你不会经常有创建库的任务。库是一系列你经常需要的方法的集合。因此，决定哪些方法是必需的，需要一定的成熟度。'
- en: '**Plan in advance**: Since a library is something that is used again and again
    without much modification, you will not get to release versions very often. Since
    the versions are released once in a while, if an incorrect plan creeps in while
    creating the library, it will be discovered very late that you do not have a big
    margin for error.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前规划**：由于库是一种经常使用而很少修改的东西，你不会经常发布版本。由于版本发布得很少，如果在创建库的过程中出现了一个不正确的计划，那么你可能会很晚才发现你没有很大的错误空间。'
- en: '**Make/reuse decision**: You have to decide whether the required library can
    be built by reusing another''s or even your code that you created for another
    project in the past. Remember, you need to have a sharp memory for that. The other
    option to decide on is whether to create a library from scratch.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**制作/重用决策**：你必须决定所需的库是否可以通过重用他人的代码，甚至是你为过去的项目创建的代码来构建。记住，你需要对此有敏锐的记忆。另一个需要决定的选项是是否从头开始创建一个库。'
- en: So, in essence, all the rules are to facilitate the creation of *phar* containing
    PHP code. Get ready for the ride!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，所有规则都是为了方便创建包含PHP代码的*phar*。准备好享受这次旅程吧！
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Choose a directory containing the code you want to include for the plugin. Since
    you have been attempting to cook pizza, you can assume a use case where an end
    user needs an algorithm to cook pizza. There, you have the requirements!
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个包含你想要包含在插件中的代码的目录。既然你一直在尝试制作披萨，你可以假设一个用例，即最终用户需要一个制作披萨的算法。在那里，你有需求！
- en: Create a directory with the name `src`, which will contain the source PHP scripts.
    This will serve as the source for the library.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src`的目录，其中将包含源PHP脚本。这将是库的源。
- en: Create a directory with the name `build`, which will contain the target library,
    as shown in the following screenshot. This is the library you were longing for.![How
    to do it…](img/3878OT_08_00.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`build`的目录，它将包含目标库，如下面的截图所示。这就是你一直渴望的库。![如何操作…](img/3878OT_08_00.jpg)
- en: There is a change that you need to make inside the `php.ini` file. To find out
    which `php.ini` your system uses, you can type `php-ini` inside PhpStorm (do you
    remember the command window available by the keyboard shortcut *Ctrl* + *Shift*
    + *X*). You need to add the line `phar.readonly=0` to enable creating phars with
    PHP.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要在`php.ini`文件中进行一些更改。要找出你的系统使用哪个`php.ini`，你可以在PhpStorm中输入`php-ini`（你还记得可以通过键盘快捷键*Ctrl*
    + *Shift* + *X*访问的命令窗口吗？）。你需要添加行`phar.readonly=0`以启用使用PHP创建phar。
- en: You will need to define an entry point for the library. What's the reason for
    this? This is the way phars behave. There has to be an `index.php` file by default.
    You need to put it at the top level in the `src` (or sources) directory. At the
    minimum, it needs to include a file that will provide access to the required class
    in the library (of course, you can change the name of `index.php` to another `file.php`
    and make it act as the entry point).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要为库定义一个入口点。为什么需要这样做？这是phar的行为方式。默认情况下必须有一个`index.php`文件。你需要将它放在`src`（或源）目录的顶层。至少，它需要包含一个文件，该文件将提供对库中所需类的访问（当然，你可以将`index.php`的名称更改为另一个`file.php`，并使其作为入口点）。
- en: 'In the current scenario, you need to include the file `PizzaDish.php` so that
    you are able to cook pizza again—this time by the library. So, considering PHP
    code, you will write something like the following:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在当前场景中，你需要包含`PizzaDish.php`文件，这样你才能再次制作披萨——这次是通过库。所以，考虑到PHP代码，你将编写如下内容：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since phar is a PHP functionality, you need to write code to create a phar
    package. You will write something like the following:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于phar是PHP功能，你需要编写代码来创建phar包。你将编写如下内容：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With that done, you can sit back and feel happy having created a new plugin
    that you can easily pass on to the testing and the quality assurance teams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可以坐下来，感到高兴，因为你已经创建了一个新的插件，你可以轻松地将其传递给测试和质量保证团队。
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It's time for the nuts and bolts and grease and dirty workshop clothes!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候准备螺丝钉、润滑油和油腻的工作服了！
- en: 'You can see that you did nothing extraordinary: you just wrote very simple
    and native PHP code to generate an archive that will be available to be used as
    a plugin. You created directories to contain the source files and the build file(s)
    separately. This step was not a mandatory step, but it ensured that your working
    area remained clean.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你并没有做什么特别的事情：你只是写了一些非常简单和自然的PHP代码来生成一个可以作为插件使用的存档。你创建了目录来分别存放源文件和构建文件。这一步不是强制性的，但它确保了你的工作区域保持整洁。
- en: 'The `index.php` file serves as the entry point for phar. Thus, when you include
    a functionality, you need to involve the reference to that functionality. This
    is what you do when you *include* `PizzaDish.php`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.php`文件作为phar的入口点。因此，当你包含一个功能时，你需要涉及对该功能的引用。这就是你*包含*`PizzaDish.php`时所做的：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you write this, you are initializing the phar-creating facility, which
    takes in the name of the expected plugin (the first argument), flags to pass to
    the parent class `RecursiveDirectoryIterator` (the second argument), and the name
    of the archive that will serve as its calling name. Thus, you will create a library
    that will have the filename `pizza.phar` and will be known as `pizza.phar` when
    you access it through the `phar://` stream.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写这段代码时，你正在初始化创建phar的功能，它接受预期插件的名称（第一个参数），传递给父类`RecursiveDirectoryIterator`的标志（第二个参数），以及将作为其调用名称的存档名称。因此，你将创建一个库，其文件名为`pizza.phar`，当你通过`phar://`流访问时，它将被称为`pizza.phar`。
- en: You need to start buffering to initiate the process of creating the archive.
    Buffering is the process of writing to the disk until the time the buffering is
    stopped. It is done by `$phar->startBuffering();`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要开始缓冲以启动创建存档的过程。缓冲是将数据写入磁盘直到缓冲停止的过程。这是通过`$phar->startBuffering();`来完成的。
- en: 'The source files inside a directory are included in the plugin that you created
    when you write the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写以下代码时，目录内的源文件被包含在你创建的插件中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The process of including files to the archive continues until you stop the buffering
    of the output. You need to stop buffering to finish the process of writing the
    changes to disk. The archive that you wrote will not be visible until you stop
    buffering. This is done by `$phar->stopBuffering();`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件包含到存档中的过程会一直持续到你停止输出缓冲。你需要停止缓冲以完成将更改写入磁盘的过程。你编写的存档在你停止缓冲之前是不可见的。这是通过`$phar->stopBuffering();`完成的。
- en: Once you stop the buffering of the output, the output (which was the archive
    file) will be displayed to you. How? In the form of the archive itself! Simple,
    isn't it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你停止输出缓冲，输出（即存档文件）将显示给你。如何？以存档本身的形式！简单，不是吗？
- en: Refining the plugin
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的精炼
- en: Having a plugin by your side definitely encourages you. However, this encouragement
    can lead to some dire consequences if the software engineering principles are
    not applied to the plugin at hand. The plugin at hand can then lead you to become
    an engineer at bay!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 旁边有一个插件确实会鼓励你。然而，如果不对手头的插件应用软件工程原则，这种鼓励可能会导致一些严重的后果。这可能会让你成为一个退居二线的工程师！
- en: Software engineering is the entity that does not let you forget it easily in
    whatever you do. You need to validate that the product you created (here, the
    plugin) is working correctly. Now, this *correctly* has a very broad meaning.
    Simply put, you just need to check that the plugin you created performs the intended
    action. Another aspect is verification. Having checked the intended actions, you
    need to check whether the action performed is correct or not. This is especially
    useful because the actual testing is done on the plugin according to this phenomenon.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程是你在做任何事情时都不容易忘记的实体。你需要验证你创建的产品（这里，插件）是否工作正常。现在，这个“正确”有一个非常广泛的意义。简单来说，你只需要检查你创建的插件是否执行了预期的操作。另一方面是验证。在检查了预期的操作后，你需要检查执行的操作是否正确。这一点特别有用，因为实际的测试是根据这一现象在插件上进行的。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You need to take two actions. Both are mandatory. The first is the validation
    part. You need to validate if the pizza-cooking plugin works or not. To do that,
    you need to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要采取两个动作。两者都是强制性的。第一个是验证部分。你需要验证披萨烹饪插件是否工作。为此，你需要：
- en: Create a new PHP file.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的PHP文件。
- en: Include (or require) the plugin you created in it.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中包含（或要求）你创建的插件。
- en: Run this file, as shown in the following screenshot.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示运行此文件。
- en: If the run process gets completed as shown, it means your pizza is being cooked.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果运行过程如所示完成，这意味着你的披萨正在被烹饪。
- en: '![How to do it…](img/3878OT_08_01.jpg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/3878OT_08_01.jpg)'
- en: 'Now comes the verification part. You might need to verify that the dish you
    are cooking is actually pizza, else you might end up destroying your taste buds.
    To verify this is rather a vague sequence of steps, and it is not impossible to
    have different versions. The steps can be:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是验证部分。你可能需要验证你正在烹饪的实际上是披萨，否则你可能会破坏你的味蕾。为了验证这一点，这是一个相当模糊的步骤序列，并且可能会有不同的版本。步骤可以是：
- en: Check whether the classes in the plugin are accessible freely. You will need
    to create a new instance of the object. Thus, something like `$pizza = new PizzaDish('Mushroom',
    'Dish')` should not produce an error. You should be able to use the object and
    the members in some external class in just the same way as you use a locally created
    class. Also, something like `echo $pizza->getDishName()` should not create an
    error about the unavailability of this function and should perform the intended
    activity correctly.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查插件中的类是否可以自由访问。你需要创建对象的新实例。因此，像`$pizza = new PizzaDish('Mushroom', 'Dish')`这样的操作不应该产生错误。你应该能够像使用本地创建的类一样使用该对象和外部类中的成员。同样，像`echo
    $pizza->getDishName()`这样的操作不应该创建关于此函数不可用的错误，并且应该正确执行预期的活动。
- en: 'If a problem occurs in the plugin that you think is not in accordance with
    business requirements, you need to (obviously) fix it (quickly). So, you might
    need to again follow a few steps:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果插件中出现了你认为不符合业务要求的问题，你需要（显然）快速修复它。所以，你可能需要再次遵循几个步骤：
- en: In the `src` directory, locate the file (here `PizzaDish.php`).
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录中，找到文件（这里`PizzaDish.php`）。
- en: Identify the error-creating (or misbehaving) line(s).
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别创建错误（或行为不当）的行。
- en: Make the appropriate changes.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行适当的更改。
- en: Create phar afresh with the changed source code. You might want to revisit the
    *Creating a library plugin* recipe.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用更改后的源代码重新创建phar。你可能想回顾一下“创建库插件”的配方。
- en: Repeat steps 1-3 until the plugin starts behaving in the way it was expected
    to behave.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1-3，直到插件开始以预期的行为运行。
- en: Whatever you do, you just need to have a refined version of the plugin.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，你只需要有一个插件的精炼版本。
- en: How it works…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working of the validation process is quite straightforward to understand.
    The validation of a product checks whether the plugin that you created is actually
    working as a plugin. Thus, you check for possible errors and problems in the process
    of using the plugin as a system. This is like saying, "Dude, check whether the
    plugin is working". Can you imagine who says this? A programmer says this to his
    fellow programmer!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 验证过程的工作原理相当直观易懂。产品的验证检查你创建的插件是否实际上作为一个插件在工作。因此，你检查在作为系统使用插件的过程中可能出现的错误和问题。这就像说，“伙计，检查一下插件是否在工作”。你能想象是谁说的吗？是一个程序员对他的同行程序员说的！
- en: The verification process needs to be understood. When you create a plugin, you
    don't know which agent will use it—it could be a command-line user, an IDE, or
    another bigger plugin. So, you need to ensure that the plugin you wrote is usable.
    Thus, when you create a new object, you check whether the classes that you intended
    to provide in the plugin are present. When you call a method, you check whether
    the method defined inside the plugin is accessible, and that too, no improper
    access specifier is restricting you from using the method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 验证过程需要理解。当你创建一个插件时，你不知道哪个代理会使用它——它可能是一个命令行用户、一个IDE或另一个更大的插件。因此，你需要确保你编写的插件是可用的。因此，当你创建一个新的对象时，你检查你打算在插件中提供的类是否存在。当你调用一个方法时，你检查插件内部定义的方法是否可访问，而且，没有不适当的访问修饰符限制你使用该方法。
- en: The process of verification of the plugin is rather cyclic. Since it is your
    responsibility to ensure a proper functioning plugin, you need to repeat the verification
    steps until the quality assurance team is fully satisfied with the plugin. In
    the process, if you detect errors, you would have to go back to the source code
    to fix the problems and rebuild the entire plugin again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的验证过程相当循环。由于确保插件正常工作是你的责任，你需要重复验证步骤，直到质量保证团队对插件完全满意。在这个过程中，如果你发现错误，你将不得不回到源代码中修复问题，并重新构建整个插件。
- en: So, the process continues for you. You write code. The code gets tested. You
    correct code. The code gets tested. The code gets tested. You create a plugin.
    The plugin gets tested. You go back to the correct code, and the process continues
    from that point. Cyclic, isn't it?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个过程对你来说继续进行。你编写代码。代码被测试。你修正代码。代码被测试。代码被测试。你创建一个插件。插件被测试。你回到正确的代码，并从那个点继续这个过程。循环，不是吗？
- en: Configuring the plugin with PhpStorm
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PhpStorm配置插件
- en: When it comes to saying that there is a plugin, it is to be assumed that there
    has to be a user of that plugin. Since you are a PhpStorm lover, you can safely
    assume that PhpStorm can be (one of the) possible users of the plugin. So, you
    need to act as a pseudo recipient of the library plugin and make an attempt to
    use the library. By configuring, it is to be understood as making the necessary
    adjustments in the project structure so that the library can be used to add functionality
    to the project. The age-old practice of reusability is at work, you see.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当说到有一个插件时，可以假设必须有一个使用该插件的用户。既然你是PhpStorm的爱好者，你可以安全地假设PhpStorm可以是（其中之一）可能的插件用户。因此，你需要充当库插件的伪接收者并尝试使用库。通过配置，可以理解为在项目结构中进行必要的调整，以便可以使用库来为项目添加功能。你看到了，这是可重用性的古老实践在发挥作用。
- en: The main advantage that is associated with a library plugin is the ease of inclusion
    in a project. You just have to make use of this advantage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与库插件相关的主要优势是将其包含到项目中的便利性。你只需利用这个优势。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To configure the plugin with PhpStorm, the steps to be followed are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PhpStorm配置插件，需要遵循以下步骤：
- en: Obtain phar from whichever source you wish.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你想要的任何来源获取phar。
- en: Create a directory inside your project with a proper and descriptive name.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个具有适当且描述性的目录。
- en: The plugin can be used very easily via `require(_once) 'phar://name-of-phar.phar';`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过`require(_once) 'phar://name-of-phar.phar';`非常容易地使用插件。
- en: All done! So simple—quite unlike what it appeared to be. This is the power of
    PHP unleashed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！如此简单——完全不像它看起来那样。这是PHP释放的力量。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: However, if you think that you want to do more with the library and are more
    interested in doing development by tinkering with the internal classes and/or
    packages, you might need to select certain classes in particular. This is done
    as `require_once 'phar://pizza.phar/Dish.php';`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你认为你想用这个库做更多的事情，并且对通过调整内部类和/或包进行开发更感兴趣，你可能需要特别选择某些类。这是通过`require_once 'phar://pizza.phar/Dish.php';`来完成的。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The creation of a directory to hold the library plugin is not rocket science.
    It just facilitates obeying software engineering conventions. You as a developer
    or the plugin user is being referenced here. Thus, when you create a new directory,
    the code base of the project you are working on remains compartmentalised. So,
    when you need to change this library, you know where you have to go. Also, when
    you need to delete this library from your code base, you know where you have to
    go. If you are asked a question as to when you need to add a similar functioning
    library or some dependency, do you know where to go?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录来存放库插件并不是什么高深的技术。这只是为了方便遵守软件工程规范。这里提到的开发者或插件用户。因此，当你创建一个新的目录时，你正在工作的项目的代码库保持模块化。所以，当你需要更改这个库时，你知道该去哪里。同样，当你需要从代码库中删除这个库时，你也知道该去哪里。如果你被问到何时需要添加一个具有类似功能的库或某些依赖项，你知道去哪里吗？
- en: 'The way you use the library is dependent on the scenario. Recall that the library
    plugin contains two files: `PizzaDish.php` and `Dish.php`. If you want to use
    the basic functionality—cook pizza by adding some simple toppings and ingredients—requiring
    phar as a whole will serve the purpose. If you want selected functionality, specifying
    the name of the file relative to phar (inside phar) serves the purpose.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用库的方式取决于场景。回想一下，库插件包含两个文件：`PizzaDish.php`和`Dish.php`。如果你想使用基本功能——通过添加一些简单的配料和食材来烤披萨——整个phar的使用就足够了。如果你想使用特定的功能，指定相对于phar（在phar内部）的文件名就足够了。
- en: Since phar is said to behave in the same way as a PHP file does, when you included
    phar, the hinting also starts. Thus, when you write `phar://pizza.phar/` and press
    *Ctrl* + *Space*, there is a list of all the files contained inside phar shown
    to you. You can select one from the list in just the same way you used to do for
    regular PHP files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于phar据说表现得和PHP文件一样，当你包含phar时，提示也开始。因此，当你写下`phar://pizza.phar/`并按下*Ctrl* + *Space*时，会显示给你一个包含在phar内部的所有文件的列表。你可以像使用常规PHP文件一样从列表中选择一个。
- en: Code hinting for the plugin
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的代码提示
- en: Here comes the actual utility of using an IDE for the plugin you created. It
    is a very common article of faith among developers that IDEs provide the autocompletion
    feature no matter what. However, at the same time, it is very uncommon amongst
    the same set of developers to know exactly how it is possible that the IDE provides
    autocompletion. Grandma always used to say *Ignorance never pays*. Exactly! Ignorance
    never pays (pun intended).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你创建的插件的IDE的实际效用现在显现出来了。开发者们普遍相信，IDE无论在什么情况下都能提供自动补全功能。然而，在同一群开发者中，知道IDE如何提供自动补全功能的人却非常罕见。奶奶总是说“无知无回报”。没错！无知无回报（言外之意）。
- en: A question could be popping up in your mind. Why on the earth do you need to
    use the **autocomplete** feature? The answer to this might not be a diplomatic
    one, but it is true. In most cases, developers are ignorant enough not to write
    documentation for their code. Thus, autocompletion and / or code hinting serve
    as the saviors for the users of the code you provided. Since you are a programmer
    yourself, you can very easily understand the ease of using the code-hinting feature.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一个疑问出现在你的脑海中。为什么你需要使用**自动补全**功能呢？这个答案可能不是外交辞令，但它是真实的。在大多数情况下，开发者们足够无知，以至于不会为他们的代码编写文档。因此，自动补全和/或代码提示成为了你提供的代码用户的救星。既然你自己也是程序员，你很容易就能理解使用代码提示功能的便捷性。
- en: In the current context, you need to have similar settings so that PhpStorm is
    able to show you the documentation, method usage, and necessary information that
    is essential for a potential plugin user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前上下文中，你需要有类似的设置，这样PhpStorm才能显示文档、方法使用和对于潜在的插件用户来说是必要的信息。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Enabling code hinting for a plugin is a one-liner. If you really want to configure
    code hinting for PhpStorm, you need to update the include path that PhpStorm respects.
    Updating the include path is done by opening the Project view and adding the location
    of phar to the list of libraries for the project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为插件启用代码提示是一个单行操作。如果你真的想为PhpStorm配置代码提示，你需要更新PhpStorm尊重的包含路径。更新包含路径是通过打开项目视图并将phar的位置添加到项目的库列表中完成的。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The steps are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Select the Project view (*Alt* + *1*).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目视图（*Alt* + *1*）。
- en: Find the `External Libraries` directory.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`外部库`目录。
- en: Press *F4*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F4*。
- en: Provide the location of the directory where you have the plugin located.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供插件所在目录的位置。
- en: Click on **Apply** and press **OK**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**并按**确定**。
- en: Done! Take a deep breath and press *Ctrl* + *Space* whenever you need code-hinting
    activation for this plugin. PhpStorm is again at your disposal!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！深呼吸，并在需要为此插件激活代码提示时按*Ctrl* + *Space*。PhpStorm再次为你服务！
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: PhpStorm makes a lookup in the include paths that are available for the project
    and provides the list of classes and methods available in the current context.
    The system-wide include paths (`/usr/share/php`, `/usr/share/pear`, and so on.)
    are also looked up. Thus, when you add the phar to the include path, PhpStorm
    gets an additional path to look up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm会在项目可用的包含路径中进行查找，并提供当前上下文中可用的类和方法列表。系统范围内的包含路径（`/usr/share/php`，`/usr/share/pear`等）也会被查找。因此，当你将phar添加到包含路径时，PhpStorm会得到一个额外的查找路径。
- en: So, the methods and classes available in phar (which you included in `index.php`)
    become available for code hinting. The code-hinting process covers the documentation,
    member methods, member variables, and every other thing that you designed to be
    available for use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在phar中可用的方法和类（你在`index.php`中包含的）将可用于代码提示。代码提示过程涵盖了文档、成员方法、成员变量以及你设计为可用的任何其他内容。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that when you add the library plugin to the include path,
    you start getting hints in just the same way as other methods available in the
    classes and libraries declared in the include path, but there is a difference
    to be noted. When you add the library location in the include path, PhpStorm is
    able to provide you with *only* the code hints. If you want to use the methods,
    you will not be able to do that. Another aspect is that when you need to use the
    plugin, and you `require` (`_once`) it, the code hinting is available then too,
    but this time *only* to the current script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当你将库插件添加到包含路径中时，你将以与其他在包含路径中声明的类和库中可用的方法相同的方式开始获得提示，但有一个需要注意的区别。当你将库位置添加到包含路径中时，PhpStorm能够为你提供**仅**代码提示。如果你想使用方法，你将无法做到。另一方面，当你需要使用插件，并且你`require`（`_once`）它时，代码提示也是可用的，但这次**仅**对当前脚本有效。
- en: What is the difference, then? The difference is in the usage and availability
    of the plugin and its methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，区别在哪里呢？区别在于插件及其方法的使用和可用性。
- en: To sum it up, if you wish to use the plugin, you need to use `include(_once)`
    or `require(_once)`, and when you need the code hinting to be available across
    the project, you need to add the location of the plugin to the PhpStorm include
    path.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果你想使用插件，你需要使用`include(_once)`或`require(_once)`，并且当你需要代码提示在整个项目中可用时，你需要将插件的位置添加到PhpStorm的包含路径中。
