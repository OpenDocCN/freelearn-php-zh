- en: '[*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097): Diving into
    Liquid Core with Filters'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第五章*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097): 深入了解带有过滤器的Liquid核心'
- en: In the previous two chapters, we learned about all the different Liquid tags
    and objects, and now, we will be focusing on the last of the Liquid Core features,
    which is `|`, through which we can manipulate different data types, including
    strings, numbers, variables, or even objects, making it a compelling feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了所有的不同Liquid标签和对象，现在，我们将关注Liquid核心功能的最后一部分，即 `|`，通过它可以操作不同的数据类型，包括字符串、数字、变量，甚至是对象，使其成为一个引人注目的功能。
- en: 'We can split the chapter into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将本章分为以下主题：
- en: HTML and URL filters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML和URL过滤器
- en: Enhancing the product media gallery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化产品媒体库
- en: Building product accordions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建产品折叠面板
- en: Math and money filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学和货币过滤器
- en: Exploring the additional filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索附加过滤器
- en: By the time we complete this chapter, we will precisely understand how much
    power filters provide us. Similarly, as with the previous chapter, instead of
    simply listing and going through all of the filters, we will only explain some
    essential filters through a series of small projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们完成这一章的时候，我们将精确地了解过滤器为我们提供了多少力量。同样地，就像上一章一样，我们不会简单地列出并逐一解释所有过滤器，而是通过一系列小项目来解释一些基本过滤器。
- en: First, we will learn about generating HTML elements through **HTML and URL filters**.
    Second, understanding **media filters** will help us with the product media gallery,
    one of Shopify's latest additions and one of the most sought-after features. Third,
    by working on the product accordions project, we will learn how to manipulate
    the string and array types of data through their respective filters. Lastly, working
    on a product price discount project will provide us with the necessary knowledge
    of **math and money filters**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何通过 **HTML和URL过滤器** 生成HTML元素。其次，理解 **媒体过滤器** 将帮助我们处理产品媒体库，这是Shopify的最新功能之一，也是最受欢迎的功能之一。第三，通过在产品折叠面板项目中工作，我们将学习如何通过各自的过滤器操作字符串和数组类型的数据。最后，通过在产品价格折扣项目中工作，我们将获得必要的
    **数学和货币过滤器** 知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While we will explain each topic and present it with accompanying screenshots,
    you will need an internet connection to follow the steps outlined in this chapter,
    considering that Shopify is a hosted service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将解释每个主题并附上相应的截图，但考虑到Shopify是一个托管服务，你需要一个互联网连接来跟随本章中概述的步骤。
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05)。
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3zmum4j](https://bit.ly/3zmum4j)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可在此处找到：[https://bit.ly/3zmum4j](https://bit.ly/3zmum4j)
- en: Working with HTML and URL filters
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML和URL过滤器
- en: 'In the previous chapter, we had the chance to see a type of URL filter when
    we worked on outputting the product images, `{{ image | img_url: "400x400" }}`.
    *However, what exactly are URL filters?*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，当我们处理输出产品图片时，有机会看到一种URL过滤器，`{{ image | img_url: "400x400" }}`。*然而，URL过滤器究竟是什么？*'
- en: '`image` tag, inside which we can add the string path to a specific asset as
    the `href` attribute. Alternatively, we can combine URL filters with **HTML filters**
    to automatically generate the necessary HTML element with the necessary attributes.
    Let''s see them in action now.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` 标签，在其中我们可以添加特定资产的字符串路径作为 `href` 属性。或者，我们可以将URL过滤器与 **HTML过滤器** 结合起来，自动生成必要的HTML元素及其属性。现在让我们看看它们在实际中的应用。'
- en: 'In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Shopify*, we learned about the `Assets` directory inside our theme
    files and how it contains all of the internal assets that our theme requires,
    such as stylesheets, JavaScript files, font files, and images. However, we will
    first need to load these files within our theme, by following the next steps,
    since they will not automatically be accessible to us by simply uploading them
    within the `Assets` directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015) *Shopify入门*中，我们学习了主题文件中的`Assets`目录以及它包含我们主题所需的所有内部资产，例如样式表、JavaScript文件、字体文件和图像。然而，我们首先需要在主题中加载这些文件，按照以下步骤进行，因为它们不会自动在我们将它们上传到`Assets`目录后对我们可用：
- en: 'We can retrieve the path to a file within the `Assets` directory by encapsulating
    the file''s name within quotation marks, followed by a pipeline, followed by the
    `asset_url` filter:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将文件名用引号括起来，然后跟一个管道符号，再跟`asset_url`过滤器，来检索`Assets`目录中文件的路径：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous example, we have used the name of the stylesheet file within
    our store in combination with `asset_url`, which will provide us with the string
    path toward this specific file: [https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449](https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用了存储中样式表文件的名称，结合`asset_url`，这将为我们提供指向此特定文件的字符串路径：[https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449](https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449)
- en: 'Now that we have recovered the path toward our location, as previously mentioned,
    we have two choices. The first option is to use an HTML `link` tag to link the
    CSS file with our theme:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了指向我们位置的路由，正如之前提到的，我们有两种选择。第一种选择是使用HTML `link` 标签将CSS文件与我们的主题链接：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <link rel="stylesheet" href="//cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449">
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<link rel="stylesheet" href="//cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449">`'
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, as we have previously mentioned, besides using the HTML `link` tag,
    we can also combine URL filters with an HTML filter to generate the necessary
    HTML attributes:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，正如我们之前提到的，除了使用HTML `link` 标签外，我们还可以将URL过滤器与HTML过滤器结合使用，以生成必要的HTML属性：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous example, we used the asset name whose path we are looking to
    recover, followed by the `asset_url` filter, which would usually only return the
    string path. However, pairing it with `stylesheet_tag` will automatically generate
    the HTML `link` tag with all the necessary attributes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用了想要恢复路径的资产名称，然后跟`asset_url`过滤器，它通常会只返回字符串路径。然而，与`stylesheet_tag`结合使用时，它将自动生成带有所有必要属性的HTML
    `link` 标签：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Besides being a lot cleaner, the main difference between the two approaches
    is that `stylesheet_tag` does not accept additional parameters. So, for example,
    if we were looking to change the `rel` attribute to preload, modify the `media`
    attribute, or even include the `defer` attribute, we would have to use the first
    approach and include the asset file using the HTML `link` tag.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更简洁之外，这两种方法的主要区别在于`stylesheet_tag` 不接受额外的参数。例如，如果我们想将`rel`属性更改为preload，修改`media`属性，或者甚至包括`defer`属性，我们就必须使用第一种方法，并使用HTML
    `link` 标签包含资产文件。
- en: We have now learned how to connect our theme file with the necessary stylesheet.
    However, note that we will be using a different type of HTML filter depending
    on which file we are looking to access.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何将我们的主题文件与必要的样式表连接起来。然而，请注意，我们将根据我们想要访问的文件类型使用不同类型的HTML过滤器。
- en: 'For example, if we were looking to output the content of the `theme.js` file
    into our theme, we would use a similar approach, the theme filename followed by
    `asset_url` to get its path, but instead of using `stylesheet_tag`, we will use
    `script_tag`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将`theme.js`文件的内容输出到我们的主题中，我们会使用类似的方法，主题文件名后跟`asset_url`以获取其路径，但我们将使用`script_tag`而不是`stylesheet_tag`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `script_tag`, we will automatically generate and include the HTML `script`
    tag in our theme. However, do note that similarly as with `stylesheet_tag`, `script_tag`
    also does not accept any parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`script_tag`，我们将自动生成并包含我们的主题中的HTML `script` 标签。然而，请注意，与`stylesheet_tag`类似，`script_tag`也不接受任何参数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Besides `stylesheet_tag` and `script_tag`, we also have access to `img_tag`.
    Accessing an image file within the assets can be done using the name of the image
    file, followed by `asset_url`, followed by `img_tag`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `stylesheet_tag` 和 `script_tag` 之外，我们还可以访问 `img_tag`。使用 `asset_url` 后跟图像文件名，然后是
    `img_tag`，可以在资产内访问图像文件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The crucial difference between `img_tag` and the previous two filters is that
    `img_tag` does accept additional parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`img_tag` 与前两个过滤器之间的关键区别在于 `img_tag` 接受额外的参数。'
- en: 'In [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving into
    Liquid Core with Objects*, we had the chance to see the `img_url` filter in action
    by using it to return the product image URL string, which we combined with the
    HTML `img` tag to output the product image to our storefront:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)“使用对象深入液态核心”，我们有机会通过使用它来返回产品图像URL字符串，并将其与HTML
    `img` 标签结合，将产品图像输出到我们的店面，来看到 `img_url` 过滤器的实际应用：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that besides the `img_url` filter, we have also used the `size` parameter
    to set the limit size of our image, which is one of the three parameters that
    we can use with the `img_url` and `img_tag` filters. However, note that both types
    of filters use different parameters, which we will explain shortly through the
    following mini project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了 `img_url` 过滤器外，我们还使用了 `size` 参数来设置图像的限制大小，这是我们可以在 `img_url` 和 `img_tag`
    过滤器中使用的三种参数之一。然而，请注意，这两种类型的过滤器使用不同的参数，我们将在以下迷你项目中简要解释。
- en: Building a product gallery
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建产品展示库
- en: 'Inside this mini project, we will learn how to output the necessary elements
    for the product gallery:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迷你项目中，我们将学习如何输出产品展示库所需的所有元素：
- en: Let's start by creating a new page named `Product Gallery` and a new page template
    named `product-gallery`, which we will assign to the previously created page.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `Product Gallery` 的新页面和一个名为 `product-gallery` 的新页面模板开始，我们将将其分配给之前创建的页面。
- en: Once we have created the page and assigned the appropriate template, we should
    identify one product with more than one image and recover its handle. We will
    use gardening gloves for our selection, which is one of the products that we previously
    imported from the `product-data.csv` file in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*. We can retrieve the product handle by previewing
    the product page and copying the page handle from the page URL. Alternatively,
    we can retrieve it by navigating to the product page inside the admin section
    and copying the page handle from the page URL link at the bottom of the page.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了页面并分配了适当的模板，我们应该确定一个具有多个图像的产品，并恢复其处理程序。我们将选择园艺手套，这是我们之前在[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)“使用标签深入液态核心”中从
    `product-data.csv` 文件导入的产品之一。我们可以通过预览产品页面并从页面URL中复制页面处理程序来检索产品处理程序。或者，我们可以在管理部分导航到产品页面，并从页面底部的页面URL链接中复制页面处理程序。
- en: Now that we have recovered the product handle, let's start by creating a product
    object through its handle and assigning it to a variable. To achieve this, we
    can use the previously learned method of accessing the page object through its
    handle. However, compared to the previous chapters, where we learned how to access
    the product object through its collection, accessing the product object directly
    using its handle is slightly different.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了产品处理程序，让我们首先通过其处理程序创建一个产品对象并将其分配给一个变量。为了实现这一点，我们可以使用之前学到的通过其处理程序访问页面对象的方法。然而，与之前的章节相比，在那里我们学习了如何通过其集合访问产品对象，直接使用其处理程序访问产品对象略有不同。
- en: Instead of pluralizing the product object name, we will be using a global object
    tag named `all_products`, which gives us access to all products in our store.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会将产品对象名称复数化，而将使用一个全局对象标签 `all_products`，它为我们提供了访问我们商店中所有产品的权限。
- en: 'Important note:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示：
- en: While `all_products` is quite a practical method that allows us to access any
    product directly through its handle, it comes with a limitation that we can only
    run it 20 times per page. This means that if we need to recover more than 20 specific
    products on a single page, we will need to recover them by looping over a collection.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然 `all_products` 是一种相当实用的方法，允许我们通过其处理程序直接访问任何产品，但它有一个限制，即我们只能在每页上运行它20次。这意味着如果我们需要在单页上恢复超过20个特定的产品，我们将需要通过遍历集合来恢复它们。
- en: 'We can access the product object through its handle by using the `all_products`
    global object, followed by the handle of the product we are trying to access.
    For our example, we will be using square brackets, `[]`. However, we could have
    also used the dot (`.`) annotation:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`all_products`全局对象，然后是我们要访问的产品的句柄来通过句柄访问产品对象。在我们的例子中，我们将使用方括号`[]`。然而，我们也可以使用点(`.`)注解：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this, we now have access to the gardening gloves product object. To access
    all images attached to a product, we will use the `product_object` variable as
    our object, followed by the `images` attribute, to recover the array of images
    for the specific product. Since we are dealing with an array, we will have to
    use the `for` tag to loop over them:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在可以访问园艺手套产品对象。要访问附加到产品上的所有图片，我们将使用`product_object`变量作为我们的对象，然后是`images`属性，以恢复特定产品的图片数组。由于我们正在处理一个数组，我们必须使用`for`标签来遍历它们：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have now successfully extracted an array of product images, which we can
    use to create powerful galleries using various slider plugins. However, notice
    that the size of the images we have on our storefront is relatively small.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功提取了一系列的产品图片，我们可以使用这些图片结合各种滑块插件来创建强大的相册。然而，请注意，我们店面上的图片尺寸相对较小。
- en: 'This is because Liquid always defaults to a size of `100x100` if we do not
    introduce the `size` parameter. Let''s introduce the `size` parameter by limiting
    the image dimension to 300 px in width and 300 px in height:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果没有引入`size`参数，Liquid总是默认为`100x100`的大小。让我们通过将图像尺寸限制为宽300像素和高度300像素来引入`size`参数：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that our images now have 300 px in width but only 200 px in height even
    though we have specified that we would like 300 px in height. This is because
    the `size` parameter can only limit the image size by decreasing its size to match
    the assigned values. It cannot change the image aspect, nor can it increase the
    size of the image beyond the original image size.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们指定了高度为300像素，但我们的图片现在宽度为300像素，高度仅为200像素。这是因为`size`参数只能通过减小图像大小来限制图像大小以匹配指定的值。它不能改变图像的宽高比，也不能将图像的大小增加到原始图像大小之外。
- en: In the previous example, we have used `"300x300"` to limit our product images
    in both width and height. However, we can also limit only one side by using `"300x"`
    to set the image width to 300 px or `"x300"` to limit the height to 300 px. If
    we only specify one of the two values, Shopify will automatically calculate the
    dimension of the image while maintaining the image aspect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了`"300x300"`来限制产品图片的宽度和高度。然而，我们也可以只限制一边，使用`"300x"`将图片宽度设置为300像素或使用`"x300"`将高度限制为300像素。如果我们只指定这两个值中的一个，Shopify将自动计算图像的尺寸，同时保持图像的宽高比。
- en: 'The second parameter we can use with the `img_url` filter is the `crop` parameter,
    which allows us to crop the image to the specified size when combined with the
    `size` parameter. The `crop` parameter can have five different values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与`img_url`过滤器配合的第二个参数是`crop`参数，它允许我们在与`size`参数结合时将图片裁剪到指定的大小。`crop`参数有五个不同的值：
- en: '`top`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`center`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`'
- en: '`bottom`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`left`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`right`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: 'Using the correct option, we can specify which side of the image we would like
    to crop out. For our example, we can use the `center` option to ensure that the
    image is cropped equally from each side:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的选项，我们可以指定我们想要裁剪图像的哪一侧。在我们的例子中，我们可以使用`center`选项来确保图像从每侧裁剪得一样：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By changing the image size using the `crop` parameter, we have also changed
    the image's aspect, as all the images are now exactly 300 px in width and 300
    px in height.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`crop`参数更改图像大小，我们也改变了图像的宽高比，因为所有图像的宽度和高度现在都是正好300像素。
- en: The last two parameters that we can use with the `img_url` filter are `scale`,
    which allows us to specify the pixel density of the image using the `2` and `3`
    as its option values, and `format`, which is a quite interesting parameter that
    allows us to specify the format of the displayed image. The two acceptable values
    for the `format` parameter are `jpg` and `pjpg`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与`img_url`过滤器配合的最后两个参数是`scale`，它允许我们使用`2`和`3`作为其选项值来指定图片的像素密度，以及`format`，这是一个相当有趣的参数，允许我们指定显示图片的格式。`format`参数的两个可接受值是`jpg`和`pjpg`。
- en: 'Using `pjpg`, we can convert the image format to **Progressive JPEG**, automatically
    loading a full-size image and increasing its quality gradually instead of loading
    the image from top to bottom like a traditional JPEG (we can read more about the
    Progressive JPEG at the following link: [https://en.wikipedia.org/wiki/JPEG#JPEG_compression](https://en.wikipedia.org/wiki/JPEG#JPEG_compression)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `pjpg`，我们可以将图像格式转换为**渐进式JPEG**，自动加载全尺寸图像并逐渐提高其质量，而不是像传统JPEG那样从顶部到底部加载图像（我们可以在以下链接中了解更多关于渐进式JPEG的信息：[https://en.wikipedia.org/wiki/JPEG#JPEG_compression](https://en.wikipedia.org/wiki/JPEG#JPEG_compression)):'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have familiarized ourselves with the parameters that are accessible
    using the `img_url` filter, it is time to learn more about the parameters available
    with the `img_tag` filter. Let''s start by modifying our last example to use `img_tag`
    to generate the HTML tag:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了使用`img_url`过滤器可访问的参数，是时候了解`img_tag`过滤器可用的参数了。让我们从修改我们的最后一个示例开始，使用`img_tag`生成HTML标签：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that when we first mentioned `img_tag`, we used it in combination with
    `asset_url` to recover the URL string of the image location inside the `Assets`
    directory. However, since we are not accessing the `Assets` directory but the
    product images, whose array of URL strings we already have from using `product_object.images`,
    we do not need to use any additional filters besides `img_tag`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们第一次提到`img_tag`时，我们将其与`asset_url`结合使用来恢复`Assets`目录内图像位置的URL字符串。然而，由于我们不是访问`Assets`目录，而是访问产品图像，我们已经有从使用`product_object.images`获取的URL字符串数组，所以我们不需要使用除`img_tag`之外的任何其他过滤器。
- en: By reviewing the results, we can see that we have successfully created the HTML
    `img` tag for each image within the image array. Since we haven't declared the
    image size, Shopify has by default resized our images to `100x100`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看结果，我们可以看到我们已经成功为图像数组中的每个图像创建了HTML `img`标签。由于我们没有声明图像大小，Shopify默认将我们的图像调整为`100x100`。
- en: '`img_tag` accepts only three parameters. Contrary to `img_url`, where we can
    apply only the parameter we need, for `img_tag`, we need to apply all parameters
    in a specific order. This means that we would first have to use the other parameters
    if we would like to use the `class` and `alt` tag parameters.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`img_tag`只接受三个参数。与只能应用所需参数的`img_url`不同，对于`img_tag`，我们需要按照特定顺序应用所有参数。这意味着如果我们想使用`class`和`alt`标签参数，我们首先必须使用其他参数。'
- en: 'Since we need to add all parameters in a specific order, the parameters require
    no representation. We only need to assign their values. The first value is alt
    text, inside of which we can use a fixed string value or a Liquid value, such
    as `image_item.alt`, to recover the actual image alt text. The second parameter
    we can use to assign specific classes to each image tag, while only in the third
    parameter can we assign the size value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要按特定顺序添加所有参数，参数不需要表示。我们只需要分配它们的值。第一个值是alt文本，在其中我们可以使用固定字符串值或Liquid值，如`image_item.alt`，以恢复实际的图像alt文本。第二个参数我们可以用来为每个图像标签分配特定的类，而只有在第三个参数中我们可以分配大小值：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we have had the chance to see, both the `image_url` and `img_tag` filters
    have their helpful parameters, and while `img_tag` is cleaner, it has limitations
    as we are limited in the number of attributes we can include in the generated
    HTML `img` tag.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`image_url`和`img_tag`过滤器都有它们有用的参数，虽然`img_tag`更简洁，但它有局限性，因为我们包括在生成的HTML
    `img`标签中的属性数量有限。
- en: Suppose we were looking to extract an image file from the `Assets` directory
    with the appropriate `size` parameter applied to apply it as a background image.
    We cannot use `img_tag`, as previously mentioned, as that would return an HTML
    `img` tag. We also cannot use `asset_url` alone, as `asset_url` does not accept
    any additional parameters, including the `size` parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从`Assets`目录中提取一个图像文件，并应用适当的`size`参数以将其用作背景图像。我们不能使用`img_tag`，如前所述，因为这会返回一个HTML
    `img`标签。我们也不能单独使用`asset_url`，因为`asset_url`不接受任何附加参数，包括`size`参数。
- en: 'Similarly, as with `stylesheet_tag` and `script_tag`, we have access to the
    special `asset_img_url` filter, which allows us to include the `size` parameter
    to recover the images from the `Assets` directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`stylesheet_tag`和`script_tag`，我们有权限使用特殊的`asset_img_url`过滤器，它允许我们包含`size`参数以从`Assets`目录中恢复图像：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that `asset_img_url` allows us to include the `size` parameter and other
    parameters previously available with the `img_url` filter, including `size`, `crop`,
    `scale`, and `format`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asset_img_url`允许我们包含`size`参数和其他之前通过`img_url`过滤器可用的参数，包括`size`、`crop`、`scale`和`format`。
- en: So far, we have learned how to access different types of files within the `Assets`
    directory and generate the appropriate HTML tag for each of them. We have also
    learned how to work with the `img_url` filter by working through a small project
    of outputting the necessary elements to create a basic product gallery. While
    we have not gone over all of the URL and HTML filters that Liquid offers, we have
    now set the proper groundwork for working with HTML and URL filters, knowledge
    of which is essential in Liquid and will be of great help to our future work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何访问`Assets`目录中的不同类型的文件并为每个文件生成适当的HTML标签。我们还通过一个小项目学习了如何使用`img_url`过滤器，该项目涉及输出创建基本产品库所需的所有元素。虽然我们没有涵盖Liquid提供的所有URL和HTML过滤器，但我们现在已经为使用HTML和URL过滤器奠定了适当的基础，这种知识在Liquid中至关重要，并将对我们未来的工作大有裨益。
- en: 'Tip:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on all the available HTML filters, we can refer to
    [https://shopify.dev/docs/themes/liquid/reference/filters/html-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters),
    and for additional information on the available URL filters, we can refer to [https://shopify.dev/docs/themes/liquid/reference/filters/url-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有可用的HTML过滤器，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/html-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters)，关于可用的URL过滤器，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/url-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters)。
- en: Enhancing the product media gallery
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升产品媒体库
- en: In the previous exercise, we learned how to output the image elements needed
    to output the necessary elements to create a basic product gallery that contains
    only images. In the following project, we will learn how to use media objects
    and filters to create a multifunctional gallery that will support images, 3D models,
    and internal videos hosted on Shopify. Additionally, we will also embed external
    video links to some of the most popular video platforms, Vimeo and YouTube, and
    autogenerate the appropriate video player for both.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们学习了如何输出创建仅包含图像的基本产品库所需的图像元素。在接下来的项目中，我们将学习如何使用媒体对象和过滤器创建一个多功能库，该库将支持图像、3D模型和Shopify上托管的内嵌视频。此外，我们还将嵌入一些最受欢迎的视频平台（Vimeo和YouTube）的外部视频链接，并为两者自动生成适当的视频播放器。
- en: Most of the newest themes today already contain a product media gallery. However,
    many stores still use outdated theme files, so it is essential to know how to
    create the feature from scratch.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数最新的主题已经包含了产品媒体库。然而，许多商店仍在使用过时的主题文件，因此了解如何从头开始创建这个功能是至关重要的。
- en: 'Let''s start by navigating to the `Product Gallery` page we created in the
    previous *Building a product gallery* subsection, located under the *Working with
    HTML and URL filters* section, and revise the previously included code to accept
    additional media types besides images:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导航到我们在上一节*构建产品库*中创建的`产品库`页面开始，该页面位于*使用HTML和URL过滤器*部分之下，并修改之前包含的代码以接受除了图像之外的其他媒体类型：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Initially, we have used the `product_object` variable to capture the product
    object of the gardening gloves product, after which we have used a `for` tag to
    loop over the array of images received from `product_object.images`. Considering
    that we are dealing with various media types, we will need to use a `media` attribute
    to recover the media array and replace the `image_item` variable with `media`
    to keep everything cohesive:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们使用`product_object`变量来捕获园艺手套产品的产品对象，之后我们使用`for`标签遍历从`product_object.images`接收到的图像数组。鉴于我们正在处理各种媒体类型，我们需要使用`media`属性来恢复媒体数组，并将`image_item`变量替换为`media`以保持一切的一致性：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the `media` attribute, we have now recovered an array of all the different
    media objects, which can contain the following media types:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`media`属性，我们现在已经恢复了一个包含所有不同媒体对象的数组，它可以包含以下媒体类型：
- en: '`image`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图像`'
- en: '`external_video`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`外部视频`'
- en: '`video`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`视频`'
- en: '`model`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模型`'
- en: However, having an array of media types also means that we now have a mixed
    array of objects, so we need to filter them out before anything.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有多种媒体类型也意味着我们现在有一个混合的对象数组，因此在我们做任何事情之前，我们需要过滤掉它们。
- en: We will use the `case/when` tags combined with the `media_type` attribute, a
    part of the media object that will allow us to create a `switch` statement to
    recover an array of all media of a specific type. We can remind ourselves of `case/when`
    tags by visiting the *Controlling the flow of Liquid* section, which we can find
    in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving into
    Liquid Core with Tags*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`case/when`标签与`media_type`属性结合，这是媒体对象的一部分，它将允许我们创建一个`switch`语句来恢复特定类型的所有媒体。我们可以通过访问*控制Liquid流程*部分来提醒自己`case/when`标签，这部分我们可以在[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)，*深入Liquid核心与标签*中找到。
- en: 'Let''s create a `case` tag to filter out `media_type` and write a `switch`
    statement for each media type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`case`标签来过滤`media_type`，并为每个媒体类型编写一个`switch`语句：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the `case/when` tags in place, we have successfully filtered out the media
    types and have gained access to each media type object we will need to output
    the media tags.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case/when`标签就位后，我们已经成功过滤出媒体类型，并获得了访问每个媒体类型对象的权利，我们将需要输出媒体标签。
- en: 'If we look at our code, we will notice that the code we have previously used
    to output the images in our previous example is still there. Since we now have
    access to the `image` object within the first `switch` statement, we can simply
    reposition the code inside, which will be the first step in outputting the image
    media files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的代码，我们会注意到我们之前用于在先前的示例中输出图像的代码仍然存在。由于我们现在可以在第一个`switch`语句中访问`image`对象，我们可以简单地重新定位代码，这将是在输出图像媒体文件的第一步：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With `img_tag` in place, we have now successfully outputted all the image files
    for our product. However, we still lack tags for other media types. So, let's
    proceed with the external video.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`img_tag`就位后，我们现在已经成功输出了我们产品的所有图像文件。然而，我们仍然缺少其他媒体类型的标签。所以，让我们继续处理外部视频。
- en: 'The `external_video` object provides us with information about Vimeo or YouTube
    videos associated with a specific product. Similarly, as with image objects, to
    output the `external_video` media types, we will need to use `external_video_tag`
    to generate the necessary `iframe` element, whether for Vimeo or YouTube:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`external_video`对象为我们提供了有关与特定产品相关联的Vimeo或YouTube视频的信息。同样，与图像对象一样，为了输出`external_video`媒体类型，我们需要使用`external_video_tag`来生成必要的`iframe`元素，无论是Vimeo还是YouTube：'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With `external_video_tag` in place, we will automatically generate an iframe
    with all the necessary attributes for each `external_video` media type, so let''s
    give it a quick test:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`external_video_tag`就位后，我们将自动为每个`external_video`媒体类型生成一个包含所有必要属性的iframe，所以让我们快速测试一下：
- en: To test out whether `external_video_tag` works, we will first need to include
    either a Vimeo or YouTube video on our product page media.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试`external_video_tag`是否工作，我们首先需要在我们的产品页面媒体中包含一个Vimeo或YouTube视频。
- en: We will need to click on the **Products** section in our admin sidebar and navigate
    to the product whose media files we are currently viewing to do this. In our case,
    that product is gardening gloves.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要点击我们的管理侧边栏中的**产品**部分，并导航到我们目前正在查看媒体文件的产品。在我们的例子中，这个产品是园艺手套。
- en: After opening the specific product page, we will need to scroll down to the
    **Media** section, where in the top-right corner, we will find a drop-down link
    named **Add media from URL**, which we should click to reveal the drop-down options.
    Inside the dropdown, we will find two options, the first one allowing us to add
    an external image to our product, and the second one allowing us to embed either
    a Vimeo or YouTube video.![Figure 5.1 – Example of embedding external assets to
    a product media
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开特定的产品页面后，我们需要滚动到**媒体**部分，在右上角，我们会找到一个名为**从URL添加媒体**的下拉链接，我们应该点击以显示下拉选项。在下拉菜单中，我们会找到两个选项，第一个选项允许我们向产品添加外部图像，第二个选项允许我们嵌入Vimeo或YouTube视频。![Figure
    5.1 – 将外部资产嵌入到产品媒体中的示例
- en: '](img/Figure_5.01_B17606.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 5.01_B17606.jpg]'
- en: Figure 5.1 – Example of embedding external assets to a product media
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.1 – 将外部资产嵌入到产品媒体中的示例
- en: We should proceed by clicking on **Embed video**, which will trigger a popup
    where we can include the URL of either a Vimeo or YouTube video. After pasting
    the link, click on the **Embed video** button to complete the process. After a
    few seconds of processing, the media video will be visible in the **Media** section.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该通过点击**嵌入视频**来继续，这将触发一个弹出窗口，我们可以在这里包含Vimeo或YouTube视频的URL。粘贴链接后，点击**嵌入视频**按钮来完成此过程。经过几秒钟的处理，媒体视频将在**媒体**部分可见。
- en: '![Figure 5.2 – Example of various media files on the product admin page'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 产品管理页面上的各种媒体文件示例'
- en: '](img/Figure_5.02_B17606.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B17606.jpg)'
- en: Figure 5.2 – Example of various media files on the product admin page
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 产品管理页面上的各种媒体文件示例
- en: With the video now successfully loaded within the product media assets, all
    that is left is to test whether `external_video_tag` works well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 视频现在已成功加载到产品媒体资源中，剩下要测试的是 `external_video_tag` 是否工作良好。
- en: By clicking on the media video asset, we will trigger a popup with a preview
    on one side and the option to include alt text on the other. Additionally, in
    the top-right corner, we can see three icons. The first one is a trash icon, which
    will allow us to delete the specific media. The middle icon, represented by three
    dots, when clicked will reveal a drop-down menu with the **Replace thumbnail**
    option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 点击媒体视频资源，将触发一个弹出窗口，其中一侧显示预览，另一侧提供包含 alt 文本的选项。此外，在右上角，我们可以看到三个图标。第一个是一个垃圾桶图标，允许我们删除特定的媒体。中间的图标，由三个点表示，当点击时将显示一个包含
    **替换缩略图** 选项的下拉菜单。
- en: Clicking this option will allow us to upload a thumbnail visible as a poster
    image for the iframe video and avoid having the first frame of the video as a
    poster. Note that the icon represented with three dots is only visible on video
    assets and will not be visible on regular image assets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此选项将允许我们上传一个作为 iframe 视频海报图片的缩略图，避免视频的第一帧作为海报。请注意，用三个点表示的图标仅在视频资源上可见，在常规图像资源上不可见。
- en: '![Figure 5.3 – Example of video media asset pop-up tools'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 视频媒体资源弹出工具示例'
- en: '](img/Figure_5.03_B17606.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B17606.jpg)'
- en: Figure 5.3 – Example of video media asset pop-up tools
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 视频媒体资源弹出工具示例
- en: 'Previewing the `iframe` element:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 预览 `iframe` 元素：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, by default, there are many attributes included in our YouTube
    video embedding, such as visible controls and branding. *But what if we wanted
    to modify those attributes or include some new ones?*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，默认情况下，我们的 YouTube 视频嵌入中包含了许多属性，例如可见控件和品牌。*但如果我们想修改这些属性或包含一些新的属性呢？*
- en: 'To modify existing external video attributes or include new ones, we will need
    to introduce a new media filter, `external_video_url`. By including the `external_video_url`
    filter, in combination with `external_video_tag`, we will be able to modify any
    attribute of the YouTube embedding:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改现有的外部视频属性或包含新的属性，我们需要引入一个新的媒体过滤器，`external_video_url`。通过包含 `external_video_url`
    过滤器，结合 `external_video_tag`，我们将能够修改 YouTube 嵌入的任何属性：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, we can include any number of attributes from the official YouTube
    documentation. While helpful for YouTube video embeddings, the attributes we have
    included will not help us when dealing with Vimeo videos, considering that Vimeo
    uses different attributes based on its own documentation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以从官方 YouTube 文档中包含任意数量的属性。虽然这些属性对 YouTube 视频嵌入很有帮助，但当我们处理 Vimeo 视频时，这些属性将不会对我们有所帮助，因为
    Vimeo 根据其自己的文档使用不同的属性。
- en: 'In order to differentiate which embedding link belongs to YouTube and which
    belongs to Vimeo, we will need to introduce the `host` attribute through the `external_video`
    object, which returns one of two values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分哪个嵌入链接属于 YouTube，哪个属于 Vimeo，我们需要通过 `external_video` 对象引入 `host` 属性，该对象返回两个值之一：
- en: '`youtube`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`youtube`'
- en: '`vimeo`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vimeo`'
- en: 'Using the `host` attribute in combination with an `if` statement, we can easily
    distinguish the two `iframe` elements and apply the appropriate attributes to
    each of them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用 `host` 属性和 `if` 语句，我们可以轻松地区分两个 `iframe` 元素，并将适当的属性应用于它们：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the introduction of the `host` attribute, we have ensured that each type
    of external video embedding will receive the appropriate attributes based on its
    documentation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入 `host` 属性，我们已经确保每种类型的外部视频嵌入都将根据其文档接收适当的属性。
- en: 'Tip:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For available attributes for YouTube videos, refer to [https://developers.google.com/youtube/player_parameters#Parameters](https://developers.google.com/youtube/player_parameters#Parameters).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 YouTube 视频的可用属性，请参阅 [https://developers.google.com/youtube/player_parameters#Parameters](https://developers.google.com/youtube/player_parameters#Parameters)。
- en: For available attributes for Vimeo videos, refer to [https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Vimeo 视频的可用属性，请参阅 [https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters)。
- en: We have now learned how to include both types of external videos and include
    any attributes for each type. Now we can move on to the following `switch` statement
    and learn how to output a video hosted on the Shopify platform itself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何包含两种类型的外部视频，并为每种类型包含任何属性。现在我们可以继续到下一个 `switch` 语句，学习如何输出托管在Shopify平台本身上的视频。
- en: Uploading a video as a product media asset is the same as uploading an image.
    To upload a video, click on the **Products** section within the admin sidebar
    and select the product for which we are uploading the video asset. Once inside,
    scroll down to the **Media** section and click on the **Add Media** button to
    start the uploading process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频作为产品媒体资产上传与上传图像相同。要上传视频，请点击管理侧边栏中的 **产品** 部分，并选择我们上传视频资产的产品。进入后，滚动到 **媒体**
    部分，然后点击 **添加媒体** 按钮开始上传过程。
- en: 'Important note:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Aside from external videos, uploading assets to the Shopify platform has specific
    limitations for all assets, including images and videos. Besides the specific
    types of formats that we can use, an image file cannot exceed the resolution of
    20 MP, 20 MB in size, and must be in either `.jpeg` or `.png` format, whereas
    video files are limited to a maximum length of 60 seconds, 20 MB in size, and
    must be in either `.mp4` or `.mov` video format.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了外部视频外，上传到Shopify平台的资产（包括图像和视频）都有特定的限制。除了我们可以使用的特定格式类型外，图像文件的大小不能超过20 MP，20
    MB，并且必须是 `.jpeg` 或 `.png` 格式，而视频文件的最大长度为60秒，大小为20 MB，并且必须是 `.mp4` 或 `.mov` 视频格式。
- en: Once we have uploaded the video, we can also add optional information by including
    alt text and a poster image in the same way as for external media.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们上传了视频，我们还可以通过包含替代文本和海报图像以与外部媒体相同的方式添加可选信息。
- en: 'To output the video uploaded to product media files, we will need to use `video_tag`,
    accessible through the `video` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出上传到产品媒体文件的视频，我们需要使用 `video_tag`，通过 `video` 对象访问：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By previewing the `video` tag. However, since we haven't enabled the controls,
    they have been hidden by default. Additionally, if we look closer, we will notice
    that the URL for the `poster` attribute within the HTML `video` tag has a small
    size, which is why the image on the storefront is small.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预览 `video` 标签。然而，由于我们没有启用控件，它们默认被隐藏。此外，如果我们仔细观察，我们会注意到HTML `video` 标签中 `poster`
    属性的URL有一个小尺寸，这就是为什么店面上的图像也很小。
- en: As we recall from when learning about image filters, if we try to output an
    image without defining the image size, Shopify will automatically resize the image
    to `100x100`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们回忆起学习图像过滤器时一样，如果我们尝试输出未定义图像大小的图像，Shopify会自动将图像大小调整为 `100x100`。
- en: 'With `video_tag`, we can include any number of attributes that we could use
    with the regular HTML `video` tag, including the `image_size` parameter, allowing
    us to modify the video `poster` attribute size. Let''s modify `video_tag` to make
    the controls visible, set the poster image size, and set the video size to `300x`
    to match the poster size:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `video_tag`，我们可以包含任何可以与常规HTML `video` 标签一起使用的属性，包括 `image_size` 参数，允许我们修改视频
    `poster` 属性的大小。让我们修改 `video_tag` 以使控件可见，设置海报图像大小，并将视频大小设置为 `300x` 以匹配海报大小：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the additional attributes included, we have now successfully generated
    the HTML `video` tag while retaining the ability to modify any attribute as we
    see fit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了额外的属性后，我们现在已经成功生成了HTML `video` 标签，同时保留了根据需要修改任何属性的能力。
- en: 'The following media type that we need to look into is the 3D model, which we
    can output using `model_viewer_tag`, accessible through the `model` object. Simply
    including `model_viewer_tag` with the `media` object will automatically generate
    the appropriate model viewer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的下一个媒体类型是3D模型，我们可以使用 `model_viewer_tag` 输出它，通过 `model` 对象访问。只需将 `model_viewer_tag`
    与 `media` 对象一起包含，就会自动生成适当的模型查看器：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the model viewer will automatically include specific attributes by
    default as with the previous `media` tags. Although, if we choose so, we can easily
    update or even include new attributes by following the same format mentioned with
    the previous `media` tags.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模型查看器将默认自动包含特定属性，就像之前的 `media` 标签一样。尽管如此，如果我们选择这样做，我们可以很容易地更新或包括新的属性，只需遵循之前
    `media` 标签中提到的相同格式即可。
- en: With `model_viewer_tag` in place, we have covered all four media types and ensured
    that we would represent each media type with an appropriate `media` tag. However,
    notice that we still have one final `switch` statement without any `media` tag.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`model_viewer_tag`到位的情况下，我们已经涵盖了所有四种媒体类型，并确保我们将每种媒体类型用适当的`media`标签表示。然而，请注意，我们仍然有一个没有`media`标签的最后的`switch`语句。
- en: We can consider the final `switch` statement as a failsafe if, for some reason,
    any of the previous `switch` statements or media fail to produce results, and
    we will use it with `media_tag`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最后的`switch`语句视为一种安全措施，以防万一之前的任何`switch`语句或媒体无法产生结果，我们将与`media_tag`一起使用它。
- en: The `media_tag` filter is somewhat of a special kind of filter as this particular
    filter will automatically generate the appropriate `media` tag for any of the
    four previously mentioned media types. *So, if we can use* `media_tag` *to generate
    all the* `media` *tags automatically,* *why don't we use* `media_tag` *to generate
    all the media files? Why did we bother to learn about all the* `media` *tags until
    now?*
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`media_tag`过滤器是一种特殊的过滤器，因为这个特定的过滤器将自动为之前提到的四种媒体类型中的任何一种生成适当的`media`标签。*所以，如果我们可以用*
    `media_tag` *自动生成所有* `media` *标签，* *为什么我们还要用* `media_tag` *来生成所有媒体文件呢？为什么我们到现在还要费心学习所有*
    `media` *标签呢？*'
- en: 'While it is correct that `media_tag` will automatically detect each type of
    media type and render the appropriate `media` tag for it, by using `media_tag`,
    we will lose the ability to assign custom class names and attributes to specific
    media types. For this reason, we should never use `media_tag` as the primary option
    for rendering media assets. Instead, we should use it as a failsafe to correctly
    render the media assets on the storefront:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`media_tag`确实会自动检测每种媒体类型并为其渲染适当的`media`标签，但通过使用`media_tag`，我们将失去为特定媒体类型分配自定义类名和属性的能力。因此，我们永远不应该将`media_tag`作为渲染媒体资产的主要选项。相反，我们应该将其用作后备方案，以确保在店面正确渲染媒体资产：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So far, we have learned how to output image type media files, differentiate
    between different types of external media assets, render the media tag for a video
    hosted on the Shopify platform, and generate the appropriate media tag for 3D
    models. Finally, with `media_tag`, we have covered every media type Shopify currently
    covers and have ensured that we will correctly present each media asset on our
    storefront.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何输出图像类型的媒体文件，区分不同类型的外部媒体资产，渲染Shopify平台上的视频的媒体标签，并生成3D模型的适当媒体标签。最后，通过`media_tag`，我们涵盖了Shopify目前覆盖的所有媒体类型，并确保我们将在店面正确展示每个媒体资产。
- en: Now that we have all the necessary assets to create the media gallery, the only
    thing left to do is to refine our code by including some HTML elements to format
    it properly. Besides the code format, we can also use some slider plugins, such
    as **Slick**, depending on the gallery we are looking to create. To keep everything
    concise and to the point, we will not be covering the media gallery's style and
    functionality. However, we can find the necessary suggestions on styling and functionality
    in the following Shopify article for those looking to test their skills by finishing
    the project ([https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video](https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建媒体库所需的所有必要资源，接下来要做的就是通过添加一些HTML元素来正确格式化代码，从而进一步优化我们的代码。除了代码格式，我们还可以根据我们想要创建的画廊类型，使用一些滑动插件，例如**Slick**。为了保持内容简洁并直击要点，我们不会涵盖媒体库的样式和功能。然而，对于那些想要通过完成项目来测试自己技能的人来说，我们可以在以下Shopify文章中找到关于样式和功能的必要建议（[https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video](https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video)）。
- en: Inside the article, we can find information such as using the aspect ratio box
    to create responsiveness or answers to some of the frequently asked questions
    on functionality, such as connecting the thumbnail images to the main gallery
    or the variant themselves.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在文章中，我们可以找到有关使用宽高比框创建响应性或回答一些关于功能性的常见问题解答的信息，例如将缩略图图像连接到主画廊或变体本身。
- en: 'Tip:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on all the available media filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/media-filters](https://shopify.dev/docs/themes/liquid/reference/filters/media-filters).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有可用媒体过滤器的更多信息，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/media-filters](https://shopify.dev/docs/themes/liquid/reference/filters/media-filters)。
- en: While working on this project, we created a fundamental version of the product
    media gallery, allowing us to output any type of product media to any page. While
    it might not look impressive, the knowledge we have learned with this project
    has taught us how to create one of the most sought-after features today, and it
    will be of great help to us in creating more advanced functionalities as our knowledge
    grows further.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个项目的过程中，我们创建了一个产品媒体库的基本版本，这使得我们能够将任何类型的产品媒体输出到任何页面。虽然它可能看起来并不令人印象深刻，但通过这个项目我们学到的知识教会了我们如何创建今天最受欢迎的功能之一，并且随着我们知识的进一步增长，它将对我们创建更高级的功能大有裨益。
- en: Building product accordions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建产品折叠面板
- en: In the following project, we will be learning about the string and array filters
    by working with and creating the product accordions feature. *But, before we proceed
    with the project, what exactly do string and array filters do?*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下项目中，我们将通过处理和创建产品折叠面板功能来学习字符串和数组过滤器。*但是，在我们继续项目之前，字符串和数组过滤器究竟做什么呢？*
- en: '**String filters** are methods that allow us to manipulate the output of Liquid
    code or the variable itself as long as the variable is a string type, whereas
    array filters allow us to manipulate the output of arrays.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串过滤器**是允许我们操纵 Liquid 代码的输出或变量本身的方法，只要变量是字符串类型，而数组过滤器允许我们操纵数组的输出。'
- en: For this project, we will first find one product with a lengthy description.
    To save some time, we already included the necessary description in the `product-data.csv`
    file in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving
    into Liquid Core with Tags*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们首先需要找到一个具有冗长描述的产品。为了节省时间，我们已经在`product-data.csv`文件中包含了必要的描述，在[*第 3
    章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047) *深入 Liquid 核心标签*中。
- en: '![Figure 5.4 – Example of a long product description'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 长产品描述的示例'
- en: '](img/Figure_5.04_B17606.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B17606.jpg)'
- en: Figure 5.4 – Example of a long product description
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 长产品描述的示例
- en: 'As we can see from the previous screenshot, having a lengthy product description
    can be quite inefficient as it takes up a lot of space. While we can easily format
    the product description code to include the necessary HTML tags to create product
    accordions, manually adjusting the code for each product would be a long process.
    Maintaining it is even worse. Luckily, by using string and array filters, we can
    easily manipulate the product description output to break it up and format it
    in any way we need:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的屏幕截图中所见，拥有冗长的产品描述可能相当低效，因为它占据了大量的空间。虽然我们可以轻松地格式化产品描述代码，包括创建产品折叠面板所需的必要
    HTML 标签，但手动调整每个产品的代码将是一个漫长的过程。维护它甚至更糟糕。幸运的是，通过使用字符串和数组过滤器，我们可以轻松地操纵产品描述输出，将其拆分并按任何我们需要的方式格式化：
- en: 'First, let''s begin by identifying the piece of code that is rendering the
    current product description. We can find the product description inside `product-template.liquid`
    under the `Sections` directory, which we are currently rendering using `product.description`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从识别渲染当前产品描述的代码片段开始。我们可以在`product-template.liquid`文件中找到产品描述，该文件位于`Sections`目录下，我们目前正在使用`product.description`来渲染它：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we are looking to create reusable code, the first thing we should do
    is to create a variable that will hold the `product.description` output, so that
    we can avoid calling `product.description` multiple times:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望创建可重用的代码，我们应该做的第一件事是创建一个变量来保存`product.description`的输出，这样我们就可以避免多次调用`product.description`：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have the variable in place, we should outline what exactly we are
    trying to achieve. Again, looking over the current product description, we can
    clearly see that we have three solid blocks, so let's say that we are looking
    to separate the entire product description into three or even more distinctive
    product accordions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了变量，我们应该概述我们试图实现的具体目标。再次查看当前的产品描述，我们可以清楚地看到我们有三个坚实的块，所以让我们说我们希望将整个产品描述分成三个甚至更多的独特的产品折叠面板。
- en: 'Now that we know *what*, we need to think of *how*. While we can easily hardcode
    the product accordion titles, such as **Description**, **Ingredients**, and **Instructions**,
    we are looking to create a dynamic feature that allows us to easily include any
    number of product accordions without modifying the code itself. We''ll use the
    following steps to do so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了*什么*，我们需要考虑*如何*。虽然我们可以轻松地硬编码产品折叠面板的标题，例如**描述**、**成分**和**说明**，但我们希望创建一个动态功能，允许我们轻松地包括任意数量的产品折叠面板，而无需修改代码本身。我们将使用以下步骤来实现这一点：
- en: Start by navigating to the `Description`, `Ingredients`, and `Instructions`
    as h6 headings, one before each text block. To do this, we can use the headings
    to include any number of product tab titles and set the proper markings for later.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将`Description`、`Ingredients`和`Instructions`作为h6标题导航到每个文本块之前。为此，我们可以使用标题来包含任意数量的产品标签标题，并为以后设置适当的标记。
- en: 'Then, we can apply the headings using the rich text editor by simply highlighting
    the text we are looking to format and clicking the **A** button, which will trigger
    a dropdown where we can select the h6 heading we need:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过简单地突出显示我们想要格式化的文本并点击**A**按钮来使用富文本编辑器应用标题，这将触发一个下拉菜单，我们可以从中选择所需的h6标题：
- en: '![Figure 5.5 – Example of applying headings inside the product description'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 在产品描述中应用标题的示例'
- en: '](img/Figure_5.05_B17606.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.05_B17606.jpg)'
- en: Figure 5.5 – Example of applying headings inside the product description
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 在产品描述中应用标题的示例
- en: With the headings in place, we now have proper markup that we can use to separate
    the text blocks into separate blocks, which we can do using the following string
    filter, `split`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好标题后，我们现在有了适当的标记，我们可以使用它来将文本块分隔成单独的块，这可以通过以下字符串过滤器`split`来实现。
- en: The split filter
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割过滤器
- en: The `split` filter uses a single substring as a parameter, which acts as a delimiter,
    dividing the string into an array whose items we can later output using array
    filters. *But how exactly does it work?*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`过滤器使用一个单独的子字符串作为参数，它作为分隔符，将字符串分割成一个数组，我们可以稍后使用数组过滤器输出这些数组项。*但是它究竟是如何工作的呢？*'
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we have created a variable named `methods` and assigned a
    string message to it. Let''s now use the `split` filter to divide the string message
    into an array and call it immediately to see the results:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`methods`的变量，并给它分配了一个字符串消息。现在让我们使用`split`过滤器将字符串消息分割成数组，并立即调用它以查看结果：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, after applying the `split` filter, the substring that we used
    as a delimiter was removed entirely from the initial string, and we have ended
    up with an array result. Therefore, any value assigned to the `split` filter substring
    parameter will not only serve as a markup delimiter but will also automatically
    remove any occurrence of the substring value from the string.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在应用`split`过滤器后，我们用作分隔符的子字符串被完全从初始字符串中移除，我们最终得到了一个数组结果。因此，分配给`split`过滤器子字符串参数的任何值不仅将作为标记分隔符，而且还将自动从字符串中删除任何子字符串值的出现。
- en: After using the `split` filter, we have now modified the `methods` variable
    into an array. However, this is not obvious since we have also included empty
    space within the delimiter, so as a result, we have two words written next to
    each other without any space. To test whether our `methods` variable is an array,
    we need to run it through a loop using the `for` tag. *However, what if we wanted
    to avoid using a loop since we only have two items inside the array?*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`split`过滤器后，我们现在已经将`methods`变量修改为数组。然而，这并不明显，因为我们还在分隔符内包含了空格，因此结果是我们两个单词紧挨着写在一起而没有空格。为了测试我们的`methods`变量是否为数组，我们需要使用`for`标签运行它。*但是如果我们只想避免使用循环，因为数组中只有两个项目呢？*
- en: 'This is where the `first` array filter comes to help. As we recall, we previously
    mentioned both the `first` and `last` filters in the previous chapter when we
    worked on the `Product Customization` project. Using the `first` or `last` filter
    will automatically recover the first or last element inside the array. Since our
    array only has two elements after using the `split` filter, it is a perfect fit.
    Otherwise, we would need to include a `for` tag to loop over the array to recover
    the proper values. Let''s see it in action by recovering only data before the
    delimiter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`first`数组过滤器发挥作用的地方。正如我们回忆的那样，我们在上一章中提到过`first`和`last`过滤器，当时我们在进行`Product
    Customization`项目时。使用`first`或`last`过滤器将自动恢复数组中的第一个或最后一个元素。由于使用`split`过滤器后我们的数组只有两个元素，所以这是一个完美的匹配。否则，我们需要包含一个`for`标签来遍历数组以恢复正确的值。让我们通过只恢复分隔符之前的数据来观察它的实际效果：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can now see that we have successfully modified the initial string type variable
    into an array type and have successfully recovered only the first item of the
    array. While this specific method might look non-important, the knowledge we have
    gained will be of great use in our future work.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，我们已经成功地将初始的字符串类型变量修改为数组类型，并且已经成功恢复了数组的第一项。虽然这个具体的方法看起来可能并不重要，但我们所获得的知识将在我们未来的工作中非常有用。
- en: 'Before we move on to our project, let''s take one more example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的项目之前，让我们再看一个例子：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this example, we have assigned a short string inside the `message` variable.
    We have then applied the `split` filter and set its substring to an empty space
    value, meaning that we are looking to divide the initial string for every empty
    space occurrence. Let''s create a short loop to confirm whether the `message`
    variable is now an array type:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`message`变量中分配了一个简短的字符串。然后我们应用了`split`过滤器并将子字符串设置为空格值，这意味着我们正在寻找在每个空格出现时分割初始字符串。让我们创建一个简短的循环来确认`message`变量现在是一个数组类型：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see, by introducing the `split` filter, we have successfully divided
    the initial string message using the substring parameter and created an array,
    which we have confirmed using the `for` tag. Let's now return to our project and
    use our newfound knowledge to divide the product description into three separate
    blocks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过引入`split`过滤器，我们已成功使用子字符串参数将初始字符串消息分割，并创建了一个数组，我们使用`for`标签进行了确认。现在让我们回到我们的项目，并使用我们新获得的知识将产品描述分成三个独立的块。
- en: 'Since we are looking to create a dynamic feature, we will need to set the substring
    parameter to a value that we know will be present in each product description.
    Remember that we have previously added the headings, formatted using the `h6`
    heading. So, let''s use the `split` filter and set the substring value to the
    opening `h6` heading:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找创建一个动态功能，我们需要将子字符串参数设置为一个我们知道将在每个产品描述中出现的值。记住，我们之前已经添加了标题，使用了`h6`标题进行格式化。因此，让我们使用`split`过滤器并将子字符串值设置为开头的`h6`标题：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make sense of using the `h6` heading as a substring parameter, we will first
    need to look over the current HTML format of our product description. If we were
    to inspect the product description before using the `split` filter, we would notice
    the following HTML format:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解使用`h6`标题作为子字符串参数的意义，我们首先需要查看我们产品描述的当前HTML格式。如果我们在使用`split`过滤器之前检查产品描述，我们会注意到以下HTML格式：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the markup shows, each heading is located just above the text block, providing
    perfect markup. Using the opening `h6` heading as a delimiter, we should have
    four items inside our array. Let''s now see what happens when we apply the `split`
    filter using the opening `h6` heading as a delimiter:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如标记所示，每个标题都位于文本块之上，提供了完美的标记。使用开头的`h6`标题作为分隔符，我们应该在数组中有四个项目。现在让我们看看当我们使用开头的`h6`标题作为分隔符应用`split`过滤器时会发生什么：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Based on our markup, after applying the `split` filter with the opening `h6`
    heading as a delimiter, the first item in our array should be empty, as there
    is no content before the first occurrence of our delimiter. The other three should
    contain both the heading and any content between the first and the following delimiter
    occurrence:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的标记，在应用以开头的`h6`标题作为分隔符的`split`过滤器后，数组中的第一个项目应该是空的，因为没有内容在分隔符第一次出现之前。其他三个应该包含标题以及第一个和后续分隔符出现之间的任何内容：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Looking over the results, we can see that we were successful in extracting
    each product description block. However, there are still a few things to cover.
    For example, we will have one empty `div`, which we can quickly resolve by introducing
    the `offset` parameter and setting its value to `1`, allowing us to skip the first
    iteration within the `for` loop. We can remind ourselves of the `offset` parameter
    by visiting the *Iterations tags* section located in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果，我们可以看到我们成功地提取了每个产品描述块。然而，还有一些事情需要讨论。例如，我们将有一个空的`div`，我们可以通过引入`offset`参数并将其值设置为`1`来快速解决，这样我们就可以在`for`循环中跳过第一次迭代。我们可以通过访问位于[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)的*迭代标签*部分来提醒自己`offset`参数，*深入Liquid核心使用标签*：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Adding the `offset` parameter to the `for` tag will skip the first iteration,
    otherwise returning an empty value. Additionally, we have ensured that our array
    only contains the three product description blocks we initially intended. However,
    let''s take a closer look at the current results of our array after applying the
    `offset` parameter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将`offset`参数添加到`for`标签中将会跳过第一次迭代，否则将返回一个空值。此外，我们已经确保我们的数组只包含我们最初打算的三个产品描述块。然而，让我们更仔细地看看在应用了`offset`参数后的数组当前结果：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we recall, by using the opening `h6` heading as a substring to the `split`
    filter, we will automatically remove any opening `h6` heading within the initial
    string. However, notice that we have not only removed the opening `h6` tag but
    we have also removed the closing `h6` tag.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所回忆的，通过使用打开的 `h6` 标题作为 `split` 过滤器的子字符串，我们将自动移除初始字符串中的任何打开的 `h6` 标题。然而，请注意，我们不仅移除了打开的
    `h6` 标签，我们还移除了关闭的 `h6` 标签。
- en: Technically, the closing `h6` tag is still there, located after the closing
    `span` tag. However, since we have removed the opening `h6` tag, the browser interpreted
    this as an error and automatically removed the closing `h6` tag. So, instead of
    relying on the browser to clean up, let's use the closing `h6` tag to divide our
    three blocks further.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，关闭的 `h6` 标签仍然存在，位于关闭的 `span` 标签之后。然而，由于我们移除了打开的 `h6` 标签，浏览器将其解释为错误并自动移除了关闭的
    `h6` 标签。因此，我们不要依赖浏览器来清理，而是使用关闭的 `h6` 标签进一步划分我们的三个块。
- en: 'Currently, each item variable inside the `for` loop contains both the heading
    and the content text. By applying the `split` filter using the closing `h6` heading,
    we will modify the `item` variable into an array of its own, containing the heading
    and the content. So, instead of using another `for` loop to loop over those, let''s
    recall the `first` and `last` filters that we previously mentioned and use them
    here to recover each value separately:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`for` 循环内部的每个 `item` 变量都包含标题和内容文本。通过使用关闭的 `h6` 标题应用 `split` 过滤器，我们将 `item`
    变量修改为一个包含标题和内容的数组。因此，我们不必使用另一个 `for` 循环来遍历这些内容，让我们回忆一下之前提到的 `first` 和 `last` 过滤器，并在这里使用它们来分别恢复每个值：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By applying the `split` filter again, we have removed the leftover closing `h6`
    tag. Additionally, we have separated the content more clearly, allowing us to
    use the results to complete our mini project more easily.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次应用 `split` 过滤器，我们移除了剩余的关闭 `h6` 标签。此外，我们更清晰地分离了内容，这使得我们可以更轻松地使用结果来完成我们的迷你项目。
- en: 'At this point, we possess all the necessary elements to finalize the product
    accordions project. The only thing left is to include some styling and introduce
    the script to handle the on-input animation. To keep everything concise, we will
    not cover the styling and functionality within this project. However, we will
    provide the final expectation to help us visualize a clear goal that we should
    work on, as it will serve as an excellent practice for future work:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了完成产品折叠项目所需的所有必要元素。唯一剩下的事情就是添加一些样式并引入处理输入动画的脚本。为了保持简洁，我们不会在这个项目中涵盖样式和功能。然而，我们将提供最终期望，以帮助我们可视化一个清晰的目标，这将作为未来工作的优秀实践：
- en: '![Figure 5.6 – Example of a complete product accordions project'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 完整产品折叠项目的示例'
- en: '](img/Figure_5.06_B17606.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.06 – Figure_5.06_B17606.jpg]'
- en: Figure 5.6 – Example of a complete product accordions project
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 完整产品折叠项目的示例
- en: 'So far, we have learned how to manipulate string variables by turning them
    into an array type variable and using them to create the product accordions feature.
    In addition, we have learned about the `split` and `first`/`last` filters that
    we included using the pipeline character. However, specific filters, such as `size`,
    can be used with pipeline and dot annotation, depending on the situation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何通过将字符串变量转换为数组类型变量并使用它们来创建产品折叠功能来操作字符串变量。此外，我们还了解了使用管道字符包含的 `split`
    和 `first`/`last` 过滤器。然而，根据情况，特定的过滤器，如 `size`，可以与管道和点注释一起使用：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the previous example, we have created a `message` variable and have assigned
    a short string to it. Using the `size` filter with the `message` variable, we
    will render the total number of characters within the message string. However,
    by using the size with the dot annotation, we gained the ability to use the `size`
    filter as part of Liquid logic:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个 `message` 变量并将其分配了一个简短的字符串。使用 `size` 过滤器和 `message` 变量，我们将渲染消息字符串中的字符总数。然而，通过使用点注释的
    `size`，我们获得了将 `size` 过滤器作为 Liquid 逻辑一部分的能力：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can also use the `size` filter to improve our product accordions by including
    an `if` statement that will check whether the product description has more than
    `1` block of code and render the product accordions if it does. Otherwise, it
    should simply output the regular product description:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `size` 过滤器通过包含一个检查产品描述是否超过 `1` 个代码块的 `if` 语句来改进我们的产品折叠。如果没有，它应该简单地输出常规的产品描述：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the introduction of the `size` filter, we have made our code a lot cleaner
    and more optimized, as we will not run a `for` loop for a single item inside the
    array type variable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`size`过滤器的引入，我们使代码变得更加简洁和优化，因为我们不需要在数组类型变量中的单个项目上运行`for`循环。
- en: As we can see, by simply using everyday filters, we can improve our code significantly.
    For example, *what if we wanted to split the product description and render the
    content into various places and not simply output them all at once?* For this,
    we will need to use a combination of the `split`, `first`/`last`, and `index`
    filters. We have already covered the `split` and `first`/`last` filters, *but
    what does the* `index` *filter do?*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，仅通过使用日常过滤器，我们就可以显著提高我们的代码质量。例如，*如果我们想将产品描述拆分并渲染到各个地方，而不是一次性输出所有内容，那会怎么样？*为此，我们需要使用`split`、`first`/`last`和`index`过滤器的组合。我们已经涵盖了`split`和`first`/`last`过滤器，*但`index`过滤器究竟做什么呢？*
- en: The index filter
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引过滤器
- en: 'As its name suggests, the `index` filters allow us to access a specific array
    using its index location, starting from 0\. Let''s try to apply the index location
    to our product accordions project. Note that we will no longer have any need for
    the `for` tag, as we will be accessing the `productDescription` variable directly
    through the `index` filter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所暗示的，`index`过滤器允许我们通过其索引位置访问特定的数组，起始位置为0。让我们尝试将索引位置应用于我们的产品折叠项目。请注意，我们将不再需要`for`标签，因为我们将通过`index`过滤器直接访问`productDescription`变量：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The previous code will return the first heading and block of text from our product
    description. However, we have mentioned that the index position starts at `0`,
    *so why is position* `1` *returning the results of the first block?*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将返回产品描述中的第一个标题和文本块。然而，我们提到索引位置从`0`开始，*那么为什么位置`1`返回的是第一个块的输出结果？*
- en: As we recall, since we have used the opening `h6` tag as a delimiter to our
    `split` filter, the first item in our array is empty. Previously we skipped the
    first item inside the array by including the `offset` parameter, whereas now we
    will simply skip the *first index position*, which is `0`. The downside of this
    method is that we will have to repeat the code to recover each block separately.
    However, on the plus side, we gain the flexibility of positioning them at the
    place of our choosing, which sometimes will be necessary.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所回忆的，因为我们已经使用`h6`标签作为`split`过滤器的分隔符，所以我们的数组中的第一个项目是空的。之前我们通过包含`offset`参数来跳过数组中的第一个项目，而如今我们将简单地跳过*第一个索引位置*，即`0`。这种方法的不利之处在于，我们将不得不重复代码来分别恢复每个块。然而，从积极的一面来看，我们获得了在任意位置定位它们的灵活性，这在某些情况下可能是必要的。
- en: 'Tip:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on all the available string filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/string-filters](https://shopify.dev/docs/themes/liquid/reference/filters/string-filters).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解所有可用的字符串过滤器信息，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/string-filters](https://shopify.dev/docs/themes/liquid/reference/filters/string-filters)。
- en: For additional information on all the available array filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/array-filters](https://shopify.dev/docs/themes/liquid/reference/filters/array-filters).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解所有可用的数组过滤器信息，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/array-filters](https://shopify.dev/docs/themes/liquid/reference/filters/array-filters)。
- en: We saw how somewhat insignificant filters could be a powerful tool that will
    allow us to create complex features that merchants regularly seek. Through this
    type of learning process, we gain valuable lessons by working on a real-life project,
    but we also learn how to deal with various types of filters, which is a lot more
    essential than simply listing them all.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一些看似微不足道的过滤器如何成为一个强大的工具，它将使我们能够创建商家经常寻求的复杂特征。通过这种学习过程，我们在实际项目上工作，获得了宝贵的经验教训，同时也学会了如何处理各种类型的过滤器，这比简单地列出它们要重要得多。
- en: Math and money filters
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学与货币过滤器
- en: In the previous chapter, we had a chance to see money filters in action while
    working on the `Custom collections` project. **Money filters** are simple types
    of filters whose only task is to format the number value based on the currency
    formatting options, *but what exactly does this mean?*
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在`Custom collections`项目上工作时有机会看到货币过滤器在实际中的应用。**货币过滤器**是一种简单的过滤器类型，其唯一任务是根据货币格式化选项格式化数值，*但这究竟意味着什么？*
- en: To better understand, let's navigate to our admin page and click on the **Settings**
    button in the bottom-left corner. Consequently, click on the **General** option
    to open where we will be able to update the store's basic information. Once inside,
    scroll down until you have reached the section named **Store currency**. This
    is where we can change the store's default currency, which our customers will
    use to make their purchases. Instead of changing the store currency, let's click
    on the **Change formatting** button.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们导航到我们的管理页面，并点击左下角的**设置**按钮。随后，点击**常规**选项以打开我们将能够更新商店的基本信息。一旦进入，向下滚动直到你到达名为**商店货币**的部分。这就是我们可以更改商店默认货币的地方，我们的客户将使用它来购买商品。而不是更改商店货币，让我们点击**更改格式化**按钮。
- en: '![Figure 5.7 – Location of the store currency formatting'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.7 – 商店货币格式化的位置'
- en: '](img/Figure_5.07_B17606.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.07_B17606.jpg]'
- en: Figure 5.7 – Location of the store currency formatting
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 商店货币格式化的位置
- en: By clicking the **Change formatting** button, we will reveal additional currency
    formatting options where we can define the global markup for the currency formatting
    that the money filter will later use to format any number value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**更改格式化**按钮，我们将揭示额外的货币格式化选项，在这里我们可以定义全局标记，该标记将供货币过滤器稍后用于格式化任何数值。
- en: If we were to apply the money filter to any number value, based on the formatting
    settings, the only change that we would see is that we would see a dollar sign
    before the price and USD after the price. So, let's try to modify these two fields
    to include some more helpful markup.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将货币过滤器应用于任何数值，根据格式化设置，我们唯一会看到的变化是在价格前有一个美元符号，在价格后有一个USD。所以，让我们尝试修改这两个字段以包含一些更有帮助的标记。
- en: We can edit the first two fields named `span` tag with the `money` class. However,
    note that when writing a `money` class, we should not include quote marks. Otherwise,
    we risk breaking the currency formatting.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编辑名为`span`标签的`money`类的第一个两个字段。然而，请注意，在编写`money`类时，我们不应包括引号。否则，我们可能会破坏货币格式化。
- en: '![Figure 5.8 – Example of updating the store currency formatting'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.8 – 更新商店货币格式的示例'
- en: '](img/Figure_5.08_B17606.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.08_B17606.jpg]'
- en: Figure 5.8 – Example of updating the store currency formatting
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 更新商店货币格式的示例
- en: By including the `span` tag with the `money` class inside the currency formatting,
    we have now ensured that each pricing element in our store will contain the same
    selector, which will help if we need to update the pricing dynamically.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在货币格式化中包含带有`money`类的`span`标签，我们现在确保了我们的商店中的每个定价元素都将包含相同的选择器，这有助于我们在需要动态更新定价时。
- en: On the other hand, **math filters** are self-explanatory, as they allow us to
    perform specific mathematical tasks. Similarly, as with the string and array filters,
    we can chain multiple math filters inside one line, in which case, the filters
    will apply in order from left to right.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**数学过滤器**是自我解释的，因为它们允许我们执行特定的数学任务。同样，与字符串和数组过滤器一样，我们可以在一行中链式调用多个数学过滤器，在这种情况下，过滤器将按从左到右的顺序应用。
- en: Now that we have familiarized ourselves with the money and math filters, let's
    see them in action and start working on our next mini project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了货币和数学过滤器，让我们看看它们在实际中的应用，并开始我们的下一个迷你项目。
- en: Product discount price
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品折扣价格
- en: In the following project, we will be learning about the math and money filters
    by working on one of the projects we started in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, which is `Custom collection`, located
    under the *Global Objects* section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下项目中，我们将通过工作于我们在[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)中开始的项目之一，*使用对象深入Liquid核心*，来学习数学和货币过滤器，该项目是位于**全局对象**部分的**自定义收藏夹**。
- en: We aim to create the product discount price and update the sale badge to display
    an actual percentage discount. Let's start by navigating to the location of the
    code that we have previously developed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建产品折扣价格并更新销售徽章以显示实际百分比折扣。让我们首先导航到我们之前开发的代码位置。
- en: 'We created the `Custom collection` feature by including the `collection-form.liquid`
    snippet inside the `collection.liquid` file, located under the `Templates` directory.
    Inside the `collection-form.liquid` snippet, we will see the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`Templates`目录下的`collection.liquid`文件中包含`collection-form.liquid`片段来创建`Custom
    collection`功能。在`collection-form.liquid`片段中，我们将看到以下代码：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the current setup, we display both the regular price and the comparison
    price, so let's start by modifying the comparison price and replacing it with
    the actual discount price. To output the discount between the two prices, it should
    be relatively straightforward as we only need to subtract the regular price from
    the comparison price.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前设置，我们同时显示正常价格和比较价格，所以让我们先修改比较价格，并用实际折扣价格替换它。要输出两个价格之间的折扣，应该相对简单，因为我们只需要从比较价格中减去正常价格。
- en: 'To subtract the regular price from the comparison price, we will need to use
    the `minus` math filter:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要从比较价格中减去正常价格，我们需要使用`minus`数学过滤器：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice that with the introduction of the `minus` filter, we had to remove the
    `money` filter entirely. As previously mentioned, we can only use math filters
    if all the values are number values. If we were to include `money` filters, we
    would turn both values into a string due to our previously set currency formatting.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，随着`minus`过滤器的引入，我们必须完全删除`money`过滤器。如前所述，我们只能在所有值都是数值值的情况下使用数学过滤器。如果我们包含`money`过滤器，由于我们之前设置的货币格式化，这两个值都会变成字符串。
- en: Now that we have successfully applied the `minus` filter, we need to think of
    a way to include the `money` filter. With the current setup, we have received
    a number value without any currency formatting. However, as mentioned, if we were
    to apply the `money` filter to any of the two values, even after `product.price`,
    the `money` filter would only affect `product.price`, not the final results. Consequently,
    the math filter would no longer work.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功应用了`minus`过滤器，我们需要考虑如何包含`money`过滤器。根据当前设置，我们收到了一个没有货币格式的数值。然而，如前所述，如果我们对任何两个值应用`money`过滤器，即使是在`product.price`之后，`money`过滤器只会影响`product.price`，而不会影响最终结果。因此，数学过滤器将不再工作。
- en: 'To resolve this, we would need to introduce a variable using an `assign` or
    `capture` keywords to calculate the difference between the two numbers and later
    call the variable with the `money` filter:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使用`assign`或`capture`关键字引入一个变量来计算两个数字之间的差异，然后使用`money`过滤器调用该变量：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If we preview our collection page now, we will see that we have correctly performed
    both the discount price calculations and the currency formatting. So now we can
    move to the second part of our project, which is replacing the sale badge with
    an actual percentage value discount.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在预览我们的收藏页面，我们将看到我们已经正确执行了折扣价格计算和货币格式化。所以现在我们可以转到我们项目的第二部分，即用实际百分比值折扣替换销售徽章。
- en: 'We can find the sale badge HTML code within the same `collection-form.liquid`
    snippet file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个`collection-form.liquid`代码片段文件中找到销售徽章的HTML代码：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To calculate the discounted percentage, we can use the following formula, which
    will return the discounted percentage:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算折扣百分比，我们可以使用以下公式，该公式将返回折扣百分比：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the previous example, we had to include the calculation inside a variable
    so that later we could apply the `money` filter. However, since this time we do
    not need money, we can simply include the calculation with the addition of the
    percentage string at the end. Let''s put it all together now:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们必须在变量内包含计算，以便稍后可以应用`money`过滤器。然而，由于这次我们不需要货币，我们可以简单地包含计算，并在末尾添加百分比字符串。现在让我们把它全部放在一起：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we had the chance to see, similarly as with the string filters, we could
    chain multiple math filters easily to perform the calculations we needed. However,
    it is worth mentioning that besides only working with number values, math filters
    do not accept any type of brackets, which we would usually use to perform math
    calculations in specific priority.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，与字符串过滤器类似，我们可以轻松地链式调用多个数学过滤器以执行所需的计算。然而，值得注意的是，除了仅与数值值一起工作外，数学过滤器不接受任何类型的括号，我们通常使用括号来执行具有特定优先级的数学计算。
- en: If we need to perform calculations, we have two choices. The first one is that
    we let Liquid perform math calculations from left to right. On the other hand,
    if we need to perform calculations in a specific order, we will need to split
    the formula into multiple variables and combine the results later.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行计算，我们有两个选择。第一个是我们让Liquid从左到右执行数学计算。另一方面，如果我们需要按照特定顺序执行计算，我们需要将公式拆分为多个变量，并在稍后组合结果。
- en: 'Tip:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on all the available math filters, we can refer to
    [https://shopify.dev/docs/themes/liquid/reference/filters/math-filters](https://shopify.dev/docs/themes/liquid/reference/filters/math-filters).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有可用数学过滤器的更多信息，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/math-filters](https://shopify.dev/docs/themes/liquid/reference/filters/math-filters)。
- en: For additional information on all the available money filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/money-filters](https://shopify.dev/docs/themes/liquid/reference/filters/money-filters).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有可用货币过滤器的更多信息，我们可以参考[https://shopify.dev/docs/themes/liquid/reference/filters/money-filters](https://shopify.dev/docs/themes/liquid/reference/filters/money-filters)。
- en: While we have not covered all the math and money filter types, we have gained
    a solid understanding of how both math and money filters work through this project.
    This type of knowledge will serve as a stepping stone for the features that we
    will be working on as Shopify experts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有涵盖所有的数学和货币过滤器类型，但我们通过这个项目对数学和货币过滤器的工作原理有了坚实的理解。这种知识将作为我们在Shopify专家工作中将要开发的特性的垫脚石。
- en: Exploring the additional filters
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索附加过滤器
- en: The **additional filters** are a set of filters that do not fit under any other
    filter groups. However, this does not make them any less important. While there
    are many types of filters that we can name here, we will only mention three of
    them that are the most essential as we will be using them regularly.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加过滤器**是一组不属于任何其他过滤器组的过滤器。然而，这并不意味着它们不重要。虽然我们可以命名许多类型的过滤器，但我们将只提到其中三个最重要的，因为我们将经常使用它们。'
- en: The default filter
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认过滤器
- en: 'As its name suggests, the `nil`, `false`, or an empty string. If the variable
    contains whitespace characters, we will not be able to return the `default` value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`nil`、`false`或一个空字符串。如果变量包含空白字符，我们将无法返回`default`值：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By introducing the `default` value in the previous example, we have ensured
    that we will not end up with a broken string even if the customer has not provided
    us with their name. Additionally, we also make our code look a lot cleaner. Without
    the `default` filter, we would have to use an `if` statement to check whether
    `customer.name` exists, and depending on the results, output the value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前面示例中引入`default`值，我们确保了即使客户没有提供他们的名字，我们也不会得到一个损坏的字符串。此外，我们还使我们的代码看起来更加整洁。如果没有`default`过滤器，我们就必须使用`if`语句来检查`customer.name`是否存在，并根据结果输出值。
- en: The t (translation) filter
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: t（翻译）过滤器
- en: The `Locales` directory. If we navigate to the `Locales` directory, we will
    notice a large number of files. However, one of them will contain the string default,
    which is the currently active language in our store.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Locales`目录。如果我们导航到`Locales`目录，我们会注意到大量的文件。然而，其中之一将包含默认字符串，这是我们商店中当前活动的语言。'
- en: Let's look over one of our previous projects, `Custom collections`, which we
    worked on in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving
    into Liquid Core with Objects*, in the *Working with global objects* section,
    where we developed a submit button whose value we hardcoded with the text **Add
    to Cart**. This works well for now, *but what if we changed our store language?*
    We would have to update any occurrence of the **Add to Cart** string manually
    for the entire theme.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们之前的一个项目，`自定义收藏夹`，我们在[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，“使用对象深入液态核心”部分进行了工作，在*使用全局对象*部分，我们开发了一个提交按钮，其值我们硬编码为文本**添加到购物车**。这对于现在来说效果不错，*但如果我们更改了我们的商店语言呢？*我们就必须手动更新整个主题中**添加到购物车**字符串的任何出现。
- en: 'Using the `t` filter, we can update any string value through our entire theme
    by updating a single value. The first thing that we need to do is to define the
    three-level JSON inside the currently active language file using the Shopify naming
    and grouping guidelines. Since we are looking to modify the submit button of a
    product, we can set the first level to product, the second to something more specific,
    which is the form itself, and finally, the third level points to the string we
    are looking to translate:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`t`过滤器，我们可以通过更新单个值来更新整个主题中的任何字符串值。我们首先需要做的是，根据Shopify的命名和分组指南，在当前活动的语言文件中定义三级JSON。由于我们正在修改产品的提交按钮，我们可以将第一级设置为产品，第二级设置为更具体的内容，即表单本身，最后，第三级指向我们要翻译的字符串：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once we have successfully created the JSON inside the language file, all that
    is left is to use the `t` filter to read the translated key value and render it
    on the storefront:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在语言文件中成功创建了 JSON，剩下的就是使用 `t` 过滤器来读取翻译键值并将其渲染在店面上了：
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By implementing a `t` filter on all product forms, we will gain the ability
    to automatically translate all the strings without having to search for them throughout
    our files manually. Additionally, using the same JSON naming and grouping inside
    the other language files will allow us to quickly translate our entire theme by
    simply changing the store language.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在所有产品表单上实现 `t` 过滤器，我们将获得自动翻译所有字符串的能力，而无需手动在文件中搜索它们。此外，在其它语言文件中使用相同的 JSON 命名和分组将允许我们通过简单地更改商店语言来快速翻译整个主题。
- en: 'The `t` filter is a powerful tool that allows us to pass multiple arguments
    by separating them with commas and interpolating them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`t` 过滤器是一个强大的工具，它允许我们通过逗号分隔来传递多个参数并进行插值：'
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the previous example, we are trying to access the customer string inside
    the language file. However, we have also passed the `customer.name` value as an
    argument, which we have then interpolated inside the language JSON file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们试图访问语言文件中的客户字符串。然而，我们还将 `customer.name` 值作为参数传递，然后在语言 JSON 文件中进行了插值：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Besides providing us with the ability to interpolate the variables, we can also
    escape the translated content, include the HTML in translation keys, and pluralize
    translation keys, making it a pretty powerful tool at our disposal.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供变量插值的能力外，我们还可以转义翻译内容，将 HTML 包含在翻译键中，并对翻译键进行复数化，使其成为我们可用的相当强大的工具。
- en: 'Tip:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on the `t` filter naming and grouping guidelines,
    we can refer to [https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `t` 过滤器命名和分组指南的更多信息，我们可以参考 [https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys)。
- en: For additional information on all the available arguments for the `t` filter,
    we can refer to [https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `t` 过滤器所有可用参数的更多信息，我们可以参考 [https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys)。
- en: Once we have created the necessary translation keys, we can also update the
    translation by navigating to our admin page and clicking on **Themes** located
    inside the expanded **Online store** option within the sidebar. Clicking on the
    **Actions** button on the theme file will trigger a dropdown, whereby clicking
    on **Edit Language** will quickly update any translation inside the language JSON
    file.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了必要的翻译键，我们也可以通过导航到我们的管理页面，点击侧边栏中展开的 **在线商店** 选项内的 **主题** 来更新翻译。点击主题文件上的
    **操作** 按钮将触发一个下拉菜单，点击 **编辑语言** 将快速更新语言 JSON 文件中的任何翻译。
- en: The JSON filter
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 过滤器
- en: 'The JSON filter, as its name suggests, allows us to convert strings into JSON,
    and more importantly, will make Liquid code readable by JavaScript:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，JSON 过滤器允许我们将字符串转换为 JSON，更重要的是，它将使 Liquid 代码对 JavaScript 可读：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that when using the JSON filter on Liquid output, there is no need to include
    quotations marks, as the JSON filter will include them automatically. However,
    note that specific values, such as the `inventory_quantity` and `inventory_policy`
    fields, are not something that we can return via JSON, as Shopify has deprecated
    these fields due to security reasons.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在 Liquid 输出中使用 JSON 过滤器时，无需包含引号，因为 JSON 过滤器会自动包含它们。然而，请注意，特定的值，例如 `inventory_quantity`
    和 `inventory_policy` 字段，不是我们可以通过 JSON 返回的内容，因为 Shopify 由于安全原因已弃用这些字段。
- en: 'Tip:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: For additional information on all the available additional filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters](https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有可用附加过滤器的更多信息，我们可以参考 [https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters](https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters)。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how using something trivial such as a filter
    to manipulate different data types can create powerful features. We have learned
    how using URL and HTML filters can provide us with access to the various types
    of assets throughout Shopify and help us generate them in the storefront using
    their respective HTML tags.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用一些琐碎的东西，如过滤器来操作不同的数据类型，从而创建强大的功能。我们学习了如何使用URL和HTML过滤器为我们提供访问Shopify中各种类型资产的方法，并帮助我们使用相应的HTML标签在店面中生成它们。
- en: Working on the product media gallery project has provided us with a deeper understanding
    of media objects and filters, which every developer needs to be familiar with.
    The product accordions project taught us how to easily manipulate data using string
    and array filters to create unique page content elements that are clean and easily
    maintainable. Moving on to the math and money filters, we have gained much-needed
    insight into performing complex calculations through Shopify and formatting the
    prices according to the currency formatting set in our store.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品媒体画廊项目中工作，使我们更深入地理解了媒体对象和过滤器，这是每个开发者都需要熟悉的。产品折叠面板项目教会了我们如何使用字符串和数组过滤器轻松地操作数据，以创建独特且易于维护的页面内容元素。继续到数学和货币过滤器，我们获得了通过Shopify执行复杂计算以及根据我们店铺中设置的货币格式化价格所需的重要见解。
- en: Lastly, we learned about the additional filters, which provided us with essential
    knowledge on how we can assign default value variables with no assigned values
    and make Liquid code readable by JavaScript. By understanding how to use the translation
    keys, we now have the necessary knowledge to quickly update any value across our
    theme without manually updating each value.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了额外的过滤器，这些过滤器为我们提供了如何使用没有指定值的默认值变量以及如何使Liquid代码可通过JavaScript读取的基本知识。通过理解如何使用翻译键，我们现在拥有了快速更新主题中任何值所需的知识，而无需手动更新每个值。
- en: The knowledge that we have attained through this chapter will be especially
    helpful in the next chapter, where we will learn more about the JSON settings
    and how we can use them to create settings that merchants can access using the
    theme editor.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章所学到的知识，在下一章中我们将学习更多关于JSON设置以及如何使用它们来创建商家可以通过主题编辑器访问的设置时，将特别有用。
- en: Questions
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Suppose that we have an array named `product_handles` with handles of 30 products.
    What issue in the following code would prevent us from outputting the images of
    all 30 products successfully?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `product_handles` 的数组，包含30个产品的处理程序。以下代码中的哪个问题会阻止我们成功输出所有30个产品的图片？
- en: '[PRE59]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Why is only using the `model_viewer_tag` tag not recommended when creating the
    product media gallery?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不建议在创建产品媒体画廊时仅使用 `model_viewer_tag` 标签？
- en: '[PRE60]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Which filter could we use if we were looking to access an item at a specific
    location inside the array?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要访问数组中的特定位置的项，可以使用哪个过滤器？
- en: What filter can we use to quickly update any occurrence of a string value inside
    the theme files?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个过滤器来快速更新主题文件中任何字符串值的出现？
- en: Practice makes perfect
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟能生巧
- en: Project 3
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 3
- en: In one of our previous exercises, we learned how to create basic and complex
    product galleries by outputting all types of product media types. *However, what
    if we only needed to output several images related to the specific variant at
    a time?*
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的练习中，我们学习了如何通过输出所有类型的商品媒体类型来创建基本和复杂的产品画廊。*然而，如果我们一次只需要输出与特定变体相关的几个图片呢？*
- en: For our third project, we will be working on rendering a product media gallery
    with distinctive markings that will allow us to show only the thumbnails of the
    currently selected variant.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第三个项目中，我们将致力于渲染一个具有独特标记的产品媒体画廊，这将使我们能够仅显示当前所选变体的缩略图。
- en: 'Here are the instructions for the assets:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是资产的说明：
- en: Create a new page template using the name `variant-thumbnails.liquid`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称为 `variant-thumbnails.liquid` 的新页面模板。
- en: Create a new page named `Product Variant Thumbnails`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Product Variant Thumbnails` 的新页面。
- en: Create a new layout file with the name `alternate.liquid`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称为 `alternate.liquid` 的新布局文件。
- en: Create a new product with at least three color variants and upload at least
    three media assets to represent each variant. When creating a new product, we
    should set the product status to Active and not leave it to Draft. Otherwise,
    we will not be able to access it later.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建至少包含三种颜色变体的新产品，并为每个变体上传至少三种媒体资产。在创建新产品时，我们应该将产品状态设置为“活动”，而不是将其保留为“草稿”。否则，我们以后将无法访问它。
- en: Create two new asset files, a stylesheet with the name `custom.css` and a script
    file with the name `script.js`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新的资产文件，一个名为 `custom.css` 的样式表文件和一个名为 `script.js` 的脚本文件。
- en: Create a new snippet file with the name `custom-media`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `custom-media` 的新代码片段文件。
- en: 'The following are the steps for the assignment:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为任务分配的步骤：
- en: Edit the new layout file by including two asset files that we have previously
    used throughout this project.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过包含我们在此项目中所使用的两个资产文件来编辑新的布局文件。
- en: Include the layout file to the previously created page template and assign the
    new page template to the newly created page.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局文件包含到之前创建的页面模板中，并将新的页面模板分配给新创建的页面。
- en: Navigate to the `red_This` is an image description. Repeat the process for all
    images. Note that each variant should have at least three images to it.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `red_This` 是一个图像描述。为所有图像重复此过程。请注意，每个变体至少应有三个图像。
- en: Inside `variant-thumbnails.liquid`, create a variable that we will use to access
    the previously created product object using the product handle.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `variant-thumbnails.liquid` 内部，创建一个变量，我们将使用该变量通过产品处理来访问之前创建的产品对象。
- en: Using a `for` loop, access the product media object, and pass the media object
    inside the `custom-media` snippet as a parameter.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环访问产品媒体对象，并将媒体对象作为参数传递到 `custom-media` 代码片段中。
- en: Inside the snippet, using the case-control flow tag and the object that we have
    passed as a parameter, create code that will output each media file type.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码片段内部，使用情况控制流标签和作为参数传递的对象，编写代码以输出每种媒体文件类型。
- en: Edit each `media` tag to include three attributes. The first one, `data-variant`,
    will contain the first part of the media alt text before the underscore. The second
    attribute, `alt`, will contain the second part of the media alt text. Finally,
    the third attribute, named `index`, will contain the index position value of the
    media file. If we are having trouble calling the `forloop` object's index value
    directly inside the snippet, we might want to pass it as a parameter through the
    snippet.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑每个 `media` 标签，包括三个属性。第一个属性，`data-variant`，将包含下划线之前媒体 alt 文本的第一个部分。第二个属性，`alt`，将包含媒体
    alt 文本的第二个部分。最后，第三个属性，命名为 `index`，将包含媒体文件的索引位置值。如果我们直接在代码片段内部调用 `forloop` 对象的索引值有困难，我们可能需要通过代码片段将其作为参数传递。
- en: With the attributes in place, we should have all the necessary elements needed
    to filter out product media files and only display the thumbnails related to the
    currently selected color variant using the `data-variant` attribute value.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好属性后，我们应该拥有过滤产品媒体文件并仅使用 `data-variant` 属性值显示与当前所选颜色变体相关的缩略图所需的所有必要元素。
- en: 'For those looking to finalize the project, follow these steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想要完成项目的人来说，请遵循以下步骤：
- en: Apply the necessary styling inside `custom.css` and the necessary script inside
    `script.js` that will hide or display only the media files with the correct `data-attribute`
    value.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `custom.css` 中应用必要的样式，并在 `script.js` 中应用必要的脚本，以隐藏或仅显示具有正确 `data-attribute`
    值的媒体文件。
- en: Additionally, we can create a new `for` loop that will serve as a primary media
    gallery.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以创建一个新的 `for` 循环，作为主要媒体库使用。
- en: Include any type of slider plugin, such as a Slick slider, and connect it to
    the primary media gallery.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含任何类型的滑块插件，例如 Slick 滑块，并将其连接到主要媒体库。
- en: Clicking on the thumbnail media asset should automatically make the primary
    slider scroll to the selected asset.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击缩略图媒体资产应自动使主滑块滚动到所选资产。
