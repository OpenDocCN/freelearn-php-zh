- en: '[*Chapter 7*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131): Working with
    Static and Dynamic Sections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第七章*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131)《处理静态和动态部分》'
- en: In the previous chapter, we familiarized ourselves with the different types
    of inputs, whether they're basic or specialized, and how we can use them to create
    global settings that we can easily configure through the theme editor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们熟悉了不同类型的输入，无论是基本的还是专业的，以及我们如何使用它们来创建可以通过主题编辑器轻松配置的全局设置。
- en: In this chapter, we will not only get to use the previously mentioned inputs,
    but we will also learn how to create easily configurable and reusable sections
    that we can use to change the page or even templates' layouts easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将使用之前提到的输入，还将学习如何创建易于配置和可重复使用的部分，我们可以使用这些部分来轻松更改页面或模板的布局。
- en: 'We will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Static versus dynamic sections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态部分与动态部分
- en: Working with the section schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与部分架构一起工作
- en: Building with blocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用块构建
- en: Enhancing pages with JSON templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON模板增强页面
- en: Exploring section-specific tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索特定于部分的标签
- en: By the time we complete this chapter, we will understand what sections are,
    when to use them, and how to create one. We will also learn about the difference
    between static and dynamic sections, and how we can configure them through the
    theme editor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后，我们将了解部分是什么，何时使用它们，以及如何创建一个部分。我们还将了解静态部分与动态部分之间的区别，以及我们如何通过主题编辑器来配置它们。
- en: By learning about the section schema and the different attributes that we can
    use, we will also learn how to create reusable block modules within a section
    that we can use to repeat and receive different results. After familiarizing ourselves
    with sections and blocks, we will learn how to improve these concepts by learning
    about JSON templates and built-in metafields. Lastly, we will learn about the
    different types of specialized tags that we can use within section files, which
    will help us create reusable and dynamic modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解部分架构和我们可以使用的不同属性，我们还将学习如何在部分内创建可重复使用的模块，我们可以使用这些模块来重复操作并获得不同的结果。在熟悉了部分和块之后，我们将通过学习JSON模板和内置元字段来提高这些概念。最后，我们将了解在部分文件内可以使用的不同类型的专用标签，这将帮助我们创建可重复使用和动态的模块。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While we will explain each topic and have it presented with the accompanying
    graphics, we will need an internet connection to follow the steps outlined in
    this chapter, considering that Shopify is a hosted service.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将解释每个主题并配合相应的图形展示，但考虑到Shopify是一个托管服务，我们需要互联网连接来跟随本章中概述的步骤。
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07)。
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3hQzhVg](https://bit.ly/3hQzhVg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在这里找到：[https://bit.ly/3hQzhVg](https://bit.ly/3hQzhVg)
- en: Static versus dynamic sections
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态部分与动态部分
- en: In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Shopify*, while discussing the theme structure, we briefly mentioned section
    files, *but what exactly are sections?*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015)《Shopify入门》中，当我们讨论主题结构时，简要提到了部分文件，*但部分究竟是什么呢？*
- en: Besides being the name of one of the directories in the theme file, a **section**
    is a type of file that allows us to create reusable modules that we can customize
    using the theme editor, as we learned previously. However, as opposed to the global
    settings that we have learned about, the major difference is that the JSON settings
    for sections are defined inside each section file and are section-specific.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是主题文件中的一个目录名称之外，*部分*是一种文件类型，它允许我们创建可重复使用的模块，我们可以使用主题编辑器来定制这些模块，正如我们之前所学的。然而，与我们所学的全局设置相比，主要区别在于部分的JSON设置是在每个部分文件内部定义的，并且是针对特定部分的。
- en: Section-specific settings allow us to reuse the same section module multiple
    times on the page and select a different set of options for each occurrence, making
    it a pretty powerful feature. For example, we can create a featured collections
    section and repeat it three times to display three products from three separate
    collections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 特定部分的设置允许我们在页面上多次使用相同的部分模块，并为每个出现选择不同的选项集，这使得它成为一个相当强大的功能。例如，我们可以创建一个特色收藏部分，并重复三次以显示来自三个不同收藏的三种产品。
- en: 'Before we proceed, let''s navigate to the theme editor by clicking the **Customize**
    button from the code editor and see the section files in action. Clicking the
    **Customize** button will automatically open the theme editor and position us
    on the home page, with the page preview on the right-hand side and a sidebar on
    the left. Within the sidebar, we can see several sections that are available on
    this specific page:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们通过从代码编辑器中点击**自定义**按钮来导航到主题编辑器，并查看部分文件的实际效果。点击**自定义**按钮将自动打开主题编辑器，并将我们定位在主页上，页面预览在右侧，侧边栏在左侧。在侧边栏中，我们可以看到此特定页面上可用的几个部分：
- en: '![Figure 7.1 – Example of page sections within the theme editor'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 主题编辑器内页面部分的示例'
- en: '](img/Figure_7.01_B17606.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.01_B17606.jpg)'
- en: Figure 7.1 – Example of page sections within the theme editor
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 主题编辑器内页面部分的示例
- en: At first glance, we can see that the **Header** and **Footer** sections are
    separated from the rest of the sections by a thin border. This tells us that the
    **Header** and **Footer** sections are static sections whose positions we cannot
    change from within the theme editor.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，我们可以看到**页眉**和**页脚**部分通过一条细边框与其它部分分开。这告诉我们**页眉**和**页脚**部分是静态部分，我们不能从主题编辑器中改变它们的位置。
- en: 'Similarly, as with snippet files, `section` theme tag:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于片段文件，`section`主题标签：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By including the `section` tag, we will automatically render the content of
    the section to the position where we have included the tag and be able to customize
    it further using its JSON settings. Note that since this is a static section that
    we have manually included within the theme files, any settings that we apply to
    this specific section through the theme editor will be visible across all the
    pages where we have included this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`section`标签，我们将自动将部分的内容渲染到我们包含标签的位置，并能够通过其JSON设置进一步自定义它。请注意，由于这是一个我们手动包含在主题文件中的静态部分，通过主题编辑器应用到此特定部分的任何设置将在我们包含此部分的任何页面上可见。
- en: For example, the theme developers have included the header and footer section
    files inside the `theme.liquid` layout file, which is our theme master file, meaning
    that the header and footer sections will be visible on any page on our store.
    On the other hand, if we were to navigate to a different page within our theme
    editor, we would see a header, a footer, and an entirely different set of sections
    between those two than those we previously saw on the home page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，主题开发者已经在`theme.liquid`布局文件中包含了页眉和页脚部分文件，这是我们的主题主文件，这意味着页眉和页脚部分将在我们商店的任何页面上可见。另一方面，如果我们导航到主题编辑器内的不同页面，我们会看到一个页眉、一个页脚，以及在这两个之间的一组完全不同的部分，与我们之前在主页上看到的不同。
- en: By including the header and footer sections inside the `theme.liquid` file,
    we have made them visible across the entire theme on any page. However, we will
    not include all the sections within the `theme.liquid` file as they are not needed.
    Instead, we will include certain template-specific sections inside their respective
    template files so that they can only be accessed when visiting pages with the
    specific template assigned.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`theme.liquid`文件中包含页眉和页脚部分，我们已经使它们在整个主题的任何页面上都可见。然而，我们不会在`theme.liquid`文件中包含所有部分，因为它们不是必需的。相反，我们将某些特定模板的部分包含在其各自的模板文件中，这样它们就只能在我们访问具有特定模板的页面时访问。
- en: Let's say that we wanted to include the related products section on the product
    pages. Here, we would navigate to the `product.liquid` template and include the
    `section` tag at any position, which would make the related products section visible
    on any product that uses this particular template.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在产品页面上包含相关产品部分。在这里，我们会导航到`product.liquid`模板，并在任何位置包含`section`标签，这将使相关产品部分在任何使用此特定模板的产品上可见。
- en: As we recall from [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, in *The Please apply P-Italics here content_for_layout
    object* section, we mentioned that the `content_for_layout` object allows us to
    connect the other templates to the `theme.liquid` file by loading the dynamically
    generated content, including the section files from other templates, into the
    `theme.liquid` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，“使用对象深入Liquid核心”中回忆的，在“*The
    Please apply P-Italics here content_for_layout object*”部分，我们提到`content_for_layout`对象允许我们通过加载动态生成的内容，包括来自其他模板的章节文件，将其连接到`theme.liquid`文件。
- en: 'Since `content_for_layout` outputs the content of all other templates, by placing
    it between the header and footer sections, we have ensured that we will position
    all the section files from other template files in between the header and footer
    sections. Let''s look at the `theme.liquid` layout file; we will notice that we
    positioned `content_for_layout` between the `header` and `footer` sections, as
    depicted in the following block of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`content_for_layout`输出所有其他模板的内容，通过将其放置在页眉和页脚部分之间，我们已经确保了将所有来自其他模板文件的章节文件放置在页眉和页脚部分之间。让我们看看`theme.liquid`布局文件；我们会注意到`content_for_layout`被放置在`header`和`footer`部分之间，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that including the same section file across multiple templates will result
    in the same content being visible across all templates. By configuring the static
    section from the theme editor, we can save the selected data inside the `settings_data.json`
    file, which will return the exact data for any occurrence of the same section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在多个模板中包含相同的部分文件将在所有模板中显示相同的内容。通过从主题编辑器配置静态部分，我们可以将选择的数据保存到`settings_data.json`文件中，这将返回相同部分的任何出现的精确数据。
- en: 'If we need to repeat the static section multiple times with different content,
    we would need to create a new section file using a different name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要多次重复静态部分并包含不同的内容，我们需要使用不同的名称创建一个新的部分文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So far, we have seen what static sections are and how to use them to create
    a template-based configurable layout. But we also have access to dynamic sections,
    which we do not have to include every time we want to reposition a section manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了静态部分是什么以及如何使用它们来创建基于模板的可配置布局。但我们也有访问动态部分的能力，我们不必每次手动重新定位部分时都包括它们。
- en: 'As the name suggests, **dynamic sections** are a set of sections that we can
    add, remove, reposition, or repeat any number of times with different content,
    without touching a single line of code, all from the theme editor. Let''s return
    to the home page within the theme editor and look at some of the existing dynamic
    sections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，**动态部分**是一组我们可以添加、删除、重新定位或重复任意次数，内容各不相同，而不需要修改任何代码的部分，所有这些都可以从主题编辑器中完成。让我们回到主题编辑器中的主页，并查看一些现有的动态部分：
- en: '![Figure 7.2 – Example of page sections within the theme editor'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 主题编辑器中页面部分的示例](img/Figure_7.2_B17606.jpg)'
- en: '](img/Figure_7.02_B17606.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.02_B17606.jpg)'
- en: Figure 7.2 – Example of page sections within the theme editor
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 主题编辑器中页面部分的示例
- en: We can easily distinguish the static section from the dynamic section by simply
    hovering over the section itself. We will notice two icons to the right of the
    dynamic section's name – an *eye* icon and *six dots* – by hovering over it. The
    eye icon will allow us to toggle the section's visibility on and off. By clicking
    and holding onto the six dots icon, we can reposition the section by moving it
    above or below the other sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地悬停在部分本身上轻松地区分静态部分和动态部分。我们会注意到动态部分名称右侧有两个图标——一个**眼睛**图标和一个**六个点**图标——通过悬停。眼睛图标将允许我们切换部分的可见性。通过单击并按住六个点图标，我们可以通过将其移动到其他部分的上方或下方来重新定位部分。
- en: Additionally, at the bottom of the dynamic sections, we will notice an **Add
    section** button, which, once clicked, will show a dropdown that we can use to
    include any number of sections that exist in our store by simply clicking on them.
    Any section that's added to the theme via the **Add section** button will allow
    us to include different content for any occurrence, and we can repeat this as
    many times as we want.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在动态部分的底部，我们会注意到一个**添加部分**按钮，点击后会出现一个下拉菜单，我们可以通过简单地点击它们来包含我们商店中存在的任意数量的部分。通过**添加部分**按钮添加到主题中的任何部分都将允许我们为任何出现包含不同的内容，并且我们可以根据需要重复此操作任意多次。
- en: Until recently, the home page was the only place where we could use dynamic
    sections. For all other templates, we had to rely on using static sections. However,
    since the Shopify Unite 2021 event, Shopify has introduced JSON type templates,
    which we briefly mentioned in [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Shopify*. JSON templates, which we will learn more about
    later in this chapter, add dynamic sections to any page and bring the store's
    entire functionality to a whole new level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，主页是我们唯一可以使用动态部分的地方。对于所有其他模板，我们不得不依赖于使用静态部分。然而，自从Shopify Unite 2021活动以来，Shopify引入了JSON类型模板，我们在[*第一章*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015)“使用Shopify入门”中简要提到了这一点。JSON模板，我们将在本章后面了解更多，可以为任何页面添加动态部分，并将商店的整个功能提升到一个全新的水平。
- en: Now that we have learned about what sections are and how we can use them, it
    is time to learn how to create them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是部分以及如何使用它们，现在是时候学习如何创建它们了。
- en: Working with the section schema
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与部分模式一起工作
- en: In the previous chapter, we learned how to use JSON to create global settings,
    which has a similar format to the JSON for section files. However, sectional JSON
    comes with a few distinct differences.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用JSON创建全局设置，其格式与部分文件的JSON格式相似。然而，部分JSON有一些显著的不同之处。
- en: 'The first major difference is that we need to define JSON inside the section
    file instead of the `settings_schema.json` file. To do this, we will need to introduce
    the `schema` tag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要区别是我们需要在部分文件内定义JSON，而不是在`settings_schema.json`文件中。为此，我们需要引入`schema`标签：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `schema` tag is a Liquid tag that does not have any output on its own. It
    simply allows us to write JSON code inside the section files. Note that each section
    file can only contain a single `schema` tag, which must stand on its own. It cannot
    be nested inside any kind of other Liquid tags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema`标签是一个Liquid标签，它本身没有输出。它仅仅允许我们在部分文件中编写JSON代码。请注意，每个部分文件只能包含一个`schema`标签，它必须独立存在。它不能嵌套在任何其他Liquid标签内。'
- en: Once we have the `schema` tag in place, we are ready to familiarize ourselves
    with the types of attributes that we can use within the `schema` tags.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了`schema`标签，我们就可以熟悉在`schema`标签内可以使用哪些类型的属性了。
- en: The name attribute
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称属性
- en: 'As its name suggests, the `name` attribute allows us to set the section name,
    which we will use to identify the section inside the theme editor later:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`name`属性允许我们设置部分名称，我们将在稍后通过主题编辑器识别该部分：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, we have learned how to define the name of the section file, *but
    what if we wanted to create an international store where we can easily translate
    not only the store content, but also the store setting labels, inside the theme
    editor?*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何定义部分文件的名称，*但如果我们想创建一个国际化的商店，我们可以在主题编辑器中轻松翻译不仅商店内容，还包括商店设置标签怎么办呢？*
- en: 'We can easily translate most of the attributes inside the `schema` tag by including
    the translation keys in the `name` attribute value:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将`schema`标签内的大多数属性通过在`name`属性值中包含翻译键来翻译：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first value represents the name of the file inside the `Locales` directory,
    whereas the second one represents the translated value. By introducing the translating
    keys, we have ensured that as soon as we change our store language, the `name`
    value will automatically adjust and present the value of the currently selected
    language file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值代表`Locales`目录内文件的名称，而第二个值代表翻译值。通过引入翻译键，我们确保一旦我们更改商店语言，`name`值将自动调整并显示当前选定语言文件的值。
- en: Note that we can include the translation keys for different kinds of attributes,
    including some of the input settings that we learned about in the previous chapter.
    The attributes that we can use the translation keys with include `name`, `info`,
    `label`, `group`, `placeholder`, `unit`, `content`, and `category`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以包括不同类型属性的翻译键，包括我们在上一章中学到的某些输入设置。我们可以使用翻译键的属性包括`name`、`info`、`label`、`group`、`placeholder`、`unit`、`content`和`category`。
- en: Note that `name` is a mandatory attribute. However, the `name` attribute does
    not have to be unique compared to the other sections, so we should pay attention
    when creating new sections to avoid confusion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`name`是一个必填属性。然而，与其他部分相比，`name`属性不必是唯一的，因此我们在创建新部分时应注意，以避免混淆。
- en: The class attribute
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性
- en: '`class` is a simple attribute that allows us to add additional classes to the
    `div` element, which wraps around the section content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`是一个简单的属性，允许我们向`div`元素添加额外的类，该元素围绕部分内容：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Through this optional attribute, we can easily include any number of classes
    in the parent element wrapping around our section, as shown in the following code
    block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个可选属性，我们可以轻松地将任意数量的类包含在围绕我们的部分的父元素中，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that while we can include any number of classes, we cannot dynamically
    modify them since the `class` attribute only accepts string values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们可以包含任意数量的类，但由于`class`属性只接受字符串值，我们无法动态修改它们。
- en: The settings attribute
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置属性
- en: 'Using the `settings` attribute, we can create section-specific settings, which
    allows us to configure the section using the theme editor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`settings`属性，我们可以创建特定于部分的设置，这允许我们使用主题编辑器来配置部分：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have defined the `settings` attribute, we can start including any input
    settings, whether they''re basic or specialized, that we have previously learned
    about to create the flow that we need. Since we are working on creating an announcement
    bar, we can include the following inputs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`settings`属性，我们就可以开始包含任何我们之前学过的基本或专业的输入设置，以创建我们需要的流程。由于我们正在创建一个公告栏，我们可以包含以下输入：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the introduction of `settings` and input settings, we have successfully
    created the first section, whose text and text color values can be adjusted within
    the theme editor. If we were to try and include this section as a static section,
    the two input settings that we created previously would immediately be visible
    under the respective section:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入`settings`和输入设置，我们已经成功创建了第一个部分，其文本和文本颜色值可以在主题编辑器中调整。如果我们尝试将其作为静态部分包含，我们之前创建的两个输入设置将立即在相应的部分下可见：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, if we were to navigate to the home page and include the announcement
    section via the **Add section** button, we would not find it. We are still missing
    one attribute, which we need to create a section that we can dynamically add to
    the home page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们导航到主页并通过**添加部分**按钮包含公告部分，我们将找不到它。我们仍然缺少一个属性，我们需要创建一个可以动态添加到主页的部分。
- en: The presets attribute
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预设属性
- en: 'The `presets` attribute allows us to define the default configuration of a
    section, which makes the section accessible from the `presets` attribute can contain
    the following attributes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`presets`属性允许我们定义一个部分的默认配置，这使得部分可以通过`presets`属性访问，它可以包含以下属性：'
- en: The `name` attribute is mandatory and will define how the section will appear
    under the **Add section** dropdown.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`属性是强制的，它将定义部分在**添加部分**下拉菜单中的显示方式。'
- en: The `category` attribute is not mandatory. We can use it to group different
    sections under a single category for more straightforward navigation.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`属性不是强制的。我们可以使用它将不同的部分分组到单个类别下，以便更直观地导航。'
- en: 'Note that it is advisable to use a unique name for the `presets` section to
    avoid confusion, even though Shopify does not strictly require it. Otherwise,
    we might end up with multiple sections with similar names:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然Shopify没有严格要求，但建议为`presets`部分使用一个独特的名称以避免混淆。否则，我们可能会得到多个具有相似名称的部分：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we should only include the `presets` attribute for dynamic sections.
    If we plan on using it as a static section, we should remove the `presets` attribute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只应该为动态部分包含`presets`属性。如果我们计划将其用作静态部分，我们应该删除`presets`属性。
- en: If we were to open the theme editor now and click on the **Add section** button
    on the home page, we would see the **Announcement Bar** section, with the text
    and color settings that we defined earlier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开主题编辑器并点击主页上的**添加部分**按钮，我们会看到**公告栏**部分，其中包含我们之前定义的文本和颜色设置。
- en: 'Accessing the section-specific JSON input values is relatively similar to how
    we access the settings inside the `settings_schema.json` file. The only difference
    is that the only way to access the section''s `settings` object is through the
    `section` object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 访问特定部分的JSON输入值与访问`settings_schema.json`文件内的设置的方式相对类似。唯一的区别是，访问部分的`settings`对象的唯一方式是通过`section`对象：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For additional information on the `section` object, please refer to [https://shopify.dev/api/liquid/objects/section](https://shopify.dev/api/liquid/objects/section).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`section`对象的更多信息，请参阅[https://shopify.dev/api/liquid/objects/section](https://shopify.dev/api/liquid/objects/section)。
- en: So far, we have learned what sections are, the differences between static and
    dynamic sections, and how to use them. However, looking over the announcement
    section project that we have worked on, it is clear that the entire section is
    pretty basic as it only allows us to create a single announcement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了什么是章节，静态章节和动态章节之间的区别，以及如何使用它们。然而，回顾我们已工作的公告章节项目，很明显整个章节相当基础，因为它只允许我们创建一个公告。
- en: We can include a few more text input options that we can use to create multiple
    announcements, but that would require us to manually edit the JSON code every
    time we need to include an additional announcement. *What if we're looking to
    create a section that would allow us to add any number of announcements, without
    modifying the JSON code every time we need to include an additional announcement?*
    For this, we can use the `blocks` attribute.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含一些额外的文本输入选项，我们可以使用这些选项来创建多个公告，但这将需要我们每次需要包含额外的公告时都手动编辑JSON代码。*如果我们想创建一个可以添加任意数量公告的章节，而不需要在每次需要包含额外的公告时都修改JSON代码，那会怎么样？*
    对于这个，我们可以使用`blocks`属性。
- en: Building with blocks
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块构建
- en: The `blocks` attribute is one of the most potent tools in Shopify. By using
    them, we can create modules that we can reuse any number of times and reorder
    the section content from within the theme editor. At this point, this might be
    confusing as it sounds similar to what we just learned about regarding dynamic
    sections. However, the key difference is that `blocks` sections allow us to reorder
    the content within the section, not the sections themselves, which allows us to
    create more complex features.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocks`属性是Shopify中最强大的工具之一。通过使用它们，我们可以创建可以重复使用任意次数的模块，并从主题编辑器内部重新排序章节内容。然而，这可能会让人感到困惑，因为它听起来与我们刚刚学到的关于动态章节的内容相似。然而，关键的区别在于`blocks`章节允许我们在章节内部重新排序内容，而不是章节本身，这使得我们可以创建更复杂的功能。'
- en: Additionally, we can combine the `blocks` attributes with static sections to
    create a dynamic section functionality that's similar to what we currently have
    on the home page, and then include it on any page. However, instead of rearranging
    sections, we will be rearranging the blocks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将`blocks`属性与静态章节结合使用，以创建类似于我们目前在主页上拥有的动态章节功能，并将其包含在任何页面上。然而，我们将重新排列的不是章节，而是模块。
- en: The `blocks` attribute allows us to create different types of blocks using the
    object format, under which each object type will act as a unique module. Here,
    we can include a different set of input settings options under each of those modules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocks`属性允许我们使用对象格式创建不同类型的模块，其中每个对象类型将作为一个独特的模块。在这里，我们可以在每个模块下包含一组不同的输入设置选项。'
- en: 'Here are the steps for creating and using a `blocks` module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建和使用`blocks`模块的步骤：
- en: 'Let''s learn how to modify the previously created announcement bar section
    by introducing the `blocks` attribute. Additionally, we will remove certain features,
    such as translation keys and the `class` attributes, for the code to remain concise
    and readable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过引入`blocks`属性来修改之前创建的公告栏章节。此外，我们将删除某些功能，如翻译键和`class`属性，以使代码保持简洁和可读：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s learn how to include the previously mentioned `blocks` module attributes
    inside the section schema. Note that we will only show the code that''s inside
    the `blocks` attribute to keep the code concise and to the point:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在章节模式中包含之前提到的`blocks`模块属性。请注意，我们只展示`blocks`属性内部的代码，以保持代码简洁并突出重点：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have all the necessary attributes in place, all we need to do is
    populate the `settings` attribute with the necessary input settings. Since we
    have already created the text and text color input settings, we can simply migrate
    the text input setting inside the `blocks` module:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有必要的属性，我们只需要将必要的输入设置填充到`settings`属性中。因为我们已经创建了文本和文本颜色输入设置，所以我们可以简单地将文本输入设置迁移到`blocks`模块内部：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's see what this looks like by navigating to the theme editor and clicking
    on the `settings` object:![Figure 7.3 – Example of a section inside the theme
    editor
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过导航到主题编辑器并点击`settings`对象来查看这看起来是什么样子：![Figure 7.03 – Example of a section
    inside the theme editor
- en: '](img/Figure_7.03_B17606.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.03_B17606.jpg](img/Figure_7.03_B17606.jpg)'
- en: Figure 7.3 – Example of a section inside the theme editor
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.3 – 主题编辑器内章节的示例
- en: Since we have only migrated the text input and left the text color input inside
    the section `settings` object, we can use it to style the text color of all the
    blocks at once. Let's click on the arrow to the left of the `blocks` module in
    action.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们只迁移了文本输入，而将文本颜色输入留在了`section`设置对象中，我们可以一次性使用它来设置所有块的文本颜色。让我们点击`blocks`模块左侧的箭头。
- en: 'We will notice that besides the **Add section** button, we also have an **Add
    Announcement** button under the **Announcement Bar** section that we created:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们会注意到，除了**添加部分**按钮外，我们还在我们创建的**公告栏**部分下方有一个**添加公告**按钮：
- en: '![Figure 7.4 – Example of a section block module'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.4 – 区块块模块的示例'
- en: '](img/Figure_7.04_B17606.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.04_B17606.jpg)'
- en: Figure 7.4 – Example of a section block module
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.4 – 区块块模块的示例
- en: Clicking `settings` object, whereby clicking on the `blocks` module and immediately
    position us inside the block. Here, we can define the announcement text input.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`settings`对象，点击`blocks`模块并立即定位到块内部。在这里，我们可以定义公告文本输入。
- en: 'After defining all the inputs inside the `blocks` module''s object settings,
    we can click on the arrow on the left-hand side of the `blocks` modules. However,
    note that since we have introduced a `limit` attribute with a value of `3`, we
    can only repeat the **Announcement** block up to 3 times, as shown here:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blocks`模块的对象设置中定义所有输入后，我们可以点击左侧的箭头。然而，请注意，由于我们引入了一个值为`3`的`limit`属性，我们只能重复使用**公告**块最多3次，如下所示：
- en: '![Figure 7.5 – Example of a limited number of section block modules'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 有限数量的区块块模块示例'
- en: '](img/Figure_7.05_B17606.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.05_B17606.jpg)'
- en: Figure 7.5 – Example of a limited number of section block modules
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 有限数量的区块块模块示例
- en: Once we have included the maximum number of modules, as per the defined value,
    the `blocks` modules. Similarly, as with the dynamic sections, hovering over the
    `blocks` modules will reveal two icons. These will allow us to hide the currently
    selected block or rearrange the block's order using the drag-and-drop feature.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们包含了定义的最大模块数，`blocks`模块。同样，与动态部分一样，悬停在`blocks`模块上会显示两个图标。这些图标将允许我们隐藏当前选定的块或使用拖放功能重新排列块的顺序。
- en: 'Now that we have learned how to create and use a `blocks` module, we need to
    learn how to output the values of the `blocks` module''s input settings:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建和使用`blocks`模块，我们需要学习如何输出`blocks`模块输入设置的值：
- en: 'We can access the `blocks` module''s object settings similar to how we accessed
    the `section` object: we will need to use a `section` object in combination with
    the `blocks` attribute. This combination of the `section` object and the `blocks`
    attribute will return an array of sections blocks that we can access using a simple
    `for` loop:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像访问`section`对象一样访问`blocks`模块的对象设置：我们需要使用一个`section`对象与`blocks`属性结合。这个`section`对象和`blocks`属性的组合将返回一个包含区块块的数组，我们可以使用简单的`for`循环来访问这些数组：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have created the `for` loop, the only thing left to do is output the
    values of each block, as we did with the sections. The only difference is that
    this time, we will use the variable that we defined in the `for` loop instead
    of using the `sections` keyword:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了`for`循环，剩下的唯一事情就是输出每个块的值，就像我们对部分所做的那样。唯一的区别是这次，我们将使用在`for`循环中定义的变量，而不是使用`sections`关键字：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, we have learned how to create the entire section schema, through which
    we can create static and dynamic sections and build `blocks` modules. We have
    also learned how to output the values of both the `sections` and `blocks` modules'
    input settings. However, in the previous example, we only had one type of block;
    *what if we had multiple block types?*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何创建整个部分架构，通过它我们可以创建静态和动态部分，并构建`blocks`模块。我们还学会了如何输出`sections`和`blocks`模块输入设置的值。然而，在先前的例子中，我们只有一种类型的块；*如果我们有多个块类型会怎样呢？*
- en: 'The true power of section blocks is that we can create multiple `blocks` module
    types inside a single `section` element, which we can do by simply creating multiple
    section `blocks` objects with different type values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 区块块真正的力量在于我们可以在单个`section`元素内创建多个`blocks`模块类型，这可以通过简单地创建具有不同类型值的多个`section`块对象来实现：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that all of the `name` and `type` attribute values need to be unique across
    the entire section, whereas the `id` attributes of the input settings only need
    to be unique inside a single block.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有`name`和`type`属性值在整个节区内都需要是唯一的，而输入设置的`id`属性只需要在单个块内是唯一的。
- en: 'As we can see, creating multiple `blocks` module elements is relatively simple.
    While we have only created two simple `blocks` modules in our example, we can
    create any number of `blocks` modules that we can rearrange through the theme
    editor to create complex layouts:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，创建多个`blocks`模块元素相对简单。虽然在我们的示例中我们只创建了两个简单的`blocks`模块，但我们可以创建任意数量的`blocks`模块，并通过主题编辑器重新排列以创建复杂的布局：
- en: '![Figure 7.6 – Example of multiple blocks modules inside a section'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 某节区内多个块模块的示例'
- en: '](img/Figure_7.6_B17606.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B17606.jpg)'
- en: Figure 7.6 – Example of multiple blocks modules inside a section
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 某节区内多个块模块的示例
- en: As we can see from our example, we have four different types of blocks (**Text**,
    **Collection**, **Image**, and **Video**) that we can use to create a layout that
    the store owners can easily configure, without having to modify the code themselves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中可以看到，我们有四种不同类型的块（**文本**、**集合**、**图片**和**视频**），我们可以使用这些块来创建一个店主可以轻松配置的布局，而无需自己修改代码。
- en: Previously, we learned how to loop over the array of blocks by using the `for`
    tags that `section.blocks` returns. However, if we have more than one `blocks`
    module type, we will need to introduce an additional step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何通过使用`section.blocks`返回的`for`标签来遍历块数组。然而，如果我们有多个`blocks`模块类型，我们还需要引入一个额外的步骤。
- en: Suppose that, as in the preceding example, we had a section with four types
    of blocks. *How would we recognize the block types and know what layout we should
    output for which block?* To solve this problem, we can use the `block` object
    paired with the `type` attribute, which will allow us to recover the block type
    value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，正如前面的示例中那样，我们有一个包含四种类型块的节。*我们如何识别块类型并知道应该为哪个块输出哪种布局？*为了解决这个问题，我们可以使用与`type`属性配对的`block`对象，这将允许我们恢复块类型值。
- en: For additional information on the `block` object, please refer to [https://shopify.dev/api/liquid/objects/block](https://shopify.dev/api/liquid/objects/block).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`block`对象的更多信息，请参阅[https://shopify.dev/api/liquid/objects/block](https://shopify.dev/api/liquid/objects/block)。
- en: 'Once we have identified each block type, we can use an `if` statement or `case/when`
    control flow tags to execute the correct code for the respective value. Suppose
    we need to remind ourselves how to use statements or `case/when` control tags;
    we can revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Code with Tags*, and consult the *Controlling the flow of
    Liquid* section for this, where we outlined the process of using control flow
    tags:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们识别出每个块类型，我们就可以使用`if`语句或`case/when`控制流标签来执行相应值的正确代码。假设我们需要提醒自己如何使用语句或`case/when`控制标签；我们可以回顾[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)，*使用标签深入Liquid代码*，并查阅*控制Liquid流程*部分，其中概述了使用控制流标签的过程：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous example, we used the `case/when` control flow tags in combination
    with `block.type` to identify the types of blocks that we are currently looping
    over. After identifying the block type, we rendered the snippet file containing
    the correct layout for the respective block.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们结合使用`case/when`控制流标签和`block.type`来识别我们当前正在遍历的块类型。在识别块类型后，我们渲染了包含相应块正确布局的片段文件。
- en: Note that we have passed the `block` object to each snippet. As you may recall,
    the snippet files are the only type of files that can access the variables defined
    in the parent directory. However, even the snippet files cannot automatically
    access these variables. Instead, we need to pass the values as parameters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`block`对象传递给每个片段。如您所回忆的那样，片段文件是唯一可以访问父目录中定义的变量的文件类型。然而，即使是片段文件也无法自动访问这些变量。相反，我们需要将这些值作为参数传递。
- en: Suppose we need to remind ourselves how to pass values to snippet files; we
    can revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving
    into Liquid Code with Tags*, and consult the *The render tag* section, located
    under the *Theme tags* section, where we outlined the process of working with
    snippet files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要提醒自己如何将值传递给片段文件；我们可以回顾[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)，*使用标签深入Liquid代码*，并查阅位于*主题标签*部分下的*渲染标签*部分，其中概述了处理片段文件的过程。
- en: Besides learning how to create `blocks` modules, we learned about the `limit`
    attribute, which we can use to limit how many times we can repeat a particular
    type of `blocks` module. This worked well when we had a single type block. *However,
    what if we wanted to create a limitation so that we can have a maximum number
    of any combination of blocks inside a section?*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习如何创建`blocks`模块外，我们还了解了`limit`属性，我们可以使用它来限制重复特定类型`blocks`模块的次数。当我们只有一个类型块时，这效果很好。*但是，如果我们想创建一个限制，以便在某个部分内可以拥有任意组合的最大数量块呢？*
- en: The max_blocks attribute
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`max_blocks`属性'
- en: 'The `max_blocks` attribute, similar to the `limit` attribute, allows us to
    limit how many `blocks` modules we can create inside a section. However, they
    have one significant difference: the `limit` attribute only allows us to limit
    the number of times we can repeat a particular block type, whereas the `max_blocks`
    attribute allows us to limit a specific section to a maximum number of any type
    of block.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_blocks`属性与`limit`属性类似，允许我们限制在某个部分内可以创建的`blocks`模块的数量。然而，它们有一个显著的区别：`limit`属性只允许我们限制重复特定块类型的次数，而`max_blocks`属性允许我们限制特定部分的最大块类型数量。'
- en: 'Note that the `max_blocks` attribute is optional and only accepts number data
    as its value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`max_blocks`属性是可选的，并且只接受数字数据作为其值：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The most common use of the `max_blocks` attribute is inside the footer section.
    With it, the store owner can easily rearrange the blocks in any order, whether
    by repeating a single block five times or by using five different blocks, all
    while ensuring that the layout of the entire section maintains the proper flow.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_blocks`属性最常见的使用是在页脚部分。有了它，店主可以轻松地以任何顺序重新排列块，无论是重复单个块五次还是使用五个不同的块，同时确保整个部分的布局保持适当的流程。'
- en: Previously, we learned how to create `blocks` modules, as well as how to identify
    different types of block types and access each block object accordingly. Now that
    we have learned how we can use `max_blocks` to limit the number of products inside
    a section, we have all the necessary knowledge to build any type of `blocks` module.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们学习了如何创建`blocks`模块，以及如何识别不同类型的块类型并相应地访问每个块对象。现在我们已经学会了如何使用`max_blocks`来限制某个部分内的产品数量，我们就拥有了构建任何类型`blocks`模块所需的所有必要知识。
- en: As we saw, blocks are quite powerful and allow us to create anything from basic
    text features to complex layout features, intertwined with different types of
    blocks that store owners can use to tell the story of their products.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，块功能非常强大，允许我们创建从基本文本功能到复杂布局功能的一切，这些功能与不同类型的块交织在一起，店主可以使用这些块来讲述他们产品的故事。
- en: With that, we have learned about the differences between static sections, which
    we can manually embed on any page, and dynamic sections, which allow us to add
    any number of sections to the home page dynamically. However, as we mentioned
    at the beginning of this chapter, Shopify has recently provided us with the means
    to include sections on any page through JSON templates dynamically. By using JSON
    templates, we can combine the static and dynamic sections into a new feature that
    we can control from within the theme editor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上内容，我们已经了解了静态部分和动态部分之间的区别，静态部分是我们可以在任何页面上手动嵌入的，而动态部分则允许我们动态地向主页添加任意数量的部分。然而，正如我们在本章开头提到的，Shopify最近为我们提供了通过JSON模板在任意页面上动态包含部分的方法。通过使用JSON模板，我们可以将静态和动态部分结合成一个新的功能，我们可以在主题编辑器内对其进行控制。
- en: Enhancing pages with JSON templates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON模板增强页面
- en: In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Shopify*, while discussing the theme structure, we briefly mentioned JSON
    templates, *but what exactly are they?*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015)《Shopify入门》中，当我们讨论主题结构时，我们简要提到了JSON模板，*但它们究竟是什么呢？*
- en: The `.json` type templates generally have the same purpose as their counterpart
    `.liquid` templates, as they both allow us to create and manage the look of multiple
    pages through a single template. However, the significant difference between the
    two is that while the `.liquid` type template serves only as a markup file, the
    `.json` file serves as a data type file, which allows us to easily add, remove,
    or rearrange the sections on any page, similar to what we can do on the home page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`.json`类型模板通常与其对应的`.liquid`模板具有相同的目的，因为它们都允许我们通过单个模板创建和管理多个页面的外观。然而，两者之间的显著区别在于，虽然`.liquid`类型模板仅作为标记文件，`.json`文件则作为数据类型文件，这使我们能够轻松地在任何页面上添加、删除或重新排列部分，类似于我们在主页上所能做的。'
- en: The `.json` type templates also share similarities with the `Section` directory
    files, where we need to include a valid schema setting inside the section file.
    The `.json` type template needs to be a valid `.json` file, with the JSON code
    defined inside the template. While we can create any number of `.json` type files,
    the template files' names must be unique in the `.liquid` or `.json` file. For
    example, if we create a `product.json` file template, we cannot create a `product.liquid`
    file as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`.json`类型模板也与`Section`目录文件有相似之处，其中我们需要在部分文件中包含一个有效的模式设置。`.json`类型模板必须是一个有效的`.json`文件，模板内部定义了JSON代码。虽然我们可以创建任意数量的`.json`类型文件，但模板文件的名称必须在`.liquid`或`.json`文件中是唯一的。例如，如果我们创建一个`product.json`文件模板，我们不能同时创建一个`product.liquid`文件。'
- en: Additionally, JSON files have one limitation. We can render a maximum of 20
    sections per template with up to 16 blocks per section, which is a reasonably
    high number, but we should probably rethink our page layout if we ever reach this
    limit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSON文件有一个限制。每个模板最多可以渲染20个部分，每个部分最多16个块，这是一个相当高的数字，但如果我们达到这个限制，我们可能需要重新考虑我们的页面布局。
- en: Now that we have some general knowledge of what JSON type templates are and
    how they work, let's learn how to create our first JSON type file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对JSON类型模板是什么以及它们是如何工作的有了一些基本了解，让我们学习如何创建我们的第一个JSON类型文件。
- en: Building a JSON template structure
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建JSON模板结构
- en: Instead of simply listing the necessary attributes for creating the file, we
    will learn how to create a JSON template by migrating the current `product.liquid`
    type template into a JSON template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是简单地列出创建文件所需的必要属性，我们将学习如何通过将当前的`product.liquid`类型模板迁移到JSON模板来创建一个JSON模板。
- en: 'Let''s begin by creating a JSON-type template by opening the `Templates` directory
    and clicking the `alternate`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`Templates`目录并点击`alternate`开始创建一个JSON类型模板：
- en: '![Figure 7.7 – Example of creating a new JSON type template'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 创建新的JSON类型模板的示例'
- en: '](img/Figure_7.07_B17606.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.07 – 示例：创建新的JSON类型模板](img/Figure_7.07_B17606.jpg)'
- en: Figure 7.7 – Example of creating a new JSON type template
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 创建新的JSON类型模板的示例
- en: Once we have created a new JSON file, Shopify will automatically redirect us
    to the newly created file. We will see an almost empty file containing only two
    attributes. So, let's start creating the necessary attributes and begin our migration
    process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个新的JSON文件，Shopify将自动将我们重定向到新创建的文件。我们将看到一个几乎为空、只包含两个属性的文件。因此，让我们开始创建必要的属性并开始我们的迁移过程。
- en: 'As we mentioned previously, a JSON template must be a valid JSON file whose
    root is an object that can contain some of the following attributes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JSON模板必须是一个有效的JSON文件，其根是一个对象，可以包含以下一些属性：
- en: 'The `name` attribute is a mandatory string type attribute where, as its name
    suggests, we can define the template''s name:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`属性是一个必需的字符串类型属性，正如其名称所暗示的，我们可以定义模板的名称：'
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `layout` attribute is an optional attribute that accepts two types of values,
    a string or false, depending on what we are trying to achieve. The string value
    should represent the name of the layout file, without the `.liquid` extension
    that we would like to use with this specific template. If you need to learn more
    about layout files, please revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*, where we learned about `layout` tags in the
    *Theme tags* sections. Note that if we do not include the `layout` attribute,
    Shopify will default to the `theme.liquid` layout. However, for learning purposes,
    we will manually add and select the `theme` layout:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` 属性是一个可选属性，它接受两种类型的值，一个字符串或 false，这取决于我们想要实现什么。字符串值应该表示我们想要与这个特定模板一起使用的布局文件的名称，不包括
    `.liquid` 扩展名。如果您需要了解更多关于布局文件的信息，请回顾 [*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047)，*深入
    Liquid 核心与标签*，在那里我们学习了 *主题标签* 部分的 `layout` 标签。请注意，如果我们不包括 `layout` 属性，Shopify
    将默认使用 `theme.liquid` 布局。然而，为了学习目的，我们将手动添加并选择 `theme` 布局：'
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `wrapper` attribute is a string type attribute that allows us to select
    the type of HTML wrapper we would like to include around each section inside the
    template. We can use the following HTML tags here:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper` 属性是一个字符串类型属性，它允许我们选择在模板内部每个节周围想要包含的 HTML 包装器的类型。我们在这里可以使用以下 HTML
    标签：'
- en: '`div`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`div`'
- en: '`main`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`'
- en: '`section`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`section`'
- en: 'Note that besides selecting the HTML wrapper''s type, we can also include any
    additional attributes that we may need, such as `class`, `id`, or `data`. Note
    that the `wrapper` attribute is entirely optional:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，除了选择 HTML 包装器的类型之外，我们还可以包含我们可能需要的任何其他属性，例如 `class`、`id` 或 `data`。请注意，`wrapper`
    属性完全是可选的：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `sections` attribute is a mandatory object type attribute that uses the
    names of the sections as keys and the `section` data as values. Inside the `sections`
    object, we can define which sections we would like to include inside our page:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sections` 属性是一个强制性的对象类型属性，它使用节的名称作为键，`section` 数据作为值。在 `sections` 对象内部，我们可以定义我们想要在页面内部包含哪些节：'
- en: '[PRE24]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '{'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "JSON product template",'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"name": "JSON产品模板",'
- en: '"layout": "theme",'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"layout": "theme",'
- en: '"wrapper": "div.product-wrapper[data-type=product]",'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"wrapper": "div.product-wrapper[data-type=product]",'
- en: '"sections": {'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"sections": {'
- en: 'sections attribute uses the same format as the section attribute that we learned
    about previously, we will also need to include some additional attributes inside
    the sections object. For example, we will need to include the type attribute,
    whose value should have the name of the section we are looking to include, and
    if needed, the settings or blocks attribute:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sections 属性使用与之前我们了解过的 section 属性相同的格式，我们还需要在 sections 对象内部包含一些额外的属性。例如，我们需要包含
    type 属性，其值应该是我们想要包含的节的名字，如果需要的话，还可以包含 settings 或 blocks 属性：
- en: '[PRE25]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '{'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "JSON product template",'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"name": "JSON产品模板",'
- en: '"layout": "theme",'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"layout": "theme",'
- en: '"wrapper": "div.product-wrapper[data-type=product]",'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"wrapper": "div.product-wrapper[data-type=product]",'
- en: '"sections": {'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"sections": {'
- en: '"main-block": {'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"main-block": {'
- en: '"type": "name-of-the-section",'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"type": "name-of-the-section",'
- en: '"settings": {'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"settings": {'
- en: main and recommendations) are not preset values and that we can change their
    names to any values we like. When dealing with the `sections` object, there are
    three crucial things that we need to keep in mind:*   We need to have at least
    one block set inside the `sections` object.*   All block names must be unique
    across the entire `sections` object.*   The value of the `type` attribute needs
    to match the name of the section we are looking to include.By including the `main`
    and `recommendations` sections in our new JSON template, we have ensured that
    these two sections will always be visible inside the theme editor when previewing
    the page with the specific JSON type template assigned. However, while these sections
    are considered static, we can hide them and rearrange them, similar to dynamic
    sections.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: main 和 recommendations) 不是预设值，我们可以将它们的名称更改为我们喜欢的任何值。在处理 `sections` 对象时，我们需要牢记三个关键点：*   我们需要在
    `sections` 对象内部至少设置一个块。*   所有块名称在整个 `sections` 对象中必须是唯一的。*   `type` 属性的值需要与我们要包含的节的名字相匹配。通过在我们的新
    JSON 模板中包含 `main` 和 `recommendations` 节，我们已经确保了这两个节在预览分配了特定 JSON 类型模板的页面时，始终会在主题编辑器中可见。然而，尽管这些节被认为是静态的，我们仍然可以隐藏它们并重新排列，就像动态节一样。
- en: '[PRE26]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last attribute is the `order` attribute, which is a mandatory attribute.
    The `order` attribute is an array-type attribute. Here, we can include the IDs
    of the `sections` blocks that we previously set inside the `sections` object and
    arrange them:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性是`order`属性，这是一个必填属性。`order`属性是一个数组类型的属性。在这里，我们可以包括我们在`sections`对象内部之前设置的`sections`块
    IDs 并对它们进行排列：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And with the `order` attribute in place, our JSON template is ready! Let's navigate
    to the theme editor and test it out.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`order`属性设置到位后，我们的 JSON 模板就准备好了！让我们导航到主题编辑器并测试一下。
- en: 'To test the new product template, follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试新的商品模板，请按照以下步骤操作：
- en: Navigate to **Products** from the admin dashboard.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到管理员仪表板的**商品**。
- en: Click on any product and then select the new template name from the **Template
    suffix** drop-down menu, which is located under the **Theme templates** area.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击任何商品，然后从**模板后缀**下拉菜单中选择新的模板名称，该下拉菜单位于**主题模板**区域下。
- en: 'Important note:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The **Template suffix** drop-down menu can only read values from the current
    live theme. What this means is that the newly created template file will not be
    visible in our admin dashboard until we either publish or duplicate them live,
    or until we create the same template file within our currently live team. If we
    opt for the latter choice, note that we need to create the file with the same
    name; we do not have to make any changes to the file's content.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**模板后缀**下拉菜单只能读取当前实时主题中的值。这意味着新创建的模板文件在我们发布或复制它们为实时，或者在我们当前实时团队中创建相同的模板文件之前，将不会在我们的管理员仪表板中可见。如果我们选择后者，请注意，我们需要使用相同的名称创建文件；我们不需要对文件内容进行任何更改。'
- en: 'However, with this new type of template, we also have a new way to preview
    templates. Note that the following method only allows us to preview the template.
    We still need to assign the template by navigating to the admin dashboard''s product
    page and selecting the template from inside the dropdown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种新的模板类型，我们也有了一种新的预览模板的方法。请注意，以下方法只能让我们预览模板。我们仍然需要通过导航到管理员仪表板的商品页面，并在下拉菜单中选择模板来分配模板：
- en: Let's begin by navigating to the theme editor, clicking on the dropdown in the
    middle of the screen, and selecting the **product** option. This will show you
    the templates we currently have under the theme that we are currently working
    on. Let's select the new JSON type template that we created by clicking on it:![Figure
    7.8 – Example of selecting a template through the theme editor
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导航到主题编辑器开始，点击屏幕中间的下拉菜单，并选择**商品**选项。这将显示我们目前正在工作的主题下的模板。让我们通过点击它来选择我们创建的新
    JSON 类型模板：![图 7.8 – 在主题编辑器中选择模板的示例
- en: '](img/Figure_7.08_B17606.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B17606.jpg)'
- en: Figure 7.8 – Example of selecting a template through the theme editor
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.8 – 在主题编辑器中选择模板的示例
- en: Clicking on the **alternate** template will automatically redirect us to a random
    product, allowing us to preview the template that we have selected.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**备用**模板将自动将我们重定向到一个随机商品，允许我们预览我们选择的模板。
- en: 'Important note:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Similar to the dynamic sections on the home page, only sections with preset
    attributes present inside the sections schema will be visible under the **Add
    section** dropdown.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与主页上的动态部分类似，只有具有预设属性存在于`sections`架构中的部分将在**添加部分**下拉菜单下可见。
- en: 'If we have done everything correctly, we should see two sections and the **Add
    section** button in the left sidebar:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们一切操作正确，我们应该在左侧边栏中看到两个部分和**添加部分**按钮：
- en: '![Figure 7.9 – Example of previewing the JSON type template inside the theme
    editor'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.9 – 在主题编辑器中预览 JSON 类型模板的示例'
- en: '](img/Figure_7.09_B17606.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B17606.jpg)'
- en: Figure 7.9 – Example of previewing the JSON type template inside the theme editor
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.9 – 在主题编辑器中预览 JSON 类型模板的示例
- en: Now, try and click on any of the two sections, update any settings, or add a
    new section through the `.json` type template we created by clicking on the **X**
    next to its name, and then open it again.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试点击任何两个部分，更新任何设置，或者通过点击其名称旁边的**X**，通过我们创建的`.json`类型模板添加一个新部分，然后再次打开它。
- en: We will notice that **Shopify** has updated the template file and that it now
    contains all the settings and their values.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将注意到**Shopify**已更新模板文件，并且它现在包含所有设置及其值。
- en: Since we can find all of the settings and their values inside the template file,
    if we assign the JSON template file to multiple products, they will use the layout
    with the same settings. If we wanted to create an additional JSON template that
    would allow us to create a different layout, we could manually create a new JSON
    template and copy the code or do this through the theme editor.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们可以在模板文件中找到所有设置及其值，如果我们将JSON模板文件分配给多个产品，它们将使用具有相同设置的布局。如果我们想创建一个额外的JSON模板，以便我们可以创建不同的布局，我们可以手动创建一个新的JSON模板并复制代码，或者通过主题编辑器完成此操作。
- en: 'Let''s return to the theme editor, click on the dropdown in the middle of the
    screen, and select the **product** option. But this time, we will click on the
    **Create template** button, which will cause the following popup to appear:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到主题编辑器，点击屏幕中间的下拉菜单，并选择**产品**选项。但这次，我们将点击**创建模板**按钮，这将导致以下弹出窗口出现：
- en: '![Figure 7.10 – Example of creating a new JSON type template through the theme
    editor'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – 通过主题编辑器创建新JSON类型模板的示例'
- en: '](img/Figure_7.10_B17606.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.10_B17606.jpg]'
- en: Figure 7.10 – Example of creating a new JSON type template through the theme
    editor
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 通过主题编辑器创建新JSON类型模板的示例
- en: As we can see, inside the popup, we can easily set a new template name and select
    the JSON template whose content we should copy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在弹出窗口中，我们可以轻松设置新的模板名称并选择我们应该复制内容的JSON模板。
- en: With that, we have learned how to create any number of templates for any number
    of pages, *but what if we wanted to use the same layout for multiple pages and
    only use different content for each page?* This is where metafields come to the
    rescue!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何为任何数量的页面创建任何数量的模板，*但如果我们想为多个页面使用相同的布局，而只为每个页面使用不同的内容呢？* 这就是元字段发挥作用的地方！
- en: Upgrading a JSON template with metafields
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元字段升级JSON模板
- en: As you may recall from [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, while going through the *Improving the
    workflow with metafields* section, we mentioned that Shopify has introduced a
    feature that allows us to use metafields without having to rely on third-party
    apps.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从[*第四章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，“使用对象深入液态核心”中回忆起，在浏览“使用元字段改进工作流程”部分时，我们提到Shopify引入了一个功能，允许我们使用元字段而无需依赖第三方应用程序。
- en: 'Besides allowing us to create metafields within the dashboard, Shopify has
    provided us with a whole new set of different types of metafields that we can
    create:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们在仪表板内创建元字段外，Shopify还提供了一套全新的不同类型的元字段，我们可以创建：
- en: Start by navigating to the **Settings** options inside our dashboard, located
    at the bottom-left corner of our screen, and click on the **Metafields** options.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到仪表板中的**设置**选项，位于屏幕的左下角，并点击**元字段**选项。
- en: Once inside, we will see that we have no metafields set and that we can only
    use products and variants metafields; the others are still pending. Let's proceed
    by clicking on the **Products** metafield link.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入后，我们会看到我们没有设置任何元字段，并且我们只能使用产品和变体元字段；其他字段仍在等待中。让我们通过点击**产品**元字段链接来继续操作。
- en: Considering that we have no metafields currently set, we can immediately click
    on the **Add definition** button. This will redirect us to a page where we can
    create a metafield definition. While most of the fields should be familiar from
    when you learned about metafields in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, we now have a new field. Let's click on
    the **Select content type** field, which will show us a dropdown containing all
    the available types of metafields we can create:![Figure 7.11 – Example of the
    available metafields type fields
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们目前没有设置任何元字段，我们可以立即点击**添加定义**按钮。这将带我们到一个可以创建元字段定义的页面。虽然大多数字段应该与您在[*第四章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)“使用对象深入液态核心”中学习元字段时熟悉，但我们现在有一个新的字段。让我们点击**选择内容类型**字段，这将显示一个包含我们可以创建的所有可用元字段类型的下拉菜单：![图7.11
    – 可用元字段类型字段的示例
- en: '](img/Figure_7.11_B17606.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_7.11_B17606.jpg]'
- en: Figure 7.11 – Example of the available metafields type fields
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11 – 可用元字段类型字段的示例
- en: Note that each type of metafield will create a selector inside the dashboard
    of our product page. We can select the text input, which will automatically show
    us an additional set of settings. However, we won't be changing those now.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，每种类型的元字段都会在我们的产品页面仪表板内创建一个选择器。我们可以选择文本输入，这将自动显示一组额外的设置。然而，我们现在不会更改这些设置。
- en: After selecting the text type of the metafield, all we need to do is set its
    name. For our purposes, we will select one of the predefined metafield values
    by clicking on the **Name** field and selecting **Product subtitle**, which will
    automatically fill in all the other fields. Note that we will need to press the
    **Save** button to save the newly created metafield:![Figure 7.12 – Example of
    the metafields inside the product dashboard
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择元字段的文本类型后，我们只需要设置其名称。为了我们的目的，我们将通过点击**名称**字段并选择**产品副标题**来选择预定义的元字段值，这将自动填写所有其他字段。请注意，我们需要按下**保存**按钮来保存新创建的元字段：![图7.12
    – 产品仪表板内元字段示例
- en: Figure 7.12 – Example of the metafields inside the product dashboard
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12 – 产品仪表板内元字段示例
- en: '](img/Figure_7.12_B17606.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B17606.jpg)'
- en: Figure 7.12 – Example of the metafields inside the product dashboard
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12 – 产品仪表板内元字段示例
- en: Now that we have created a product metafield, let's click on the **Products**
    link located in the top-left corner of our admin dashboard and click on any product
    of our choosing. If we scroll down to the bottom of the page, we will notice that
    the metafield we created is now part of our product pages.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个产品元字段，让我们点击位于我们管理仪表板左上角的**产品**链接，并点击我们选择的任何产品。如果我们滚动到页面底部，我们会注意到我们创建的元字段现在已成为我们产品页面的一部分。
- en: As we can see, by simply creating a product metafield definition, we have automatically
    added the same metafield to every product, allowing us to update the metafield's
    values a lot easier than when using a third-party app. Let's update the metafield's
    value by adding any string value and pressing the **Save** button.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，通过简单地创建产品元字段定义，我们已经自动将相同的元字段添加到每个产品中，这使得我们比使用第三方应用程序更容易更新元字段的值。让我们通过添加任何字符串值并按下**保存**按钮来更新元字段的值。
- en: Now, return to the theme editor, navigate to the JSON template, and find any
    text input type from the sections that we have available. For our purposes, we
    have added a new section named `Image with text`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到主题编辑器，导航到JSON模板，并找到我们可用的部分中的任何文本输入类型。为了我们的目的，我们添加了一个名为`Image with text`的新部分。
- en: Looking through this section, we will notice new icons next to specific types
    of fields:![](img/Figure_7.13_B17606.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看本节时，我们会注意到特定类型字段旁边出现的新图标：![img/Figure_7.13_B17606.jpg]
- en: Figure 7.13 – Example of the metafields icon inside the theme editor
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.13 – 主题编辑器内元字段图标的示例
- en: Clicking on the bottom icon next to the **Heading** text input will promptly
    show us a list of all the metafields that we can pull from this particular product.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**标题**文本输入旁边的底部图标会立即显示我们可以从该特定产品中提取的所有元字段列表。
- en: 'Select the **Product subtitle** metafield that we selected previously and click
    the **Insert** button. This will automatically add the value of the selected metafield
    and output it in the input field that we have selected:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前选择的**产品副标题**元字段，并点击**插入**按钮。这将自动添加所选元字段的值，并在我们选择的输入字段中输出：
- en: '![](img/Figure_7.14_B17606.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.14_B17606.jpg)'
- en: Figure 7.14 – Example of the metafields icon inside the theme editor
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 主题编辑器内元字段图标的示例
- en: With that, we have learned how to dynamically update the values of the sections
    settings by using metafields, without having to create a new JSON template for
    each product. The only thing we have to do now is create the proper layout by
    arranging the necessary sections inside the JSON template.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经学会了如何通过使用元字段动态更新部分设置的值，而不必为每个产品创建一个新的JSON模板。我们现在需要做的就是通过在JSON模板内排列必要的部分来创建适当的布局。
- en: Note that by using metafields, we can update all kinds of inputs, such as images,
    URLs, or even color swatches. However, we should create an appropriate metafield
    to ensure that the metafield value and the input-type value match.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用元字段，我们可以更新所有类型的输入，如图片、URL或甚至是颜色样本。然而，我们应该创建一个适当的元字段，以确保元字段值和输入类型值匹配。
- en: As we saw previously, sections alone are pretty powerful. Mixing sections with
    JSON templates and metafields makes them even more impressive. It allows merchants
    to easily configure each page differently, without having to create new templates
    for each page or manually inserting sections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，仅使用部分就能非常强大。将部分与 JSON 模板和元字段混合使用，使其更加引人注目。这允许商家轻松地为每个页面配置不同的设置，而无需为每个页面创建新的模板或手动插入部分。
- en: Besides what we have learned so far, we know that Shopify also provides us with
    some additional section-specific tags that we can use to create even more powerful
    elements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们迄今为止所学的，我们还知道 Shopify 还提供了一些额外的特定于部分的标签，我们可以使用这些标签创建更强大的元素。
- en: Exploring section-specific tags
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索特定于部分的标签
- en: While we can easily define styling or include the JavaScript code inside the
    theme's respective asset files, Shopify provides us with three types of tags that
    we can use to include CSS and JavaScript directly in the section file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以轻松地在主题的相关资产文件中定义样式或包含 JavaScript 代码，但 Shopify 提供了三种类型的标签，我们可以使用这些标签直接在部分文件中包含
    CSS 和 JavaScript。
- en: The stylesheet tag
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`stylesheet` 标签'
- en: 'Similar to the `schema` tag, the `stylesheet` tag is a Liquid tag that does
    not have any output on its own. It simply allows us to write CSS code inside the
    section files. Note that each section file can only contain a single `stylesheet`
    tag, which must stand on its own. It cannot be nested inside any other kind of
    Liquid tag:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `schema` 标签类似，`stylesheet` 标签是一个 Liquid 标签，它本身没有输出。它仅仅允许我们在部分文件内编写 CSS 代码。请注意，每个部分文件只能包含一个
    `stylesheet` 标签，该标签必须独立存在。它不能嵌套在任何其他类型的 Liquid 标签内：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although this might not look like a great idea at first, since we end up having
    CSS code spread over multiple files, Shopify will automatically collect all the
    CSS files from the different section files, combine them into one stylesheet file,
    and inject it into the theme file through the `content_for_header` global object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始这可能看起来不是一个好主意，因为我们最终会在多个文件中分散 CSS 代码，但 Shopify 会自动收集来自不同部分文件的所有 CSS 文件，将它们合并成一个样式表文件，并通过
    `content_for_header` 全局对象将其注入主题文件。
- en: 'Important note:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The `stylesheet` tag only accepts CSS values. We cannot include Liquid code
    inside the tag.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`stylesheet` 标签仅接受 CSS 值。我们无法在标签内包含 Liquid 代码。'
- en: Note that bundled assets are not section- or block-specific. For section- and
    block-specific stylesheets, we will need to use the `style` tag.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，捆绑的资产不是针对部分或块的。对于针对部分或块的样式表，我们需要使用 `style` 标签。
- en: The style tag
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`style` 标签'
- en: 'The `style` tag works similarly to the `stylesheet` tag as it allows us to
    write CSS code directly into the section file. However, the `style` tag has two
    significant differences compared to the `stylesheet` tag:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 标签与 `stylesheet` 标签类似，因为它允许我们直接在部分文件中编写 CSS 代码。然而，`style` 标签与 `stylesheet`
    标签有两个显著的区别：'
- en: 'The first difference is that the `style` tag is equal to using an HTML `<style>`
    tag, meaning that Shopify will not collect and bundle the CSS code that we included
    through the `style` tag. Instead, Shopify will render the HTML `style` tag and
    its content in the same place where we have included it:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个区别在于 `style` 标签等同于使用 HTML `<style>` 标签，这意味着 Shopify 不会收集和捆绑通过 `style` 标签包含的
    CSS 代码。相反，Shopify 将在包含它的同一位置渲染 HTML `style` 标签及其内容：
- en: '[PRE30]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second and more important difference is that the `style` tag allows us
    to include Liquid code, which we can use to modify the CSS content by using the
    theme editor dynamically:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个也是更重要的一点是，`style` 标签允许我们包含 Liquid 代码，我们可以使用主题编辑器动态地通过它来修改 CSS 内容：
- en: '[PRE31]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that as opposed to the input settings defined inside the `settings_schema.json`
    file, whose values can be accessed globally within any file, the section and block
    input values can only be accessed inside the section file itself or within the
    snippet file, after we pass the value as a parameter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与定义在 `settings_schema.json` 文件内的输入设置不同，其值可以在任何文件中全局访问，部分和块的输入值只能在部分文件本身或片段文件内访问，在我们将值作为参数传递之后。
- en: In the previous example, we saw how to output the section input values and use
    them to modify the CSS code dynamically. However, in our example, we have used
    a static class, meaning that the `background-color` CSS we applied will affect
    every single section and block similarly. *But what if we wanted to apply a different
    color to each section or block?*
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何输出部分输入值并使用它们动态地修改CSS代码。然而，在我们的示例中，我们使用了静态类，这意味着我们应用到的`background-color`
    CSS将影响每个部分和块。*但如果我们想为每个部分或块应用不同的颜色呢？*
- en: 'To apply a unique styling to a specific element, we will need to use a `section`
    or `block` object, combined with the `id` attribute, to create a unique identifier
    that we can call later:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定元素应用独特的样式，我们需要使用`section`或`block`对象，结合`id`属性，创建一个我们可以稍后调用的唯一标识符：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `section.id` will return a dynamically generated ID for dynamic sections
    and a section filename, without the Liquid extension for static sections. `block.id`
    will always return a dynamically generated ID.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`section.id`将为动态部分返回一个动态生成的ID以及部分文件名（对于静态部分不包含Liquid扩展名）。`block.id`将始终返回一个动态生成的ID。
- en: 'Now that we have generated unique selectors, all we need to do is include the
    same selectors inside the `style` tag:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了唯一的选择器，我们只需要在`style`标签内包含相同的选择器：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we know how to generate and call unique selectors, we can easily create
    different styling for both section and block elements. Note that it is also possible
    to include CSS with dynamic values in HTML using the `style` attribute.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何生成和调用唯一选择器，我们可以轻松地为部分和块元素创建不同的样式。请注意，我们还可以在HTML中使用`style`属性包含具有动态值的CSS。
- en: The javascript tag
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`javascript`标签'
- en: 'The `javascript` tag works in the same way as the `stylesheet` tag. The tag
    does not have any output on its own; it simply allows us to write JavaScript code
    directly inside the section files. We can only include a single `javascript` tag
    in a section, which must stand on its own, and it cannot be nested inside other
    Liquid tags:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`javascript`标签的工作方式与`stylesheet`标签相同。该标签本身没有输出；它只是允许我们直接在部分文件内编写JavaScript代码。我们可以在一个部分中包含一个单独的`javascript`标签，该标签必须独立存在，并且不能嵌套在其他Liquid标签内：'
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similarly, as with the `stylesheet` tag, the `javascript` tag only accepts JavaScript
    code. We cannot include any Liquid code inside the tag. Additionally, Shopify
    will automatically bundle any code inside the `javascript` tag and inject it into
    the theme file through the `content_for_header` global object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，与`stylesheet`标签一样，`javascript`标签只接受JavaScript代码。我们无法在标签内包含任何Liquid代码。此外，Shopify将自动将`javascript`标签内的任何代码打包，并通过`content_for_header`全局对象将其注入主题文件。
- en: 'Since we cannot use Liquid code inside the `javascript` tag, one way to apply
    section-specific JavaScript would be to use data attributes, which will output
    the specific input value and recover the value with JavaScript later:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在`javascript`标签内使用Liquid代码，一种应用特定部分JavaScript的方法是使用数据属性，这将输出特定的输入值，并在稍后使用JavaScript恢复该值：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Considering that bundled assets are not section- or block-specific, if we needed
    to create some section- or block-specific JavaScript code, we would need to use
    an HTML `<script>` tag. Note that currently, Shopify does not have a Liquid tag
    that accepts Liquid code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到捆绑的资产不是针对部分或块的，如果我们需要创建一些针对部分或块的特定JavaScript代码，我们就需要使用HTML `<script>`标签。请注意，目前Shopify没有接受Liquid代码的Liquid标签。
- en: 'With the HTML `<script>` tag, we can now write section- and block-specific
    JavaScript and directly include the input settings values. However, note that
    when directly including the input settings values inside the JavaScript, you should
    include the values with whitespace control to ensure no extra whitespaces are
    included:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML `<script>`标签，我们现在可以编写针对部分和块的特定JavaScript，并直接包含输入设置值。然而，请注意，当直接在JavaScript中包含输入设置值时，应使用空白控制来确保不包含额外的空格：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you need to remind yourself how to use whitespace control, please revisit
    [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030), *The Basic Flow
    of Liquid*, and consult the *Controlling whitespace* section, where we outlined
    the process of controlling whitespace.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要提醒自己如何使用空白控制，请重新阅读[*第2章*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030)，*Liquid的基本流程*，并查阅*控制空白*部分，其中我们概述了控制空白的过程。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to combine our previously attained knowledge
    of basic and specialized inputs with the section schema. This allows us to create
    everything from simple to complex layouts that we can easily configure throughout
    the theme editor.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将我们之前获得的基本和专用输入知识与部分架构相结合。这使得我们能够创建从简单到复杂的布局，我们可以在主题编辑器中轻松配置。
- en: By learning the difference between static and dynamic sections, we learned how
    to extend a section's functionality and make it accessible on any type of page.
    Additionally, besides learning how to create different types of sections, we have
    also gained knowledge of how to create different types of `blocks` modules, which
    will allow us to rearrange the layouts of a single section to make it easy to
    configure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习静态和动态部分之间的区别，我们学会了如何扩展部分的功能，使其在任何类型的页面上都易于访问。此外，除了学习如何创建不同类型的部分外，我们还获得了创建不同类型的`blocks`模块的知识，这将使我们能够重新排列单个部分的结构，使其易于配置。
- en: Lastly, we learned about the different types of section-specific tags that we
    can use to develop the content of the section further, as well as creating a unique
    experience for specific sections or even `blocks` modules.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了我们可以用来进一步开发部分内容以及为特定部分或甚至`blocks`模块创建独特体验的不同类型的部分特定标签。
- en: In the next chapter, we will learn about what Shopify Ajax is and how we can
    utilize it to implement advanced functionalities and make a store more dynamic.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解Shopify Ajax是什么以及我们如何利用它来实现高级功能并使商店更加动态。
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main difference between the static and dynamic sections?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态部分和动态部分之间主要区别是什么？
- en: What object can we use to access the block input value? Write some code that
    will allow us to access the specific `blocks` module input value.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用什么对象来访问块输入值？编写一些代码，使我们能够访问特定的`blocks`模块输入值。
- en: What is the difference between the `limit` and `max_blocks` attributes?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`limit`和`max_blocks`属性之间的区别是什么？'
- en: How can we apply section-specific CSS styling?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何应用特定部分的CSS样式？
- en: Practice makes perfect
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟能生巧
- en: As with the projects in the previous chapters, this project will contain detailed
    information about what we need to do and the appropriate instructions to help
    you achieve the results.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章的项目一样，这个项目将包含关于我们需要做什么以及适当的说明，以帮助你实现结果。
- en: We recommend working on each project independently from the previous chapters
    since this will ensure you have truly understood what you have learned so far.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议独立于前几章的项目进行工作，因为这将确保你真正理解了你迄今为止所学的内容。
- en: Not a single project has a correct or incorrect solution. However, if by any
    chance you get stuck, you can always consult the project solution, which can be
    found at the end of this book.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个项目有正确或错误解决方案。然而，如果你有任何困难，你总是可以查阅项目解决方案，该解决方案可在本书末尾找到。
- en: Project 4
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目4
- en: 'For our fourth project, we will work on creating a section schema with multiple
    block types. While we can include any number of block types, we should make sure
    to include the following types:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第四个项目，我们将致力于创建一个具有多种块类型的部分架构。虽然我们可以包括任何数量的块类型，但我们应确保包括以下类型：
- en: The text type, which will render a single rich text input
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本类型，将渲染单个富文本输入
- en: The product type, which will render a single product element with a product
    name, price, image, and link
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品类型，将渲染一个包含产品名称、价格、图片和链接的单个产品元素
- en: The list type, which will render a one-level navigation list configurable from
    the Navigation admin section
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表类型，将在导航管理部分渲染一个可配置的一级导航列表
- en: The video type, which will render a video from either the YouTube or Vimeo video
    platform
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频类型，将渲染来自YouTube或Vimeo视频平台的视频
- en: 'Here are the instructions for the assets:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于资产的说明：
- en: Create a new section file called `featured-content.liquid`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`featured-content.liquid`的新部分文件。
- en: Create a separate snippet file for each section while also passing the proper
    object to each snippet.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个部分创建一个单独的片段文件，同时将适当的对象传递给每个片段。
- en: 'The following are the instructions for this assignment:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为这项作业的说明：
- en: Include all the necessary attributes that we need for a dynamic section.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含我们需要的所有动态部分属性。
- en: Create the four block modules according to the specification provided.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提供的规范创建四个模块。
- en: Limit the video block type to a maximum of two repetitions, where all the other
    blocks should be limited to one occurrence.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视频区块类型限制为最多重复两次，而其他所有区块应限制为仅出现一次。
- en: The total number of blocks present at any time should not exceed four blocks.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何时刻存在的区块总数不应超过四个区块。
- en: We should configure each block's width separately by using the predefined drop-down
    values and apply the selected width to each block via a class, not by directly
    applying the value. The values are 100%, 50%, 33.33%, and 25%.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应通过使用预定义的下拉值单独配置每个区块的宽度，并通过类应用所选宽度到每个区块，而不是直接应用值。这些值是100%、50%、33.33%和25%。
- en: Only include the section or block-specific CSS inside the section file. We should
    include all other CSS stylings inside the theme's respective CSS file.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在区块文件中包含区块或区块特定的CSS。我们应该在主题的相关CSS文件中包含所有其他CSS样式。
- en: 'Define the following input settings inside the section block settings for each
    snippet file: `font-size`, `font-family`, text `color`, and `background-color`.
    We should be able to select the font family from the Shopify `font` library.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个代码片段文件的区块设置部分定义以下输入设置：`font-size`、`font-family`、文本`颜色`和`背景颜色`。我们应该能够从Shopify的`font`库中选择字体家族。
- en: Create a text input element inside the section, which we will use to define
    the H1 heading for the entire section. If the input field is empty, we should
    hide the h1 HTML element.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在区块内创建一个文本输入元素，我们将使用它来定义整个区块的H1标题。如果输入字段为空，我们应该隐藏h1 HTML元素。
- en: Migrate the entire project into a `.json` page type template.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个项目迁移到`.json`页面类型模板。
