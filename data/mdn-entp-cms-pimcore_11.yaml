- en: '*Chapter 11*: Finalizing the Website'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：完成网站'
- en: In the last chapter, we finalized the building of our blog using Pimcore. Thanks
    to the capabilities of CMS and the data management engine, we were able to achieve
    complex goals such as creating custom unstructured content (the website's pages)
    and structured content (blog articles). It was a pleasant journey that makes us
    autonomous regarding the implementation of any kind of website or portal. Moreover,
    there are many additional steps that we may need to take to make our work reusable,
    extensible, and easy to deploy. As the title states, in this chapter we will learn
    how to finalize our website.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Pimcore完成了博客的建设。得益于CMS和数据管理引擎的能力，我们能够实现创建自定义非结构化内容（网站的页面）和结构化内容（博客文章）等复杂目标。这是一段愉快的旅程，使我们能够自主实现任何类型的网站或门户。此外，我们可能还需要采取许多其他步骤来使我们的工作可重用、可扩展且易于部署。正如标题所述，在本章中，我们将学习如何最终完成我们的网站。
- en: 'The points that we will cover will be the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的要点如下：
- en: Making a Multisite in Pimcore
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pimcore中创建多站
- en: Making the bundle installable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使捆绑包可安装
- en: Using a multi-environment configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多环境配置
- en: Using environment variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As for the previous chapters, there is a demo in our GitHub repository that
    you can find here: https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的章节一样，在我们的GitHub仓库中有一个演示，您可以在以下链接找到：[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore)。
- en: All you need to do to run the demo connected with this chapter is to clone it
    and navigate to the `Full Demo` folder to start the Docker environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行与本章相关的演示，您只需克隆它并导航到`完整演示`文件夹以启动Docker环境。
- en: 'To do so, just follow these instructions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，只需遵循以下说明：
- en: 'Run Docker with the following command:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to restore all the settings on your local machine, type the following:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了在您的本地机器上恢复所有设置，请输入以下命令：
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[http://localhost/admin](http://localhost/admin)并使用您的管理员/pimcore凭据登录。
- en: Making a Multisite in Pimcore
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pimcore中创建多站
- en: Each time you create a website, you need to take time to create the environment,
    install plugins, and configure all the other Pimcore settings. Moreover, we also
    need a hosting space, which means extra costs. This is an activity that we have
    to do each time we are going to create a website, but we would reduce the impact
    of this activity on each website creation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建网站时，您都需要花费时间来创建环境、安装插件以及配置所有其他Pimcore设置。此外，我们还需要一个托管空间，这意味着额外的成本。这是我们每次创建网站时都必须进行的操作，但我们希望减少这种活动对每个网站创建的影响。
- en: For example, think about a scenario where a customer has 10 websites, maybe
    one for each brand of the company. With the digital exposure that each company
    has nowadays, it is a plausible use case. Even if we can create a bundle that
    can be used to port the common components between websites, having separate websites
    still involves overhead. From the user's point of view, having 10 different websites
    to admin is very hard to manage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，一个客户有10个网站，可能每个品牌都有一个。考虑到如今每个公司都有的数字曝光度，这是一个合理的用例。即使我们可以创建一个可以用于迁移网站之间公共组件的捆绑包，拥有独立的网站仍然涉及额外的开销。从用户的角度来看，管理10个不同的网站是非常困难的。
- en: The solution for this common situation is still Pimcore itself. The **Multisite**
    feature lets us manage multiple websites in the same instance, reducing hosting
    costs and using the same resources (themes, bricks, custom code) in all the websites.
    With the power of scaling that the cloud provides, we do not expect server load
    problems, and we can follow this method without side effects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种常见情况，解决方案仍然是Pimcore本身。**多站**功能让我们能够在同一个实例中管理多个网站，降低托管成本，并在所有网站中使用相同的资源（主题、砖块、自定义代码）。借助云提供的扩展能力，我们预计不会出现服务器负载问题，并且我们可以无副作用地遵循这种方法。
- en: To cover all the possible scenarios you may have with a real-world website,
    we will implement a test case where we will transform a branch of a website tree
    in a standalone website. This will allow users to reach the web pages as if they
    were browsing an independent website. This is the basic tenet that will let you
    manage multiple websites in the same Pimcore instance (for example, `product1.mywebsite.com`
    and `product2.mywebsite.com`) and website alias (for example, `www.mywebsite.com`
    and `mywebsite.com`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖您可能在与现实世界网站相关的所有可能情况，我们将实施一个测试案例，其中我们将网站树的一个分支转换为独立网站。这将使用户能够像浏览独立网站一样访问网页。这是让您能够在同一个Pimcore实例中管理多个网站（例如，`product1.mywebsite.com`和`product2.mywebsite.com`）以及网站别名（例如，`www.mywebsite.com`和`mywebsite.com`）的基本原则。
- en: 'In the next example, we will create a generic subsite called **subsite1**,
    and we will make it available using a different domain than the default. Moreover,
    we will use different kinds of domain mapping to cover all the most common scenarios
    (addresses, aliases, and wildcards):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将创建一个名为**subsite1**的通用子站点，并使用与默认域名不同的域名使其可用。此外，我们将使用不同类型的域名映射来覆盖所有最常见的情况（地址、别名和通配符）：
- en: 'Add a document to the page tree. Call it **subsite1**. The name of the page
    doesn''t affect the behavior of the site. In our case, we used our full demo setup,
    and we have got a web page like the one shown in the following screenshot:![Figure
    11.1: The page used for the test'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文档添加到页面树中。命名为**subsite1**。页面的名称不会影响网站的行为。在我们的案例中，我们使用了完整的演示设置，并得到了以下截图所示的网页：![图
    11.1：用于测试的页面
- en: '](img/B17073_11_01.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B17073_11_01.jpg](img/B17073_11_01.jpg)'
- en: 'Figure 11.1: The page used for the test'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.1：用于测试的页面
- en: 'Navigate through the tree menu and right-click on the **subsite1** item. Then
    click on **Use as site**:![Figure 11.2: The menu used to convert a web page into
    a website'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树形菜单中导航，并在**subsite1**项上右键单击。然后点击**使用为站点**：![图 11.2：用于将网页转换为网站的菜单
- en: '](img/B17073_11_02.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B17073_11_02.jpg](img/B17073_11_02.jpg)'
- en: 'Figure 11.2: The menu used to convert a web page into a website'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.2：用于将网页转换为网站的菜单
- en: 'If you click on the **Use as site** button, a popup appears:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您点击**使用为站点**按钮，将弹出一个窗口：
- en: '![Figure 11.3: The form for configuring a website'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.3：配置网站的表单'
- en: '](img/B17073_11_03.jpg)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B17073_11_03.jpg](img/B17073_11_03.jpg)'
- en: 'Figure 11.3: The form for configuring a website'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.3：配置网站的表单
- en: 'Fill in the form with the following information:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写以下信息的表单：
- en: '`subsite1.local`.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subsite1.local`。'
- en: '`subsite1-alternative.local` and `*.subsite1.local`. These values have to be
    put on two different lines. This setting applies to the item that we have selected
    and all its children. This configuration tells Pimcore to serve requests using
    the pages under the one that we have promoted to a site in *step 2.* This means
    that if you navigate to one of the added domains, the pages under this page will
    be served. So, if you navigate to `subsite1.local` and `subsite1-alternative.local`,
    you will see the converted page; if you look for a path inside the domain (such
    as `subsite1.local/xxx`), a page with the same relative path under the page site
    will be served. The same goes for all the third-level domains of `subsite1.local`,
    such as `mysubsite.subsite1.local`, because we entered a wildcard address.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subsite1-alternative.local`和`*.subsite1.local`。这些值必须放在两行不同的地方。此设置适用于我们已选择的项及其所有子项。此配置告诉Pimcore使用我们在*步骤2*中提升为站点的页面下的页面来处理请求。这意味着如果您导航到添加的域名之一，将提供此页面下的页面。因此，如果您导航到`subsite1.local`和`subsite1-alternative.local`，您将看到转换后的页面；如果您在域名内部查找路径（例如`subsite1.local/xxx`），将提供页面站点下具有相同相对路径的页面。对于`subsite1.local`的所有三级域名也是如此，例如`mysubsite.subsite1.local`，因为我们输入了通配符地址。'
- en: 'Edit your hosts file to reach these fake URLs. Open the hosts file and add
    the following lines:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑您的hosts文件以访问这些虚拟URL。打开hosts文件并添加以下行：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Go to these URLs: [http://subsite1.local](http://subsite1.local), http://subiste1-alternative.local,
    and [http://test.subsite1.local](http://test.subsite1.local). You will always
    get the same results, which proves that the multisite is well configured.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请访问以下网址：[http://subsite1.local](http://subsite1.local), http://subiste1-alternative.local，以及[http://test.subsite1.local](http://test.subsite1.local)。您将始终得到相同的结果，这证明了多站点的配置良好。
- en: In this section, we learned how to transform a part of the page tree into a
    standalone website. This is very useful for hosting multiple websites and reusing
    themes and components from the same code base. This is a big help for reusable
    code that can work in conjunction with bundling and sharing the source code. In
    the next section, we will learn how to create installation processes for creating
    data and settings during our bundle's installation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将页面树的一部分转换为独立的网站。这对于托管多个网站和重用同一代码库的主题和组件非常有用。这对可重用代码非常有帮助，它可以与打包和共享源代码一起工作。在下一节中，我们将学习如何在包安装期间创建创建数据和设置的过程。
- en: Making the bundles installable
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使包可安装
- en: In [*Chapter 10*](B17073_10_ePub_RK.xhtml#_idTextAnchor188)*, Creating Pimcore
    Bricks*, we created all the assets in a single bundle to make them self-contained
    and portable. The opportunity to start our next Pimcore project by installing
    a bundle means we don't have to redo certain tasks, making this an attractive
    option. Anyway, there are some steps that we have done manually through the user
    interface that have to be replicated. Think back to the class generation in [*Chapter
    9*](B17073_09_ePub_RK.xhtml#_idTextAnchor166)*, Rendering Data*—they were created
    manually, but you do not want to replicate this step in every new blog you will
    create. Even if you only take a few minutes creating them, there is always the
    risk of entering the wrong field name or making a mistake; they will transform
    your 5-minute task into a small nightmare.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17073_10_ePub_RK.xhtml#_idTextAnchor188)*，创建Pimcore砖块*中，我们创建了一个包含所有资产的单一包，使其自包含且可移植。通过安装一个包来开始我们的下一个Pimcore项目意味着我们不必重新执行某些任务，这使得这是一个有吸引力的选项。无论如何，有一些步骤我们通过用户界面手动执行，现在必须复制。回想一下[*第9章*](B17073_09_ePub_RK.xhtml#_idTextAnchor166)*，渲染数据*，它们是手动创建的，但你不想在创建每个新博客时重复这一步骤。即使你只花几分钟创建它们，也总有可能输入错误的字段名或出错；它们将你的5分钟任务变成一个小噩梦。
- en: 'But never fear! The Pimcore installation system lets you add a special class
    that can manage the installation process. Some common use cases are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但不必担心！Pimcore的安装系统允许你添加一个特殊类来管理安装过程。以下是一些常见的用例：
- en: Creating or updating the class definition
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或更新类定义
- en: Entering seed data (such as standard categories)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入种子数据（例如标准分类）
- en: Updating the database schema (add tables, columns, indexes, and so on)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库模式（添加表、列、索引等）
- en: Importing translations
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入翻译
- en: Installers are, in fact, classes that are used by Pimcore when a bundle is installed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装器实际上是在安装包时Pimcore使用的类。
- en: 'This topic is covered by two different approaches:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题有两种不同的方法：
- en: '**Installer**: A class that manages the installation process that gives you
    the power to customize all the phases (installation and uninstallation).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装器**：一个管理安装过程并赋予你自定义所有阶段（安装和卸载）的权限的类。'
- en: '**Migrations**: This part is designed for managing the database changes and
    supporting both upgrade and downgrade options.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**：这一部分是为了管理数据库变更，并支持升级和降级选项。'
- en: Let's examine the two options in the next sections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探讨这两个选项。
- en: Installers
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装器
- en: While the installer takes care of the initial configuration, migrations keep
    the database updated. When you install the bundle, an installation process will
    be run. Then, on each bundle update, you can apply some changes to the database
    to implement a data migration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装器处理初始配置时，迁移保持数据库更新。当你安装包时，将运行一个安装过程。然后，在每次包更新时，你可以对数据库应用一些更改以实现数据迁移。
- en: 'An installer class can inherit `AbstractInstaller` and has the following anatomy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装器类可以继承自 `AbstractInstaller` 并具有以下结构：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`AbstractInstaller` has an instance of `BufferedOutput` that integrates with
    the console tool and the web UI. That means that if you use it to write logs,
    the logs will be prompted to the user. The `BufferedOutput` instance can be accessed
    by the `getOutput()` method.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractInstaller` 包含一个 `BufferedOutput` 实例，该实例与控制台工具和Web UI集成。这意味着如果你用它来记录日志，日志将会提示给用户。`BufferedOutput`
    实例可以通过 `getOutput()` 方法访问。'
- en: 'Now we will create an installer that automatically installs the classes related
    to our project. This is very easy, and we just need to complete the following
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个安装器，它可以自动安装与我们的项目相关的类。这非常简单，我们只需要完成以下步骤：
- en: Create a class definition with one or two fields. Call it `test`. To keep it
    simple, the class complexity is not relevant for our goal. If you have any doubts
    about how to create classes, just look at [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)*,
    Exploring Classes and Objects*, where this topic is covered.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一个或两个字段的类定义。命名为`test`。为了保持简单，类的复杂性对我们目标来说并不重要。如果你对如何创建类有疑问，只需查看[*第5章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)*，探索类和对象*，其中涵盖了这一主题。
- en: 'Download the class definition by clicking the **Export** button on the class
    definition page:![Figure 11.4: Menu bar for class export'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击类定义页面上的**导出**按钮下载类定义：![图11.4：类导出菜单栏
- en: '](img/B17073_11_04.jpg)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17073_11_04.jpg)'
- en: 'Figure 11.4: Menu bar for class export'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.4：类导出菜单栏
- en: Now create a folder named `class_sources` inside `/bundles/BlogBundle/Resources/install/`,
    making the final path `/bundles/BlogBundle/Resources/install/class_sources`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`/bundles/BlogBundle/Resources/install/`中创建一个名为`class_sources`的文件夹，最终路径为`/bundles/BlogBundle/Resources/install/class_sources`。
- en: Copy the JSON file you exported into this folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你导出的JSON文件复制到这个文件夹中。
- en: 'Create a folder called `Setup` in your bundle and add the `BlogInstaller` class
    inside it. The content should include the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的包中创建一个名为`Setup`的文件夹，并在其中添加`BlogInstaller`类。内容应包括以下内容：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to register the installer class to make it available for dependency
    injection. Add the following configuration to the `service.yml` file:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须注册安装器类，使其可用于依赖注入。将以下配置添加到`service.yml`文件中：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the dependency injection knows your installer and can create instances of
    it.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在依赖注入知道你的安装器，并且可以创建其实例。
- en: 'Open the `BlogBundle.php` bundle file and add the following method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BlogBundle.php`包文件，并添加以下方法：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function will tell Pimcore that your bundle has its installer and will
    use it. What happens when you install your bundle is that the event of your installer
    will be triggered, and you will be able to do all the stuff you need. In the next
    steps, we will implement the initial configuration.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将告诉Pimcore你的包有自己的安装器，并将使用它。当你安装你的包时，会发生什么，你的安装器的事件将被触发，你将能够做所有你需要的事情。在接下来的步骤中，我们将实现初始配置。
- en: 'The next snippet of code implements the class restore, so add this function
    (logs and output messages are omitted for brevity):'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段实现了类恢复，因此添加此函数（为了简洁，省略了日志和输出消息）：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The installation procedure is composed of a few simple steps. First of all,
    we read the filesystem and fetch all the files in the `classes` folder (`files
    = $this->getClassesToInstall();`). Then, for each one, we check whether the class
    exists; if it doesn't exist, we create and import the class. If the class exists
    and we override it with a different definition, we may experience data loss and
    we do not want that.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装过程由几个简单的步骤组成。首先，我们读取文件系统，并获取`classes`文件夹中的所有文件（`files = $this->getClassesToInstall();`）。然后，对于每一个，我们检查类是否存在；如果不存在，我们创建并导入类。如果类存在并且我们用不同的定义覆盖它，我们可能会遇到数据丢失，我们不希望这样。
- en: 'The next snippet contains the `getClassesToInstall` procedure. Copy it to the
    installer class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个片段包含`getClassesToInstall`过程。将其复制到安装器类中：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding piece of code reads all `*.json` files in the `class_sources`
    folder and returns them to the caller to be installed.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码读取`class_sources`文件夹中的所有`*.json`文件，并将它们返回给调用者以进行安装。
- en: Now it's time to test the bundle. To make a rigorous test, we should create
    a new environment, move the bundle to the environment, and test it. However, this
    way requires time and effort, and it is not relevant for this explanation, so
    we will use a shortcut.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候测试包了。为了进行严格的测试，我们应该创建一个新的环境，将包移动到该环境，并对其进行测试。然而，这种方法需要时间和精力，并且对于本说明来说并不相关，因此我们将使用快捷方式。
- en: 'Because we do not have any database migrations or unreversible activities,
    we will use the current installation. The first operation is to delete the classes
    you have exported. That is mandatory because our procedure will otherwise skip
    the creation (see *step 7*). You can do that by right-clicking on the class name
    and then hitting **Delete**, as shown in the next figure:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们没有数据库迁移或不可逆的操作，我们将使用当前安装。第一个操作是删除你导出的类。这是强制性的，因为否则我们的程序将跳过创建（参见*步骤7*）。你可以通过右键单击类名然后点击**删除**来完成此操作，如图所示：
- en: '![Figure 11.5: How to delete a class'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.5：如何删除一个类'
- en: '](img/B17073_11_05.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17073_11_05.jpg)'
- en: 'Figure 11.5: How to delete a class'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.5：如何删除一个类
- en: 'Now we have to trick Pimcore by telling it that our bundle is installable.
    To do this, implement the `canBeInstalled` method in the installer class, returning
    `true` (which means "yes, it can be installed!"). Copy the following piece of
    code and paste it to your file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须通过告诉Pimcore我们的包是可安装的来欺骗它。为此，在安装类中实现`canBeInstalled`方法，返回`true`（这意味着“是的，它可以安装！”）。复制以下代码片段并将其粘贴到您的文件中：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next screenshot shows the change before and after the method is implemented:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了方法实现前后的变化：
- en: '![Figure 11.6: Comparing bundle settings before and after changing the flag'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.6：比较更改标志前后的包设置'
- en: '](img/B17073_11_06.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17073_11_06.jpg)'
- en: 'Figure 11.6: Comparing bundle settings before and after changing the flag'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.6：比较更改标志前后的包设置
- en: The previous screenshot shows how the installation status changes as we alter
    the `canBeInstalled` method. The first flag matrix is the output of the `pimcore:bundle:list`
    command, and you can see that the bundle is marked as not installable. After the
    change in the installer class, the installable flag becomes active and Pimcore
    will let us install the bundle again.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个屏幕截图显示了当我们更改`canBeInstalled`方法时安装状态的变化。第一个标志矩阵是`pimcore:bundle:list`命令的输出，您可以看到该包被标记为不可安装。在安装类中的更改之后，可安装标志变为活动状态，Pimcore将允许我们再次安装该包。
- en: 'Finally, it''s time to test the bundle''s installer. Go to the `bin/console
    pimcore:bundle:install BlogBundle` from the command line:![Figure 11.7: The extension
    panel now lets you install the bundle again'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候测试包的安装器了。从命令行进入`bin/console pimcore:bundle:install BlogBundle`：![图11.7：扩展面板现在允许您再次安装包
- en: '](img/B17073_11_07.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17073_11_07.jpg)'
- en: 'Figure 11.7: The extension panel now lets you install the bundle again'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.7：扩展面板现在允许您再次安装包
- en: As you can see in the previous screenshot, the options available in the UI reflect
    the information gathered from the console.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中所见，UI中可用的选项反映了从控制台收集的信息。
- en: 'Navigate to the class list. You will find the `test` class that you deleted
    on the menu again because it was recreated by the install process:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到类列表。您将在菜单中再次找到您删除的`test`类，因为它被安装过程重新创建：
- en: '![Figure 11.8: The created class'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8：创建的类'
- en: '](img/B17073_11_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17073_11_08.jpg)'
- en: 'Figure 11.8: The created class'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：创建的类
- en: In this section, we covered how the installation process works. In the next
    section, we will take care of the schema update and data seeding using migrations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了安装过程的工作原理。在下一节中，我们将使用迁移来处理模式更新和数据播种。
- en: Migrations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: 'The purpose of migrations is to manage data migration and schema updates. This
    is very useful if you are working with a custom database structure. The basic
    concept of migration is that it starts with an existing version that can be incremented
    by applying a delta of changes. The migration can be reversed by implementing
    a rollback function. To be more concrete, a migration in Pimcore is a class implementation
    that has two methods: up (to apply changes) and down (to revert changes).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的目的是管理数据迁移和模式更新。如果您正在使用自定义数据库结构，这将非常有用。迁移的基本概念是它从一个现有版本开始，可以通过应用更改的增量来递增。可以通过实现回滚函数来撤销迁移。更具体地说，Pimcore中的迁移是一个类实现，它有两个方法：up（应用更改）和down（撤销更改）。
- en: 'The migration process is explained in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了迁移过程：
- en: '![Figure 11.9: The migration process'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9：迁移过程'
- en: '](img/B17073_11_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17073_11_09.jpg)'
- en: 'Figure 11.9: The migration process'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：迁移过程
- en: As you can see in the previous figure, after an update, version 1.0 is updated
    to 1.1, but if there is a rollback, the down method brings it back to the initial
    version.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个图中所见，更新后，版本1.0更新到1.1，但如果进行回滚，down方法将将其恢复到初始版本。
- en: 'The first step of adding the ability to manage migrations to your application
    is to map a folder for the migration files to your namespace. To do so, just open
    the `/config/config.yml` file and add the following snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将管理迁移的能力添加到您的应用程序的第一步是为迁移文件映射一个文件夹到您的命名空间。为此，只需打开`/config/config.yml`文件并添加以下片段：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous piece of code maps your namespace with the related folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将您的命名空间与相关文件夹映射。
- en: 'For creating a migration class, the best method is to invoke the `console`
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建迁移类时，最佳方法是调用`console`命令：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command creates a file inside the migration folder of the main
    application. Each version has a generated name, such as `/src/Migrations/Version20210227065641.php`,
    where the `Version` prefix of the filename is followed by a timestamp.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令在主应用程序的迁移文件夹内创建了一个文件。每个版本都有一个生成的名称，例如 `/src/Migrations/Version20210227065641.php`，其中文件名的`Version`前缀后面跟着一个时间戳。
- en: 'The created file will look something like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件看起来可能如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Schema` object is a doctrine element that lets you manipulate the database
    structure. The following examples show the most important use cases, such as creating
    a table, adding fields, and dropping them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schema`对象是一个 doctrine 元素，它允许您操作数据库结构。以下示例显示了最重要的用例，例如创建一个表、添加字段和删除字段：'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For a complete overview of the Schema object''s capabilities, take a look at
    the Symfony documentation: [https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.html](https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.ht).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解`Schema`对象的功能，请查看Symfony文档：[https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.html](https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.html)。
- en: In this section, we learned how to create an installer to manage the setup of
    a bundle and manage data migration. This topic is very useful when you want to
    create a portable bundle or product based on Pimcore. Think, for example, of a
    bundle with all the bricks and utilities that you can use as the basis for your
    projects. In the next section, we will cover another important topic when we work
    with multiple environments in the same code base.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建一个安装程序来管理包的设置和数据迁移。当您想基于Pimcore创建一个可移植的包或产品时，这个主题非常有用。例如，考虑一个包含所有砖块和实用工具的包，您可以用它作为项目的基础。在下一节中，我们将介绍在同一个代码库中工作时的另一个重要主题。
- en: Using a multi-environment configuration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多环境配置
- en: 'In any modern deployment workflow, we have four environments: `local`, `dev`,
    `test`, and `production`. Each of these environments may have different configurations
    and tunings. Your production environment will probably have to face tons of users
    and a heavy load in a clustered system, while your local environment will just
    need to fight with the amount of RAM. What we see is that each environment has
    different needs, and consequently, needs different configurations. The approach
    that we want to follow is to keep all the data in a single code base and keep
    all the settings in the same place. If you are thinking that you''ll need to manage
    a lot of files and complicated logic to switch them, you are wrong.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何现代部署工作流程中，我们都有四个环境：`local`、`dev`、`test`和`production`。这些环境可能具有不同的配置和调整。您的生产环境可能需要在集群系统中面对大量的用户和沉重的负载，而您的本地环境只需与RAM的数量作斗争。我们看到的是，每个环境都有不同的需求，因此需要不同的配置。我们想要遵循的方法是保持所有数据在一个代码库中，并将所有设置放在同一个地方。如果您认为您将需要管理大量的文件和复杂的逻辑来切换它们，那您就错了。
- en: Fortunately, Pimcore is based on Symfony and extends its very powerful configuration
    system. Pimcore manages `dev`, `test`, and `prod` environments natively (while
    others can be added with an additional configuration). To switch the environment,
    you have to specify the `PIMCORE_ENVIRONMENT` environment variable. Because our
    Pimcore instance runs in a container, this setting doesn't have any impact on
    our PC, as the configuration is limited to the container.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Pimcore基于Symfony，并扩展了其非常强大的配置系统。Pimcore原生支持`dev`、`test`和`prod`环境（而其他环境可以通过额外的配置添加）。要切换环境，您必须指定`PIMCORE_ENVIRONMENT`环境变量。由于我们的Pimcore实例运行在容器中，此设置对我们PC没有任何影响，因为配置仅限于容器。
- en: 'Once the variable is set, Pimcore will load the files following this order:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了变量，Pimcore将按以下顺序加载文件：
- en: '`config/pimcore/system_{env}.yml`'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config/pimcore/system_{env}.yml`'
- en: '`var/config/system_{env}.yml`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var/config/system_{env}.yml`'
- en: '`config/pimcore/system.yml`'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config/pimcore/system.yml`'
- en: '`var/config/system.yml`'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var/config/system.yml`'
- en: The configuration files can include other configuration files and inherit properties.
    The default setup that comes with a fresh Pimcore installation has an incremental
    configuration from `dev` to `prod` of the `config.yml` file (`prod` includes `test`,
    which includes `dev`). This mechanism is very useful for sharing settings and
    overriding them when needed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以包含其他配置文件并继承属性。全新 Pimcore 安装附带默认设置，`config.yml` 文件从 `dev` 到 `prod` 有增量配置（`prod`
    包含 `test`，而 `test` 包含 `dev`）。这种机制对于共享设置并在需要时覆盖它们非常有用。
- en: 'If you omit `PIMCORE_ENVIRONMENT`, the base files will be taken following the
    next escalation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了 `PIMCORE_ENVIRONMENT`，基础文件将按照以下升级顺序获取：
- en: '`config/pimcore/system.yml`'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config/pimcore/system.yml`'
- en: '`var/config/system.yml`'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var/config/system.yml`'
- en: 'When you are running Pimcore from the console, you can pass the environment
    as an argument, like in the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在控制台运行 Pimcore 时，你可以将环境作为参数传递，如下例所示：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In a Pimcore environment, it is very important to have different configurations
    of Pimcore to match the different specifications of the environments where we
    will work. By the way, not all the configurations can be saved into the settings
    files for security reasons. In the next section, we will learn how to manage sensitive
    data, such as passwords and API keys, safely with Pimcore.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pimcore 环境中，拥有不同的 Pimcore 配置以匹配我们将要工作的不同环境规格非常重要。顺便说一句，出于安全原因，并非所有配置都可以保存到设置文件中。在下一节中，我们将学习如何使用
    Pimcore 安全地管理敏感数据，例如密码和 API 密钥。
- en: Using Environment variables
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: The modern approach of using containers makes heavy use of environment variables
    for injecting values into applications. This approach is very convenient because
    it makes your application agnostic to the environment in which it will be deployed.
    This process implies that some part of the configuration is pulled from outside
    the application code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器作为现代方法时，会大量使用环境变量将值注入应用程序。这种方法非常方便，因为它使你的应用程序对部署的环境无关。这个过程意味着配置的一部分是从应用程序代码外部拉取的。
- en: Moving all the configuration outside the application makes developers unaware
    of everything going on internally, and this creates misunderstandings between
    the developer and operations teams when problems occur. You have your local code
    and you can see it working, but you will have no idea what can happen in the production
    environment when other settings will be applied. Often, those who manage the operations
    don't know much about the meaning behind configurations because they are not experts
    on the applications and usually are not developers. Developers know how the application
    works and are aware of the impact of settings changes but know little about the
    infrastructure and cannot make tests to fix the problems that the application
    may have (they don't have access to the production environment).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有配置移出应用程序会使开发者对内部发生的一切一无所知，当出现问题时，这会在开发者和运维团队之间造成误解。你有你的本地代码，你可以看到它运行，但你将无法了解在生产环境中应用其他设置时可能会发生什么。通常，负责运维的人对配置背后的含义知之甚少，因为他们不是应用程序的专家，而且通常不是开发者。开发者知道应用程序是如何工作的，并且了解设置更改的影响，但他们对基础设施了解不多，无法对应用程序可能存在的问题进行测试以修复问题（他们没有访问生产环境的权限）。
- en: What we are going to explain in this section is a solution that can keep production
    settings safe, share configurations between developers and operations, and is
    easy to implement with Pimcore. A good compromise is to keep all the configuration
    in the source code but remove sensitive information that is injected during the
    deployment. Keeping the sensitive information separate from the configuration
    lets us share settings with the entire team and makes everybody aware of the configuration
    chosen but does not open us to security issues. This approach creates a clean
    division of responsibility and makes our repository safer. In that way, the developers
    are aware of the configuration in each environment, and operations can manage
    system settings independently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释一种解决方案，它可以保持生产设置的安全，在开发者和运维之间共享配置，并且易于使用 Pimcore 实现。一个好的折衷方案是将所有配置保留在源代码中，但在部署期间移除注入的敏感信息。将敏感信息与配置分开，让我们能够与整个团队共享设置，并使每个人都了解选择的配置，但不会使我们面临安全问题。这种方法创建了一个清晰的职责划分，并使我们的存储库更安全。这样，开发者了解每个环境的配置，而运维可以独立管理系统设置。
- en: This solution has the positive side effect that the developers can test different
    configurations on their local PCs (but without accessing the production system)
    and the result is more predictable. But how is it possible to configure Pimcore
    to separate configurations from sensitive data? In the next example, we will create
    a configuration that will work in all environments but without adding sensitive
    data to the source code files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有积极的一面，即开发者可以在他们的本地PC上测试不同的配置（但不会访问生产系统），结果更可预测。但是，如何配置Pimcore将配置与敏感数据分开？在下一个示例中，我们将创建一个适用于所有环境但不会将敏感数据添加到源代码文件的配置。
- en: Using environment variables for managing database connections
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量管理数据库连接
- en: We aim to have a Pimcore instance with the same configuration for the local,
    test, and production environments. The configuration will all be stored in the
    `dev`, `test`, `prod`). The piece of configuration that we want to manage in that
    way is the configuration string. We will remove the hardcoded connection string
    of Pimcore, making it parametric. This data is usually set in the `config/local/database.yml`
    file, and it is generated by Pimcore at the first installation; it is not usually
    committed. As we are using a Dockerized environment, all the developers that download
    the source code work locally in a separate environment, so there isn't any problem
    with sharing this information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是拥有一个本地、测试和生产环境配置相同的Pimcore实例。所有配置都将存储在 `dev`、`test`、`prod` 文件夹中。我们想要以这种方式管理的配置项是配置字符串。我们将移除Pimcore的硬编码连接字符串，使其参数化。这些数据通常在
    `config/local/database.yml` 文件中设置，并在第一次安装时由Pimcore生成；通常不会提交。由于我们使用的是Docker化环境，所有下载源代码的开发者都在单独的环境中本地工作，因此不存在共享此信息的问题。
- en: 'We can now start work in these settings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在这些设置下工作了：
- en: Delete or rename the `database.yml` file (we won't need it anymore).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或重命名 `database.yml` 文件（我们不再需要它了）。
- en: 'Add the following code to `docker-compose.yml`. This configuration will add
    the settings as `environment` variables:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `docker-compose.yml` 文件中。此配置将设置作为 `环境变量`：
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next figure shows a bare copy of the MySQL settings on the same file:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个图显示了同一文件中MySQL设置的裸拷贝：
- en: '![Figure 11.10: Field mapping between containers'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.10：容器之间的字段映射'
- en: '](img/B17073_11_10.jpg)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B17073_11_10.jpg]'
- en: 'Figure 11.10: Field mapping between containers'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.10：容器之间的字段映射
- en: Now we have to tell Pimcore to use this variable's configuration. The chain
    of dependencies is that `config_prod.yml` includes `config_test.yml` and `config_dev.yml`
    includes `config.yml`. So, adding the proper configuration to the `config` or
    `config_dev` file will make it available for all the environments.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须告诉Pimcore使用此变量的配置。依赖链是 `config_prod.yml` 包含 `config_test.yml`，而 `config_dev.yml`
    包含 `config.yml`。因此，将适当的配置添加到 `config` 或 `config_dev` 文件中，将使其对所有环境可用。
- en: 'Open `config.yml`. The first change to make is to disable the import of the
    database configuration. Just comment out the following line:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `config.yml` 文件。首先需要做的更改是禁用数据库配置的导入。只需注释掉以下行：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The import of the `local` resource set is disabled (otherwise, you can just
    drop the `database.yml` file).
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 禁用了 `local` 资源集的导入（否则，您只需删除 `database.yml` 文件）。
- en: 'Then add the following configuration to the file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将以下配置添加到文件中：
- en: '[PRE17]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The configuration is the same as `database.yml` but parametric. We define internal
    parameters that import the environment variable from the container. We used a
    1:1 map, reusing the same name of the environment variables for the parameters.
    This makes the configuration easier to read.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置与 `database.yml` 相同，但具有参数化。我们定义内部参数，从容器中导入环境变量。我们使用1:1映射，为参数重用相同的环境变量名称。这使得配置更容易阅读。
- en: Then we use the parameter in the `doctrine\dbal\connection\default` section
    of the file. This makes sure that Pimcore will activate a connection with this
    configuration, using the parameters that get values to form the host environment
    (the `docker-compose` file in our case).
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们在文件的 `doctrine\dbal\connection\default` 部分使用该参数。这确保Pimcore将激活一个与此配置的连接，使用获取值的参数来形成主机环境（在我们的情况下是
    `docker-compose` 文件）。
- en: After this step, we fully decouple the configuration from the data so we can
    set them separately. You can commit any configuration (`dev`, `test`, `prod`)
    without the fear that someone will steal sensitive data, and during the deployment,
    the right values will be injected into the environment (virtual machine or container).
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步之后，我们将配置与数据完全解耦，因此我们可以分别设置它们。您可以提交任何配置（`dev`、`test`、`prod`），而不用担心有人会窃取敏感数据，在部署期间，正确的值将被注入到环境中（虚拟机或容器）。
- en: Open Pimcore and check whether you can log in. Because our changes are about
    the connection to the database, if we are able to log in, our new settings have
    been successful.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Pimcore并检查您是否可以登录。因为我们的更改是关于数据库的连接，如果我们能够登录，那么我们的新设置就成功了。
- en: In this section, we learned how to manage sensitive information in the Pimcore
    configuration and how to make variables without replicating the settings. Using
    containers is a useful solution because the container can be deployed as a standalone
    virtual machine, PC, or cloud service, meaning the solution covers most use cases.
    Moreover, having all the configurations on the source code makes it available
    to the developers, sharing a deeper awareness of how the platform will work in
    production. All the configurations can be easily tested locally and then committed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在Pimcore配置中管理敏感信息，以及如何创建变量而不复制设置。使用容器是一个有用的解决方案，因为容器可以被部署为独立的虚拟机、PC或云服务，这意味着该解决方案涵盖了大多数用例。此外，将所有配置放在源代码中，使得开发人员可以访问，从而对平台在生产中的工作有更深入的了解。所有配置都可以轻松地在本地进行测试，然后提交。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some details of the Pimcore developer that are very
    important for finalizing our website.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Pimcore开发人员的一些重要细节，这对于最终完成我们的网站非常重要。
- en: The multisite configuration allows us to use only one Pimcore instance to manage
    all the company's websites. This is a very interesting feature for saving time
    and money, using only one Pimcore installation to manage all the company websites.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 多站点配置允许我们仅使用一个Pimcore实例来管理公司的所有网站。这是一个节省时间和金钱的非常有趣的功能，只需使用一个Pimcore安装来管理所有公司网站。
- en: The installers give us the power to execute installation steps to recreate the
    configuration needed by our bundle. We can create data assets and perform updates
    on them. This means that we can take our bundle, install it on another Pimcore
    instance, and add all the classes and data that the bundle needs to work on. We
    also learned that we can manage the database changes at a low level.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序赋予我们执行安装步骤以重新创建我们捆绑包所需配置的能力。我们可以创建数据资产并对它们进行更新。这意味着我们可以将我们的捆绑包安装到另一个Pimcore实例上，并添加捆绑包运行所需的所有类和数据。我们还学习了我们可以以低级别管理数据库更改。
- en: The multi-environment feature lets UX specify different configurations based
    on the environment we are using. This is very useful for keeping all the features
    in one code base. Moreover, we discovered how the powerful inheritance system
    of the configuration works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多环境功能允许UX根据我们使用的环境指定不同的配置。这对于保持所有功能在一个代码库中非常有用。此外，我们还发现了配置强大的继承系统是如何工作的。
- en: Environment variables can help make the configuration agnostic from the environment,
    and we learned how to remove sensitive data from files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以帮助使配置与环境无关，并且我们学习了如何从文件中移除敏感数据。
- en: Now our journey with the CMS part is almost completed, and we can move to the
    enterprise solutions that Pimcore has out of the box. In the next chapter, we
    will learn how to properly collect and store products in Pimcore and spread the
    information to all other applications. This is very important in enabling a company
    to use Pimcore as a PIM solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对CMS部分的旅程几乎完成，我们可以转向Pimcore开箱即用的企业解决方案。在下一章中，我们将学习如何正确地在Pimcore中收集和存储产品信息，并将信息传播到所有其他应用程序。这对于使公司能够将Pimcore用作PIM解决方案非常重要。
