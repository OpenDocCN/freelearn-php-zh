- en: 5\. Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 面向对象编程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to declare classes with constants,
    attributes, and methods; instantiate a class; work with constructors and destructors;
    implement class inheritance, access modifiers, static fields, and methods; use
    class type hinting as dependency injection; use attribute and method overriding;
    apply attribute and method overloading via magic methods; use final classes and
    methods; autoload classes; and use traits and apply namespacing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够声明具有常量、属性和方法类的类；实例化一个类；处理构造函数和析构函数；实现类继承、访问修饰符、静态字段和方法；使用类类型提示作为依赖注入；使用属性和方法重写；通过魔术方法应用属性和方法重载；使用最终类和方法；自动加载类；以及使用特性和应用命名空间。
- en: To summarize, we will have a look at **Object-Oriented Programming** (**OOP**)
    concepts that can be leveraged to write modular code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将探讨可以用来编写模块化代码的**面向对象编程**（**OOP**）概念。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In order to understand the **Object-Oriented Programming** (**OOP**) approach,
    we should start by discussing the procedural-oriented programming approach first.
    The procedural approach is the conventional way of writing code in high-level
    languages where a problem is considered a sequence of things to be performed,
    such as walking, eating, reading, and so on. A number of functions can be written
    to accomplish such tasks. The procedural approach organizes a set of computer
    instructions into groups called procedures – also known as functions. Therefore,
    functions are first-class citizens in your code. When we focus that much on functions,
    consequently, the data gets less attention.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解**面向对象编程**（**OOP**）方法，我们首先应该讨论过程式编程方法。过程式方法是在高级语言中编写代码的传统方式，其中问题被视为一系列要执行的事情，如行走、吃饭、阅读等。可以编写多个函数来完成这些任务。过程式方法将一组计算机指令组织成称为过程（也称为函数）的组。因此，函数是代码中的第一公民。当我们如此关注函数时，随之而来的是数据得到的关注较少。
- en: In a multi-function program, despite the fact that functions can house local
    data, a lot of important data is defined as global data. Several functions might
    operate on such global data and, therefore, the data might become vulnerable.
    Also, such an approach might not establish a secure way of interacting with data
    using functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在多函数程序中，尽管函数可以包含局部数据，但许多重要数据被定义为全局数据。多个函数可能会操作这样的全局数据，因此数据可能会变得脆弱。此外，这种方法可能不会建立一个安全的方式来使用函数与数据交互。
- en: 'The following figure shows you how functions operate on global data and how
    they interact with each other:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了函数如何操作全局数据以及它们如何相互交互：
- en: '![Figure 5.1: Data and functions in the procedural-oriented approach'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：过程式方法中的数据和函数'
- en: '](img/C14196_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_05_01.jpg)'
- en: 'Figure 5.1: Data and functions in the procedural-oriented approach'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：过程式方法中的数据和函数
- en: 'Now, the object-oriented approach comes with a number of different ways to
    secure your data by tying the data more closely to the functions so that accidental
    modifications to the data from external functions can be prevented. The approach,
    by nature, allows us to decompose a large problem into smaller entities called
    objects and bundles the data and functions into such objects. The following figure
    shows how data and functions are organized into objects:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，面向对象的方法提供了一系列不同的方式来保护数据，通过将数据与函数更紧密地绑定，从而防止外部函数对数据的意外修改。这种方法本质上允许我们将一个大问题分解成称为对象的小实体，并将数据和函数打包到这样的对象中。以下图展示了数据和函数是如何组织到对象中的：
- en: '![Figure 5.2: Data and functions in the object-oriented approach'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：面向对象方法中的数据和函数'
- en: '](img/C14196_05_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_05_02.jpg)'
- en: 'Figure 5.2: Data and functions in the object-oriented approach'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：面向对象方法中的数据和函数
- en: A programming approach should address major concerns, such as how we represent
    real-life problem entities in a program, how to design a program with standard
    interfaces to interact with functions, how to organize a program into a number
    of modules so that we can reuse and extend them later, how to add new features
    to such modules, and much more. The object-oriented approach was developed to
    address such issues.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程方法应该解决主要问题，例如如何在程序中表示现实生活中的问题实体，如何设计具有标准接口的程序以与函数交互，如何将程序组织成多个模块以便以后重用和扩展，如何向这些模块添加新功能，等等。面向对象的方法是为了解决这些问题而开发的。
- en: The Object-Oriented Approach
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象方法
- en: In programming, a thing that is describable and has a certain set of actions
    can be referred to as an object. An object might represent a real-life entity
    with a certain number of actions to perform. A dog can be described by using certain
    states, such as color, breed, age, and so on, and performs certain actions, such
    as barking, running, wagging its tail, and so on. A table fan can be described
    by color, speed, direction, and so on, and perform actions such as changing speed,
    changing direction, rotating, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一个可描述的事物，具有一组特定的动作，可以被称为对象。一个对象可能代表一个具有一定数量动作执行的现实生活实体。可以用某些状态来描述狗，如颜色、品种、年龄等，并执行某些动作，如吠叫、奔跑、摇尾巴等。台式风扇可以用颜色、速度、方向等来描述，并执行改变速度、改变方向、旋转等动作。
- en: In OOP, data and code are bundled together into an entity, which is known as
    an object. Objects interact with each other. Consider a teacher object and a student
    object. The teacher might have certain subjects to offer and the student might
    enroll in these subjects. Hence, if we consider enrolling as an action of the
    student, then the student object might need to interact with the teacher object
    regarding the available subjects and register for one or more subjects. Simply
    put, an object is data that performs actions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，数据和代码被捆绑成一个实体，称为对象。对象之间相互交互。考虑一个教师对象和一个学生对象。教师可能有一些科目可以提供，学生可能注册这些科目。因此，如果我们考虑注册是学生的一个动作，那么学生对象可能需要与教师对象就可用科目进行交互，并注册一个或多个科目。简单来说，对象是执行动作的数据。
- en: Bundling code into objects has its own benefits, such as your code base becoming
    modular, which means you can maintain, reuse, and debug your code individually
    against objects. The implementation of an object (code) remains hidden from the
    outside world, which means we can hide our data and internal complexities and
    can interact with the object via a standard set of procedures. For example, in
    order to use a table fan, you don't need to learn about AC motors or electronic
    circuitry; rather, you can use the table fan via the provided actions, such as
    the speed control buttons or rotation control. Hence, hiding such information
    is another important aspect of OOP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码打包成对象有其自身的好处，例如你的代码库变得更加模块化，这意味着你可以单独针对对象进行维护、重用和调试。对象的实现（代码）对外界是隐藏的，这意味着我们可以隐藏我们的数据和内部复杂性，并且可以通过一套标准的程序与对象交互。例如，为了使用台式风扇，你不需要了解交流电机或电子电路；相反，你可以通过提供的行为来使用台式风扇，例如速度控制按钮或旋转控制。因此，隐藏此类信息是面向对象编程的另一个重要方面。
- en: Such code bundling also differentiates OOP from procedural programming. An object
    simply contains attributes, also known as data, and a bunch of methods to communicate
    with that object. These methods are the functions of procedural programming. In
    OOP, some of these methods can be used to interact with that object, and these
    methods therefore make up its interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码打包也区分了面向对象编程和过程式编程。一个对象简单地包含属性，也称为数据，以及一些与该对象通信的方法。这些方法是过程式编程的功能。在面向对象编程中，这些方法中的一些可以用来与该对象交互，因此这些方法构成了它的接口。
- en: There are a good number of famous programming languages, such as C++, Java,
    PHP, Python, C#, JavaScript, Ruby, Dart, Swift, Objective-C, and so on, that support
    OOP. Since the introduction of PHP to its most recent version, PHP supports the
    complete set of object-oriented models. PHP supports class-based object initiation,
    constructors and destructors, inheritance, property visibility, polymorphism,
    abstract and final classes, static fields and methods, anonymous classes, interfaces,
    namespaces, magic methods, object cloning, object comparisons, type hinting, traits,
    and much more interesting OOP techniques and tools. We will be discussing them
    in this chapter and will practice the concepts of OOP using different examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多著名的编程语言支持面向对象编程，例如C++、Java、PHP、Python、C#、JavaScript、Ruby、Dart、Swift、Objective-C等等。自从PHP引入其最新版本以来，PHP支持完整的面向对象模型。PHP支持基于类的对象初始化、构造函数和析构函数、继承、属性可见性、多态、抽象和最终类、静态字段和方法、匿名类、接口、命名空间、魔术方法、对象克隆、对象比较、类型提示、特性等许多有趣的面向对象技术和工具。我们将在本章中讨论它们，并使用不同的示例来实践面向对象编程的概念。
- en: OOP Concepts
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象概念
- en: 'The object-oriented approach addresses programming problems using the generalized
    concepts given in the following list. In this chapter, we are going to discuss
    these concepts in detail and practice them using a number of exercises so that,
    by the end of the chapter, we''ll be used to working with these concepts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的方法使用以下列表中给出的通用概念来解决编程问题。在本章中，我们将详细讨论这些概念，并通过一系列练习来实践它们，以便在章节结束时，我们将习惯于使用这些概念：
- en: Objects are entities with data and interfaces. They may represent a person,
    a vehicle, a table fan, or maybe a bank account that plays a role in our program.
    Data and functions (or methods) live together inside an object.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是有数据和接口的实体。它们可能代表一个人、一辆车、一个电风扇，或者可能是一个在我们的程序中扮演角色的银行账户。数据和函数（或方法）共同存在于一个对象中。
- en: Classes are templates for object creation. Data is the description of an object,
    while functions are the behaviors of that object, so such definitions of data
    and methods can be written using a class. Classes can be referred to as custom
    data types.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象创建的模板。数据是对象的描述，而函数是那个对象的行为，因此可以使用类来编写数据和方法的定义。类可以被称为自定义数据类型。
- en: Data encapsulation is the wrapping up of data and functions into a single unit
    – that is, a class. Imagine an unbreachable capsule with data and functions encapsulated
    inside so that the outside world cannot access the data as long as we don't expose
    methods for them. Such insulation of the data from direct access by the program
    is called data hiding. In short, declaring a class is the encapsulation of data.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据封装是将数据和函数封装成一个单一单元——即类。想象一个不可穿透的胶囊，其中封装着数据和函数，这样外部世界就不能访问数据，除非我们为它们提供访问方法。这种将数据从程序直接访问中隔离出来的过程称为数据隐藏。简而言之，声明一个类就是数据的封装。
- en: Data abstraction is the act of representing essential properties and features
    without giving details. So, the entire entity description remains abstract and
    the responsibility of detailing the entity can be done via the entity creation
    process or inheritance. Such abstraction enables everyone to "follow the guidelines
    and do it your way."
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据抽象是不提供细节而表示基本属性和特征的行为。因此，整个实体描述保持抽象，详细描述实体的责任可以通过实体创建过程或继承来完成。这种抽象使得每个人都可以“遵循指南，按自己的方式行事。”
- en: Inheritance is the process of acquiring properties and behaviors of another
    class so that common properties and behaviors can be reused in a hierarchical
    manner.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承是获取另一个类的属性和行为的过程，这样就可以以分层的方式重用共同的属性和行为。
- en: Polymorphism is the concept of using the same definition for multiple purposes.
    For example, flying is a polymorphic behavior, as birds and airplanes have their
    own different ways of flying.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态是使用相同定义进行多个目的的概念。例如，飞行是一种多态行为，因为鸟类和飞机有它们自己不同的飞行方式。
- en: Dynamic binding is the linking of a function call to the code that will be executed
    in response to the function call. With this concept, the code associated with
    the given function is unknown until the call is made at runtime. Say that multiple
    objects implemented the same function differently and at runtime, the code matching
    the object being referenced would be called.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态绑定是将函数调用与响应函数调用的代码链接起来的过程。有了这个概念，与给定函数关联的代码在运行时调用之前是未知的。比如说，多个对象以不同的方式实现了同一个函数，在运行时，与被引用的对象匹配的代码会被调用。
- en: Message passing is the way that objects interact with each other. It involves
    specifying the object name, the name of the methods, and the information to be
    sent. For example, if a car is an object, changing speed is a method on it, and
    speed in kilometers per hour is the speed parameter to be passed. The outside
    world will use the car object to send the "change speed" message to that parameter.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递是对象之间交互的方式。它涉及指定对象名称、方法名称和要发送的信息。例如，如果一辆车是一个对象，改变速度是它上面的一个方法，每小时千米数是传递的速度参数。外部世界将使用汽车对象将“改变速度”的消息发送给该参数。
- en: '*Figure 5.3* depicts the preceding concepts using a vehicle analogy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3* 使用车辆类比来展示前面的概念：'
- en: '![Figure 5.3: Vehicle property inheritance diagram'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：车辆属性继承图'
- en: '](img/C14196_05_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_03.jpg)'
- en: 'Figure 5.3: Vehicle property inheritance diagram'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：车辆属性继承图
- en: There are many different types of vehicles, such as cars, buses, motorcycles,
    airplanes, and many more. Vehicles have general properties such as make, model,
    color, wheels, engine size, and so on. These are the common properties found in
    vehicle subtypes or classes too. Since cars, buses, motorcycles, and so on share
    a common list of properties, those common properties and behaviors come from the
    parent class, and each subclass adds its very own properties and behaviors. For
    example, cars have four wheels and motorcycles are two-wheelers, cars have more
    passenger capacity than a motorcycle, and so on. Therefore, such deviations of
    vehicle types should be placed into their own vehicle subclasses. Thus, we can
    inherit common properties and gradually add our own properties using object-oriented
    concepts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的车辆，例如汽车、公共汽车、摩托车、飞机等等。车辆具有一般属性，如制造商、型号、颜色、车轮、发动机大小等。这些是车辆子类型或类中常见的属性。由于汽车、公共汽车、摩托车等共享一个共同的属性列表，这些共同的属性和行为来自父类，每个子类都添加它自己的属性和行为。例如，汽车有四个车轮，摩托车是两轮车，汽车比摩托车有更多的乘客容量，等等。因此，这种车辆类型的偏差应该放置在其自己的车辆子类中。因此，我们可以继承共同的属性，并逐步添加我们自己的属性，使用面向对象的概念。
- en: Classes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is a blueprint of an object. What data an object should contain and
    what methods are needed to access that data can be described using a class. A
    class acts as a template for object creation. Consider a car designed using a
    blueprint as a guide. Vehicle type, make, model, engine size, color, and so on
    are defined in the `Car` class along with the methods to retrieve this information,
    such as get the model name, start the engine, and so on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的蓝图。一个对象应该包含哪些数据以及需要哪些方法来访问这些数据可以使用类来描述。类充当对象创建的模板。考虑使用蓝图作为指南设计的汽车。车辆类型、制造商、型号、发动机大小、颜色等都在
    `Car` 类中定义，以及检索这些信息的方法，例如获取型号名称、启动发动机等。
- en: A class begins with the `class` keyword followed by the given name and the body
    enclosed in a pair of curly braces. The body of the class houses class members
    and they are variables, constants, functions, class variables (also known as class
    properties or class attributes), and the functions that belong to the class, known
    as class methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类以 `class` 关键字开始，后跟给定的名称，并用一对花括号括起来的主体。类的主体包含类成员，它们是变量、常量、函数、类变量（也称为类属性或类属性），以及属于类的函数，称为类方法。
- en: 'Check out the following class declaration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下类声明：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A class name starts with letters or underscores followed by any number of alphanumeric
    characters and underscores. PHP's predefined class names, constants, and reserved
    keywords – for example, `break`, `else`, `function`, `for`, `new`, and so on –
    cannot be used as a class name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类名以字母或下划线开头，后跟任意数量的字母数字字符和下划线。PHP 的预定义类名、常量和保留关键字（例如，`break`、`else`、`function`、`for`、`new`
    等）不能用作类名。
- en: The list of reserved words in PHP can be found at [https://packt.live/2M3QL1d](https://packt.live/2M3QL1d).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中保留字列表可以在 [https://packt.live/2M3QL1d](https://packt.live/2M3QL1d) 找到。
- en: In the PHP Standards Recommendations, PSR-1 recommends that a class name is
    declared in `CamelizedClassName` and class methods are declared in `camelizedMethodName`.
    Note the camel case of *class name* and the use of lowercase at the start of the
    method names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 标准建议中，PSR-1 建议类名以 `CamelizedClassName` 声明，类方法以 `camelizedMethodName` 声明。注意
    *类名* 的驼峰式命名和在每个方法名开头使用小写字母。
- en: 'To learn more about PSR-1: Basic Coding Standard, visit [https://packt.live/2IBLprS](https://packt.live/2IBLprS).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 PSR-1：基本编码标准的信息，请访问 [https://packt.live/2IBLprS](https://packt.live/2IBLprS)。
- en: 'Let''s check out the following simple `Person` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下简单的 `Person` 类：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `class Person {…}` is the `Person` class declaration. A single attribute
    has been added with the line `public $name = 'John Doe';`, and the body also contains
    the `sayHello()` member method, which prints a simple string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`class Person {…}` 是 `Person` 类的声明。通过添加一行 `public $name = 'John Doe';` 添加了一个属性，并且主体还包含了
    `sayHello()` 成员方法，该方法会打印一个简单的字符串。
- en: In the next section, we will be discussing how we should instantiate a class
    and what happens in memory when we perform such an instantiation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论我们应该如何实例化一个类，以及当我们执行此类实例化时内存中会发生什么。
- en: Instantiating a Class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: 'An object is an instance of a class, so instantiating a class means creating
    a new object using the class. We can instantiate a class using the `new` keyword,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是一个类的实例，因此实例化一个类意味着使用该类创建一个新的对象。我们可以使用`new`关键字来实例化一个类，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the instantiation, an object is created in memory with copies of its own
    attributes. Here, the `$object` variable doesn't hold the actual object; rather,
    it points to the object. Just to be clear here, the `$object` variable is a pointer
    to the object and doesn't hold a reference to the object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化过程中，一个对象在内存中创建，并包含其自身的属性副本。在这里，`$object`变量并不持有实际的对象；相反，它指向该对象。为了明确起见，`$object`变量是对象的指针，并不持有对象的引用。
- en: The `$object` variable should be of the `MySimpleClass` type as classes are
    often called as custom data types. Then, the constructor method gets called automatically
    if one is declared. A class constructor and destructor are two special kinds of
    methods; for example, `__construct()` and `__destruct()`, which are called automatically
    with object creation and deletion, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`$object`变量应该是`MySimpleClass`类型，因为类通常被称为自定义数据类型。然后，如果声明了构造方法，构造方法会自动调用。类构造器和析构器是两种特殊的方法；例如，`__construct()`和`__destruct()`，它们分别在对象创建和删除时自动调用。'
- en: 'To access an object''s properties and methods, we can use the `->` object operator,
    as in the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问对象的属性和方法，我们可以使用`->`对象操作符，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, object creation involves memory allocation followed by the constructor method
    being called automatically. We are going to discuss constructor and destructor
    methods in later sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对象的创建涉及内存分配，然后自动调用构造方法。我们将在后面的章节中讨论构造方法和析构方法。
- en: Class Attributes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性
- en: As we have already seen, class attributes and variables hold data. To write
    a class attribute in PHP, we need to start with the `public`, `private`, or `protected`
    keyword, then the rest is the general PHP variable assignment statement. In the
    previous example, in the `Person` class, the `public $name = 'John Doe';` line
    was used to assign a person's name; here, the `public` keyword is an access modifier
    or class member visibility keyword and it has been used so that the attribute
    can be accessed outside of the class. We will be discussing access modifiers in
    detail in later sections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，类的属性和变量持有数据。要在PHP中编写类属性，我们需要从`public`、`private`或`protected`关键字开始，然后是其余的一般PHP变量赋值语句。在先前的`Person`类示例中，`public
    $name = 'John Doe';`这一行被用来分配一个人的名字；在这里，`public`关键字是一个访问修饰符或类成员可见性关键字，它已经被用来确保属性可以在类外部被访问。我们将在后面的章节中详细讨论访问修饰符。
- en: 'Note that the class structure is compiled before the PHP file execution. Regarding
    value assignment in class attributes, the value should be static, meaning the
    value must not be dependent on the runtime. For example, the following class attributes
    won''t work:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类结构在PHP文件执行之前被编译。关于类属性的值赋值，值应该是静态的，这意味着值不能依赖于运行时。例如，以下类属性将不会工作：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the attributes are dependent on the `getdate()` function's return and
    an arithmetic expression evaluation, respectively, as function calling and the
    arithmetic expression evaluation won't be performed during the class' compile
    time and can be evaluated at runtime, so such variable initialization won't work
    in the case of class attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，属性分别依赖于`getdate()`函数的返回值和算术表达式评估，分别作为函数调用和算术表达式评估，这些都不会在类的编译时执行，而可以在运行时评估，因此这样的变量初始化在类属性的情况下不会工作。
- en: 'So, class attributes that do not involve in runtime information should be considered
    a good attribute, such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不涉及运行时信息的类属性应该被视为好的属性，例如以下内容：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the preceding variables can be evaluated at compile time rather than at
    runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前面的变量可以在编译时而不是在运行时评估。
- en: 'Non-static class attributes—for example, the `public`, `private`, and `protected`
    attributes—can be accessed by using the `$this` object context referrer variable
    with the `->` object operator, as in the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态类属性——例如，`public`、`private`和`protected`属性——可以通过使用`$this`对象上下文引用变量和`->`对象操作符来访问，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, static properties can be written with the `static` keyword at the start
    of the variable declaration and can be accessed using the `self` keyword followed
    by the `::` (double colon) operator. The double colon is also called the scope
    operator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，静态属性可以用 `static` 关键字在变量声明开始处编写，并且可以使用 `self` 关键字后跟 `::`（双冒号）操作符来访问。双冒号也称为范围操作符：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: More on access modifiers and static properties can be found in later sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问修饰符和静态属性的更多内容可以在后面的章节中找到。
- en: Class Constants
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类常量
- en: 'Class-specific constants (fixed values that do not change throughout the program)
    can be written inside a class, as in the following examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类特定的常量（在整个程序中不改变的固定值）可以写在类内部，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that class constants do not use `$` as it is used in variable declaration
    and are all the letters are in uppercase. The default visibility of the constant
    is `public` and they can be accessed with the `::` scope operator from outside
    of the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类常量不使用 `$` 符号，就像变量声明中使用的那样，并且所有字母都是大写。常量的默认可见性是 `public`，并且可以从类外部使用 `::`
    范围操作符来访问。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: According to the PHP Standards Recommendations, PSR-1, "Class constants MUST
    be declared in all upper case with underscore separators." You can read more at
    [https://packt.live/2IBLprS](https://packt.live/2IBLprS).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PHP 标准建议，PSR-1，“类常量必须全部大写，使用下划线分隔。”你可以在 [https://packt.live/2IBLprS](https://packt.live/2IBLprS)
    上了解更多信息。
- en: Class constants are allocated memory for a single class and not for every class
    instance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量只为单个类分配内存，而不是为每个类实例分配。
- en: 'Also, you can use such constants using `self::` inside a class, as in the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在类内部使用 `self::` 来使用此类常量，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `self::` operator can be used only inside a class. Since PHP 5.6.0, the
    constant expression has been added as in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`self::` 操作符只能在类内部使用。自 PHP 5.6.0 版本以来，已添加了常量表达式，如下所示：'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Class constants also support access modifiers; for example, `public`, `private`,
    and so on, which will be demonstrated in the *Access Modifiers* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量也支持访问修饰符；例如，`public`、`private` 等，这些将在 *访问修饰符* 部分进行演示。
- en: You can use such constants in PHP interfaces, which are another OOP tool to
    establish a common interface or the standards that classes should implement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PHP 接口中使用此类常量，这是另一种面向对象编程工具，用于建立公共接口或类应该实现的规范。
- en: The $this Variable
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$this` 变量'
- en: '`$this` is the pseudo variable that is available when class member variables
    or methods are called within an object context. `$this` works when we have instantiated
    a class and can be used to access the corresponding object''s members. So, to
    access an attribute in an object context, we use `$this->attribute_name`, and
    to access a method, we use `$this->methodName()`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this` 是在对象上下文中调用类成员变量或方法时可用的一个伪变量。当实例化一个类后，`$this` 就可以使用来访问相应对象的成员。因此，在对象上下文中访问一个属性时，我们使用
    `$this->attribute_name`，访问方法时使用 `$this->methodName()`。'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For example, a `$name` attribute declared in the class should be accessed with
    `$this->name`, not with `$this->$name`. Mind the `$` here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在类中声明的 `$name` 属性应该使用 `$this->name` 来访问，而不是使用 `$this->$name`。请注意这里的 `$` 符号。
- en: Class Methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: Class methods are just functions and act like wrappers on the class data assigned
    to attributes. Getter and setter are the two most common ways of fetching and
    assigning data, respectively. Both of these methods simply return and assign data
    from and to member variables. We might want to prefix the getter and setter methods
    with `get` and `set` followed by a quick descriptive method name of our choice;
    for example, `getMyValue()` or `setMyValue()`. Although this is not necessary,
    this practice improves code readability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法只是函数，并且像包装器一样作用于分配给属性的类数据。获取器和设置器是分别获取和分配数据的两种最常见方式。这两种方法只是简单地从和向成员变量返回和分配数据。我们可能希望使用
    `get` 和 `set` 前缀以及我们选择的快速描述性方法名称来前缀获取器和设置器方法；例如，`getMyValue()` 或 `setMyValue()`。尽管这不是必需的，但这种做法可以提高代码的可读性。
- en: 'Check out the following getter and setter methods example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下获取器和设置器方法示例：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the key concept of such member methods is to provide a wrapper around
    the data available in an object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，此类成员方法的关键概念是为对象中可用的数据提供一个包装器。
- en: 'Along with these, another type of method can often be used that performs certain
    actions or executions based on the available data within the object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还可以使用另一种类型的方法，它根据对象内部可用的数据执行某些操作或执行：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `sayGreetings()` method could be an example of a member method that
    implements an algorithm to identify the current hour and load a greetings string
    into a local variable, and later on prints the greetings string with the given
    attribute value assigned at `$name`. The method works for printing greetings –
    for example, '`Good Morning John Doe`', '`Good Afternoon John Doe`', and '`Good
    Evening John Doe`' – based on the current hour in 24-hour format, returned by
    the `date('G')` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sayGreetings()` 方法可以是实现识别当前小时并将问候字符串加载到局部变量的成员方法的示例，然后稍后使用分配给 `$name` 的给定属性值打印问候字符串。该方法用于打印问候语——例如，`'Good
    Morning John Doe'`、`'Good Afternoon John Doe'` 和 `'Good Evening John Doe'`——基于由
    `date('G')` 函数返回的 24 小时制当前小时。
- en: We also have some manager methods, such as constructor and destructor, to initiate
    properties of an object and clean up the memory utilized by an object, respectively.
    In later sections, we will be discussing them in detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些管理方法，如构造函数和析构函数，分别用于初始化对象的属性和清理对象使用的内存。在后面的章节中，我们将详细讨论它们。
- en: 'Exercise 5.1: Using the Getter and Setter Methods'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.1：使用获取和设置方法
- en: 'In the following exercise, you will declare a `Vehicle` class with attributes
    such as make, model, color, and number of wheels. Also, to access and work on
    those given attributes, we will be declaring some methods, such as to get the
    model name, get the engine number, get the number of the wheels, and so on:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将声明一个具有型号、型号、颜色和轮子数量等属性的 `Vehicle` 类。此外，为了访问和操作这些给定的属性，我们将声明一些方法，例如获取型号名称、获取发动机编号、获取轮子数量等：
- en: 'Create a PHP file named `Vehicle.php` and declare the `Vehicle` class with
    the following attributes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Vehicle.php` 的 PHP 文件，并声明具有以下属性的 `Vehicle` 类：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `Vehicle` object is described using a make, model, color, number of wheels,
    and engine number. Here, we have added this data about the vehicle in terms of
    class attributes. As different types of data can be bundled together inside a
    class, our `Vehicle` class can act as a custom data type. Just like the preceding
    class, we can enclose a lot of metadata about an object, as per OOP concepts.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用型号、型号、颜色、轮子数量和发动机编号来描述 `Vehicle` 对象。在这里，我们将有关车辆的数据添加为类属性。由于不同类型的数据可以打包在类内部，我们的
    `Vehicle` 类可以充当自定义数据类型。就像前面的类一样，我们可以根据面向对象的概念封装大量关于对象的元数据。
- en: Note that the values that have been assigned to the class attributes do not
    depend on runtime; they can easily be assigned at compile time. All of them are
    clearly different types of data and are accessible or visible from outside the
    class as they use a public access modifier.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，分配给类属性的值不依赖于运行时；它们可以轻松地在编译时分配。所有这些都是不同类型的数据，并且由于它们使用公共访问修饰符，因此可以从类外部访问或可见。
- en: 'Now it is time to add member methods to the class. As per our exercise goal,
    we need to know information such as the number of wheels the vehicle has, the
    engine number, and the make, model, and color. In order to obtain that information,
    we are going to add the following five methods after the attributes section:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候向类添加成员方法了。根据我们的练习目标，我们需要了解有关车辆轮子数量、发动机编号、型号和颜色等信息。为了获取这些信息，我们将在属性部分之后添加以下五个方法：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have added five getter methods: `getMake()` returns the company name/make,
    `getModel()` returns the model name, `getColor()` returns the color name, `getNoOfWheels()`
    returns the number of wheels the vehicle has, and `getEngineNumber()` returns
    the engine number. All of these methods are pretty straightforward to execute,
    and they access the attributes using `$this` to return the values.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了五个获取方法：`getMake()` 返回公司名称/型号，`getModel()` 返回型号名称，`getColor()` 返回颜色名称，`getNoOfWheels()`
    返回车辆拥有的轮子数量，而 `getEngineNumber()` 返回发动机编号。所有这些方法执行起来都很简单，它们使用 `$this` 访问属性以返回值。
- en: 'To set the vehicle make, model, color, number of wheels, and engine number,
    we need setter methods. Now, let''s add the corresponding setter methods after
    the preceding five getters:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置车辆的型号、型号、颜色、轮子数量和发动机编号，我们需要设置方法。现在，让我们在前面五个获取方法之后添加相应的设置方法：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have added the five setter methods to set our appropriate class attributes.
    The `setMake($make)` method accesses the class attribute for `$make` using `$this->make`
    and assigns the `$make` argument to it. The same goes for `setModel($model)`,
    `setColor($color)`, `setNoOfWheels($wheels)`, and `setEngineNumber($engineNo)`.
    All of them access the corresponding class attributes to assign the passed parameter
    to them. Hence, we can set class attributes using setter methods.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了五个设置器方法来设置适当的类属性。`setMake($make)` 方法使用 `$this->make` 访问类属性 `$make`
    并将 `$make` 参数分配给它。对于 `setModel($model)`、`setColor($color)`、`setNoOfWheels($wheels)`
    和 `setEngineNumber($engineNo)` 也是同样的情况。所有这些方法都访问相应的类属性，将传递的参数分配给它们。因此，我们可以使用设置器方法设置类属性。
- en: 'Finally, our class looks like the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们的类看起来如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s instantiate the class as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实例化类：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the class has been instantiated to create an object of the `Vehicle` class.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，类已经被实例化以创建 `Vehicle` 类的对象。
- en: 'Set the class attributes using the setter methods, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置器方法设置类属性，如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have assigned the make, model, color, number of wheels, and engine
    number class attributes via the class member methods; that is, setter methods.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过类成员方法（即设置器方法）分配了制造、型号、颜色、车轮数量和发动机号类属性；也就是说，设置器方法。
- en: 'To access the data stored in the `Vehicle` object handler, `$object`, we need
    to use getter methods, as in the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问存储在 `Vehicle` 对象处理程序 `$object` 中的数据，我们需要使用获取器方法，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the `Vehicle.php` file using the `Vehicle.php` PHP command. The preceding
    code should output the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Vehicle.php` PHP 命令运行 `Vehicle.php` 文件。前面的代码应该输出以下内容：
- en: '![Figure 5.4: Vehicle object''s setter and getter methods'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：车辆对象的设置器和获取器方法'
- en: '](img/C14196_05_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_04.jpg)'
- en: 'Figure 5.4: Vehicle object''s setter and getter methods'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：车辆对象的设置器和获取器方法
- en: So, we have a `Vehicle` class that describes a particular type of vehicle with
    different attributes associated to vehicle, and the getter and setter methods
    to work on the attributes. From now on, we will be working with this `Vehicle`
    class to exercise our OOP understanding.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个 `Vehicle` 类，它描述了具有与车辆相关联的不同属性的特定类型的车辆，以及用于操作这些属性的设置器和获取器方法。从现在开始，我们将使用这个
    `Vehicle` 类来练习我们的面向对象理解。
- en: Just to summarize, the exercise we walked through is all about defining a class,
    so the key learning here is that we have to add class attributes that sufficiently
    describe the particular type of object and write methods to set and fetch data
    from those attributes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 简要来说，我们刚才进行的练习完全是关于定义一个类，所以这里的关键学习是，我们必须添加足够描述特定类型对象的类属性，并编写设置和从这些属性获取数据的方法。
- en: In the next section, we will discuss how constructor and destructor methods
    fit a role in a class structure and walk through an exercise on how to instantiate
    the `Vehicle` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论构造函数和析构函数方法在类结构中的作用，并介绍一个关于如何实例化 `Vehicle` 类的练习。
- en: Constructor
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: A constructor, such as `__construct()`, is a special kind of method that is
    invoked automatically when instantiating a class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，如 `__construct()`，是一种特殊的方法，在实例化类时自动调用。
- en: 'The syntax of a class constructor is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数的语法如下：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s add a `__construct()` method in our previously discussed `Person` class
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前讨论的 `Person` 类中添加一个 `__construct()` 方法，如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The key idea behind using a `__construct()` method is to perform the initial
    set of executions that need to be done immediately upon object creation. In the
    preceding simple approach, a `__construct()` method performs attribute assignment(s).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__construct()` 方法的核心思想是在对象创建后立即执行需要执行的一组初始操作。在前面的简单方法中，`__construct()` 方法执行属性分配。
- en: 'Hence, we can create instances of the `Person` class like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以创建 `Person` 类的实例，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `MySimpleClass` constructor, `__construct()`, takes an argument, `$username`,
    and assigns it to the `$name` attribute by accessing it with `$this->name`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MySimpleClass` 构造函数 `__construct()` 接收一个参数 `$username`，并通过 `$this->name`
    访问它，将其分配给 `$name` 属性。
- en: Apart from the initial value assignment, a constructor method might hold a database
    connection, set cookies, hold an HTTP client, accept dependencies as arguments,
    and much more.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始值分配之外，构造函数方法可能包含数据库连接、设置cookie、持有HTTP客户端、接受依赖项作为参数等。
- en: A constructor method must not have a return statement, it can accept arguments,
    and the name should always be `__construct()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数方法不能有返回语句，它可以接受参数，并且名称应该是`__construct()`。
- en: Destructor
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数
- en: The destructor method, `__destruct()`, is invoked automatically when an object
    is destroyed. When we remove an object or perhaps a PHP script ends its execution
    and releases the memory utilized by the variables, then `__destruct()` gets called.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数方法`__destruct()`在对象被销毁时自动调用。当我们删除一个对象或者PHP脚本结束执行并释放变量使用的内存时，`__destruct()`就会被调用。
- en: 'The syntax of a class destructor is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类析构函数的语法如下：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s add a `__destruct()` method to our previously discussed `Person` class,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前讨论的`Person`类中添加一个`__destruct()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, as an example, the `__destruct()` method can be added for log-keeping
    purposes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，作为一个例子，可以添加`__destruct()`方法用于日志记录目的。
- en: 'If we `unset()` the object handler variable to destroy the object instance,
    as follows, the destructor should be called automatically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们`unset()`对象处理变量来销毁对象实例，如下所示，析构函数应该会自动调用：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, the destructor method is invoked automatically if no object is found
    in the memory, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果没有在内存中找到对象，析构函数方法也会自动调用，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apart from the preceding manual object destruction, when the script execution
    ends, all the `__destruct()` methods within different objects are invoked automatically
    and PHP will start to release the memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的手动对象销毁之外，当脚本执行结束时，不同对象中的所有`__destruct()`方法都会自动调用，PHP将开始释放内存。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A destructor method does not take arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数方法不接收参数。
- en: Just to summarize, so far, we have learned about class declaration with attributes
    and methods, the instantiation of a class, and constructor and destructor methods.
    Hence, we should walk through the next exercise to apply these concepts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，到目前为止，我们已经学习了具有属性和方法类的声明、类的实例化以及构造函数和析构函数方法。因此，我们应该通过下一个练习来应用这些概念。
- en: 'Exercise 5.2: Instantiating the Class and Printing the Details'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.2：实例化类并打印详细信息
- en: 'In the following exercise, you will learn how to instantiate the `Vehicle`
    class that we created in the previous exercise. We will introduce a constructor
    to it so that we can assign attributes via the constructor''s parameters instead
    of assigning the values during the class declaration. We should be able to print
    that information using the corresponding getters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将学习如何实例化我们在上一个练习中创建的`Vehicle`类。我们将向其中引入一个构造函数，这样我们就可以通过构造函数的参数来分配属性，而不是在类声明期间分配值。我们应该能够使用相应的获取器打印这些信息：
- en: 'Open the `Vehicle` class file, `Vehicle.php`, and you should see the attributes
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Vehicle`类文件，`Vehicle.php`，你应该会看到以下属性：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have a better way of assigning the values of these attributes using a constructor
    method.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有更好的方法来使用构造函数方法分配这些属性的值。
- en: 'Modify the attributes as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改属性如下：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have taken out the default values assigned to the attributes.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经提取了分配给属性的默认值。
- en: 'Add the `__construct` method after the attributes section as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性部分之后添加`__construct`方法，如下所示：
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have added the default values of the constructor's parameters as the
    default values for the attributes if no values were passed.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将构造函数参数的默认值作为属性的默认值，如果没有传递值。
- en: The constructor method will be invoked automatically with the instantiation
    of the `Vehicle` class. If we can pass parameters with the new object creation,
    they are received inside the constructor.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数方法将在`Vehicle`类实例化时自动调用。如果我们可以在创建新对象时传递参数，它们将在构造函数内部接收。
- en: 'Within the `__construct()` method, assign the parameters to the corresponding
    attributes, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__construct()`方法中，将参数分配给相应的属性，如下所示：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have assigned the attributes obtained from the constructor arguments.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将从构造函数参数获得的属性分配给属性。
- en: 'Erase or comment out the following lines for the `Vehicle` class initialization
    and the use of setters and getters from `Vehicle.php`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释掉以下行以初始化`Vehicle`类和使用`Vehicle.php`中的设置器和获取器：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have erased these lines as we are going to include the `Vehicle.php` file
    in another file that will take care of the `Vehicle` initialization. So far, we
    have the `Vehicle` class ready to use in the next steps.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经删除了这些行，因为我们打算将`Vehicle.php`文件包含到另一个文件中，该文件将负责`Vehicle`的初始化。到目前为止，`Vehicle`类已经准备好在下一步中使用。
- en: 'Create a new PHP file called `vehicle-objects.php` in the same directory and
    add the following lines to require the `Vehicle` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个名为 `vehicle-objects.php` 的新 PHP 文件，并添加以下行以包含 `Vehicle` 类：
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `vehicle-objects.php` script, we have added the `Vehicle` class using
    the `require_once` command, which will add the file if it's not already added
    or produce a fatal error in the event that the file is not found. For the next
    steps, we will be working on this file.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `vehicle-objects.php` 脚本中，我们使用 `require_once` 命令添加了 `Vehicle` 类，如果文件尚未添加，则会添加该文件；如果找不到文件，则会产生致命错误。对于接下来的步骤，我们将在这个文件上工作。
- en: 'Now, it''s time to instantiate the class. Create an object without passing
    any arguments to the constructor as follows, after requiring the `Vehicle` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实例化类了。在包含 `Vehicle` 类之后，按照以下方式创建一个不向构造函数传递任何参数的对象：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have created an object of the `Vehicle` type with the `new` keyword
    and the constructor should be called after the memory allocation for the copy
    of the object's own attributes.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `new` 关键字创建了一个 `Vehicle` 类型的对象，构造函数应该在为对象属性副本分配内存之后调用。
- en: As we have getter methods written already to access the preceding attributes,
    we should try to print the attribute information.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已经编写了获取前面属性的 getter 方法，我们应该尝试打印属性信息。
- en: 'Print the attribute information with the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式打印属性信息：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As all of the `Vehicle` member methods are public, we can access the vehicle
    data via the interface of the instantiated `$vehicle` object.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于所有的 `Vehicle` 成员方法都是公开的，我们可以通过实例化的 `$vehicle` 对象的接口访问车辆数据。
- en: 'Also, all of the `Vehicle` attributes are public, so we can access the attributes
    using the `$vehicle` object handler outside of the class. So, the following code
    should output the same as the preceding:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，所有的 `Vehicle` 属性都是公开的，因此我们可以在类外部使用 `$vehicle` 对象处理器来访问这些属性。所以，以下代码应该会输出与前面相同的结果：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The standard way to access object attributes is via the object's member methods.
    When we apply restrictions on object attributes, accessing them should be performed
    via object interfaces or methods only.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问对象属性的标准方式是通过对象的成员方法。当我们对对象属性施加限制时，访问它们应该仅通过对象接口或方法进行。
- en: 'From the terminal or console, run `vehicle-objects.php` using the `php vehicle-objects.php`
    command. The preceding code outputs the following:![Figure 5.5: Vehicle object''s
    default attributes'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端或控制台运行 `vehicle-objects.php`，使用 `php vehicle-objects.php` 命令。前面的代码输出以下内容：![图
    5.5：车辆对象的默认属性
- en: '](img/C14196_05_05.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_05.jpg)'
- en: 'Figure 5.5: Vehicle object''s default attributes'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.5：车辆对象的默认属性
- en: Here, we haven't passed arguments to the class constructor, so the default parameter
    values have been assigned to the attributes.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们没有向类构造函数传递任何参数，因此属性被分配了默认参数值。
- en: 'Now, we will create another object with parameters passed to the constructor
    after the lines in *step 7*, like the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在 *步骤 7* 之后的行中创建另一个对象，并传递给构造函数的参数，如下所示：
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rerun `Vehicle.php` using the `php vehicle-objects.php` command. The portion
    of code in *step 9* outputs the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php vehicle-objects.php` 命令重新运行 `Vehicle.php`。*步骤 9* 中的代码部分输出以下内容：
- en: '![Figure 5.6: Printing the details on the terminal'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6：在终端上打印详细信息'
- en: '](img/C14196_05_06.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_06.jpg)'
- en: 'Figure 5.6: Printing the details on the terminal'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：在终端上打印详细信息
- en: So, the attributes' initial values can be settled via the constructor parameters.
    Regardless of the constructor parameters, attributes can be assigned using setter
    methods when you want to prevent direct access to your attributes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过构造函数参数来设定属性的初始值。无论构造函数参数如何，当您想防止直接访问您的属性时，都可以使用设置器方法来分配属性。
- en: Inheritance
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: To implement the idea of reusability, we need to learn the process of acquiring
    the properties of objects of one class (the parent class) using the objects of
    another class (the child class). Hence, inheritance is the process of deriving
    one class from a base class (the parent class) and the derived class (a child
    class or subclass).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现可重用性的想法，我们需要学习使用另一个类的对象（子类）获取一个类（父类）的对象属性的过程。因此，继承是从基类（父类）派生出一个类（子类或子类）的过程。
- en: Inheritance supports the flow of information in a hierarchical way to the derived
    objects so that, along with the inherited properties, the derived class can add
    its own properties. Again, such a derived class can be inherited by another and
    so on. Bundled data and actions can be reused in an organized manner to add additional
    features to derived classes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 继承支持以分层方式将信息流向派生对象，这样，除了继承的属性外，派生类还可以添加自己的属性。再次强调，这样的派生类还可以被另一个类继承，以此类推。捆绑的数据和行为可以以组织化的方式重用，以向派生类添加额外的功能。
- en: 'Inheritance allows us to implement the idea of hierarchical classification
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使我们能够以下面的方式实现层次分类的概念：
- en: '![Figure 5.7: Inheritance diagram'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7：继承图'
- en: '](img/C14196_05_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_07.jpg)'
- en: 'Figure 5.7: Inheritance diagram'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：继承图
- en: As the preceding diagram shows, the `Car` and `Motorcycle` classes can be derived
    from the base `Vehicle` class to reuse the attributes, constructors, and methods.
    Hence, the derived classes inherit the members from the base class and are allowed
    to add their own members for example, `Car` adds four doors — or modify inherited
    members — motorcycle modifies the number of wheels to two, and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`Car` 和 `Motorcycle` 类可以从基类 `Vehicle` 派生出来，以重用属性、构造函数和方法。因此，派生类从基类继承了成员，并被允许添加自己的成员，例如，`Car`
    添加了四个车门——或者修改继承成员——摩托车将轮子的数量修改为两个，等等。
- en: With the derived classes, you can keep and reuse the members of the parent class.
    Also, you can override the parent's properties and methods to tailor your demands
    in the derived classes. Modifying inherited members in derived classes is called
    overriding, which is another OOP paradigm. We will look at a detailed example
    of method overriding in later sections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过派生类，你可以保留并重用父类的成员。此外，你还可以覆盖父类的属性和方法，以调整派生类中的需求。在派生类中修改继承成员被称为覆盖，这是另一种面向对象编程范式。我们将在后面的章节中详细探讨方法覆盖的例子。
- en: In short, inheritance allows us to share common characteristics and behaviors
    through generations of classes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，继承使我们能够通过类的代际共享共同的特征和行为。
- en: 'PHP uses the `extends` keyword to inherit from a parent class. The syntax of
    PHP class inheritance is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 使用 `extends` 关键字从父类继承。PHP 类继承的语法如下：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: PHP supports single inheritance, meaning a class can inherit from a single class;
    not like Java, where you can inherit from multiple classes at a time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 支持单继承，这意味着一个类可以继承自一个类；与 Java 不同，Java 可以同时从多个类继承。
- en: 'In order to access a parent class'' member attributes and methods, write the
    following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问父类的成员属性和方法，请编写以下代码：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, the properties from the parent class can be reused in the derived object.
    Normally, in order to share common properties and behaviors, we establish a base
    class so that the subclasses don't need to add the same properties and behaviors
    repetitively. Thus, the data and the code operating on that data can be reused
    and the size of the code base remains minimal.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，父类的属性可以在派生对象中被重用。通常，为了共享常见的属性和行为，我们建立一个基类，这样子类就不需要重复添加相同的属性和行为。因此，数据和操作该数据的相关代码可以被重用，并且代码库的大小保持最小。
- en: 'Again, while deriving, you can add your additional members and use the parent
    members as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在派生过程中，你可以添加额外的成员，并如下使用父类成员：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `MyNewClass` adds its own `$addedProperty` attribute and the `addedMethodName()`
    method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyNewClass` 添加了自己的 `$addedProperty` 属性和 `addedMethodName()` 方法。
- en: You can access and work with the parent's members using the `parent` keyword
    followed by the scope operator, `::`; for example, `parent::`. In the preceding
    example, the `MyNewClass` child class adds its own `addedMethodName()` member
    method, which accesses the parent's `methodName()` method in it by using `parent::methodName()`
    and prints the '`I am an added method`' string. Hence, `$object->addedMethodName()`
    prints '`I am a base method. I am an added method.`'.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `parent` 关键字后跟作用域运算符 `::` 来访问和使用父类的成员，例如，`parent::`。在上面的例子中，`MyNewClass`
    子类添加了自己的 `addedMethodName()` 成员方法，它通过使用 `parent::methodName()` 访问父类的 `methodName()`
    方法，并打印出 '`我是一个添加的方法`' 字符串。因此，`$object->addedMethodName()` 打印出 '`我是一个基类方法。我是一个添加的方法。`'。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A child class can't access or inherit the private properties or members of a
    parent class since something that's private is meant to remain private.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 子类不能访问或继承父类的私有属性或成员，因为私有意味着应该保持私有。
- en: 'Exercise 5.3: Implementing Inheritance'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.3：实现继承
- en: Now is the time to classify different vehicle types and leverage the `Vehicle`
    class to derive new types of vehicles, such as car, bus, truck, motorcycle, and
    so on. In order to produce new types of vehicle objects, we will extend the `Vehicle`
    class to derive newer classes such as `Car` and `Motorcycle`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候对不同的车辆类型进行分类，并利用 `Vehicle` 类来派生新的车辆类型，例如汽车、公交车、卡车、摩托车等。为了产生新的车辆类型对象，我们将扩展
    `Vehicle` 类以派生新的类，如 `Car` 和 `Motorcycle`。
- en: 'In this exercise, you will learn how to derive classes from the `Vehicle` class.
    We will create `Car` and `Motorcycle` subclasses and add new attributes in them,
    and print the `Car` and `Motorcycle` attributes by instantiating corresponding
    objects:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何从 `Vehicle` 类派生类。我们将创建 `Car` 和 `Motorcycle` 子类，并在它们中添加新的属性，并通过实例化相应的对象来打印
    `Car` 和 `Motorcycle` 的属性：
- en: 'Create a new `Car` class file, `Car.php`, in the same directory and add the
    following lines to include the `Vehicle` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个新的 `Car` 类文件，名为 `Car.php`，并添加以下行以包含 `Vehicle` 类：
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Car` class extends the `Vehicle` class. Add the following content after
    the `require` command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Car` 类扩展了 `Vehicle` 类。在 `require` 命令之后添加以下内容：'
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Car` class inherits all the attributes and methods from the parent class.
    Now it's time to add new attributes or properties into the `Car` class so that
    a car object can be distinguished among other types of vehicles.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Car` 类继承自父类所有的属性和方法。现在，是时候向 `Car` 类中添加新的属性或属性，以便汽车对象可以在其他类型的车辆中区分开来。'
- en: 'A car should have doors, passenger capacity, a steering wheel, transmission,
    and so on and inherit the default four wheels along with other properties. Add
    the following attributes into the `Car` class:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一辆汽车应该有车门、乘客容量、方向盘、变速器等，并继承默认的四个轮子以及其他属性。将以下属性添加到 `Car` 类中：
- en: '[PRE42]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hence, the `Car` class itself is a vehicle so it possesses all the given characteristics
    of a vehicle and adds its own set of characteristics.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，`Car` 类本身就是一个车辆，所以它具有车辆的所有给定特征，并添加了自己的特征集。
- en: 'Now, it''s time to leverage the beauty of inheritance. We will be using the
    inherited constructor from the `Vehicle` class. We can set the car''s attributes
    by passing them as constructor parameters. We can instantiate the `Car` class
    and access the `Vehicle` class'' members using the object of the `Car` class,
    as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候利用继承的美丽之处了。我们将使用从 `Vehicle` 类继承的构造函数。我们可以通过传递构造函数参数来设置汽车的属性。我们可以实例化 `Car`
    类，并使用 `Car` 类的对象来访问 `Vehicle` 类的成员，如下所示：
- en: '[PRE43]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, alongside additional car properties, we can access the inherited features
    of the base class. The `get_class()` returns the class name that we have used
    to obtain the `Vehicle` type as a class name. Note that we are accessing the inherited
    methods using the child object's handler.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，除了额外的汽车属性外，我们还可以访问基类的继承特性。`get_class()` 返回我们用来获取 `Vehicle` 类型的类名。注意，我们是通过子对象的处理器来访问继承的方法的。
- en: 'Run `Car.php` from the terminal with the `php Car.php` command. The preceding
    code outputs the following:![Figure 5.8: Printing the details of the car'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行 `Car.php`，使用 `php Car.php` 命令。前面的代码输出以下内容：![图 5.8：打印汽车详情
- en: '](img/C14196_05_08.jpg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_05_08.jpg](img/C14196_05_08.jpg)'
- en: 'Figure 5.8: Printing the details of the car'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.8：打印汽车详情
- en: 'Similarly, let''s create another type of vehicle type here. Create a `Motorcycle`
    class by extending the `Vehicle` class. Create a `Motorcycle.php` file in the
    same directory with the following content:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，让我们在这里创建另一种类型的车辆。通过扩展 `Vehicle` 类创建一个 `Motorcycle` 类。在同一目录下创建一个 `Motorcycle.php`
    文件，内容如下：
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Again, this specific type of vehicle adds its new attributes. This is how inheritance
    enables your object to move forward with the newer characteristics while reusing
    the existing features. Note that `$noOfWheels` and `$stroke` can also be set in
    the constructor, but we also override these values here, in case the `Motorcycle`
    class is instantiated with the default empty constructor.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，这种特定类型的车辆添加了其新的属性。这就是继承如何使你的对象在重用现有功能的同时，带着新的特征向前发展。注意，`$noOfWheels` 和 `$stroke`
    也可以在构造函数中设置，但我们也在这里覆盖了这些值，以防 `Motorcycle` 类使用默认的空构造函数实例化。
- en: 'Now, let''s instantiate the derived `Motorcycle` class, and access the inherited
    and added properties as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实例化派生的 `Motorcycle` 类，并按如下方式访问继承和添加的属性：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, a two-wheeler type of vehicle should have the `$noOfWheels` attribute as
    a value of `2`. Note that `$noOfWheels` has been overridden here with `2` and
    an additional `$stroke` attribute, which is the stroke type of `Motorcyle`. The
    default is `4`.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，两轮车辆类型应该将 `$noOfWheels` 属性的值设为 `2`。请注意，这里已将 `$noOfWheels` 覆盖为 `2` 并添加了一个额外的
    `$stroke` 属性，它是 `Motorcyle` 的冲程类型。默认值为 `4`。
- en: 'Run the `Motorcycle.php` file from the terminal with the `php Motorcycle.php`
    command. The preceding code outputs the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php Motorcycle.php` 命令从终端运行 `Motorcycle.php` 文件。前面的代码输出以下内容：
- en: '![](img/C14196_05_09.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14196_05_09.jpg)'
- en: 'Figure 5.9: Inherited and added attributes of the motorcycle object'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：摩托车对象的继承和新增属性
- en: So far, we have derived `Car` and `Motorcycle` by extending the `Vehicle` class,
    added new properties into derived classes, and accessed parent attributes and
    methods in a straightforward manner since all of them are publicly accessible.
    Inheritance lets you implement your objects in a hierarchical way. You might be
    adding new features or reusing existing ones throughout the system to keep your
    code modular. In the exercise, we noticed that accessing parent members is easy
    and there are no restrictions to prevent you from accessing their data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过扩展 `Vehicle` 类派生了 `Car` 和 `Motorcycle`，在派生类中添加了新的属性，并且以直接的方式访问了父属性和方法，因为它们都是公开可访问的。继承允许您以分层的方式实现对象。您可能需要在整个系统中添加新功能或重用现有功能以保持代码模块化。在练习中，我们注意到访问父成员很容易，并且没有限制来阻止您访问它们的数据。
- en: In order to enforce a specific data access policy on the class attributes, we
    will need the Access Modifiers before the class attributes and method declaration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在类属性上强制执行特定的数据访问策略，我们需要在类属性和方法声明之前使用访问修饰符。
- en: Access Modifiers
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Two core concepts sitting at the heart of OOP are modularity (which allows for
    reusability) and encapsulation (which bundles data and methods, in order to hide
    information). It is important to establish access guidelines for data and interfacing
    among objects so that who can access what and to what extent is defined. Access
    modifiers provide access protection for object constants, attributes, and methods.
    The concept is to secure the object's members so that we can declare public, protected,
    and private member constants, attributes, and methods for the object. The `public`,
    `protected`, and `private` keywords are also known as visibility keywords in PHP.
    The `public` keyword can be used before a member to access the member from outside
    via the object. The `protected` keyword can be used to access a member from the
    derived class but not from outside. The `private` keyword can be used to restrict
    the access of a member to its own class only and for it to not be accessible via
    derivation or from outside.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的核心概念有两个，即模块化（允许重用）和封装（将数据和函数捆绑在一起，以隐藏信息）。为数据访问和对象之间的接口建立访问指南非常重要，以便定义谁可以访问什么以及访问的程度。访问修饰符为对象常量、属性和方法提供访问保护。其概念是保护对象的成员，以便我们可以为对象声明
    `public`、`protected` 和 `private` 成员常量、属性和方法。`public`、`protected` 和 `private` 关键字在
    PHP 中也被称为可见性关键字。`public` 关键字可以用在成员之前，以便通过对象从外部访问该成员。`protected` 关键字可以用来自从派生类访问成员，但不能从外部访问。`private`
    关键字可以用来自限制成员的访问仅限于其自身类，并且不能通过派生或从外部访问。
- en: 'Let''s look at an example of the `public`, `protected`, and `private` keywords
    applied to class members:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将 `public`、`protected` 和 `private` 关键字应用于类成员的示例：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To elaborate on the class members with the new access modifiers prefixed, check
    out the following table for the `public`, `protected`, and `private` access modifiers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细说明带有前缀的新访问修饰符的类成员，请查看以下表格，了解 `public`、`protected` 和 `private` 访问修饰符：
- en: '![Figure 5.10: Scope of the access modifiers'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：访问修饰符的作用范围'
- en: '](img/C14196_05_10.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_10.jpg)'
- en: 'Figure 5.10: Scope of the access modifiers'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：访问修饰符的作用范围
- en: All public members can be accessed from outside of their own object or derived
    object using an object handler such as `$object->publicAttribute` or `$object->publicMethod()`,
    and to access them from inside their own object or derived object we need to use
    the special `$this` variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有公共成员都可以通过对象处理程序（如 `$object->publicAttribute` 或 `$object->publicMethod()`）从其自身对象或派生对象外部访问，而从其自身对象或派生对象内部访问它们则需要使用特殊的
    `$this` 变量。
- en: All protected members can be accessed only from inside their own object or derived
    object using `$this-> protectedAttribute` or `$this->protectedMethod()`. Accessing
    them using the `$object->protectedAttribute` object handler will produce a `FATAL`
    error. Hence, an access modifier can be used when we allow data and behaviors
    to be reused via derivation only.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有受保护的成员只能从它们自己的对象或派生对象内部访问，使用 `$this->protectedAttribute` 或 `$this->protectedMethod()`。使用
    `$object->protectedAttribute` 对象处理程序访问它们将产生一个 `FATAL` 错误。因此，当我们可以通过派生来重用数据和行为时，可以使用访问修饰符。
- en: 'Private members are exclusively private to their own objects and are non-accessible
    via inheritance. The whole idea with this access modifier is that class-specific
    data and behaviors cannot be reused:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 私有成员仅对其自己的对象是私有的，并且不能通过继承访问。这个访问修饰符的整个想法是，类特定的数据和行为不能被重用：
- en: '![Figure 5.11: Access modifiers diagra'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：访问修饰符图]'
- en: '](img/C14196_05_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_05_11.jpg](img/C14196_05_11.jpg)'
- en: 'Figure 5.11: Access modifiers diagram'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：访问修饰符图
- en: The diagram shows who can access what data and which methods. Outsiders can
    access an object's public data and methods only via the object's handler. An outsider's
    access is restricted to protected and private areas. Access is allowed to protected
    areas only by means of derivation and private areas are meant to be private for
    the class. Therefore, the restricted areas of a class can be accessed by its own
    methods and the world is set to access those restricted areas indirectly if and
    only if the class declares those methods that access their own restricted areas
    as public.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了谁可以访问哪些数据以及哪些方法。外部人员只能通过对象处理程序访问对象的公共数据和方法。外部人员的访问受到受保护和私有区域的限制。只有通过派生，才能允许访问受保护区域，而私有区域意味着类内部的私有。因此，类的受限区域只能通过其自己的方法访问，并且如果类声明了访问其受限区域的方法为公共的，那么世界只能间接地访问这些受限区域。
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If no access modifiers are mentioned before a method, then it will be considered
    public by default.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在方法之前没有提到访问修饰符，那么它将默认被认为是公共的。
- en: It's now time to apply access modifiers to the `Vehicle` class. Let's walk through
    an exercise. In the `Vehicle` class, the number of wheels should be available
    for the different types of vehicles to be implemented, the engine number should
    be confidential, and the other information should not be confidential.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将访问修饰符应用到 `Vehicle` 类上了。让我们通过一个练习来了解这个过程。在 `Vehicle` 类中，车轮的数量应该对不同的车辆类型可用以实现，引擎号应该是机密的，其他信息不应是机密的。
- en: 'Exercise 5.4: Applying Access Modifiers'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.4：应用访问修饰符
- en: 'In this exercise, we need to apply access modifiers before the `Vehicle` class
    attributes so that we can ensure the hiding of the data for the engine number
    variable, `$engineNumber`. The engine number can be obtained only via the getter
    `getEngineNumber()` member method. Also, the number of wheels should not be available
    outside the class; rather, it should be available to derived classes to implement
    their own number of wheels and the rest of the attributes can be accessed outside
    the class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们需要在 `Vehicle` 类属性之前应用访问修饰符，以确保对引擎号变量 `$engineNumber` 的数据隐藏。引擎号只能通过成员方法
    `getEngineNumber()` 获取。此外，车轮的数量不应在类外部可用；相反，它应该对派生类可用以实现它们自己的车轮数量，其余的属性可以在类外部访问：
- en: 'Open the `Vehicle.php` file and update the access modifiers of the `$noOfWheels`
    attribute as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Vehicle.php` 文件，并按如下方式更新 `$noOfWheels` 属性的访问修饰符：
- en: '[PRE47]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have protected the `$noOfWheels` data as this needs to be available
    to the child classes to implement their own number of wheels and should not be
    available outside of the class. We have modified the `$noOfWheels` attribute from
    `public` to `protected`.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们保护了 `$noOfWheels` 数据，因为这需要对子类可用以实现它们自己的车轮数量，并且不应在类外部可用。我们将 `$noOfWheels`
    属性从 `public` 更改为 `protected`。
- en: 'Also, the engine number should be private to different vehicle types. Update
    the `$engineNumber` visibility from `public` to `private` as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，引擎号应该对不同的车辆类型是私有的。将 `$engineNumber` 的可见性从 `public` 更改为 `private`，如下所示：
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, due to a visibility change for the `$engineNumber` attribute, the attribute
    should remain private to its own class and should not be available to the derived
    classes or outside of the class. One way to access such private attributes is
    to write a public getter method for outsiders or a protected getter method for
    derived classes only.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，由于`$engineNumber`属性的可见性变化，该属性应保持为其自身类的私有属性，并且不应对派生类或类外部的代码可用。访问此类私有属性的一种方法是为外部编写一个公共获取器方法，或者只为派生类编写一个受保护的获取器方法。
- en: 'Some vehicle types might need to modify the number of wheels and we won''t
    be allowing outsiders to make that modification; hence, we declare the `$noOfWheels`
    attribute as `protected`. What if the number of wheels is set as `public`? It
    might get modified directly (read: bizarrely): a car might have two wheels, or
    a motorcycle might be modified to have 100 wheels. That''s why we wanted the attribute
    to be modified only in subclasses and not by outsiders.'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些车辆类型可能需要修改车轮数量，我们不会允许外部进行此类修改；因此，我们将`$noOfWheels`属性声明为`protected`。如果将车轮数量设置为`public`会怎样？它可能会被直接修改（读：奇怪）：一辆车可能有两条轮子，或者一辆摩托车可能会被修改为有100条轮子。这就是为什么我们希望属性只能在子类中修改，而不是由外部修改。
- en: Here, the first three attributes are publicly visible, meaning these are the
    common attributes of any vehicle types and such information can be accessed directly
    via the object if anyone wants to do that.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，前三个属性是公开可见的，这意味着这些是任何车辆类型的公共属性，并且如果有人想这样做，可以直接通过对象访问此类信息。
- en: So, we are able to deliver restrictions on class attributes using the `visibility`
    keyword. Let's try accessing the attributes with updated visibility by instantiating
    the class.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们能够通过`visibility`关键字对类属性施加限制。让我们通过实例化类来尝试访问具有更新可见性的属性。
- en: 'Create a new `vehicle-visibility.php` file and instantiate the `Vehicle` class
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`vehicle-visibility.php`文件，并按照以下方式实例化`Vehicle`类：
- en: '[PRE49]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Try to access the member attributes outside of the class using the object handler,
    just the same as earlier:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用对象处理程序在类外部访问成员属性，就像之前一样：
- en: '[PRE50]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that we are trying to access `$noOfWheels` and `$engineNumber` outside
    the class using the `$vehicle` object handler with an object operator. Both should
    produce a `FATAL` error.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在尝试使用对象操作符通过`$vehicle`对象处理程序在类外部访问`$noOfWheels`和`$engineNumber`，这两个都应该产生一个`FATAL`错误。
- en: 'From the terminal or console, run `vehicle-visibility.php` using the `php -d
    display_errors=on vehicle-visibility.php` command. Using the `–d` flag with `display_errors=on`
    should override the default `display_erros=off` from `php-cli`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端或控制台运行`vehicle-visibility.php`，使用`php -d display_errors=on vehicle-visibility.php`命令。使用`-d`标志并设置`display_errors=on`应该覆盖来自`php-cli`的默认`display_erros=off`设置：
- en: 'The preceding command outputs the following:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令输出以下内容：
- en: '![Figure 5.12: Accessing a protected property of the vehicle object'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.12：访问车辆对象的受保护属性'
- en: '](img/C14196_05_12.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_12.jpg)'
- en: 'Figure 5.12: Accessing a protected property of the vehicle object'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.12：访问车辆对象的受保护属性
- en: 'Let''s take out the line with `$vehicle->noOfWheels` and try to rerun the previous
    command:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们移除包含`$vehicle->noOfWheels`的行，并尝试重新运行之前的命令：
- en: '[PRE51]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We need to alter our approach for accessing such restricted attributes. We
    need to use the `getNoOfWheels()` and `getEngineNumber()` object interface, as
    follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要改变访问此类受限属性的方法。我们需要使用`getNoOfWheels()`和`getEngineNumber()`对象接口，如下所示：
- en: '[PRE52]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, if we rerun the script, we should see that all the expected values have
    been printed as follows:![Figure 5.13: Accessing private and protected properties
    via methods of the vehicle object'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果我们重新运行脚本，我们应该看到所有预期的值都按以下方式打印出来：![图 5.13：通过车辆对象的方法访问私有和受保护的属性
- en: '](img/C14196_05_13.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_13.jpg)'
- en: 'Figure 5.13: Accessing private and protected properties via methods of the
    vehicle object'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.13：通过车辆对象的方法访问私有和受保护的属性
- en: Now, we should try accessing the modified visibility attributes from the child
    class to see the differences.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们应该尝试从子类访问修改后的可见性属性，以查看差异。
- en: Let's try accessing the modified visibility attributes from the child class.
    Open `Car.php` and locate the line with `$car->getNoOfWheels()`. The protected
    `$noOfWheels` attribute is inherited by the `$car` object and is available only
    via the `getNoOfWheels()` standard interface.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从子类访问修改后的可见性属性。打开`Car.php`并定位到包含`$car->getNoOfWheels()`的行。受保护的`$noOfWheels`属性由`$car`对象继承，并且只能通过`getNoOfWheels()`标准接口访问。
- en: 'Try to run `Car.php` using the `php -d display_errors=on Car.php` command.
    The command prints the following:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试使用 `php -d display_errors=on Car.php` 命令运行 `Car.php`。该命令会打印以下内容：
- en: '![Figure 5.14: Accessing the parent''s attributes via inheritance'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.14：通过继承访问父类的属性'
- en: '](img/C14196_05_14.jpg)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.14：通过继承访问父类的属性](img/C14196_05_14.jpg)'
- en: 'Figure 5.14: Accessing the parent''s attributes via inheritance'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.14：通过继承访问父类的属性
- en: This is how access modifiers ensure data protection throughout child classes.
    If we try accessing the protected attribute using `$car->noOfWheels`, it will
    produce a fatal error.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是访问修饰符如何确保在子类中保护数据的方法。如果我们尝试使用 `$car->noOfWheels` 访问受保护的属性，它将产生一个致命错误。
- en: 'Now, let''s try to access the private property of the parent class of `Car.php`
    and add the following line:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试访问 `Car.php` 的父类的私有属性，并添加以下行：
- en: '[PRE53]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember, although a car is a vehicle and is inherited from the `Vehicle` class,
    the attribute should remain private to the `Vehicle` class and is unknown to the
    `Car` object.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，尽管汽车是一种车辆并且是从 `Vehicle` 类继承的，但该属性应该保持对 `Vehicle` 类的私有性，并且对 `Car` 对象来说是未知的。
- en: 'Try to rerun the previous command and it will raise a `Notice` message (a PHP
    interpreter''s message) as the property is unknown to the `$car` object:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试重新运行之前的命令，它将引发一个 `Notice` 消息（PHP 解释器的消息），因为属性对 `$car` 对象来说是未知的：
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: PHP will raise a `Notice` message only because the property is completely unknown
    to the object. So, this is how visibility keywords can be applied before class
    members in order to ensure the hiding of data and protection through inheritance.
    Note that a `Notice` message is information about wrongdoing by the interpreter
    and would not halt the program execution, while an error should halt the program
    execution and must be resolved in order to execute the program.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PHP 只会引发一个 `Notice` 消息，因为该属性对对象来说是完全未知的。所以，这就是如何在类成员之前应用可见性关键字以确保数据的隐藏和保护以及通过继承的保护。请注意，`Notice`
    消息是关于解释器违规的信息，不会停止程序执行，而错误应该停止程序执行，并且必须解决才能执行程序。
- en: In summary, access modifiers allow us to establish control over our data and
    behaviors and provide guidelines for how data should be communicated via standard
    methods. Hence, we have learned how to protect, privatize, and publicize data
    when we need to establish secure data communication between objects.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，访问修饰符允许我们控制我们的数据和行为，并为数据通过标准方法进行通信提供指导。因此，当我们需要在对象之间建立安全的数据通信时，我们已经学会了如何保护、私有化和公开数据。
- en: Static Fields and Methods
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态字段和方法
- en: When class instances or objects want to have the same data among them, the class
    needs to have such data declared as static. Each instance might have its own copy
    of data, but we use static members to have a certain portion of data and behavior
    that should be the same instance-wide.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当类实例或对象想要在它们之间共享相同的数据时，类需要将此类数据声明为静态。每个实例可能有自己的数据副本，但我们使用静态成员来确保某些数据和行为在实例范围内应该是相同的。
- en: Static fields or attributes and methods are just attributes and methods declared
    with the `static` keyword after the access modifiers and serve the special purpose
    that you can access static attributes, constants, and methods without instantiating
    the class. So far, we have accessed members that are declared inside a class from
    the object context. In the case of accessing class members without an object,
    we declare them as static members and access them with the `::` scope operator
    (double colon).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段或属性和方法只是声明了 `static` 关键字（在访问修饰符之后）的属性和方法，它们具有特殊用途，即可以在不实例化类的情况下访问静态属性、常量和方法。到目前为止，我们已经从对象上下文访问了在类内部声明的成员。在不需要对象访问类成员的情况下，我们将它们声明为静态成员，并使用
    `::` 范围运算符（双冒号）来访问它们。
- en: 'The syntax looks like the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来如下：
- en: '[PRE55]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To access static properties or methods from their own class, check out the
    following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要从它们自己的类中访问静态属性或方法，查看以下示例：
- en: '[PRE56]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, static members can be accessed outside of the class using the class name
    and the `::` scope operator. Also, to access the static members inside the class,
    we can use the `self` keyword followed by the `::` scope operator.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，静态成员可以使用类名和 `::` 范围运算符在类外部访问。此外，要访问类内部的静态成员，我们可以使用 `self` 关键字后跟 `::` 范围运算符。
- en: 'To access static properties or methods from subclasses, we use the `parent`
    keyword followed by the `::` scope operator. Check out the following example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要从子类访问静态属性或方法，我们使用 `parent` 关键字后跟 `::` 范围运算符。查看以下示例：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also, static methods are available in the object context:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，静态方法在对象上下文中也是可用的：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Static attributes and members are global variables and functions, except they
    live inside a class that is accessible from anywhere via the class name. Static
    members should be public; otherwise, accessing them from outside using the class
    name would produce a fatal error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性和成员是全局变量和函数，除了它们存在于一个可以通过类名从任何地方访问的类中。静态成员应该是公共的；否则，使用类名从外部访问它们会产生致命错误。
- en: 'parent:: and self::'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'parent:: 和 self::'
- en: '`self::` refers to the current class and can be used to access static attributes,
    constants, and methods.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`self::` 指的是当前类，并且可以用来访问静态属性、常量和方法。'
- en: Similarly, `parent::` refers to the parent class and can be used inside subclasses
    in order to access parent's member attributes, constants, and methods.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`parent::` 指的是父类，并且可以在子类内部使用，以便访问父类的成员属性、常量和方法。
- en: 'Exercise 5.5: Applying a Static Member'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.5：应用静态成员
- en: 'In this exercise, we will walk through an interesting use case for static members.
    We will be adding a static attribute to the `Vehicle` class and will increment
    the attribute inside the constructor so that the static member gets increased
    with each object creation:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨静态成员的一个有趣用例。我们将向 `Vehicle` 类添加一个静态属性，并在构造函数中增加该属性，以便随着每个对象的创建而增加静态成员：
- en: 'Open `Vehicle.php` and add a static property in the class, as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Vehicle.php` 文件并在类中添加一个静态属性，如下所示：
- en: '[PRE59]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we have added a `$counter` static property and initiated the counter with
    `0`.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个 `$counter` 静态属性，并用 `0` 初始化计数器。
- en: 'Now, just add a line in the constructor to increment `$counter` by using `self::$counter++`
    as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需在构造函数中添加一行代码来增加 `$counter`，如下所示：
- en: '[PRE60]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the counter gets incremented with each object creation as we know the
    constructor method gets called while instantiating the class. In our case, the
    `Car` and `Motorcycle` subclasses don't have a `__construct()` method declared
    in them so they should be using the parent class' constructor via inheritance.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，计数器随着每个对象的创建而递增，因为我们知道在实例化类时调用构造方法。在我们的例子中，`Car` 和 `Motorcycle` 子类没有声明 `__construct()`
    方法，所以它们应该通过继承使用父类的构造函数。
- en: 'Now, open `Car.php` and create `Car` objects multiple times, as follows. Print
    the `$counter` static variable using `Car::$counter`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `Car.php` 文件并多次创建 `Car` 对象，如下所示。使用 `Car::$counter` 打印 `$counter` 静态变量：
- en: '[PRE61]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, the static attribute inherited by the derived `Car` class contains the
    number of the objects created at any particular point in time. So, we get to know
    the number of cars available in the application. The preceding should print `Available
    cars are 4`. Note that we are reusing the static counter in the constructor of
    the parent `Vehicle` class, meaning the derived `Car` objects share the same counter.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，继承自 `Car` 类的静态属性包含了在任何特定时间点创建的对象数量。因此，我们可以知道应用程序中可用的汽车数量。前面的代码应该打印 `Available
    cars are 4`。注意，我们在父类 `Vehicle` 的构造函数中重用了静态计数器，这意味着派生的 `Car` 对象共享同一个计数器。
- en: 'Now, to count `Motorcycle` objects, just create some objects and print the
    `$counter` static variable using `Motorcycle::$counter`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要计算 `Motorcycle` 对象的数量，只需创建一些对象，并使用 `Motorcycle::$counter` 打印 `$counter`
    静态变量：
- en: '[PRE62]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding should print `Available motorcycles are 3`. So, we have declared
    a static counter in the parent class and created objects and accessed the `static`
    attribute using child class names to get the number of objects created. This is
    how we can implement so many interesting features with the `static` property and
    methods.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码应该打印 `Available motorcycles are 3`。因此，我们在父类中声明了一个静态计数器，通过使用子类名称创建对象并访问
    `static` 属性来获取创建的对象数量。这就是我们如何使用 `static` 属性和方法实现许多有趣功能的方法。
- en: Class Abstraction
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类抽象
- en: 'In OOP, class abstraction is the way to define the common behaviors of objects
    so that derived classes can implement those behaviors in their own way to achieve
    different purposes. Just take the vehicle analogy: both cars and motorcycles have
    engines in common, but you know the engines are completely different for each
    type of vehicle. So, the class abstraction should provide an abstract engine for
    both types of vehicles. To match an exact common definition of an engine, the
    engine should start, the engine should stop, and we might want to know the status
    of the engine — whether it is running or not.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，类抽象是定义对象共同行为的方式，以便派生类可以以它们自己的方式实现这些行为以实现不同的目的。仅以车辆类比：汽车和摩托车都有共同的引擎，但你都知道每种类型的车辆的引擎是完全不同的。因此，类抽象应该为两种类型的车辆提供抽象引擎。为了匹配一个精确的共同定义的引擎，引擎应该可以启动，引擎应该可以停止，我们可能还想了解引擎的状态——它是否正在运行。
- en: 'Each type of vehicle should implement its way to start the engine. For example,
    we could start a car engine by using a key in the ignition, whereas a motorcycle
    might need us to kick-start the engine:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的车辆都应该实现其启动引擎的方式。例如，我们可以通过在点火开关中使用钥匙来启动汽车引擎，而摩托车可能需要我们踢启动引擎：
- en: '![Figure 5.15: A simple abstract engine diagram'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15：一个简单的抽象引擎图'
- en: '](img/C14196_05_15.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_05_15.jpg)'
- en: 'Figure 5.15: A simple abstract engine diagram'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：一个简单的抽象引擎图
- en: PHP supports abstract classes and methods and they can be written with the `abstract`
    keyword at the start. An abstract class cannot be instantiated; rather, it can
    be inherited to achieve common behaviors among objects. A class must contain at
    least an abstract method to be an abstract class. Using such a class, we deliver
    common methods to subclasses. In an abstract class, the common methods could be
    abstract because they only have the signatures and the subclasses implement those
    methods in their own way. A method declared as an abstract method must not have
    the implementation written in it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持抽象类和方法，并且可以使用`abstract`关键字来编写。抽象类不能被实例化；相反，它可以被继承以实现对象之间的共同行为。一个类必须包含至少一个抽象方法才能成为抽象类。使用此类，我们向子类提供共同的方法。在抽象类中，共同的方法可能是抽象的，因为它们只有签名，而子类以它们自己的方式实现这些方法。声明为抽象方法的方法不得包含实现代码。
- en: 'Check out the following syntax:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下语法：
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An abstract class can have some implemented methods in it, along with abstract
    methods. Generally, we leave those methods as abstract, which should have a different
    implementation in different child classes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以包含一些实现的方法，以及抽象方法。通常，我们保留这些方法为抽象的，它们应该在不同的子类中有不同的实现。
- en: As well as the abstract method implementation, the child class must add all
    the arguments given in the abstract method and optionally can add extra arguments.
    Say the abstract method comes with two parameters, then the child class must add
    both of the given parameters and can optionally add its own parameters.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抽象方法实现外，子类必须添加抽象方法中给出的所有参数，并且可以选择添加额外的参数。比如说，抽象方法带有两个参数，那么子类必须添加这两个参数，并且可以选择添加它自己的参数。
- en: In the following exercise, we will be adding basic engine functionality to cars
    and motorcycles so that the engine can be turned on and off.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将向汽车和摩托车添加基本的引擎功能，以便引擎可以被打开和关闭。
- en: 'Exercise 5.6: Implementing an Abstract Class'
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.6：实现抽象类
- en: In this exercise, we will be converting the `Vehicle` class into an abstract
    class so that we can deliver the engine-start action in an abstract manner and
    each subclass can implement its own way of starting the engine. We can add an
    abstract engine start method so that `Car` and `Motorcycle` can inherit the engine
    action to implement it and start the vehicle in their own way. The whole idea
    of this exercise is to practice and understand how abstraction helps us to achieve
    certain scenarios. In order to provide an abstract engine start to each vehicle
    type, we will declare the `Vehicle` class as abstract by simply adding the `abstract`
    keyword in front of it and adding an abstract engine-start method. Since `Car`
    and `Motorcycle` extended the `Vehicle` class, they will be forced to implement
    the `abstract` method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把`Vehicle`类转换为一个抽象类，这样我们就可以以抽象的方式提供引擎启动动作，并且每个子类都可以以自己的方式实现引擎启动。我们可以添加一个抽象的引擎启动方法，这样`Car`和`Motorcycle`就可以继承引擎动作并实现它，以自己的方式启动车辆。这个练习的整个想法是练习和理解抽象如何帮助我们实现某些场景。为了为每种车辆类型提供一个抽象的引擎启动，我们将通过在它前面添加`abstract`关键字并将一个抽象的引擎启动方法添加到`Vehicle`类中，简单地声明`Vehicle`类为抽象类。由于`Car`和`Motorcycle`扩展了`Vehicle`类，它们将被迫实现这个`abstract`方法。
- en: PSR Naming Conventions
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: PSR命名规范
- en: An abstract class name must be prefixed by `abstract`; for example, `AbstractTest`.
    You can take a look at [https://packt.live/2IEkR9k](https://packt.live/2IEkR9k).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类名称必须以`abstract`前缀开头；例如，`AbstractTest`。您可以查看[https://packt.live/2IEkR9k](https://packt.live/2IEkR9k)。
- en: 'Let us take a look at the steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看步骤：
- en: 'Open the `Vehicle.php` class and add the `abstract` keyword before the `class`
    keyword, as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Vehicle.php`类，在`class`关键字之前添加`abstract`关键字，如下所示：
- en: '[PRE64]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, the `Vehicle` class became an abstract class, as discussed.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，`Vehicle`类变成了一个抽象类，正如之前讨论的那样。
- en: 'Also, prefix the class name with `Abstract`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将类名前缀改为`Abstract`：
- en: '[PRE65]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Rename the `Vehicle.php` file to `AbstractVehicle.php`.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`Vehicle.php`文件重命名为`AbstractVehicle.php`。
- en: 'Update the `Car.php` file with the abstract `AbstractVehicle` class name and
    the `AbstractVehicle.php` filename, as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式更新`Car.php`文件，包括抽象`AbstractVehicle`类名称和`AbstractVehicle.php`文件名：
- en: '[PRE66]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And for `Motorcycle.php`, add the following:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`Motorcycle.php`，添加以下内容：
- en: '[PRE67]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We need to add an attribute to the `AbstractVehicle` class to store the engine
    status – whether it is started or stopped, so let''s add a protected `$engineStatus`
    attribute as a Boolean type so that it holds the status of the running engine
    as `true` or `false`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`AbstractVehicle`类中添加一个属性来存储引擎状态——它是否启动或停止，所以让我们添加一个受保护的`$engineStatus`属性，其类型为布尔型，以便它以`true`或`false`的形式保存正在运行的引擎状态：
- en: '[PRE68]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we have added an `$engineStatus` attribute that is false by default, so
    we can confirm that the engine is not running.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个默认值为false的`$engineStatus`属性，这样我们就可以确认引擎没有在运行。
- en: According to our abstract class concept, we will add some implemented methods
    that will be the same in each vehicle type and some non-implemented abstract methods
    that will be implemented differently in each vehicle type. The engine starting
    is different in a car and a motorcycle so this method should be abstract, but
    stopping the engine or getting the engine's status should be the same for both.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据我们的抽象类概念，我们将添加一些在每个车辆类型中都会实现的方法，以及一些在每个车辆类型中都会以不同方式实现的非实现抽象方法。汽车的引擎启动和摩托车不同，所以这个方法应该是抽象的，但停止引擎或获取引擎状态应该是相同的。
- en: 'Add the following abstract method signature in the abstract `Vehicle` class,
    which should be implemented differently (read: behave differently) in `Car` and
    `Motorcycle`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在抽象类`Vehicle`中添加以下抽象方法签名，这个方法在`Car`和`Motorcycle`中应该有不同的实现（即：表现不同）：
- en: '[PRE69]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, both vehicle subclasses will be enforced to add an implementation of this
    method in their own classes.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，两个车辆子类都将被强制在自己的类中实现这个方法。
- en: 'Also, we will be delivering common functionalities in terms of the implemented
    method so that the subclasses can avail them. Add the following two methods in
    the `AbstractVehicle` class:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将通过实现的方法提供一些公共功能，以便子类可以使用。在`AbstractVehicle`类中添加以下两个方法：
- en: '[PRE70]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, in order to stop the engine and get the engine's status, we have added
    the `stop()` and `getEngineStatus()` methods. So, these two should be the same
    in `Car` and `Motorcycle`.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，为了停止引擎和获取引擎状态，我们添加了`stop()`和`getEngineStatus()`方法。所以，这两个方法在`Car`和`Motorcycle`中应该是相同的。
- en: 'Finally, the abstract `AbstractVehicle` class with a single abstract method
    looks like the following:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，具有单个抽象方法的抽象类 `AbstractVehicle` 看起来如下：
- en: '[PRE71]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, it''s time to implement the abstract `start()` method in the subclasses.
    A car has its own way of starting its engine — you need to place the key in the
    ignition. In `Car.php`, add a private property, `$hasKeyinIgnition`, along with
    the `start()` implementation, as follows:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候在子类中实现抽象的 `start()` 方法了。汽车启动发动机有自己的方式——你需要将钥匙插入点火开关。在 `Car.php` 中，添加一个私有属性
    `$hasKeyinIgnition`，以及 `start()` 实现如下：
- en: '[PRE72]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, a car implements the engine start with the key in the ignition. `$this->hasKeyinIgnition`
    should be `true` to set the `$engineStatus` variable to `start` or `true`.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，汽车通过在点火开关中插入钥匙来实现发动机启动。`$this->hasKeyinIgnition` 应该为 `true` 以将 `$engineStatus`
    变量设置为 `start` 或 `true`。
- en: 'We can create a `Car` object and start/stop the engine as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `Car` 对象，并按如下方式启动/停止发动机：
- en: '[PRE73]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run `Car.php` with the `php Car.php` command. The preceding code should output
    the following:![Figure 5.16: Abstract method implementation on the car objec'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php Car.php` 命令运行 `Car.php`。前面的代码应该输出以下内容：![图 5.16：汽车对象上的抽象方法实现
- en: '](img/C14196_05_16.jpg)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_16.jpg)'
- en: 'Figure 5.16: Abstract method implementation on the car objec'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.16：汽车对象上的抽象方法实现
- en: 'A motorcycle needs a key to unlock the vehicle and a kick on the corresponding
    lever to start the engine. The term "kickstart" was coined from this particular
    type of vehicle. Open `Motorcycle.php` to simulate the key being in place and
    a kickstart taking place. Let''s add two private attributes, `$hasKey` and `$hasKicked`,
    and implement the `start()` method as follows:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摩托车需要一把钥匙来解锁车辆，并踩在相应的杠杆上以启动发动机。术语“kickstart”就是从这个特定类型的车辆中来的。打开 `Motorcycle.php`
    来模拟钥匙到位和启动过程。让我们添加两个私有属性 `$hasKey` 和 `$hasKicked`，并按如下方式实现 `start()` 方法：
- en: '[PRE74]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, in the `start()` method, we have checked that both elements for starting
    a motorcycle engine are present and started the engine by setting `$engineStatus`
    to `true`.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，在 `start()` 方法中，我们已经检查了启动摩托车发动机所需的两个元素是否存在，并通过将 `$engineStatus` 设置为 `true`
    来启动了发动机。
- en: 'Similarly, we can create a `Motorcycle` object and start/stop the engine as
    follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以创建一个 `Motorcycle` 对象，并按如下方式启动/停止发动机：
- en: '[PRE75]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Run `Motorcycle.php` with the `php Motorcycle.php` command. The preceding code
    should output the following:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php Motorcycle.php` 命令运行 `Motorcycle.php`。前面的代码应该输出以下内容：
- en: '![Figure 5.17: Abstract method implementation on the motorcycle object'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17：摩托车对象上的抽象方法实现](img/C14196_05_17.jpg)'
- en: '](img/C14196_05_17.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_16.jpg)'
- en: 'Figure 5.17: Abstract method implementation on the motorcycle object'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：摩托车对象上的抽象方法实现
- en: So, different behaviors of the same action among the children should come from
    the parent in an abstract way.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子类中相同动作的不同行为应该以抽象的方式来自父类。
- en: Interfaces
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: We have discussed how an abstract class can come up with common and abstract
    methods. In an abstract class, we keep the methods abstract that should be different
    in derived classes. What if we want a full set of abstract functionalities? Or,
    what if we want to settle a standard of functionality? Maybe we want to establish
    a standard set of methods to communicate with the object? This is why we need
    an interface. An interface groups similar abstract methods so that it can express
    an abstract feature and different classes that need that feature can implement
    the interface. For example, the `Flight` feature is implemented by `Birds` and
    `Aeroplanes`. Hence, the `Flight` interface has to be fully abstract so that `Birds`
    and `Aeroplanes` can implement completely different flight techniques.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何通过抽象类提出共同和抽象的方法。在抽象类中，我们保留在派生类中应该不同的方法。如果我们想要一套完整的抽象功能呢？或者，如果我们想要确定功能标准呢？也许我们想要建立一个与对象通信的标准方法集？这就是为什么我们需要接口。接口将类似的抽象方法分组，以便它可以表达一个抽象特征，并且需要该功能的不同的类可以实现该接口。例如，`Flight`
    功能由 `Birds` 和 `Aeroplanes` 实现。因此，`Flight` 接口必须是完全抽象的，这样 `Birds` 和 `Aeroplanes`
    就可以实现完全不同的飞行技术。
- en: 'An interface can be similar to a class without the `class` keyword and without
    all the method''s body. Therefore, an interface is a collection of method signatures
    to be implemented like the following syntax:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以类似于没有 `class` 关键字和没有所有方法体的类。因此，接口是一组要实现的方法签名，如下所示：
- en: '[PRE76]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: An interface cannot be extended but rather implemented; classes use the `implements`
    keyword to inherit the given interfaces so that they can implement them. PHP supports
    constants in interfaces so that implementing classes have those constants automatically
    defined. A class that implements an interface should implement every method and
    if any method remains unimplemented, then it will produce a fatal error.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不能扩展，而应实现；类使用 `implements` 关键字继承给定的接口，以便它们可以实施。PHP 支持接口中的常量，以便实现类自动定义这些常量。实现接口的类应该实现每个方法，如果任何方法未实现，则将产生致命错误。
- en: 'A class can implement multiple interfaces:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现多个接口：
- en: '[PRE77]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And an interface can extend multiple interfaces:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以扩展多个接口：
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So, a class can extend a single class and can implement multiple interfaces,
    and an interface can extend multiple interfaces. But implementing/extending interfaces
    should not have methods with the same name, which creates interface clashing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个类可以扩展一个类，并实现多个接口，一个接口可以扩展多个接口。但是实现/扩展接口不应有同名的方法，这会导致接口冲突。
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interfacing methods are always public and you can't declare access modifiers
    for method prototypes in their declaration.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接口方法始终是公开的，你无法在它们的声明中为方法原型声明访问修饰符。
- en: Interface constants can be accessed similarly to class constants but they cannot
    be overridden through inheritance by classes or interfaces.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接口常量可以像类常量一样访问，但它们不能通过继承被类或接口覆盖。
- en: 'Here is a representation of the `Drive` interface:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Drive` 接口的一个表示：
- en: '![Figure 5.18: Drive interface diagram'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18：驱动接口图](img/C14196_05_18.jpg)'
- en: '](img/C14196_05_18.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'Figure 5.18: Drive interface diagram'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：驱动接口图
- en: Referring to the preceding diagram, consider the vehicle analogy again. Cars
    and Motorcycles both can be driven so they need their own drive interfaces. While
    driving, they should change their speed, change gear, apply breaks, and so on.
    We can see that driving behavior is common and the necessary actions are the same
    in both types of vehicles. The thing is, despite the same actions, their way of
    dealing with those actions is different. This is where we need an interface. We
    might want to declare a `Drive` interface with the `changeGear()`, `changeSpeed()`,
    and `applyBreak()` abstract methods.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的图，再次考虑车辆类比。汽车和摩托车都可以驾驶，因此它们需要自己的驱动接口。在驾驶过程中，它们应该改变速度、改变档位、施加制动等。我们可以看到，驾驶行为是共同的，两种类型的车辆中必要的动作是相同的。问题是，尽管动作相同，但它们处理这些动作的方式不同。这就是我们需要接口的地方。我们可能想要声明一个具有
    `changeGear()`、`changeSpeed()` 和 `applyBreak()` 抽象方法的 `Drive` 接口。
- en: Therefore, an interface focuses on functionality, rather than being a template
    (of an abstract class) for an object. And this is the main difference between
    the interface and class abstraction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接口侧重于功能，而不是作为对象的模板（抽象类的模板）。这是接口和类抽象之间的主要区别。
- en: We can add a simple drive interface for `Car` and `Motorcycle` so that the vehicle
    can change speed, change gear, and apply the brake. If the vehicle hasn't implemented
    the brake, then a fatal error will be displayed.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 `Car` 和 `Motorcycle` 添加一个简单的驱动接口，以便车辆可以改变速度、改变档位和施加制动。如果车辆没有实现制动，则将显示致命错误。
- en: Let's add the driving feature as an interface in the following exercise.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的练习中添加驾驶功能作为接口。
- en: 'Exercise 5.7: Implementing an Interface'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.7：实现接口
- en: 'In this exercise, we will practice working with the object interfaces and learn
    how an interface can settle a standard way of implementing behaviors for objects.
    We will create an interface with the necessary driving guidelines, such as the
    ability to change speed and gear, or the ability to apply the brakes when needed:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将练习使用对象接口，并学习接口如何为对象实现行为提供一种标准方式。我们将创建一个接口，包含必要的驾驶指南，例如改变速度和档位的能力，或在需要时施加制动的能力：
- en: Note
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As per PSR naming conventions, an interface name must be suffixed by `interface`;
    for example, `TestInterface` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k)).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PSR 命名约定，接口名称必须后缀为 `interface`；例如，`TestInterface` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k))。
- en: 'Create the following Drive interface and save the file as `DriveInterface.php`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `Drive` 接口并将其保存为 `DriveInterface.php`：
- en: '[PRE79]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we have declared the `Drive` interface with a minimal set of method signatures.
    Remember, no implementation should be available here; rather, the implementation
    should be shifted to objects that implement such an interface.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们声明了 `Drive` 接口，并使用最小的方法签名集。记住，这里不应该有任何实现；相反，实现应该转移到实现该接口的对象中。
- en: To change the speed, we have added the `changeSpeed($speed)` method signature,
    which accepts an argument for the speed to achieve. To change the gear, we have
    added the `changeGear($gear)` method signature, which accepts an argument for
    the gear number to be shifted to. To apply the brakes, we have added the `applyBreak()`
    method so that we can just simulate the "break" behavior whenever required.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要改变速度，我们添加了 `changeSpeed($speed)` 方法签名，它接受一个参数以实现所需的速度。要改变挡位，我们添加了 `changeGear($gear)`
    方法签名，它接受一个参数以切换到要换的挡位。要应用刹车，我们添加了 `applyBreak()` 方法，这样我们就可以在需要时模拟“刹车”行为。
- en: 'Add the interface to both the `Car` and `Motorcycle` classes as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将接口添加到 `Car` 和 `Motorcycle` 类中：
- en: '[PRE80]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, the `Car` and `Motorcycle` class should implement the interface as follows
    and add their own implementations for `changeSpeed()`, `changeGear()`, and `applyBreak()`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`Car` 和 `Motorcycle` 类应该按照以下方式实现接口，并为 `changeSpeed()`、`changeGear()` 和 `applyBreak()`
    添加它们自己的实现：
- en: '[PRE81]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we try to run `Car.php` or `Motorcycle.php`, it will produce a fatal error
    that the classes must contain three abstract methods and, therefore, be declared
    abstract or implement the remaining methods. Therefore, we need to add the implementation
    of those three interfaces or methods.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们尝试运行 `Car.php` 或 `Motorcycle.php`，它将产生一个致命错误，指出这些类必须包含三个抽象方法，因此必须声明为抽象或实现剩余的方法。因此，我们需要添加这三个接口或方法的实现。
- en: 'Add the implementation of those three methods in the `Car` class as follows:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式在 `Car` 类中实现这三个方法：
- en: '[PRE82]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, `Car` has implemented the three methods from the `DriveInterface` interface.
    We can put the relevant implementation in them but, for the sake of learning,
    we have just printed a simple line in them.
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Car` 实现了 `DriveInterface` 接口的三个方法。我们可以在其中放置相关的实现，但为了学习的目的，我们只是在其中打印了一条简单的信息。
- en: 'Now, instantiate the `Car` class as follows and start driving:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式实例化 `Car` 类并开始驾驶：
- en: '[PRE83]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, we have accessed the driving methods to execute the operations implemented
    by `Car`.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们调用了驾驶方法来执行 `Car` 实现的操作。
- en: 'If we try to run the `Car` script, with `php Car.php`, the preceding code should
    print the following:![Figure 5.19: The DriveInterface interface implemented by
    car'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 `php Car.php` 运行 `Car` 脚本，前面的代码应该打印以下内容：![图 5.19：由汽车实现的 `DriveInterface`
    接口
- en: '](img/C14196_05_19.jpg)'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_19.jpg)'
- en: 'Figure 5.19: The DriveInterface interface implemented by car'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.19：由汽车实现的 `DriveInterface` 接口
- en: 'Also, add the implementation of those three methods in the `Motorcycle` class,
    as follows:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在 `Motorcycle` 类中添加这三个方法的实现，如下所示：
- en: '[PRE84]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, we have implemented the `DriveInterface` interface in the `Motorcycle`
    class. Just like that, you can come up with your own implementation and, here,
    for the sake of learning, we have printed different information in this `DriveInterface`
    implementation.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们在 `Motorcycle` 类中实现了 `DriveInterface` 接口。就像那样，你可以提出自己的实现，在这里，为了学习的目的，我们在这种
    `DriveInterface` 实现中打印了不同的信息。
- en: 'Now, instantiate the `Motorcycle` class as follows and start driving:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式实例化 `Motorcycle` 类并开始驾驶：
- en: '[PRE85]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we have accessed the driving methods to execute the operations implemented
    by `Motorcycle`.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们调用了驾驶方法来执行 `Motorcycle` 实现的操作。
- en: 'If we try to run the `Motorcycle` script with `php Motorcycle.php`, the preceding
    code should print the following:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 `php Motorcycle.php` 运行 `Motorcycle` 脚本，前面的代码应该打印以下内容：
- en: '![](img/C14196_05_20.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14196_05_20.jpg)'
- en: 'Figure 5.20: The DriveInterface interface implemented by Motorcycle'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：由摩托车实现的 `DriveInterface` 接口
- en: Hence, the vehicles can shift gears, change speed, and brake while driving.
    The `DriveInterface` interface described what should be the standard behaviors
    for vehicles for driving and their derived objects obeyed the formula of the standard
    feature. Moreover, the interface can add more functionalities so that the derived
    objects are forced to implement them.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，车辆可以在行驶过程中换挡、变速和刹车。`DriveInterface` 接口描述了车辆及其派生对象在行驶中应遵循的标准行为，而这些派生对象遵循了标准特性的公式。此外，该接口还可以添加更多功能，以便派生对象必须实现它们。
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The declaration of implemented methods and interface methods must be compatible
    with each other; for example, the number of arguments or the signature should
    be exactly the same.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法和接口方法的声明必须相互兼容；例如，参数数量或签名应该完全相同。
- en: Abstract Classes versus Interfaces
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类与接口
- en: We have learned how the concepts of class abstraction and object interfaces
    work nicely as added dimensions of inheritance to deliver common behaviors and
    standards for derived objects. There are frequent debates about when to use abstract
    classes and when to use interfaces. Although we have gone through the practical
    use cases of both via our exercises, the topic still needs discussion.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了类抽象和对象接口的概念如何作为继承的附加维度很好地工作，从而为派生对象提供共同的行为和标准。关于何时使用抽象类和何时使用接口，经常有争论。尽管我们已经通过练习了解了两者的实际应用案例，但这个话题仍然需要讨论。
- en: 'Abstract classes are meant to deliver common behaviors or actions via methods
    to extended objects while keeping vital room for common methods to be implemented
    differently by derived objects. In contrast, interfaces are for setting standard
    ways of interacting with objects. An abstract class must have at least one abstract
    method, whereas all the methods in an interface are abstract. Remember, this is
    not a concept of having one or more abstract methods versus all abstract methods.
    Both have their own use cases when it comes to inheritance: the abstract class
    delivers the common functionalities and allows us to implement our own functionalities,
    whereas the interface is not about sharing functionalities at all; rather, the
    interface is all about setting standards for certain actions.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类旨在通过方法向扩展对象提供共同的行为或动作，同时为共同方法的不同实现保留重要的空间。相比之下，接口是为了设置与对象交互的标准方式。一个抽象类必须至少有一个抽象方法，而接口中的所有方法都是抽象的。记住，这并不是一个有一个或多个抽象方法与所有抽象方法的概念。在继承方面，两者都有自己的用例：抽象类提供共同的功能，并允许我们实现自己的功能，而接口根本不是关于共享功能；相反，接口完全是关于为某些动作设置标准。
- en: Simple abstract classes can have implemented methods and attributes, whereas
    interfaces cannot as they contain constants and method signatures without bodies.
    Therefore, it is not possible to share code via interfaces.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的抽象类可以有实现的方法和属性，而接口则不能，因为它们包含常量和没有主体的方法签名。因此，无法通过接口共享代码。
- en: In previous exercises, the abstract class provided us with common engine functionalities
    and allowed us to deal with specific features of the engine in our own way. The
    interface showed us the standards to drive the car and we followed the guidelines
    accordingly to achieve our own goal of driving actions.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，抽象类为我们提供了共同的引擎功能，并允许我们以自己的方式处理引擎的特定功能。接口向我们展示了驾驶汽车的标准，我们遵循这些指南以实现我们的驾驶行为目标。
- en: Class Type Hinting Plays a Role in Dependency Injection
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类类型提示在依赖注入中发挥作用
- en: Type hinting allows us to define the type of data to be passed as arguments
    into a function. PHP supports class type hints, which means that, in function
    arguments, you can mention which class type the passed argument object belongs
    to. For example, a `User` class might want to use a `Mailer` service to deliver
    email. The `Mailer` object can be passed to the `User` class and the `User` needs
    to make sure that nothing except a `Mailer` object is passed to it.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示允许我们定义要传递给函数的数据类型。PHP支持类类型提示，这意味着在函数参数中，你可以提到传递的参数对象属于哪个类类型。例如，一个`User`类可能想使用`Mailer`服务来发送电子邮件。`Mailer`对象可以传递给`User`类，而`User`需要确保传递给它的不是`Mailer`对象以外的任何东西。
- en: 'Check out the following example where the function argument was expected to
    be an instance of a specific class:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例，其中函数参数预期为特定类的实例：
- en: '[PRE86]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If the object is not an instance of the expected class, then an exception is
    thrown with the message '`Only Objects of ClassName can be sent to this function.`'.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象不是预期类的实例，则抛出异常，消息为"`只有ClassName的对象可以发送到这个函数。`"。
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An exception is a class that is throwable and catchable with an error message
    so that the catch block can catch the exception and work accordingly. *Chapter
    8, Error Handling,* discusses exceptions in detail.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一个可以抛出并带有错误信息的类，这样捕获块就可以捕获异常并相应地工作。"第8章，错误处理"详细讨论了异常。
- en: 'The preceding snippet is equivalent to the following class type hinting syntax:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段等同于以下类类型提示语法：
- en: '[PRE87]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So, with class type hinting, we can enforce the function or method caller to
    pass the appropriate type of object. When class type hinting is applied, PHP automatically
    performs `instanceof` checking and produces an error if the object doesn't satisfy
    the class relationship.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用类类型提示，我们可以强制函数或方法调用者传递适当的对象类型。当应用类类型提示时，PHP会自动执行`instanceof`检查，如果对象不满足类关系，则产生错误。
- en: '`user` object might need to send out emails and perform certain database operations;
    therefore, the user is dependent on the `mailer` object and the `database` object.
    We could supply such `mailer` and `database` objects to the `user` object as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`对象可能需要发送电子邮件并执行某些数据库操作；因此，用户依赖于`mailer`对象和`database`对象。我们可以如下提供这样的`mailer`和`database`对象给`user`对象：'
- en: '[PRE88]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, while instantiating the `User` class, we have passed the name of the user,
    a `mailer` object, and a `database` object as arguments. The `Mailer` `$mailer`
    class type hint ensures that the only instance of the `Mailer` class can be supplied
    and the other class type hint at `Database $database` ensures that the only instance
    of the `Database` class can be supplied. We have added these two object dependencies
    in the user's constructor so that the object gets loaded with certain dependencies
    and any failure upon injecting dependencies will prevent object creation.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在实例化`User`类时，我们传递了用户名、一个`mailer`对象和一个`database`对象作为参数。`Mailer` `$mailer`类类型提示确保只能提供`Mailer`类的唯一实例，而`Database
    $database`类的其他类类型提示确保只能提供`Database`类的唯一实例。我们在用户的构造函数中添加了这两个对象依赖项，以便对象加载了某些依赖项，并且任何注入依赖项的失败都将阻止对象创建。
- en: The preceding technique is called **constructor injection**. You can inject
    dependencies using a setter method or you can use a dependency injection container.
    You could search for books or online resources to extend your learning about dependency
    injection even further.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的技术被称为**构造器注入**。您可以使用setter方法注入依赖项，或者可以使用依赖注入容器。您可以搜索书籍或在线资源来进一步扩展您对依赖注入的了解。
- en: In the next section, we are going to discuss two important aspects of polymorphism
    that serve the same purpose for different conditions.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论多态的两个重要方面，它们在不同条件下服务于相同的目的。
- en: Overriding
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖
- en: Overriding is the process of updating an existing implementation (an inherited
    implementation) with a new one; it can be redeclaring a class attribute in derived
    objects or it can be taking an inherited member method to update with a whole
    new function body. Overriding keeps the external interface the same while the
    internal
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖是更新现有实现（继承的实现）的过程；它可以是重新声明派生对象中的类属性，或者可以是使用全新的函数体更新继承的成员方法。覆盖保持外部接口不变，而内部
- en: functionalities might be fully changed to suit your own objectives. In PHP,
    you can do both attribute and method overriding. Note that this overriding happens
    in new classes derived by inheritance.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 功能可能完全改变以适应您的目标。在PHP中，您可以同时进行属性和方法覆盖。请注意，这种覆盖发生在通过继承派生的新类中。
- en: For example, an animal class might provide a common behavior; for example, eat.
    Such behavior is shared among the animal subclasses via inheritance. But the fact
    is, each animal subclass has its own way of eating. Like dogs and birds, they
    have redefined the behavior of eating in their own class. The idea of adding your
    own way of doing something is conceptualized as overriding.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个动物类可能提供一种共同的行为；例如，吃。这种行为通过继承在动物子类之间共享。但事实是，每个动物子类都有自己独特的方式进食。像狗和鸟一样，它们在自己的类中重新定义了进食的行为。添加自己独特方式的观念被概念化为覆盖。
- en: Attribute Overriding
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性覆盖
- en: 'Attribute overriding is the process of replacing the parent''s class'' data
    in the subclass. We have already seen that the `Motorcycle` class overrides the
    inherited number of wheels from the parent `Vehicle` class to two as motorcycles
    are two-wheelers. So, in order to suit the derived class'' requirement, we have
    overridden the attribute:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 属性覆盖是替换子类中父类数据的进程。我们已经看到，`Motorcycle`类覆盖了从父类`Vehicle`继承的轮子数量，将其更改为两个，因为摩托车是两轮车。因此，为了满足派生类的要求，我们覆盖了以下属性：
- en: '[PRE89]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Method Overriding
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法覆盖
- en: Method overriding is necessary when we need to rewrite an inherited method.
    For example, to get the price of a vehicle, the class provides a getter method
    and the vehicle subclasses can avail the getter via inheritance. What if we want
    to tweak the returned price for a particular type of vehicle; for example, a discounted
    motorcycle price, and keep the getter intact for `Car`? We need to tweak the desired
    subclass price getter by overriding it.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要重写继承的方法时，方法重写是必要的。例如，为了获取车辆的价格，类提供了一个getter方法，车辆子类可以通过继承使用getter。如果我们想调整特定类型车辆返回的价格；例如，折扣后的摩托车价格，并保持`Car`的getter不变？我们需要通过重写来调整所需的子类价格getter。
- en: 'Check out the following example of method overriding:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下方法重写的示例：
- en: '[PRE90]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: So, we can override the inherited method and update the method with the new
    implementation.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以重写继承的方法，并更新方法以使用新的实现。
- en: Let's have some fun and sell our vehicles. So far, we have been adding technical
    features to our vehicles with the help of OOP. Now, let's add some commerce-related
    features to our vehicle types. In the following exercise, the price for the car
    and motorcycle should be returned using a common method. The price of a motorcycle
    should be returned after applying a 5% discount, and no discount is applicable
    to the car price.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩得开心一些，出售我们的车辆。到目前为止，我们已经在OOP的帮助下为我们的车辆添加了技术特性。现在，让我们为我们的车辆类型添加一些与商业相关的特性。在下面的练习中，汽车和摩托车的价格应使用通用方法返回。摩托车的价格应在应用5%折扣后返回，而汽车价格不适用折扣。
- en: 'Exercise 5.8: Overriding an Inherited Method'
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.8：重写继承的方法
- en: 'In this exercise, we will practice method overriding by adding a simple `getPrice()`
    getter method to the parent `Vehicle` class and override the method from our child
    classes. If we add a getter method with the implementation of the method into
    the parent `Vehicle` class, then it should be available for all the subclasses
    to use. We are going to override the `getPrice()` method in the `Motorcycle` class
    since we need to handle the pricing in a different way in that subclass:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过向父`Vehicle`类添加简单的`getPrice()`getter方法并重写子类中的方法来练习方法重写。如果我们向父`Vehicle`类添加一个具有方法实现的getter方法，那么它应该对所有子类可用。我们将重写`Motorcycle`类中的`getPrice()`方法，因为我们需要在那个子类中以不同的方式处理定价：
- en: 'Open `AbstractVehicle.php` and add the following protected attribute in the
    attributes section:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AbstractVehicle.php`并在属性部分添加以下受保护的属性：
- en: '[PRE91]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Also, add the `getPrice()` and `setPrice()` price getter and setter methods
    in the methods section as follows:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在方法部分添加`getPrice()`和`setPrice()`价格getter和setter方法，如下所示：
- en: '[PRE92]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, the `getPrice()` simply returns the price and `setPrice()` takes `$price`
    as an argument, assigns it to the `price` attribute of the vehicle, and both these
    methods should be available to the `Car` and `Motorcycle` objects so that we can
    set and get the prices of a car and a motorcycle, respectively.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`getPrice()`简单地返回价格，`setPrice()`接受`$price`作为参数，将其分配给车辆的`price`属性，并且这两个方法都应该对`Car`和`Motorcycle`对象可用，以便我们可以分别设置和获取汽车和摩托车的价格。
- en: Imagine there is a discount of 5% on all kinds of motorcycles for a special
    occasion. Now, we need to apply the discount to the price of this particular vehicle
    type.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，为了特殊场合，所有类型的摩托车都有5%的折扣。现在，我们需要将这个折扣应用到这种特定车辆类型的价格上。
- en: 'In order to handle prices differently, we need to override the `getPrice()`
    method in the `Motorcycle.php` class and add the `getPrice()` method into the
    class, as follows, and modify the price calculation:'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了对价格进行不同的处理，我们需要在`Motorcycle.php`类中重写`getPrice()`方法，并将`getPrice()`方法添加到类中，如下所示，并修改价格计算：
- en: '[PRE93]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we have deducted the discounted value from the original price. So, the
    motorcycle objects will return the discounted price and the car objects will return
    the original price.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们从原始价格中扣除了折扣值。因此，摩托车对象将返回折扣后的价格，而汽车对象将返回原始价格。
- en: 'In order to test the discounted price, we should instantiate the `Motorcycle`
    class, set the price, and get the price to see whether a discount has been applied
    or not. Let''s do the following in `Motorcycle.php`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试折扣后的价格，我们应该实例化`Motorcycle`类，设置价格，并获取价格以查看是否应用了折扣。让我们在`Motorcycle.php`中执行以下操作：
- en: '[PRE94]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we have settled the original price as `5000` and tried to get the price
    using the `getPrice()` method.
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将原始价格设定为`5000`并尝试使用`getPrice()`方法获取价格。
- en: 'Now, if we run `Motorcycle.php` with the `php Motorcycle.php` command, the
    preceding code outputs the following:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们使用`php Motorcycle.php`命令运行`Motorcycle.php`，前面的代码将输出以下内容：
- en: '[PRE95]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: So, the discount mentioned has been applied to the motorcycle price and if we
    apply the getter and setter methods for the cars, we should get the car price
    equal to the original price that we set. This is why, when we need something to
    be delivered in a different manner by the child classes, we need an override.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所提到的折扣已经应用于摩托车价格，如果我们为汽车应用getter和setter方法，我们应该得到与原始设置相等的汽车价格。这就是为什么当我们需要子类以不同方式实现某些功能时，我们需要重写。
- en: Overloading
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载
- en: Another important aspect of using the polymorphism concept of overloading relates
    to the use of the same thing defined differently or the same thing behaving differently
    on different occasions.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重载的多态概念的一个重要方面是关于同一事物以不同的方式定义或在不同场合表现出不同的行为。
- en: Generally, among programming languages such as C++ and Java, method overloading
    or function polymorphism is just declaring the same function with different parameters;
    for example, `int add(int a, int b)`, `int add(int a, int b, int c)`, `double
    add( double a, double b, double c)`, and so on. These might have different implementations
    inside. In such a traditional way, the function name remains the same while the
    return type and the number of arguments and their types might be different. This
    also happens in statically typed programming languages (C++/Java) where type checking
    happens at compile time and function binding depends on the type of each parameter.
    Hence, for statically typed languages, each such function is different.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在C++和Java等编程语言中，方法重载或函数多态只是声明具有不同参数的相同函数；例如，`int add(int a, int b)`，`int
    add(int a, int b, int c)`，`double add(double a, double b, double c)`等等。这些可能具有不同的实现。在这种传统方式中，函数名保持不变，而返回类型和参数的数量及其类型可能不同。这种情况也发生在静态类型编程语言（C++/Java）中，其中类型检查发生在编译时，函数绑定取决于每个参数的类型。因此，对于静态类型语言，每个这样的函数都是不同的。
- en: 'In PHP, you could try to declare a function or method with the same name as
    the following:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，你可以尝试声明一个与以下相同的名称的函数或方法：
- en: '[PRE96]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This would produce a fatal error that you cannot redeclare a function or method
    with the same name.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个致命错误，你不能重新声明具有相同名称的函数或方法。
- en: 'PHP doesn''t support declaring same function multiple times. Still, you can
    achieve classical function overloading using the built-in `func_get_args()` function
    in order to enable the same function, taking a multiple number of arguments since
    PHP isn''t bothered about parameter types. Here''s an example for the sake of
    discussion here. Let''s use the following approach:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: PHP不支持多次声明相同的函数。尽管如此，你可以使用内置的`func_get_args()`函数来实现经典的重载功能，以便使同一个函数能够接受多个参数，因为PHP不关心参数类型。以下是一个讨论的例子。让我们使用以下方法：
- en: '[PRE97]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`func_get_args()` can really turn your functions on to support multiple arguments.
    Also, if you are worried about parameter types, you can deal with type checking
    inside the function.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_get_args()`可以使你的函数支持多个参数。此外，如果你担心参数类型，你可以在函数内部处理类型检查。'
- en: So the preceding approach is not the approach we are going to talk about in
    this section on method overloading in OOP. PHP has a lot to offer flexibility-wise
    when it comes to overloading in OOP. Still, the approach is different from other
    languages and that might be why there is some controversy about the way it serves
    overloading compared to traditional overloading.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面提到的方法不是本节将要讨论的关于面向对象编程（OOP）中方法重载的方法。PHP在面向对象编程中的重载方面提供了很多灵活性。然而，这种方法与其他语言不同，这也可能是为什么在传统重载方式与PHP的重载方式之间存在一些争议。
- en: The interpretation of overloading in PHP is different than most of the other
    object-oriented languages. Overloading allows you to have multiple methods with
    the same name but different signatures.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中重载的解释与大多数其他面向对象的语言不同。重载允许你拥有多个具有相同名称但不同签名的函数。
- en: PHP allows the overloading of attribute and method calls by implementing certain
    magic methods. These magic methods are invoked when trying to access the attributes
    and methods that are not declared or are not accessible in the current scope.
    Such special proxy methods are to create attributes and methods during runtime
    (dynamic attributes and methods), and we can implement magic methods easily in
    our class for numerous functionalities.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 允许通过实现某些魔术方法来重载属性和方法调用。当尝试访问当前作用域中未声明或不可访问的属性和方法时，会调用这些魔术方法。这些特殊的代理方法用于在运行时创建属性和方法（动态属性和方法），我们可以在我们的类中轻松实现魔术方法以实现多种功能。
- en: Attribute Overloading
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性重载
- en: We might need to add data to our objects at runtime; for example, in our `Car`
    subclass, we haven't declared attributes such as model, year, owner name, and
    so on. But while running the program, we might want to welcome such attributes
    to be stored in our objects. PHP allows you to achieve such dynamic attribute
    addition at runtime in terms of attribute overloading. Hence, with such dynamic
    declaration, attributes become polymorphic enough in use and can be overloaded
    easily.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在运行时向我们的对象添加数据；例如，在我们的 `Car` 子类中，我们没有声明模型、年份、车主姓名等属性。但在程序运行时，我们可能希望将这些属性存储在我们的对象中。PHP
    允许您通过属性重载在运行时实现这样的动态属性添加。因此，通过这种动态声明，属性在用途上足够多态，并且可以轻松重载。
- en: 'For attribute or property overloading, PHP supports the following two magic
    methods:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性或属性重载，PHP 支持以下两个魔术方法：
- en: '`public __get(string $attribute) : mixed`'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public __get(string $attribute) : mixed`'
- en: '`public __set(string $attribute, mixed $value)`'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public __set(string $attribute, mixed $value)`'
- en: '`__get()` is invoked when accessing or reading data from not declared or not
    accessible (protected or private) attributes and `__set()` is invoked when trying
    to write data to not declared or not accessible (protected or private) attributes.
    All we need to do is implement these two special methods in our class to avail
    the dynamic (created at runtime) attributes. `__set()` accepts any types (mixed)
    of data in the second parameter; `__get()` returns that type of data. Here, the
    `mixed` keyword has been used to explain that the method returns or accepts a
    type of data, such as integer, string, array, object, and so on.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`__get()` 在访问或读取未声明或不可访问（受保护或私有）属性时被调用，而 `__set()` 在尝试写入未声明或不可访问（受保护或私有）属性时被调用。我们只需要在我们的类中实现这两个特殊方法，以使用动态（在运行时创建）属性。`__set()`
    接受任何类型的（混合）数据作为第二个参数；`__get()` 返回该类型的数据。在这里，`mixed` 关键字被用来解释该方法返回或接受的数据类型，如整数、字符串、数组、对象等。'
- en: 'Let''s look at the class here, which has these two method implementations:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里具有这些两种方法实现的类：
- en: '[PRE98]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here, the private declared property, `$arr` , holds the dynamic attributes coming
    from the `__set()` setter magic method. The attribute has been used as an array
    key to store the passed value with the `$this->arr[$attribute] = $value` line.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，私有声明的属性 `$arr` 存储来自 `__set()` setter 魔术方法的动态属性。该属性已被用作数组键，通过 `$this->arr[$attribute]
    = $value` 这一行存储传递的值。
- en: Also, to return the settled attribute via the implemented getter magic method,
    `__get()`, we have checked that the attribute exists in the array using the `array_key_exists()`
    function. If it exists, then return the attribute value by accessing `$arr` with
    the attribute name as a key. Otherwise, print an error message.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了通过实现的 getter 魔术方法 `__get()` 返回已设置的属性，我们已使用 `array_key_exists()` 函数检查该属性是否存在于数组中。如果存在，则通过使用属性名作为键访问
    `$arr` 来返回属性值。否则，打印错误信息。
- en: At the `$object->dynamicAttribute = 'I am magic';` line, we have accessed an
    attribute that is not declared anywhere within the `MyMagicClass` class. So, behind
    the scene, the magic method invoked `__set('dynamicAttribute', 'I am magic')`
    to store the attribute. The `__get('dynamicAttribute')` is invoked with the line
    `echo $object->dynamicAttribute . PHP_EOL;`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$object->dynamicAttribute = 'I am magic';` 这一行，我们访问了一个在 `MyMagicClass` 类内部任何地方都没有声明的属性。因此，在幕后，调用了魔术方法
    `__set('dynamicAttribute', 'I am magic')` 来存储该属性。`__get('dynamicAttribute')` 在
    `echo $object->dynamicAttribute . PHP_EOL;` 这一行被调用。
- en: Thus, implementing such magic methods gives you a lot of flexibility to define
    your own attributes. Remember that attribute overloading works in object context
    and not in a static context.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的魔术方法为您提供了很多灵活性来定义自己的属性。请记住，属性重载在对象上下文中工作，而不是在静态上下文中。
- en: Now, the questions are, are we going to allow many attribute creation on the
    fly or should we apply some restrictions? Or is there any predefined set of attributes
    that we accept as overloaded. The answer is yes, we should predefine the set of
    attributes that we are going to overload. In the previous example, we should add
    a predefined list of overloadable attributes into an array and in `__set()`, the
    given dynamic attribute should be cross-checked with our predefined array to check
    whether it is allowed or not.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是，我们是否允许动态创建许多属性，或者我们应该施加一些限制？或者是否存在一组预定义的属性，我们接受为重载。答案是，我们应该预定义我们将要重载的属性集。在先前的例子中，我们应该将一个预定义的重载属性列表添加到一个数组中，并在`__set()`方法中，将给定的动态属性与我们的预定义数组交叉检查，以确定是否允许。
- en: 'Let''s check out the following example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下示例：
- en: '[PRE99]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, we have added an associative array in the `$arr` private property and
    when the `__set()` method triggers, we cross-check that the attribute is allowed
    in `$arr` using the `array_key_exists()` function; otherwise, we print an error
    message.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`$arr`私有属性中添加了一个关联数组，当`__set()`方法触发时，我们使用`array_key_exists()`函数检查属性是否在`$arr`中允许；否则，我们打印一条错误信息。
- en: 'We are flexible enough to come up with innovative implementations and restrictions
    of such special proxy methods. After the magical setter and getter implementations,
    we can implement the following two magic methods:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们足够灵活，可以提出这样的特殊代理方法的创新实现和限制。在魔法设置器和获取器实现之后，我们可以实现以下两个魔法方法：
- en: '`public __isset(string $attribute) : bool`'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public __isset(string $attribute) : bool`'
- en: '`public __unset(string $attribute): void`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public __unset(string $attribute): void`'
- en: The `__isset()` one should be implemented if we want to check the attribute
    with `isset($attribute)` or the `empty($attribute)` function. Similarly, we should
    implement `__unset()` if we want to implement and unset the attribute with the
    `unset($attribute)` function. Without `__isset()` and `__unset()`, we won't be
    able to use native `isset()` and `unset()`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用`isset($attribute)`或`empty($attribute)`函数检查属性，那么应该实现`__isset()`。同样，如果我们想要实现和取消设置属性，应该实现`__unset()`。没有`__isset()`和`__unset()`，我们将无法使用原生的`isset()`和`unset()`。
- en: Note
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: PHP's magic methods should not be declared as static since they trigger only
    in object context. The implemented magic methods must be declared as public. Also,
    pass by reference cannot be used as parameters in magic methods. The `__` notation
    is reserved for magic methods.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的魔法方法不应声明为静态，因为它们仅在对象上下文中触发。实现的魔法方法必须声明为公共的。此外，在魔法方法中不能使用按引用作为参数。`__`符号是为魔法方法保留的。
- en: Method Overloading
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: Method overloading is all about doing extra work with the same method. For example,
    in our `Car` subclass, we haven't declared the `honking` behavior. What if we
    can avail the `honk()` method dynamically (at runtime) and can overload the normal
    `honking` behavior with honking loud? PHP supports such dynamic method declaration
    and we are allowed to overload those methods.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载完全是关于使用相同的方法做额外的工作。例如，在我们的`Car`子类中，我们没有声明`honking`行为。如果我们能够在运行时动态地使用`honk()`方法，并且可以用响亮的声音重载正常的`honking`行为，那会怎么样？PHP支持这样的动态方法声明，并且我们允许重载这些方法。
- en: 'For method overloading, PHP supports the following two magic methods:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法重载，PHP支持以下两个魔法方法：
- en: '`public __call(string $method, array $arguments): mixed`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public __call(string $method, array $arguments): mixed`'
- en: '`public static __callStatic(string $method, array $arguments): mixed`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static __callStatic(string $method, array $arguments): mixed`'
- en: These are the `__call()` invoked when the inaccessible method has been called
    in the object context and the `__callStatic()` invoked when the inaccessible method
    has been called in the static context. The second argument of these methods is
    `$arguments`, which is a numerically indexed array. The index 0 contains the first
    argument and so on.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是当在对象上下文中调用不可访问的方法时触发的`__call()`，以及当在静态上下文中调用不可访问的方法时触发的`__callStatic()`。这些方法的第二个参数是`$arguments`，它是一个数值索引数组。索引0包含第一个参数，依此类推。
- en: 'Let''s check out the following implementations of these magic methods:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下这些魔法方法的实现：
- en: '[PRE100]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, with the `$object->showMagic('object context', 'second argument');` line,
    `showMagic()` is declared nowhere or is a non-accessible method to the object
    handler, so behind the scenes the `__call()` is invoked like `__call('showMagic',
    array('object context', 'second argument'))`. Also, you can see that the `showMagic()`
    method can interact with a different number of arguments.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `$object->showMagic('object context', 'second argument');` 这一行，`showMagic()`
    在任何地方都没有声明，或者是一个对对象处理程序不可访问的方法，所以幕后 `__call()` 被调用，就像 `__call('showMagic', array('object
    context', 'second argument'))`。同时，你可以看到 `showMagic()` 方法可以与不同数量的参数交互。
- en: Similarly, `__callStatic('showMagic', array(static context'))` works in the
    static context when `MyMagicMethodClass::showMagic('static context')` gets called.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`__callStatic('showMagic', array(static context'))` 在静态上下文中工作，当调用 `MyMagicMethodClass::showMagic('static
    context')` 时。
- en: 'Exercise 5.9: Implementing Attribute and Method Overloading'
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.9：实现属性和方法重载
- en: 'In this exercise, let''s implement the overloading magic methods in `AbstractVehicle`
    so that both vehicle types should have the facility to define their dynamic attributes
    and methods at runtime. All we need to do is, go through our previously discussed
    implementation of the `__set()`,`__get()`, and `__call()` magic methods into the
    `AbstractVehicle` class. This will help the `Car` and `Motorcycle` objects avail
    such runtime properties and method creation:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，让我们在 `AbstractVehicle` 中实现属性和方法重载的魔术方法，以便车辆类型都应该能够在运行时定义它们的动态属性和方法。我们所需做的只是，将之前讨论的
    `__set()`、`__get()` 和 `__call()` 魔术方法实现到 `AbstractVehicle` 类中。这将帮助 `Car` 和 `Motorcycle`
    对象获得这样的运行时属性和方法创建：
- en: 'Open `AbstractVehicle.php` and add the following private attribute, which holds
    dynamic time attributes:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AbstractVehicle.php` 并添加以下私有属性，它持有动态时间属性：
- en: '[PRE101]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, `$runtimeAttributes` should act as an associative array to store the runtime
    key-value pairs of the dynamic attributes. The attribute or property name should
    be the key with the associated value.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`$runtimeAttributes` 应该作为一个关联数组来存储动态属性的运行时键值对。属性或属性名称应该是键，相关值是关联值。
- en: 'Now, we should add the magic setter, `__set()`, in the `AbstractVehicle` class,
    as follows:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在 `AbstractVehicle` 类中添加魔术设置器，`__set()`，如下所示：
- en: '[PRE102]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, the `$attribute` name and `$value` are passed to the magic method via
    the `$attribute` and `$value` arguments. The `$value` runtime attribute has been
    stored in the associative array using the `$attribute` attribute name argument
    as key, so that, later, we can access the runtime attribute with `$this->runtimeAttributes[$attribute]`.
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`$attribute` 名称和 `$value` 通过 `$attribute` 和 `$value` 参数传递给魔术方法。使用 `$attribute`
    属性名称参数作为键，将 `$value` 运行时属性存储在关联数组中，这样我们就可以通过 `$this->runtimeAttributes[$attribute]`
    访问运行时属性。
- en: 'Let''s add the magic getter, `__get()`, as well:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加魔术获取器，`__get()`：
- en: '[PRE103]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, the magic method asks to return the runtime attribute value by passing
    the attribute name as an argument. The method checks whether the attribute name
    is available as a key in `$this->runtimeAttributes` using PHP's `array_key_exists()`
    function. If the attribute was set previously, then it should return it, else
    it will print the preceding error message.
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，魔术方法要求通过传递属性名称作为参数来返回运行时属性值。该方法使用 PHP 的 `array_key_exists()` 函数检查属性名称是否作为键存在于
    `$this->runtimeAttributes` 中。如果属性之前已设置，则应返回它，否则将打印前面的错误消息。
- en: 'Now, try such attribute creation at runtime in the `Car.php` class. For example,
    we can add car properties such as `ownerName`, `make`, `year`, and so on, as follows:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Car.php` 类中尝试在运行时创建这样的属性。例如，我们可以添加汽车属性，如 `ownerName`、`make`、`year` 等，如下所示：
- en: '[PRE104]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, we haven't declared `$ownerName` and `$year` in the `Car` class. When
    an attribute is accessed via a `Car` object handler that is not declared or not
    accessible to the object, then PHP invokes magic methods in order to deliver you
    that attribute. Note that without assigning a value to such a runtime attribute,
    it won't be available or registered.
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们没有在 `Car` 类中声明 `$ownerName` 和 `$year`。当通过一个未声明或对对象不可访问的 `Car` 对象处理程序访问属性时，PHP
    将调用魔术方法以提供该属性。请注意，如果没有为这样的运行时属性分配值，它将不可用或注册。
- en: Since the `Car` class inherited the implemented magic methods and we have settled
    values on both the attributes using `$car->ownerName` and `$car->year`, they have
    been added into the `$runtimeAttributes` array, which is private to the parent
    `Vehicle` class.
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `Car` 类继承了实现的魔术方法，并且我们已经使用 `$car->ownerName` 和 `$car->year` 在属性上设置了值，它们已经被添加到私有父类
    `Vehicle` 的 `$runtimeAttributes` 数组中。
- en: 'If we try to run `Car.php` with the `php Car.php` command, the preceding code
    should be printed as follows:![Figure 5.21: Attribute overloading and non-existing
    attribute access of the car object'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`php Car.php`命令运行`Car.php`，前面的代码应该按以下方式打印：![图5.21：汽车对象的属性重载和非现有属性访问
- en: '](img/C14196_05_21.jpg)'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_21.jpg)'
- en: '[PRE105]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we have added the implementation of the magic method with two arguments.
    The first argument, `$method`, is for the method name, and the latter one, `$arguments`,
    is a numerically indexed array of arguments to be passed when we invoke the given
    method.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们添加了带有两个参数的魔术方法实现。第一个参数`$method`是方法名称，后者`$arguments`是一个参数数组，当调用给定方法时，我们将传递这些参数。
- en: So, we can add our own styles or patterns as implementation, but now, for the
    sake of simplicity, we have just printed the method name inside the function.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们可以添加自己的样式或模式作为实现，但现在，为了简单起见，我们只是在函数内部打印了方法名称。
- en: 'Add the following line at the bottom of `Car.php`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car.php`的底部添加以下行：
- en: '[PRE106]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, we have called the `honk()` method to dynamically add the honking behavior
    to our `Car` objects.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们调用了`honk()`方法，以动态地向我们的`Car`对象添加鸣笛行为。
- en: 'If we run `Car.php` using the `php Car.php` command, it will output the following:![Figure
    5.22: Method overloading of car'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`php Car.php`命令运行`Car.php`，它将输出以下内容：![图5.22：汽车的函数重载
- en: '](img/C14196_05_22.jpg)'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_22.jpg)'
- en: 'Figure 5.22: Method overloading of car'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.22：汽车的函数重载
- en: 'We can now overload the `honk()` method easily by updating the `__call()` method
    at `AbstractVehicle.php` with the following content:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过在`AbstractVehicle.php`中更新`__call()`方法，以下列内容轻松地重载`honk()`方法：
- en: '[PRE107]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we have added a switch case to accommodate different dynamic methods.
    We have added a case for the `honk()` method so that we can respond to it and
    perform steps for the `honk()` method. In the `honk()` case, for demo purposes,
    we have checked for supplied arguments, we have printed a message based on the
    first argument, and printed another message based on the second argument and so
    on. We can also handle the arguments differently.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个switch case来适应不同的动态方法。我们为`honk()`方法添加了一个case，以便我们可以对其做出响应并执行`honk()`方法的步骤。在`honk()`case中，为了演示目的，我们检查了提供的参数，根据第一个参数打印了一条消息，并根据第二个参数打印了另一条消息，依此类推。我们也可以以不同的方式处理参数。
- en: 'At the bottom of `Car.php`, after the previous `$car->honk()` line, add the
    following two lines:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car.php`的底部，在之前的`$car->honk()`行之后，添加以下两行：
- en: '[PRE108]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we have overloaded the `honk()` method and the method became polymorphic.
    We can honk (default), we can honk gently, we can honk louder, and we can enable
    the siren in the event of an emergency. The whole idea of the honk analogy is
    to summarize how we can overload methods in PHP.
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们重载了`honk()`方法，并且该方法变得多态。我们可以鸣笛（默认），我们可以轻柔地鸣笛，我们可以大声鸣笛，在紧急情况下我们可以启用警报器。鸣笛的类比整个想法是总结我们如何在PHP中重载方法。
- en: 'If we run `Car.php` using the `php Car.php` command, it will output the following:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`php Car.php`命令运行`Car.php`，它将输出以下内容：
- en: '![Figure 5.23: The honk method overloaded'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23：`honk`方法的重载'
- en: '](img/C14196_05_23.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_23.jpg)'
- en: 'Figure 5.23: The honk method overloaded'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：`honk`方法的重载
- en: This is how we can add dynamic properties and behaviors to our objects, and,
    yes, of course we can add attribute/method restrictions and cross-check them with
    a prebuilt checklist, implement patterns, and so on in such magic methods.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以向我们的对象添加动态属性和行为的方法，当然，我们当然可以在这些魔术方法中添加属性/方法限制，并与预构建的清单进行交叉检查，实现模式，等等。
- en: Final Classes and Methods
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终类和方法
- en: When we finalize our class declaration by providing a standard set of attributes
    and methods to describe an object and we neither want the class to be modified
    nor an extension of that class, we need to declare it with the `final` keyword.
    For example, in a simple login process, we match the given password with the stored
    password to grant access to the user. We don't want this password matchmaker method
    to be modified so we need to declare the method as final or our user authentication
    class might have a standard set of methods that we don't want to be modified or
    extended so we need to declare the class as final.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过提供一组标准的属性和方法来描述对象并既不希望修改类也不希望扩展该类来最终化我们的类声明时，我们需要使用 `final` 关键字声明它。例如，在一个简单的登录过程中，我们将给定的密码与存储的密码匹配以授予用户访问权限。我们不希望修改这个密码匹配器方法，因此我们需要将该方法声明为最终方法，或者我们的用户身份验证类可能有一组标准的我们不想修改或扩展的方法，因此我们需要将类声明为最终类。
- en: Final classes are written to not be inherited and final methods cannot be overridden.
    PHP uses the `final` keyword before the final class and final methods.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 最终类被编写为不继承，最终方法不能被覆盖。PHP 使用 `final` 关键字在最终类和最终方法之前。
- en: 'Check out the following example of the final class:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下最终类的示例：
- en: '[PRE109]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, if we try to extend the final class, `MyClass`, it will produce a fatal
    error that the `MyChildClass` class may not inherit from the final `MyClass` class.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们尝试扩展最终类 `MyClass`，它将产生一个致命错误，即 `MyChildClass` 类不能从最终的 `MyClass` 类继承。
- en: 'Also, let''s have an example for the final methods:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们有一个最终方法的示例：
- en: '[PRE110]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The preceding will produce a fatal error as you cannot override a final method.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作将产生一个致命错误，因为您不能覆盖最终方法。
- en: 'Exercise 5.10: Implementing a Final Class and Methods'
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.10：实现最终类和方法
- en: 'In this exercise, we are going to practice implementing a final class and methods
    to understand what the consequences of finalizing methods and classes are. We
    will be applying a member method as final in the `Car` subclass and then we will
    be applying the `Car` class as final so that we can block any derivation (inheritance)
    from the `Car` class:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将练习实现一个最终类和方法，以了解最终化方法和类的后果。我们将在 `Car` 子类中将一个成员方法作为最终方法应用，然后我们将把 `Car`
    类作为最终类应用，这样我们就可以阻止从 `Car` 类的任何派生（继承）：
- en: 'Open `Car.php` and locate the `start()` method as follows:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Car.php` 并按照以下方式定位 `start()` 方法：
- en: '[PRE111]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As you can see, `Car` checks that the key is in the ignition to turn on the
    engine. We need to make sure that the engine start involves checking for the key.
    In other words, we won't allow the overriding of this engine start procedure.
    Hence, we need to lock any possible overriding via derivation by using the `final`
    keyword before the access modifier of the `start()` method.
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`Car` 会检查钥匙是否在点火位置以启动发动机。我们需要确保发动机启动过程涉及检查钥匙。换句话说，我们不会允许覆盖这个发动机启动过程。因此，我们需要通过在
    `start()` 方法的访问修饰符之前使用 `final` 关键字来锁定任何可能的覆盖。
- en: 'Add the `final` keyword before the `start()` method as follows:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `start()` 方法之前添加 `final` 关键字，如下所示：
- en: '[PRE112]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Here, the `start()` method has been finalized and no override should be allowed.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`start()` 方法已经被最终化，不应允许覆盖。
- en: 'Create a new `Car` subclass, `Van`, in a PHP file, `Van.php`, with the following
    content:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Van.php` 文件中创建一个新的 `Car` 子类 `Van`，内容如下：
- en: '[PRE113]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, `Van` is an offspring of the `Car` class and is ready to override any
    methods acquired from the parent.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Van` 是 `Car` 类的后代，并准备好覆盖从父类获得的所有方法。
- en: 'Let''s try overriding the final method, `start()`, declared by the `Car` class:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试覆盖由 `Car` 类声明的最终方法 `start()`：
- en: '[PRE114]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, the `Van` class overrides the `Car` class' engine `start()` method, which
    is not permissible from the `Car` class.
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Van` 类覆盖了 `Car` 类的 `engine start()` 方法，这在 `Car` 类中是不允许的。
- en: 'If we run `Van.php` using the `php –d display_errors=on Van.php` command, we
    should see the following fatal error:![Figure 5.24: The Van subclass attempts
    to override the Car engine start method'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用 `php –d display_errors=on Van.php` 命令运行 `Van.php`，我们应该看到以下致命错误：![图 5.24：`Van`
    子类尝试覆盖 `Car` 发动机启动方法
- en: '](img/C14196_05_24.jpg)'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_24.jpg)'
- en: 'Figure 5.24: The Van subclass attempts to override the Car engine start method'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.24：`Van` 子类尝试覆盖 `Car` 发动机启动方法
- en: The override failed at the `Van` subclass. When we need to secure our methods
    from communicating with an object, we need to finalize those methods.
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 覆盖失败在 `Van` 子类。当我们需要确保我们的方法不与对象通信时，我们需要最终化这些方法。
- en: 'Now, let''s say we don''t need further derivation of the `Car` class and we
    have finalized the `Car` class, as follows, by adding the `final` keyword before
    the `Car` class keyword:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们不需要进一步派生`Car`类，并且我们已经通过在`Car`类关键字之前添加`final`关键字来最终确定`Car`类，如下所示：
- en: '[PRE115]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Again, if we run `Van.php` using the `php –d display_errors=on Van.php` command,
    we should see the following fatal error:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，如果我们使用`php –d display_errors=on Van.php`命令运行`Van.php`，我们应该看到以下致命错误：
- en: '![Figure 5.25: The Van subclass attempts to extend the Car class'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：Van子类尝试扩展Car类](img/C14196_05_25.jpg)'
- en: '](img/C14196_05_25.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：Van子类尝试扩展Car类](img/C14196_05_25.jpg)'
- en: 'Figure 5.25: The Van subclass attempts to extend the Car class'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：Van子类尝试扩展Car类
- en: This is how the `final` keyword can be used to prevent method overriding and
    class extending. In practice, methods that should not be overridden anyhow should
    be finalized and classes that should not be extendable should be finalized.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用`final`关键字来防止方法覆盖和类扩展。在实践中，那些无论如何都不应该被覆盖的方法应该被最终化，那些不应该被扩展的类也应该被最终化。
- en: Traits
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`trait`'
- en: In a single inheritance language such as PHP, we often feel that we could have
    extended another class to inherit some functionalities. For example, in our `Car`
    class, we have inherited all the generic vehicle functionalities and now we might
    be in need of adding some e-commerce functionalities. Again, the `Motorcycle`
    class might want to have such e-commerce functionalities. As e-commerce related
    methods do not belong to the `Vehicle` class, we need to think of an alternative
    approach to reuse such e-commerce behavior. Hence, when we need to add a group
    of behaviors to our objects, we group the behaviors in terms of methods with a
    `trait` and use the `trait` inside our classes. A trait is similar to a class
    but you can't instantiate it; rather, you can use traits inside classes. A trait
    can be used in a class context with the `use` keyword; for example, `use TraitName`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在像PHP这样的单继承语言中，我们常常觉得我们可以扩展另一个类来继承一些功能。例如，在我们的`Car`类中，我们已经继承了所有通用的车辆功能，现在我们可能需要添加一些电子商务功能。同样，`Motorcycle`类可能也需要这样的电子商务功能。由于与电子商务相关的功能不属于`Vehicle`类，我们需要考虑一个替代方案来重用这样的电子商务行为。因此，当我们需要向我们的对象添加一组行为时，我们通过方法将行为分组，并在我们的类中使用`trait`。`trait`类似于一个类，但你不能实例化它；相反，你可以在类中使用`trait`。`trait`可以在类上下文中使用`use`关键字；例如，`use
    TraitName`。
- en: 'Check out the following `trait` syntax:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下`trait`语法：
- en: '[PRE116]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, the `MyTraitName` trait helps to group multiple methods, `one()` and `two()`,
    and to reuse these methods, we can use the trait using `MyTraitName;`. Hence,
    the trait methods become available to `MyClass{…}` and can be called using the
    `MyClass{…}` object handler, as in the preceding code.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyTraitName``trait`帮助组合多个方法，`one()`和`two()`，并且为了重用这些方法，我们可以使用`MyTraitName;`来使用`trait`。因此，`trait`方法对`MyClass{…}`可用，并且可以使用`MyClass{…}`对象处理程序来调用，如前面的代码所示。
- en: 'You can use multiple traits as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个`trait`，如下所示：
- en: '[PRE117]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Again, the member inserted by a trait overrides an inherited member. Let''s
    check out the following example:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由`trait`插入的成员覆盖了继承的成员。让我们看看以下例子：
- en: '[PRE118]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Here, `MyClass` extends class `A`, which has a method named `say()`, since `MyClass`
    avails the trait method `say()`. Then, we can consider the `MyClass` member `say()`
    as overriding the `say()` parent. In order to call the original parent method,
    `say()`, the trait supports `parent::` to access the parent's methods. Trait is
    all about delivering methods to your class that are assumed to be a useful part
    of your class.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyClass`扩展了具有名为`say()`方法的类`A`，因为`MyClass`使用了`trait`方法`say()`。然后，我们可以将`MyClass`成员`say()`视为覆盖了父类的`say()`。为了调用原始父方法`say()`，`trait`支持使用`parent::`来访问父类的方法。`trait`完全是关于向你的类提供被认为是类有用部分的方法的。
- en: 'Current class members can override the members added by traits. Again, if we
    extend the preceding example, we can derive the following example:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 当前类成员可以覆盖`trait`添加的成员。再次，如果我们扩展前面的例子，我们可以得到以下例子：
- en: '[PRE119]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Notice that the `say()` method gets overridden according to the sequence. Trait
    methods override inherited methods and class members override trait methods. Hence,
    `say()` from parent class `A` gets overridden by the `say()` method of trait `T`,
    and then, finally, `say()` in `MyClass` overrides the trait's `say()` method.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`say()`方法根据顺序被覆盖。`trait`方法覆盖继承的方法，类成员覆盖`trait`方法。因此，父类`A`中的`say()`被`trait`
    `T`的`say()`方法覆盖，然后，最终，`MyClass`中的`say()`覆盖了`trait`的`say()`方法。
- en: A trait is a way of adding functionalities and additions to inheritance. A trait
    enables you to add more features horizontally without the need to inherit another
    class.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是一种添加功能和扩展继承的方式。特性使您能够水平地添加更多功能，而无需继承另一个类。
- en: 'Exercise 5.11: Implementing Trait'
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.11：实现特性
- en: In this exercise, we will create a new trait named `PriceTrait` and shift the
    price setter and getter methods from the `AbstractVehicle` class to this trait.
    Since price-related methods should not belong to core vehicle features but to
    e-commerce features, we will add all sorts of price methods into the new price-related
    trait. The whole idea of shifting price-related methods into `PriceTrait` is to
    conceptualize how traits should come into the scenario and group logically related
    methods under a name.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的特性名为`PriceTrait`，并将价格设置器和获取器方法从`AbstractVehicle`类移到这个特性中。由于与价格相关的功能不应属于核心车辆特性，而应属于电子商务特性，我们将添加各种价格方法到新的价格相关特性中。将价格相关方法移入`PriceTrait`的整体想法是概念化特性如何进入场景，并将逻辑上相关的方法定义为具有名称的组。
- en: Note
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As per the PSR naming conventions, the Trait name must be suffixed by Trait;
    for example, `TestTrait` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k)).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PSR命名约定，特性名称必须后缀为Trait；例如，`TestTrait` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k))。
- en: Open `AbstractVehicle.php` and locate the `getPrice()` and `setPrice()` methods.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AbstractVehicle.php`并定位`getPrice()`和`setPrice()`方法。
- en: 'Create a new PHP file called `PriceTrait.php` with the following trait:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PriceTrait.php`的新PHP文件，包含以下特性：
- en: '[PRE120]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Cut the `getPrice()` and `setPrice()` methods from the `Vehicle` class and
    paste them into the `PriceTrait` trait as follows:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Vehicle`类中的`getPrice()`和`setPrice()`方法剪切并粘贴到以下`PriceTrait`特性中：
- en: '[PRE121]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, we have added the `PriceTrait` body with the `getPrice()` and `setPrice()`
    methods shifted from the `AbstractVehicle` class. Note that the methods still
    contain the original lines that use `$this` (the object instance variable), though,
    traits cannot be instantiated, meaning that these methods are intended to be accessed
    by the objects of classes that are going to use `PriceTrait`.
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了包含从`AbstractVehicle`类移除的`getPrice()`和`setPrice()`方法的`PriceTrait`特性体。请注意，这些方法仍然包含使用`$this`（对象实例变量）的原始行，尽管特性不能实例化，这意味着这些方法是为了被将要使用`PriceTrait`的类的对象访问而设计的。
- en: 'Now we need to require the `PriceTrait.php` file in the `AbstractVehicle` class,
    as follows, so that the `AbstractVehicle` class can use the trait:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在`AbstractVehicle`类中引入`PriceTrait.php`文件，如下所示，以便`AbstractVehicle`类可以使用该特性：
- en: '[PRE122]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Use `PriceTrait` from the `Vehicle` class, as follows:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Vehicle`类中使用`PriceTrait`，如下所示：
- en: '[PRE123]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Here, in the line `use PriceTrait`, the `AbstractVehicle` class acquired the
    `PriceTrait` trait that comes with two methods for price set and get. Hence, the
    `Car` and `Motorcycle` classes inherited these two methods, which was our intention,
    to add features horizontally like this. Note that we have kept the `$price` attribute
    intact at the `AbstractVehicle` class to access it via the setter and getter of
    the derived vehicles.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一行`use PriceTrait`中，`AbstractVehicle`类获取了包含两个价格设置和获取方法的`PriceTrait`特性。因此，`Car`和`Motorcycle`类继承了这两个方法，这正是我们的意图，以这种方式水平地添加功能。请注意，我们在`AbstractVehicle`类中保留了`$price`属性，以便通过派生车辆的设置器和获取器来访问它。
- en: 'There are no changes in the `Car` and `Motorcycle` subclasses as they should
    avail the trait methods automatically. As the parent `Vehicle` class uses `PriceTrait`,
    the trait methods become members of the `Vehicle` class and the subclasses can
    override such inherited methods. The `Car` class doesn''t override price methods
    but the `Motorcycle` class overrides the `getPrice()` method to apply a 5% discount
    to the given price. Locate the `getPrice()` method in the `Motorcycle` class:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Car`和`Motorcycle`子类没有变化，因为它们应该自动使用特性方法。由于父类`Vehicle`使用`PriceTrait`，特性方法成为`Vehicle`类的成员，子类可以覆盖这些继承的方法。`Car`类没有覆盖价格方法，但`Motorcycle`类覆盖了`getPrice()`方法，以对给定的价格应用5%的折扣。在`Motorcycle`类中定位`getPrice()`方法：'
- en: '[PRE124]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, after trait, such an override works for the subclass and no change should
    be required here.
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，特性之后的这种覆盖对子类有效，这里不需要进行任何更改。
- en: 'In order to test the discounted price, we should instantiate the `Motorcycle`
    class, set the price, and get the price to see whether a discount has been applied
    or not, which was previously done in `Motorcycle.php`. Locate the following content
    in the `Motorcycle.php` file:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试折扣价格，我们应该实例化`Motorcycle`类，设置价格，并获取价格以查看是否应用了折扣，这在之前的`Motorcycle.php`中已经完成。在`Motorcycle.php`文件中定位以下内容：
- en: '[PRE125]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, if we run `Motorcycle.php` with the `php Motorcycle.php` command, the
    preceding code outputs the following:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们用`php Motorcycle.php`命令运行`Motorcycle.php`，前面的代码将输出以下内容：
- en: '![Figure 5.26: The trait method overridden by Motorcycle'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26：由摩托车覆盖的特性方法'
- en: '](img/C14196_05_26.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_26.jpg)'
- en: 'Figure 5.26: The trait method overridden by Motorcycle'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：由摩托车覆盖的特性方法
- en: Therefore, traits can be used to add member methods of a class, can override
    any existing member methods of the same name, and can be overridden via inheritance.
    Alternatively, we could have used `PriceTrait` in the `Car` and `Motorcycle` classes
    directly instead of the `Vehicle` class by adding the trait in them. Our intention
    is to share the common characteristics of vehicles via the parent `Vehicle` class,
    that's why we have used the trait in the mother class.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，特性可以用来添加类的成员方法，可以覆盖任何同名的现有成员方法，并且可以通过继承来被覆盖。或者，我们也可以直接在`Car`和`Motorcycle`类中使用`PriceTrait`，而不是通过`Vehicle`类来添加特性。我们的意图是通过父类`Vehicle`共享车辆的共同特性，这就是为什么我们在母类中使用了特性的原因。
- en: Class Autoloading
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类自动加载
- en: You may skip this section if you choose to use Composer. Consider class auto
    loading for legacy PHP projects who can't use Composer.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用Composer，你可以跳过这一部分。考虑为无法使用Composer的旧版PHP项目进行类自动加载。
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With the addition of PHP's package manager, Composer, you can leverage Composer's
    autoloader to load classes, libraries, and so on. See [https://packt.live/2MrJG9u](https://packt.live/2MrJG9u)
    for more details. *Chapter 9*, *Composer* is dedicated to discussing **Composer**
    and **Autoloading** in detail.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PHP包管理器Composer的加入，你可以利用Composer的自动加载器来加载类、库等等。有关更多详细信息，请参阅[https://packt.live/2MrJG9u](https://packt.live/2MrJG9u)。第9章，*Composer*详细讨论了**Composer**和**自动加载**。
- en: To use a class inside a file that is located in another file, we have to include
    the corresponding file that contains the class in the current file. This approach
    ends up including a good number of files in any PHP script. Hence, we need something
    that automatically includes our required class files.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个文件中使用的类，我们必须在当前文件中包含包含该类的相应文件。这种方法最终会在任何PHP脚本中包含大量的文件。因此，我们需要某种自动包含所需类文件的东西。
- en: In order to load your class automatically, PHP comes with the `spl_autoload_register()`
    function. With that function, we can register any number of autoloaders so that
    we can load classes and interfaces on demand. Yes – on-demand. That means the
    autoloading is lazy – it loads the classes or interfaces only when they are called.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动加载你的类，PHP自带了`spl_autoload_register()`函数。使用该函数，我们可以注册任意数量的自动加载器，以便我们可以按需加载类和接口。是的——按需。这意味着自动加载是懒加载的——只有当它们被调用时才会加载类或接口。
- en: 'Check out the following simple code snippet:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下简单的代码片段：
- en: '[PRE126]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Preceding snippet is equivalent to the following:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段等同于以下：
- en: '[PRE127]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: So, in the preceding code snippet, you can see that we have passed an anonymous
    PHP function to the `spl_autoload_register()` function. This anonymous function
    accepts the class or interface name and tries to include/require the corresponding
    file. With the `spl_autoload_register` function, we can register our own such
    autoloader functions and we can do all sorts of operations to load the file, such
    as setting the file path/directory, checking whether the file exists or not, throwing
    an exception, and so on. Hence, we can avoid a larger list of file inclusion statements.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的代码片段中，你可以看到我们向`spl_autoload_register()`函数传递了一个匿名PHP函数。这个匿名函数接受类或接口名称，并尝试包含/要求相应的文件。使用`spl_autoload_register`函数，我们可以注册我们自己的这样的自动加载器函数，并且我们可以执行所有
    sorts 的操作来加载文件，例如设置文件路径/目录，检查文件是否存在，抛出异常等等。因此，我们可以避免一个较大的文件包含语句列表。
- en: 'Say, for `Car.php` and `Motorcycle.php`, we can just replace the following
    two lines with the `spl_autoload_register()` function:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`Car.php`和`Motorcycle.php`，我们可以用`spl_autoload_register()`函数替换以下两行：
- en: '[PRE128]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The preceding snippet can be replaced with the following:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段可以用以下代码替换：
- en: '[PRE129]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'So, like the following, when the `Car` class extends the `AbstractVehicle`
    class and implements the `DriveInterface` interface, the autoloader is invoked
    to load the corresponding class file and interface file:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如下所示，当`Car`类继承自`AbstractVehicle`类并实现`DriveInterface`接口时，自动加载器会被调用以加载相应的类文件和接口文件：
- en: '[PRE130]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here, the registered autoloader is invoked to load the file when the class or
    interface has been used.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当类或接口被使用时，注册的自动加载器会被调用以加载文件。
- en: Note
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To autoload PSR-4 classes, follow the guidelines at [https://packt.live/314fBCj](https://packt.live/314fBCj).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动加载PSR-4类，请遵循[https://packt.live/314fBCj](https://packt.live/314fBCj)上的指南。
- en: The `spl_autoload_register()` function specification can be found at [https://packt.live/2B1PLEu](https://packt.live/2B1PLEu).
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`spl_autoload_register()`函数的规范可以在[https://packt.live/2B1PLEu](https://packt.live/2B1PLEu)找到。'
- en: Namespaces
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: As the name suggests, a namespace provides naming and scoping, therefore, a
    namespace is another way of encapsulating items. We can call a named scope, a
    namespace can house related constants, functions, classes, abstract classes, traits,
    and interfaces in a group with a name, and they can be accessed using the name.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，命名空间提供了命名和作用域，因此，命名空间是封装项的另一种方式。我们可以调用命名作用域，命名空间可以包含具有名称的组中的相关常量、函数、类、抽象类、特质和接口，并且可以使用名称来访问它们。
- en: As an analogy, consider the naming of people. People are given unique names
    in a family in order to identify them and call them by. Beyond family, what if
    there are two people with the same name? There could be one John Doe in the computer
    science department and another John Doe in the electrical department. Coincidentally,
    they end up in the varsity's football team, so they can be called John Doe of
    computer science and John Doe of the electrical department. Surely, the team doesn't
    want to pass the football to the wrong John Doe.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类比，考虑人的命名。人在家庭中会被赋予独特的名字以便识别和称呼。在家庭之外，如果有两个人同名怎么办？在计算机科学系可能有一个John Doe，在电子工程系可能也有另一个John
    Doe。巧合的是，他们最终都加入了大学足球队，因此他们可以被称作计算机科学系的John Doe或电子工程系的John Doe。当然，球队不希望把足球传给错误的人。
- en: 'The same goes for computer filesystems: there are directories and subdirectories.
    Inside a directory, there could be other directories and there can''t be two directories
    with the same name. Again, files with the same name can exist in two different
    directories; for example, `/usr/home/readme.md` and `/var/projects/readme.md`.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于计算机文件系统：有目录和子目录。在一个目录内部，可以包含其他目录，但不能有两个同名目录。再次强调，同名文件可以存在于两个不同的目录中；例如，`/usr/home/readme.md`
    和 `/var/projects/readme.md`。
- en: In programming, a namespace solves problems such as name collisions where classes
    or libraries have the same name so that they can be utilized under a different
    name. Surely, we don't want to write a class that pollutes the global scope by
    conflicting with another class's name. Also, the namespace provides aliasing –
    we can shorten a long name, so that code readability improves.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，命名空间解决了诸如名称冲突等问题，其中类或库具有相同的名称，以便它们可以在不同的名称下使用。当然，我们不希望编写一个与另一个类的名称冲突而污染全局作用域的类。此外，命名空间提供了别名功能——我们可以缩短长名称，从而提高代码的可读性。
- en: 'PHP supports the namespace with the `namespace` keyword, as follows:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持使用`namespace`关键字声明命名空间，如下所示：
- en: '[PRE131]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The namespace should be the first statement you declare in your script. Although,
    you can write code without using a namespace.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间应该是您在脚本中声明的第一个语句。尽管如此，您可以在不使用命名空间的情况下编写代码。
- en: If we don't define a namespace, our code stays in the global namespace. That's
    why the global namespace can be easily polluted by producing name collisions.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不定义命名空间，我们的代码将保持在全局命名空间中。这就是为什么全局命名空间很容易被产生名称冲突所污染。
- en: 'Alternative syntax for declaring a namespace is as follows:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 声明命名空间的可选语法如下：
- en: '[PRE132]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We can declare multiple namespaces within a single file as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个文件中声明多个命名空间，如下所示：
- en: '[PRE133]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: It is strongly discouraged to put multiple namespaces into the same file in
    order to promote good coding practices. A general use case for an example of having
    multiple namespaces in the same file is including multiple PHP files in the same
    file.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈不建议在同一个文件中放置多个命名空间，以促进良好的编码实践。一个在同一个文件中放置多个命名空间的通用用例是包含多个PHP文件在同一个文件中。
- en: 'You can also declare subnamespaces to achieve a hierarchy of namespaces, as
    follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明子命名空间以实现命名空间的层次结构，如下所示：
- en: '[PRE134]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We can import a namespace using the `use` keyword and, optionally, we can alias
    the namespace with the `as` keyword as follows:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `use` 关键字导入命名空间，并且可以选择使用 `as` 关键字给命名空间起别名，如下所示：
- en: '[PRE135]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `file2.php` will be as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`file2.php` 将如下所示：'
- en: '[PRE136]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here, at the `use MyNamespaceA\MyClass as A;` line, `MyClass` and `MyNamespaceA`
    are imported inside `MyNamespaceB` and, while importing, we aliased the class
    name to `A` so that we can instantiate the `MyClass` class as class `A` with `$object
    = new A();`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `use MyNamespaceA\MyClass as A;` 行中，`MyClass` 和 `MyNamespaceA` 被导入到 `MyNamespaceB`
    中，并且在导入时将类名别名为 `A`，这样我们就可以将 `MyClass` 类实例化为类 `A`，即 `$object = new A();`。
- en: The same goes for other imports. We can import a function from another namespace,
    such as using the `MyNamespaceA\myFunction;` function and alias it by using the
    `MyNamespaceA\myFunction as func;` function.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他导入也是如此。我们可以从另一个命名空间导入一个函数，例如使用 `MyNamespaceA\myFunction;` 函数，并通过使用 `MyNamespaceA\myFunction
    as func;` 函数来给它起别名。
- en: That way, we can call the function using the `func()` alias name. Also, we can
    do the same while importing constants. With the `use const MyNamespaceA\MYCONST;`
    line, we have imported the constant.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用 `func()` 别名来调用函数。同样，在导入常量时也可以这样做。使用 `use const MyNamespaceA\MYCONST;`
    行，我们导入了常量。
- en: 'Combining multiple importing is also possible:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 组合多个导入也是可能的：
- en: '[PRE137]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Here, we have imported a class and a method together in the `use MyNamespaceA\MyClass
    as A, MyNamespaceA\myFunction;` line and aliased the class name as `A`. Normally,
    bringing in the necessary classes or functions from a namespace is the purpose
    of such importing instead of importing the whole namespace.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `use MyNamespaceA\MyClass as A, MyNamespaceA\myFunction;` 行中，我们同时导入了类和方法，并且将类名别名为
    `A`。通常，导入必要的类或函数从命名空间的目的就是这样的导入，而不是导入整个命名空间。
- en: PHP namespaces have so much to offer and there are more use cases and aspects
    that can be learned at [https://packt.live/2AYilqj](https://packt.live/2AYilqj).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 命名空间提供了很多功能，并且有更多用例和方面可以在 [https://packt.live/2AYilqj](https://packt.live/2AYilqj)
    学习。
- en: 'Exercise 5.12: Implementing Namespaces'
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.12：实现命名空间
- en: 'In this exercise, we will apply namespaces to our vehicle-related classes,
    traits, and interfaces. We will apply a common namespace to the `AbstractVehicle`
    class, `DriveInterface`, `Car`, and `Motorcycle` classes. Also, for the traits,
    we will apply a different namespace so that we can keep the traits out of the
    common namespace:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将将命名空间应用到我们的与车辆相关的类、特性和接口中。我们将对 `AbstractVehicle` 类、`DriveInterface`、`Car`
    和 `Motorcycle` 类应用一个公共命名空间。对于特性，我们将应用不同的命名空间，以便我们可以将特性保持在与公共命名空间分开的状态：
- en: Create a `Vehicle` directory to relocate `AbstractVehicle.php` and `DriveInterface.php`
    in it.
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Vehicle` 目录来将 `AbstractVehicle.php` 和 `DriveInterface.php` 移动到其中。
- en: Relocate `AbstractVehicle.php` and `DriveInterface.php` in the vehicle subdirectory,
    under your current working directory.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AbstractVehicle.php` 和 `DriveInterface.php` 移动到当前工作目录下的车辆子目录中。
- en: Create another directory, `Traits`, for relocating the `PriceTrait.php` file
    and future traits.
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个目录 `Traits` 来移动 `PriceTrait.php` 文件和未来的特性。
- en: 'The directory structure looks like the following:'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目录结构如下所示：
- en: '![Fig 5.27: Namespaced directory structure'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.27：命名空间目录结构'
- en: '](img/C14196_05_27.jpg)'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_27.jpg)'
- en: 'Fig 5.27: Namespaced directory structure'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.27：命名空间目录结构
- en: 'Now it''s time to apply namespaces to our classes and traits. Open the `PriceTrait.php`
    file and add the `Traits` namespace at the beginning, as follows:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将命名空间应用到我们的类和特性中了。打开 `PriceTrait.php` 文件并在开头添加 `Traits` 命名空间，如下所示：
- en: '[PRE138]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here, we have declared the `Traits` namespace at the beginning of `PriceTrait`.
    Our intention is to add different trait files in future, under the same namespace;
    for example, `namespace Traits` (at the beginning of any new trait files). The
    whole idea is to apply the `Traits` namespace across multiple trait files so that
    we can pick the right trait via the namespace. Hence, we can use `PriceTrait`
    like we use `\Traits\PriceTrait` in different classes.
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们在 `PriceTrait` 的开头声明了 `Traits` 命名空间。我们的目的是在将来，在同一个命名空间下添加不同的特性文件；例如，`namespace
    Traits`（在任意新的特性文件的开头）。整个想法是将 `Traits` 命名空间应用到多个特性文件中，这样我们就可以通过命名空间选择正确的特性。因此，我们可以像使用
    `\Traits\PriceTrait` 一样使用 `PriceTrait`。
- en: 'Open the `AbstractVehicle.php` file and remove the following line:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AbstractVehicle.php` 文件并删除以下行：
- en: '[PRE139]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Since we are going to autoload the classes and trait files, we don't need to
    manually require files.
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们将自动加载类和特性文件，我们不需要手动要求文件。
- en: 'Add the following namespace before the `AbstractVehicle` class:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AbstractVehicle` 类之前添加以下命名空间：
- en: '[PRE140]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, the `Vehicle` namespace will be our common namespace to share across vehicle
    subclasses and interfaces.
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Vehicle` 命名空间将成为我们在车辆子类和接口之间共享的公共命名空间。
- en: 'Update the `use PriceTrait` using the namespace, as follows:'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名空间更新 `use PriceTrait`，如下所示：
- en: '[PRE141]'
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, the `use \Traits\PriceTrait;` line tells the autoloader to load `PriceTrait`
    from the `Traits` directory located in your code base root.
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`use \Traits\PriceTrait;` 行告诉自动加载器从位于代码库根目录的 `Traits` 目录加载 `PriceTrait`。
- en: 'Add the `Vehicle` namespace before the `DriveInterface` interface, as follows:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DriveInterface` 接口之前添加 `Vehicle` 命名空间，如下所示：
- en: '[PRE142]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Here, `DriveInterface` shares the `Vehicle` namespace, so the interface is accessible
    via the same namespace.
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`DriveInterface` 与 `Vehicle` 命名空间共享，因此可以通过相同的命名空间访问该接口。
- en: 'Open the `Car.php` file to eliminate the following manual file inclusion:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Car.php` 文件以消除以下手动文件包含：
- en: '[PRE143]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Replace the `Vehicle` namespace with the following:'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `Vehicle` 命名空间替换为以下内容：
- en: '[PRE144]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Here, `Car` shares the same namespace, `Vehicle`. So, in the class line, `Car`
    extends `AbstractVehicle` and implements `DriveInterface`, `AbstractVehicle`,
    and `DriveInterface` to resolve the current namespace, which is `Vehicle`. This
    is similar to the `Car` class extending to `Vehicle\AbstractVehicle` and implementing
    `Vehicle\DriveInterface`.
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Car` 与 `Vehicle` 具有相同的命名空间。因此，在类行中，`Car` 继承自 `AbstractVehicle` 并实现了 `DriveInterface`、`AbstractVehicle`
    和 `DriveInterface`，以解决当前的命名空间 `Vehicle`。这与 `Car` 类继承自 `Vehicle\AbstractVehicle`
    并实现 `Vehicle\DriveInterface` 相似。
- en: 'Now, add the `spl_autoload_register()` function before the `Car` class as follows:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Car` 类之前添加 `spl_autoload_register()` 函数，如下所示：
- en: '[PRE145]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Hence, the autoloader function should load the `AbstractVehicle` class and the
    `DriveInterface` interface from the `Vehicle` directory as it supports class loading
    from a namespaced directory.
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，自动加载函数应从 `Vehicle` 目录加载 `AbstractVehicle` 类和 `DriveInterface` 接口，因为它支持从命名空间目录加载类。
- en: 'Do the same for the `Motorcycle.php`, as follows:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Motorcycle.php` 也进行相同的操作，如下所示：
- en: '[PRE146]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Here, the `Motorcycle` class also shares the same namespace, `Vehicle`, to avail
    `AbstractVehicle` and `DriveInterface`.
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Motorcycle` 类也共享相同的命名空间 `Vehicle`，以便使用 `AbstractVehicle` 和 `DriveInterface`。
- en: 'At `Car.php`, add the following `Car` instance to test the `AbstractVehicle`
    and `DriveInterface` implementation:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Car.php` 中，添加以下 `Car` 实例以测试 `AbstractVehicle` 和 `DriveInterface` 的实现：
- en: '[PRE147]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Here, just to test the extended class and the implemented interface, we have
    instantiated the `Car` class and accessed different member methods using the object
    handler.
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，为了测试扩展类和实现接口，我们实例化了 `Car` 类，并使用对象处理程序访问不同的成员方法。
- en: 'The preceding code will produce the following output if we run the `Car.php`
    script with the `php Car.php` command:![Fig 5.28: Namespace applied to Car'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用 `php Car.php` 命令运行前面的 `Car.php` 脚本，将产生以下输出：![图 5.28：应用于 Car 的命名空间
- en: '](img/C14196_05_28.jpg)'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_05_28.jpg)'
- en: 'Fig 5.28: Namespace applied to Car'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.28：应用于 Car 的命名空间
- en: We can see that the `Car` class can access the namespace applied to the abstract
    class and the interface.
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到 `Car` 类可以访问应用于抽象类和接口的命名空间。
- en: 'Now, to `Motorcycle.php`, add the following `Motorcycle` instance to test the
    `AbstractVehicle` and `DriveInterface` implementation:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下 `Motorcycle` 实例添加到 `Motorcycle.php` 中以测试 `AbstractVehicle` 和 `DriveInterface`
    的实现：
- en: '[PRE148]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The preceding code will produce the following output if we run the `Motorcycle.php`
    script with the `php Motorcycle.php` command:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行 `Motorcycle.php` 脚本并使用 `php Motorcycle.php` 命令后，前面的代码将产生以下输出：
- en: '![Fig 5.29: Namespace applied to Motorcycle'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.29：应用于 Motorcycle 的命名空间'
- en: '](img/C14196_05_29.jpg)'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_29.jpg)'
- en: 'Fig 5.29: Namespace applied to Motorcycle'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29：应用于 Motorcycle 的命名空间
- en: In the preceding exercise, we saw that the `Vehicle` namespace encapsulated
    all the relevant items, such as the abstract class, the interface, and the subclasses.
    Thus, a namespace can be shared across multiple files among relevant code components.
    Also, we can subnamespace internal libraries, plugins, utility files, and so on.
    The idea of the namespace is to assemble your project under a unique and relevant
    name so that none of your code components conflict when you integrate third-party
    code components.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们看到了 `Vehicle` 命名空间封装了所有相关项，例如抽象类、接口和子类。因此，命名空间可以在多个文件的相关代码组件之间共享。此外，我们还可以在内部库、插件、实用文件等中创建子命名空间。命名空间的想法是将你的项目组织在一个独特且相关的名称下，这样在集成第三方代码组件时，你的代码组件不会发生冲突。
- en: 'Activity 5.1: Building a Student and Professor Object Relationship'
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第 5.1 部分：构建学生和教授对象关系
- en: In this activity, we will implement OOP concepts to create `Student` and `Professor`
    classes with parameterized constructors, attributes, and member methods. We will
    instantiate both classes and establish a relationship between the objects. A professor
    might have a certain number of students enrolled in their class. The list of students
    should be printed using a member method of the `Professor` object.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现 OOP 概念，创建具有参数化构造函数、属性和成员方法的 `Student` 和 `Professor` 类。我们将实例化这两个类，并在对象之间建立关系。教授可能在其课程中有一定数量的注册学生。应使用
    `Professor` 对象的成员方法打印学生列表。
- en: 'The steps to be performed are as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行的操作如下：
- en: Create a directory named `activity1` to put all our activity content in it.
    This should be our working directory (you can `cd` to the directory).
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `activity1` 的目录，将所有活动内容放入其中。这应该是我们的工作目录（你可以使用 `cd` 命令进入该目录）。
- en: Create a script file called `activity-classes.php`.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `activity-classes.php` 的脚本文件。
- en: Create `Professor` and `Student` classes in separate directories with the following
    functionalities.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的目录中创建 `Professor` 和 `Student` 类，并具有以下功能。
- en: Both use their own namespacing to load the classes automatically.
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两者都使用自己的命名空间自动加载类。
- en: Both take the name as the first argument in the constructor; the `Professor`
    class accepts the second argument as a list of students – the list will be filtered
    for instances of `Student` only.
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个类都将名称作为构造函数的第一个参数；`Professor` 类接受第二个参数作为学生列表 – 列表将仅过滤 `Student` 实例。
- en: Both will have the title property, which, by default, for the `Professor` class
    is `Prof.` and for the `Student` class is `student`.
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两者都将具有标题属性，对于 `Professor` 类默认为 `Prof.`，对于 `Student` 类默认为 `student`。
- en: Create a function that will print the Professor's title, name, the student count,
    and the list of students.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于打印教授的标题、姓名、学生数量和学生列表。
- en: Create a `Professor` instance, providing a name and a list of students – instances
    of `Student` with a name in the constructor.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Professor` 实例，提供一个名称和学生列表 – 构造函数中的 `Student` 实例具有名称。
- en: Add a random amount of `Student` instances to the `Professor` instance.
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Professor` 实例添加一定数量的 `Student` 实例。
- en: Change the title of the professor to `Dr.`.
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将教授的标题更改为 `Dr.`。
- en: Print the output by invoking the function with the `Professor` instance.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用函数并使用 `Professor` 实例来打印输出。
- en: 'The output should look like the following:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE149]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 515.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 515 页找到。
- en: Summary
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked with object-oriented concepts and took note of how
    each of those concepts fitted into different scenarios. Encapsulation, inheritance,
    polymorphism, data abstraction, dynamic binding, and message passing all added
    new dimensions to our program. Note that these concepts can be adopted when they
    fit your particular scenario; until then, there's no need to complicate the program.
    We have seen that the misuse of OOP principles is common, and, down the road,
    that adds a burden of complexity.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了面向对象的概念，并注意到了每个概念如何适应不同的场景。封装、继承、多态、数据抽象、动态绑定和消息传递都为我们的程序增添了新的维度。请注意，当这些概念适合你的特定场景时，可以采用它们；在此之前，没有必要使程序复杂化。我们已经看到，OOP
    原则的误用很常见，而且将来这会增加复杂性的负担。
- en: 'Dependencies should be injected from outside rather than being hardcoded inside.
    Abstractions should not depend on details; hide your data appropriately, hide
    your complexities, and expose simplicity when message passing. Overall, the mapping
    of the objects in your program with the problem domain should be taken care of.
    Remember this simple statement: "If you can''t reuse it, then it doesn''t possess
    value."'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项应从外部注入，而不是在内部硬编码。抽象不应依赖于细节；适当地隐藏你的数据，隐藏你的复杂性，并在消息传递时展示简单性。总的来说，应负责将程序中的对象与问题域进行映射。请记住这个简单的陈述：“如果你不能重用它，那么它就没有价值。”
- en: In the next chapter, we will describe request handling, storing local data,
    and file uploads.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述请求处理、存储本地数据和文件上传。
