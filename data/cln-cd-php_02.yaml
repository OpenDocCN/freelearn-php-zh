- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Who Gets to Decide What “Good Practices” Are?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁有权决定“良好实践”是什么？
- en: Good practices are great but knowing who decides them and where they come from
    is better. It is no secret that when you fully understand what you are doing,
    you immediately feel better and more comfortable. The same thing applies to good
    practices. Why should you believe without question these precepts decided by people
    you do not know and who have never collaborated with you on your project?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践固然很好，但了解谁决定它们以及它们从何而来则更为重要。当你完全理解自己在做什么时，你会立刻感到更好、更自在，这一点同样适用于良好的实践。你为何要无条件的相信那些你并不了解且从未与你合作过的人所决定的这些原则呢？
- en: You could say that the people dictating these principles have more experience
    than you and know this world better than you do. Two things. First, maybe one
    day you will have more experience than they do. Maybe you will be better. Maybe
    you already are. Second, years of experience are not everything. It is common
    to see developers with 20 or 30 years of experience who are completely out of
    date or with habits from the last century. Years of experience can be an argument,
    but not the only one. Computing evolves at an exceptional speed, and the web world
    is even more affected by this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，制定这些原则的人比你有更多经验，并且比你更了解这个世界。两点。首先，也许有一天你的经验会比他们多。也许你会做得更好。也许你已经做到了。其次，多年的经验并非一切。我们经常看到有20年或30年经验的开发者，他们完全过时或有着上个世纪的习惯。多年的经验可以是一个论据，但不是唯一的论据。计算机发展速度极快，而网络世界更是受到这种影响。
- en: 'We’re going to see together in this chapter where best practices have originated
    from: were they really invented and decided by a precise group of people? What
    are the different existing clean-code principles that you can already apply to
    your projects starting from now? Your way of thinking might change once you know
    them.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起探讨最佳实践的起源：它们真的是由一个精确的小组发明和决定的吗？你现在就可以应用到你的项目中的不同现有清洁代码原则有哪些？一旦你了解了它们，你的思维方式可能会改变。
- en: 'Here are the main topics we’ll cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要主题如下：
- en: Who decides these things anyway?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁来决定这些事情呢？
- en: Best practices—where do they really come from?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践——它们真正从何而来？
- en: Being context-aware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持情境意识
- en: Being consistent—get results quicker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持一致性——更快地获得结果
- en: Who decides these things anyway?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁来决定这些事情呢？
- en: 'One thing we are going to see is that you should always question “good practices”
    and never consider them as a general truth that you must respect without understanding
    why. One excellent way to improve yourself is to ask every time you do not agree
    with someone’s review or point of view. Developers are fascinating as they can
    find unlimited ways to solve a single problem—unlimited solutions for the same
    result. Even if this can be seen as something a bit tiring sometimes, it is always
    interesting to understand why a developer wants to solve a problem in a different
    way than you. There are multiple goals to this, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的一点是，你应该始终质疑“良好实践”，永远不要将它们视为一个你必须尊重而不理解其为何的普遍真理。当你不同意某人的评审或观点时，询问是一个提升自己的极好方式。开发者们非常迷人，因为他们可以找到无限种解决同一个问题的方法——为同一个结果提供无限种解决方案。即使这有时可能看起来有点累人，但了解为什么开发者想要以与你不同的方式解决问题总是很有趣的。这有几个目标，如下所示：
- en: '**You will improve your communication skills**: If you want to communicate
    and be understood, you will have to explain your problem clearly.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你会提高你的沟通技巧**：如果你想进行沟通并被理解，你必须清楚地解释你的问题。'
- en: '**You may learn new ways of doing things**: We are all using the same language,
    but we all have different experiences with it. These different career and life
    paths can bring terrific ideas to the table.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可能会学习到做事的新方法**：我们都在使用同一种语言，但我们每个人都有不同的使用经验。这些不同的职业和生活道路可以为会议带来极好的想法。'
- en: You are reinforcing your relationship with this developer, which will make it
    easier to discuss further subjects in the future.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在加强与这位开发者的关系，这将使得未来讨论更多主题变得更加容易。
- en: You are improving your teamwork skills and all the participants in the conversation
    are improving their skills, respectively.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在提高你的团队合作技能，并且对话中的所有参与者都在相应地提高他们的技能。
- en: That is a pretty long list. A lot of soft skills are improved just by discussing
    with other developers a way to solve a given problem. Being able to explain a
    situation clearly is way harder than it seems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个相当长的列表。许多软技能仅仅通过与其他开发者讨论解决特定问题的方法就能得到提升。能够清楚地解释一个情况比看起来要困难得多。
- en: 'And this is also why you should always ask for further explanation when you
    disagree with someone. First, there can be a misunderstanding about the exposed
    problem. This is a common situation where multiple parties are disagreeing: the
    problem was not clear at first. Each party is trying to justify what they understood.
    You can easily imagine the mess it brings.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么你应该总是在你不同意某人的观点时要求进一步解释的原因。首先，可能存在对暴露问题的误解。这是一个常见的多方面意见不一致的情况：问题一开始并不明确。每个方面都在试图证明他们理解的内容。你可以很容易地想象这会带来多大的混乱。
- en: 'Being a good developer is (also) being able to justify and explain all your
    choices. No more: “We always made things like this; there are no other reasons
    to do it this way.” When you are deciding or telling someone to follow some guidelines,
    you must always be able to justify and explain clearly why your way is the best
    for you. It may not be the best way to do it objectively, but if you are able
    to explain why it is best suited to you, it will make you look way more open-minded.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 成为一名优秀的开发者（也）意味着能够证明和解释你所有的选择。不再有：“我们总是这样做；没有其他理由这样做。”当你决定或告诉某人遵循某些指南时，你必须始终能够清楚地证明和解释为什么你的方式对你来说是最好的。这可能不是客观上做这件事的最佳方式，但如果你能够解释为什么它最适合你，这将使你看起来更加开放。
- en: 'That being said, you may now understand where we are going with this: no one
    holds the absolute truth. If someone is confident enough to say so, you should
    always be careful.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你现在可能已经明白我们想要表达的意思了：没有人掌握绝对的真理。如果有人足够自信地说出这一点，你应该始终保持警惕。
- en: Best practices – where do they really come from?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践——它们真正来自哪里？
- en: 'When we are talking about “best practices," we can differentiate three cases,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论“最佳实践”时，我们可以区分三种情况，如下所示：
- en: '**Principles that have been proven for decades to work, which also are deduced
    from common sense**: In this category, we can—for example—find design patterns.
    In short and if you do not know them, these are tools that fix recurrent programming
    problems. They have been here for decades and are known by millions of developers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经过几十年证明有效的原则，这些原则也源于常识**：在这个类别中，例如我们可以找到设计模式。简而言之，如果你不知道它们，这些是解决重复编程问题的工具。它们已经存在了几十年，并且被数百万开发者所熟知。'
- en: '**Choices made because we had to make them**: Here, we can find things such
    as code style, naming conventions, and so on. Technically, it does not matter
    if you would like to use *camelCase* or *snake_case* to name your files. But if
    everyone is following the same rule, it is easier for everybody to understand
    each other.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因为我们不得不做出的选择**：在这里，我们可以找到诸如代码风格、命名约定等等。从技术上讲，如果你想要使用*camelCase*或*snake_case*来命名你的文件，这并不重要。但如果每个人都遵循相同的规则，那么每个人理解彼此会更容易。'
- en: '`get`, `set`, `is`, and so on. If everyone has their own rules about naming
    accessors and mutators, you can be sure that someday and without warning, things
    will blow out.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`、`set`、`is`等等。如果每个人都对命名访问器和修改器有自己的规则，你可以确信总有一天，没有任何警告，事情会失控。'
- en: Design pattern principles
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式原则
- en: The design patterns case describes objective solutions to solve problems. You
    can dislike them and how the code is being organized by them but cannot say that
    they are objectively bad. Because your thoughts on them do not matter, they work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式案例描述了解决问题的客观解决方案。你可能不喜欢它们以及它们如何组织代码，但你不能说它们在客观上是不好的。因为你的想法并不重要，它们是有效的。
- en: 'Talking about principles that have been present for decades, we can highlight
    four famous ones: **DRY**, **KISS**, **YAGNI**, and **SOLID**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了几十年一直存在的原则，我们可以突出四个著名的：**DRY**、**KISS**、**YAGNI**和**SOLID**。
- en: DRY
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DRY
- en: '**DRY** stands for **Don’t Repeat Yourself**. This principle simply states
    that you should never have, in your application, two authorities doing the very
    same thing. It may sound obvious, but applying this may not always be a reflex,
    especially when you are new to application programming. Having the same responsibility
    at two separate places in your code means maintaining those two places every time
    you fix something. It means having to think about these two places at each change
    (and someday, you are going to forget one, for sure). Also, how is any developer
    maintaining your source code supposed to know which one to use if two things have
    the same responsibility?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**代表**不要重复自己**。这个原则简单地说，你永远不应该在你的应用程序中有两个权限做完全相同的事情。这听起来可能很显然，但应用这个原则可能并不总是本能的，尤其是当你刚开始应用编程时。在代码的两个不同地方有相同的责任意味着每次你修复某事时都要维护这两个地方。这意味着每次更改时都必须考虑这两个地方（而且肯定有一天你会忘记其中一个）。此外，如果两件事有相同的责任，任何开发者如何维护你的源代码才能知道该使用哪一个呢？'
- en: KISS
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KISS
- en: '**KISS** stands for **Keep It Simple, Stupid**. Sometimes, we complicate our
    lives. We can see two main reasons for this, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**KISS**代表**保持简单，傻瓜**。有时，我们会使自己的生活复杂化。我们可以看到有两个主要原因，如下：'
- en: First, we try to do complicated things with our code, but these stunts do not
    bring anything valuable and complicate the code. We will see later in this book
    in detail why we absolutely need to avoid this.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们试图用我们的代码做复杂的事情，但这些花招并没有带来任何有价值的东西，反而使代码复杂化。我们将在本书的后面详细说明为什么我们绝对需要避免这样做。
- en: The second reason is a lack of perspective on what we are doing. We have spent
    many hours trying to solve something, and we are too much “into it." Some rest
    is necessary to get this perspective and, sometimes, start it all over again.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是缺乏对我们所做的事情的视角。我们花费了很多小时试图解决问题，我们太“投入”了。一些休息是必要的，以获得这种视角，有时甚至需要从头开始。
- en: Both cases are recurrent and prevent us from going straight to the point and
    keeping things simple. When you feel you are going “too far," think of this acronym
    to get back on the rails.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都是常见的，阻止我们直接切入要点并保持简单。当你觉得你“走得太远”时，想想这个缩写词，以便回到正轨。
- en: YAGNI
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAGNI
- en: '**YAGNI** stands for **You Aren’t Gonna Need It**. In some way, it goes hand
    in hand with the KISS principle. It is quite common (not to say part of our daily
    lives as developers) to want to find a solution to a problem by thinking about
    the future. Indeed, we regularly have this thought: “If tomorrow I need to do
    such and such a thing, at least this will already be in place.” The reality is
    that, in general, no—we will never have the need that we want to try to foresee.
    Then, by trying to get ahead of a task that may never exist and whose functional
    constraints are unknown, not only do we waste time, but we also complicate our
    lives by thinking too far ahead. We move away from our initial goal, which is
    to find a quick, viable, and robust solution.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI**代表**你不需要它**。在某种程度上，它与KISS原则相辅相成。想要通过考虑未来来找到问题的解决方案是很常见的（不用说，这是开发者日常生活的部分），我们经常有这样的想法：“如果明天我需要做这样或那样的事情，至少这已经准备好了。”现实是，总的来说——不会——我们永远不会需要我们想要预见的需求。然后，试图提前完成一个可能永远不存在的任务，并且其功能约束是未知的，不仅浪费时间，而且通过过于前瞻性的思考使我们的生活复杂化。我们偏离了最初的目标，即找到快速、可行和健壮的解决方案。'
- en: We are not psychic, and we cannot know all the problems that will appear if
    the task we predicted appears. You will quickly realize that if you keep things
    simple and without superfluous additions to try to get ahead of the game for the
    next day, you will have a healthy, no-frills code base. This means a faster understanding
    of the code, greater ease in navigating through it, and making changes when they
    are really needed. Plus, you will probably save yourself a lot of bugs. It is
    always complicated (if not impossible) to justify that a bug was made in your
    source code because you developed and spent time on something that was not asked
    of you. If your job as a developer requires you to collaborate directly with the
    customer, you should know that the customer will not pay you for something they
    did not ask for. You will have worked for free, which is never ideal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是先知，无法预知预测的任务会出现所有问题。你很快就会意识到，如果你保持简单，不添加任何多余的代码来试图领先于明天的需求，你将拥有一个健康、无装饰的代码库。这意味着更快地理解代码，更容易在其中导航，并在真正需要时进行更改。此外，你可能会节省很多错误。如果因为你在源代码中开发并花费时间在未要求的事情上而造成错误，那么总是很复杂（如果不是不可能的话）来证明这个错误。如果你的工作作为开发者需要你直接与客户合作，你应该知道客户不会为你没有要求的事情付钱。你将免费工作，这从来不是理想的情况。
- en: '**Caution**: It is obviously necessary to take this on a per-case basis. We
    can take as an example *magic numbers*. Magic numbers are constant values, mainly
    numbers, hardcoded and without any explanation of their meaning.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：显然，我们必须根据每个案例来处理。我们可以以*魔法数字*为例。魔法数字是常量值，主要是数字，硬编码且没有任何解释其含义。'
- en: '**Verdict**: Two weeks later, everyone has forgotten what this number corresponds
    to. We will then think of using well-named code constants. However, there is a
    huge chance that the value of this code constant will never change because the
    needs would have changed. At first sight, it would be strange to want to declare
    a constant to use it everywhere. The purpose of code constants is to add semantics
    to fixed values and allow us to easily change that value everywhere it is used
    in the code, at once. This is, in a sense, contrary to YAGNI (since these values
    will probably never change).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：两周后，每个人都忘记了这个数字代表什么。然后我们会考虑使用命名良好的代码常量。然而，有很大可能性这个代码常量的值永远不会改变，因为需求已经发生了变化。乍一看，想要声明一个常量并在所有地方使用它似乎很奇怪。代码常量的目的是为固定值添加语义，并允许我们轻松地在代码中任何使用该值的地方一次性更改它。这在某种程度上与YAGNI原则相悖（因为这些值可能永远不会改变）。'
- en: However, we can see the value of using constants. Perspective and reflection
    are always necessary, whatever the clean-code principles applied.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以看到使用常量的价值。无论应用了哪些清洁代码原则，视角和反思总是必要的。
- en: SOLID
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOLID
- en: 'Finally, maybe the most famous one, **SOLID**. Let’s see what these letters
    stand for:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可能是最著名的一个，**SOLID**。让我们看看这些字母代表什么：
- en: '**S** stands for **single-responsibility principle** (often abbreviated to
    **SRP**). Very simply, it means that a class in your code must respond to only
    one task. Obviously, the size of that task is the key point here. We are not talking
    about creating a class with only one available method. Rather, we are talking
    about creating a logical breakdown. A very concrete example is the **model-view-controller**
    (**MVC**) architecture. The important thing to remember is that you must avoid
    having catch-all classes, grouping together database operations, **Hypertext Markup
    Language** (**HTML**) rendering, business logic, and so on. The breakdown must
    be logical. An example of a breakdown could be a class for generating HTML, a
    class for database interactions for a given object, and so on.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S** 代表 **单一职责原则**（通常缩写为 **SRP**）。非常简单地说，这意味着你的代码中的类必须只响应一个任务。显然，这个任务的大小是这里的关键点。我们不是在谈论创建一个只有一个可用方法的类。而是在谈论创建一个逻辑分解。一个非常具体的例子是
    **模型-视图-控制器**（**MVC**）架构。重要的是要记住，你必须避免有万能的类，将数据库操作、**超文本标记语言**（**HTML**）渲染、业务逻辑等组合在一起。分解必须是逻辑的。分解的一个例子可以是用于生成HTML的类，用于特定对象的数据库交互的类，等等。'
- en: '`if` and `else` statements. Indeed, if you use conditional branching, you incur
    a modification of the class, and this can quickly become unmanageable if you have
    more than two cases. By extending a class and overloading the methods you are
    interested in, you get concise code, well broken up and without branching of several
    hundred lines.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`和`else`语句。确实，如果你使用条件分支，你将修改类，如果你有超过两个情况，这可能会很快变得难以管理。通过扩展类并重载你感兴趣的方法，你可以得到简洁的代码，很好地分割，并且没有数百行的分支。'
- en: '`foo` method and another implementation returns an object, it will be complicated).
    Fortunately, the typing of return values exists in recent versions of PHP, limiting
    the possibilities of violation of this principle.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`foo`方法和另一个实现返回一个对象，这将变得复杂）。幸运的是，返回值的类型在PHP的最新版本中存在，限制了违反此原则的可能性。
- en: '`null` value. When you put it like that, you realize that it does not sound
    like very "clean code."'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`值。当你这样表达时，你会意识到这听起来并不像非常“干净的代码”。'
- en: Finally, `MailerInterface` interface. You will then have one implementation
    per mail service. By typing the argument with the interface, the method will be
    able to receive any implementation and use the right email service for your case.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是`MailerInterface`接口。这样，你将为每种邮件服务有一个实现。通过使用接口的参数，该方法能够接收任何实现，并为你当前的情况使用正确的电子邮件服务。
- en: We can quickly realize that these principles are very much linked. They work
    together, and they allow a strong decoupling, a strong separation of responsibilities,
    and a fluid thinking when you have these principles in mind while writing code.
    It can be extremely helpful to remember these principles; at least, it is a particularly
    good thing to know their existence. Apart from the SOLID principle, you can see
    that KISS, DRY, and YAGNI are pretty common-sense and logical. Remembering them
    from time to time can be beneficial and can help us to put up barriers when we
    get a little off track.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很快地意识到这些原则之间有着非常紧密的联系。它们共同工作，并在你编写代码时考虑到这些原则，允许有强大的解耦、责任分离和流畅的思维。记住这些原则可能非常有帮助；至少，了解它们的存在是一个特别好的事情。除了SOLID原则外，你还可以看到KISS、DRY和YAGNI都是非常直观和逻辑的。时不时地记住它们可能有益，并有助于我们在稍微偏离轨道时设置障碍。
- en: Bonus – Scouts’ principle
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奖励 - 指导员原则
- en: Something that can also be added, which is also a common-sense principle, is
    the “Scouts’ principle." We all know those groups of young people and teenagers
    that act with a benevolent purpose and show a great deal of altruism. The Scouts
    go camping in the woods, build a fire, and spend the night there. Once they get
    up in the morning, they might put out the fire and put away their stuff, but most
    of all, they clean up the place to make it cleaner than it was before they arrived
    (at least, in theory).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以添加的是，这也是一个常识性原则，即“指导员原则”。我们都知道那些有善意的年轻人和青少年群体，他们表现出极大的利他主义。指导员在树林里露营，生火，并在那里过夜。一旦他们早上起床，他们可能会熄灭火焰并收拾东西，但最重要的是，他们会清理这个地方，使其比他们到来之前更干净（至少，在理论上）。
- en: As a developer, it is the same. Be a Scout. When exploring and browsing the
    code, if time and context allow, it is often a particularly clever idea to clean
    up where you see some technical debt. If you are going through places in the code
    base and think “this is really bad," maybe this is an opportunity to make it more
    manageable and cleaner. If everyone gets on board, the quality of the project’s
    source code can rise very quickly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，情况也是一样的。成为一名指导员。在探索和浏览代码时，如果时间和环境允许，清理你看到的一些技术债务通常是一个特别聪明的想法。如果你正在遍历代码库中的地方，并想“这真的很糟糕”，这可能是一个机会使其更易于管理和更干净。如果每个人都参与进来，项目的源代码质量可以迅速提高。
- en: Of course, this “Scouts’ principle” must be done in accordance with your project
    constraints, time constraints, and customer needs. Moreover, it is quite risky,
    and you must know when to stop. When you send your changes to your team for review,
    the changes and cleanup you have done must be consistent. You do not want to rewrite
    half the application every time you find a little thing, which leads to another,
    then another, and so on. It’s more about cleaning up the things that are relevant
    to what you’re doing. It can be extremely complicated to stay focused and fixed
    on your context. There is no genuine answer to “when to stop”; it will depend
    a lot on the time you have and your task. However, there is nothing to stop you
    from writing down things that you want to come back to but that unfortunately
    were not related to what you were doing, that seemed too energy- and time-consuming,
    or that simply require further reflection with the team.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个“童子军原则”必须符合你的项目约束、时间约束和客户需求。此外，这相当有风险，你必须知道何时停止。当你将你的更改发送给团队进行审查时，你所做的更改和清理必须保持一致。你不想每次发现一点小问题就重写一半的应用程序，这会导致另一个问题，然后又是另一个，以此类推。这更多的是关于清理与你所做事情相关的事情。保持专注并固定在你的环境中可能会非常复杂。关于“何时停止”没有真正的答案；这将很大程度上取决于你拥有的时间和你的任务。然而，没有什么可以阻止你写下你想要回来但不幸地与你的工作无关的事情，这些事情似乎太耗费精力和时间，或者需要与团队进行进一步的反思。
- en: On the opposite side, code style, naming conventions, and similar things are
    subject to tastes and habits. Everyone has their own tastes and habits, so decisions
    need to be made. As we discussed earlier, it is so much easier to talk together
    when we all follow the same rules.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，代码风格、命名约定和类似的事情都是主观的，取决于个人品味和习惯。每个人都有自己的品味和习惯，所以需要做出决定。正如我们之前讨论的，当我们都遵循相同的规则时，一起讨论要容易得多。
- en: So, who decides these best practices in a team or an organization? Well, generally,
    it is a consensus after lengthy discussions about the subject at the beginning
    of a project. Because yes—“best practices” are not something that you can always
    apply everywhere, and you should be aware of this. You should be aware of the
    context you are in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁决定团队或组织中的最佳实践呢？嗯，通常情况下，这是在项目开始时关于该主题长时间讨论后的共识。因为是的——“最佳实践”并不是你可以在任何地方都适用的东西，你应该意识到这一点。你应该意识到你所处的环境。
- en: Being context-aware
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持情境意识
- en: 'Here, we enter one of the most important parts when we talk about clean code.
    If there were only one thing to remember, it would be this. We may regularly talk
    about the rules defined by other developers, object principles, and the principles
    of clean code, but nothing will ever be as good as what we are going to talk about
    here: it is about being aware of your context. One thing that is missing from
    many books and articles about clean code is the feeling that it is relevant to
    everyday life. A developer’s life is made up of unexpected events, technical constraints,
    impossibilities to do some things, or being forced to do some other things.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论清洁代码时，这里是我们进入最重要的部分之一。如果我们只能记住一件事，那就会是这件事。我们可能会经常谈论其他开发者定义的规则、面向对象原则和清洁代码原则，但没有什么会比我们即将讨论的内容更好：这是关于意识到你的情境。许多关于清洁代码的书籍和文章中缺少的是这种感觉，即它与日常生活相关。开发者的生活由意外事件、技术约束、无法完成某些事情或被迫做某些其他事情组成。
- en: There are as many ways of doing things as there are projects. Each project has
    its own history, technical decisions, and constraints. As a result, we end up
    with many theoretical principles that are not applicable or that would break the
    coherence of the project. Good practices may dictate how you name variables, how
    you name your classes and methods, how you name your files, or how you make up
    the tree structure of your project. However, what if this goes against what has
    been set up in the project? This is a problem that arises very regularly, especially
    on so-called “legacy” projects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 做事情的方式和项目一样多。每个项目都有其自己的历史、技术决策和约束。因此，我们最终得到了许多理论原则，这些原则可能不适用，或者会破坏项目的连贯性。良好的实践可能会指导你如何命名变量、如何命名你的类和方法、如何命名你的文件，或者如何构建你的项目树结构。然而，如果这与项目中的设置相矛盾怎么办？这是一个非常常见的问题，尤其是在所谓的“遗留”项目中。
- en: 'The answer is both simple and complicated. It is simple because it can be summed
    up in one sentence: discuss it with your team and the other people working on
    the project. This is where the answer can become complicated because it will most
    likely start debates (sometimes heated) within the team, and this is quite normal.
    But the important thing is this: you must not only find a common ground that everyone
    will respect to be consistent with the project, but also find ways that work best
    for you and your team.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 答案既简单又复杂。它之所以简单，是因为可以总结为一句话：与你的团队和其他参与项目的人讨论。这也是答案可能变得复杂的地方，因为它很可能会在团队中引发辩论（有时是热烈的），这是很正常的。但重要的是：你不仅要找到一个大家都会尊重的共识以保持与项目的连贯性，还要找到对你和你的团队最有效的方法。
- en: 'This may be the cornerstone of all these discussions: you may have good practices
    and clean-code principles, but maybe some rules are worth bending because it just
    works better for you and your team. This is a perfectly valid reason to deviate
    from certain principles (not all of them, of course, otherwise it is total anarchy).
    Sometimes, no common ground will be found, and that’s when best practices and
    other principles can prevail in dictating a rule that everyone will have to follow,
    if not one that works for everyone.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是所有这些讨论的基础：你可能有一些良好实践和清洁代码原则，但也许有些规则值得调整，因为它们对你和你的团队来说效果更好。这是偏离某些原则（当然不是所有原则，否则就是完全的无政府状态）的一个完全合理的理由。有时，找不到共识，这时最佳实践和其他原则可以占上风，制定出每个人都必须遵守的规则，如果不是对每个人都适用的规则。
- en: And that is when we come back to a point made earlier. Having common rules in
    a team of developers helps to make it easier to be understood. Navigating through
    the project is easier, as is navigating through files. By all speaking the same
    language, we understand each other better. Whether it is helping someone or being
    helped, it is always the same story. If common naming and indentation rules are
    respected, not only do you avoid sterile debates that would distract you from
    your initial goal, but if you feel that the code written by your teammate is written
    by you, it is a win-win.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，我们回到了之前提到的一个观点。在开发者团队中拥有共同规则有助于使项目更容易理解。在项目中的导航，以及文件中的导航都变得更简单。通过使用相同的语言，我们更好地理解彼此。无论是帮助他人还是被他人帮助，总是同一个故事。如果遵守了共同的命名和缩进规则，你不仅可以避免那些会分散你注意力、远离最初目标的枯燥辩论，而且如果你觉得你的队友编写的代码就像你自己的代码一样，那将是一个双赢的局面。
- en: 'We can summarize the choice of deciding on good practice and “classic” principles
    of clean code in this way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样总结决定采用良好实践和“经典”清洁代码原则的选择：
- en: Has your situation already occurred in the past in the project?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你的情况在项目过去是否已经出现过？
- en: '*Yes*. Does it respect the principles of clean code and the good practices
    dictated by the tools you use (such as *Symfony*’s good practices)?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是的*。它是否遵循了你使用的工具（如 *Symfony* 的良好实践）所规定的清洁代码原则和良好实践？'
- en: '*Yes*. In this case, you just have to follow the way the situation has been
    handled in the past.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是的*。在这种情况下，你只需要遵循过去处理这种情况的方式。'
- en: '*No*. You should talk to your team to find out why. There may be historical
    reasons due to functional and/or technical constraints, or maybe there is no reason
    at all. In this case, if you agree, you can follow the good practices (and even
    update the other parts of the code concerned if you have the possibility, and
    the time, to respect the “Scouts’ principle” we discussed earlier, in the previous
    section).'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不*。你应该与你的团队交谈，找出原因。可能由于功能和/或技术限制存在历史原因，或者可能根本没有任何原因。在这种情况下，如果你同意，你可以遵循良好的实践（如果你有修改相关代码部分的可能性，并且有时间，可以尊重我们之前讨论的“童子军原则”），。'
- en: '*No*. Is it possible to apply good practices and clean-code principles?'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不*。是否可以应用良好实践和清洁代码原则？'
- en: '*Yes*. Perfect! All you have to do is apply them to the best of your ability,
    in accordance with the other practices in place within the team and the project.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是的*。太完美了！你只需要尽你所能将它们应用到团队和项目中现有的其他实践之中。'
- en: '*No*. In this case, you should discuss it with your team, but perhaps also
    discuss it with people outside the project who have had this case. Again, these
    discussions can take quite a long time, and an answer will not always be found
    immediately. Debates will be raised, for the better. Once you have found a consensus
    or discussed it at length, you can either rethink the application of clean-code
    principles and good practices or apply rules that have been set up with the team
    for this kind of situation.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不*。在这种情况下，你应该与你的团队讨论，也许还应该与项目外有类似经验的人讨论。再次，这些讨论可能需要相当长的时间，而且答案不会总是立即找到。辩论将会被提出，这将是件好事。一旦你找到了共识或进行了深入的讨论，你既可以重新思考清洁代码原则和良好实践的应用，也可以应用团队为这种情况设定的规则。'
- en: 'Here, we see very clearly, once again, that the key to success will be communication
    and debate. Everyone has their own point of view and approach to the problem,
    so it is never all black and white. But keep one thing in mind: you should avoid
    making decisions alone about a practice that could be debated. Avoiding making
    a decision alone does not mean you should not make one. Rather, what we mean by
    this is to think through the options, weighing up the pros and cons of each. And
    again, *be able to justify each proposal* you offer to the other people working
    on the project. You can be sure that you will be highly appreciated by your team
    if you offer several solutions to the problems with a good justification of why
    these solutions are appropriate, but also the risks that these solutions entail.
    You will quickly realize that this work can be complicated to do alone, hence
    the importance of discussing it with your team. Each brain has its own way of
    working.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次非常清楚地看到，成功的关键将是沟通和辩论。每个人都有自己的观点和解决问题的方法，所以事情永远不会是全黑或全白。但请记住一点：你应该避免就一个可能被辩论的实践单独做出决定。避免单独做出决定并不意味着你不应该做出决定。相反，我们这里的含义是思考选项，权衡每个选项的利弊。再次，*能够为每个你提出的建议提供合理的依据*给项目中的其他人。如果你提供几个解决方案，并很好地解释为什么这些解决方案是合适的，同时也解释了这些解决方案所涉及的风险，你将很快意识到这项工作单独做可能会很复杂，因此与团队讨论其重要性。每个大脑都有其独特的工作方式。
- en: 'By the way, all this does not only apply to IT, clean code, and PHP. That is
    why it was mentioned in the previous chapter that clean code is not just a set
    of rules: it is a way of being—it is a mindset.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这一切不仅适用于IT、清洁代码和PHP。这就是为什么在上一章中提到，清洁代码不仅仅是一套规则：它是一种生活方式——它是一种思维方式。
- en: Being consistent – get results quicker
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持一致性——更快地获得结果
- en: 'Being perfectly consistent in what you do will force you to understand what
    you are doing. Then, everything will become a habit. If you have these good habits
    to the point that they have become natural to you, results will come faster in
    two specific cases, as outlined here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在你所做的事情上保持完美的一致性将迫使你理解你在做什么。然后，一切都将变成习惯。如果你有这些良好的习惯，以至于它们对你来说已经变得自然，那么在以下两种具体情况下，结果将会更快地到来，如下所述：
- en: 'As we have seen from the beginning, you will be able to understand each other
    much faster within your team—developers will have the same habits. More rarely,
    but it can happen: you will sometimes have to discuss code or show things to non-technical
    people in your project. Although these people—such as a product owner, for example—may
    have some basic technical knowledge, it is best to assume that you will need to
    go back to the most basic basics. You will have a much easier time explaining
    a complex and technical subject to someone non-technical if you have done things
    simply, cleanly, and without hesitation in your work.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们从一开始就能看到的，你将能够更快地在团队内部相互理解——开发者将拥有相同的习惯。更少的情况下，但这种情况可能发生：你有时可能需要与项目中的非技术人员讨论代码或展示事物。尽管这些人——例如产品负责人——可能有一些基本的技术知识，但最好假设你需要回到最基本的基本知识。如果你在工作中的事情简单、干净、毫不犹豫，你将更容易向非技术人员解释复杂和技术的主题。
- en: The second case is during automated checks. Automated checks are tasks that
    have been set up and discussed with the team and that are executed every time
    you want to propose changes. These checks can take place in several places. It
    can be in your software to write code (IDEs such as NetBeans, PhpStorm, or **Visual
    Studio Code** (**VS Code**)), through **continuous integration** (**CI**) tools
    (GitHub Actions, GitLab CI/CD), and so on.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是在自动化检查期间。自动化检查是已经与团队设置和讨论过的任务，每次你想提出更改时都会执行。这些检查可以在多个地方进行。它可能是在你编写代码的软件中（如NetBeans、PhpStorm或**Visual
    Studio Code**（**VS Code**）），通过**持续集成**（**CI**）工具（GitHub Actions、GitLab CI/CD）等。
- en: 'Automated auditing tasks can include absolutely any task you want. We will
    go into more detail on how to perform these tasks as soon as [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084)*,*
    *Code Quality Tools,* of this book (in the *Code quality tools* section), but
    here are the most common ones:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自动审计任务可以包括你想要的任何任务。我们将在本书的*第7章*（*代码质量工具*部分）中详细介绍如何执行这些任务（[第7章](B19050_07.xhtml#_idTextAnchor084)*,*
    *代码质量工具*），但这里是最常见的几个：
- en: Check code style and indentation
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码样式和缩进
- en: Run test suites (unit, functional…)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试套件（单元测试、功能测试…）
- en: Run a static analysis of your code to make sure that the variables you use are
    well defined, that they use the right types, and so on
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的代码进行静态分析，以确保你使用的变量定义良好，使用正确的类型等
- en: Set up alerts to notify you of the success or failure of tasks through a chosen
    channel (email, instant messaging such as Slack, and so on)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择一个渠道（如电子邮件、即时消息如Slack等）设置警报，以通知你任务的成功或失败
- en: Deploy to a test environment
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码部署到测试环境
- en: Install dependencies and vendors
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖和供应商
- en: Copy files to the server and do some remote operations
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件复制到服务器并进行一些远程操作
- en: Whatever you want!
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你想要什么！
- en: You get it. These tools allow you to perform the tasks you want and need. In
    reality, they are just orchestrators that will play the commands you define. It
    is as simple as that. After that, if your commands are complex, it is another
    story. But you realize how infinite these automated checks can be.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白了。这些工具允许你执行你想要和需要的任务。实际上，它们只是执行你定义的命令的协调者。就这么简单。之后，如果你的命令很复杂，那就另当别论了。但你意识到这些自动化检查可以无限扩展。
- en: About source code analysis tools
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于源代码分析工具
- en: By having good code habits, you will definitely speed up the process. Perhaps
    the most telling and concrete example of this is style-code checking. If you do
    not know how to write code in your team and your team has put automatic checks
    on it for everything you want to change, you may spend hours figuring out that
    a space was missing in one place, a line break in another, and so on. Do not worry—most
    tools offer options to correct these errors automatically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过养成良好的代码习惯，你肯定会加快这个过程。也许最具体和有说服力的例子是样式代码检查。如果你不知道如何在你的团队中编写代码，并且你的团队对你想要更改的每一项内容都设置了自动检查，你可能会花几个小时来找出一个地方缺少了一个空格，另一个地方缺少了一个换行符，等等。不用担心——大多数工具都提供自动纠正这些错误的选择。
- en: 'However, this is not the case with static analysis tools, such as the ones
    we’re going to set up in the section dedicated to static analysis tools in [*Chapter
    7*](B19050_07.xhtml#_idTextAnchor084)*, Code Quality Tools*. In fact, a static
    analysis will review your code and make sure that the most common errors are not
    made. We are not talking about checking the number of spaces in your tabs, but
    really parsing the PHP to try to understand it and make sure everything is in
    order. These tools can be a bit too strict at times, and it can take a lot of
    time to understand them properly. Also, these tools are not perfect, and the static
    analysis tool may not be able to understand what you want to do. Although this
    is a separate issue, you will save yourself a lot of trouble if you deal with
    it at the source: develop good coding habits. Be thorough and do not leave anything
    to chance. PHP is a very lax language that allows you to do just about anything
    with variables—for example, allowing you to typecast without flinching. As we
    know, the results of this kind of operation can be random, even very surprising,
    and may seem completely illogical. Anyway, PHP is what it is. Although static
    analysis tools can spot these risky cases most of the time, you may spend hours
    correcting these small things that can number in the dozens very quickly.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，静态分析工具的情况并非如此，例如我们将在关于静态分析工具的章节中设置的工具，[第7章](B19050_07.xhtml#_idTextAnchor084)*代码质量工具*。实际上，静态分析将审查你的代码，并确保不会犯最常见的错误。我们不是在检查你的制表符中的空格数量，而是在真正解析PHP代码，试图理解它并确保一切井然有序。这些工具有时可能会过于严格，正确理解它们可能需要花费大量时间。此外，这些工具并不完美，静态分析工具可能无法理解你的意图。尽管这是一个单独的问题，但如果你在源头处理它，你会省去很多麻烦：培养良好的编码习惯。要彻底，不要留下任何侥幸心理。PHP是一种非常宽松的语言，允许你用变量做几乎所有的事情——例如，允许你在不皱眉的情况下进行类型转换。正如我们所知，这类操作的结果可能是随机的，甚至非常令人惊讶，看起来完全不合逻辑。无论如何，PHP就是PHP。尽管静态分析工具大多数时候可以识别这些风险案例，但你可能需要花费数小时来纠正这些可能迅速增加到数十的小问题。
- en: Also (and this may sound silly), the cleaner you code by implementing clean
    code practices and what follows, the fewer bugs you implement. By being sure of
    yourself, you save yourself a lot of scares. Moreover, you allow the next developers
    who will pass over your code not to be fooled too and make their passage easier.
    If you are lucky enough (or if you have applied the principles of clean code and
    what goes around it!), you will have tests that ensure the proper functioning
    of the application. Maybe you are not familiar with tests, so let’s go through
    this together.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外（这可能听起来很傻），通过实施清洁代码实践和随之而来的内容，你的代码越干净，你实现的错误就越少。通过自信，你可以避免很多惊吓。此外，你还允许未来的开发者在你代码上工作时不会受到欺骗，并使他们的工作更容易。如果你足够幸运（或者如果你已经应用了清洁代码及其相关原则！），你将拥有确保应用程序正确运行的测试。也许你对测试不太熟悉，所以让我们一起来了解一下。
- en: About testing and its multiple forms
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于测试及其多种形式
- en: 'Tests are mostly lines of code written by the developers. These tests make
    sure that for some input data, a specific output is returned. These **inputs and
    outputs** (**I/Os**) can be of diverse types and sizes. It can be an integer as
    well as a generated HTML page or even an image. To make things easier and to simplify
    the concept, automated tests are generally grouped into three main families, as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测试主要是开发者编写的代码行。这些测试确保对于某些输入数据，会返回特定的输出。这些**输入和输出**（**I/Os**）可以是各种类型和大小。它可以是一个整数，也可以是一个生成的HTML页面，甚至是一张图片。为了使事情更容易，并简化概念，自动化测试通常被分为三个主要类别，如下所示：
- en: Unit tests, which are the tests with the finest granularity. They generally
    assess the return of the methods in the code while ignoring everything that surrounds
    them. What matters is the result returned by the function, and that’s all.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，这是粒度最细的测试。它们通常评估代码中方法的返回值，而忽略它们周围的一切。重要的是函数返回的结果，仅此而已。
- en: 'Functional tests have a medium granularity. They will assess full-fledged functionalities,
    where several parties and methods can be involved. The most obvious example is
    the testing of an **application programming interface** (**API**): we check that
    if we call a specific **Uniform Resource Locator** (**URL**) with specific parameters
    in the request, the API returns the expected result.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试具有中等粒度。它们将评估完整的功能，其中可能涉及多个参与方和方法。最明显的例子是对**应用程序编程接口**（**API**）的测试：我们检查如果我们用特定的参数调用一个特定的**统一资源定位符**（**URL**），API是否会返回预期的结果。
- en: '**End-to-end** (**E2E**) tests are the most complex to maintain. These tests
    will mostly simulate a web browser, controlled automatically. A classic example
    is the test of a login form. A robot will automatically fill in the fields, click
    on the button, make sure that we are redirected and that a success message is
    present on the HTML page, and so on.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端**（**E2E**）测试是最难维护的。这些测试通常会模拟一个网络浏览器，并由自动控制。一个经典的例子是登录表单的测试。机器人会自动填写字段，点击按钮，确保我们被重定向并且HTML页面上有成功消息，等等。'
- en: 'All these tests exist for a specific reason: non-regression.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试都存在一个特定的原因：非回归。
- en: Non-regression testing is without a doubt the thing that will save your position
    as a developer in a company. Alright—maybe that is a bit of an exaggeration. However,
    we cannot count the number of applications that have been saved thanks to it.
    When your test coverage is good enough (the proportion of lines of code and features
    covered by one or more tests), you can modify almost anything and be sure to never
    break anything if the tests are always *green*. Indeed, you can break features
    to rewrite them differently and test new ways of doing things. As long as the
    tests are green, you can be sure that the application behaves correctly, as it
    did before your modifications. Of course, several things come into play.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 没有疑问，非回归测试是能保住你在公司中作为开发者的位置的事情。好吧——这可能有点夸张。然而，我们不能统计有多少应用程序得益于它。当你的测试覆盖率足够高（被一个或多个测试覆盖的代码行和特性的比例）时，你几乎可以修改任何东西，并且如果测试总是*绿色*的，你就可以确信永远不会破坏任何东西。确实，你可以打破特性以用不同的方式重写它们并测试新的做事方式。只要测试是绿色的，你就可以确信应用程序的行为是正确的，就像你修改之前一样。当然，还有其他一些因素需要考虑。
- en: First, the tests have to test something. This may sound strange, but in fact,
    you end up with a lot of tests that do not actually assess anything. The most
    typical example is the unit tests on the setters and getters of a class. When
    you write tests for that, you are assessing that a variable assignment has been
    done and that a method call has been done. You are testing... PHP! And PHP already
    has its own tests. Writing relevant tests is a book in itself and is an art that
    can be mastered and refined over the years. And for that, there is nothing like
    practice—again and again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，测试必须测试某些东西。这听起来可能有些奇怪，但实际上，你最终会得到很多实际上并没有评估任何东西的测试。最典型的例子是一个类中设置器和获取器的单元测试。当你为这些编写测试时，你是在评估一个变量赋值是否完成以及一个方法调用是否完成。你是在测试...
    PHP！而PHP已经有了自己的测试。编写相关的测试本身就是一本大书，并且是一种可以在多年中掌握和精炼的艺术。为此，没有什么比反复练习更好的了。
- en: 'The second thing to consider when you modify an application is simply that
    the tests you have set up are no longer up to date and must be modified. Sometimes,
    it can be difficult to understand whether a test fails voluntarily (that is, it
    becomes incompatible with your changes) or involuntarily (because the application
    does not behave the same way as before when it should). It depends entirely on
    your case. Remember one thing: if your application is tested correctly, you can
    change any line of code and deploy your application with your eyes closed, at
    any time, and without hesitation. Pretty interesting, isn’t it?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改应用程序时，需要考虑的第二件事是，你设置的测试已经不再是最新的，必须进行修改。有时，可能很难理解一个测试是自愿失败（即，它与你的更改不兼容）还是无意中失败（因为当它应该以与之前相同的方式表现时，应用程序没有这样做）。这完全取决于你的情况。记住一件事：如果你的应用程序被正确测试，你可以在任何时候，毫不犹豫地更改任何代码行并部署你的应用程序，即使闭上眼睛也可以。这很令人感兴趣，不是吗？
- en: 'Now that you see the benefit of tests in your application, we can discuss a
    practice that is quite common in the practice of clean code. You may have already
    heard of it: TDD.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了测试在你应用程序中的好处，我们可以讨论一个在清洁代码实践中相当常见的做法。你可能已经听说过它：TDD（测试驱动开发）。
- en: '**TDD** stands for **test-driven development**. It is a methodology that consists
    of writing tests before writing the rest of the code. At first, it is very confusing.
    It is complicated to understand how it happens, or even how it is possible. It
    is about thinking backward and questioning our thinking habits, yet the principle
    is quite trivial. First, we think about the tests—that is, the data we are going
    to send (to our methods in unit tests, to an API endpoint in the case of functional
    tests, and so on), as well as the output we want (a precise object or value in
    unit tests; a precise **JavaScript Object Notation** (**JSON**) return, for example,
    in the case of an API functional test). Obviously, and because you have not written
    the rest of the code yet, all tests fail. This is intentional. The goal is now
    to make these tests go green one by one.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**TDD**代表**测试驱动开发**。这是一种在编写其余代码之前先编写测试的方法。一开始，它非常令人困惑。理解它是如何发生的，甚至是否可能，都很复杂。它涉及到逆向思考和质疑我们的思维习惯，尽管原则本身相当简单。首先，我们考虑测试——也就是说，我们将要发送的数据（到单元测试中的方法，到功能测试中的API端点等），以及我们想要的输出（单元测试中的精确对象或值；例如，在API功能测试中的精确**JavaScript对象表示法**（**JSON**）返回值）。显然，因为你还没有编写其余的代码，所以所有测试都会失败。这是故意的。现在的目标是让这些测试一个接一个地变为绿色。'
- en: If you try this practice, you will realize that a kind of magic happens without
    even realizing it. You will organize your code in a way that you would never have
    done at first. It will be cut up in a clear and precise way so that your tests
    can pass as quickly and easily as possible. In addition to the exceptional intellectual
    satisfaction that will result, you will end up with instantly more readable and
    cleaner code. Also (and contrary to widespread belief and intuition), developments
    will be much faster. There is indeed a period of adaptation for it to become quite
    natural, and you may have the impression of being awfully slow at first. However,
    thanks to this, your code is simpler and therefore faster to write, understand,
    adapt, and extend. You have to try it to experience this, as it may sound a bit
    miraculous. And it really is in some way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这种实践，你会意识到一种魔法般的事情在不经意间发生了。你会以你最初绝不会这样做的方式组织你的代码。它将被切割成清晰而精确的方式，以便你的测试可以尽可能快、尽可能容易地通过。除了将带来的非凡的智力满足感之外，你最终会得到更易于阅读和更干净的代码。而且（与普遍的信念和直觉相反），开发速度会更快。确实有一个适应期，让它变得相当自然，你可能会觉得一开始进展非常缓慢。然而，正因为如此，你的代码更简单，因此编写、理解、适应和扩展的速度更快。你必须尝试它来体验这一点，因为它听起来可能有点神奇。实际上，它确实在某些方面是神奇的。
- en: 'Moreover, the code coverage becomes increasingly extensive as you develop.
    This has a direct impact on the maintenance of your application, as we said before:
    you will be much more confident in amending your code, as well as all the people
    who will have to read and modify it. The tests will be there to protect you. As
    a bonus, reading tests can be invaluable in getting into complex code. By reading
    the tests, you can understand from the I/Os given where the developer writing
    the tests was going. This is priceless in the vast majority of applications, especially
    legacy ones. Also, a lot of developers are looking at tests in the first place
    when reviewing your code. It is an amazing entry point when getting into someone’s
    change to the code base. See your tests as the one and only way to prove that
    what you just did actually works. This is a reality: most developers sensitive
    to clean code and alike consider tests as the only valuable proof that your changes
    work.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着你的开发，代码覆盖率会越来越广泛。这直接影响了你应用程序的维护，正如我们之前所说的：你将更有信心修改你的代码，以及所有将不得不阅读和修改它的人。测试将保护你。作为额外的好处，阅读测试对于理解复杂代码非常有价值。通过阅读测试，你可以从给定的I/O中了解编写测试的开发者想要去哪里。在大多数应用程序中，尤其是遗留应用程序中，这是无价的。此外，许多开发者在审查你的代码时首先查看测试。当你进入某个代码库的更改时，这是一个惊人的切入点。把你的测试看作是证明你刚刚所做事情真正工作的唯一方式。这是一个现实：大多数对干净代码敏感的开发者认为测试是证明你的更改工作的唯一有价值的证据。
- en: It can be noted, for example, that for most (if not all) open source projects
    such as PHP, you must add tests when you make changes. Whether it’s for adding
    a new feature or fixing a problem, testing will be mandatory, and your changes
    will never be approved without testing. These tests will be, once again, irrefutable
    proof of the behavior of your new feature or that you have indeed fixed the bug
    in question. All this is a lot of work, but with this in place, the code coverage
    becomes huge, and you contribute fully to the stability of the software.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以注意到，对于大多数（如果不是所有）像PHP这样的开源项目，在做出更改时你必须添加测试。无论是添加新功能还是修复问题，测试将是强制性的，你的更改在没有测试的情况下永远不会被批准。这些测试将再次成为你新功能行为或你确实修复了所讨论的bug的不可辩驳的证据。所有这些工作都是很多，但有了这些，代码覆盖率变得巨大，你完全为软件的稳定性做出了贡献。
- en: Testing is invaluable, both for the quality of your code and for the speed with
    which you get results. Thanks to it, you will be consistent, and you will get
    results quicker.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于你代码的质量和获得结果的快速速度都是无价的。多亏了它，你将保持一致性，并且会更快地得到结果。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just seen a lot of new knowledge together. If you understand it, you
    can be sure that you are already a better developer than you were in the previous
    chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚一起学到了很多新知识。如果你理解了它们，你可以确信你已经比上一章的你自己成为一个更好的开发者了。
- en: Knowing the SOLID principles is a real asset in the professional world and in
    industrial-quality projects. Even if each case is different and each project has
    its specificities, these principles have the advantage of being applicable almost
    everywhere, and at least of being very strongly inspired by them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 了解SOLID原则在专业领域和工业级项目中是一项真正的资产。即使每个案例都不同，每个项目都有其特殊性，但这些原则的优势在于几乎适用于任何地方，至少是受到了极大的启发。
- en: 'Keeping in mind the KISS, DRY, and YAGNI principles will allow you to keep
    your feet on the ground and not spread yourself too thin during your next developments.
    They emphasize thinking about the present moment to help prepare for the future,
    rather than thinking about the future to try to adapt to the present moment. You
    should definitely remember this. We don’t know the future constraints that will
    be imposed on us, whether technical or functional, so it makes more sense to think
    about how to make it easier to deal with those constraints rather than guess at
    them. Because let’s face it: we have very little chance of hitting the bull’s
    eye.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住KISS、DRY和YAGNI原则将帮助你保持脚踏实地，在接下来的开发中不要过于分散精力。它们强调思考当下，以帮助为未来做准备，而不是试图适应当下而思考未来。你绝对应该记住这一点。我们不知道未来将对我们施加的技术或功能限制，因此考虑如何使处理这些限制更容易更有意义，而不是猜测它们。因为说实话：我们几乎没有击中靶心的机会。
- en: If you have the opportunity and the possibility, implementing the “Scouts’ principle”
    in a TDD strategy can be more than beneficial and will always be an excellent
    idea. If you have never practiced TDD, and despite the explanations given in this
    chapter, it is quite normal to be completely dubious about its usefulness and—especially—its
    effectiveness. This is normal, and we have all been there. However, the results
    are there, and the various case studies that have been conducted on this subject
    demonstrate this drastically. It might be time to test this way of doing things,
    which is very well seen and appreciated by the seniors of clean code!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有机会和可能性，在TDD策略中实施“童子军原则”可以带来更多的好处，并且始终是一个极好的主意。如果你从未实践过TDD，尽管本章提供了解释，但对其有用性和——尤其是——其有效性感到完全怀疑是很正常的。这是正常的，我们都有过这样的经历。然而，结果就在那里，关于这个主题所进行的各种案例研究都证明了这一点。可能是时候尝试这种做事方式了，这种方式得到了清洁代码资深人士的高度认可和赞赏！
- en: In spite of all this, we must keep in mind that clean code is also about adapting
    to its environment. It is not a question of rewriting the application entirely
    and changing all the habits of the development team under the pretext that someone
    outside the project has decided to do so. You must be aware of your context and
    deal with your environment. You must be able to adapt to the need and to what
    is around you. This is what will make you a good “clean-coder." Remember to communicate
    as much as possible with your team when a change of habit is perceived, and be
    able to justify all your choices. If possible, it will always be good to propose
    several solutions, as well as the advantages and disadvantages of each.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们必须记住，干净代码也关乎适应其环境。这并不是一个完全重写应用程序并改变开发团队所有习惯的问题，理由是项目外的人决定这样做。你必须意识到你的环境，并处理你的环境。你必须能够适应需求和周围的环境。这就是让你成为一个优秀的“干净程序员”的关键。记住，当感知到习惯的改变时，尽可能与你的团队沟通，并能够证明你所有选择。如果可能的话，始终提出几个解决方案，以及每个方案的优缺点。
- en: After all this theory, we can move on to a slightly more practical part. What
    are the ways to write clean code? What is the purpose of code? Although we have
    seen some advanced principles, we should not forget the basics, and we should
    also question what we already know.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些理论之后，我们可以继续进入一个稍微更实用的部分。编写干净代码的方法有哪些？代码的目的是什么？尽管我们已经看到了一些高级原则，但我们不应忘记基础知识，同时也应该质疑我们已知的内容。
