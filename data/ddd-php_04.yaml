- en: Entities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: We've talked about the benefits of trying to first model everything in the Domain
    as a Value Object. But when modeling the Domain, there will probably be situations
    where you'll find that some concept in the Ubiquitous Language demands a thread
    of Identity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了首先将域中的所有内容建模为值对象的益处。但在对域进行建模时，可能会遇到一些情况，你会发现普遍语言中的某些概念需要一条身份线索。
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Clear examples of objects requiring an Identity include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 需要身份的对象的清晰例子包括：
- en: A **person**. A person always has an Identity and it's always the same in terms
    of their name or identification card.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**人**。一个人总是有一个身份，并且他们的名字或身份证在时间上始终相同。
- en: An **order** in an e-commerce system. In such a context, every new order created
    has its own Identity and it's the same over time.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电子商务系统中，一个**订单**。在这种情况下，每个新创建的订单都有自己的身份，并且随着时间的推移保持不变。
- en: 'These concepts have an Identity that endures over time. No matter how many
    times data in the concepts changes, their Identities remain the same. That''s
    what makes them Entities and not Value Objects. In terms of PHP implementation,
    they would be plain old classes. For example, consider the following in the case
    of a person:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念具有随时间持久存在的身份。无论概念中的数据如何变化，它们的身份保持不变。这就是它们是实体而不是值对象的原因。在PHP实现方面，它们将是普通的旧类。例如，考虑以下关于人的情况：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, consider the following in the case of an order:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑以下关于订单的情况：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Objects Vs. Primitive Types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象与原始类型
- en: 'Most of the time, the Identity of an Entity is represented as a primitive type
    — usually a string or an integer. But using a Value Object to represent it has
    more advantages:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，实体的身份以原始类型表示——通常是字符串或整数。但使用值对象来表示它有更多优势：
- en: Value Objects are immutable, so they can't be modified.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象是不可变的，因此不能被修改。
- en: Value Objects are complex types that can have custom behaviors, something which
    primitive types can't have. Take, as an example, **the equality operation**. With
    Value Objects, equality operations can be modeled and encapsulated in their own
    classes, making concepts go from implicit to explicit.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象是具有自定义行为的复杂类型，这是原始类型所不具备的。以**等价操作**为例。使用值对象，等价操作可以建模并封装在自己的类中，使概念从隐式变为显式。
- en: 'Let''s see a possible implementation for `OrderId`, the `Order` Identity that
    has evolved into a Value Object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`OrderId`、`Order`身份（它已演变为值对象）的一个可能的实现：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are different implementations you can consider for implementing the `OrderId`.
    The example shown above is quite simple. As explained in the [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml),
    *Value Objects*, you can make the `__constructor` method private and use static
    factory methods to create new instances. Talk with your team, experiment, and
    agree. Because Entity Identities are not complex Value Objects, our recommendation
    is that you shouldn't worry too much here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现`OrderId`，你可以考虑不同的实现方式。上面显示的例子相当简单。正如[第3章](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml)中解释的，*值对象*，你可以将`__constructor`方法设为私有，并使用静态工厂方法来创建新实例。与你的团队讨论，进行实验，并达成一致。因为实体身份并不复杂，我们的建议是，你在这里不必过于担心。
- en: 'Going back to the `Order`, it''s time to update references to `OrderId`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Order`，是时候更新对`OrderId`的引用了：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our Entity has an Identity modeled using a Value Object. Let's consider different
    ways of creating an `OrderId`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体使用值对象建模了身份。让我们考虑创建`OrderId`的不同方法。
- en: Identity Operation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份操作
- en: 'As stated before, the Identity of an Entity is what defines it. So then, handling
    it is an important aspect of the Entity. There are usually four ways to define
    the Identity of an Entity: the persistence mechanism provides the Identity, a
    client provides the Identity, the application itself provides the Identity, or
    another Bounded Context provides the Identity.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实体的身份定义了它。因此，处理它就是实体的重要方面之一。通常有四种方式来定义实体的身份：持久化机制提供身份，客户端提供身份，应用程序本身提供身份，或者另一个边界上下文提供身份。
- en: Persistence Mechanism Generates Identity
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化机制生成身份
- en: 'Usually, the simplest way of generating the Identity is to delegate it to the
    persistence mechanism, because the vast majority of persistence mechanisms support
    some kind of Identity generation — like MySQL''s `AUTO_INCREMENT` attribute or
    Postgres and Oracle sequences. This, although simple, has a major drawback: we
    won''t have the Identity of the Entity until we persist it. So to some degree,
    if we''re going with persistence mechanism-generated Identities, we''ll couple
    the Identity operation with the underlying persistence store:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成标识符的最简单方法是将它委托给持久化机制，因为绝大多数持久化机制都支持某种类型的标识符生成——比如MySQL的`AUTO_INCREMENT`属性或Postgres和Oracle序列。虽然这很简单，但有一个主要的缺点：我们只有在持久化实体之后才能获得实体的标识符。因此，在某种程度上，如果我们采用由持久化机制生成的标识符，我们将把标识符操作与底层持久化存储耦合起来：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then we might consider this code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可能会考虑以下代码：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you've ever tried to build your own ORM, you've already experienced this
    situation. What's the approach for creating a new Person? If the database is going
    to generate the Identity, do we have to pass it in the constructor? When and where
    is the magic that will update the Person with its Identity? What happens if we
    end up not persisting the Entity?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经尝试构建自己的ORM，你肯定已经经历过这种情况。创建一个新的Person对象的方法是什么？如果数据库将要生成标识符，我们是否需要在构造函数中传递它？何时何地会有魔法更新Person对象的标识符？如果我们最终没有持久化实体，会发生什么？
- en: Surrogate Identity
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理标识符
- en: Sometimes when using an ORM to map Entities to a persistence store, some constraints
    are imposed — for example, Doctrine demands an integer field if an `IDENTITY`
    generator strategy is used. This can conflict with the Domain Model if it requires
    another kind of Identity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用ORM将实体映射到持久化存储时，会施加一些约束——例如，如果使用`IDENTITY`生成策略，Doctrine要求一个整数字段。这可能会与需要另一种类型标识符的领域模型冲突。
- en: 'The simplest way to handle such a situation is by using a [Layer Supertype](http://martinfowler.com/eaaCatalog/layerSupertype.html),
    where the Identity field created for the persistence store is placed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况的最简单方法是通过使用[层超类型](http://martinfowler.com/eaaCatalog/layerSupertype.html)，将用于持久化存储创建的标识符字段放置在其中：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Active Record Vs. Data Mapper for Rich Domain Models
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Active Record与富领域模型的数据映射器
- en: 'Every project always faces the decision of which ORM should be used. There
    are a lot of good ORMs for PHP out there: Doctrine, Propel, Eloquent, Paris, and
    many more.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都会面临选择使用哪种ORM的决定。PHP有很多好的ORM：Doctrine、Propel、Eloquent、Paris等等。
- en: 'Most of them are [Active Record](http://www.martinfowler.com/eaaCatalog/activeRecord.html) implementations.
    An Active Record implementation is fine mostly for CRUD applications, but it''s
    not the ideal solution for Rich Domain Models for the following reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大多数是[Active Record](http://www.martinfowler.com/eaaCatalog/activeRecord.html)实现。Active
    Record实现对于CRUD应用程序来说很好，但它并不是富领域模型的理想解决方案，以下是一些原因：
- en: The Active Record pattern assumes a one-to-one relation between an Entity and
    a database table. So it couples the design of the database to the design of the
    object system**.** And in a Rich Domain Model, sometimes Entities are constructed
    with information that may come from different data sources.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Active Record模式假设实体与数据库表之间存在一对一的关系。因此，它将数据库的设计与对象系统的设计耦合在一起**。**在一个富领域模型中，有时实体是使用可能来自不同数据源的信息构建的。
- en: Advanced things like collections and inheritance are tricky to implement.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合和继承等高级功能实现起来很棘手。
- en: Most of the implementations force the use, through inheritance, of some sort
    of constructions that impose several conventions. This can lead to persistence
    leakage into the Domain Model by coupling the Domain Model with the ORM. The only
    Active Record implementation we've seen that doesn't impose inheriting from a
    base class is `[Castle ActiveRecord](http://docs.castleproject.org/Active%20Record.MainPage.ashx)` from 
    `[Castle Project](http://www.castleproject.org/)`, a .NET framework. While this
    leads to some degree of separation between persistence and Domain concerns in
    the produced Entities, it doesn't decouple the low-level persistence details from
    high-level Domain design.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数实现都强制通过继承使用某种类型的构造，这会强加几个约定。这可能导致通过将领域模型与ORM耦合，将持久性泄漏到领域模型中。我们看到的唯一不强制从基类继承的Active
    Record实现是来自[Castle Project](http://www.castleproject.org/)的[Castle ActiveRecord](http://docs.castleproject.org/Active%20Record.MainPage.ashx)，这是一个.NET框架。虽然这导致在生成的实体中持久性和领域关注点之间有一定的分离，但它并没有将低级持久性细节与高级领域设计解耦。
- en: As mentioned in the previous chapter, currently the best ORM for PHP is [Doctrine ](http://doctrine-project.org),
    which is an implementation of the [Data Mapper pattern](http://www.martinfowler.com/eaaCatalog/dataMapper.html).
    Data Mapper decouples persistence concerns from Domain concerns, leading to persistence-free
    Entities. This makes the tool the best for someone wanting to build a Rich Domain
    Model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，目前 PHP 最好的 ORM 是 [Doctrine](http://doctrine-project.org)，它实现了 [数据映射模式](http://www.martinfowler.com/eaaCatalog/dataMapper.html)。数据映射将持久性关注点与域关注点解耦，导致持久性无实体。这使得该工具成为想要构建丰富域模型的人的最佳选择。
- en: Client Provides Identity
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端提供身份
- en: 'Sometimes, when dealing with certain Domains, the Identities come naturally,
    with the client consuming the Domain Model. This is likely the ideal case, because
    the Identity can be modeled easily. Let''s take a look at the book-selling market:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理某些域时，身份会自然出现，客户端消费域模型。这可能是理想的情况，因为身份可以轻松建模。让我们看看图书销售市场：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/International_Standard_Book_Number):
    The **International Standard Book Number** (**ISBN**) is a unique numeric commercial
    book identifier. An ISBN is assigned to each edition and variation (except re-printings)
    of a book. For example, an e-book, a paperback and a hardcover edition of the
    same book would each have a different ISBN. The ISBN is 13 digits long if assigned
    on or after 1 January 2007, and 10 digits long if assigned before 2007\. The method
    of assigning an ISBN is nation-based and varies from country to country, often
    depending on how large the publishing industry is within a country.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [维基百科](https://en.wikipedia.org/wiki/International_Standard_Book_Number)：**国际标准书号**（ISBN）是一个独特的商业书号。ISBN
    被分配给每本书的每个版本和变体（除了再版）。例如，同一本书的电子书、平装版和精装版将各自有不同的 ISBN。如果是在 2007 年 1 月 1 日或之后分配的，ISBN
    将有 13 位数字，如果是在 2007 年之前分配的，ISBN 将有 10 位数字。分配 ISBN 的方法基于国家，并且各国之间有所不同，通常取决于一个国家内出版业的规模。
- en: 'The cool thing about the ISBN is that it''s already defined in the Domain,
    it''s a valid identifier because it''s unique, and it can be easily validated.
    This is a good example of an Identity provided by the client:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 的好处在于它已经在域中定义了，它是一个有效的标识符，因为它具有唯一性，并且可以轻松验证。这是一个客户端提供的身份的很好例子：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, it''s just a matter of using it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关键在于使用它：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Exercise
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Think about other Domains where Identities are built in and model one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑其他在域中构建身份的域，并对其进行建模。
- en: Application Generates Identity
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序生成身份
- en: If the client can't provide the Identity generally, the preferred way to handle
    the Identity operation is to let the application generate the Identities, usually
    through a UUID. This is our recommended approach in the case that you don't have
    a scenario as shown in the previous section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端不能一般性地提供身份，处理身份操作的首选方式是让应用程序生成身份，通常是通过 UUID。如果你没有前述章节中所示的场景，这是我们推荐的方法。
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/Universally_unique_identifier):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [维基百科](https://en.wikipedia.org/wiki/Universally_unique_identifier)：
- en: The intent of UUIDs is to enable distributed systems to uniquely identify information
    without significant central coordination. In this context the word unique should
    be taken to mean *practically unique* rather than *guaranteed unique*. Since the
    identifiers have a finite size, it is possible for two differing items to share
    the same identifier. This is a form of hash collision. The identifier size and
    generation process need to be selected so as to make this sufficiently improbable
    in practice. Anyone can create a UUID and use it to identify something with reasonable
    confidence that the same identifier will never be unintentionally created by anyone
    to identify something else. Information labeled with  UUIDs can therefore be later
    combined into a single database without needing to resolve identifier (ID) conflicts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: UUID 的目的是使分布式系统能够在不进行重大中央协调的情况下唯一标识信息。在此上下文中，"唯一"一词应理解为"实际上唯一"而不是"保证唯一"。由于标识符具有有限的大小，两个不同的项目可能共享相同的标识符。这是一种哈希冲突的形式。标识符的大小和生成过程需要选择，以便在实际中使这种情况尽可能不可能。任何人都可以创建一个
    UUID 并用它来标识某物，有合理的信心认为相同的标识符不会无意中被其他人用来标识其他事物。因此，带有 UUID 标记的信息可以在以后合并到一个数据库中，而无需解决标识符（ID）冲突。
- en: 'There are several libraries in PHP that generate UUIDs, and they can be found
    at Packagist: [https://packagist.org/search/?q=uuid](https://packagist.org/search/?q=uuid).
    The best recommendation is the one developed by Ben Ramsey at the following  link:
    [https://github.com/ramsey/uuid](https://github.com/ramsey/uuid) because it has
    tons of watchers on GitHub and millions of installations on Packagist.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中有几个库可以生成UUID，它们可以在Packagist上找到：[https://packagist.org/search/?q=uuid](https://packagist.org/search/?q=uuid)。最佳推荐是Ben
    Ramsey在以下链接中开发的版本：[https://github.com/ramsey/uuid](https://github.com/ramsey/uuid)，因为它在GitHub上有大量的关注者，在Packagist上有数百万的安装量。
- en: 'The preferred place to put the creation of the Identity would be inside a Repository
    (we''ll go deeper into this in the [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建标识的最佳位置是在仓库中（我们将在第10章[Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)，*仓库*中进一步探讨这个问题）：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When using Doctrine, we''ll need to create a custom Repository that implements
    such an interface. It will basically create the new Identity and use the `EntityManager`
    in order to persist and delete Entities. A small variation is to put the `nextIdentity`
    implementation into the interface that will become an abstract class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Doctrine时，我们需要创建一个实现该接口的自定义仓库。它基本上会创建新的标识并使用`EntityManager`来持久化和删除实体。一个小变化是将`nextIdentity`实现放入将成为抽象类的接口中：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s quickly review the final implementation of the `OrderId` Value Object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下`OrderId`值对象的最终实现：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main concern about this approach, as you'll see in the following sections,
    is how easy it is to persist Entities that contain Value Objects. However, mapping
    embedded Value Objects that are inside an Entity can be tricky, depending on the
    ORM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种方法的主要担忧，正如你将在以下章节中看到的，是持久化包含值对象的实体有多容易。然而，根据ORM的不同，映射实体内部的嵌入式值对象可能会很棘手。
- en: Other Bounded Context Generates Identity
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他边界上下文生成标识
- en: This is likely the most complex Identity generation strategy because it forces
    a local Entity to be dependent not only on local Bounded Context events, but also
    on external Bounded Contexts events. So in terms of maintenance, the cost would
    be high.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最复杂的标识生成策略，因为它迫使本地实体不仅依赖于本地边界上下文事件，还依赖于外部边界上下文事件。因此，在维护方面，成本会很高。
- en: The other Bounded Context provides an interface to select the Identity from
    the local Entity. It can take some of the exposed properties as its own.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个边界上下文提供了一个接口，用于从本地实体中选择标识。它可以采用一些公开的属性作为自己的属性。
- en: When synchronization is needed between the Entities of the Bounded Contexts,
    it can usually be achieved with an Event-Driven Architecture on each of the Bounded
    Contexts that need to be notified when the original Entity is changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在边界上下文的实体之间进行同步时，通常可以通过在每个需要通知原始实体发生更改的边界上下文中使用事件驱动架构来实现。
- en: Persisting Entities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化实体
- en: 'Currently, as discussed earlier in the chapter, the best tool for saving Entity
    state to a persistent store is Doctrine ORM. Doctrine has several ways to specify
    Entity metadata: by annotations in Entity code, by XML, by YAML, or by plain PHP.
    In this chapter, we''ll discuss in depth why annotations are not the best thing
    to use when mapping Entities.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，正如本章前面所讨论的，将实体状态保存到持久存储的最佳工具是Doctrine ORM。Doctrine有几种指定实体元数据的方式：通过实体代码中的注解、通过XML、通过YAML或通过纯PHP。在本章中，我们将深入讨论为什么在映射实体时使用注解不是最佳选择。
- en: Setting Up Doctrine
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Doctrine
- en: 'First of all, we need to require Doctrine through Composer. At the root folder
    of the project, the command below has to be executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过Composer要求Doctrine。在项目的根目录中，必须执行以下命令：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, these lines will allow you to set up Doctrine:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些行将允许你设置Doctrine：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mapping Entities
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的映射
- en: By default, Doctrine's documentation presents the code examples using annotations.
    So we begin the code example using annotations and discussing why they should
    be avoided whenever possible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Doctrine的文档使用注解来展示代码示例。因此，我们开始使用注解编写代码示例，并讨论为什么在可能的情况下应避免使用注解。
- en: To do so, we'll bring back the `Order` class discussed earlier in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将回顾本章前面讨论过的`Order`类。
- en: Mapping Entities Using Annotated Code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解代码映射实体
- en: When Doctrine was released, a catchy way of showing how to map objects in the
    code examples was by using annotations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当Doctrine发布时，通过在代码示例中使用注解来展示如何映射对象是一种吸引人的方式。
- en: What's an annotation?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是注解？
- en: 'An annotation is a special form of metadata. In PHP, it''s put under source
    code comments. For example, *PHPDocumentor* makes use of annotations to build
    API information, and `PHPUnit` uses some annotations to specify data providers
    or to provide expectations about exceptions thrown by a piece of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是一种特殊的元数据形式。在 PHP 中，它位于源代码注释下。例如，*PHPDocumentor* 使用注释来构建 API 信息，而 `PHPUnit`
    使用一些注释来指定数据提供者或提供关于代码抛出异常的期望：
- en: '`class SumTest extends PHPUnit_Framework_TestCase  {`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`class SumTest extends PHPUnit_Framework_TestCase {`'
- en: '`    /** @dataProvider aMethodName */`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`    /** @dataProvider aMethodName */`'
- en: '`    public function testAddition() {`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`    public function testAddition() {`'
- en: '`        //... `'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`    //...`'
- en: '`    }`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`    }`'
- en: '`}`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'In order to map the `Order` Entity to the persistence store, the source code
    for the `Order` should be modified to add the Doctrine annotations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `Order` 实体映射到持久化存储，应该修改 `Order` 的源代码以添加 Doctrine 注释：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, to persist the Entity to the persistent store, it''s just as easy to
    do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要将实体持久化到持久化存储，只需执行以下操作即可：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At first glance, this code looks simple, and this can be an easy way to specify
    mapping information. But it comes at a cost. What's odd about the final code?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码看起来很简单，这可以是一个指定映射信息的简单方法。但它是有代价的。最终代码有什么奇怪的地方？
- en: First of all, Domain concerns are mixed with Infrastructure concerns. Order
    is a Domain concept, whereas Table, Column, and so on are infrastructure concerns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，领域关注点与基础设施关注点混合在一起。订单是一个领域概念，而表、列等则是基础设施关注点。
- en: As a result, this Entity is tightly coupled to the mapping information specified
    by the annotations in the source code. If the Entity were required to be persisted
    using another Entity manager and with different mapping metadata, this wouldn't
    be possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个实体与源代码中指定的注释映射信息紧密耦合。如果实体需要使用另一个实体管理器和不同的映射元数据来持久化，这将不可能实现。
- en: Annotations tend to lead to side effects and tight coupling, so it would be
    better to not use them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注释往往会引起副作用和紧密耦合，因此最好不用它们。
- en: So what's the best way to specify mapping information? The best way is the one
    that allows you to separate the mapping information from the Entity itself. This
    can be achieved by using XML mapping, YAML mapping, or PHP mapping. In this book,
    we're going to cover XML mapping.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么指定映射信息最好的方法是什么？最好的方法是允许你将映射信息与实体本身分离。这可以通过使用 XML 映射、YAML 映射或 PHP 映射来实现。在这本书中，我们将介绍
    XML 映射。
- en: Mapping Entities Using XML
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 映射映射实体
- en: 'To map the `Order` Entity using the XML mapping, the setup code of Doctrine
    should be altered slightly:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 XML 映射映射 `Order` 实体，需要稍微修改 Doctrine 的设置代码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The mapping file should be created on the path where Doctrine will search for
    the mapping files, and the mapping files should be named after the fully qualified
    class name, replacing the backslashes `\` with dots. Consider the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 映射文件应该创建在 Doctrine 将要搜索映射文件的路劲上，并且映射文件应该以完全限定的类名命名，将反斜杠 `\` 替换为点。考虑以下示例：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding illustration would have the mapping file named like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的映射文件将命名为如下：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Additionally, it''s convenient that all the mapping files use a special XML
    Schema created specially for specifying mapping information:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有映射文件都使用一个专门为指定映射信息而创建的特殊 XML 架构，这很方便：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Mapping Entity Identity
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射实体标识符
- en: Our Identity, `OrderId`, is a Value Object. As seen in the previous chapter,
    there are different approaches for mapping a Value Object using Doctrine, embeddables,
    and custom types. When Value Objects are used as Identities, the best option is
    custom types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标识符，`OrderId`，是一个值对象。正如前一章所看到的，使用 Doctrine、嵌入对象和自定义类型映射值对象有不同的方法。当值对象用作标识符时，最佳选项是自定义类型。
- en: 'An interesting new feature in *Doctrine 2.5* is that it''s now possible to
    use Objects as identifiers for Entities, so long as they implement the magic method
    `__toString()`. So we can add  `__toString` to our Identity Value Objects and
    use them in our mappings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Doctrine 2.5* 中一个有趣的新特性是，现在可以使用对象作为实体的标识符，只要它们实现了 `__toString()` 魔法方法。因此，我们可以将
    `__toString` 添加到我们的标识符值对象中，并在映射中使用它们：'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Check the implementation of the Doctrine custom types. They inherit from `GuidType`,
    so their internal representation will be a UUID. We need to specify the database
    native translation. Then we need to register our custom types before we use them.
    If you need help with these steps, [Custom Mapping Types](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/cookbook/custom-mapping-types.html) is
    a good reference.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Doctrine自定义类型的实现。它们继承自`GuidType`，因此它们的内部表示将是UUID。我们需要指定数据库的本地转换。然后在我们使用它们之前，我们需要注册我们的自定义类型。如果你需要这些步骤的帮助，[自定义映射类型](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/cookbook/custom-mapping-types.html)是一个很好的参考。
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we''ll set up the registration of custom types. Again, we have to update
    our bootstrapping:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置自定义类型的注册。同样，我们必须更新我们的引导过程：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Final Mapping File
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终映射文件
- en: 'With all the changes, we''re finally ready, so let''s take a look at the final
    mapping file. The most interesting detail is to check how the id gets mapped with
    our defined custom type for `OrderId`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些变化，我们终于准备就绪，现在让我们看一下最终的映射文件。最有趣的细节是检查`OrderId`的ID是如何与我们的自定义类型进行映射的：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing Entities
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试实体
- en: It's relatively easy to test Entities, simply because they're plain old PHP
    classes with actions derived from the Domain concept they represent. The focus
    of the test should be the invariants that the Entity protects, because the behavior
    on the Entities will likely be modeled around those invariants.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 测试实体相对简单，因为它们是具有从它们所代表的领域概念派生出的操作的普通PHP类。测试的重点应该是实体所保护的那些不变性，因为实体的行为很可能会围绕这些不变性进行建模。
- en: 'For example, and for the sake of simplicity, suppose a Domain Model for a blog
    is needed. A possible one could be this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了简化，假设需要一个博客的领域模型。一个可能的模型可以是这个：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to test this Domain Model, we must ensure the test covers all the
    `Post` invariants:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个领域模型，我们必须确保测试覆盖了所有的`Post`不变性：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: DateTimes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期时间
- en: 'Because `DateTimes` are widely used in Entities, we think it''s important to
    point out specific approaches on unit testing Entities that have fields with date
    types. Consider that a `Post` is new if it was created within the last 15 days:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DateTimes`在实体中广泛使用，我们认为指出针对具有日期类型字段的实体进行单元测试的具体方法很重要。考虑一下，如果一篇`Post`是在过去15天内创建的，那么它就是新的：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `isNew()` method needs to compare two `DateTimes;` it's a comparison between
    the date when the Post was created and today's date. We compute the difference
    and check if it's less than the specified amount of days. How do we unit test
    the `isNew()` method? As we demonstrated in the implementation, it's difficult
    to reproduce specific flows in our test suites. What options do we have?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNew()`方法需要比较两个`DateTimes`；这是创建`Post`时的日期与今天的日期之间的比较。我们计算差异并检查它是否小于指定的天数。我们如何单元测试`isNew()`方法？正如我们在实现中展示的那样，在测试套件中重现特定的流程是困难的。我们有什么选择？'
- en: Passing All Dates as Parameters
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有日期作为参数传递
- en: 'One possible option could be passing all the dates as parameters when needed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的选择是在需要时将所有日期作为参数传递：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the easiest approach for unit testing purposes. Just pass different
    pairs of dates to test all possible scenarios with 100 percent coverage. However,
    if you consider the client code that''s creating and asking for the `isNew()`
    method result, things don''t look so nice. The resulting code can be a bit weird
    because of always passing today''s `DateTime`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于单元测试来说是最简单的方法。只需传递不同的日期对来测试所有可能的场景，实现100%的覆盖率。然而，如果你考虑创建和请求`isNew()`方法结果的客户端代码，事情看起来就不那么好了。由于总是传递今天的`DateTime`，生成的代码可能有点奇怪：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Test Class
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类
- en: 'Another alternative is to use the Test Class pattern. The idea is to extend
    the `Post` class with a new one that we can manipulate to force specific scenarios.
    This new class is going to be used only for unit testing purposes. The bad news
    is that we have to modify the original `Post` class a bit, extracting some methods
    and changing some fields and methods from `private` to `protected`. Some developers
    may worry about increasing the visibility of class properties just because of
    testing reasons. However, we think that in most cases, it''s worth it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是使用测试类模式。这个想法是扩展`Post`类，创建一个新的类，我们可以操作它来强制特定的场景。这个新类将仅用于单元测试目的。坏消息是我们必须稍微修改原始的`Post`类，提取一些方法，并将一些字段和方法从`private`改为`protected`。一些开发者可能担心仅仅因为测试原因而增加类属性的可见性。然而，我们认为在大多数情况下，这是值得的：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, we''ve extracted the logic for getting today''s date into the
    `today()` method. This way, by applying the Template Method pattern, we can change
    its behavior from a derived class. Something similar happens with the `createdAt`
    method and field. Now they''re protected, so they can be used and overridden in
    derived classes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将获取今天日期的逻辑提取到`today()`方法中。这样，通过应用模板方法模式，我们可以从派生类中改变其行为。类似的情况也发生在`createdAt`方法和字段上。现在它们是受保护的，因此可以在派生类中使用和重写：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With these changes, we can now test our original `Post` class through testing
    `PostTestClass`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们现在可以通过测试`PostTestClass`来测试我们的原始`Post`类：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just one last small detail: with this approach, it''s impossible to achieve
    100 percent coverage on the `Post` class, because the `today()` method is never
    going to be executed. However, it can be covered by other tests.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个小细节：使用这种方法，我们无法在`Post`类上实现100%的覆盖率，因为`today()`方法永远不会被执行。然而，它可以通过其他测试来覆盖。
- en: External Fake
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部模拟
- en: 'Another option is to wrap calls to the `DateTimeImmutable` constructor or named
    constructors using a new class and some static methods. In doing so, we can statically
    change the result of those methods to behave differently based on specific testing
    scenarios:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用新类和一些静态方法包装对`DateTimeImmutable`构造函数或命名构造函数的调用。这样做，我们可以静态地改变这些方法的结果，使其根据特定的测试场景表现出不同的行为：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For getting today''s `DateTime`, we now use a static call to `MyCustomDateTimeBuilder::today()`.
    This class also has some setter methods to fake the result to return in the next
    calls:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取今天的`DateTime`，我们现在使用对`MyCustomDateTimeBuilder::today()`的静态调用。这个类还有一些设置方法，可以在后续调用中模拟返回结果：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The main problem with this approach is it's coupled statically with an object.
    Depending on your use case, it'll also be tricky to create a flexible fake object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是与对象静态耦合。根据您的使用情况，创建一个灵活的模拟对象也会变得很棘手。
- en: Reflection
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: 'You can also use reflection techniques for building a new `Post` class with
    custom dates. Consider [Mimic](https://github.com/keyvanakbary/mimic), a simple
    functional library for object prototyping, data hydration, and data exposition:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用反射技术来构建一个新的`Post`类，并自定义日期。考虑使用[Mimic](https://github.com/keyvanakbary/mimic)，这是一个简单的用于对象原型设计、数据注入和数据展示的功能性库：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Share and Discuss
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分享和讨论
- en: Discuss with your workmates how to properly unit test your Entities with fixed
    `DateTimes` and come up with additional alternatives.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与您的同事讨论如何正确地对具有固定`DateTimes`的实体进行单元测试，并提出额外的替代方案。
- en: 'If you want to know more about testing patterns and approaches, take a look
    at the book *xUnit Test Patterns: Refactoring Test Code* by Gerard Meszaros.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想了解更多关于测试模式和方法的资料，请查看Gerard Meszaros所著的书籍《xUnit Test Patterns: Refactoring
    Test Code》。'
- en: Validation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'Validation is a highly important process in our Domain Model. It checks not
    only for the correctness of attributes, but also for that of entire objects and
    the composition of those objects. Different levels of validation are required
    in order to keep this Model in a valid state. Just because an object consists
    of valid attributes (on a per basis) doesn''t necessarily mean the object (as
    a whole) is valid. And the opposite is true: valid objects don''t necessarily
    equal valid compositions.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是我们领域模型中一个非常重要的过程。它不仅检查属性的正确性，还检查整个对象及其组成的正确性。为了保持模型的有效状态，需要不同级别的验证。仅仅因为一个对象由有效的属性组成（基于每个属性），并不意味着该对象（作为一个整体）是有效的。反之亦然：有效的对象不一定等于有效的组合。
- en: Attribute Validation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性验证
- en: 'Some people understand validation as the process whereby a service validates
    the state of a given object. In this case, the validation conforms to a [Design-by-contract](http://en.wikipedia.org/wiki/Design_by_contract) approach,
    which consists of preconditions, postconditions, and invariants. One such way
    to protect a single attribute is by using [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml), *Value
    Objects*. In order to make our design more flexible for change, we focus only
    on asserting Domain preconditions that must be met. Here, we''ll be using guards
    as an easy way of validating the preconditions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人将验证理解为服务验证给定对象状态的过程。在这种情况下，验证符合[设计-by-合同](http://en.wikipedia.org/wiki/Design_by_contract)方法，该方法包括前置条件、后置条件和不变性。保护单个属性的一种方式是使用[第3章](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml)，*值对象*。为了使我们的设计更灵活，我们只关注断言必须满足的领域前置条件。在这里，我们将使用守卫作为验证前置条件的一种简单方式：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see in the example above, there are four preconditions that must
    be satisfied in order to build a Username Value Object. It:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，为了构建一个用户名值对象，必须满足四个前提条件。它：
- en: Must not be empty
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能为空
- en: Must be at least 5 characters
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须至少5个字符
- en: Must be less than 10 characters
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须少于10个字符
- en: Must follow a format of alphanumeric characters or underscores
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须遵循字母数字字符或下划线的格式
- en: If all the preconditions are met, the attribute will be set and the object will
    be successfully built. Otherwise, an `InvalidArgumentException` will be raised,
    execution will be halted, and the client will be shown an error.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有前提条件都满足，属性将被设置，对象将被成功构建。否则，将抛出`InvalidArgumentException`异常，执行将被终止，并且客户端将显示错误。
- en: Some developers may consider this kind of validation defensive programming.
    However, we're not checking that the input is a string or that nulls are not permitted.
    We can't avoid people using our code incorrectly, but we can control the correctness
    of our Domain state. As seen in the [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml), *Value
    Objects*, validation can help us with security too.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者可能会认为这种验证是防御性编程。然而，我们并没有检查输入是否为字符串或nulls是否不被允许。我们无法避免人们错误地使用我们的代码，但我们可以控制我们的领域状态的正确性。如[第3章](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml)中的*值对象*所示，验证还可以帮助我们提高安全性。
- en: '[Defensive programming](https://en.wikipedia.org/wiki/Defensive_programming) isn''t
    a bad thing. In general, it makes sense when developing components or libraries
    that are going to be used as a third party in other projects. However, when developing
    your own Bounded Context, those extra paranoid checks (nulls, basic types, type
    hinting, and so  on.) can be avoided to increase development speed by relying
    on the coverage of your unit test suite.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[防御性编程](https://en.wikipedia.org/wiki/Defensive_programming)并不是一件坏事。一般来说，当开发将要作为第三方在其他项目中使用的组件或库时，这样做是有意义的。然而，当开发自己的边界上下文时，那些额外的偏执检查（nulls、基本类型、类型提示等）可以通过依赖单元测试套件的覆盖率来避免，从而提高开发速度。'
- en: Entire Object Validation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整个对象验证
- en: There are times when an object composed of valid properties, as a whole, can
    still be deemed invalid. It can be tempting to add this kind of validation to
    the object itself, but generally this is an anti-pattern. Higher-level validation
    changes at a rhythm different than that of the object logic itself. Also, it's
    good practice to separate these responsibilities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个由有效属性组成的对象整体仍然可能被认为是无效的。可能会诱使人们将这种验证添加到对象本身，但通常这并不是一个好的做法。高级别的验证变化节奏与对象逻辑本身不同。此外，将责任分离是良好的实践。
- en: The validation informs the client about any errors that have been found or collects
    the results to be reviewed later, as sometimes we don't want to stop the execution
    at the first sign of trouble.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 验证通知客户端任何已发现的错误，或者收集结果以供稍后审查，因为有时我们不想在出现问题的第一个迹象时就停止执行。
- en: 'An `abstract` and reusable `Validator` could be something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`抽象`且可重用的`Validator`可能如下所示：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As a concrete example, we want to validate an entire `Location` object, composed
    of valid Country, City, and Postcode Value Objects. However, these individual
    values might be in an invalid state at the time of validation. Maybe the city
    doesn''t form part of the country, or maybe the postcode doesn''t follow the city
    format:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们想要验证一个由有效的国家、城市和邮编值对象组成的整个`Location`对象。然而，这些个别值在验证时可能处于无效状态。也许城市不是国家的一部分，或者邮编可能不符合城市格式：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The validator checks the state of the `Location` object in its entirety, analyzing
    the meaning of the relationships between properties:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器检查`Location`对象的整体状态，分析属性之间关系的意义：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once all the properties have been set, we''re able to validate the Entity,
    most likely after some described process. On the surface, it looks as if the Location
    validates itself. However, this isn''t the case. The  `Location` class delegates
    this validation to a concrete validator instance, splitting these two clear responsibilities:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有属性都已设置，我们就能验证实体，这通常是在某个描述的过程之后。表面上看起来，位置似乎是自我验证的。然而，事实并非如此。`Location`类将这种验证委托给一个具体的验证器实例，将这两个清晰的责任分开：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Decoupling Validation Messages
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦验证消息
- en: 'With some minor changes to our existing implementation, we''re able to decouple
    the validation messages from the validator:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对我们现有实现的一些小改动，我们能够将验证消息与验证器解耦：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also need to change the signature of the validation method to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将验证方法的签名更改为以下形式：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Validating Object Compositions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证对象组合
- en: Validating object compositions can be complicated. As such, the preferred way
    of achieving this is through a Domain Service. The service then communicates with
    Repositories in order to retrieve the valid Aggregate. Due to the likely complex
    object graphs that can be created, an Aggregate could be in an intermediate state,
    requiring other Aggregates to be validated beforehand. We can use Domain Events
    to notify other parts of the system that a particular element has been validated.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 验证对象组合可能很复杂。因此，实现这一目标的最佳方式是通过领域服务。然后，该服务与存储库通信，以检索有效的聚合。由于可能创建的复杂对象图，聚合可能处于中间状态，需要先验证其他聚合。我们可以使用领域事件来通知系统的其他部分，特定元素已被验证。
- en: Entities and Domain Events
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和领域事件
- en: 'We''ll explore [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events* in
    future chapters; however, it''s important to highlight that operations performed
    on Entities can fire Domain Events. This approach is used to communicate the Domain
    change to other parts of the Application, or even to other Applications, as you''ll
    see in [Chapter 12](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml), *Integrating
    Bounded Contexts*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中探讨[第6章](607255c5-e619-4398-94bb-484c008472b7.xhtml)，*领域事件*；然而，重要的是要强调，对实体执行的操作可以触发领域事件。这种方法用于将领域变化传达给应用程序的其他部分，或者甚至传达给其他应用程序，正如你将在[第12章](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml)，*集成边界上下文*中看到的：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Domain Events can even be fired when a new instance of our Entity is created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的实体创建新实例时，甚至可以触发领域事件：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wrap-Up
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Some concepts in the Domain demand Identity — that is, changes to their internal
    states don''t change their own unique identities. We''ve seen how modeling Identity
    as a Value Object brings benefits like immutability, in addition to logic for
    operating the Identity itself. We''ve also shown several ways of providing Identity,
    restated in the following pointers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 领域中的一些概念需要身份——也就是说，它们内部状态的变化不会改变它们自己的唯一身份。我们已经看到如何将身份建模为值对象，除了操作身份本身的逻辑外，还能带来不可变等好处。我们还展示了提供身份的几种方法，以下是一些要点：
- en: 'Persistence mechanism: Easy to implement, but you won''t have the Identity
    before persisting the object, which delays and complicates event propagation.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化机制：易于实现，但在持久化对象之前，你将无法获得身份，这会延迟并复杂化事件传播。
- en: 'Surrogate ID: Some ORMs require an extra field on your Entity to map the Identity
    with the persisting mechanism.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理ID：一些ORM要求在实体上添加额外字段，以将身份与持久化机制映射。
- en: 'Provided by the client: Sometimes the Identity fits a Domain concept and you
    can model it inside your Domain.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由客户端提供：有时身份符合领域概念，你可以在领域内部对其进行建模。
- en: 'Generated by the application: You can use a library to generate IDs.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由应用程序生成：你可以使用库来生成ID。
- en: 'Generated by a Bounded Context: Probably the most complex strategy. Other Bounded
    Contexts provide an interface for generating Identities.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由边界上下文生成：这可能是最复杂的策略。其他边界上下文提供了一个生成身份的接口。
- en: 'We''ve seen and discussed Doctrine as a persistence mechanism, we''ve looked
    at the drawbacks of using the Active Record pattern, and finally, we''ve checked
    different levels of Entity validation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到并讨论了Doctrine作为持久化机制，我们研究了使用Active Record模式的缺点，最后，我们检查了实体验证的不同级别：
- en: 'Attribute validation: Check for specifics inside the object state through preconditions,
    postconditions, and invariants.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性验证：通过前置条件、后置条件和不变性检查对象状态中的具体内容。
- en: 'Entire object validation: Look for consistency of an object as a whole. Extracting
    the validation to an external service is a good practice.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个对象验证：寻找对象作为一个整体的一致性。将验证提取到外部服务是一种良好的实践。
- en: 'Object compositions: Complex object compositions could be validated through
    Domain Services. A good way of communicating this to the rest of the application
    is through Domain Events.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象组合：可以通过领域服务验证复杂对象组合。将此传达给应用程序其余部分的好方法是使用领域事件。
